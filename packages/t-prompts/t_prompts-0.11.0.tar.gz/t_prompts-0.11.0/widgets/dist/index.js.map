{
  "version": 3,
  "sources": ["../src/index.ts", "../src/metadata.ts", "../src/transforms/base.ts", "../src/transforms/createChunks.ts", "../src/transforms/typing.ts", "../src/transforms/imageTruncate.ts", "../src/transforms/lineWrap.ts", "../src/transforms/imageHoverPreview.ts", "../src/transforms/boundaries.ts", "../src/components/CodeView.ts", "../src/folding/utils.ts", "../src/folding/controller.ts", "../src/components/WidgetContainer.ts", "../src/renderer.ts", "../src/styles.css", "../src/generated.ts"],
  "sourcesContent": ["/**\n * Jupyter notebook widgets for visualizing t-prompts structures.\n * Phase 0 & 1: Asset de-duplication and minimal static renderer\n */\n\nimport { initWidget } from './renderer';\nimport widgetStyles from './styles.css';\nimport { STYLES_HASH } from './generated';\n\n// Export version matching Python package\nexport const VERSION = '0.9.0-alpha';\n\n// Store widget runtime on window for singleton pattern (Phase 0)\ndeclare global {\n  interface Window {\n    __TPWidget?: {\n      version: string;\n      initWidget: typeof initWidget;\n      stylesInjected: boolean;\n    };\n  }\n}\n\n/**\n * Inject widget styles into the document (once per page)\n */\nfunction injectStyles(): void {\n  // Use hash-based style ID for cache busting\n  const styleId = `tp-widget-styles-${STYLES_HASH}`;\n\n  // Check if this version is already injected\n  // Use querySelector instead of getElementById for reliability across environments\n  if (document.querySelector(`#${styleId}`)) {\n    return;\n  }\n\n  // Remove any old versions of the styles\n  const oldStyles = document.querySelectorAll('[id^=\"tp-widget-styles\"]');\n  oldStyles.forEach(el => el.remove());\n\n  // Inject new styles\n  const styleElement = document.createElement('style');\n  styleElement.id = styleId;\n  styleElement.textContent = widgetStyles;\n  document.head.appendChild(styleElement);\n\n  if (window.__TPWidget) {\n    window.__TPWidget.stylesInjected = true;\n  }\n}\n\n/**\n * Initialize the widget runtime on window (Phase 0 singleton)\n */\nfunction initRuntime(): void {\n  if (!window.__TPWidget) {\n    window.__TPWidget = {\n      version: VERSION,\n      initWidget,\n      stylesInjected: false,\n    };\n  }\n}\n\n/**\n * Auto-initialize all widgets on the page\n */\nfunction autoInit(): void {\n  initRuntime();\n  injectStyles();\n\n  // Find all widget containers and initialize them\n  const containers = document.querySelectorAll('[data-tp-widget]');\n  containers.forEach((container) => {\n    if (container instanceof HTMLElement && !container.dataset.tpInitialized) {\n      initWidget(container);\n      container.dataset.tpInitialized = 'true';\n    }\n  });\n}\n\n// Auto-initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', autoInit);\n} else {\n  autoInit();\n}\n\n// Watch for new widgets being added to the page (for Jupyter dynamic cell rendering)\nif (typeof MutationObserver !== 'undefined') {\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      mutation.addedNodes.forEach((node) => {\n        if (node instanceof HTMLElement) {\n          // Check if this node is a widget container\n          if (node.matches('[data-tp-widget]') && !node.dataset.tpInitialized) {\n            initRuntime();\n            injectStyles();\n            initWidget(node);\n            node.dataset.tpInitialized = 'true';\n          }\n          // Check if this node contains widget containers\n          const widgets = node.querySelectorAll('[data-tp-widget]');\n          widgets.forEach((widget) => {\n            if (widget instanceof HTMLElement && !widget.dataset.tpInitialized) {\n              initRuntime();\n              injectStyles();\n              initWidget(widget);\n              widget.dataset.tpInitialized = 'true';\n            }\n          });\n        }\n      });\n    });\n  });\n\n  // Observe the entire document body for new widgets\n  observer.observe(document.body, {\n    childList: true,\n    subtree: true,\n  });\n}\n\n// Export for manual initialization\nexport { initWidget, injectStyles, initRuntime };\n", "/**\n * Metadata computation and analysis (Phase 1 & 2)\n *\n * These functions analyze widget data and build lookup maps\n * that are view-agnostic and reusable across visualizations.\n */\n\nimport type {\n  WidgetData,\n  WidgetMetadata,\n  PromptData,\n  ElementData,\n  SourceLocationData,\n} from './types';\n\n/**\n * Trim the source prefix from a file path to make it relative\n *\n * @param filepath - The absolute file path\n * @param prefix - The prefix to remove (e.g., project root directory)\n * @returns The relative path, or original path if prefix doesn't match\n *\n * @example\n * trimSourcePrefix('/Users/dev/project/src/main.py', '/Users/dev/project')\n * // Returns: 'src/main.py'\n */\nexport function trimSourcePrefix(filepath: string | null, prefix: string): string | null {\n  if (!filepath) {\n    return null;\n  }\n\n  // Normalize prefix to ensure it ends with a separator\n  const normalizedPrefix = prefix.endsWith('/') ? prefix : prefix + '/';\n\n  // Check if filepath starts with the prefix\n  if (filepath.startsWith(normalizedPrefix)) {\n    return filepath.substring(normalizedPrefix.length);\n  }\n\n  // Also check without trailing slash in case filepath === prefix\n  if (filepath === prefix) {\n    return '.';\n  }\n\n  // Prefix doesn't match - return original path\n  return filepath;\n}\n\n/**\n * Format a source location as a compact string\n *\n * @param location - The source location data\n * @param sourcePrefix - The prefix to trim from filepaths\n * @returns Formatted location string (e.g., \"src/main.py:42\") or null if location not available\n */\nfunction formatSourceLocation(\n  location: SourceLocationData | null | undefined,\n  sourcePrefix: string\n): string | null {\n  if (!location || !location.filename) {\n    return null;\n  }\n\n  // Use filepath if available, otherwise use filename\n  const path = location.filepath || location.filename;\n  const relativePath = trimSourcePrefix(path, sourcePrefix) || path;\n\n  // Add line number if available\n  if (location.line !== null && location.line !== undefined) {\n    return `${relativePath}:${location.line}`;\n  }\n\n  return relativePath;\n}\n\n/**\n * Build a map from element_id to formatted location string by walking the source prompt tree\n *\n * For elements with both source_location and creation_location (nested prompts),\n * the format is: \"source.py:84 (created: other.py:42)\"\n */\nfunction buildElementLocationMap(\n  promptData: PromptData | null,\n  sourcePrefix: string\n): Record<string, string> {\n  const map: Record<string, string> = {};\n\n  if (!promptData) {\n    return map;\n  }\n\n  function walkElements(elements: ElementData[]): void {\n    for (const element of elements) {\n      // Format source_location (where interpolated/used)\n      const sourceLoc = formatSourceLocation(element.source_location, sourcePrefix);\n\n      // Format creation_location (where originally created)\n      const creationLoc = formatSourceLocation(element.creation_location, sourcePrefix);\n\n      // Build location string\n      if (sourceLoc && creationLoc && sourceLoc !== creationLoc) {\n        // Both locations exist and differ (nested prompt case)\n        map[element.id] = `${sourceLoc} (created: ${creationLoc})`;\n      } else if (sourceLoc) {\n        // Just source location\n        map[element.id] = sourceLoc;\n      } else if (creationLoc) {\n        // Just creation location (shouldn't happen normally)\n        map[element.id] = creationLoc;\n      }\n      // If neither exists, no entry in map\n\n      // Recursively process nested elements\n      if (element.children) {\n        walkElements(element.children);\n      }\n    }\n  }\n\n  // Start walking from the root prompt's children\n  walkElements(promptData.children);\n  return map;\n}\n\n/**\n * Build a map from element_id to element_type by walking the source prompt tree\n */\nfunction buildElementTypeMap(promptData: PromptData | null): Record<string, string> {\n  const map: Record<string, string> = {};\n\n  if (!promptData) {\n    return map;\n  }\n\n  function walkElements(elements: ElementData[]): void {\n    for (const element of elements) {\n      map[element.id] = element.type;\n\n      // Recursively process nested elements\n      if (element.children) {\n        walkElements(element.children);\n      }\n    }\n  }\n\n  // Start walking from the root prompt's children\n  walkElements(promptData.children);\n  return map;\n}\n\n/**\n * Compute all widget metadata from widget data.\n * This centralizes all map-building logic and creates view-agnostic metadata\n * that can be reused across different visualizations.\n *\n * @param data - The widget data\n * @returns Metadata containing all computed maps\n */\nexport function computeWidgetMetadata(data: WidgetData): WidgetMetadata {\n  const sourcePrefix = data.config?.sourcePrefix || '';\n\n  return {\n    elementTypeMap: buildElementTypeMap(data.source_prompt || null),\n    elementLocationMap: buildElementLocationMap(data.source_prompt || null, sourcePrefix),\n  };\n}\n", "/**\n * Transform pipeline infrastructure\n *\n * Transforms are pure functions that take state and return modified state.\n * They allow incremental modification of DOM structure and data.\n */\n\nimport type { WidgetData, WidgetMetadata } from '../types';\n\n/**\n * State that flows through the transform pipeline\n */\nexport interface TransformState {\n  // DOM\n  element: HTMLElement;\n  chunks: Map<string, HTMLElement[]>; // chunkId \u2192 array of top-level DOM elements\n\n  // Data\n  data: WidgetData;\n  metadata: WidgetMetadata;\n\n  // Analysis results (built incrementally)\n  // Future: textMapping, lineBreaks, syntaxTree, etc.\n}\n\n/**\n * Transform function signature\n * Takes state, returns modified state\n */\nexport type Transform = (state: TransformState) => TransformState;\n\n/**\n * Chunk ID Utilities\n *\n * Chunks are identified using data-chunk-id attributes rather than HTML IDs.\n * This allows multiple DOM elements to be associated with the same chunk.\n */\n\n/**\n * Get the chunk ID from an element's data-chunk-id attribute\n */\nexport function getChunkId(element: HTMLElement): string | null {\n  return element.getAttribute('data-chunk-id');\n}\n\n/**\n * Copy chunk ID from one element to another\n */\nexport function copyChunkId(fromElement: HTMLElement, toElement: HTMLElement): void {\n  const chunkId = getChunkId(fromElement);\n  if (chunkId) {\n    toElement.setAttribute('data-chunk-id', chunkId);\n  }\n}\n\n/**\n * Add an element to the chunks map for a given chunk ID\n */\nexport function addToChunksMap(\n  chunkId: string,\n  element: HTMLElement,\n  map: Map<string, HTMLElement[]>\n): void {\n  const existing = map.get(chunkId);\n  if (existing) {\n    existing.push(element);\n  } else {\n    map.set(chunkId, [element]);\n  }\n}\n\n/**\n * Remove a specific element from the chunks map for a given chunk ID\n */\nexport function removeFromChunksMap(\n  chunkId: string,\n  element: HTMLElement,\n  map: Map<string, HTMLElement[]>\n): void {\n  const existing = map.get(chunkId);\n  if (existing) {\n    const index = existing.indexOf(element);\n    if (index !== -1) {\n      existing.splice(index, 1);\n    }\n    // Remove the key entirely if array is now empty\n    if (existing.length === 0) {\n      map.delete(chunkId);\n    }\n  }\n}\n\n/**\n * Replace an element in the chunks map with a new element.\n * Only replaces if the old element is actually in the map.\n * Does NOT add new elements if the old element wasn't tracked.\n *\n * This maintains the invariant that only top-level wrapped containers\n * are tracked in the map, not nested containers created during recursive wrapping.\n */\nexport function replaceInChunksMap(\n  oldElement: HTMLElement,\n  newElement: HTMLElement,\n  map: Map<string, HTMLElement[]>\n): void {\n  const chunkId = getChunkId(oldElement);\n  if (!chunkId) return;\n\n  // Check if old element is tracked\n  const existing = map.get(chunkId);\n  if (existing) {\n    const index = existing.indexOf(oldElement);\n    if (index !== -1) {\n      // Replace in the array\n      existing[index] = newElement;\n      return;\n    }\n  }\n\n  // Old element not found in map - do NOT add the new element.\n  // This prevents nested containers from being added to the map during recursive wrapping.\n}\n", "/**\n * Create Chunks Transform\n *\n * Creates initial <span> elements for each chunk and adds them to the DOM.\n * This is the first transform in the pipeline - it builds the raw structure.\n */\n\nimport type { TransformState } from './base';\nimport { addToChunksMap } from './base';\n\n/**\n * Create initial DOM elements for all chunks\n */\nexport function applyTransform_CreateChunks(state: TransformState): TransformState {\n  const { element, chunks, data } = state;\n\n  if (!data.ir?.chunks) {\n    return state;\n  }\n\n  // Process each chunk\n  for (const chunk of data.ir.chunks) {\n    let chunkElement: HTMLElement;\n\n    if (chunk.type === 'TextChunk' && chunk.text !== undefined) {\n      // Text chunk - simple span with text content\n      const span = document.createElement('span');\n      span.setAttribute('data-chunk-id', chunk.id);\n      span.textContent = chunk.text;\n      chunkElement = span;\n    } else if (chunk.type === 'ImageChunk' && chunk.image) {\n      // Image chunk - simple span with text placeholder\n      // (Hover preview can be added via future transform)\n      const imgData = chunk.image;\n      const format = imgData.format || 'PNG';\n      const dataUrl = `data:image/${format.toLowerCase()};base64,${imgData.base64_data}`;\n      const chunkText = `![${format} ${imgData.width}x${imgData.height}](${dataUrl})`;\n\n      const span = document.createElement('span');\n      span.setAttribute('data-chunk-id', chunk.id);\n      span.textContent = chunkText;\n      // Store image data on element for future transforms\n      (span as HTMLElement & { _imageData?: typeof imgData })._imageData = imgData;\n      chunkElement = span;\n    } else {\n      // Unknown chunk type - empty span\n      const span = document.createElement('span');\n      span.setAttribute('data-chunk-id', chunk.id);\n      chunkElement = span;\n    }\n\n    // Add to chunks map\n    addToChunksMap(chunk.id, chunkElement, chunks);\n\n    // Append to DOM\n    element.appendChild(chunkElement);\n  }\n\n  return state;\n}\n", "/**\n * Typing Transform\n *\n * Adds type-based CSS classes to chunks and source location tooltips.\n * This enables semantic coloring and provides developer metadata on hover.\n */\n\nimport type { TransformState } from './base';\n\n/**\n * Add type classes and location tooltips to all chunks\n */\nexport function applyTransform_AddTyping(state: TransformState): TransformState {\n  const { chunks, data, metadata } = state;\n\n  if (!data.ir?.chunks) {\n    return state;\n  }\n\n  for (const chunk of data.ir.chunks) {\n    const elements = chunks.get(chunk.id);\n    if (!elements) continue;\n\n    // Apply typing to all elements for this chunk\n    for (const chunkElement of elements) {\n      // Determine element type and apply CSS class\n      const elementType = metadata.elementTypeMap[chunk.element_id] || 'unknown';\n      chunkElement.className = `tp-chunk-${elementType}`;\n\n      // Add source location as title (hover tooltip) if available\n      const location = metadata.elementLocationMap[chunk.element_id];\n      if (location) {\n        chunkElement.title = location;\n      }\n    }\n  }\n\n  return state;\n}\n", "/**\n * Image Truncate Transform\n *\n * Truncates the base64 data URL in image chunks to a simple \"(...)\".\n * This keeps the text short for better line wrapping and readability,\n * while maintaining the image format and dimensions in the placeholder.\n */\n\nimport type { TransformState } from './base';\nimport type { ImageData } from '../types';\n\n/**\n * Truncate image data URLs in text content\n */\nexport function applyTransform_ImageTruncate(state: TransformState): TransformState {\n  const { chunks } = state;\n\n  // Process all chunks\n  for (const [, chunkElement] of chunks) {\n    // Check if this chunk has image data stored\n    const imageData = (chunkElement as HTMLElement & { _imageData?: ImageData })._imageData;\n    if (!imageData) continue;\n\n    // Truncate the text to remove the long base64 data URL\n    const format = imageData.format || 'PNG';\n    const truncatedText = `![${format} ${imageData.width}x${imageData.height}](...)`;\n    chunkElement.textContent = truncatedText;\n\n    // Remove title attribute - we don't want source location tooltip on images\n    // since they'll have hover preview instead\n    chunkElement.removeAttribute('title');\n  }\n\n  return state;\n}\n", "/**\n * Line Wrap Transform\n *\n * Implements terminal-style fixed-column text wrapping.\n * Wraps text at column boundaries (not word boundaries) and creates\n * a right-leaning tree structure for multi-wrap scenarios.\n */\n\nimport type { TransformState } from './base';\nimport { replaceInChunksMap } from './base';\n\nconst DEFAULT_COLUMN_LIMIT = 100;\n\n/**\n * Copy all data-* attributes from one element to another\n */\nfunction copyDataAttributes(fromElement: HTMLElement, toElement: HTMLElement): void {\n  for (const key in fromElement.dataset) {\n    toElement.dataset[key] = fromElement.dataset[key]!;\n  }\n}\n\n/**\n * Copy classes from one element to another\n */\nfunction copyClasses(fromElement: HTMLElement, toElement: HTMLElement): void {\n  if (fromElement.className) {\n    toElement.className = fromElement.className;\n  }\n}\n\n/**\n * Wrap an element that needs to be split at a column boundary.\n * Creates a container with the first part, a line break, and recursively\n * processes the rest.\n *\n * @param element - The element to wrap\n * @param splitIndex - Character index where to split the text\n * @param columnLimit - Maximum columns per line\n * @param chunks - Chunks map for tracking\n * @returns The new container element\n */\nfunction wrapElement(\n  element: HTMLElement,\n  splitIndex: number,\n  columnLimit: number,\n  chunks: Map<string, HTMLElement[]>\n): HTMLElement {\n  const text = element.textContent || '';\n\n  // Split the text\n  const firstPart = text.substring(0, splitIndex);\n  const remainder = text.substring(splitIndex);\n\n  // Create container that will replace the original element\n  const container = document.createElement('span');\n  copyDataAttributes(element, container);\n  copyClasses(element, container);\n  container.classList.add('tp-wrap-container');\n\n  // Create span for first part (no special classes, just copy originals)\n  const firstSpan = document.createElement('span');\n  copyDataAttributes(element, firstSpan);\n  copyClasses(element, firstSpan);\n  firstSpan.textContent = firstPart;\n\n  // Create line break\n  const lineBreak = document.createElement('br');\n  lineBreak.className = 'tp-wrap-newline';\n\n  // Create span for remainder - only child spans get continuation class, not containers\n  const remainderSpan = document.createElement('span');\n  copyDataAttributes(element, remainderSpan);\n  copyClasses(element, remainderSpan);\n  remainderSpan.textContent = remainder;\n\n  // Check if remainder needs further wrapping\n  if (remainder.length > columnLimit) {\n    // Recursively wrap the remainder\n    const wrappedRemainder = wrapElement(remainderSpan, columnLimit, columnLimit, chunks);\n    // Mark the wrapped remainder as continuation (not the leaf spans)\n    wrappedRemainder.classList.add('tp-wrap-continuation');\n    container.appendChild(firstSpan);\n    container.appendChild(lineBreak);\n    container.appendChild(wrappedRemainder);\n  } else {\n    // No further wrapping needed - mark this leaf span as continuation\n    remainderSpan.classList.add('tp-wrap-continuation');\n    container.appendChild(firstSpan);\n    container.appendChild(lineBreak);\n    container.appendChild(remainderSpan);\n  }\n\n  // Copy special data (like _imageData) from original element to container\n  const elementWithImageData = element as HTMLElement & { _imageData?: any };\n  if (elementWithImageData._imageData) {\n    (container as typeof elementWithImageData)._imageData = elementWithImageData._imageData;\n  }\n\n  return container;\n}\n\n/**\n * Process a single element for wrapping.\n * Returns the element to continue processing from (rightmost child if wrapped).\n */\nfunction processElement(\n  element: HTMLElement,\n  currentColumn: number,\n  columnLimit: number,\n  chunks: Map<string, HTMLElement[]>\n): { nextElement: HTMLElement | null; newColumn: number } {\n  const text = element.textContent || '';\n  const textLength = text.length;\n\n  // Check if this element would exceed the column limit\n  if (currentColumn + textLength > columnLimit) {\n    // Need to wrap\n    const availableColumns = columnLimit - currentColumn;\n    const splitIndex = availableColumns > 0 ? availableColumns : columnLimit;\n\n    // Create wrapped structure\n    const container = wrapElement(element, splitIndex, columnLimit, chunks);\n\n    // Replace in DOM\n    if (element.parentNode) {\n      element.parentNode.replaceChild(container, element);\n    }\n\n    // Replace in chunks map (if this element was tracked)\n    replaceInChunksMap(element, container, chunks);\n\n    // Find the rightmost child (last continuation span)\n    let rightmost = container;\n    while (rightmost.lastElementChild && rightmost.lastElementChild instanceof HTMLElement) {\n      const lastChild = rightmost.lastElementChild;\n      // Skip line breaks\n      if (lastChild.className === 'tp-wrap-newline') {\n        // Check second-to-last child\n        const prevSibling = lastChild.previousElementSibling;\n        if (prevSibling instanceof HTMLElement) {\n          rightmost = prevSibling;\n          break;\n        }\n        break;\n      }\n      rightmost = lastChild;\n    }\n\n    // The rightmost element determines our new column position\n    const rightmostText = rightmost.textContent || '';\n    return { nextElement: rightmost.nextElementSibling as HTMLElement | null, newColumn: rightmostText.length };\n  }\n\n  // No wrapping needed, advance column counter\n  return { nextElement: element.nextElementSibling as HTMLElement | null, newColumn: currentColumn + textLength };\n}\n\n/**\n * Apply line wrapping transform to all elements\n */\nexport function applyTransform_LineWrap(\n  state: TransformState,\n  columnLimit: number = DEFAULT_COLUMN_LIMIT\n): TransformState {\n  const { element, chunks } = state;\n\n  let currentColumn = 0;\n  let currentElement = element.firstElementChild as HTMLElement | null;\n\n  while (currentElement) {\n    // Check if this is a line break element (resets column)\n    if (currentElement.tagName === 'BR') {\n      currentColumn = 0;\n      currentElement = currentElement.nextElementSibling as HTMLElement | null;\n      continue;\n    }\n\n    // Skip non-text elements\n    if (!currentElement.textContent) {\n      currentElement = currentElement.nextElementSibling as HTMLElement | null;\n      continue;\n    }\n\n    // Process this element\n    const result = processElement(currentElement, currentColumn, columnLimit, chunks);\n    currentColumn = result.newColumn;\n    currentElement = result.nextElement;\n  }\n\n  return state;\n}\n\n/**\n * Reverse line wrapping by unwrapping all tp-wrap-container elements\n *\n * This function:\n * 1. Finds all .tp-wrap-container elements\n * 2. Collects all text from children (excluding <br> elements)\n * 3. Replaces container with a single span containing the concatenated text\n * 4. Preserves data attributes and original classes (minus wrap-related ones)\n *\n * @param element - The container element to unwrap within\n * @param chunks - The chunks map to update\n */\nexport function unwrapLineWrapping(element: HTMLElement, chunks: Map<string, HTMLElement[]>): void {\n  // Find all wrap containers (process from deepest to shallowest to handle nested wraps)\n  const containers = Array.from(element.querySelectorAll('.tp-wrap-container'));\n\n  // Process in reverse order to handle nested containers correctly\n  for (let i = containers.length - 1; i >= 0; i--) {\n    const container = containers[i] as HTMLElement;\n\n    // Collect all text from this container (excluding line breaks)\n    let fullText = '';\n    const walker = document.createTreeWalker(\n      container,\n      NodeFilter.SHOW_TEXT,\n      null\n    );\n\n    let node: Node | null;\n    while ((node = walker.nextNode())) {\n      fullText += node.textContent;\n    }\n\n    // Create replacement span with the full text\n    const replacement = document.createElement('span');\n\n    // Copy data attributes from container\n    for (const key in container.dataset) {\n      replacement.dataset[key] = container.dataset[key]!;\n    }\n\n    // Copy classes from container, but remove wrap-related classes\n    const classesToCopy = container.className\n      .split(' ')\n      .filter(c => c !== 'tp-wrap-container' && c !== 'tp-wrap-continuation');\n    replacement.className = classesToCopy.join(' ');\n\n    // Set the text content\n    replacement.textContent = fullText;\n\n    // Copy special data (like _imageData)\n    const containerWithImageData = container as HTMLElement & { _imageData?: any };\n    if (containerWithImageData._imageData) {\n      (replacement as typeof containerWithImageData)._imageData = containerWithImageData._imageData;\n    }\n\n    // Replace in DOM\n    if (container.parentNode) {\n      container.parentNode.replaceChild(replacement, container);\n    }\n\n    // Replace in chunks map (if this container was tracked)\n    replaceInChunksMap(container, replacement, chunks);\n  }\n\n  // Also remove any standalone tp-wrap-continuation classes and tp-wrap-newline elements\n  const continuations = Array.from(element.querySelectorAll('.tp-wrap-continuation'));\n  for (const elem of continuations) {\n    elem.classList.remove('tp-wrap-continuation');\n  }\n\n  const lineBreaks = Array.from(element.querySelectorAll('.tp-wrap-newline'));\n  for (const br of lineBreaks) {\n    br.remove();\n  }\n}\n", "/**\n * Image Hover Preview Transform\n *\n * Adds hover preview functionality for image chunks.\n * Wraps image placeholder text in a container and adds a hidden preview image\n * that appears on hover (via CSS).\n */\n\nimport type { TransformState } from './base';\nimport { copyChunkId, addToChunksMap, removeFromChunksMap } from './base';\nimport type { ImageData } from '../types';\n\n/**\n * Add hover preview support for images\n */\nexport function applyTransform_ImageHoverPreview(state: TransformState): TransformState {\n  const { chunks } = state;\n\n  // Process all chunks - iterate over a copy since we'll be modifying the map\n  for (const [chunkId, elements] of Array.from(chunks.entries())) {\n    // Process each element for this chunk\n    for (const chunkElement of elements) {\n      // Check if this chunk has image data stored\n      const imageData = (chunkElement as HTMLElement & { _imageData?: ImageData })._imageData;\n      if (!imageData) continue;\n\n      // Build data URL for the preview\n      const format = imageData.format || 'PNG';\n      const dataUrl = `data:image/${format.toLowerCase()};base64,${imageData.base64_data}`;\n\n      // Create container span\n      const container = document.createElement('span');\n      container.className = 'tp-chunk-image-container';\n\n      // Copy chunk ID to the new container\n      copyChunkId(chunkElement, container);\n\n      // Copy any existing classes from the chunk element (e.g., tp-chunk-image, type classes)\n      if (chunkElement.className) {\n        container.className += ` ${chunkElement.className}`;\n      }\n\n      // Create text span (no data-chunk-id needed, just for display)\n      const textSpan = document.createElement('span');\n      textSpan.className = 'tp-chunk-image';\n      textSpan.textContent = chunkElement.textContent;\n\n      // Create preview image (hidden by default, shown on hover via CSS)\n      const previewImg = document.createElement('img');\n      previewImg.className = 'tp-chunk-image-preview';\n      previewImg.src = dataUrl;\n      previewImg.alt = `${format} ${imageData.width}x${imageData.height}`;\n\n      // Assemble container\n      container.appendChild(textSpan);\n      container.appendChild(previewImg);\n\n      // Replace original element in DOM\n      if (chunkElement.parentNode) {\n        chunkElement.parentNode.replaceChild(container, chunkElement);\n      }\n\n      // Update chunks map: remove old element, add new container\n      removeFromChunksMap(chunkId, chunkElement, chunks);\n      addToChunksMap(chunkId, container, chunks);\n    }\n  }\n\n  return state;\n}\n", "/**\n * Boundaries Transform\n *\n * Marks first and last chunks of each element with boundary classes.\n * This enables visual boundary indicators (colored bars) in the CSS.\n */\n\nimport type { TransformState } from './base';\n\n/**\n * Mark first and last chunks for each element\n */\nexport function applyTransform_MarkBoundaries(state: TransformState): TransformState {\n  const { chunks, data, metadata } = state;\n\n  if (!data.compiled_ir?.subtree_map) {\n    return state;\n  }\n\n  // Iterate through each element and its chunks\n  for (const [elementId, chunkIds] of Object.entries(data.compiled_ir.subtree_map)) {\n    if (chunkIds.length === 0) {\n      continue;\n    }\n\n    // Get element type for this element\n    const elementType = metadata.elementTypeMap[elementId] || 'unknown';\n\n    // Mark first chunk - get all elements for this chunk\n    const firstChunkId = chunkIds[0];\n    const firstElements = chunks.get(firstChunkId);\n    if (firstElements) {\n      for (const el of firstElements) {\n        el.classList.add(`tp-first-${elementType}`);\n      }\n    }\n\n    // Mark last chunk\n    const lastChunkId = chunkIds[chunkIds.length - 1];\n    const lastElements = chunks.get(lastChunkId);\n    if (lastElements) {\n      for (const el of lastElements) {\n        el.classList.add(`tp-last-${elementType}`);\n      }\n    }\n  }\n\n  return state;\n}\n", "/**\n * Code View Component\n *\n * Renders text output with semantic coloring and element boundaries.\n * Uses a transform pipeline to incrementally build and annotate the DOM.\n */\n\nimport type { Component } from './base';\nimport type { WidgetData, WidgetMetadata } from '../types';\nimport type { TransformState } from '../transforms/base';\nimport { applyTransform_CreateChunks } from '../transforms/createChunks';\nimport { applyTransform_AddTyping } from '../transforms/typing';\nimport { applyTransform_ImageTruncate } from '../transforms/imageTruncate';\nimport { applyTransform_LineWrap } from '../transforms/lineWrap';\nimport { applyTransform_ImageHoverPreview } from '../transforms/imageHoverPreview';\nimport { applyTransform_MarkBoundaries } from '../transforms/boundaries';\nimport type { FoldingController } from '../folding/controller';\nimport type { FoldingEvent, FoldingClient } from '../folding/types';\n\n/**\n * Code view component interface\n */\nexport interface CodeView extends Component {\n  // Text-specific data\n  chunkIdToTopElements: Map<string, HTMLElement[]>; // chunkId \u2192 array of top-level DOM elements\n}\n\n/**\n * Build a CodeView component from widget data and metadata\n *\n * @param data - Widget data containing IR chunks\n * @param metadata - Widget metadata\n * @param foldingController - Folding controller for managing code folding state\n */\nexport function buildCodeView(\n  data: WidgetData,\n  metadata: WidgetMetadata,\n  foldingController: FoldingController\n): CodeView {\n  // 1. Create initial DOM structure\n  const element = document.createElement('div');\n  element.className = 'tp-output-container wrap';\n\n  // 2. Build chunk ID to top-level elements map\n  const chunkIdToTopElements = new Map<string, HTMLElement[]>();\n\n  // 3. Apply transformation pipeline\n  let state: TransformState = { element, chunks: chunkIdToTopElements, data, metadata };\n\n  // Transform pipeline - each function modifies state\n  state = applyTransform_CreateChunks(state);\n  state = applyTransform_AddTyping(state);\n  state = applyTransform_ImageTruncate(state);\n  state = applyTransform_LineWrap(state);\n  state = applyTransform_ImageHoverPreview(state);\n  state = applyTransform_MarkBoundaries(state);\n\n  // Future transforms can be added here:\n  // state = applyTransform_SyntaxHighlighting(state);\n\n  // 4. Selection tracking with debouncing\n  let selectionTimeout: ReturnType<typeof setTimeout> | null = null;\n\n  function handleSelectionChange(): void {\n    if (selectionTimeout) {\n      clearTimeout(selectionTimeout);\n    }\n\n    selectionTimeout = setTimeout(() => {\n      const selectedIds = getSelectedChunkIds();\n\n      if (selectedIds.size > 0) {\n        // Clear existing selections and apply new ones\n        foldingController.clearSelections();\n        foldingController.selectByIds(selectedIds);\n      }\n    }, 100);\n  }\n\n  function getSelectedChunkIds(): Set<string> {\n    const selection = window.getSelection();\n    if (!selection || selection.rangeCount === 0 || selection.isCollapsed) {\n      return new Set();\n    }\n\n    const range = selection.getRangeAt(0);\n\n    // Only process if selection is within our container\n    if (!element.contains(range.commonAncestorContainer)) {\n      return new Set();\n    }\n\n    const selectedIds = new Set<string>();\n\n    // Check each chunk's top-level elements\n    for (const [chunkId, elements] of chunkIdToTopElements) {\n      for (const chunkElement of elements) {\n        // Skip elements that are no longer in the DOM\n        // (This can happen if the map has stale references after unwrap/rewrap)\n        if (!document.contains(chunkElement)) {\n          continue;\n        }\n\n        if (isElementInRange(chunkElement, range)) {\n          selectedIds.add(chunkId);\n          break; // Found one element for this chunk, that's enough\n        }\n      }\n    }\n\n    return selectedIds;\n  }\n\n  function isElementInRange(element: HTMLElement, range: Range): boolean {\n    const elementRange = document.createRange();\n    elementRange.selectNodeContents(element);\n\n    // Check if ranges intersect\n    return (\n      range.compareBoundaryPoints(Range.START_TO_END, elementRange) > 0 &&\n      range.compareBoundaryPoints(Range.END_TO_START, elementRange) < 0\n    );\n  }\n\n  // 5. Keyboard handler for collapse\n  function handleKeyDown(event: KeyboardEvent): void {\n    if (event.key === ' ' && !event.shiftKey && !event.ctrlKey && !event.metaKey) {\n      event.preventDefault();\n      const selections = foldingController.getSelections();\n      if (selections.length > 0) {\n        foldingController.commitSelections();\n      }\n    }\n  }\n\n  // Make element focusable for keyboard events\n  element.tabIndex = 0;\n\n  // 6. Create folding client to respond to controller events\n  const foldingClient: FoldingClient = {\n    onStateChanged(event: FoldingEvent): void {\n      // Handle different event types\n      switch (event.type) {\n        case 'selections-changed':\n          // No visual feedback needed for selections\n          break;\n        case 'chunks-collapsed':\n          handleChunksCollapsed(event.collapsedIds);\n          break;\n        case 'chunk-expanded':\n          handleChunkExpanded(event.expandedId);\n          break;\n        case 'state-reset':\n          handleStateReset();\n          break;\n      }\n    },\n  };\n\n  function handleChunksCollapsed(collapsedIds: string[]): void {\n    // 1. Unwrap line wrapping before making changes\n    // TEMPORARILY COMMENTED OUT FOR TESTING\n    // unwrapLineWrapping(element, chunkIdToTopElements);\n\n    // 2. Process each collapsed chunk\n    for (let i = 0; i < collapsedIds.length; i++) {\n      const collapsedId = collapsedIds[i];\n      const collapsed = foldingController.getCollapsedChunk(collapsedId);\n      if (!collapsed) continue;\n\n      // Count total characters in collapsed children\n      let charCount = 0;\n      let firstElement: HTMLElement | null = null;\n\n      for (const childId of collapsed.children) {\n        const childElements = chunkIdToTopElements.get(childId);\n        if (childElements) {\n          for (const el of childElements) {\n            if (!firstElement) {\n              firstElement = el;\n            }\n            charCount += el.textContent?.length || 0;\n            el.style.display = 'none'; // Hide children\n          }\n        }\n      }\n\n      // Create collapsed chunk span\n      const collapsedSpan = document.createElement('span');\n      collapsedSpan.setAttribute('data-chunk-id', collapsedId);\n      collapsedSpan.className = 'tp-chunk-collapsed';\n      collapsedSpan.textContent = `[${charCount} chars]`;\n      collapsedSpan.title = 'Double-click to expand';\n\n      // Add double-click handler\n      collapsedSpan.addEventListener('dblclick', () => {\n        foldingController.expandChunk(collapsedId);\n      });\n\n      // Insert in DOM before the first child element\n      if (firstElement && firstElement.parentNode) {\n        firstElement.parentNode.insertBefore(collapsedSpan, firstElement);\n      }\n\n      // Track in chunkIdToTopElements map\n      chunkIdToTopElements.set(collapsedId, [collapsedSpan]);\n    }\n\n    // 3. Re-apply line wrapping\n    // TEMPORARILY COMMENTED OUT FOR TESTING\n    // applyTransform_LineWrap({ element, chunks: chunkIdToTopElements, data, metadata });\n\n    // NOTE: Don't cleanup here - hidden children need to stay in the map for expand\n  }\n\n  function handleChunkExpanded(expandedId: string): void {\n    // 1. Unwrap line wrapping before making changes\n    // TEMPORARILY COMMENTED OUT FOR TESTING\n    // unwrapLineWrapping(element, chunkIdToTopElements);\n\n    const collapsed = foldingController.getCollapsedChunk(expandedId);\n    if (!collapsed) return;\n\n    // Find the collapsed span\n    const collapsedElements = chunkIdToTopElements.get(expandedId);\n    if (!collapsedElements || collapsedElements.length === 0) return;\n\n    const collapsedSpan = collapsedElements[0];\n\n    // 2. Show all children's top-level elements\n    for (const childId of collapsed.children) {\n      const childElements = chunkIdToTopElements.get(childId);\n      if (childElements) {\n        for (const el of childElements) {\n          el.style.display = ''; // Restore display\n        }\n      }\n    }\n\n    // Remove collapsed span from DOM and map\n    collapsedSpan.remove();\n    chunkIdToTopElements.delete(expandedId);\n\n    // 3. Re-apply line wrapping\n    // TEMPORARILY COMMENTED OUT FOR TESTING\n    // applyTransform_LineWrap({ element, chunks: chunkIdToTopElements, data, metadata });\n  }\n\n  function handleStateReset(): void {\n    // TODO: Implement state reset handling if needed\n    console.log('State reset');\n  }\n\n  // 7. Add event listeners\n  document.addEventListener('selectionchange', handleSelectionChange);\n  element.addEventListener('keydown', handleKeyDown);\n\n  // 8. Register as client\n  foldingController.addClient(foldingClient);\n\n  // 9. Return component with operations\n  return {\n    element: state.element,\n    chunkIdToTopElements: state.chunkIdToTopElements,\n\n    destroy(): void {\n      // Remove event listeners\n      document.removeEventListener('selectionchange', handleSelectionChange);\n      element.removeEventListener('keydown', handleKeyDown);\n\n      // Clear any pending timeouts\n      if (selectionTimeout) {\n        clearTimeout(selectionTimeout);\n      }\n\n      // Unregister from folding controller\n      foldingController.removeClient(foldingClient);\n\n      // Cleanup DOM and data\n      element.remove();\n      chunkIdToTopElements.clear();\n    },\n  };\n}\n", "/**\n * Utility functions for the folding system\n */\n\n/**\n * Generate a UUID v4\n * Simple implementation for browser environments\n */\nexport function generateUUID(): string {\n  // Use crypto.randomUUID if available (modern browsers)\n  if (typeof crypto !== 'undefined' && crypto.randomUUID) {\n    return crypto.randomUUID();\n  }\n\n  // Fallback implementation\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n", "/**\n * Folding Controller\n *\n * Manages the state of code folding/unfolding and notifies clients of changes.\n * Maintains a linear sequence of visible chunks and tracks collapsed chunks.\n */\n\nimport type {\n  ChunkId,\n  CollapsedChunk,\n  Selection,\n  FoldingState,\n  FoldingEvent,\n  FoldingClient,\n} from './types';\nimport { generateUUID } from './utils';\n\nexport class FoldingController {\n  private state: FoldingState;\n  private clients: Set<FoldingClient>;\n  private indexMap: Map<ChunkId, number>; // ChunkId \u2192 index in visibleSequence\n\n  /**\n   * Create a new folding controller\n   *\n   * @param initialSequence - The initial linear sequence of chunk IDs\n   */\n  constructor(initialSequence: ChunkId[]) {\n    this.state = {\n      visibleSequence: [...initialSequence], // Clone to avoid external mutation\n      collapsedChunks: new Map(),\n      selections: [],\n    };\n    this.clients = new Set();\n    this.indexMap = this.buildIndexMap();\n  }\n\n  // ============================================================================\n  // Core Operations\n  // ============================================================================\n\n  /**\n   * Add a selection range. If it overlaps with existing selections, merge them.\n   *\n   * @param start - Start index in visible sequence\n   * @param end - End index in visible sequence (inclusive)\n   * @throws Error if indices are out of bounds\n   */\n  addSelection(start: number, end: number): void {\n    // Validate indices\n    if (start < 0 || end >= this.state.visibleSequence.length) {\n      throw new Error(\n        `Selection indices out of bounds: [${start}, ${end}] (sequence length: ${this.state.visibleSequence.length})`\n      );\n    }\n\n    if (start > end) {\n      throw new Error(`Invalid selection: start (${start}) must be <= end (${end})`);\n    }\n\n    // Create new selection\n    const newSelection: Selection = { start, end };\n\n    // Find overlapping selections and merge them\n    const merged = this.mergeSelections([...this.state.selections, newSelection]);\n    this.state.selections = merged;\n\n    // Notify clients\n    this.notifyClients({\n      type: 'selections-changed',\n      selections: merged,\n    });\n  }\n\n  /**\n   * Clear all selections\n   */\n  clearSelections(): void {\n    if (this.state.selections.length === 0) {\n      return; // Already cleared\n    }\n\n    this.state.selections = [];\n\n    // Notify clients\n    this.notifyClients({\n      type: 'selections-changed',\n      selections: [],\n    });\n  }\n\n  /**\n   * Select chunks by their IDs in the visible sequence\n   *\n   * Given an iterable of chunk IDs, finds all maximal contiguous ranges\n   * that contain those IDs and adds selections for each range.\n   *\n   * @param chunkIds - Iterable of chunk IDs to select (can include both regular and collapsed chunks)\n   *\n   * @example\n   * // Select chunks by ID\n   * controller.selectByIds(['chunk1', 'chunk2', 'chunk5']);\n   * // If chunk1 and chunk2 are at indices 0,1 and chunk5 is at index 4,\n   * // this creates two selections: [0,1] and [4,4]\n   */\n  selectByIds(chunkIds: Iterable<ChunkId>): void {\n    // 1. Convert input to Set for O(1) lookup\n    const idSet = new Set(chunkIds);\n\n    if (idSet.size === 0) {\n      return; // Nothing to select\n    }\n\n    // 2. Find indices for all valid IDs using cached index map\n    const validIndices: number[] = [];\n    for (const id of idSet) {\n      const index = this.indexMap.get(id);\n      if (index !== undefined) {\n        validIndices.push(index);\n      } else {\n        // Log error for IDs not in visible sequence (logic bug)\n        console.error(`selectByIds: Chunk ID \"${id}\" not found in visible sequence`);\n      }\n    }\n\n    if (validIndices.length === 0) {\n      return; // No valid IDs found\n    }\n\n    // 3. Sort indices and find maximal contiguous ranges\n    validIndices.sort((a, b) => a - b);\n\n    const ranges: Array<[number, number]> = [];\n    let rangeStart = validIndices[0];\n    let rangeEnd = validIndices[0];\n\n    for (let i = 1; i < validIndices.length; i++) {\n      const currentIndex = validIndices[i];\n\n      if (currentIndex === rangeEnd + 1) {\n        // Extend current range\n        rangeEnd = currentIndex;\n      } else {\n        // End current range and start new one\n        ranges.push([rangeStart, rangeEnd]);\n        rangeStart = currentIndex;\n        rangeEnd = currentIndex;\n      }\n    }\n\n    // Don't forget the last range\n    ranges.push([rangeStart, rangeEnd]);\n\n    // 4. Apply each range as a selection\n    for (const [start, end] of ranges) {\n      this.addSelection(start, end);\n    }\n  }\n\n  /**\n   * Commit all current selections as collapsed chunks\n   *\n   * Creates one collapsed chunk for each disjoint selection range.\n   * Processes selections from right to left to maintain correct indices.\n   *\n   * @returns Array of IDs of the newly created collapsed chunks\n   * @throws Error if there are no active selections\n   */\n  commitSelections(): ChunkId[] {\n    if (this.state.selections.length === 0) {\n      throw new Error('Cannot commit: no active selections');\n    }\n\n    // Create array of [selection, originalIndex] to track original order\n    const indexedSelections = this.state.selections.map((sel, idx) => ({ sel, idx }));\n\n    // Sort by start index (descending) to process right-to-left\n    indexedSelections.sort((a, b) => b.sel.start - a.sel.start);\n\n    // Build mapping from original index to collapsed ID\n    const collapsedMap = new Map<number, { id: ChunkId; range: [number, number] }>();\n\n    // Process each selection from right to left\n    for (const { sel, idx } of indexedSelections) {\n      const { start, end } = sel;\n\n      // Extract the selected chunks\n      const selectedChunks = this.state.visibleSequence.slice(start, end + 1);\n\n      // Generate a new collapsed chunk ID\n      const collapsedId = generateUUID();\n\n      // Create the collapsed chunk\n      const collapsedChunk: CollapsedChunk = {\n        id: collapsedId,\n        children: selectedChunks,\n        type: 'collapsed',\n      };\n\n      // Store in collapsed chunks map\n      this.state.collapsedChunks.set(collapsedId, collapsedChunk);\n\n      // Replace the selected range with the collapsed chunk in visible sequence\n      this.state.visibleSequence.splice(start, end - start + 1, collapsedId);\n\n      // Store result with original index\n      collapsedMap.set(idx, { id: collapsedId, range: [start, end] });\n    }\n\n    // Clear all selections\n    this.state.selections = [];\n\n    // Rebuild index map since visible sequence changed\n    this.indexMap = this.buildIndexMap();\n\n    // Build result arrays in original selection order\n    const collapsedIds: ChunkId[] = [];\n    const affectedRanges: Array<[number, number]> = [];\n\n    for (let i = 0; i < indexedSelections.length; i++) {\n      const result = collapsedMap.get(i)!;\n      collapsedIds.push(result.id);\n      affectedRanges.push(result.range);\n    }\n\n    // Notify clients\n    this.notifyClients({\n      type: 'chunks-collapsed',\n      collapsedIds,\n      affectedRanges,\n    });\n\n    return collapsedIds;\n  }\n\n  /**\n   * Expand a collapsed chunk\n   *\n   * @param collapsedId - The ID of the collapsed chunk to expand\n   * @throws Error if the chunk is not found or not in the visible sequence\n   */\n  expandChunk(collapsedId: ChunkId): void {\n    // Find the collapsed chunk\n    const collapsedChunk = this.state.collapsedChunks.get(collapsedId);\n    if (!collapsedChunk) {\n      throw new Error(`Collapsed chunk not found: ${collapsedId}`);\n    }\n\n    // Find the index in visible sequence\n    const index = this.state.visibleSequence.indexOf(collapsedId);\n    if (index === -1) {\n      throw new Error(`Collapsed chunk not in visible sequence: ${collapsedId}`);\n    }\n\n    // Replace the collapsed chunk with its children\n    this.state.visibleSequence.splice(index, 1, ...collapsedChunk.children);\n\n    // Rebuild index map since visible sequence changed\n    this.indexMap = this.buildIndexMap();\n\n    // Note: We keep the collapsed chunk in the map (for potential undo/history)\n\n    // Notify clients\n    this.notifyClients({\n      type: 'chunk-expanded',\n      expandedId: collapsedId,\n      insertIndex: index,\n    });\n  }\n\n  // ============================================================================\n  // Queries\n  // ============================================================================\n\n  /**\n   * Get the current visible sequence\n   *\n   * @returns A copy of the visible sequence\n   */\n  getVisibleSequence(): ChunkId[] {\n    return [...this.state.visibleSequence];\n  }\n\n  /**\n   * Get all current selections\n   *\n   * @returns Array of current selections (may be empty)\n   */\n  getSelections(): Selection[] {\n    return this.state.selections.map((s) => ({ ...s }));\n  }\n\n  /**\n   * Get a collapsed chunk by ID\n   *\n   * @param id - The collapsed chunk ID\n   * @returns The collapsed chunk, or undefined if not found\n   */\n  getCollapsedChunk(id: ChunkId): CollapsedChunk | undefined {\n    const chunk = this.state.collapsedChunks.get(id);\n    return chunk ? { ...chunk, children: [...chunk.children] } : undefined;\n  }\n\n  /**\n   * Get the complete state (read-only)\n   *\n   * @returns A readonly view of the current state\n   */\n  getState(): Readonly<FoldingState> {\n    return {\n      visibleSequence: [...this.state.visibleSequence],\n      collapsedChunks: new Map(this.state.collapsedChunks),\n      selections: this.state.selections.map((s) => ({ ...s })),\n    };\n  }\n\n  // ============================================================================\n  // Client Management\n  // ============================================================================\n\n  /**\n   * Add a client to receive state change notifications\n   *\n   * @param client - The client to add\n   */\n  addClient(client: FoldingClient): void {\n    this.clients.add(client);\n  }\n\n  /**\n   * Remove a client from receiving notifications\n   *\n   * @param client - The client to remove\n   */\n  removeClient(client: FoldingClient): void {\n    this.clients.delete(client);\n  }\n\n  // ============================================================================\n  // Private Methods\n  // ============================================================================\n\n  /**\n   * Build index map from chunk IDs to their positions in visible sequence\n   *\n   * @returns Map from ChunkId to index\n   */\n  private buildIndexMap(): Map<ChunkId, number> {\n    const map = new Map<ChunkId, number>();\n    for (let i = 0; i < this.state.visibleSequence.length; i++) {\n      map.set(this.state.visibleSequence[i], i);\n    }\n    return map;\n  }\n\n  /**\n   * Merge overlapping selections into disjoint ranges\n   *\n   * @param selections - Array of selections to merge\n   * @returns Array of non-overlapping selections, sorted by start index\n   */\n  private mergeSelections(selections: Selection[]): Selection[] {\n    if (selections.length === 0) {\n      return [];\n    }\n\n    // Sort by start index\n    const sorted = [...selections].sort((a, b) => a.start - b.start);\n\n    const merged: Selection[] = [];\n    let current = sorted[0];\n\n    for (let i = 1; i < sorted.length; i++) {\n      const next = sorted[i];\n\n      // Check if current and next overlap or are adjacent\n      if (next.start <= current.end + 1) {\n        // Merge: extend current to include next\n        current = {\n          start: current.start,\n          end: Math.max(current.end, next.end),\n        };\n      } else {\n        // No overlap: push current and start new range\n        merged.push(current);\n        current = next;\n      }\n    }\n\n    // Push the last range\n    merged.push(current);\n\n    return merged;\n  }\n\n  /**\n   * Notify all clients of a state change\n   */\n  private notifyClients(event: FoldingEvent): void {\n    const state = this.getState();\n    for (const client of this.clients) {\n      client.onStateChanged(event, state);\n    }\n  }\n}\n", "/**\n * Widget Container Component\n *\n * Top-level container that orchestrates multiple views and toolbars.\n * Currently contains just CodeView, but designed to support:\n * - Toolbar for view switching and controls\n * - Multiple visualization views (tree, table, etc.)\n */\n\nimport type { Component } from './base';\nimport type { WidgetData, WidgetMetadata } from '../types';\nimport { buildCodeView } from './CodeView';\nimport { FoldingController } from '../folding/controller';\n\n/**\n * Widget container component interface\n */\nexport interface WidgetContainer extends Component {\n  // Container-specific\n  views: Component[]; // Child components\n  toolbar?: HTMLElement; // Future: toolbar\n  foldingController: FoldingController; // Exposed for testing\n\n  // Operations\n  addView(view: Component): void;\n  removeView(view: Component): void;\n}\n\n/**\n * Build a WidgetContainer component from widget data and metadata\n */\nexport function buildWidgetContainer(data: WidgetData, metadata: WidgetMetadata): WidgetContainer {\n  // 1. Create root element\n  const element = document.createElement('div');\n  element.className = 'tp-widget-output';\n\n  // 2. Initialize folding controller with chunk sequence\n  const initialChunkIds = data.ir?.chunks?.map((chunk) => chunk.id) || [];\n  const foldingController = new FoldingController(initialChunkIds);\n\n  // 3. Build code view with folding controller\n  const codeView = buildCodeView(data, metadata, foldingController);\n\n  // 3. Assemble\n  // Future: Add toolbar here\n  // const toolbar = createToolbar();\n  // element.appendChild(toolbar);\n\n  element.appendChild(codeView.element);\n\n  // 4. Track views\n  const views: Component[] = [codeView];\n\n  // 5. Return component\n  return {\n    element,\n    views,\n    toolbar: undefined, // Future\n    foldingController, // Expose for testing\n\n    destroy(): void {\n      // Cleanup all views\n      views.forEach((view) => view.destroy());\n      element.remove();\n    },\n\n    addView(view: Component): void {\n      views.push(view);\n      element.appendChild(view.element);\n    },\n\n    removeView(view: Component): void {\n      const index = views.indexOf(view);\n      if (index !== -1) {\n        views.splice(index, 1);\n        view.element.remove();\n      }\n    },\n  };\n}\n", "/**\n * Widget renderer - main orchestrator\n *\n * Simplified to just:\n * 1. Parse JSON data\n * 2. Compute metadata\n * 3. Build widget component\n * 4. Mount to DOM\n */\n\nimport type { WidgetData } from './types';\nimport { computeWidgetMetadata } from './metadata';\nimport { buildWidgetContainer } from './components/WidgetContainer';\n\n/**\n * Initialize a widget in the given container\n *\n * This is the main entry point called by index.ts\n */\nexport function initWidget(container: HTMLElement): void {\n  try {\n    // 1. Parse embedded JSON data\n    const scriptTag = container.querySelector('script[data-role=\"tp-widget-data\"]');\n    if (!scriptTag || !scriptTag.textContent) {\n      container.innerHTML = '<div class=\"tp-error\">No widget data found</div>';\n      return;\n    }\n\n    const data: WidgetData = JSON.parse(scriptTag.textContent);\n\n    // 2. Validate data\n    if (!data.ir || !data.ir.chunks) {\n      container.innerHTML = '<div class=\"tp-error\">No chunks found in widget data</div>';\n      return;\n    }\n\n    // 3. Compute metadata (Phase 1 & 2)\n    const metadata = computeWidgetMetadata(data);\n\n    // 4. Build widget component (Phase 3)\n    const widget = buildWidgetContainer(data, metadata);\n\n    // 5. Mount to DOM\n    const mountPoint = container.querySelector('.tp-widget-mount');\n    if (mountPoint) {\n      mountPoint.innerHTML = '';\n      mountPoint.appendChild(widget.element);\n    } else {\n      container.innerHTML = '';\n      container.appendChild(widget.element);\n    }\n\n    // 6. Store component reference for future access\n    (container as HTMLElement & { _widgetComponent?: typeof widget })._widgetComponent = widget;\n  } catch (error) {\n    console.error('Widget initialization error:', error);\n    container.innerHTML = `<div class=\"tp-error\">Failed to initialize widget: ${\n      error instanceof Error ? error.message : String(error)\n    }</div>`;\n  }\n}\n", "/* T-Prompts Widget Styles */\n\n/* =============================================================================\n   CSS VARIABLES FOR THEMING\n   ============================================================================= */\n\n/* Base UI Variables */\n:root {\n  --tp-color-bg: #ffffff;\n  --tp-color-fg: #24292e;\n  --tp-color-border: #e1e4e8;\n  --tp-color-accent: #0366d6;\n  --tp-color-muted: #6a737d;\n  --tp-color-error: #d73a49;\n  --tp-font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;\n  --tp-font-mono: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;\n  --tp-spacing: 8px;\n\n  /* ==========================================================================\n     TIER 1: PALETTE PRIMITIVES - Hue values for each element type\n     ========================================================================== */\n  --tp-hue-static: 220;         /* Neutral blue-gray */\n  --tp-hue-interpolation: 212;  /* Blue - dynamic data */\n  --tp-hue-nested: 270;         /* Purple - compositional structure */\n  --tp-hue-list: 160;           /* Teal - collections */\n  --tp-hue-image: 30;           /* Orange - media */\n  --tp-hue-unknown: 0;          /* Red - warning/edge case */\n\n  /* ==========================================================================\n     TIER 2: SEMANTIC TOKENS - Light Mode\n     Saturation, lightness, and alpha values for foregrounds and backgrounds\n     ========================================================================== */\n\n  /* Static text - minimal styling (baseline) */\n  --tp-static-fg-s: 15%;\n  --tp-static-fg-l: 30%;\n  --tp-static-bg-alpha: 0.04;\n\n  /* Interpolations - blue, medium visibility */\n  --tp-interp-fg-s: 80%;\n  --tp-interp-fg-l: 35%;\n  --tp-interp-bg-alpha: 0.10;\n\n  /* Nested prompts - purple, slightly stronger */\n  --tp-nested-fg-s: 75%;\n  --tp-nested-fg-l: 38%;\n  --tp-nested-bg-alpha: 0.12;\n\n  /* Lists - teal, medium tint (increased visibility) */\n  --tp-list-fg-s: 80%;\n  --tp-list-fg-l: 32%;\n  --tp-list-bg-alpha: 0.14;\n\n  /* Images - orange, distinct */\n  --tp-image-fg-s: 85%;\n  --tp-image-fg-l: 40%;\n  --tp-image-bg-alpha: 0.10;\n\n  /* Unknown - red, warning signal */\n  --tp-unknown-fg-s: 80%;\n  --tp-unknown-fg-l: 45%;\n  --tp-unknown-bg-alpha: 0.12;\n}\n\n/* Dark Mode Overrides */\n@media (prefers-color-scheme: dark) {\n  :root {\n    --tp-color-bg: #0d1117;\n    --tp-color-fg: #c9d1d9;\n    --tp-color-border: #30363d;\n    --tp-color-accent: #58a6ff;\n    --tp-color-muted: #8b949e;\n    --tp-color-error: #f85149;\n\n    /* ==========================================================================\n       TIER 2: SEMANTIC TOKENS - Dark Mode Overrides\n       Higher lightness for foregrounds, higher alpha for backgrounds\n       ========================================================================== */\n\n    /* Static text */\n    --tp-static-fg-l: 75%;\n    --tp-static-bg-alpha: 0.08;\n\n    /* Interpolations */\n    --tp-interp-fg-l: 75%;\n    --tp-interp-bg-alpha: 0.18;\n\n    /* Nested prompts */\n    --tp-nested-fg-l: 78%;\n    --tp-nested-bg-alpha: 0.22;\n\n    /* Lists */\n    --tp-list-fg-l: 72%;\n    --tp-list-bg-alpha: 0.24;\n\n    /* Images */\n    --tp-image-fg-l: 80%;\n    --tp-image-bg-alpha: 0.18;\n\n    /* Unknown */\n    --tp-unknown-fg-l: 75%;\n    --tp-unknown-bg-alpha: 0.22;\n  }\n}\n\n/* Main widget container - three-pane grid layout */\n.tp-widget-container {\n  display: grid;\n  grid-template-columns: 1fr 1fr 1fr;\n  gap: var(--tp-spacing);\n  font-family: var(--tp-font-family);\n  font-size: 14px;\n  color: var(--tp-color-fg);\n  background: var(--tp-color-bg);\n  border: 1px solid var(--tp-color-border);\n  border-radius: 6px;\n  padding: var(--tp-spacing);\n  margin: calc(var(--tp-spacing) * 2) 0;\n  max-width: 100%;\n  overflow: hidden;\n}\n\n/* Output container for chunks */\n.tp-output-container {\n  font-family: var(--tp-font-mono);\n  font-size: 12px;\n  line-height: 1.6;\n  color: var(--tp-color-fg);\n  max-width: 110ch;\n  word-break: break-all;\n  position: relative;\n  outline: none; /* Remove focus outline for keyboard events */\n}\n\n/* Wrapping mode (default) */\n.tp-output-container.wrap {\n  white-space: pre-wrap;\n}\n\n/* Scrolling mode (horizontal scroll, no wrapping) */\n.tp-output-container.scroll {\n  white-space: pre;\n  overflow-x: auto;\n}\n\n/* =============================================================================\n   TIER 3: APPLIED STYLES - Chunk Element Types\n   Semantic colors applied using the three-tier variable system\n   ============================================================================= */\n\n/* Static text - neutral baseline */\n.tp-chunk-static {\n  white-space: pre-wrap;\n  color: hsl(\n    var(--tp-hue-static),\n    var(--tp-static-fg-s),\n    var(--tp-static-fg-l)\n  );\n  background: hsla(\n    var(--tp-hue-static),\n    20%,\n    60%,\n    var(--tp-static-bg-alpha)\n  );\n}\n\n/* Interpolations - blue for dynamic data */\n.tp-chunk-interpolation {\n  white-space: pre-wrap;\n  color: hsl(\n    var(--tp-hue-interpolation),\n    var(--tp-interp-fg-s),\n    var(--tp-interp-fg-l)\n  );\n  background: hsla(\n    var(--tp-hue-interpolation),\n    80%,\n    60%,\n    var(--tp-interp-bg-alpha)\n  );\n}\n\n/* Nested prompts - purple for composition */\n.tp-chunk-nested_prompt {\n  white-space: pre-wrap;\n  color: hsl(\n    var(--tp-hue-nested),\n    var(--tp-nested-fg-s),\n    var(--tp-nested-fg-l)\n  );\n  background: hsla(\n    var(--tp-hue-nested),\n    75%,\n    65%,\n    var(--tp-nested-bg-alpha)\n  );\n}\n\n/* Lists - teal for collections */\n.tp-chunk-list {\n  white-space: pre-wrap;\n  color: hsl(\n    var(--tp-hue-list),\n    var(--tp-list-fg-s),\n    var(--tp-list-fg-l)\n  );\n  background: hsla(\n    var(--tp-hue-list),\n    70%,\n    60%,\n    var(--tp-list-bg-alpha)\n  );\n}\n\n/* Images - orange for media, with text elision */\n.tp-chunk-image {\n  white-space: nowrap;\n  max-width: 200px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  display: inline-block;\n  vertical-align: middle;\n  color: hsl(\n    var(--tp-hue-image),\n    var(--tp-image-fg-s),\n    var(--tp-image-fg-l)\n  );\n  background: hsla(\n    var(--tp-hue-image),\n    85%,\n    65%,\n    var(--tp-image-bg-alpha)\n  );\n}\n\n/* Image container for hover preview */\n.tp-chunk-image-container {\n  position: relative;\n  display: inline-block;\n  overflow: visible !important; /* Override overflow: hidden from tp-chunk-image class */\n}\n\n/* Hidden image preview - shown on hover */\n.tp-chunk-image-preview {\n  display: none;\n  position: absolute;\n  left: 100%;\n  top: 0;\n  margin-left: 8px;\n  z-index: 1000;\n  max-width: 400px;\n  max-height: 400px;\n  border: 2px solid var(--tp-color-border);\n  border-radius: 4px;\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n  background: var(--tp-color-bg);\n}\n\n/* Show preview on hover */\n.tp-chunk-image-container:hover .tp-chunk-image-preview {\n  display: block;\n}\n\n/* Unknown types - red warning */\n.tp-chunk-unknown {\n  white-space: pre-wrap;\n  color: hsl(\n    var(--tp-hue-unknown),\n    var(--tp-unknown-fg-s),\n    var(--tp-unknown-fg-l)\n  );\n  background: hsla(\n    var(--tp-hue-unknown),\n    80%,\n    60%,\n    var(--tp-unknown-bg-alpha)\n  );\n}\n\n/* Element boundary markers - type-specific borders */\n/* Borders use each element type's semantic hue for visual consistency */\n\n/* No borders for static elements (baseline) */\n.tp-first-static,\n.tp-last-static {\n  /* Static elements have no boundary borders */\n}\n\n/* 1px borders for interpolation (blue, hue 212) */\n.tp-first-interpolation {\n  box-shadow: inset 1px 0 0 0 hsl(212, 90%, 45%);\n  padding-left: 1px;\n}\n\n.tp-last-interpolation {\n  box-shadow: inset -1px 0 0 0 hsl(212, 90%, 55%);\n  padding-right: 1px;\n}\n\n/* 1px borders for image (orange, hue 30) */\n.tp-first-image {\n  box-shadow: inset 1px 0 0 0 hsl(30, 90%, 50%);\n  padding-left: 1px;\n}\n\n.tp-last-image {\n  box-shadow: inset -1px 0 0 0 hsl(30, 90%, 60%);\n  padding-right: 1px;\n}\n\n\n/* 1px borders for nested_prompt (purple, hue 270) */\n.tp-first-nested_prompt {\n  box-shadow: inset 1px 0 0 0 hsl(270, 85%, 50%);\n  padding-left: 1px;\n}\n\n.tp-last-nested_prompt {\n  box-shadow: inset -1px 0 0 0 hsl(270, 85%, 60%);\n  padding-right: 1px;\n}\n\n/* 1px borders for list (teal, hue 160) - higher priority, placed last */\n.tp-first-list {\n  box-shadow: inset 1px 0 0 0 hsl(160, 80%, 40%);\n  padding-left: 1px;\n}\n\n.tp-last-list {\n  box-shadow: inset -1px 0 0 0 hsl(160, 80%, 50%);\n  padding-right: 1px;\n}\n\n\n/* Dark mode adjustments for boundaries - lighter colors for better visibility */\n@media (prefers-color-scheme: dark) {\n  .tp-first-interpolation {\n    box-shadow: inset 1px 0 0 0 hsl(212, 90%, 60%);\n  }\n\n  .tp-last-interpolation {\n    box-shadow: inset -1px 0 0 0 hsl(212, 90%, 70%);\n  }\n\n  .tp-first-image {\n    box-shadow: inset 1px 0 0 0 hsl(30, 90%, 65%);\n  }\n\n  .tp-last-image {\n    box-shadow: inset -1px 0 0 0 hsl(30, 90%, 75%);\n  }\n\n  .tp-first-nested_prompt {\n    box-shadow: inset 1px 0 0 0 hsl(270, 85%, 65%);\n  }\n\n  .tp-last-nested_prompt {\n    box-shadow: inset -1px 0 0 0 hsl(270, 85%, 75%);\n  }\n\n  .tp-first-list {\n    box-shadow: inset 1px 0 0 0 hsl(160, 80%, 55%);\n  }\n\n  .tp-last-list {\n    box-shadow: inset -1px 0 0 0 hsl(160, 80%, 65%);\n  }\n}\n\n/* =============================================================================\n   LINE WRAPPING STYLES\n   ============================================================================= */\n\n/* Line break element created by wrapping transform */\n.tp-wrap-newline {\n  display: block;\n  height: 0;\n  line-height: 0;\n}\n\n/* Container created when an element is wrapped */\n.tp-wrap-container {\n  display: inline;\n}\n\n/* Continuation lines (after a wrap) - add gutter icon */\n.tp-wrap-continuation::before {\n  content: '\u21A9';\n  position: absolute;\n  left: -2ch;\n  color: var(--tp-color-muted);\n  font-size: 0.9em;\n  opacity: 0.6;\n  pointer-events: none;\n}\n\n/* Dark mode - slightly more visible gutter icon */\n@media (prefers-color-scheme: dark) {\n  .tp-wrap-continuation::before {\n    opacity: 0.5;\n  }\n}\n\n/* Error display */\n.tp-error {\n  color: var(--tp-color-error);\n  font-family: var(--tp-font-mono);\n  font-size: 12px;\n  padding: var(--tp-spacing);\n  background: rgba(248, 81, 73, 0.1);\n  border: 1px solid var(--tp-color-error);\n  border-radius: 4px;\n  margin: var(--tp-spacing) 0;\n}\n\n/* Responsive layout */\n@media (max-width: 1200px) {\n  .tp-widget-container {\n    grid-template-columns: 1fr;\n  }\n\n  .tp-pane {\n    max-height: 400px;\n  }\n}\n\n@media (min-width: 1201px) and (max-width: 1600px) {\n  .tp-widget-container {\n    grid-template-columns: 1fr 1fr;\n  }\n}\n\n/* =============================================================================\n   COLLAPSED CHUNKS\n   ============================================================================= */\n\n/* Collapsed chunk styling */\n.tp-chunk-collapsed {\n  display: inline-block;\n  padding: 2px 6px;\n  margin: 0 2px;\n  background-color: var(--tp-color-muted-bg, #e0e0e0);\n  color: var(--tp-color-muted, #666);\n  border-radius: 3px;\n  font-size: 0.9em;\n  cursor: pointer;\n  user-select: none;\n}\n\n.tp-chunk-collapsed:hover {\n  background-color: var(--tp-color-muted-bg-hover, #d0d0d0);\n}\n\n/* Dark mode for collapsed chunks */\n@media (prefers-color-scheme: dark) {\n  .tp-chunk-collapsed {\n    background-color: var(--tp-color-muted-bg, #30363d);\n    color: var(--tp-color-muted, #8b949e);\n  }\n\n  .tp-chunk-collapsed:hover {\n    background-color: var(--tp-color-muted-bg-hover, #40464d);\n  }\n}\n", "// Auto-generated by build.js - do not edit manually\nexport const STYLES_HASH = '47e5a1d5';\n"],
  "mappings": "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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ECCO,IAAMC,EAAc,WfSpB,IAAMC,EAAU,cAgBvB,SAASC,GAAqB,CAE5B,IAAMC,EAAU,oBAAoBC,CAAW,GAI/C,GAAI,SAAS,cAAc,IAAID,CAAO,EAAE,EACtC,OAIgB,SAAS,iBAAiB,0BAA0B,EAC5D,QAAQE,GAAMA,EAAG,OAAO,CAAC,EAGnC,IAAMC,EAAe,SAAS,cAAc,OAAO,EACnDA,EAAa,GAAKH,EAClBG,EAAa,YAAcC,EAC3B,SAAS,KAAK,YAAYD,CAAY,EAElC,OAAO,aACT,OAAO,WAAW,eAAiB,GAEvC,CAKA,SAASE,GAAoB,CACtB,OAAO,aACV,OAAO,WAAa,CAClB,QAASP,EACT,WAAAQ,EACA,eAAgB,EAClB,EAEJ,CAKA,SAASC,GAAiB,CACxBF,EAAY,EACZN,EAAa,EAGM,SAAS,iBAAiB,kBAAkB,EACpD,QAASS,GAAc,CAC5BA,aAAqB,aAAe,CAACA,EAAU,QAAQ,gBACzDF,EAAWE,CAAS,EACpBA,EAAU,QAAQ,cAAgB,OAEtC,CAAC,CACH,CAGI,SAAS,aAAe,UAC1B,SAAS,iBAAiB,mBAAoBD,CAAQ,EAEtDA,EAAS,EAIP,OAAO,iBAAqB,KACb,IAAI,iBAAkBE,GAAc,CACnDA,EAAU,QAASC,GAAa,CAC9BA,EAAS,WAAW,QAASC,GAAS,CAChCA,aAAgB,cAEdA,EAAK,QAAQ,kBAAkB,GAAK,CAACA,EAAK,QAAQ,gBACpDN,EAAY,EACZN,EAAa,EACbO,EAAWK,CAAI,EACfA,EAAK,QAAQ,cAAgB,QAGfA,EAAK,iBAAiB,kBAAkB,EAChD,QAASC,GAAW,CACtBA,aAAkB,aAAe,CAACA,EAAO,QAAQ,gBACnDP,EAAY,EACZN,EAAa,EACbO,EAAWM,CAAM,EACjBA,EAAO,QAAQ,cAAgB,OAEnC,CAAC,EAEL,CAAC,CACH,CAAC,CACH,CAAC,EAGQ,QAAQ,SAAS,KAAM,CAC9B,UAAW,GACX,QAAS,EACX,CAAC",
  "names": ["src_exports", "__export", "VERSION", "initRuntime", "initWidget", "injectStyles", "trimSourcePrefix", "filepath", "prefix", "normalizedPrefix", "formatSourceLocation", "location", "sourcePrefix", "path", "relativePath", "buildElementLocationMap", "promptData", "map", "walkElements", "elements", "element", "sourceLoc", "creationLoc", "buildElementTypeMap", "computeWidgetMetadata", "data", "getChunkId", "element", "copyChunkId", "fromElement", "toElement", "chunkId", "addToChunksMap", "map", "existing", "removeFromChunksMap", "index", "replaceInChunksMap", "oldElement", "newElement", "applyTransform_CreateChunks", "state", "element", "chunks", "data", "chunk", "chunkElement", "span", "imgData", "format", "dataUrl", "chunkText", "addToChunksMap", "applyTransform_AddTyping", "state", "chunks", "data", "metadata", "chunk", "elements", "chunkElement", "elementType", "location", "applyTransform_ImageTruncate", "state", "chunks", "chunkElement", "imageData", "truncatedText", "DEFAULT_COLUMN_LIMIT", "copyDataAttributes", "fromElement", "toElement", "key", "copyClasses", "wrapElement", "element", "splitIndex", "columnLimit", "chunks", "text", "firstPart", "remainder", "container", "firstSpan", "lineBreak", "remainderSpan", "wrappedRemainder", "elementWithImageData", "processElement", "currentColumn", "textLength", "availableColumns", "replaceInChunksMap", "rightmost", "lastChild", "prevSibling", "rightmostText", "applyTransform_LineWrap", "state", "currentElement", "result", "applyTransform_ImageHoverPreview", "state", "chunks", "chunkId", "elements", "chunkElement", "imageData", "format", "dataUrl", "container", "copyChunkId", "textSpan", "previewImg", "removeFromChunksMap", "addToChunksMap", "applyTransform_MarkBoundaries", "state", "chunks", "data", "metadata", "elementId", "chunkIds", "elementType", "firstChunkId", "firstElements", "el", "lastChunkId", "lastElements", "buildCodeView", "data", "metadata", "foldingController", "element", "chunkIdToTopElements", "state", "applyTransform_CreateChunks", "applyTransform_AddTyping", "applyTransform_ImageTruncate", "applyTransform_LineWrap", "applyTransform_ImageHoverPreview", "applyTransform_MarkBoundaries", "selectionTimeout", "handleSelectionChange", "selectedIds", "getSelectedChunkIds", "selection", "range", "chunkId", "elements", "chunkElement", "isElementInRange", "elementRange", "handleKeyDown", "event", "foldingClient", "handleChunksCollapsed", "handleChunkExpanded", "handleStateReset", "collapsedIds", "i", "collapsedId", "collapsed", "charCount", "firstElement", "childId", "childElements", "el", "collapsedSpan", "expandedId", "collapsedElements", "generateUUID", "c", "r", "FoldingController", "initialSequence", "start", "end", "newSelection", "merged", "chunkIds", "idSet", "validIndices", "id", "index", "a", "b", "ranges", "rangeStart", "rangeEnd", "i", "currentIndex", "indexedSelections", "sel", "idx", "collapsedMap", "selectedChunks", "collapsedId", "generateUUID", "collapsedChunk", "collapsedIds", "affectedRanges", "result", "s", "chunk", "client", "map", "selections", "sorted", "current", "next", "event", "state", "buildWidgetContainer", "data", "metadata", "element", "initialChunkIds", "chunk", "foldingController", "FoldingController", "codeView", "buildCodeView", "views", "view", "index", "initWidget", "container", "scriptTag", "data", "metadata", "computeWidgetMetadata", "widget", "buildWidgetContainer", "mountPoint", "error", "styles_default", "STYLES_HASH", "VERSION", "injectStyles", "styleId", "STYLES_HASH", "el", "styleElement", "styles_default", "initRuntime", "initWidget", "autoInit", "container", "mutations", "mutation", "node", "widget"]
}
