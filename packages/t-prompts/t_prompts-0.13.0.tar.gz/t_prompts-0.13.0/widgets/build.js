import esbuild from 'esbuild';
import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function copyDistToPython() {
  const distDir = path.join(__dirname, 'dist');
  const pythonWidgetsDir = path.join(__dirname, '..', 'src', 't_prompts', 'widgets');

  // Ensure Python widgets directory exists
  if (!fs.existsSync(pythonWidgetsDir)) {
    fs.mkdirSync(pythonWidgetsDir, { recursive: true });
  }

  // Copy .js and .css files from dist/ to Python package (exclude .map files)
  const files = fs.readdirSync(distDir);
  for (const file of files) {
    const ext = path.extname(file);
    if (ext === '.js' || ext === '.css') {
      const srcPath = path.join(distDir, file);
      const destPath = path.join(pythonWidgetsDir, file);
      fs.copyFileSync(srcPath, destPath);
      console.log(`  Copied ${file} to Python package`);
    }
  }
}

function generateStylesHash() {
  // Read final bundled styles.css and generate a hash
  const stylesPath = path.join(__dirname, 'dist', 'styles.css');
  const stylesContent = fs.readFileSync(stylesPath, 'utf8');
  const hash = crypto.createHash('sha256').update(stylesContent).digest('hex').substring(0, 8);

  // Write the hash to a generated TypeScript file
  const generatedPath = path.join(__dirname, 'src', 'generated.ts');
  const content = `// Auto-generated by build.js - do not edit manually
export const STYLES_HASH = '${hash}';
`;
  fs.writeFileSync(generatedPath, content);
  console.log(`  Generated styles hash: ${hash}`);

  return hash;
}

async function build() {
  const outdir = path.join(__dirname, 'dist');
  const srcdir = path.join(__dirname, 'src');

  // Ensure output directory exists
  if (!fs.existsSync(outdir)) {
    fs.mkdirSync(outdir, { recursive: true });
  }

  try {
    // Step 1: Bundle KaTeX CSS (resolves @import and bundles fonts)
    console.log('Building KaTeX bundle...');
    await esbuild.build({
      entryPoints: [path.join(srcdir, 'katex-bundle.css')],
      bundle: true,
      minify: true,
      outfile: path.join(outdir, 'katex-bundle.css'),
      loader: {
        '.woff': 'dataurl',
        '.woff2': 'dataurl',
        '.ttf': 'dataurl',
        '.eot': 'dataurl',
      },
    });
    console.log('✓ KaTeX bundle built');

    // Step 2: Concatenate widget styles + bundled KaTeX
    const widgetStyles = fs.readFileSync(path.join(srcdir, 'styles.css'), 'utf8');
    const katexBundle = fs.readFileSync(path.join(outdir, 'katex-bundle.css'), 'utf8');
    const finalStyles = widgetStyles + '\n\n' + katexBundle;
    fs.writeFileSync(path.join(outdir, 'styles.css'), finalStyles);
    console.log('✓ Concatenated styles.css');

    // Step 3: Generate styles hash (after styles are created)
    generateStylesHash();

    // Step 4: Build JavaScript (uses loader for CSS text import)
    console.log('Building JavaScript bundle...');
    await esbuild.build({
      entryPoints: ['src/index.ts'],
      bundle: true,
      minify: true,
      sourcemap: true,
      sourcesContent: false,  // Exclude source content from source map
      target: ['es2020'],
      format: 'iife',
      globalName: 'TPromptsWidgets',
      outfile: path.join(outdir, 'index.js'),
      platform: 'browser',
      metafile: true,
      logLevel: 'info',
      loader: {
        '.css': 'text',  // Import CSS as text string in JS
      },
    });
    console.log('✓ JavaScript bundle built');

    // Step 5: Copy artifacts to Python package
    copyDistToPython();
    console.log('✓ Copied to Python package');

    console.log('\n✅ Build completed successfully');
  } catch (error) {
    console.error('✗ Build failed:', error);
    process.exit(1);
  }
}

build();
