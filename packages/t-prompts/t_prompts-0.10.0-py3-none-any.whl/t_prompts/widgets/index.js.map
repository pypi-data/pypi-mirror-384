{
  "version": 3,
  "sources": ["../src/index.ts", "../src/metadata.ts", "../src/transforms/base.ts", "../src/transforms/createChunks.ts", "../src/transforms/typing.ts", "../src/transforms/boundaries.ts", "../src/transforms/textMapping.ts", "../src/components/CodeView.ts", "../src/components/WidgetContainer.ts", "../src/renderer.ts", "../src/styles.css", "../src/generated.ts"],
  "sourcesContent": ["/**\n * Jupyter notebook widgets for visualizing t-prompts structures.\n * Phase 0 & 1: Asset de-duplication and minimal static renderer\n */\n\nimport { initWidget } from './renderer';\nimport widgetStyles from './styles.css';\nimport { STYLES_HASH } from './generated';\n\n// Export version matching Python package\nexport const VERSION = '0.9.0-alpha';\n\n// Store widget runtime on window for singleton pattern (Phase 0)\ndeclare global {\n  interface Window {\n    __TPWidget?: {\n      version: string;\n      initWidget: typeof initWidget;\n      stylesInjected: boolean;\n    };\n  }\n}\n\n/**\n * Inject widget styles into the document (once per page)\n */\nfunction injectStyles(): void {\n  // Use hash-based style ID for cache busting\n  const styleId = `tp-widget-styles-${STYLES_HASH}`;\n\n  // Check if this version is already injected\n  // Use querySelector instead of getElementById for reliability across environments\n  if (document.querySelector(`#${styleId}`)) {\n    return;\n  }\n\n  // Remove any old versions of the styles\n  const oldStyles = document.querySelectorAll('[id^=\"tp-widget-styles\"]');\n  oldStyles.forEach(el => el.remove());\n\n  // Inject new styles\n  const styleElement = document.createElement('style');\n  styleElement.id = styleId;\n  styleElement.textContent = widgetStyles;\n  document.head.appendChild(styleElement);\n\n  if (window.__TPWidget) {\n    window.__TPWidget.stylesInjected = true;\n  }\n}\n\n/**\n * Initialize the widget runtime on window (Phase 0 singleton)\n */\nfunction initRuntime(): void {\n  if (!window.__TPWidget) {\n    window.__TPWidget = {\n      version: VERSION,\n      initWidget,\n      stylesInjected: false,\n    };\n  }\n}\n\n/**\n * Auto-initialize all widgets on the page\n */\nfunction autoInit(): void {\n  initRuntime();\n  injectStyles();\n\n  // Find all widget containers and initialize them\n  const containers = document.querySelectorAll('[data-tp-widget]');\n  containers.forEach((container) => {\n    if (container instanceof HTMLElement && !container.dataset.tpInitialized) {\n      initWidget(container);\n      container.dataset.tpInitialized = 'true';\n    }\n  });\n}\n\n// Auto-initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', autoInit);\n} else {\n  autoInit();\n}\n\n// Watch for new widgets being added to the page (for Jupyter dynamic cell rendering)\nif (typeof MutationObserver !== 'undefined') {\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      mutation.addedNodes.forEach((node) => {\n        if (node instanceof HTMLElement) {\n          // Check if this node is a widget container\n          if (node.matches('[data-tp-widget]') && !node.dataset.tpInitialized) {\n            initRuntime();\n            injectStyles();\n            initWidget(node);\n            node.dataset.tpInitialized = 'true';\n          }\n          // Check if this node contains widget containers\n          const widgets = node.querySelectorAll('[data-tp-widget]');\n          widgets.forEach((widget) => {\n            if (widget instanceof HTMLElement && !widget.dataset.tpInitialized) {\n              initRuntime();\n              injectStyles();\n              initWidget(widget);\n              widget.dataset.tpInitialized = 'true';\n            }\n          });\n        }\n      });\n    });\n  });\n\n  // Observe the entire document body for new widgets\n  observer.observe(document.body, {\n    childList: true,\n    subtree: true,\n  });\n}\n\n// Export for manual initialization\nexport { initWidget, injectStyles, initRuntime };\n", "/**\n * Metadata computation and analysis (Phase 1 & 2)\n *\n * These functions analyze widget data and build lookup maps\n * that are view-agnostic and reusable across visualizations.\n */\n\nimport type {\n  WidgetData,\n  WidgetMetadata,\n  PromptData,\n  ElementData,\n  SourceLocationData,\n} from './types';\n\n/**\n * Trim the source prefix from a file path to make it relative\n *\n * @param filepath - The absolute file path\n * @param prefix - The prefix to remove (e.g., project root directory)\n * @returns The relative path, or original path if prefix doesn't match\n *\n * @example\n * trimSourcePrefix('/Users/dev/project/src/main.py', '/Users/dev/project')\n * // Returns: 'src/main.py'\n */\nexport function trimSourcePrefix(filepath: string | null, prefix: string): string | null {\n  if (!filepath) {\n    return null;\n  }\n\n  // Normalize prefix to ensure it ends with a separator\n  const normalizedPrefix = prefix.endsWith('/') ? prefix : prefix + '/';\n\n  // Check if filepath starts with the prefix\n  if (filepath.startsWith(normalizedPrefix)) {\n    return filepath.substring(normalizedPrefix.length);\n  }\n\n  // Also check without trailing slash in case filepath === prefix\n  if (filepath === prefix) {\n    return '.';\n  }\n\n  // Prefix doesn't match - return original path\n  return filepath;\n}\n\n/**\n * Format a source location as a compact string\n *\n * @param location - The source location data\n * @param sourcePrefix - The prefix to trim from filepaths\n * @returns Formatted location string (e.g., \"src/main.py:42\") or null if location not available\n */\nfunction formatSourceLocation(\n  location: SourceLocationData | null | undefined,\n  sourcePrefix: string\n): string | null {\n  if (!location || !location.filename) {\n    return null;\n  }\n\n  // Use filepath if available, otherwise use filename\n  const path = location.filepath || location.filename;\n  const relativePath = trimSourcePrefix(path, sourcePrefix) || path;\n\n  // Add line number if available\n  if (location.line !== null && location.line !== undefined) {\n    return `${relativePath}:${location.line}`;\n  }\n\n  return relativePath;\n}\n\n/**\n * Build a map from element_id to formatted location string by walking the source prompt tree\n *\n * For elements with both source_location and creation_location (nested prompts),\n * the format is: \"source.py:84 (created: other.py:42)\"\n */\nfunction buildElementLocationMap(\n  promptData: PromptData | null,\n  sourcePrefix: string\n): Record<string, string> {\n  const map: Record<string, string> = {};\n\n  if (!promptData) {\n    return map;\n  }\n\n  function walkElements(elements: ElementData[]): void {\n    for (const element of elements) {\n      // Format source_location (where interpolated/used)\n      const sourceLoc = formatSourceLocation(element.source_location, sourcePrefix);\n\n      // Format creation_location (where originally created)\n      const creationLoc = formatSourceLocation(element.creation_location, sourcePrefix);\n\n      // Build location string\n      if (sourceLoc && creationLoc && sourceLoc !== creationLoc) {\n        // Both locations exist and differ (nested prompt case)\n        map[element.id] = `${sourceLoc} (created: ${creationLoc})`;\n      } else if (sourceLoc) {\n        // Just source location\n        map[element.id] = sourceLoc;\n      } else if (creationLoc) {\n        // Just creation location (shouldn't happen normally)\n        map[element.id] = creationLoc;\n      }\n      // If neither exists, no entry in map\n\n      // Recursively process nested elements\n      if (element.children) {\n        walkElements(element.children);\n      }\n    }\n  }\n\n  // Start walking from the root prompt's children\n  walkElements(promptData.children);\n  return map;\n}\n\n/**\n * Build a map from element_id to element_type by walking the source prompt tree\n */\nfunction buildElementTypeMap(promptData: PromptData | null): Record<string, string> {\n  const map: Record<string, string> = {};\n\n  if (!promptData) {\n    return map;\n  }\n\n  function walkElements(elements: ElementData[]): void {\n    for (const element of elements) {\n      map[element.id] = element.type;\n\n      // Recursively process nested elements\n      if (element.children) {\n        walkElements(element.children);\n      }\n    }\n  }\n\n  // Start walking from the root prompt's children\n  walkElements(promptData.children);\n  return map;\n}\n\n/**\n * Compute all widget metadata from widget data.\n * This centralizes all map-building logic and creates view-agnostic metadata\n * that can be reused across different visualizations.\n *\n * @param data - The widget data\n * @returns Metadata containing all computed maps\n */\nexport function computeWidgetMetadata(data: WidgetData): WidgetMetadata {\n  const sourcePrefix = data.config?.sourcePrefix || '';\n\n  return {\n    elementTypeMap: buildElementTypeMap(data.source_prompt || null),\n    elementLocationMap: buildElementLocationMap(data.source_prompt || null, sourcePrefix),\n  };\n}\n", "/**\n * Transform pipeline infrastructure\n *\n * Transforms are pure functions that take state and return modified state.\n * They allow incremental modification of DOM structure and data.\n */\n\nimport type { WidgetData, WidgetMetadata, TextMapping } from '../types';\n\n/**\n * State that flows through the transform pipeline\n */\nexport interface TransformState {\n  // DOM\n  element: HTMLElement;\n  chunks: Map<string, HTMLElement>; // chunkId \u2192 DOM element\n\n  // Data\n  data: WidgetData;\n  metadata: WidgetMetadata;\n\n  // Analysis results (built incrementally)\n  textMapping?: TextMapping;\n  // Future: lineBreaks, syntaxTree, etc.\n}\n\n/**\n * Transform function signature\n * Takes state, returns modified state\n */\nexport type Transform = (state: TransformState) => TransformState;\n\n/**\n * ID Conversion Utilities\n *\n * Convention: Python UUIDs are prefixed with \"id-\" when used as DOM element IDs.\n * This ensures IDs always start with a letter (HTML spec compliant) and avoids\n * CSS selector issues with IDs starting with digits.\n */\n\n/**\n * Convert a Python UUID to a DOM element ID by prefixing with \"id-\"\n */\nexport function toElementId(pythonId: string): string {\n  return `id-${pythonId}`;\n}\n\n/**\n * Convert a DOM element ID back to Python UUID by removing the \"id-\" prefix\n */\nexport function fromElementId(elementId: string): string {\n  if (elementId.startsWith('id-')) {\n    return elementId.substring(3);\n  }\n  return elementId;\n}\n", "/**\n * Create Chunks Transform\n *\n * Creates initial <span> elements for each chunk and adds them to the DOM.\n * This is the first transform in the pipeline - it builds the raw structure.\n */\n\nimport type { TransformState } from './base';\nimport { toElementId } from './base';\n\n/**\n * Create initial DOM elements for all chunks\n */\nexport function applyTransform_CreateChunks(state: TransformState): TransformState {\n  const { element, chunks, data } = state;\n\n  if (!data.ir?.chunks) {\n    return state;\n  }\n\n  // Process each chunk\n  for (const chunk of data.ir.chunks) {\n    let chunkElement: HTMLElement;\n\n    if (chunk.type === 'TextChunk' && chunk.text !== undefined) {\n      // Text chunk - simple span with text content\n      const span = document.createElement('span');\n      span.id = toElementId(chunk.id);\n      span.textContent = chunk.text;\n      chunkElement = span;\n    } else if (chunk.type === 'ImageChunk' && chunk.image) {\n      // Image chunk - container with text placeholder and hidden preview\n      const imgData = chunk.image;\n      const format = imgData.format || 'PNG';\n      const dataUrl = `data:image/${format.toLowerCase()};base64,${imgData.base64_data}`;\n      const chunkText = `![${format} ${imgData.width}x${imgData.height}](${dataUrl})`;\n\n      // Create container for text + preview image\n      const container = document.createElement('span');\n      container.className = 'tp-chunk-image-container';\n      container.id = toElementId(chunk.id);\n\n      // Text placeholder\n      const textSpan = document.createElement('span');\n      textSpan.className = 'tp-chunk-image';\n      textSpan.textContent = chunkText;\n\n      // Hidden preview image (shown on hover via CSS)\n      const previewImg = document.createElement('img');\n      previewImg.className = 'tp-chunk-image-preview';\n      previewImg.src = dataUrl;\n      previewImg.alt = `${format} ${imgData.width}x${imgData.height}`;\n\n      container.appendChild(textSpan);\n      container.appendChild(previewImg);\n\n      chunkElement = container;\n    } else {\n      // Unknown chunk type - empty span\n      const span = document.createElement('span');\n      span.id = toElementId(chunk.id);\n      chunkElement = span;\n    }\n\n    // Add to chunks map\n    chunks.set(chunk.id, chunkElement);\n\n    // Append to DOM\n    element.appendChild(chunkElement);\n  }\n\n  return state;\n}\n", "/**\n * Typing Transform\n *\n * Adds type-based CSS classes to chunks and source location tooltips.\n * This enables semantic coloring and provides developer metadata on hover.\n */\n\nimport type { TransformState } from './base';\n\n/**\n * Add type classes and location tooltips to all chunks\n */\nexport function applyTransform_AddTyping(state: TransformState): TransformState {\n  const { chunks, data, metadata } = state;\n\n  if (!data.ir?.chunks) {\n    return state;\n  }\n\n  for (const chunk of data.ir.chunks) {\n    const chunkElement = chunks.get(chunk.id);\n    if (!chunkElement) continue;\n\n    // Determine element type and apply CSS class\n    const elementType = metadata.elementTypeMap[chunk.element_id] || 'unknown';\n\n    // For image chunks, the class is already set on the text span, not the container\n    if (chunk.type === 'ImageChunk') {\n      // Find the text span inside the container\n      const textSpan = chunkElement.querySelector('.tp-chunk-image');\n      if (textSpan) {\n        // The class is already set, just add location\n        const location = metadata.elementLocationMap[chunk.element_id];\n        if (location) {\n          textSpan.setAttribute('title', location);\n        }\n      }\n    } else {\n      // Regular text chunk - set class and title\n      chunkElement.className = `tp-chunk-${elementType}`;\n\n      // Add source location as title (hover tooltip) if available\n      const location = metadata.elementLocationMap[chunk.element_id];\n      if (location) {\n        chunkElement.title = location;\n      }\n    }\n  }\n\n  return state;\n}\n", "/**\n * Boundaries Transform\n *\n * Marks first and last chunks of each element with boundary classes.\n * This enables visual boundary indicators (colored bars) in the CSS.\n */\n\nimport type { TransformState } from './base';\nimport { toElementId } from './base';\n\n/**\n * Mark first and last chunks for each element\n */\nexport function applyTransform_MarkBoundaries(state: TransformState): TransformState {\n  const { element, data, metadata } = state;\n\n  if (!data.compiled_ir?.subtree_map) {\n    return state;\n  }\n\n  // Iterate through each element and its chunks\n  for (const [elementId, chunkIds] of Object.entries(data.compiled_ir.subtree_map)) {\n    if (chunkIds.length === 0) {\n      continue;\n    }\n\n    // Get element type for this element\n    const elementType = metadata.elementTypeMap[elementId] || 'unknown';\n\n    // Mark first chunk - convert Python UUID to element ID for DOM query\n    const firstChunkId = chunkIds[0];\n    const firstSpan = element.querySelector(`[id=\"${toElementId(firstChunkId)}\"]`);\n    if (firstSpan) {\n      firstSpan.classList.add(`tp-first-${elementType}`);\n    }\n\n    // Mark last chunk\n    const lastChunkId = chunkIds[chunkIds.length - 1];\n    const lastSpan = element.querySelector(`[id=\"${toElementId(lastChunkId)}\"]`);\n    if (lastSpan) {\n      lastSpan.classList.add(`tp-last-${elementType}`);\n    }\n  }\n\n  return state;\n}\n", "/**\n * Text Mapping Transform\n *\n * Builds bidirectional mapping between text positions and chunks.\n * This enables O(1) lookups for text selection, search, and highlighting.\n */\n\nimport type { TransformState } from './base';\nimport type { TextMapping } from '../types';\n\n/**\n * Build bidirectional text mapping\n */\nexport function applyTransform_BuildTextMapping(state: TransformState): TransformState {\n  const { data } = state;\n\n  if (!data.ir?.chunks) {\n    return state;\n  }\n\n  // Initialize mapping structures\n  let fullText = '';\n  const offsetToChunkId: string[] = [];\n  const chunkIdToOffsets: Record<string, { start: number; end: number }> = {};\n\n  // Process each chunk\n  for (const chunk of data.ir.chunks) {\n    // Get text for this chunk\n    let chunkText = '';\n    if (chunk.type === 'TextChunk' && chunk.text !== undefined) {\n      chunkText = chunk.text;\n    } else if (chunk.type === 'ImageChunk' && chunk.image) {\n      // Image chunks have placeholder text\n      const imgData = chunk.image;\n      const format = imgData.format || 'PNG';\n      const dataUrl = `data:image/${format.toLowerCase()};base64,${imgData.base64_data}`;\n      chunkText = `![${format} ${imgData.width}x${imgData.height}](${dataUrl})`;\n    }\n\n    // Record offsets\n    const start = fullText.length;\n    const end = start + chunkText.length;\n\n    // Add to full text\n    fullText += chunkText;\n\n    // Map each character offset to chunk ID\n    for (let i = start; i < end; i++) {\n      offsetToChunkId.push(chunk.id);\n    }\n\n    // Map chunk ID to offsets\n    chunkIdToOffsets[chunk.id] = { start, end };\n  }\n\n  // Create text mapping\n  const textMapping: TextMapping = {\n    fullText,\n    offsetToChunkId,\n    chunkIdToOffsets,\n  };\n\n  return {\n    ...state,\n    textMapping,\n  };\n}\n", "/**\n * Code View Component\n *\n * Renders text output with semantic coloring and element boundaries.\n * Uses a transform pipeline to incrementally build and annotate the DOM.\n */\n\nimport type { Component } from './base';\nimport type { WidgetData, WidgetMetadata, TextMapping } from '../types';\nimport type { TransformState } from '../transforms/base';\nimport { applyTransform_CreateChunks } from '../transforms/createChunks';\nimport { applyTransform_AddTyping } from '../transforms/typing';\nimport { applyTransform_MarkBoundaries } from '../transforms/boundaries';\nimport { applyTransform_BuildTextMapping } from '../transforms/textMapping';\n\n/**\n * Code view component interface\n */\nexport interface CodeView extends Component {\n  // Text-specific data\n  textMapping: TextMapping | null;\n  chunks: Map<string, HTMLElement>; // chunkId \u2192 DOM element\n\n  // Operations\n  highlightRange(start: number, end: number): void;\n  clearHighlight(): void;\n}\n\n/**\n * Build a CodeView component from widget data and metadata\n */\nexport function buildCodeView(data: WidgetData, metadata: WidgetMetadata): CodeView {\n  // 1. Create initial DOM structure\n  const element = document.createElement('div');\n  element.className = 'tp-output-container wrap';\n\n  // 2. Build chunks map\n  const chunks = new Map<string, HTMLElement>();\n\n  // 3. Apply transformation pipeline\n  let state: TransformState = { element, chunks, data, metadata };\n\n  // Transform pipeline - each function modifies state\n  state = applyTransform_CreateChunks(state);\n  state = applyTransform_AddTyping(state);\n  state = applyTransform_BuildTextMapping(state);\n  state = applyTransform_MarkBoundaries(state);\n\n  // Future transforms can be added here:\n  // state = applyTransform_LineWrapping(state);\n  // state = applyTransform_SyntaxHighlighting(state);\n\n  // 4. Return component with operations\n  return {\n    element: state.element,\n    textMapping: state.textMapping || null,\n    chunks: state.chunks,\n\n    hide(ids: string[]): void {\n      ids.forEach((id) => {\n        const el = chunks.get(id);\n        if (el) el.style.display = 'none';\n      });\n    },\n\n    show(ids: string[]): void {\n      ids.forEach((id) => {\n        const el = chunks.get(id);\n        if (el) el.style.display = '';\n      });\n    },\n\n    destroy(): void {\n      element.remove();\n      chunks.clear();\n    },\n\n    highlightRange(start: number, end: number): void {\n      // Future: Use textMapping to find chunks and highlight them\n      console.log(`Highlight range: ${start}-${end}`);\n    },\n\n    clearHighlight(): void {\n      // Future: Clear highlight styling\n      console.log('Clear highlight');\n    },\n  };\n}\n", "/**\n * Widget Container Component\n *\n * Top-level container that orchestrates multiple views and toolbars.\n * Currently contains just CodeView, but designed to support:\n * - Toolbar for view switching and controls\n * - Multiple visualization views (tree, table, etc.)\n */\n\nimport type { Component } from './base';\nimport type { WidgetData, WidgetMetadata } from '../types';\nimport { buildCodeView } from './CodeView';\n\n/**\n * Widget container component interface\n */\nexport interface WidgetContainer extends Component {\n  // Container-specific\n  views: Component[]; // Child components\n  toolbar?: HTMLElement; // Future: toolbar\n\n  // Operations\n  addView(view: Component): void;\n  removeView(view: Component): void;\n}\n\n/**\n * Build a WidgetContainer component from widget data and metadata\n */\nexport function buildWidgetContainer(data: WidgetData, metadata: WidgetMetadata): WidgetContainer {\n  // 1. Create root element\n  const element = document.createElement('div');\n  element.className = 'tp-widget-output';\n\n  // 2. Build code view\n  const codeView = buildCodeView(data, metadata);\n\n  // 3. Assemble\n  // Future: Add toolbar here\n  // const toolbar = createToolbar();\n  // element.appendChild(toolbar);\n\n  element.appendChild(codeView.element);\n\n  // 4. Track views\n  const views: Component[] = [codeView];\n\n  // 5. Return component\n  return {\n    element,\n    views,\n    toolbar: undefined, // Future\n\n    hide(ids: string[]): void {\n      // Delegate to all views\n      views.forEach((view) => view.hide(ids));\n    },\n\n    show(ids: string[]): void {\n      // Delegate to all views\n      views.forEach((view) => view.show(ids));\n    },\n\n    destroy(): void {\n      // Cleanup all views\n      views.forEach((view) => view.destroy());\n      element.remove();\n    },\n\n    addView(view: Component): void {\n      views.push(view);\n      element.appendChild(view.element);\n    },\n\n    removeView(view: Component): void {\n      const index = views.indexOf(view);\n      if (index !== -1) {\n        views.splice(index, 1);\n        view.element.remove();\n      }\n    },\n  };\n}\n", "/**\n * Widget renderer - main orchestrator\n *\n * Simplified to just:\n * 1. Parse JSON data\n * 2. Compute metadata\n * 3. Build widget component\n * 4. Mount to DOM\n */\n\nimport type { WidgetData } from './types';\nimport { computeWidgetMetadata } from './metadata';\nimport { buildWidgetContainer } from './components/WidgetContainer';\n\n/**\n * Initialize a widget in the given container\n *\n * This is the main entry point called by index.ts\n */\nexport function initWidget(container: HTMLElement): void {\n  try {\n    // 1. Parse embedded JSON data\n    const scriptTag = container.querySelector('script[data-role=\"tp-widget-data\"]');\n    if (!scriptTag || !scriptTag.textContent) {\n      container.innerHTML = '<div class=\"tp-error\">No widget data found</div>';\n      return;\n    }\n\n    const data: WidgetData = JSON.parse(scriptTag.textContent);\n\n    // 2. Validate data\n    if (!data.ir || !data.ir.chunks) {\n      container.innerHTML = '<div class=\"tp-error\">No chunks found in widget data</div>';\n      return;\n    }\n\n    // 3. Compute metadata (Phase 1 & 2)\n    const metadata = computeWidgetMetadata(data);\n\n    // 4. Build widget component (Phase 3)\n    const widget = buildWidgetContainer(data, metadata);\n\n    // 5. Mount to DOM\n    const mountPoint = container.querySelector('.tp-widget-mount');\n    if (mountPoint) {\n      mountPoint.innerHTML = '';\n      mountPoint.appendChild(widget.element);\n    } else {\n      container.innerHTML = '';\n      container.appendChild(widget.element);\n    }\n\n    // 6. Store component reference for future access\n    (container as HTMLElement & { _widgetComponent?: typeof widget })._widgetComponent = widget;\n  } catch (error) {\n    console.error('Widget initialization error:', error);\n    container.innerHTML = `<div class=\"tp-error\">Failed to initialize widget: ${\n      error instanceof Error ? error.message : String(error)\n    }</div>`;\n  }\n}\n", "/* T-Prompts Widget Styles */\n\n/* =============================================================================\n   CSS VARIABLES FOR THEMING\n   ============================================================================= */\n\n/* Base UI Variables */\n:root {\n  --tp-color-bg: #ffffff;\n  --tp-color-fg: #24292e;\n  --tp-color-border: #e1e4e8;\n  --tp-color-accent: #0366d6;\n  --tp-color-muted: #6a737d;\n  --tp-color-error: #d73a49;\n  --tp-font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;\n  --tp-font-mono: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;\n  --tp-spacing: 8px;\n\n  /* ==========================================================================\n     TIER 1: PALETTE PRIMITIVES - Hue values for each element type\n     ========================================================================== */\n  --tp-hue-static: 220;         /* Neutral blue-gray */\n  --tp-hue-interpolation: 212;  /* Blue - dynamic data */\n  --tp-hue-nested: 270;         /* Purple - compositional structure */\n  --tp-hue-list: 160;           /* Teal - collections */\n  --tp-hue-image: 30;           /* Orange - media */\n  --tp-hue-unknown: 0;          /* Red - warning/edge case */\n\n  /* ==========================================================================\n     TIER 2: SEMANTIC TOKENS - Light Mode\n     Saturation, lightness, and alpha values for foregrounds and backgrounds\n     ========================================================================== */\n\n  /* Static text - minimal styling (baseline) */\n  --tp-static-fg-s: 15%;\n  --tp-static-fg-l: 30%;\n  --tp-static-bg-alpha: 0.04;\n\n  /* Interpolations - blue, medium visibility */\n  --tp-interp-fg-s: 80%;\n  --tp-interp-fg-l: 35%;\n  --tp-interp-bg-alpha: 0.10;\n\n  /* Nested prompts - purple, slightly stronger */\n  --tp-nested-fg-s: 75%;\n  --tp-nested-fg-l: 38%;\n  --tp-nested-bg-alpha: 0.12;\n\n  /* Lists - teal, medium tint (increased visibility) */\n  --tp-list-fg-s: 80%;\n  --tp-list-fg-l: 32%;\n  --tp-list-bg-alpha: 0.14;\n\n  /* Images - orange, distinct */\n  --tp-image-fg-s: 85%;\n  --tp-image-fg-l: 40%;\n  --tp-image-bg-alpha: 0.10;\n\n  /* Unknown - red, warning signal */\n  --tp-unknown-fg-s: 80%;\n  --tp-unknown-fg-l: 45%;\n  --tp-unknown-bg-alpha: 0.12;\n}\n\n/* Dark Mode Overrides */\n@media (prefers-color-scheme: dark) {\n  :root {\n    --tp-color-bg: #0d1117;\n    --tp-color-fg: #c9d1d9;\n    --tp-color-border: #30363d;\n    --tp-color-accent: #58a6ff;\n    --tp-color-muted: #8b949e;\n    --tp-color-error: #f85149;\n\n    /* ==========================================================================\n       TIER 2: SEMANTIC TOKENS - Dark Mode Overrides\n       Higher lightness for foregrounds, higher alpha for backgrounds\n       ========================================================================== */\n\n    /* Static text */\n    --tp-static-fg-l: 75%;\n    --tp-static-bg-alpha: 0.08;\n\n    /* Interpolations */\n    --tp-interp-fg-l: 75%;\n    --tp-interp-bg-alpha: 0.18;\n\n    /* Nested prompts */\n    --tp-nested-fg-l: 78%;\n    --tp-nested-bg-alpha: 0.22;\n\n    /* Lists */\n    --tp-list-fg-l: 72%;\n    --tp-list-bg-alpha: 0.24;\n\n    /* Images */\n    --tp-image-fg-l: 80%;\n    --tp-image-bg-alpha: 0.18;\n\n    /* Unknown */\n    --tp-unknown-fg-l: 75%;\n    --tp-unknown-bg-alpha: 0.22;\n  }\n}\n\n/* Main widget container - three-pane grid layout */\n.tp-widget-container {\n  display: grid;\n  grid-template-columns: 1fr 1fr 1fr;\n  gap: var(--tp-spacing);\n  font-family: var(--tp-font-family);\n  font-size: 14px;\n  color: var(--tp-color-fg);\n  background: var(--tp-color-bg);\n  border: 1px solid var(--tp-color-border);\n  border-radius: 6px;\n  padding: var(--tp-spacing);\n  margin: calc(var(--tp-spacing) * 2) 0;\n  max-width: 100%;\n  overflow: hidden;\n}\n\n/* Output container for chunks */\n.tp-output-container {\n  font-family: var(--tp-font-mono);\n  font-size: 12px;\n  line-height: 1.6;\n  color: var(--tp-color-fg);\n  max-width: 100ch;\n  word-break: break-all;\n  position: relative;\n}\n\n/* Wrapping mode (default) */\n.tp-output-container.wrap {\n  white-space: pre-wrap;\n}\n\n/* Scrolling mode (horizontal scroll, no wrapping) */\n.tp-output-container.scroll {\n  white-space: pre;\n  overflow-x: auto;\n}\n\n/* =============================================================================\n   TIER 3: APPLIED STYLES - Chunk Element Types\n   Semantic colors applied using the three-tier variable system\n   ============================================================================= */\n\n/* Static text - neutral baseline */\n.tp-chunk-static {\n  white-space: pre-wrap;\n  color: hsl(\n    var(--tp-hue-static),\n    var(--tp-static-fg-s),\n    var(--tp-static-fg-l)\n  );\n  background: hsla(\n    var(--tp-hue-static),\n    20%,\n    60%,\n    var(--tp-static-bg-alpha)\n  );\n}\n\n/* Interpolations - blue for dynamic data */\n.tp-chunk-interpolation {\n  white-space: pre-wrap;\n  color: hsl(\n    var(--tp-hue-interpolation),\n    var(--tp-interp-fg-s),\n    var(--tp-interp-fg-l)\n  );\n  background: hsla(\n    var(--tp-hue-interpolation),\n    80%,\n    60%,\n    var(--tp-interp-bg-alpha)\n  );\n}\n\n/* Nested prompts - purple for composition */\n.tp-chunk-nested_prompt {\n  white-space: pre-wrap;\n  color: hsl(\n    var(--tp-hue-nested),\n    var(--tp-nested-fg-s),\n    var(--tp-nested-fg-l)\n  );\n  background: hsla(\n    var(--tp-hue-nested),\n    75%,\n    65%,\n    var(--tp-nested-bg-alpha)\n  );\n}\n\n/* Lists - teal for collections */\n.tp-chunk-list {\n  white-space: pre-wrap;\n  color: hsl(\n    var(--tp-hue-list),\n    var(--tp-list-fg-s),\n    var(--tp-list-fg-l)\n  );\n  background: hsla(\n    var(--tp-hue-list),\n    70%,\n    60%,\n    var(--tp-list-bg-alpha)\n  );\n}\n\n/* Images - orange for media, with text elision */\n.tp-chunk-image {\n  white-space: nowrap;\n  max-width: 200px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  display: inline-block;\n  vertical-align: middle;\n  color: hsl(\n    var(--tp-hue-image),\n    var(--tp-image-fg-s),\n    var(--tp-image-fg-l)\n  );\n  background: hsla(\n    var(--tp-hue-image),\n    85%,\n    65%,\n    var(--tp-image-bg-alpha)\n  );\n}\n\n/* Image container for hover preview */\n.tp-chunk-image-container {\n  position: relative;\n  display: inline-block;\n}\n\n/* Hidden image preview - shown on hover */\n.tp-chunk-image-preview {\n  display: none;\n  position: absolute;\n  left: 100%;\n  top: 0;\n  margin-left: 8px;\n  z-index: 1000;\n  max-width: 400px;\n  max-height: 400px;\n  border: 2px solid var(--tp-color-border);\n  border-radius: 4px;\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n  background: var(--tp-color-bg);\n}\n\n/* Show preview on hover */\n.tp-chunk-image-container:hover .tp-chunk-image-preview {\n  display: block;\n}\n\n/* Unknown types - red warning */\n.tp-chunk-unknown {\n  white-space: pre-wrap;\n  color: hsl(\n    var(--tp-hue-unknown),\n    var(--tp-unknown-fg-s),\n    var(--tp-unknown-fg-l)\n  );\n  background: hsla(\n    var(--tp-hue-unknown),\n    80%,\n    60%,\n    var(--tp-unknown-bg-alpha)\n  );\n}\n\n/* Element boundary markers - type-specific borders */\n/* Borders use each element type's semantic hue for visual consistency */\n\n/* No borders for static elements (baseline) */\n.tp-first-static,\n.tp-last-static {\n  /* Static elements have no boundary borders */\n}\n\n/* 1px borders for interpolation (blue, hue 212) */\n.tp-first-interpolation {\n  box-shadow: inset 1px 0 0 0 hsl(212, 90%, 45%);\n  padding-left: 1px;\n}\n\n.tp-last-interpolation {\n  box-shadow: inset -1px 0 0 0 hsl(212, 90%, 55%);\n  padding-right: 1px;\n}\n\n/* 1px borders for image (orange, hue 30) */\n.tp-first-image {\n  box-shadow: inset 1px 0 0 0 hsl(30, 90%, 50%);\n  padding-left: 1px;\n}\n\n.tp-last-image {\n  box-shadow: inset -1px 0 0 0 hsl(30, 90%, 60%);\n  padding-right: 1px;\n}\n\n\n/* 1px borders for nested_prompt (purple, hue 270) */\n.tp-first-nested_prompt {\n  box-shadow: inset 1px 0 0 0 hsl(270, 85%, 50%);\n  padding-left: 1px;\n}\n\n.tp-last-nested_prompt {\n  box-shadow: inset -1px 0 0 0 hsl(270, 85%, 60%);\n  padding-right: 1px;\n}\n\n/* 1px borders for list (teal, hue 160) - higher priority, placed last */\n.tp-first-list {\n  box-shadow: inset 1px 0 0 0 hsl(160, 80%, 40%);\n  padding-left: 1px;\n}\n\n.tp-last-list {\n  box-shadow: inset -1px 0 0 0 hsl(160, 80%, 50%);\n  padding-right: 1px;\n}\n\n\n/* Dark mode adjustments for boundaries - lighter colors for better visibility */\n@media (prefers-color-scheme: dark) {\n  .tp-first-interpolation {\n    box-shadow: inset 1px 0 0 0 hsl(212, 90%, 60%);\n  }\n\n  .tp-last-interpolation {\n    box-shadow: inset -1px 0 0 0 hsl(212, 90%, 70%);\n  }\n\n  .tp-first-image {\n    box-shadow: inset 1px 0 0 0 hsl(30, 90%, 65%);\n  }\n\n  .tp-last-image {\n    box-shadow: inset -1px 0 0 0 hsl(30, 90%, 75%);\n  }\n\n  .tp-first-nested_prompt {\n    box-shadow: inset 1px 0 0 0 hsl(270, 85%, 65%);\n  }\n\n  .tp-last-nested_prompt {\n    box-shadow: inset -1px 0 0 0 hsl(270, 85%, 75%);\n  }\n\n  .tp-first-list {\n    box-shadow: inset 1px 0 0 0 hsl(160, 80%, 55%);\n  }\n\n  .tp-last-list {\n    box-shadow: inset -1px 0 0 0 hsl(160, 80%, 65%);\n  }\n}\n\n/* Error display */\n.tp-error {\n  color: var(--tp-color-error);\n  font-family: var(--tp-font-mono);\n  font-size: 12px;\n  padding: var(--tp-spacing);\n  background: rgba(248, 81, 73, 0.1);\n  border: 1px solid var(--tp-color-error);\n  border-radius: 4px;\n  margin: var(--tp-spacing) 0;\n}\n\n/* Responsive layout */\n@media (max-width: 1200px) {\n  .tp-widget-container {\n    grid-template-columns: 1fr;\n  }\n\n  .tp-pane {\n    max-height: 400px;\n  }\n}\n\n@media (min-width: 1201px) and (max-width: 1600px) {\n  .tp-widget-container {\n    grid-template-columns: 1fr 1fr;\n  }\n}\n", "// Auto-generated by build.js - do not edit manually\nexport const STYLES_HASH = 'c2093c0b';\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "VERSION", "initRuntime", "initWidget", "injectStyles", "trimSourcePrefix", "filepath", "prefix", "normalizedPrefix", "formatSourceLocation", "location", "sourcePrefix", "path", "relativePath", "buildElementLocationMap", "promptData", "map", "walkElements", "elements", "element", "sourceLoc", "creationLoc", "buildElementTypeMap", "computeWidgetMetadata", "data", "toElementId", "pythonId", "applyTransform_CreateChunks", "state", "element", "chunks", "data", "chunk", "chunkElement", "span", "toElementId", "imgData", "format", "dataUrl", "chunkText", "container", "textSpan", "previewImg", "applyTransform_AddTyping", "state", "chunks", "data", "metadata", "chunk", "chunkElement", "elementType", "textSpan", "location", "applyTransform_MarkBoundaries", "state", "element", "data", "metadata", "elementId", "chunkIds", "elementType", "firstChunkId", "firstSpan", "toElementId", "lastChunkId", "lastSpan", "applyTransform_BuildTextMapping", "state", "data", "fullText", "offsetToChunkId", "chunkIdToOffsets", "chunk", "chunkText", "imgData", "format", "dataUrl", "start", "end", "i", "buildCodeView", "data", "metadata", "element", "chunks", "state", "applyTransform_CreateChunks", "applyTransform_AddTyping", "applyTransform_BuildTextMapping", "applyTransform_MarkBoundaries", "ids", "id", "el", "start", "end", "buildWidgetContainer", "data", "metadata", "element", "codeView", "buildCodeView", "views", "ids", "view", "index", "initWidget", "container", "scriptTag", "data", "metadata", "computeWidgetMetadata", "widget", "buildWidgetContainer", "mountPoint", "error", "styles_default", "STYLES_HASH", "VERSION", "injectStyles", "styleId", "STYLES_HASH", "el", "styleElement", "styles_default", "initRuntime", "initWidget", "autoInit", "container", "mutations", "mutation", "node", "widget"]
}
