# coding: utf-8

"""
    Cobo Wallet as a Service 2.0

    Contact: help@cobo.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated
from cobo_waas2.models.create_swap_activity_request import CreateSwapActivityRequest
from cobo_waas2.models.estimated_fee import EstimatedFee
from cobo_waas2.models.list_swap_activities200_response import ListSwapActivities200Response
from cobo_waas2.models.list_swap_enabled_tokens200_response import ListSwapEnabledTokens200Response
from cobo_waas2.models.swap_activity_detail import SwapActivityDetail
from cobo_waas2.models.swap_activity_status import SwapActivityStatus
from cobo_waas2.models.swap_estimate_fee import SwapEstimateFee
from cobo_waas2.models.swap_quote import SwapQuote
from cobo_waas2.models.swap_type import SwapType

from cobo_waas2.api_client import ApiClient, RequestSerialized
from cobo_waas2.api_response import ApiResponse
from cobo_waas2.rest import RESTResponseType


class SwapsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client: ApiClient = None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def create_swap_activity(
        self,
        create_swap_activity_request: Annotated[CreateSwapActivityRequest, Field(description="The request body for creating a swap activity.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> SwapActivityDetail:
        """Create swap activity

        This operation creates a swap activity. A swap activity can be either a bridge (cross-chain transfer) or an exchange (token-to-token swap on the same chain). 

        :param create_swap_activity_request: The request body for creating a swap activity. (required)
        :type create_swap_activity_request: CreateSwapActivityRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_swap_activity_serialize(
            create_swap_activity_request=create_swap_activity_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "SwapActivityDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_swap_activity_with_http_info(
        self,
        create_swap_activity_request: Annotated[CreateSwapActivityRequest, Field(description="The request body for creating a swap activity.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[SwapActivityDetail]:
        """Create swap activity

        This operation creates a swap activity. A swap activity can be either a bridge (cross-chain transfer) or an exchange (token-to-token swap on the same chain). 

        :param create_swap_activity_request: The request body for creating a swap activity. (required)
        :type create_swap_activity_request: CreateSwapActivityRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_swap_activity_serialize(
            create_swap_activity_request=create_swap_activity_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "SwapActivityDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_swap_activity_without_preload_content(
        self,
        create_swap_activity_request: Annotated[CreateSwapActivityRequest, Field(description="The request body for creating a swap activity.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Create swap activity

        This operation creates a swap activity. A swap activity can be either a bridge (cross-chain transfer) or an exchange (token-to-token swap on the same chain). 

        :param create_swap_activity_request: The request body for creating a swap activity. (required)
        :type create_swap_activity_request: CreateSwapActivityRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_swap_activity_serialize(
            create_swap_activity_request=create_swap_activity_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "SwapActivityDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_swap_activity_serialize(
        self,
        create_swap_activity_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_swap_activity_request is not None:
            _body_params = create_swap_activity_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/swaps/swap',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def estimate_swap_fee(
        self,
        swap_estimate_fee: Annotated[SwapEstimateFee, Field(description="The request body for estimating the network fee of a swap activity.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> EstimatedFee:
        """Estimate swap fee

        This operation estimates the network fee of a swap activity. You can use this operation to estimate the network fee before initiating swap activities from MPC Wallets or Web3 Wallets.  It requires a valid `wallet_id` and `quote_id`, so you need to [get a swap quote](https://www.cobo.com/developers/v2/api-references/swaps/get-swap-quote) first. 

        :param swap_estimate_fee: The request body for estimating the network fee of a swap activity. (required)
        :type swap_estimate_fee: SwapEstimateFee
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._estimate_swap_fee_serialize(
            swap_estimate_fee=swap_estimate_fee,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "EstimatedFee",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def estimate_swap_fee_with_http_info(
        self,
        swap_estimate_fee: Annotated[SwapEstimateFee, Field(description="The request body for estimating the network fee of a swap activity.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[EstimatedFee]:
        """Estimate swap fee

        This operation estimates the network fee of a swap activity. You can use this operation to estimate the network fee before initiating swap activities from MPC Wallets or Web3 Wallets.  It requires a valid `wallet_id` and `quote_id`, so you need to [get a swap quote](https://www.cobo.com/developers/v2/api-references/swaps/get-swap-quote) first. 

        :param swap_estimate_fee: The request body for estimating the network fee of a swap activity. (required)
        :type swap_estimate_fee: SwapEstimateFee
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._estimate_swap_fee_serialize(
            swap_estimate_fee=swap_estimate_fee,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "EstimatedFee",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def estimate_swap_fee_without_preload_content(
        self,
        swap_estimate_fee: Annotated[SwapEstimateFee, Field(description="The request body for estimating the network fee of a swap activity.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Estimate swap fee

        This operation estimates the network fee of a swap activity. You can use this operation to estimate the network fee before initiating swap activities from MPC Wallets or Web3 Wallets.  It requires a valid `wallet_id` and `quote_id`, so you need to [get a swap quote](https://www.cobo.com/developers/v2/api-references/swaps/get-swap-quote) first. 

        :param swap_estimate_fee: The request body for estimating the network fee of a swap activity. (required)
        :type swap_estimate_fee: SwapEstimateFee
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._estimate_swap_fee_serialize(
            swap_estimate_fee=swap_estimate_fee,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "EstimatedFee",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _estimate_swap_fee_serialize(
        self,
        swap_estimate_fee,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if swap_estimate_fee is not None:
            _body_params = swap_estimate_fee

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/swaps/estimate_fee',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_swap_activity(
        self,
        activity_id: Annotated[StrictStr, Field(description="The unique identifier of the swap activity.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> SwapActivityDetail:
        """Get swap activity

        This operation retrieves detailed information about a specified swap activity. 

        :param activity_id: The unique identifier of the swap activity. (required)
        :type activity_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_swap_activity_serialize(
            activity_id=activity_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SwapActivityDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_swap_activity_with_http_info(
        self,
        activity_id: Annotated[StrictStr, Field(description="The unique identifier of the swap activity.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[SwapActivityDetail]:
        """Get swap activity

        This operation retrieves detailed information about a specified swap activity. 

        :param activity_id: The unique identifier of the swap activity. (required)
        :type activity_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_swap_activity_serialize(
            activity_id=activity_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SwapActivityDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_swap_activity_without_preload_content(
        self,
        activity_id: Annotated[StrictStr, Field(description="The unique identifier of the swap activity.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get swap activity

        This operation retrieves detailed information about a specified swap activity. 

        :param activity_id: The unique identifier of the swap activity. (required)
        :type activity_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_swap_activity_serialize(
            activity_id=activity_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SwapActivityDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_swap_activity_serialize(
        self,
        activity_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if activity_id is not None:
            _path_params['activity_id'] = activity_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/swaps/activities/{activity_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_swap_quote(
        self,
        wallet_id: Annotated[StrictStr, Field(description="The wallet ID.")],
        pay_token_id: Annotated[StrictStr, Field(description="The ID of the token to pay.")],
        receive_token_id: Annotated[StrictStr, Field(description="The ID of the token to receive.")],
        pay_amount: Annotated[Optional[StrictStr], Field(description="The amount of the token to pay.")] = None,
        receive_amount: Annotated[Optional[StrictStr], Field(description="The amount of the token to receive.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> SwapQuote:
        """Get swap quote

        This operation retrieves the current market exchange rate and estimated service fee. You need to provide `wallet_id`, `pay_token_id`, and `receive_token_id`, along with either `pay_amount` or `receive_amount`. 

        :param wallet_id: The wallet ID. (required)
        :type wallet_id: str
        :param pay_token_id: The ID of the token to pay. (required)
        :type pay_token_id: str
        :param receive_token_id: The ID of the token to receive. (required)
        :type receive_token_id: str
        :param pay_amount: The amount of the token to pay.
        :type pay_amount: str
        :param receive_amount: The amount of the token to receive.
        :type receive_amount: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_swap_quote_serialize(
            wallet_id=wallet_id,
            pay_token_id=pay_token_id,
            receive_token_id=receive_token_id,
            pay_amount=pay_amount,
            receive_amount=receive_amount,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SwapQuote",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_swap_quote_with_http_info(
        self,
        wallet_id: Annotated[StrictStr, Field(description="The wallet ID.")],
        pay_token_id: Annotated[StrictStr, Field(description="The ID of the token to pay.")],
        receive_token_id: Annotated[StrictStr, Field(description="The ID of the token to receive.")],
        pay_amount: Annotated[Optional[StrictStr], Field(description="The amount of the token to pay.")] = None,
        receive_amount: Annotated[Optional[StrictStr], Field(description="The amount of the token to receive.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[SwapQuote]:
        """Get swap quote

        This operation retrieves the current market exchange rate and estimated service fee. You need to provide `wallet_id`, `pay_token_id`, and `receive_token_id`, along with either `pay_amount` or `receive_amount`. 

        :param wallet_id: The wallet ID. (required)
        :type wallet_id: str
        :param pay_token_id: The ID of the token to pay. (required)
        :type pay_token_id: str
        :param receive_token_id: The ID of the token to receive. (required)
        :type receive_token_id: str
        :param pay_amount: The amount of the token to pay.
        :type pay_amount: str
        :param receive_amount: The amount of the token to receive.
        :type receive_amount: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_swap_quote_serialize(
            wallet_id=wallet_id,
            pay_token_id=pay_token_id,
            receive_token_id=receive_token_id,
            pay_amount=pay_amount,
            receive_amount=receive_amount,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SwapQuote",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_swap_quote_without_preload_content(
        self,
        wallet_id: Annotated[StrictStr, Field(description="The wallet ID.")],
        pay_token_id: Annotated[StrictStr, Field(description="The ID of the token to pay.")],
        receive_token_id: Annotated[StrictStr, Field(description="The ID of the token to receive.")],
        pay_amount: Annotated[Optional[StrictStr], Field(description="The amount of the token to pay.")] = None,
        receive_amount: Annotated[Optional[StrictStr], Field(description="The amount of the token to receive.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get swap quote

        This operation retrieves the current market exchange rate and estimated service fee. You need to provide `wallet_id`, `pay_token_id`, and `receive_token_id`, along with either `pay_amount` or `receive_amount`. 

        :param wallet_id: The wallet ID. (required)
        :type wallet_id: str
        :param pay_token_id: The ID of the token to pay. (required)
        :type pay_token_id: str
        :param receive_token_id: The ID of the token to receive. (required)
        :type receive_token_id: str
        :param pay_amount: The amount of the token to pay.
        :type pay_amount: str
        :param receive_amount: The amount of the token to receive.
        :type receive_amount: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_swap_quote_serialize(
            wallet_id=wallet_id,
            pay_token_id=pay_token_id,
            receive_token_id=receive_token_id,
            pay_amount=pay_amount,
            receive_amount=receive_amount,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SwapQuote",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_swap_quote_serialize(
        self,
        wallet_id,
        pay_token_id,
        receive_token_id,
        pay_amount,
        receive_amount,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if wallet_id is not None:
            
            _query_params.append(('wallet_id', wallet_id))
            
        if pay_token_id is not None:
            
            _query_params.append(('pay_token_id', pay_token_id))
            
        if receive_token_id is not None:
            
            _query_params.append(('receive_token_id', receive_token_id))
            
        if pay_amount is not None:
            
            _query_params.append(('pay_amount', pay_amount))
            
        if receive_amount is not None:
            
            _query_params.append(('receive_amount', receive_amount))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/swaps/quote',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_swap_activities(
        self,
        type: Optional[SwapType] = None,
        status: Optional[SwapActivityStatus] = None,
        min_updated_timestamp: Annotated[Optional[StrictInt], Field(description="The start time of the query. All swap activities updated after the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.")] = None,
        max_updated_timestamp: Annotated[Optional[StrictInt], Field(description="The end time of the query. All swap activities updated before the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.")] = None,
        initiator: Annotated[Optional[StrictStr], Field(description="The initiator of the swap activity. It is optional when creating the activity and defaults to your API key if not specified.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="The field to sort the results by.   Possible values include: - `created_timestamp`: Sort by the time when the data was created. - `updated_timestamp`: Sort by the time when the data was last updated. ")] = None,
        direction: Annotated[Optional[StrictStr], Field(description="The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListSwapActivities200Response:
        """List swap activities

        This operation retrieves a list of swap activities. You can filter the results by swap type, status, initiator, and time range. 

        :param type:
        :type type: SwapType
        :param status:
        :type status: SwapActivityStatus
        :param min_updated_timestamp: The start time of the query. All swap activities updated after the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.
        :type min_updated_timestamp: int
        :param max_updated_timestamp: The end time of the query. All swap activities updated before the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.
        :type max_updated_timestamp: int
        :param initiator: The initiator of the swap activity. It is optional when creating the activity and defaults to your API key if not specified.
        :type initiator: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param sort_by: The field to sort the results by.   Possible values include: - `created_timestamp`: Sort by the time when the data was created. - `updated_timestamp`: Sort by the time when the data was last updated. 
        :type sort_by: str
        :param direction: The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. 
        :type direction: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_swap_activities_serialize(
            type=type,
            status=status,
            min_updated_timestamp=min_updated_timestamp,
            max_updated_timestamp=max_updated_timestamp,
            initiator=initiator,
            limit=limit,
            before=before,
            after=after,
            sort_by=sort_by,
            direction=direction,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListSwapActivities200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_swap_activities_with_http_info(
        self,
        type: Optional[SwapType] = None,
        status: Optional[SwapActivityStatus] = None,
        min_updated_timestamp: Annotated[Optional[StrictInt], Field(description="The start time of the query. All swap activities updated after the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.")] = None,
        max_updated_timestamp: Annotated[Optional[StrictInt], Field(description="The end time of the query. All swap activities updated before the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.")] = None,
        initiator: Annotated[Optional[StrictStr], Field(description="The initiator of the swap activity. It is optional when creating the activity and defaults to your API key if not specified.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="The field to sort the results by.   Possible values include: - `created_timestamp`: Sort by the time when the data was created. - `updated_timestamp`: Sort by the time when the data was last updated. ")] = None,
        direction: Annotated[Optional[StrictStr], Field(description="The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListSwapActivities200Response]:
        """List swap activities

        This operation retrieves a list of swap activities. You can filter the results by swap type, status, initiator, and time range. 

        :param type:
        :type type: SwapType
        :param status:
        :type status: SwapActivityStatus
        :param min_updated_timestamp: The start time of the query. All swap activities updated after the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.
        :type min_updated_timestamp: int
        :param max_updated_timestamp: The end time of the query. All swap activities updated before the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.
        :type max_updated_timestamp: int
        :param initiator: The initiator of the swap activity. It is optional when creating the activity and defaults to your API key if not specified.
        :type initiator: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param sort_by: The field to sort the results by.   Possible values include: - `created_timestamp`: Sort by the time when the data was created. - `updated_timestamp`: Sort by the time when the data was last updated. 
        :type sort_by: str
        :param direction: The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. 
        :type direction: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_swap_activities_serialize(
            type=type,
            status=status,
            min_updated_timestamp=min_updated_timestamp,
            max_updated_timestamp=max_updated_timestamp,
            initiator=initiator,
            limit=limit,
            before=before,
            after=after,
            sort_by=sort_by,
            direction=direction,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListSwapActivities200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_swap_activities_without_preload_content(
        self,
        type: Optional[SwapType] = None,
        status: Optional[SwapActivityStatus] = None,
        min_updated_timestamp: Annotated[Optional[StrictInt], Field(description="The start time of the query. All swap activities updated after the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.")] = None,
        max_updated_timestamp: Annotated[Optional[StrictInt], Field(description="The end time of the query. All swap activities updated before the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.")] = None,
        initiator: Annotated[Optional[StrictStr], Field(description="The initiator of the swap activity. It is optional when creating the activity and defaults to your API key if not specified.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="The field to sort the results by.   Possible values include: - `created_timestamp`: Sort by the time when the data was created. - `updated_timestamp`: Sort by the time when the data was last updated. ")] = None,
        direction: Annotated[Optional[StrictStr], Field(description="The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List swap activities

        This operation retrieves a list of swap activities. You can filter the results by swap type, status, initiator, and time range. 

        :param type:
        :type type: SwapType
        :param status:
        :type status: SwapActivityStatus
        :param min_updated_timestamp: The start time of the query. All swap activities updated after the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.
        :type min_updated_timestamp: int
        :param max_updated_timestamp: The end time of the query. All swap activities updated before the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.
        :type max_updated_timestamp: int
        :param initiator: The initiator of the swap activity. It is optional when creating the activity and defaults to your API key if not specified.
        :type initiator: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param sort_by: The field to sort the results by.   Possible values include: - `created_timestamp`: Sort by the time when the data was created. - `updated_timestamp`: Sort by the time when the data was last updated. 
        :type sort_by: str
        :param direction: The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. 
        :type direction: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_swap_activities_serialize(
            type=type,
            status=status,
            min_updated_timestamp=min_updated_timestamp,
            max_updated_timestamp=max_updated_timestamp,
            initiator=initiator,
            limit=limit,
            before=before,
            after=after,
            sort_by=sort_by,
            direction=direction,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListSwapActivities200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_swap_activities_serialize(
        self,
        type,
        status,
        min_updated_timestamp,
        max_updated_timestamp,
        initiator,
        limit,
        before,
        after,
        sort_by,
        direction,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if type is not None:
            
            _query_params.append(('type', type.value))
            
        if status is not None:
            
            _query_params.append(('status', status.value))
            
        if min_updated_timestamp is not None:
            
            _query_params.append(('min_updated_timestamp', min_updated_timestamp))
            
        if max_updated_timestamp is not None:
            
            _query_params.append(('max_updated_timestamp', max_updated_timestamp))
            
        if initiator is not None:
            
            _query_params.append(('initiator', initiator))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if sort_by is not None:
            
            _query_params.append(('sort_by', sort_by))
            
        if direction is not None:
            
            _query_params.append(('direction', direction))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/swaps/activities',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_swap_enabled_tokens(
        self,
        type: Optional[SwapType] = None,
        asset_id: Annotated[Optional[StrictStr], Field(description="(This concept applies to Exchange Wallets only) The asset ID. An asset ID is the unique identifier of the asset held within your linked exchange account.")] = None,
        chain_id: Annotated[Optional[StrictStr], Field(description="The chain ID, which is the unique identifier of a blockchain. You can retrieve the IDs of all the chains you can use by calling [List enabled chains](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-chains).")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListSwapEnabledTokens200Response:
        """List enabled tokens for swap

        This operation retrieves a list of tokens that are enabled for the swap feature. You can filter the results by swap type, asset ID, and chain ID. 

        :param type:
        :type type: SwapType
        :param asset_id: (This concept applies to Exchange Wallets only) The asset ID. An asset ID is the unique identifier of the asset held within your linked exchange account.
        :type asset_id: str
        :param chain_id: The chain ID, which is the unique identifier of a blockchain. You can retrieve the IDs of all the chains you can use by calling [List enabled chains](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-chains).
        :type chain_id: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_swap_enabled_tokens_serialize(
            type=type,
            asset_id=asset_id,
            chain_id=chain_id,
            limit=limit,
            before=before,
            after=after,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListSwapEnabledTokens200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_swap_enabled_tokens_with_http_info(
        self,
        type: Optional[SwapType] = None,
        asset_id: Annotated[Optional[StrictStr], Field(description="(This concept applies to Exchange Wallets only) The asset ID. An asset ID is the unique identifier of the asset held within your linked exchange account.")] = None,
        chain_id: Annotated[Optional[StrictStr], Field(description="The chain ID, which is the unique identifier of a blockchain. You can retrieve the IDs of all the chains you can use by calling [List enabled chains](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-chains).")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListSwapEnabledTokens200Response]:
        """List enabled tokens for swap

        This operation retrieves a list of tokens that are enabled for the swap feature. You can filter the results by swap type, asset ID, and chain ID. 

        :param type:
        :type type: SwapType
        :param asset_id: (This concept applies to Exchange Wallets only) The asset ID. An asset ID is the unique identifier of the asset held within your linked exchange account.
        :type asset_id: str
        :param chain_id: The chain ID, which is the unique identifier of a blockchain. You can retrieve the IDs of all the chains you can use by calling [List enabled chains](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-chains).
        :type chain_id: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_swap_enabled_tokens_serialize(
            type=type,
            asset_id=asset_id,
            chain_id=chain_id,
            limit=limit,
            before=before,
            after=after,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListSwapEnabledTokens200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_swap_enabled_tokens_without_preload_content(
        self,
        type: Optional[SwapType] = None,
        asset_id: Annotated[Optional[StrictStr], Field(description="(This concept applies to Exchange Wallets only) The asset ID. An asset ID is the unique identifier of the asset held within your linked exchange account.")] = None,
        chain_id: Annotated[Optional[StrictStr], Field(description="The chain ID, which is the unique identifier of a blockchain. You can retrieve the IDs of all the chains you can use by calling [List enabled chains](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-chains).")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List enabled tokens for swap

        This operation retrieves a list of tokens that are enabled for the swap feature. You can filter the results by swap type, asset ID, and chain ID. 

        :param type:
        :type type: SwapType
        :param asset_id: (This concept applies to Exchange Wallets only) The asset ID. An asset ID is the unique identifier of the asset held within your linked exchange account.
        :type asset_id: str
        :param chain_id: The chain ID, which is the unique identifier of a blockchain. You can retrieve the IDs of all the chains you can use by calling [List enabled chains](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-chains).
        :type chain_id: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_swap_enabled_tokens_serialize(
            type=type,
            asset_id=asset_id,
            chain_id=chain_id,
            limit=limit,
            before=before,
            after=after,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListSwapEnabledTokens200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_swap_enabled_tokens_serialize(
        self,
        type,
        asset_id,
        chain_id,
        limit,
        before,
        after,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if type is not None:
            
            _query_params.append(('type', type.value))
            
        if asset_id is not None:
            
            _query_params.append(('asset_id', asset_id))
            
        if chain_id is not None:
            
            _query_params.append(('chain_id', chain_id))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/swaps/enabled_tokens',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )
