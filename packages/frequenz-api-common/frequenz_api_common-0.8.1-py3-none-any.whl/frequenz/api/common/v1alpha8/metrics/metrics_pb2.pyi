"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Metrics definitions.

Copyright:
Copyright 2025 Frequenz Energy-as-a-Service GmbH

License:
MIT
"""

import builtins
import collections.abc
import frequenz.api.common.v1alpha8.metrics.bounds_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _Metric:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _MetricEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Metric.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    METRIC_UNSPECIFIED: _Metric.ValueType  # 0
    """Default value."""
    METRIC_DC_VOLTAGE: _Metric.ValueType  # 1
    """DC electricity metrics"""
    METRIC_DC_CURRENT: _Metric.ValueType  # 2
    METRIC_DC_POWER: _Metric.ValueType  # 3
    METRIC_AC_FREQUENCY: _Metric.ValueType  # 10
    """General AC electricity metrics"""
    METRIC_AC_VOLTAGE: _Metric.ValueType  # 11
    METRIC_AC_VOLTAGE_PHASE_1_N: _Metric.ValueType  # 12
    METRIC_AC_VOLTAGE_PHASE_2_N: _Metric.ValueType  # 13
    METRIC_AC_VOLTAGE_PHASE_3_N: _Metric.ValueType  # 14
    METRIC_AC_VOLTAGE_PHASE_1_PHASE_2: _Metric.ValueType  # 15
    METRIC_AC_VOLTAGE_PHASE_2_PHASE_3: _Metric.ValueType  # 16
    METRIC_AC_VOLTAGE_PHASE_3_PHASE_1: _Metric.ValueType  # 17
    METRIC_AC_CURRENT: _Metric.ValueType  # 18
    METRIC_AC_CURRENT_PHASE_1: _Metric.ValueType  # 19
    METRIC_AC_CURRENT_PHASE_2: _Metric.ValueType  # 20
    METRIC_AC_CURRENT_PHASE_3: _Metric.ValueType  # 21
    METRIC_AC_POWER_APPARENT: _Metric.ValueType  # 22
    """AC power metrics"""
    METRIC_AC_POWER_APPARENT_PHASE_1: _Metric.ValueType  # 23
    METRIC_AC_POWER_APPARENT_PHASE_2: _Metric.ValueType  # 24
    METRIC_AC_POWER_APPARENT_PHASE_3: _Metric.ValueType  # 25
    METRIC_AC_POWER_ACTIVE: _Metric.ValueType  # 26
    METRIC_AC_POWER_ACTIVE_PHASE_1: _Metric.ValueType  # 27
    METRIC_AC_POWER_ACTIVE_PHASE_2: _Metric.ValueType  # 28
    METRIC_AC_POWER_ACTIVE_PHASE_3: _Metric.ValueType  # 29
    METRIC_AC_POWER_REACTIVE: _Metric.ValueType  # 30
    METRIC_AC_POWER_REACTIVE_PHASE_1: _Metric.ValueType  # 31
    METRIC_AC_POWER_REACTIVE_PHASE_2: _Metric.ValueType  # 32
    METRIC_AC_POWER_REACTIVE_PHASE_3: _Metric.ValueType  # 33
    METRIC_AC_POWER_FACTOR: _Metric.ValueType  # 40
    """AC Power factor"""
    METRIC_AC_POWER_FACTOR_PHASE_1: _Metric.ValueType  # 41
    METRIC_AC_POWER_FACTOR_PHASE_2: _Metric.ValueType  # 42
    METRIC_AC_POWER_FACTOR_PHASE_3: _Metric.ValueType  # 43
    METRIC_AC_ENERGY_APPARENT: _Metric.ValueType  # 50
    """AC energy metrics"""
    METRIC_AC_ENERGY_APPARENT_PHASE_1: _Metric.ValueType  # 51
    METRIC_AC_ENERGY_APPARENT_PHASE_2: _Metric.ValueType  # 52
    METRIC_AC_ENERGY_APPARENT_PHASE_3: _Metric.ValueType  # 53
    METRIC_AC_ENERGY_ACTIVE: _Metric.ValueType  # 54
    METRIC_AC_ENERGY_ACTIVE_PHASE_1: _Metric.ValueType  # 55
    METRIC_AC_ENERGY_ACTIVE_PHASE_2: _Metric.ValueType  # 56
    METRIC_AC_ENERGY_ACTIVE_PHASE_3: _Metric.ValueType  # 57
    METRIC_AC_ENERGY_ACTIVE_CONSUMED: _Metric.ValueType  # 58
    METRIC_AC_ENERGY_ACTIVE_CONSUMED_PHASE_1: _Metric.ValueType  # 59
    METRIC_AC_ENERGY_ACTIVE_CONSUMED_PHASE_2: _Metric.ValueType  # 60
    METRIC_AC_ENERGY_ACTIVE_CONSUMED_PHASE_3: _Metric.ValueType  # 61
    METRIC_AC_ENERGY_ACTIVE_DELIVERED: _Metric.ValueType  # 62
    METRIC_AC_ENERGY_ACTIVE_DELIVERED_PHASE_1: _Metric.ValueType  # 63
    METRIC_AC_ENERGY_ACTIVE_DELIVERED_PHASE_2: _Metric.ValueType  # 64
    METRIC_AC_ENERGY_ACTIVE_DELIVERED_PHASE_3: _Metric.ValueType  # 65
    METRIC_AC_ENERGY_REACTIVE: _Metric.ValueType  # 66
    METRIC_AC_ENERGY_REACTIVE_PHASE_1: _Metric.ValueType  # 67
    METRIC_AC_ENERGY_REACTIVE_PHASE_2: _Metric.ValueType  # 68
    METRIC_AC_ENERGY_REACTIVE_PHASE_3: _Metric.ValueType  # 69
    METRIC_AC_TOTAL_HARMONIC_DISTORTION_CURRENT: _Metric.ValueType  # 80
    """AC harmonics"""
    METRIC_AC_TOTAL_HARMONIC_DISTORTION_CURRENT_PHASE_1: _Metric.ValueType  # 81
    METRIC_AC_TOTAL_HARMONIC_DISTORTION_CURRENT_PHASE_2: _Metric.ValueType  # 82
    METRIC_AC_TOTAL_HARMONIC_DISTORTION_CURRENT_PHASE_3: _Metric.ValueType  # 83
    METRIC_BATTERY_CAPACITY: _Metric.ValueType  # 100
    """General BMS metrics."""
    METRIC_BATTERY_SOC_PCT: _Metric.ValueType  # 101
    METRIC_BATTERY_TEMPERATURE: _Metric.ValueType  # 102
    METRIC_INVERTER_TEMPERATURE: _Metric.ValueType  # 120
    """General inverter metrics."""
    METRIC_INVERTER_TEMPERATURE_CABINET: _Metric.ValueType  # 121
    METRIC_INVERTER_TEMPERATURE_HEATSINK: _Metric.ValueType  # 122
    METRIC_INVERTER_TEMPERATURE_TRANSFORMER: _Metric.ValueType  # 123
    METRIC_EV_CHARGER_TEMPERATURE: _Metric.ValueType  # 140
    """EV charging station metrics."""
    METRIC_SENSOR_WIND_SPEED: _Metric.ValueType  # 160
    """General sensor metrics"""
    METRIC_SENSOR_WIND_DIRECTION: _Metric.ValueType  # 161
    METRIC_SENSOR_TEMPERATURE: _Metric.ValueType  # 162
    METRIC_SENSOR_RELATIVE_HUMIDITY: _Metric.ValueType  # 163
    METRIC_SENSOR_DEW_POINT: _Metric.ValueType  # 164
    METRIC_SENSOR_AIR_PRESSURE: _Metric.ValueType  # 165
    METRIC_SENSOR_IRRADIANCE: _Metric.ValueType  # 166

class Metric(_Metric, metaclass=_MetricEnumTypeWrapper):
    """List of supported metrics.

    !!! note
    AC energy metrics information:

    * This energy metric is reported directly from the component, and not a
     result of aggregations in our systems. If a component does not have this
     metric, this field cannot be populated.

     * Components that provide energy metrics reset this metric from time to
     time. This behaviour is specific to each component model. E.g., some
     components reset it on UTC 00:00:00.

     * This energy metric does not specify the timestamp since when the energy
     was being accumulated, and therefore can be inconsistent.
    """

METRIC_UNSPECIFIED: Metric.ValueType  # 0
"""Default value."""
METRIC_DC_VOLTAGE: Metric.ValueType  # 1
"""DC electricity metrics"""
METRIC_DC_CURRENT: Metric.ValueType  # 2
METRIC_DC_POWER: Metric.ValueType  # 3
METRIC_AC_FREQUENCY: Metric.ValueType  # 10
"""General AC electricity metrics"""
METRIC_AC_VOLTAGE: Metric.ValueType  # 11
METRIC_AC_VOLTAGE_PHASE_1_N: Metric.ValueType  # 12
METRIC_AC_VOLTAGE_PHASE_2_N: Metric.ValueType  # 13
METRIC_AC_VOLTAGE_PHASE_3_N: Metric.ValueType  # 14
METRIC_AC_VOLTAGE_PHASE_1_PHASE_2: Metric.ValueType  # 15
METRIC_AC_VOLTAGE_PHASE_2_PHASE_3: Metric.ValueType  # 16
METRIC_AC_VOLTAGE_PHASE_3_PHASE_1: Metric.ValueType  # 17
METRIC_AC_CURRENT: Metric.ValueType  # 18
METRIC_AC_CURRENT_PHASE_1: Metric.ValueType  # 19
METRIC_AC_CURRENT_PHASE_2: Metric.ValueType  # 20
METRIC_AC_CURRENT_PHASE_3: Metric.ValueType  # 21
METRIC_AC_POWER_APPARENT: Metric.ValueType  # 22
"""AC power metrics"""
METRIC_AC_POWER_APPARENT_PHASE_1: Metric.ValueType  # 23
METRIC_AC_POWER_APPARENT_PHASE_2: Metric.ValueType  # 24
METRIC_AC_POWER_APPARENT_PHASE_3: Metric.ValueType  # 25
METRIC_AC_POWER_ACTIVE: Metric.ValueType  # 26
METRIC_AC_POWER_ACTIVE_PHASE_1: Metric.ValueType  # 27
METRIC_AC_POWER_ACTIVE_PHASE_2: Metric.ValueType  # 28
METRIC_AC_POWER_ACTIVE_PHASE_3: Metric.ValueType  # 29
METRIC_AC_POWER_REACTIVE: Metric.ValueType  # 30
METRIC_AC_POWER_REACTIVE_PHASE_1: Metric.ValueType  # 31
METRIC_AC_POWER_REACTIVE_PHASE_2: Metric.ValueType  # 32
METRIC_AC_POWER_REACTIVE_PHASE_3: Metric.ValueType  # 33
METRIC_AC_POWER_FACTOR: Metric.ValueType  # 40
"""AC Power factor"""
METRIC_AC_POWER_FACTOR_PHASE_1: Metric.ValueType  # 41
METRIC_AC_POWER_FACTOR_PHASE_2: Metric.ValueType  # 42
METRIC_AC_POWER_FACTOR_PHASE_3: Metric.ValueType  # 43
METRIC_AC_ENERGY_APPARENT: Metric.ValueType  # 50
"""AC energy metrics"""
METRIC_AC_ENERGY_APPARENT_PHASE_1: Metric.ValueType  # 51
METRIC_AC_ENERGY_APPARENT_PHASE_2: Metric.ValueType  # 52
METRIC_AC_ENERGY_APPARENT_PHASE_3: Metric.ValueType  # 53
METRIC_AC_ENERGY_ACTIVE: Metric.ValueType  # 54
METRIC_AC_ENERGY_ACTIVE_PHASE_1: Metric.ValueType  # 55
METRIC_AC_ENERGY_ACTIVE_PHASE_2: Metric.ValueType  # 56
METRIC_AC_ENERGY_ACTIVE_PHASE_3: Metric.ValueType  # 57
METRIC_AC_ENERGY_ACTIVE_CONSUMED: Metric.ValueType  # 58
METRIC_AC_ENERGY_ACTIVE_CONSUMED_PHASE_1: Metric.ValueType  # 59
METRIC_AC_ENERGY_ACTIVE_CONSUMED_PHASE_2: Metric.ValueType  # 60
METRIC_AC_ENERGY_ACTIVE_CONSUMED_PHASE_3: Metric.ValueType  # 61
METRIC_AC_ENERGY_ACTIVE_DELIVERED: Metric.ValueType  # 62
METRIC_AC_ENERGY_ACTIVE_DELIVERED_PHASE_1: Metric.ValueType  # 63
METRIC_AC_ENERGY_ACTIVE_DELIVERED_PHASE_2: Metric.ValueType  # 64
METRIC_AC_ENERGY_ACTIVE_DELIVERED_PHASE_3: Metric.ValueType  # 65
METRIC_AC_ENERGY_REACTIVE: Metric.ValueType  # 66
METRIC_AC_ENERGY_REACTIVE_PHASE_1: Metric.ValueType  # 67
METRIC_AC_ENERGY_REACTIVE_PHASE_2: Metric.ValueType  # 68
METRIC_AC_ENERGY_REACTIVE_PHASE_3: Metric.ValueType  # 69
METRIC_AC_TOTAL_HARMONIC_DISTORTION_CURRENT: Metric.ValueType  # 80
"""AC harmonics"""
METRIC_AC_TOTAL_HARMONIC_DISTORTION_CURRENT_PHASE_1: Metric.ValueType  # 81
METRIC_AC_TOTAL_HARMONIC_DISTORTION_CURRENT_PHASE_2: Metric.ValueType  # 82
METRIC_AC_TOTAL_HARMONIC_DISTORTION_CURRENT_PHASE_3: Metric.ValueType  # 83
METRIC_BATTERY_CAPACITY: Metric.ValueType  # 100
"""General BMS metrics."""
METRIC_BATTERY_SOC_PCT: Metric.ValueType  # 101
METRIC_BATTERY_TEMPERATURE: Metric.ValueType  # 102
METRIC_INVERTER_TEMPERATURE: Metric.ValueType  # 120
"""General inverter metrics."""
METRIC_INVERTER_TEMPERATURE_CABINET: Metric.ValueType  # 121
METRIC_INVERTER_TEMPERATURE_HEATSINK: Metric.ValueType  # 122
METRIC_INVERTER_TEMPERATURE_TRANSFORMER: Metric.ValueType  # 123
METRIC_EV_CHARGER_TEMPERATURE: Metric.ValueType  # 140
"""EV charging station metrics."""
METRIC_SENSOR_WIND_SPEED: Metric.ValueType  # 160
"""General sensor metrics"""
METRIC_SENSOR_WIND_DIRECTION: Metric.ValueType  # 161
METRIC_SENSOR_TEMPERATURE: Metric.ValueType  # 162
METRIC_SENSOR_RELATIVE_HUMIDITY: Metric.ValueType  # 163
METRIC_SENSOR_DEW_POINT: Metric.ValueType  # 164
METRIC_SENSOR_AIR_PRESSURE: Metric.ValueType  # 165
METRIC_SENSOR_IRRADIANCE: Metric.ValueType  # 166
global___Metric = Metric

class _MetricConnectionCategory:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _MetricConnectionCategoryEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_MetricConnectionCategory.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    METRIC_CONNECTION_CATEGORY_UNSPECIFIED: _MetricConnectionCategory.ValueType  # 0
    """Default value.
    Do not use this value.
    """
    METRIC_CONNECTION_CATEGORY_OTHER: _MetricConnectionCategory.ValueType  # 1
    """A generic connection for metrics that do not fit into any other category."""
    METRIC_CONNECTION_CATEGORY_BATTERY: _MetricConnectionCategory.ValueType  # 2
    """A connection to a metric representing a battery."""
    METRIC_CONNECTION_CATEGORY_PV: _MetricConnectionCategory.ValueType  # 3
    """A connection to a metric representing a PV (photovoltaic) array or string."""
    METRIC_CONNECTION_CATEGORY_AMBIENT: _MetricConnectionCategory.ValueType  # 10
    """A connection to a metric representing ambient conditions."""
    METRIC_CONNECTION_CATEGORY_CABINET: _MetricConnectionCategory.ValueType  # 11
    """A connection to a metric representing a cabinet or an enclosure."""
    METRIC_CONNECTION_CATEGORY_HEATSINK: _MetricConnectionCategory.ValueType  # 12
    """A connection to a metric representing a heatsink."""
    METRIC_CONNECTION_CATEGORY_TRANSFORMER: _MetricConnectionCategory.ValueType  # 13
    """A connection to a metric representing a transformer."""

class MetricConnectionCategory(_MetricConnectionCategory, metaclass=_MetricConnectionCategoryEnumTypeWrapper):
    """Enumerated categories of connections from which metrics can be obtained for a
    given electrical component or sensor.
    """

METRIC_CONNECTION_CATEGORY_UNSPECIFIED: MetricConnectionCategory.ValueType  # 0
"""Default value.
Do not use this value.
"""
METRIC_CONNECTION_CATEGORY_OTHER: MetricConnectionCategory.ValueType  # 1
"""A generic connection for metrics that do not fit into any other category."""
METRIC_CONNECTION_CATEGORY_BATTERY: MetricConnectionCategory.ValueType  # 2
"""A connection to a metric representing a battery."""
METRIC_CONNECTION_CATEGORY_PV: MetricConnectionCategory.ValueType  # 3
"""A connection to a metric representing a PV (photovoltaic) array or string."""
METRIC_CONNECTION_CATEGORY_AMBIENT: MetricConnectionCategory.ValueType  # 10
"""A connection to a metric representing ambient conditions."""
METRIC_CONNECTION_CATEGORY_CABINET: MetricConnectionCategory.ValueType  # 11
"""A connection to a metric representing a cabinet or an enclosure."""
METRIC_CONNECTION_CATEGORY_HEATSINK: MetricConnectionCategory.ValueType  # 12
"""A connection to a metric representing a heatsink."""
METRIC_CONNECTION_CATEGORY_TRANSFORMER: MetricConnectionCategory.ValueType  # 13
"""A connection to a metric representing a transformer."""
global___MetricConnectionCategory = MetricConnectionCategory

@typing.final
class SimpleMetricValue(google.protobuf.message.Message):
    """Represents a single sample of a specific metric, the value of which is either
    measured or derived at a particular time.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    value: builtins.float
    """The value of the metric, which could be either measured or derived."""
    def __init__(
        self,
        *,
        value: builtins.float = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["value", b"value"]) -> None: ...

global___SimpleMetricValue = SimpleMetricValue

@typing.final
class AggregatedMetricValue(google.protobuf.message.Message):
    """Encapsulates derived statistical summaries of a single metric.

    The message allows for the reporting of statistical summaries — minimum,
    maximum, and average values - as well as the complete list of individual
    samples if available.

    This message represents derived metrics and contains fields for statistical
    summaries—minimum, maximum, and average values. Individual measurements are
    are optional, accommodating scenarios where only subsets of this information
    are available.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AVG_VALUE_FIELD_NUMBER: builtins.int
    MIN_VALUE_FIELD_NUMBER: builtins.int
    MAX_VALUE_FIELD_NUMBER: builtins.int
    RAW_VALUES_FIELD_NUMBER: builtins.int
    avg_value: builtins.float
    """The derived average value of the metric."""
    min_value: builtins.float
    """The minimum measured value of the metric."""
    max_value: builtins.float
    """The maximum measured value of the metric."""
    @property
    def raw_values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """Optional array of all the raw individual values."""

    def __init__(
        self,
        *,
        avg_value: builtins.float = ...,
        min_value: builtins.float | None = ...,
        max_value: builtins.float | None = ...,
        raw_values: collections.abc.Iterable[builtins.float] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_max_value", b"_max_value", "_min_value", b"_min_value", "max_value", b"max_value", "min_value", b"min_value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_max_value", b"_max_value", "_min_value", b"_min_value", "avg_value", b"avg_value", "max_value", b"max_value", "min_value", b"min_value", "raw_values", b"raw_values"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_max_value", b"_max_value"]) -> typing.Literal["max_value"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_min_value", b"_min_value"]) -> typing.Literal["min_value"] | None: ...

global___AggregatedMetricValue = AggregatedMetricValue

@typing.final
class MetricValueVariant(google.protobuf.message.Message):
    """`MetricValueVariant` serves as a union type that can encapsulate either a
    `SimpleMetricValue` or an `AggregatedMetricValue`.

    This message is designed to offer flexibility in capturing different
    granularities of metric samples—either a simple single-point measurement
    or an aggregated set of measurements for a metric.

    A `MetricValueVariant` can hold either a `SimpleMetricValue` or an
    `AggregatedMetricValue`, but not both simultaneously. Setting one will
    nullify the other.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SIMPLE_METRIC_FIELD_NUMBER: builtins.int
    AGGREGATED_METRIC_FIELD_NUMBER: builtins.int
    @property
    def simple_metric(self) -> global___SimpleMetricValue: ...
    @property
    def aggregated_metric(self) -> global___AggregatedMetricValue: ...
    def __init__(
        self,
        *,
        simple_metric: global___SimpleMetricValue | None = ...,
        aggregated_metric: global___AggregatedMetricValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["aggregated_metric", b"aggregated_metric", "metric_value_variant", b"metric_value_variant", "simple_metric", b"simple_metric"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["aggregated_metric", b"aggregated_metric", "metric_value_variant", b"metric_value_variant", "simple_metric", b"simple_metric"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["metric_value_variant", b"metric_value_variant"]) -> typing.Literal["simple_metric", "aggregated_metric"] | None: ...

global___MetricValueVariant = MetricValueVariant

@typing.final
class MetricConnection(google.protobuf.message.Message):
    """A connection to a metric representing from which a metric was obtained."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CATEGORY_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    category: global___MetricConnectionCategory.ValueType
    """The category of the connection from which the metric was obtained."""
    name: builtins.str
    """A  string that can be used to identify the specific connection from which
    the metric was obtained.

    This is expected to be populated when the same `Metric` variant can be
    obtained from multiple distinct inputs or connection points on the
    component. Knowing the connection for the metric can help in certain
    control and monitoring applications.
    """
    def __init__(
        self,
        *,
        category: global___MetricConnectionCategory.ValueType = ...,
        name: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["category", b"category", "name", b"name"]) -> None: ...

global___MetricConnection = MetricConnection

@typing.final
class MetricSample(google.protobuf.message.Message):
    """Representation of a sampled metric along with its value.

    !!! note
        This represents a single sample of a specific metric, the value of which
        is either measured or derived at a particular time. The real-time
        system-defined bounds are optional and may not always be present or set.

    !!! note
        ### Relationship Between Bounds and Metric Samples
        Suppose a metric sample for active power has a lower-bound of -10,000 W,
        and an upper-bound of 10,000 W. For the system to accept a charge
        command, clients need to request current values within the bounds.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SAMPLE_TIME_FIELD_NUMBER: builtins.int
    METRIC_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    BOUNDS_FIELD_NUMBER: builtins.int
    CONNECTION_FIELD_NUMBER: builtins.int
    metric: global___Metric.ValueType
    """The metric that was sampled."""
    @property
    def sample_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The UTC timestamp of when the metric was sampled."""

    @property
    def value(self) -> global___MetricValueVariant:
        """The value of the sampled metric."""

    @property
    def bounds(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[frequenz.api.common.v1alpha8.metrics.bounds_pb2.Bounds]:
        """List of bounds that apply to the metric sample.

        These bounds adapt in real-time to reflect the operating conditions at the
        time of aggregation or derivation.

        #### Multiple Bounds

        In the case of certain components like batteries, multiple bounds might
        exist. These multiple bounds collectively extend the range of allowable
        values, effectively forming a union of all given bounds. In such cases,
        the value of the metric must be within at least one of the bounds.
        In accordance with the passive sign convention, bounds that limit discharge
        would have negative numbers, while those limiting charge, such as for the
        State of Power (SoP) metric, would be positive. Hence bounds can have
        positive and negative values depending on the metric they represent.

        #### Example

        The diagram below illustrates the relationship between the bounds.
        ```
             bound[0].lower                         bound[1].upper
        <-------|============|------------------|============|--------->
                       bound[0].upper      bound[1].lower
        ```
        ---- values here are disallowed and will be rejected
        ==== values here are allowed and will be accepted
        """

    @property
    def connection(self) -> global___MetricConnection:
        """An optional field that can be used to identify the specific connection
        from which the metric was obtained.

        This is expected to be populated when the same `Metric` variant can be
        obtained from multiple distinct inputs or connection points on the
        component. Knowing the connection for the metric can help in certain
        control and monitoring applications.

        E.g.,
        - A PV inverter might have multiple PV strings connected (e.g.,
          `pv_string_1`, `pv_string_2`).
        - A hybrid inverter can have a DC connection for a battery (e.g.,
          `dc_battery_0`) and another for a PV array (e.g., `dc_pv_0`). A metric
          like DC voltage can be obtained from both connections. For an application
          to determine the SoC of the battery using its voltage, identifying the
          `dc_battery_0` connection is important.
        - A sensor unit might report temperature from different connected probes
          (e.g., `temp_sensor_outdoor`, `temp_sensor_transformer`).

        !!! note "Default Connection Behavior"
            If this field is unset, it is implicitly assumed that the component
            only has a single connection for this metric, and the connection is
            uniquely identified by the component itself.

        !!! example
            ```
            // DC power from battery string 0 in a hybrid inverter
            source {
              category: METRIC_CONNECTION_CATEGORY_BATTERY
              name: "dc_battery_0"
            }
            ```
        """

    def __init__(
        self,
        *,
        sample_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        metric: global___Metric.ValueType = ...,
        value: global___MetricValueVariant | None = ...,
        bounds: collections.abc.Iterable[frequenz.api.common.v1alpha8.metrics.bounds_pb2.Bounds] | None = ...,
        connection: global___MetricConnection | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_connection", b"_connection", "connection", b"connection", "sample_time", b"sample_time", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_connection", b"_connection", "bounds", b"bounds", "connection", b"connection", "metric", b"metric", "sample_time", b"sample_time", "value", b"value"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_connection", b"_connection"]) -> typing.Literal["connection"] | None: ...

global___MetricSample = MetricSample
