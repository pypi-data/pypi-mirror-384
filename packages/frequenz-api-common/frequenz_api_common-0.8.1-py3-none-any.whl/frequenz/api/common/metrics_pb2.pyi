"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Metrics & bounds definitions.

Copyright:
Copyright 2023 Frequenz Energy-as-a-Service GmbH

License:
MIT
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class Bounds(google.protobuf.message.Message):
    """A set of lower and upper bounds for any metric.
    The units of the bounds are always the same as the related metric.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LOWER_FIELD_NUMBER: builtins.int
    UPPER_FIELD_NUMBER: builtins.int
    lower: builtins.float
    """The lower bound."""
    upper: builtins.float
    """The upper bound."""
    def __init__(
        self,
        *,
        lower: builtins.float = ...,
        upper: builtins.float = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["lower", b"lower", "upper", b"upper"]) -> None: ...

global___Bounds = Bounds

@typing.final
class Metric(google.protobuf.message.Message):
    """A metric's value, with optional limits."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    RATED_BOUNDS_FIELD_NUMBER: builtins.int
    COMPONENT_BOUNDS_FIELD_NUMBER: builtins.int
    SYSTEM_EXCLUSION_BOUNDS_FIELD_NUMBER: builtins.int
    SYSTEM_INCLUSION_BOUNDS_FIELD_NUMBER: builtins.int
    value: builtins.float
    """The current value of the metric."""
    @property
    def rated_bounds(self) -> global___Bounds:
        """The manufacturer's rated bounds of the metric. This may differ from
        `system_bounds` as it does not take into account the current state of the
        overall system.
        """

    @property
    def component_bounds(self) -> global___Bounds:
        """The current bounds of the metric, as imposed by the component this metric
        originates from.
        """

    @property
    def system_exclusion_bounds(self) -> global___Bounds:
        """These bounds indicate the range of values that are disallowed for the
        metric.
        If these bounds for a metric are [`lower`, `upper`], then this metric's
        `value` needs to comply with the constraints
        `value <= lower` OR `upper <= value`.

        It is important to note that these bounds work together with
        `system_inclusion_bounds`.

        E.g., for the system to accept a charge command,
        clients need to request power values within the bounds
        `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.
        This means that clients can only request charge commands with values that
        are within the `system_inclusion_bounds`, but not within
        `system_exclusion_bounds`.
        Similarly, for the system to accept a discharge command,
        clients need to request power values within the bounds
        `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.

        The following diagram illustrates the relationship between the bounds.
        ```
          inclusion.lower                              inclusion.upper
        <-------|============|------------------|============|--------->
                       exclusion.lower    exclusion.upper
        ```
        ---- values here are disallowed and wil be rejected
        ==== vales here are allowed and will be accepted
        """

    @property
    def system_inclusion_bounds(self) -> global___Bounds:
        """These bounds indicate the range of values that are allowed for the metric.
        If these bounds for a metric are [`lower`, `upper`], then this metric's
        `value` needs to comply with the constraint `lower <= value <= upper`

        It is important to note that these bounds work together with
        `system_exclusion_bounds`.

        E.g., for the system to accept a charge command,
        clients need to request power values within the bounds
        `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.
        This means that clients can only request charge commands with values that
        are within the `system_inclusion_bounds`, but not within
        `system_exclusion_bounds`.
        Similarly, for the system to accept a discharge command,
        clients need to request power values within the bounds
        `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.

        The following diagram illustrates the relationship between the bounds.
        ```
          inclusion.lower                              inclusion.upper
        <-------|============|------------------|============|--------->
                       exclusion.lower    exclusion.upper
        ```
        ---- values here are disallowed and wil be rejected
        ==== vales here are allowed and will be accepted
        """

    def __init__(
        self,
        *,
        value: builtins.float = ...,
        rated_bounds: global___Bounds | None = ...,
        component_bounds: global___Bounds | None = ...,
        system_exclusion_bounds: global___Bounds | None = ...,
        system_inclusion_bounds: global___Bounds | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["component_bounds", b"component_bounds", "rated_bounds", b"rated_bounds", "system_exclusion_bounds", b"system_exclusion_bounds", "system_inclusion_bounds", b"system_inclusion_bounds"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["component_bounds", b"component_bounds", "rated_bounds", b"rated_bounds", "system_exclusion_bounds", b"system_exclusion_bounds", "system_inclusion_bounds", b"system_inclusion_bounds", "value", b"value"]) -> None: ...

global___Metric = Metric

@typing.final
class MetricAggregation(google.protobuf.message.Message):
    """Metrics depicted as a collection of statistical summaries.

    Useful when a component has to report multiple values for the same metric.
    E.g., a battery is a collection of several blocks, and each block has a
    temperature sensor. The battery can report a summary of the values provided
    by all these sensors, like, min, max, avg, etc., and if possible, the entire
    array of temperature values.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AVG_FIELD_NUMBER: builtins.int
    MIN_FIELD_NUMBER: builtins.int
    MAX_FIELD_NUMBER: builtins.int
    RAW_VALUES_FIELD_NUMBER: builtins.int
    RATED_BOUNDS_FIELD_NUMBER: builtins.int
    COMPONENT_BOUNDS_FIELD_NUMBER: builtins.int
    SYSTEM_EXCLUSION_BOUNDS_FIELD_NUMBER: builtins.int
    SYSTEM_INCLUSION_BOUNDS_FIELD_NUMBER: builtins.int
    avg: builtins.float
    """The average value of the metric."""
    min: builtins.float
    """The minimum value of the metric."""
    max: builtins.float
    """The maximum value of the metric."""
    @property
    def raw_values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """The array of all the metric values."""

    @property
    def rated_bounds(self) -> global___Bounds:
        """The manufacturer's rated bounds of the metric. This may differ from
        `system_bounds` as it does not take into account the current state of the
        overall system.
        """

    @property
    def component_bounds(self) -> global___Bounds:
        """The current bounds of the metric, as imposed by the component this metric
        originates from.
        """

    @property
    def system_exclusion_bounds(self) -> global___Bounds:
        """These bounds indicate the range of values that are disallowed for the
        metric.
        If these bounds for a metric are [`lower`, `upper`], then this metric's
        `value` needs to comply with the constraints
        `value <= lower` OR `upper <= value`.

        It is important to note that these bounds work together with
        `system_inclusion_bounds`.

        E.g., for the system to accept a charge command,
        clients need to request power values within the bounds
        `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.
        This means that clients can only request charge commands with power values
        that are within the `system_inclusion_bounds`, but not within
        `system_exclusion_bounds`.
        Similarly, for the system to accept a discharge command,
        clients need to request power values within the bounds
        `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.

        The following diagram illustrates the relationship between the bounds.
        ```
          inclusion.lower                              inclusion.upper
        <-------|============|------------------|============|--------->
                       exclusion.lower    exclusion.upper
        ```
        ---- values here are disallowed and wil be rejected
        ==== vales here are allowed and will be accepted
        """

    @property
    def system_inclusion_bounds(self) -> global___Bounds:
        """These bounds indicate the range of values that are allowed for the metric.
        If these bounds for a metric are [`lower`, `upper`], then this metric's
        `value` needs to comply with the constraint `lower <= value <= upper`

        It is important to note that these bounds work together with
        `system_exclusion_bounds`.

        E.g., for the system to accept a charge command,
        clients need to request power values within the bounds
        `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.
        This means that clients can only request charge commands with power values
        that are within the `system_inclusion_bounds`, but not within
        `system_exclusion_bounds`.
        Similarly, for the system to accept a discharge command,
        clients need to request power values within the bounds
        `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.

        The following diagram illustrates the relationship between the bounds.
        ```
          inclusion.lower                              inclusion.upper
        <-------|============|------------------|============|--------->
                       exclusion.lower    exclusion.upper
        ```
        ---- values here are disallowed and wil be rejected
        ==== vales here are allowed and will be accepted
        """

    def __init__(
        self,
        *,
        avg: builtins.float = ...,
        min: builtins.float | None = ...,
        max: builtins.float | None = ...,
        raw_values: collections.abc.Iterable[builtins.float] | None = ...,
        rated_bounds: global___Bounds | None = ...,
        component_bounds: global___Bounds | None = ...,
        system_exclusion_bounds: global___Bounds | None = ...,
        system_inclusion_bounds: global___Bounds | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_max", b"_max", "_min", b"_min", "component_bounds", b"component_bounds", "max", b"max", "min", b"min", "rated_bounds", b"rated_bounds", "system_exclusion_bounds", b"system_exclusion_bounds", "system_inclusion_bounds", b"system_inclusion_bounds"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_max", b"_max", "_min", b"_min", "avg", b"avg", "component_bounds", b"component_bounds", "max", b"max", "min", b"min", "rated_bounds", b"rated_bounds", "raw_values", b"raw_values", "system_exclusion_bounds", b"system_exclusion_bounds", "system_inclusion_bounds", b"system_inclusion_bounds"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_max", b"_max"]) -> typing.Literal["max"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_min", b"_min"]) -> typing.Literal["min"] | None: ...

global___MetricAggregation = MetricAggregation
