"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Metrics definitions.

Copyright:
Copyright 2023 Frequenz Energy-as-a-Service GmbH

License:
MIT
"""

import builtins
import collections.abc
import frequenz.api.common.v1.metrics.bounds_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _Metric:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _MetricEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Metric.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    METRIC_UNSPECIFIED: _Metric.ValueType  # 0
    """Default value."""
    METRIC_DC_VOLTAGE: _Metric.ValueType  # 1
    """DC electricity metrics"""
    METRIC_DC_CURRENT: _Metric.ValueType  # 2
    METRIC_DC_POWER: _Metric.ValueType  # 3
    METRIC_AC_FREQUENCY: _Metric.ValueType  # 10
    """General AC electricity metrics"""
    METRIC_AC_VOLTAGE: _Metric.ValueType  # 11
    METRIC_AC_VOLTAGE_PHASE_1_N: _Metric.ValueType  # 12
    METRIC_AC_VOLTAGE_PHASE_2_N: _Metric.ValueType  # 13
    METRIC_AC_VOLTAGE_PHASE_3_N: _Metric.ValueType  # 14
    METRIC_AC_VOLTAGE_PHASE_1_PHASE_2: _Metric.ValueType  # 15
    METRIC_AC_VOLTAGE_PHASE_2_PHASE_3: _Metric.ValueType  # 16
    METRIC_AC_VOLTAGE_PHASE_3_PHASE_1: _Metric.ValueType  # 17
    METRIC_AC_CURRENT: _Metric.ValueType  # 18
    METRIC_AC_CURRENT_PHASE_1: _Metric.ValueType  # 19
    METRIC_AC_CURRENT_PHASE_2: _Metric.ValueType  # 20
    METRIC_AC_CURRENT_PHASE_3: _Metric.ValueType  # 21
    METRIC_AC_APPARENT_POWER: _Metric.ValueType  # 22
    """AC power metrics"""
    METRIC_AC_APPARENT_POWER_PHASE_1: _Metric.ValueType  # 23
    METRIC_AC_APPARENT_POWER_PHASE_2: _Metric.ValueType  # 24
    METRIC_AC_APPARENT_POWER_PHASE_3: _Metric.ValueType  # 25
    METRIC_AC_ACTIVE_POWER: _Metric.ValueType  # 26
    METRIC_AC_ACTIVE_POWER_PHASE_1: _Metric.ValueType  # 27
    METRIC_AC_ACTIVE_POWER_PHASE_2: _Metric.ValueType  # 28
    METRIC_AC_ACTIVE_POWER_PHASE_3: _Metric.ValueType  # 29
    METRIC_AC_REACTIVE_POWER: _Metric.ValueType  # 30
    METRIC_AC_REACTIVE_POWER_PHASE_1: _Metric.ValueType  # 31
    METRIC_AC_REACTIVE_POWER_PHASE_2: _Metric.ValueType  # 32
    METRIC_AC_REACTIVE_POWER_PHASE_3: _Metric.ValueType  # 33
    METRIC_AC_POWER_FACTOR: _Metric.ValueType  # 40
    """AC Power factor"""
    METRIC_AC_POWER_FACTOR_PHASE_1: _Metric.ValueType  # 41
    METRIC_AC_POWER_FACTOR_PHASE_2: _Metric.ValueType  # 42
    METRIC_AC_POWER_FACTOR_PHASE_3: _Metric.ValueType  # 43
    METRIC_AC_APPARENT_ENERGY: _Metric.ValueType  # 50
    """AC energy metrics"""
    METRIC_AC_APPARENT_ENERGY_PHASE_1: _Metric.ValueType  # 51
    METRIC_AC_APPARENT_ENERGY_PHASE_2: _Metric.ValueType  # 52
    METRIC_AC_APPARENT_ENERGY_PHASE_3: _Metric.ValueType  # 53
    METRIC_AC_ACTIVE_ENERGY: _Metric.ValueType  # 54
    METRIC_AC_ACTIVE_ENERGY_PHASE_1: _Metric.ValueType  # 55
    METRIC_AC_ACTIVE_ENERGY_PHASE_2: _Metric.ValueType  # 56
    METRIC_AC_ACTIVE_ENERGY_PHASE_3: _Metric.ValueType  # 57
    METRIC_AC_ACTIVE_ENERGY_CONSUMED: _Metric.ValueType  # 58
    METRIC_AC_ACTIVE_ENERGY_CONSUMED_PHASE_1: _Metric.ValueType  # 59
    METRIC_AC_ACTIVE_ENERGY_CONSUMED_PHASE_2: _Metric.ValueType  # 60
    METRIC_AC_ACTIVE_ENERGY_CONSUMED_PHASE_3: _Metric.ValueType  # 61
    METRIC_AC_ACTIVE_ENERGY_DELIVERED: _Metric.ValueType  # 62
    METRIC_AC_ACTIVE_ENERGY_DELIVERED_PHASE_1: _Metric.ValueType  # 63
    METRIC_AC_ACTIVE_ENERGY_DELIVERED_PHASE_2: _Metric.ValueType  # 64
    METRIC_AC_ACTIVE_ENERGY_DELIVERED_PHASE_3: _Metric.ValueType  # 65
    METRIC_AC_REACTIVE_ENERGY: _Metric.ValueType  # 66
    METRIC_AC_REACTIVE_ENERGY_PHASE_1: _Metric.ValueType  # 67
    METRIC_AC_REACTIVE_ENERGY_PHASE_2: _Metric.ValueType  # 69
    METRIC_AC_REACTIVE_ENERGY_PHASE_3: _Metric.ValueType  # 70
    METRIC_AC_TOTAL_HARMONIC_DISTORTION_CURRENT: _Metric.ValueType  # 80
    """AC harmonics"""
    METRIC_AC_TOTAL_HARMONIC_DISTORTION_CURRENT_PHASE_1: _Metric.ValueType  # 81
    METRIC_AC_TOTAL_HARMONIC_DISTORTION_CURRENT_PHASE_2: _Metric.ValueType  # 82
    METRIC_AC_TOTAL_HARMONIC_DISTORTION_CURRENT_PHASE_3: _Metric.ValueType  # 83
    METRIC_BATTERY_CAPACITY: _Metric.ValueType  # 101
    """General BMS metrics."""
    METRIC_BATTERY_SOC_PCT: _Metric.ValueType  # 102
    METRIC_BATTERY_TEMPERATURE: _Metric.ValueType  # 103
    METRIC_INVERTER_TEMPERATURE: _Metric.ValueType  # 120
    """General inverter metrics."""
    METRIC_INVERTER_TEMPERATURE_CABINET: _Metric.ValueType  # 121
    METRIC_INVERTER_TEMPERATURE_HEATSINK: _Metric.ValueType  # 122
    METRIC_INVERTER_TEMPERATURE_TRANSFORMER: _Metric.ValueType  # 123
    METRIC_EV_CHARGER_TEMPERATURE: _Metric.ValueType  # 140
    """EV charging station metrics."""
    METRIC_SENSOR_WIND_SPEED: _Metric.ValueType  # 160
    """General sensor metrics"""
    METRIC_SENSOR_WIND_DIRECTION: _Metric.ValueType  # 162
    METRIC_SENSOR_TEMPERATURE: _Metric.ValueType  # 163
    METRIC_SENSOR_RELATIVE_HUMIDITY: _Metric.ValueType  # 164
    METRIC_SENSOR_DEW_POINT: _Metric.ValueType  # 165
    METRIC_SENSOR_AIR_PRESSURE: _Metric.ValueType  # 166
    METRIC_SENSOR_IRRADIANCE: _Metric.ValueType  # 167

class Metric(_Metric, metaclass=_MetricEnumTypeWrapper):
    """List of supported metrics.

    !!! note
    AC energy metrics information:

    * This energy metric is reported directly from the component, and not a
     result of aggregations in our systems. If a component does not have this
     metric, this field cannot be populated.

     * Components that provide energy metrics reset this metric from time to
     time. This behaviour is specific to each component model. E.g., some
     components reset it on UTC 00:00:00.

     * This energy metric does not specify the timestamp since when the energy
     was being accumulated, and therefore can be inconsistent.
    """

METRIC_UNSPECIFIED: Metric.ValueType  # 0
"""Default value."""
METRIC_DC_VOLTAGE: Metric.ValueType  # 1
"""DC electricity metrics"""
METRIC_DC_CURRENT: Metric.ValueType  # 2
METRIC_DC_POWER: Metric.ValueType  # 3
METRIC_AC_FREQUENCY: Metric.ValueType  # 10
"""General AC electricity metrics"""
METRIC_AC_VOLTAGE: Metric.ValueType  # 11
METRIC_AC_VOLTAGE_PHASE_1_N: Metric.ValueType  # 12
METRIC_AC_VOLTAGE_PHASE_2_N: Metric.ValueType  # 13
METRIC_AC_VOLTAGE_PHASE_3_N: Metric.ValueType  # 14
METRIC_AC_VOLTAGE_PHASE_1_PHASE_2: Metric.ValueType  # 15
METRIC_AC_VOLTAGE_PHASE_2_PHASE_3: Metric.ValueType  # 16
METRIC_AC_VOLTAGE_PHASE_3_PHASE_1: Metric.ValueType  # 17
METRIC_AC_CURRENT: Metric.ValueType  # 18
METRIC_AC_CURRENT_PHASE_1: Metric.ValueType  # 19
METRIC_AC_CURRENT_PHASE_2: Metric.ValueType  # 20
METRIC_AC_CURRENT_PHASE_3: Metric.ValueType  # 21
METRIC_AC_APPARENT_POWER: Metric.ValueType  # 22
"""AC power metrics"""
METRIC_AC_APPARENT_POWER_PHASE_1: Metric.ValueType  # 23
METRIC_AC_APPARENT_POWER_PHASE_2: Metric.ValueType  # 24
METRIC_AC_APPARENT_POWER_PHASE_3: Metric.ValueType  # 25
METRIC_AC_ACTIVE_POWER: Metric.ValueType  # 26
METRIC_AC_ACTIVE_POWER_PHASE_1: Metric.ValueType  # 27
METRIC_AC_ACTIVE_POWER_PHASE_2: Metric.ValueType  # 28
METRIC_AC_ACTIVE_POWER_PHASE_3: Metric.ValueType  # 29
METRIC_AC_REACTIVE_POWER: Metric.ValueType  # 30
METRIC_AC_REACTIVE_POWER_PHASE_1: Metric.ValueType  # 31
METRIC_AC_REACTIVE_POWER_PHASE_2: Metric.ValueType  # 32
METRIC_AC_REACTIVE_POWER_PHASE_3: Metric.ValueType  # 33
METRIC_AC_POWER_FACTOR: Metric.ValueType  # 40
"""AC Power factor"""
METRIC_AC_POWER_FACTOR_PHASE_1: Metric.ValueType  # 41
METRIC_AC_POWER_FACTOR_PHASE_2: Metric.ValueType  # 42
METRIC_AC_POWER_FACTOR_PHASE_3: Metric.ValueType  # 43
METRIC_AC_APPARENT_ENERGY: Metric.ValueType  # 50
"""AC energy metrics"""
METRIC_AC_APPARENT_ENERGY_PHASE_1: Metric.ValueType  # 51
METRIC_AC_APPARENT_ENERGY_PHASE_2: Metric.ValueType  # 52
METRIC_AC_APPARENT_ENERGY_PHASE_3: Metric.ValueType  # 53
METRIC_AC_ACTIVE_ENERGY: Metric.ValueType  # 54
METRIC_AC_ACTIVE_ENERGY_PHASE_1: Metric.ValueType  # 55
METRIC_AC_ACTIVE_ENERGY_PHASE_2: Metric.ValueType  # 56
METRIC_AC_ACTIVE_ENERGY_PHASE_3: Metric.ValueType  # 57
METRIC_AC_ACTIVE_ENERGY_CONSUMED: Metric.ValueType  # 58
METRIC_AC_ACTIVE_ENERGY_CONSUMED_PHASE_1: Metric.ValueType  # 59
METRIC_AC_ACTIVE_ENERGY_CONSUMED_PHASE_2: Metric.ValueType  # 60
METRIC_AC_ACTIVE_ENERGY_CONSUMED_PHASE_3: Metric.ValueType  # 61
METRIC_AC_ACTIVE_ENERGY_DELIVERED: Metric.ValueType  # 62
METRIC_AC_ACTIVE_ENERGY_DELIVERED_PHASE_1: Metric.ValueType  # 63
METRIC_AC_ACTIVE_ENERGY_DELIVERED_PHASE_2: Metric.ValueType  # 64
METRIC_AC_ACTIVE_ENERGY_DELIVERED_PHASE_3: Metric.ValueType  # 65
METRIC_AC_REACTIVE_ENERGY: Metric.ValueType  # 66
METRIC_AC_REACTIVE_ENERGY_PHASE_1: Metric.ValueType  # 67
METRIC_AC_REACTIVE_ENERGY_PHASE_2: Metric.ValueType  # 69
METRIC_AC_REACTIVE_ENERGY_PHASE_3: Metric.ValueType  # 70
METRIC_AC_TOTAL_HARMONIC_DISTORTION_CURRENT: Metric.ValueType  # 80
"""AC harmonics"""
METRIC_AC_TOTAL_HARMONIC_DISTORTION_CURRENT_PHASE_1: Metric.ValueType  # 81
METRIC_AC_TOTAL_HARMONIC_DISTORTION_CURRENT_PHASE_2: Metric.ValueType  # 82
METRIC_AC_TOTAL_HARMONIC_DISTORTION_CURRENT_PHASE_3: Metric.ValueType  # 83
METRIC_BATTERY_CAPACITY: Metric.ValueType  # 101
"""General BMS metrics."""
METRIC_BATTERY_SOC_PCT: Metric.ValueType  # 102
METRIC_BATTERY_TEMPERATURE: Metric.ValueType  # 103
METRIC_INVERTER_TEMPERATURE: Metric.ValueType  # 120
"""General inverter metrics."""
METRIC_INVERTER_TEMPERATURE_CABINET: Metric.ValueType  # 121
METRIC_INVERTER_TEMPERATURE_HEATSINK: Metric.ValueType  # 122
METRIC_INVERTER_TEMPERATURE_TRANSFORMER: Metric.ValueType  # 123
METRIC_EV_CHARGER_TEMPERATURE: Metric.ValueType  # 140
"""EV charging station metrics."""
METRIC_SENSOR_WIND_SPEED: Metric.ValueType  # 160
"""General sensor metrics"""
METRIC_SENSOR_WIND_DIRECTION: Metric.ValueType  # 162
METRIC_SENSOR_TEMPERATURE: Metric.ValueType  # 163
METRIC_SENSOR_RELATIVE_HUMIDITY: Metric.ValueType  # 164
METRIC_SENSOR_DEW_POINT: Metric.ValueType  # 165
METRIC_SENSOR_AIR_PRESSURE: Metric.ValueType  # 166
METRIC_SENSOR_IRRADIANCE: Metric.ValueType  # 167
global___Metric = Metric

@typing.final
class SimpleMetricValue(google.protobuf.message.Message):
    """Represents a single sample of a specific metric, the value of which is either
    measured or derived at a particular time.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    value: builtins.float
    """The value of the metric, which could be either measured or derived."""
    def __init__(
        self,
        *,
        value: builtins.float = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["value", b"value"]) -> None: ...

global___SimpleMetricValue = SimpleMetricValue

@typing.final
class AggregatedMetricValue(google.protobuf.message.Message):
    """Encapsulates derived statistical summaries of a single metric.

    The message allows for the reporting of statistical summaries — minimum,
    maximum, and average values - as well as the complete list of individual
    samples if available.

    This message represents derived metrics and contains fields for statistical
    summaries—minimum, maximum, and average values. Individual measurements are
    are optional, accommodating scenarios where only subsets of this information
    are available.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AVG_VALUE_FIELD_NUMBER: builtins.int
    MIN_VALUE_FIELD_NUMBER: builtins.int
    MAX_VALUE_FIELD_NUMBER: builtins.int
    RAW_VALUES_FIELD_NUMBER: builtins.int
    avg_value: builtins.float
    """The derived average value of the metric."""
    min_value: builtins.float
    """The minimum measured value of the metric."""
    max_value: builtins.float
    """The maximum measured value of the metric."""
    @property
    def raw_values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """Optional array of all the raw individual values."""

    def __init__(
        self,
        *,
        avg_value: builtins.float = ...,
        min_value: builtins.float | None = ...,
        max_value: builtins.float | None = ...,
        raw_values: collections.abc.Iterable[builtins.float] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_max_value", b"_max_value", "_min_value", b"_min_value", "max_value", b"max_value", "min_value", b"min_value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_max_value", b"_max_value", "_min_value", b"_min_value", "avg_value", b"avg_value", "max_value", b"max_value", "min_value", b"min_value", "raw_values", b"raw_values"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_max_value", b"_max_value"]) -> typing.Literal["max_value"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_min_value", b"_min_value"]) -> typing.Literal["min_value"] | None: ...

global___AggregatedMetricValue = AggregatedMetricValue

@typing.final
class MetricValueVariant(google.protobuf.message.Message):
    """`MetricValueVariant` serves as a union type that can encapsulate either a
    `SimpleMetricValue` or an `AggregatedMetricValue`.

    This message is designed to offer flexibility in capturing different
    granularities of metric samples—either a simple single-point measurement
    or an aggregated set of measurements for a metric.

    A `MetricValueVariant` can hold either a `SimpleMetricValue` or an
    `AggregatedMetricValue`, but not both simultaneously. Setting one will
    nullify the other.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SIMPLE_METRIC_FIELD_NUMBER: builtins.int
    AGGREGATED_METRIC_FIELD_NUMBER: builtins.int
    @property
    def simple_metric(self) -> global___SimpleMetricValue: ...
    @property
    def aggregated_metric(self) -> global___AggregatedMetricValue: ...
    def __init__(
        self,
        *,
        simple_metric: global___SimpleMetricValue | None = ...,
        aggregated_metric: global___AggregatedMetricValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["aggregated_metric", b"aggregated_metric", "metric_value_variant", b"metric_value_variant", "simple_metric", b"simple_metric"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["aggregated_metric", b"aggregated_metric", "metric_value_variant", b"metric_value_variant", "simple_metric", b"simple_metric"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["metric_value_variant", b"metric_value_variant"]) -> typing.Literal["simple_metric", "aggregated_metric"] | None: ...

global___MetricValueVariant = MetricValueVariant

@typing.final
class MetricSample(google.protobuf.message.Message):
    """Representation of a sampled metric along with its value.

    !!! note
        This represents a single sample of a specific metric, the value of which
        is either measured or derived at a particular time. The real-time
        system-defined bounds are optional and may not always be present or set.

    !!! note
        ### Relationship Between Bounds and Metric Samples
        Suppose a metric sample for active power has a lower-bound of -10,000 W,
        and an upper-bound of 10,000 W. For the system to accept a charge
        command, clients need to request current values within the bounds.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SAMPLED_AT_FIELD_NUMBER: builtins.int
    METRIC_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    BOUNDS_FIELD_NUMBER: builtins.int
    SOURCE_FIELD_NUMBER: builtins.int
    metric: global___Metric.ValueType
    """The metric that was sampled."""
    source: builtins.str
    """An optional string that can be used to identify the source of the metric.

    This is expected to be populated when the same `Metric` variant can be
    obtained from multiple sensors in the component. Knowing the source of the
    metric can help in certain control and monitoring applications.

    E.g., a hybrid inverter can have a DC string for a battery and another DC
    string for a PV array. The source names could resemble, say,
    `dc_battery_0` and ``dc_pv_0`. A metric like DC voltage can be obtained
    from both sources. For an application to determine the SoC of the battery
    using the battery voltage, the source of the voltage metric is important.

    In cases where the component has just one source for a metric, then this
    field is not expected to be present, because the source is implicit.
    """
    @property
    def sampled_at(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The UTC timestamp of when the metric was sampled."""

    @property
    def value(self) -> global___MetricValueVariant:
        """The value of the sampled metric."""

    @property
    def bounds(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[frequenz.api.common.v1.metrics.bounds_pb2.Bounds]:
        """List of bounds that apply to the metric sample.

        These bounds adapt in real-time to reflect the operating conditions at the
        time of aggregation or derivation.

        #### Multiple Bounds

        In the case of certain components like batteries, multiple bounds might
        exist. These multiple bounds collectively extend the range of allowable
        values, effectively forming a union of all given bounds. In such cases,
        the value of the metric must be within at least one of the bounds.
        In accordance with the passive sign convention, bounds that limit discharge
        would have negative numbers, while those limiting charge, such as for the
        State of Power (SoP) metric, would be positive. Hence bounds can have
        positive and negative values depending on the metric they represent.

        #### Example

        The diagram below illustrates the relationship between the bounds.
        ```
             bound[0].lower                         bound[1].upper
        <-------|============|------------------|============|--------->
                       bound[0].upper      bound[1].lower
        ```
        ---- values here are disallowed and will be rejected
        ==== values here are allowed and will be accepted
        """

    def __init__(
        self,
        *,
        sampled_at: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        metric: global___Metric.ValueType = ...,
        value: global___MetricValueVariant | None = ...,
        bounds: collections.abc.Iterable[frequenz.api.common.v1.metrics.bounds_pb2.Bounds] | None = ...,
        source: builtins.str | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_source", b"_source", "sampled_at", b"sampled_at", "source", b"source", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_source", b"_source", "bounds", b"bounds", "metric", b"metric", "sampled_at", b"sampled_at", "source", b"source", "value", b"value"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_source", b"_source"]) -> typing.Literal["source"] | None: ...

global___MetricSample = MetricSample
