# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import numpy
import numpy.typing
import typing
from enum import Enum

class EvaluationResult:
    @property
    def objective(self) -> builtins.float: ...
    @property
    def constraints(self) -> builtins.dict[builtins.str, Violation]: ...
    @property
    def penalties(self) -> builtins.dict[builtins.str, Violation]: ...
    def __new__(cls, objective:builtins.float=0.0, constraints:typing.Mapping[builtins.str, Violation]={}, penalties:typing.Mapping[builtins.str, Violation]={}) -> EvaluationResult: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class MeasuringTime:
    def __new__(cls, solving_time:typing.Optional[SolvingTime]=None, system_time:typing.Optional[SystemTime]=None) -> MeasuringTime: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def total(self) -> builtins.float:
        r"""
        Returns the total time measurred, across both `SolvingTime` and `SystemTime`.
        """
    def view_solving_time(self) -> SolvingTime:
        r"""
        Returns a readonly view of the internal `SolvingTime` field.
        """
    def view_system_time(self) -> SystemTime:
        r"""
        Returns a readonly view of the internal `SystemTime` field.
        """

class Sample:
    r"""
    A Sample representing an individual solution found by running the mathematical optimization model.
    
    Variables in `var_values` are stored in instances of `SparseVarValues`. This uses a dictionary
    style, retaining only non-zero elements. For example, if the values for a two-dimensional
    decision variable are `x = [[0, 1, 2], [1, 0, 0]]`, they will be stored as
    `{(0,1): 1, (0,2): 2, (1,0): 1}`. To retrieve this, use `sample.var_values["x"].values`.
    If you want a dense array of decision variables, you can use the `to_dense()` method.
    
    `run_id` is a unique identifier of the run in which this sample was found.
    Note that this is not the same as a unique identifier of the Sample.
    """
    @property
    def run_id(self) -> builtins.str: ...
    @property
    def num_occurrences(self) -> builtins.int: ...
    @property
    def run_info(self) -> builtins.dict[builtins.str, None | builtins.str | builtins.int | builtins.float | builtins.list | builtins.dict]: ...
    @property
    def var_values(self) -> builtins.dict[builtins.str, SparseVarValues]: ...
    @property
    def eval(self) -> EvaluationResult: ...
    def __new__(cls, num_occurrences:builtins.int=1, run_id:typing.Optional[builtins.str]=None, run_info:typing.Optional[typing.Mapping[builtins.str, None | builtins.str | builtins.int | builtins.float | builtins.list | builtins.dict]]=None, var_values:typing.Optional[typing.Mapping[builtins.str, SparseVarValues]]=None, eval:typing.Optional[EvaluationResult]=None) -> Sample: ...
    @staticmethod
    def from_dense_arrays(dict:typing.Mapping[builtins.str, numpy.typing.NDArray[numpy.float64] | list], num_occurrences:builtins.int=1, var_types:typing.Optional[typing.Mapping[builtins.str, VarType]]=None, run_id:typing.Optional[builtins.str]=None, meta_info:typing.Optional[typing.Mapping[builtins.str, None | builtins.str | builtins.int | builtins.float | builtins.list | builtins.dict]]=None) -> Sample: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __eq__(self, other:typing.Any) -> builtins.bool: ...
    def is_feasible(self, epsilon:builtins.float=1e-08) -> builtins.bool: ...
    def to_dense(self) -> builtins.dict[builtins.str, numpy.typing.NDArray[numpy.float64]]: ...
    @staticmethod
    def from_dict(dict:dict) -> Sample:
        r"""
        Converts a python dictionary into a SampleSet.
        
        This is intended to be used primarily with dictionaries generated by
        the `to_dict()` method. As such sparse value maps must be represented as
        association lists.
        """
    def to_dict(self) -> typing.Any:
        r"""
        Converts this SampleSet into a regular python dictionary.
        
        Note that this dictionary has a slightly different structure to better support JSON
        serialization of the output dictionary: sparse values are stored differently. Any mapping
        with tuples as keys is transformed into an association list of key-value pairs,
        that is, `[(k1, v1), (k2, v2), ...]`.
        """

class SampleIter:
    def __iter__(self) -> SampleIter: ...
    def __next__(self) -> Sample: ...

class SampleSet:
    @property
    def data(self) -> builtins.list[Sample]: ...
    @property
    def set_id(self) -> builtins.str: ...
    @property
    def set_info(self) -> builtins.dict[builtins.str, None | builtins.str | builtins.int | builtins.float | builtins.list | builtins.dict]: ...
    @property
    def run_info(self) -> builtins.dict[builtins.str, None | builtins.str | builtins.int | builtins.float | builtins.list | builtins.dict]: ...
    @property
    def measuring_time(self) -> MeasuringTime: ...
    @property
    def run_times(self) -> builtins.dict[builtins.str, MeasuringTime]: ...
    def __new__(cls, data:typing.Sequence[Sample]=[], *, set_id:typing.Optional[builtins.str]=None, set_info:typing.Optional[typing.Mapping[builtins.str, None | builtins.str | builtins.int | builtins.float | builtins.list | builtins.dict]]=None, run_info:typing.Optional[typing.Mapping[builtins.str, None | builtins.str | builtins.int | builtins.float | builtins.list | builtins.dict]]=None, measuring_time:MeasuringTime=..., run_times:typing.Mapping[builtins.str, MeasuringTime]={}) -> SampleSet: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __eq__(self, other:typing.Any) -> builtins.bool: ...
    def __len__(self) -> builtins.int: ...
    def __getitem__(self, idx:builtins.int) -> Sample: ...
    def __iter__(self) -> SampleIter: ...
    @staticmethod
    def from_array(samples:typing.Sequence[typing.Mapping[builtins.str, numpy.typing.NDArray[numpy.float64] | list]]) -> SampleSet:
        r"""
        Builds a SampleSet from a list of dictionaries, where each entry is interpreted as a sample.
        
        Args
        -----
        - `samples`(`list[dict[str, list | numpy.ndarray]]`)
        """
    @staticmethod
    def concat(family:typing.Sequence[SampleSet]) -> SampleSet:
        r"""
        Creates a single SampleSet by concatenating a list of multiple SampleSets.
        
        Args
        -----
        - `family` (`list[SampleSet]`)
        """
    @staticmethod
    def from_dict(dict:dict) -> SampleSet:
        r"""
        Converts a python dictionary into a SampleSet.
        
        This is intended to be used primarily with dictionaries generated by
        the `to_dict()` method. As such sparse value maps must be represented as
        association lists.
        """
    def to_dict(self) -> typing.Any:
        r"""
        Converts this SampleSet into a regular python dictionary.
        
        Note that this dictionary has a slightly different structure to better support JSON
        serialization of the output dictionary: sparse values are stored differently. Any mapping
        with tuples as keys is transformed into an association list of key-value pairs,
        that is, `[(k1, v1), (k2, v2), ...]`.
        """
    def feasibles(self, epsilon:builtins.float=1e-08) -> SampleSet:
        r"""
        Returns a SampleSet containing only the feasible samples.
        
        Args
        -----
        - `epsilon` (`float`, optional): Tolerance threshold for constraint violations. Defaults to $1e-8$.
        
        Returns
        --------
        - `SampleSet`: a feasible subset of the current set.
        """
    def separate(self) -> builtins.dict[builtins.str, SampleSet]:
        r"""
        Splits this `SampleSet` based on the `run_id` of the samples.
        
        In other words, for each distinct `run_id` among the `Sample`s contained in this instance, a
        new `SampleSet` is created to store all `Sample`s with that ID.
        
        Returns
        -----
        - `sets` (dict[str, SampleSet]): The separated SampleSets. Keys are the run IDs.
        """
    def lowest(self, epsilon:builtins.float=1e-08) -> builtins.list[Sample]:
        r"""
        Returns a list of the feasible samples which have the lowest objective value.
        If there are no feasible solutions, this returns an empty list.
        
        Args
        -----
        - `epsilon` (`float`, optional): Tolerance threshold. Objective values within this tolerance are included, even if not exactly the minimum value. Defaults to $1e-8$.
        
        Returns
        -----
        `lowest_samples`: A list of Sample objects with the lowest ojective value in this SampleSet.
        """

class SolvingTime:
    @property
    def compiling_time(self) -> builtins.float: ...
    @property
    def transpiling_time(self) -> builtins.float: ...
    @property
    def preprocess_time(self) -> builtins.float: ...
    @property
    def solving_time(self) -> builtins.float: ...
    @property
    def decoding_time(self) -> builtins.float: ...
    @property
    def postprocess_time(self) -> builtins.float: ...
    def __new__(cls, compiling_time:builtins.float=0.0, transpiling_time:builtins.float=0.0, preprocess_time:builtins.float=0.0, solving_time:builtins.float=0.0, decoding_time:builtins.float=0.0, postprocess_time:builtins.float=0.0) -> SolvingTime: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def total(self) -> builtins.float: ...

class SparseVarValues:
    @property
    def name(self) -> builtins.str: ...
    @property
    def values(self) -> builtins.dict[typing.Tuple[int, ...], builtins.float]: ...
    @property
    def var_type(self) -> VarType: ...
    @property
    def shape(self) -> tuple: ...
    def __new__(cls, name:builtins.str, values:typing.Mapping[typing.Tuple[int, ...], builtins.float], shape:typing.Sequence[builtins.int], var_type:VarType=VarType.CONTINUOUS) -> SparseVarValues: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    @staticmethod
    def from_array(name:builtins.str, array:numpy.typing.NDArray[numpy.float64], var_type:VarType=VarType.CONTINUOUS) -> SparseVarValues: ...
    def to_dense(self) -> numpy.typing.NDArray[numpy.float64]: ...

class SystemTime:
    @property
    def posting_time(self) -> typing.Optional[builtins.float]: ...
    @property
    def request_queuing_time(self) -> typing.Optional[builtins.float]: ...
    @property
    def fetching_problem_time(self) -> typing.Optional[builtins.float]: ...
    @property
    def fetching_result_time(self) -> typing.Optional[builtins.float]: ...
    @property
    def deserialize_time(self) -> typing.Optional[builtins.float]: ...
    def __new__(cls, posting_time:typing.Optional[builtins.float]=None, request_queuing_time:typing.Optional[builtins.float]=None, fetching_problem_time:typing.Optional[builtins.float]=None, fetching_result_time:typing.Optional[builtins.float]=None, deserialize_time:typing.Optional[builtins.float]=None) -> SystemTime: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class Violation:
    @property
    def name(self) -> builtins.str: ...
    @property
    def total_violation(self) -> builtins.float: ...
    @property
    def expr_values(self) -> builtins.dict[typing.Tuple[int, ...], builtins.float]: ...
    def __new__(cls, name:builtins.str, total_violation:builtins.float, expr_values:typing.Mapping[typing.Tuple[int, ...], builtins.float]) -> Violation: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class VarType(Enum):
    CONTINUOUS = ...
    INTEGER = ...
    BINARY = ...

def from_old_sampleset(sampleset:typing.Any) -> SampleSet: ...

