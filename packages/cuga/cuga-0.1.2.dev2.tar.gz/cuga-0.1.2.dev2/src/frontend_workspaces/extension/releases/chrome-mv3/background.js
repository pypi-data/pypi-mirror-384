var Ae=Object.defineProperty;var be=(D,I,N)=>I in D?Ae(D,I,{enumerable:!0,configurable:!0,writable:!0,value:N}):D[I]=N;var O=(D,I,N)=>be(D,typeof I!="symbol"?I+"":I,N);var background=(function(){"use strict";typeof Symbol.dispose!="symbol"&&Object.defineProperty(Symbol,"dispose",{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for("dispose")}),typeof Symbol.asyncDispose!="symbol"&&Object.defineProperty(Symbol,"asyncDispose",{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for("asyncDispose")});function D(c){return c&&c.__esModule&&Object.prototype.hasOwnProperty.call(c,"default")?c.default:c}var I={exports:{}},N=I.exports,Q;function Y(){return Q||(Q=1,(function(c,t){(function(e,r){r(c)})(typeof globalThis<"u"?globalThis:typeof self<"u"?self:N,function(e){var r,s;if(!((s=(r=globalThis.chrome)==null?void 0:r.runtime)!=null&&s.id))throw new Error("This script should only be loaded in a browser extension.");if(typeof globalThis.browser>"u"||Object.getPrototypeOf(globalThis.browser)!==Object.prototype){const u="The message port closed before a response was received.",g=w=>{const A={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(A).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class y extends WeakMap{constructor(a,l=void 0){super(l),this.createItem=a}get(a){return this.has(a)||this.set(a,this.createItem(a)),super.get(a)}}const d=n=>n&&typeof n=="object"&&typeof n.then=="function",x=(n,a)=>(...l)=>{w.runtime.lastError?n.reject(new Error(w.runtime.lastError.message)):a.singleCallbackArg||l.length<=1&&a.singleCallbackArg!==!1?n.resolve(l[0]):n.resolve(l)},T=n=>n==1?"argument":"arguments",p=(n,a)=>function(o,...h){if(h.length<a.minArgs)throw new Error(`Expected at least ${a.minArgs} ${T(a.minArgs)} for ${n}(), got ${h.length}`);if(h.length>a.maxArgs)throw new Error(`Expected at most ${a.maxArgs} ${T(a.maxArgs)} for ${n}(), got ${h.length}`);return new Promise((v,C)=>{if(a.fallbackToNoCallback)try{o[n](...h,x({resolve:v,reject:C},a))}catch(f){console.warn(`${n} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,f),o[n](...h),a.fallbackToNoCallback=!1,a.noCallback=!0,v()}else a.noCallback?(o[n](...h),v()):o[n](...h,x({resolve:v,reject:C},a))})},P=(n,a,l)=>new Proxy(a,{apply(o,h,v){return l.call(h,n,...v)}});let m=Function.call.bind(Object.prototype.hasOwnProperty);const b=(n,a={},l={})=>{let o=Object.create(null),h={has(C,f){return f in n||f in o},get(C,f,R){if(f in o)return o[f];if(!(f in n))return;let S=n[f];if(typeof S=="function")if(typeof a[f]=="function")S=P(n,n[f],a[f]);else if(m(l,f)){let U=p(f,l[f]);S=P(n,n[f],U)}else S=S.bind(n);else if(typeof S=="object"&&S!==null&&(m(a,f)||m(l,f)))S=b(S,a[f],l[f]);else if(m(l,"*"))S=b(S,a[f],l["*"]);else return Object.defineProperty(o,f,{configurable:!0,enumerable:!0,get(){return n[f]},set(U){n[f]=U}}),S;return o[f]=S,S},set(C,f,R,S){return f in o?o[f]=R:n[f]=R,!0},defineProperty(C,f,R){return Reflect.defineProperty(o,f,R)},deleteProperty(C,f){return Reflect.deleteProperty(o,f)}},v=Object.create(n);return new Proxy(v,h)},i=n=>({addListener(a,l,...o){a.addListener(n.get(l),...o)},hasListener(a,l){return a.hasListener(n.get(l))},removeListener(a,l){a.removeListener(n.get(l))}}),k=new y(n=>typeof n!="function"?n:function(l){const o=b(l,{},{getContent:{minArgs:0,maxArgs:0}});n(o)}),M=new y(n=>typeof n!="function"?n:function(l,o,h){let v=!1,C,f=new Promise(q=>{C=function(L){v=!0,q(L)}}),R;try{R=n(l,o,C)}catch(q){R=Promise.reject(q)}const S=R!==!0&&d(R);if(R!==!0&&!S&&!v)return!1;const U=q=>{q.then(L=>{h(L)},L=>{let J;L&&(L instanceof Error||typeof L.message=="string")?J=L.message:J="An unexpected error occurred",h({__mozWebExtensionPolyfillReject__:!0,message:J})}).catch(L=>{console.error("Failed to send onMessage rejected reply",L)})};return U(S?R:f),!0}),E=({reject:n,resolve:a},l)=>{w.runtime.lastError?w.runtime.lastError.message===u?a():n(new Error(w.runtime.lastError.message)):l&&l.__mozWebExtensionPolyfillReject__?n(new Error(l.message)):a(l)},_=(n,a,l,...o)=>{if(o.length<a.minArgs)throw new Error(`Expected at least ${a.minArgs} ${T(a.minArgs)} for ${n}(), got ${o.length}`);if(o.length>a.maxArgs)throw new Error(`Expected at most ${a.maxArgs} ${T(a.maxArgs)} for ${n}(), got ${o.length}`);return new Promise((h,v)=>{const C=E.bind(null,{resolve:h,reject:v});o.push(C),l.sendMessage(...o)})},B={devtools:{network:{onRequestFinished:i(k)}},runtime:{onMessage:i(M),onMessageExternal:i(M),sendMessage:_.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:_.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},F={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return A.privacy={network:{"*":F},services:{"*":F},websites:{"*":F}},b(w,B,A)};e.exports=g(chrome)}else e.exports=globalThis.browser})})(I)),I.exports}var ee=Y();const $=D(ee);var j={exports:{}},te=j.exports,z;function re(){return z||(z=1,(function(c){(function(t,e){c.exports?c.exports=e():t.log=e()})(te,function(){var t=function(){},e="undefined",r=typeof window!==e&&typeof window.navigator!==e&&/Trident\/|MSIE /.test(window.navigator.userAgent),s=["trace","debug","info","warn","error"],u={},g=null;function w(m,b){var i=m[b];if(typeof i.bind=="function")return i.bind(m);try{return Function.prototype.bind.call(i,m)}catch{return function(){return Function.prototype.apply.apply(i,[m,arguments])}}}function A(){console.log&&(console.log.apply?console.log.apply(console,arguments):Function.prototype.apply.apply(console.log,[console,arguments])),console.trace&&console.trace()}function y(m){return m==="debug"&&(m="log"),typeof console===e?!1:m==="trace"&&r?A:console[m]!==void 0?w(console,m):console.log!==void 0?w(console,"log"):t}function d(){for(var m=this.getLevel(),b=0;b<s.length;b++){var i=s[b];this[i]=b<m?t:this.methodFactory(i,m,this.name)}if(this.log=this.debug,typeof console===e&&m<this.levels.SILENT)return"No console available for logging"}function x(m){return function(){typeof console!==e&&(d.call(this),this[m].apply(this,arguments))}}function T(m,b,i){return y(m)||x.apply(this,arguments)}function p(m,b){var i=this,k,M,E,_="loglevel";typeof m=="string"?_+=":"+m:typeof m=="symbol"&&(_=void 0);function B(o){var h=(s[o]||"silent").toUpperCase();if(!(typeof window===e||!_)){try{window.localStorage[_]=h;return}catch{}try{window.document.cookie=encodeURIComponent(_)+"="+h+";"}catch{}}}function F(){var o;if(!(typeof window===e||!_)){try{o=window.localStorage[_]}catch{}if(typeof o===e)try{var h=window.document.cookie,v=encodeURIComponent(_),C=h.indexOf(v+"=");C!==-1&&(o=/^([^;]+)/.exec(h.slice(C+v.length+1))[1])}catch{}return i.levels[o]===void 0&&(o=void 0),o}}function n(){if(!(typeof window===e||!_)){try{window.localStorage.removeItem(_)}catch{}try{window.document.cookie=encodeURIComponent(_)+"=; expires=Thu, 01 Jan 1970 00:00:00 UTC"}catch{}}}function a(o){var h=o;if(typeof h=="string"&&i.levels[h.toUpperCase()]!==void 0&&(h=i.levels[h.toUpperCase()]),typeof h=="number"&&h>=0&&h<=i.levels.SILENT)return h;throw new TypeError("log.setLevel() called with invalid level: "+o)}i.name=m,i.levels={TRACE:0,DEBUG:1,INFO:2,WARN:3,ERROR:4,SILENT:5},i.methodFactory=b||T,i.getLevel=function(){return E??M??k},i.setLevel=function(o,h){return E=a(o),h!==!1&&B(E),d.call(i)},i.setDefaultLevel=function(o){M=a(o),F()||i.setLevel(o,!1)},i.resetLevel=function(){E=null,n(),d.call(i)},i.enableAll=function(o){i.setLevel(i.levels.TRACE,o)},i.disableAll=function(o){i.setLevel(i.levels.SILENT,o)},i.rebuild=function(){if(g!==i&&(k=a(g.getLevel())),d.call(i),g===i)for(var o in u)u[o].rebuild()},k=a(g?g.getLevel():"WARN");var l=F();l!=null&&(E=a(l)),d.call(i)}g=new p,g.getLogger=function(b){if(typeof b!="symbol"&&typeof b!="string"||b==="")throw new TypeError("You must supply a name when creating a logger.");var i=u[b];return i||(i=u[b]=new p(b,g.methodFactory)),i};var P=typeof window!==e?window.log:void 0;return g.noConflict=function(){return typeof window!==e&&window.log===g&&(window.log=P),g},g.getLoggers=function(){return u},g.default=g,g})})(j)),j.exports}var ne=re();const W=D(ne);var H={exports:{}},se=H.exports,Z;function oe(){return Z||(Z=1,(function(c){(function(t,e){c.exports?c.exports=e():t.prefix=e(t)})(se,function(t){var e=function(d){for(var x=1,T=arguments.length,p;x<T;x++)for(p in arguments[x])Object.prototype.hasOwnProperty.call(arguments[x],p)&&(d[p]=arguments[x][p]);return d},r={template:"[%t] %l:",levelFormatter:function(d){return d.toUpperCase()},nameFormatter:function(d){return d||"root"},timestampFormatter:function(d){return d.toTimeString().replace(/.*(\d{2}:\d{2}:\d{2}).*/,"$1")},format:void 0},s,u={},g=function(d){if(!d||!d.getLogger)throw new TypeError("Argument is not a root logger");s=d},w=function(d,x){if(!d||!d.setLevel)throw new TypeError("Argument is not a logger");var T=d.methodFactory,p=d.name||"",P=u[p]||u[""]||r;function m(b,i,k){var M=T(b,i,k),E=u[k]||u[""],_=E.template.indexOf("%t")!==-1,B=E.template.indexOf("%l")!==-1,F=E.template.indexOf("%n")!==-1;return function(){for(var n="",a=arguments.length,l=Array(a),o=0;o<a;o++)l[o]=arguments[o];if(p||!u[k]){var h=E.timestampFormatter(new Date),v=E.levelFormatter(b),C=E.nameFormatter(k);E.format?n+=E.format(v,C,h):(n+=E.template,_&&(n=n.replace(/%t/,h)),B&&(n=n.replace(/%l/,v)),F&&(n=n.replace(/%n/,C))),l.length&&typeof l[0]=="string"?l[0]=n+" "+l[0]:l.unshift(n)}M.apply(void 0,l)}}return u[p]||(d.methodFactory=m),x=x||{},x.template&&(x.format=void 0),u[p]=e({},P,x),d.setLevel(d.getLevel()),s||d.warn("It is necessary to call the function reg() of loglevel-plugin-prefix before calling apply. From the next release, it will throw an error. See more: https://github.com/kutuluk/loglevel-plugin-prefix/blob/master/README.md"),d},A={reg:g,apply:w},y;return t&&(y=t.prefix,A.noConflict=function(){return t.prefix===A&&(t.prefix=y),A}),A})})(H)),H.exports}var ae=oe();const X=D(ae);function ie(c){return new Promise(t=>setTimeout(t,c))}function le(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(c){var t=Math.random()*16|0,e=c==="x"?t:t&3|8;return e.toString(16)})}class ce{constructor(){this.type="nl2ui.sidepanel.render",this.id=le()}}class ge{constructor(){O(this,"onConnectBound");O(this,"port");O(this,"heartbeatInterval");this.onConnectBound=this.onConnect.bind(this)}handleBrowserActionClick(){const t=$.action;if(!t)throw Error("'WorkerNL2UI' class can only be used in the context of 'service workers' of a browser extension.");t.onClicked.addListener(async e=>{$.sidePanel.setOptions({path:"./sidepanel.html"}),$.sidePanel.open({windowId:e.windowId})})}startHeartbeat(){this.heartbeatInterval||(this.heartbeatInterval=setInterval(()=>{this.port&&this.port.postMessage({type:"heartbeat"})},2e4))}stopHeartbeat(){this.heartbeatInterval&&(clearInterval(this.heartbeatInterval),this.heartbeatInterval=void 0)}async onConnect(t){t.name==="sidepanel"&&(this.port||(this.port=t,t.onDisconnect.addListener(e=>{this.stopHeartbeat(),this.port=void 0}),this.startHeartbeat(),t.postMessage(new ce)))}start(){this.handleBrowserActionClick(),$.runtime.onConnect.addListener(this.onConnectBound)}stop(){this.stopHeartbeat(),$.runtime.onConnect.removeListener(this.onConnectBound)}}function me(c){return c==null||typeof c=="function"?{main:c}:c}const K="http://localhost:8005",de=`${K}/extension/command_stream`,ue=`${K}/extension/command_result`;class he{constructor(){O(this,"eventSource",null);O(this,"isConnected",!1);O(this,"pendingAgentQueries",new Map)}start(){this.connectToCommandStream(),this.setupEventListeners()}stop(){this.eventSource&&(this.eventSource.close(),this.eventSource=null),this.isConnected=!1}connectToCommandStream(){this.eventSource=new EventSource(de),this.eventSource.onopen=()=>{console.log("[HTTP-STREAM] Connected to command stream"),this.isConnected=!0},this.eventSource.onerror=t=>{console.error("[HTTP-STREAM] EventSource error",t),this.isConnected=!1},this.eventSource.onmessage=async t=>{try{const e=JSON.parse(t.data);if(console.log("[HTTP-STREAM] Received command:",e),e.type==="agent_response"||e.type==="agent_complete"||e.type==="agent_error"){if(e.request_id&&this.pendingAgentQueries.has(e.request_id)){const s=this.pendingAgentQueries.get(e.request_id);s&&s(e),this.pendingAgentQueries.delete(e.request_id)}try{await globalThis.chrome.runtime.sendMessage({source:"background",...e}),console.log("[HTTP-STREAM] Forwarded agent message to popup:",e.type)}catch(s){console.log("[HTTP-STREAM] Could not forward message to popup (popup might be closed):",s.message)}return}const r=await this.executeCommand(e);await this.sendCommandResult(e.request_id,r)}catch(e){console.error("[HTTP-STREAM] Failed to process command:",e)}}}async sendCommandResult(t,e){try{await fetch(ue,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({request_id:t,...e})}),console.log("[HTTP-STREAM] Sent command result for",t)}catch(r){console.error("[HTTP-STREAM] Failed to send command result:",r)}}async executeCommand(t){switch(t.type){case"ping":return{type:"pong",timestamp:Date.now()};case"mark_elements":return await this.handleMarkElements(t.data);case"unmark_elements":return await this.handleUnmarkElements();case"extract_dom_snapshot":return await this.handleExtractDomSnapshot(t.data);case"extract_accessibility_tree":return await this.handleExtractAccessibilityTree();case"extract_dom_tree":return await this.handleExtractDomTree(t.data);case"extract_screenshot":return await this.handleExtractScreenshot(t.data);case"extract_focused_element_bid":return await this.handleExtractFocusedElementBid(t.data);case"extract_page_content":return await this.handleExtractPageContent(t.data);case"get_active_tab_url":return await this.handleGetActiveTabUrl();case"get_active_tab_title":return await this.handleGetActiveTabTitle();case"browser_command":return await this.handleBrowserCommand(t.command,t.args,t.request_id);default:return{type:"error",message:`Unknown command type: ${t.type}`}}}async handleBrowserCommand(t,e,r){try{switch(t){case"click":return await this.handleClickCommand(e);case"type":return await this.handleTypeCommand(e);case"add_animation":return await this.handleAddAnimation(e);case"select_option":return await this.handleSelectOption(e);default:return{type:"error",message:`Unknown browser command: ${t}`}}}catch(s){return{type:"error",message:s.message||String(s)}}}async handleClickCommand(t){var x,T;const e=await this.getActiveTab();if(!e)throw new Error("No active tab found");const{bid:r,button:s="left",modifiers:u=[]}=t;if(!r)throw new Error("BID is required for click command");console.log(`[CUGA] Clicking element with BID: ${r}, button: ${s}, modifiers: ${u}`);let g=await this.findElementByDomTreeId(e.id,r);if(!g)throw new Error(`Element with BID '${r}' not found`);try{const p=await globalThis.chrome.debugger.sendCommand({tabId:e.id},"DOM.describeNode",{nodeId:g}),P=(x=p==null?void 0:p.node)==null?void 0:x.nodeName,m=((T=p==null?void 0:p.node)==null?void 0:T.attributes)??[];if(P&&P.toLowerCase()==="label"&&m.length>0){const b=m.findIndex(i=>i==="for");if(b!==-1&&b+1<m.length){const i=m[b+1];if(i){const k=await globalThis.chrome.debugger.sendCommand({tabId:e.id},"DOM.getDocument"),M=await globalThis.chrome.debugger.sendCommand({tabId:e.id},"DOM.querySelector",{nodeId:k.root.nodeId,selector:`#${i}`});M&&M.nodeId&&(console.log(`[CUGA] Redirecting click from <label> to associated element id '${i}', nodeId: ${M.nodeId}`),g=M.nodeId)}}}}catch(p){console.warn("[CUGA] Failed to resolve label target element:",p)}const w=await globalThis.chrome.debugger.sendCommand({tabId:e.id},"DOM.getBoxModel",{nodeId:g});if(!w||!w.model)throw new Error("Could not get element bounding box");let A=null,y=null;const d=await this.getElementRect(e.id,r);if(d&&(A=Math.round(d.left+d.width/2),y=Math.round(d.top+d.height/2),console.log(`[CUGA] Bounding rect via content script, center: (${A}, ${y})`)),A===null||y===null){const p=w.model.border,P=[p[0],p[2],p[4],p[6]],m=[p[1],p[3],p[5],p[7]];A=Math.round((Math.min(...P)+Math.max(...P))/2),y=Math.round((Math.min(...m)+Math.max(...m))/2),console.log(`[CUGA] Fallback BoxModel center: (${A}, ${y})`)}return await globalThis.chrome.debugger.sendCommand({tabId:e.id},"Input.dispatchMouseEvent",{type:"mousePressed",x:A,y,button:s,clickCount:1}),ie(100),await globalThis.chrome.debugger.sendCommand({tabId:e.id},"Input.dispatchMouseEvent",{type:"mouseReleased",x:A,y,button:s,clickCount:1}),console.log("[CUGA] Click completed successfully"),{success:!0,position:{x:A,y}}}async handleTypeCommand(t){const e=await this.getActiveTab();if(!e)throw new Error("No active tab found");const{bid:r,value:s,press_enter:u=!1}=t;if(!r)throw new Error("BID is required for type command");if(!s)throw new Error("Value is required for type command");console.log(`[CUGA] Typing in element with BID: ${r}, value: "${s}", press_enter: ${u}`);const g=await this.findElementByDomTreeId(e.id,r);if(!g)throw new Error(`Element with BID '${r}' not found`);await globalThis.chrome.debugger.sendCommand({tabId:e.id},"DOM.focus",{nodeId:g}),await globalThis.chrome.debugger.sendCommand({tabId:e.id},"Input.dispatchKeyEvent",{type:"keyDown",windowsVirtualKeyCode:46,code:"Delete",key:"Delete"});for(let w=0;w<s.length;w++){const A=s[w];await globalThis.chrome.debugger.sendCommand({tabId:e.id},"Input.dispatchKeyEvent",{type:"keyDown",text:A,key:A,code:`Key${A.toUpperCase()}`}),await globalThis.chrome.debugger.sendCommand({tabId:e.id},"Input.dispatchKeyEvent",{type:"keyUp",text:A,key:A,code:`Key${A.toUpperCase()}`}),await new Promise(y=>setTimeout(y,10))}return u&&(console.log("[CUGA] Pressing Enter after typing"),await globalThis.chrome.debugger.sendCommand({tabId:e.id},"Input.dispatchKeyEvent",{type:"keyDown",windowsVirtualKeyCode:13,code:"Enter",key:"Enter"}),await globalThis.chrome.debugger.sendCommand({tabId:e.id},"Input.dispatchKeyEvent",{type:"keyUp",windowsVirtualKeyCode:13,code:"Enter",key:"Enter"})),console.log("[CUGA] Type completed successfully"),{success:!0,value:s,press_enter:u}}async handleAddAnimation(t){const e=await this.getActiveTab();if(!e)throw new Error("No active tab found");await this.ensureContentScriptInjected(e.id);const{bid:r,icon_type:s,banner_text:u}=t;return await globalThis.chrome.tabs.sendMessage(e.id,{type:"add_animation",bid:r,iconType:s,bannerText:u})}async handleSelectOption(t){const e=await this.getActiveTab();if(!e)throw new Error("No active tab found");await this.ensureContentScriptInjected(e.id);const{bid:r,options:s}=t;return await globalThis.chrome.tabs.sendMessage(e.id,{type:"select_option",bid:r,options:s})}async handleMarkElements(t){try{const e=await this.getActiveTab();if(!e)throw new Error("No active tab found");return await this.ensureContentScriptInjected(e.id),{type:"success",warnings:(await globalThis.chrome.tabs.sendMessage(e.id,{type:"mark_elements",data:{frameId:t.frameId||"",bidAttribute:t.bid_attribute||"dom-tree-id",tagsToMark:t.tags_to_mark||"standard_html"}})).warnings||[]}}catch(e){return{type:"error",message:e.message}}}async handleUnmarkElements(){try{const t=await this.getActiveTab();if(!t)throw new Error("No active tab found");return await this.ensureContentScriptInjected(t.id),await globalThis.chrome.tabs.sendMessage(t.id,{type:"unmark_elements"}),{type:"success"}}catch(t){return{type:"error",message:t.message}}}async handleExtractDomSnapshot(t){try{const e=await this.getActiveTab();if(!e)throw new Error("No active tab found");return await this.ensureDebuggerAttached(e.id),{type:"success",data:await globalThis.chrome.debugger.sendCommand({tabId:e.id},"DOMSnapshot.captureSnapshot",{computedStyles:t.computed_styles||[],includeDOMRects:t.include_dom_rects!==!1,includePaintOrder:t.include_paint_order!==!1})}}catch(e){return{type:"error",message:e.message}}}async handleExtractAccessibilityTree(){try{const t=await this.getActiveTab();if(!t)throw new Error("No active tab found");return await this.ensureDebuggerAttached(t.id),{type:"success",data:await globalThis.chrome.debugger.sendCommand({tabId:t.id},"Accessibility.getFullAXTree")}}catch(t){return{type:"error",message:t.message}}}async handleExtractScreenshot(t){try{const e=await this.getActiveTab();if(!e)throw new Error("No active tab found");await this.ensureDebuggerAttached(e.id);const r=await globalThis.chrome.debugger.sendCommand({tabId:e.id},"Page.captureScreenshot",{format:t.format||"png",quality:t.quality||100});try{const s=t&&typeof t.cleanup_delay_ms=="number"?t.cleanup_delay_ms:3e3,u=e.id;setTimeout(async()=>{try{await this.ensureContentScriptInjected(u),await globalThis.chrome.tabs.sendMessage(u,{type:"unmark_elements"}),console.log("[HTTP-STREAM] Cleaned marked elements after screenshot")}catch(g){console.warn("[HTTP-STREAM] Failed to clean elements after screenshot:",g)}},s)}catch(s){console.warn("[HTTP-STREAM] Failed to schedule cleanup after screenshot:",s)}return{type:"success",data:r.data}}catch(e){return{type:"error",message:e.message}}}async handleExtractFocusedElementBid(t){try{const e=await this.getActiveTab();if(!e)throw new Error("No active tab found");return await this.ensureContentScriptInjected(e.id),{type:"success",data:(await globalThis.chrome.tabs.sendMessage(e.id,{type:"get_focused_element_bid",data:{bidAttribute:t.bid_attribute||"dom-tree-id"}})).data||""}}catch(e){return{type:"error",message:e.message}}}async handleExtractDomTree(t){try{const e=await this.getActiveTab();if(!e)throw new Error("No active tab found");return await this.ensureContentScriptInjected(e.id),{type:"success",data:(await globalThis.chrome.tabs.sendMessage(e.id,{type:"extract_dom_tree",data:{doHighlightElements:t.do_highlight_elements||!1,focusHighlightIndex:t.focus_highlight_index||-1,viewportExpansion:t.viewport_expansion||0,debugMode:t.debug_mode||!1}})).data||null}}catch(e){return{type:"error",message:e.message}}}async handleExtractPageContent(t){try{const e=await this.getActiveTab();if(!e)throw new Error("No active tab found");return await this.ensureContentScriptInjected(e.id),{type:"success",data:(await globalThis.chrome.tabs.sendMessage(e.id,{type:"extract_page_content",data:{asText:t.as_text||!1}})).data||""}}catch(e){return{type:"error",message:e.message}}}async handleGetActiveTabUrl(){try{const t=await this.getActiveTab();if(!t)throw new Error("No active tab found");return{type:"success",data:t.url}}catch(t){return{type:"error",message:t.message}}}async handleGetActiveTabTitle(){try{const t=await this.getActiveTab();if(!t)throw new Error("No active tab found");return{type:"success",data:t.title??""}}catch(t){return{type:"error",message:t.message}}}async findElementByDomTreeId(t,e){console.log(`[CUGA] Searching for element with BID: ${e}`),await globalThis.chrome.debugger.sendCommand({tabId:t},"DOM.getDocument");const r=await globalThis.chrome.debugger.sendCommand({tabId:t},"DOM.performSearch",{query:`[dom-tree-id="${e}"]`});if(!r.searchId)throw new Error("Search failed");const s=await globalThis.chrome.debugger.sendCommand({tabId:t},"DOM.getSearchResults",{searchId:r.searchId,fromIndex:0,toIndex:1});if(await globalThis.chrome.debugger.sendCommand({tabId:t},"DOM.discardSearchResults",{searchId:r.searchId}),!s.nodeIds||s.nodeIds.length===0)return console.log(`[CUGA] Element with BID '${e}' not found`),null;const u=s.nodeIds[0];return console.log(`[CUGA] Found element with BID '${e}', nodeId: ${u}`),u}async getActiveTab(){return(await globalThis.chrome.tabs.query({active:!0,currentWindow:!0}))[0]||null}async ensureContentScriptInjected(t){try{const e=await globalThis.chrome.tabs.get(t);if(!e||e.url.startsWith("chrome://")||e.url.startsWith("chrome-extension://"))throw new Error("Cannot inject content script into restricted page");await new Promise((r,s)=>{const u=setTimeout(()=>{s(new Error("Content script ping timeout"))},1e3);globalThis.chrome.tabs.sendMessage(t,{type:"ping"},g=>{clearTimeout(u),globalThis.chrome.runtime.lastError?s(new Error(globalThis.chrome.runtime.lastError.message)):g&&g.type==="pong"?r(g):s(new Error("Invalid ping response"))})}),console.log("Content script already injected and responding")}catch(e){console.log("Content script not present or not responding:",e.message),console.log("Content script should be automatically injected via manifest"),await new Promise(r=>setTimeout(r,1e3));try{await new Promise((r,s)=>{const u=setTimeout(()=>{s(new Error("Content script verification timeout"))},2e3);globalThis.chrome.tabs.sendMessage(t,{type:"ping"},g=>{clearTimeout(u),globalThis.chrome.runtime.lastError?s(new Error(globalThis.chrome.runtime.lastError.message)):g&&g.type==="pong"?r(g):s(new Error("Content script injection verification failed"))})}),console.log("Content script injection verified")}catch(r){throw console.error("Failed to verify content script injection:",r),new Error(`Content script not available: ${r.message}`)}}}async ensureDebuggerAttached(t){var e,r;try{await globalThis.chrome.debugger.attach({tabId:t},"1.3")}catch(s){if(!(s&&((e=s.message)!=null&&e.includes("already attached")||(r=s.message)!=null&&r.includes("Already attached"))))throw console.error("Failed to attach Chrome debugger:",s),new Error("Chrome debugger not attached and could not attach")}}async getElementRect(t,e){try{await this.ensureContentScriptInjected(t);const r=await globalThis.chrome.tabs.sendMessage(t,{type:"get_element_rect",bid:e});if(r&&r.type==="success"&&r.data)return r.data}catch(r){console.warn("[CUGA] Failed to get element rect via content script:",r)}return null}setupEventListeners(){globalThis.chrome.runtime.onMessage.addListener((t,e,r)=>{if(t.source==="popup")return this.handlePopupMessage(t).then(s=>r(s)).catch(s=>r({type:"error",message:s.message})),!0})}async handlePopupMessage(t){switch(t.type){case"ping":return{type:"pong",connected:this.isConnected};case"send_agent_query":if(!this.isConnected)throw new Error("Not connected to backend server");return await this.handleAgentQuery(t.query);default:throw new Error(`Unknown popup message type: ${t.type}`)}}async handleAgentQuery(t){var r;const e=`agent_query_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;try{const s=await fetch(`${K}/extension/agent_query`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({query:t,request_id:e})});if(!s.ok)throw new Error(`Failed to send agent query: ${s.statusText}`);const u=(r=s.body)==null?void 0:r.getReader();if(!u)throw new Error("No response body reader available");const g=new TextDecoder;let w="";try{for(;;){const{done:A,value:y}=await u.read();if(A)break;w+=g.decode(y,{stream:!0});const d=w.split(`
`);w=d.pop()||"";for(const x of d)if(x.trim())try{const T=JSON.parse(x);console.log("[HTTP-STREAM] Received agent response:",T.type);try{await globalThis.chrome.runtime.sendMessage({source:"background",...T})}catch(p){console.log("[HTTP-STREAM] Could not forward to popup:",p.message)}if(T.type==="agent_complete"||T.type==="agent_error")return{type:"success",message:"Agent query completed"}}catch(T){console.error("[HTTP-STREAM] Failed to parse agent response:",T)}}if(w.trim())try{const A=JSON.parse(w);console.log("[HTTP-STREAM] Final agent response:",A.type);try{await globalThis.chrome.runtime.sendMessage({source:"background",...A})}catch(y){console.log("[HTTP-STREAM] Could not forward final response to popup:",y.message)}}catch(A){console.error("[HTTP-STREAM] Failed to parse final agent response:",A)}return{type:"success",message:"Agent query stream completed"}}finally{u.releaseLock()}}catch(s){throw new Error(s.message||String(s))}}}const fe=me(()=>{X.reg(W),X.apply(W,{template:"[%t] %l %n:"}),W.enableAll();const c=[new he,new ge];for(const t of c)t.start();$.runtime.onSuspend.addListener(()=>{for(const t of c)t.stop()}),$.runtime.onSuspendCanceled.addListener(()=>{for(const t of c)t.start()})});function we(){}function G(c,...t){}const pe={debug:(...c)=>G(console.debug,...c),log:(...c)=>G(console.log,...c),warn:(...c)=>G(console.warn,...c),error:(...c)=>G(console.error,...c)};let V;try{V=fe.main(),V instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(c){throw pe.error("The background crashed on startup!"),c}return V})();
