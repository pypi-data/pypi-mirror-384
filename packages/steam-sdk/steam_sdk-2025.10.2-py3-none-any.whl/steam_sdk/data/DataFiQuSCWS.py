from pydantic import BaseModel, Field
from typing import Dict, List, Literal, Optional, Union


class CWSGeometryConductors(BaseModel):  # Conductor file data for geometry building
    """
    Level 2: Class for FiQuS CWS
    """

    skip_middle_from: Optional[List[int]] = Field(
        default=None,
        description="This is a list of integers that needs to be the same length as file_names and it acts on these conductor file bricks."
                    "The integer specified results in bricks from 0 to skip_middle_from that are only constructed by gmsh and put into the brep file."
                    "Typically all the bricks, but one, in the fine_names file that overlap with the former should be skipped to speed up the geometry construction."
                    "If this option is not specified, i.e. empty list [] is given everything would work, but it may take longer to create geometry.")

    skip_middle_to: Optional[List[int]] = Field(
        default=None,
        description="This is a list of integers that needs to be the same length as file_names and it acts on these conductor file bricks."
                    "The integer specified results in bricks from skip_middle_to to the last brick that are only constructed by gmsh and put into the brep file."
                    "Typically all the bricks, but one, in the fine_names file that overlap with the former should be skipped to speed up the geometry construction."
                    "If this option is not specified, i.e. empty list [] is given everything would work, but it may take longer to create geometry.")
    file_names_large: Optional[List[str]] = Field(
        default=None,
        description="This is a list of large (normal) conductor file names (without .cond extensions). If you have only one size of conductor file (without having the smaller conductor) this is the mandatory"
                    "list of names to specify")
    file_names: Optional[List[str]] = Field(
        default=None,
        description="This is a list of small (for pre-cutting) conductor file names (without .cond extensions). In some CCT magnets, using this smaller set of conductor files speeds up the"
                    "geometry operations dramatically. For other magnets, like Racetrack, this entry can be left as an empty list")
    ends_need_trimming: bool = Field(
        default=False,
        description="If there are windings 'sticking out' of the air region this needs to set to True. This is typically the case if the conductors are generated by other software and the magnet is"
                    "rotated in strange way (i.e. as it was for Fusillo sub). If set to true, FiQuS removes 2 volumes per winding that are outside the air region after the fragment operation.")


class CWSGeometryFormers(BaseModel):  # STEP file data for geometry building
    """
    Level 2: Class for FiQuS CWS
    """

    file_names: Optional[List[str]] = None  # STEP file names to use
    air_pockets: Optional[List[int]] = (
        None  # number of air pockets (for e.g. for heater or temperature sensor pads) on the formers
    )


class CWSGeometryShells(BaseModel):  # STEP file data for geometry building
    """
    Level 2: Class for FiQuS CWS
    """

    file_names: Optional[List[str]] = None  # STEP file names to use


class CWSGeometryIronYokes(BaseModel):  # STEP file data for geometry building
    """
    Level 2: Class for FiQuS CWS
    """

    file_names: Optional[List[str]] = Field(
        default=None, description="BREP file names (without .brep) to use for iron yoke geometry."
    )


class CWSGeometryAir(BaseModel):  # Geometry related air_region _inputs
    """
    Level 2: Class for FiQuS CWS
    """

    name: Optional[str] = None  # name to use in gmsh and getdp
    sh_type: Optional[str] = (
        None  # cylinder, cuboid, cylinder_offset, cylinder_cov, cylinder_link or from_file are possible
    )
    ar: Optional[float] = (
        None  # if box type is cuboid 'a' is taken as a dimension, if cylinder then 'r' is taken
    )
    z_min: Optional[float] = (
        None  # extend of air region in negative z direction, for cylinder_cov this is ignored
    )
    z_max: Optional[float] = (
        None  # extend of air region in positive z direction, for cylinder_cov this is ignored
    )
    rotate: Optional[float] = None  # rotation around z axis in degrees
    xy_offset: Optional[List[float]] = (
        None  # list with x and y offset of the cylinder, only works if sh_type is set to cylinder_offset, e.g. [0, 0.3]
    )
    extension_distance: Optional[List[float]] = (
        None  # list with distances in meter to take along the line going through bricks of end terminals. For example to extend the air region by 0.5 m each way the entry could be [0.5, -0.5]
    )


class CWSGeometry(BaseModel):
    """
    Level 2: Class for FiQuS CWS for FiQuS input
    """

    use_fragment: Optional[bool] = Field(
        default=None, description="Controls if fragment is handled by gmsh only (false) or python with gmsh (ture)"
    )
    concurrent: Optional[bool] = Field(
        default=None, description="Controls if geometry operations are done in concurrent or sequential way"
    )
    conductors: CWSGeometryConductors = CWSGeometryConductors()
    formers: CWSGeometryFormers = CWSGeometryFormers()
    shells: CWSGeometryShells = CWSGeometryShells()
    iron_yokes: CWSGeometryIronYokes = CWSGeometryIronYokes()
    air: CWSGeometryAir = CWSGeometryAir()


class CWSSolveMaterialPropertyListConductors(BaseModel):
    constant: Optional[List[float]] = None  # list of values if constant is used


class CWSSolveMaterialPropertyList(BaseModel):
    constant: Optional[List[float]] = None  # list of values if constant is used
    function: Optional[List[str]] = (
        None  # list of material property function names if function is used
    )


class CWSSolveMaterialPropertySingle(BaseModel):
    constant: Optional[float] = None  # value if constant is used
    function: Optional[str] = (
        None  # material property function name if function is used
    )


class CWSSolveConductorsExcitationFunction(
    BaseModel
):  # Solution time used Conductor _inputs (materials and BC)
    """
    Level 2: Class for FiQuS CWS
    """

    initials: Optional[List[float]] = Field(
        default=None, description="List of initial current in each conductor"
    )
    finals: Optional[List[float]] = Field(
        default=None, description="List of final currents in each conductor"
    )
    names: Optional[List[Literal["exponential", "linear"]]] = Field(
        default=['exponential'],
        description="Currently, these function names are supported: exponential, linear"
    )
    taus: Optional[List[float]] = Field(
        default=None,
        description="Time constant for exponential: Amplitude*Exp(-time/tau), for linear: Amplitude*(time-time_initial)/tau"
                    "For linear ramp, the taus will be added as break points in the solution adaptive time stepping to correctly follow the linear ramp to the end.",
    )

class CWSSolveExcitationFromFile(
    BaseModel
):  # Solution time used Conductor _inputs (materials and BC)
    """
    Level 2: Class for FiQuS CWS
    """

    file_name: Optional[str] = (
        None  # full file name (i.e. with extension) in the input folder or complete path
    )
    time_header: Optional[str] = (
        None  # string defining the time signal header in the txt file
    )
    value_headers: Optional[List[str]] = Field(
        default=None,
        description="String defining the header for current [A], voltage [V] or inductive_voltage [V] in the txt file",
    )
    resistance_headers: Optional[List[str]] = Field(
        default=None,
        description="String defining the header for resistance [ohm] in the txt file. This option only works for inductive_voltage",
    )


class CWSSolveExcitationFromFileHeaters(
    BaseModel
):  # Solution time used Conductor _inputs (materials and BC)
    """
    Level 2: Class for FiQuS CWS
    """

    file_name: Optional[str] = (
        None  # full file name (i.e. with extension) in the input folder or complete path
    )
    time_header: Optional[str] = (
        None  # string defining the time signal header in the txt file
    )
    value_headers: Optional[List[str]] = Field(
        default=None,
        description="String defining the header for Power [W] in the txt file",
    )

class CWSSolveConductorsExcitation(
    BaseModel
):  # Solution time used Conductor _inputs (materials and BC)
    """
    Level 2: Class for FiQuS CWS
    """

    conductors_nw: Optional[List[int]] = Field(
        default=None,
        description="Number of conductors in channel in the height direction (pointing out of the channel direction)",
    )
    conductors_nh: Optional[List[int]] = Field(
        default=None,
        description="Number of conductors in channel in the width direction",
    )
    multips: Optional[List[float]] = Field(
        default=None,
        description="This is decide on polarity of powering the magnet, most often value of 1 or -1 is used. However, arbitrary multiplication is also supported",
    )
    iscivss: Optional[List[float]] = Field(
        default=None, description="Initial Static Current for Inductive Voltage SolutionS (ISCIVSS) in Amps"
    )
    function: CWSSolveConductorsExcitationFunction = (
        CWSSolveConductorsExcitationFunction()
    )
    from_file: CWSSolveExcitationFromFile = (
        CWSSolveExcitationFromFile()
    )
    transient_use: Optional[Literal["function", "from_file"]] = Field(
        default="function",
        title="Use excitation as 'function' or 'from_file'",
        description="Either values from a function or from_file are used",
    )
    mode: Optional[Literal["current", "voltage", "inductive_voltage"]] = Field(
        default="current",
        title="Use excitation in current or voltage mode",
        description="Conductors can be powered in  'current' controlled more or 'voltage' controlled mode or 'inductive voltage' controlled mode.",
    )


class CWSSolveConductors(
    BaseModel
):  # Solution time used Conductor _inputs (materials and BC)
    """
    Level 2: Class for FiQuS CWS
    """

    excitation: CWSSolveConductorsExcitation = CWSSolveConductorsExcitation()
    conductivity_el: CWSSolveMaterialPropertyListConductors = (
        CWSSolveMaterialPropertyListConductors()
    )
    permeability: Optional[List[float]] = None  # relative permeability


class CWSSolveInduced(BaseModel):  # Solution time used fqpls _inputs (materials and BC)
    """
    Level 2: Class for FiQuS CWS
    """

    use: Optional[Literal["function", "constant"]] = Field(
        default="function",
        title="Use Material Property as",
        description="Either values from a function or constant can be used",
    )
    RRR_functions: Optional[List[float]] = None  # RRR to use in material functions
    conductivity_el: CWSSolveMaterialPropertyList = CWSSolveMaterialPropertyList()
    permeability: List[float] = []  # relative permeability
    conductivity_th: CWSSolveMaterialPropertyList = Field(
        default=CWSSolveMaterialPropertyList(),
        alias="conductivity_th",
        description="W/mK",
    )
    heat_capacity: CWSSolveMaterialPropertyList = Field(
        default=CWSSolveMaterialPropertyList(),
        alias="heat_capacity",
        description="J/m^3 K",
    )


class CWSSolveIron(BaseModel):  # Solution time used fqpls _inputs (materials and BC)
    """
    Level 2: Iron yoke solve parameters
    """
    use: Optional[Literal["function", "constant"]] = Field(
        default=None,
        title="Use Material Property as",
        description="Either constant values (permeability) or function (bh_cure)",
    )
    permeability: Optional[List[float]] = Field(
        default=None,
        title="permeability of iron yokesFixed values of permeability for iron yoke.",
        description="The length of the most outer list must correspond to the number of iron yokes in the model"
                    "Fixed values of permeability for iron yoke. Use 1.0 to make iron yoke to be magnetically equivalent to air."
    )

    bh_curve: Optional[List[List[List[float]]]] = Field(
        default=None,
        title="BH curves list of list for each iron yoke",
        description="The length of the most outer list must correspond to the number of iron yokes in the model"
                    "The next inner list consists of two lists of equal length and strictly monotonic, i.e. [B_list, H_list]"
                    "The B_lists consist of values of B in [T] and H_lists consists of values of H in [A/m]",
    )


class CWSSolveHeaterFunction(BaseModel):
    """
    Defines entries for function to use in a form of linearly interpolated LOOK-UP-TABLE (LUT) of power vs time
    """
    times: Optional[List[List[float]]] = Field(
        default=None,
        title="Time look up table",
        description="Time values for power values. This list must be the same length as power_LUT. It is list of list, with each list per heater.",
    )
    powers: Optional[List[List[float]]] = Field(
        default=None,
        title="Time look up table",
        description="Power values [W] for time values specified. This list must be the same length as time_LUT. It is list of list, with each list per heater.",
    )


class CWSSolveCoolingHeatTransferCoefficients(BaseModel):
    use: Optional[Literal["function", "constant", "disabled"]] = Field(
        default="disabled",
        title="Controls what type of cooling is applied to surfaces specified in mesh.cooled_surfaces. The list lengths must match for number of surfaces and constants of functions",
        description="Either values from a function or constant or disabled can be used",
    )
    constant: Optional[List[float]] = None  # heat transfer coefficient in W m^-2 K^-1
    function: Optional[List[str]] = None  # Names of material function to use


class CWSSolveCoolingChannelsInsulationConductivityTh(BaseModel):
    use: Optional[Literal["function", "constant", "disabled"]] = Field(
        default="disabled",
        title="Controls what type of cooling is applied to surfaces specified in mesh.cooled_surfaces. The list lengths must match for number of surfaces and constants of functions",
        description="Either values from a function or constant or disabled can be used",
    )
    constant: Optional[float] = None  # thermal conductivity value
    function: Optional[str] = None  # thermal conductivity funcion name


class CWSSolveCoolingChannels(BaseModel):
    insulation_thickness: Optional[float] = None
    scaling_factor: Optional[float] = None
    insulation_conductivity_th: CWSSolveCoolingChannelsInsulationConductivityTh = CWSSolveCoolingChannelsInsulationConductivityTh()


class CWSSolveCooling(BaseModel):
    heat_transfer_coefficients: CWSSolveCoolingHeatTransferCoefficients = CWSSolveCoolingHeatTransferCoefficients()
    channels: CWSSolveCoolingChannels = CWSSolveCoolingChannels()


class CWSSolveHeaters(BaseModel):  # Solver options for applying BC for heaters
    """
    Level 2: Class for FiQuS CWS
    """

    transient_use: Literal["LUT", "from_file", "disabled"] = Field(
        default="disabled",
        title="Use Material Property as",
        description="Either values from a function or from_file can be used",
    )
    LUT: CWSSolveHeaterFunction = (
        CWSSolveConductorsExcitationFunction()
    )
    from_file: CWSSolveExcitationFromFileHeaters = (
        CWSSolveExcitationFromFileHeaters()
    )


class CWSSolveInsulation(BaseModel):
    """
    Level 2: Class for FiQuS CWS
    """

    thickness: Optional[float] = Field(
        default=None,
        description="Thickness of insulation former to former or former to shell",
    )  #
    conductivity_th: CWSSolveMaterialPropertySingle = CWSSolveMaterialPropertySingle()
    heat_capacity: CWSSolveMaterialPropertySingle = Field(
        default=CWSSolveMaterialPropertySingle(),
        alias="heat_capacity",
        description="J/m^3 K",
    )


class CWSSolveAir(BaseModel):  # Solution time used air _inputs (materials and BC)
    """
    Level 2: Class for FiQuS CWS
    """

    conductivity_el: Optional[float] = Field(
        default=None, description="Electrical conductivity"
    )
    permeability: Optional[float] = Field(
        default=None, description="Relative permeability"
    )


class CWSSolveOutputResample(BaseModel):  # Solution outputs definition
    enabled: Optional[bool] = Field(
        default=None, description="Flag to decide if the output is resampled or not"
    )
    delta_t: Optional[float] = Field(
        default=None, description="Delta time for resampling"
    )


class CWSSolveOutput(BaseModel):  # Solution outputs definition
    saved: Optional[bool] = Field(
        default=None, description="Flat to decide if the output is saved"
    )
    resample: CWSSolveOutputResample = CWSSolveOutputResample()
    variables: Optional[List[str]] = Field(
        default=None, description="Name of variable to post-process by GetDP"
    )
    volumes: Optional[List[str]] = Field(
        default=None, description="Name of volume to post-process by GetDP"
    )
    file_exts: Optional[List[str]] = Field(
        default=None, description="Name of file extensions to output by GetDP"
    )


class CWSSolveNonLinearSettingsTolerance(BaseModel):
    relative: Optional[float] = Field(default=None, description="relative tolerance")
    absolute: Optional[float] = Field(default=None, description="absolute tolerance")
    normType: Optional[str] = Field(
        default=None,
        description="string with norm type, allowed: L1Norm, MeanL1Norm, L2Norm, MeanL2Norm, LinfNorm",
    )


class CWSSolveNonLinearSettings_TH(BaseModel):
    enabled: Optional[bool] = Field(
        default=None,
        description="Flag to decide if constant material properties or nonlinear material functions should be used",
    )
    maximumNumberOfIterations: Optional[int] = Field(
        default=None, description="Number of iterations to use"
    )
    relaxationFactor: Optional[float] = Field(
        default=None, description="Relaxation factor to use"
    )
    tolerance: CWSSolveNonLinearSettingsTolerance = Field(
        default=CWSSolveNonLinearSettingsTolerance(), description="This uses sys_The_trans. The relative and absolute tolerances and the norm type are related to this sys_The_trans")


class CWSSolveNonLinearSettings_EM(BaseModel):
    useNewtonRaphson: Optional[bool] = Field(
        default=False,
        description="Flag to decide if Newton-Raphson method is used",
    )
    maximumNumberOfIterations: Optional[int] = Field(
        default=None, description="Number of iterations to use"
    )
    relaxationFactor: Optional[float] = Field(
        default=None, description="Relaxation factor to use"
    )
    tolerance: CWSSolveNonLinearSettingsTolerance = Field(
        default=CWSSolveNonLinearSettingsTolerance(), description="This uses magnetic energy integrated over the iron volume. The relative and absolute tolerances and the norm type are related to this energy")


class CWSSolveStaticSettings(BaseModel):
    solved: Optional[bool] = Field(
        default=None,
        description="Chooses if static solution is solved. Note the transient solution starts with a static solution, so if this and the transient are set to true, the static is solved twice",
    )
    nonlinear_electromagnetic_iterations: CWSSolveNonLinearSettings_EM = (
        CWSSolveNonLinearSettings_EM()
    )
    output: CWSSolveOutput = CWSSolveOutput()


class CWSSolveTime(BaseModel):
    initial: Optional[float] = Field(default=None, description="Initial time")
    end: Optional[float] = Field(default=None, description="End time")


class CWSSolveTimeFixed(BaseModel):
    step: Optional[float] = Field(default=None, description="Time step")
    theta: Optional[float] = Field(default=None, description="Time stepping scheme")


class CWSSolveTimeAdaptiveLTEInputs(BaseModel):
    names: Optional[List[str]] = Field(
        default=None, description="string: name of post operation to use. For example conv_V_ind_all'conv_V_ind_all' or 'conv_V_ind_first'"
    )
    relatives: Optional[List[float]] = Field(
        default=None, description="relative tolerance"
    )
    absolutes: Optional[List[float]] = Field(
        default=None, description="absolute tolerance"
    )
    normTypes: Optional[List[str]] = Field(
        default=None,
        description="string with norm type, allowed: L1Norm, MeanL1Norm, L2Norm, MeanL2Norm, LinfNorm",
    )


class CWSSolveTimeAdaptiveLTE(BaseModel):
    System: CWSSolveTimeAdaptiveLTEInputs = (
        CWSSolveTimeAdaptiveLTEInputs()
    )  # Quantities of interest specified at system level
    PostOperation: CWSSolveTimeAdaptiveLTEInputs = (
        CWSSolveTimeAdaptiveLTEInputs()
    )  # Quantities of interest specified at PostOperation level


class CWSSolveTimeAdaptive(BaseModel):
    initial_fixed_time_step: Optional[float] = Field(
        default=-1.0,
        description="If this value is set to > 0 then an initial fixed time step is performed",
    )
    initial_step: Optional[float] = Field(
        default=None,
        description="Initial time step. Note this is only used when not starting from previous result",
    )
    min_step: Optional[float] = Field(default=None, description="Minimum time step")
    max_step: Optional[float] = Field(default=None, description="Maximum time step")
    integration_method: Optional[str] = Field(
        default=None,
        description="string: Euler, Trapezoidal, Gear_2, Gear_3, Gear_4, Gear_5, Gear_6",
    )
    breakpoints_every: Optional[float] = Field(
        default=None,
        description="this creates a list from initial to end time with this step",
    )
    additional_breakpoints: Optional[List[float]] = Field(
        default=[],
        description="Additional break points to request, typically when the solution is expected to change steeply, like t_PC_off of LEDET",
    )
    LTE: CWSSolveTimeAdaptiveLTE = CWSSolveTimeAdaptiveLTE()  # local_truncation_errors


class CWSSolveTransientSettings(BaseModel):
    solved: Optional[bool] = Field(
        default=None,
        description="Flag to decide if a transient solution is solved (when true), when false the transient is skipped",
    )
    with_thermal: Optional[bool] = Field(
        default=None,
        description="Flag to decide if thermal transient is is solved and weakly coupled to the electromagnetic (when true), when false only electromagnetic is considered (depending on the flag 'solved' above)",
    )
    thermal_TSA_N_elements: Optional[int] = Field(
        default=None,
        description="When set to 0 the thermal TSA is disabled so the is no heat flow between induced parts. Otherwise, this is number of elements across the thin shell",
    )
    nonlinear_thermal_iterations: CWSSolveNonLinearSettings_TH = (
        CWSSolveNonLinearSettings_TH()
    )
    nonlinear_electromagnetic_iterations: CWSSolveNonLinearSettings_EM = (
        CWSSolveNonLinearSettings_EM()
    )
    time_stepping: Optional[Literal["fixed", "adaptive"]] = Field(
        default=None, description="either 'fixed' or 'adaptive'"
    )
    time: CWSSolveTime = CWSSolveTime()
    fixed: CWSSolveTimeFixed = CWSSolveTimeFixed()
    adaptive: CWSSolveTimeAdaptive = CWSSolveTimeAdaptive()
    em_output: CWSSolveOutput = CWSSolveOutput()
    th_output: CWSSolveOutput = CWSSolveOutput()


class CWSSolve(BaseModel):
    """
    Level 2: Class for FiQuS CWS
    """
    temperature: Optional[float] = None  # Initial temperature for the thermal solve
    link: Optional[bool] = Field(
        default=None,
        description="Decides if powering volumes in a 'linked way' (two windings powered in series with only two terminals) is used. This does not work well, so do not use for now",
    )
    save_last: bool = Field(
        default=False,
        description="This controls if lastTime step only solution is save to allow starting from previous solution",
    )
    start_from_previous: Optional[bool] = Field(
        default=None,
        description="flag to decide if the previous solution (time window of transient should be used as a starting point for this time window)",
    )
    conductors: CWSSolveConductors = (
        CWSSolveConductors()
    )  # windings solution time _inputs
    formers: CWSSolveInduced = CWSSolveInduced()  # formers solution time _inputs
    shells: CWSSolveInduced = CWSSolveInduced()  # shells solution time _inputs
    iron_yokes: CWSSolveIron = CWSSolveIron()
    cooling: CWSSolveCooling = CWSSolveCooling()
    heaters: CWSSolveHeaters = CWSSolveHeaters()  # shells solution time _inputs
    insulation_th: CWSSolveInsulation = (
        CWSSolveInsulation()
    )  # insulation former to former or former to shell, thermal properties only.
    insulation_el: Optional[bool] = Field(
        default=None,
        description="Flag to decide if windings are insulated from formers and formers from each other",
    )
    insulation_turns: Optional[bool] = Field(
        default=None,
        description="Flag to decide if windings are insulated from formers and formers from each other",
    )
    air: CWSSolveAir = CWSSolveAir()  # air solution time _inputs
    pro_template: Optional[str] = None  # file name of .pro template file
    static: CWSSolveStaticSettings = (
        CWSSolveStaticSettings()
    )  # transient solution settings
    transient: CWSSolveTransientSettings = (
        CWSSolveTransientSettings()
    )  # transient solution settings
    noOfMPITasks: Optional[Union[bool, int]] = Field(
        default=False,
        title="No. of tasks for MPI parallel run of GetDP",
        description=(
            "If integer, GetDP will be run in parallel using MPI. This is only valid"
            " if MPI is installed on the system and an MPI-enabled GetDP is used."
            " If False, GetDP will be run in serial without invoking mpiexec."
        ),
    )


class CWSPMeshFieldCoils(BaseModel):
    enabled: Optional[bool] = Field(
        default=False, description="If true the coils lines are added."
    )
    coils: Optional[Dict[Union[str, int], List[List[float]]]] = Field(
        default=None,
        description="Dictionary with structure: key: [[p1_x,p1_y,p1_z], [p2_x,p2_y,p2_z], [p3_x,p3_y,p3_z], [p4_x,p4_y,p4_z]]. At least 3 points are needed. All the pints will be used to create a closed surface.",
    )


class CWSPMeshThCooledSurfaces(BaseModel):
    enabled: Optional[bool] = Field(default=False, description="If true the coils lines are added.")
    surfaces: Optional[List[Union[Literal['auto'], List[int]]]] = Field(default=None, description="Specifies lists of surfaces of the brep file to group together to apply cooling power."
                                                                                                  "If 'auto' is chosen it loops through list of formers + shell and creates automatically a list of surfaces that touch air region")
    names: Optional[List[str]] = Field(default=None, description="Specifies user friendly names for the surfaces")


class CWSPMeshThSensorAndHeater(BaseModel):
    enabled: Optional[bool] = Field(default=False, description="If true the coils lines are added.")
    surfaces: Optional[List[int]] = Field(default=None, description="Specifies surfaces of the brep file to average temperature over or apply heater power.")
    names: Optional[List[str]] = Field(default=None, description="Specifies user friendly names for the surfaces")


class CWSMesh(BaseModel):
    """
    Level 2: Class for FiQuS CWS
    """

    OptimizeNetgenIterations: Optional[int] = Field(default=0, description="This specifies number of Netgen iterations. If >0 gmsh.model.mesh.optimize(method='Netgen', force=False, niter=OptimizeNetgenIterations) is called to optimize mesh.")

    conductor_subregion_splitting: Optional[List[Dict[str, int]]] = Field(default=None, description="This is a list of dictionaries. The list must be as long as the number of conductor files."
                                                                                                    "Each dictionary has two entries:"
                                                                                                    "'i' - initial number of bricks before the splitting point (typically end of first quarter)"
                                                                                                    "'r' - recurring - number of bricks to to complete half of the turn")
    MaxAspectWindings: Optional[float] = (
        None  # used in transfinite mesh_generators settings to define mesh_generators size along two longer lines of hex elements of windings
    )
    Min_length_windings: Optional[float] = (
        None  # sets how small the edge length for the winding geometry volumes could be used. Overwrites the calculated value if it is smaller than this number.
    )
    ThresholdSizeMinWindings: Optional[float] = (
        None  # sets field control of Threshold SizeMin
    )
    ThresholdSizeMaxWindings: Optional[float] = (
        None  # sets field control of Threshold SizeMax
    )
    ThresholdDistMinWindings: Optional[float] = (
        None  # sets field control of Threshold DistMin
    )
    ThresholdDistMaxWindings: Optional[float] = (
        None  # sets field control of Threshold DistMax
    )
    ThresholdSizeMinFormers: Optional[float] = (
        None  # sets field control of Threshold SizeMin
    )
    ThresholdSizeMaxFormers: Optional[float] = (
        None  # sets field control of Threshold SizeMax
    )
    ThresholdDistMinFormers: Optional[float] = (
        None  # sets field control of Threshold DistMin
    )
    ThresholdDistMaxFormers: Optional[float] = (
        None  # sets field control of Threshold DistMax
    )
    ThresholdSizeMinIronYokes: Optional[float] = (
        None  # sets field control of Threshold SizeMin
    )
    ThresholdSizeMaxIronYokes: Optional[float] = (
        None  # sets field control of Threshold SizeMax
    )
    ThresholdDistMinIronYokes: Optional[float] = (
        None  # sets field control of Threshold DistMin
    )
    ThresholdDistMaxIronYokes: Optional[float] = (
        None  # sets field control of Threshold DistMax
    )

    link_terminal: Optional[List[List[int]]] = Field(
        default=None,
        description="Specify which windings are connected by giving indexes of winding to connect in the file_names. This is 0 based indexing. To connect first with second winding this is the entry [[0, 1]]",
    )
    cooled_surfaces: CWSPMeshThCooledSurfaces = CWSPMeshThCooledSurfaces()
    temperature_sensors: CWSPMeshThSensorAndHeater = CWSPMeshThSensorAndHeater()
    heaters: CWSPMeshThSensorAndHeater = CWSPMeshThSensorAndHeater()
    field_coils: CWSPMeshFieldCoils = CWSPMeshFieldCoils()


class CWSPostproc_FieldMap(BaseModel):
    process_static: Optional[bool] = (
        None  # flag to switch on and off processing of static solution for field map
    )
    process_transient: Optional[bool] = (
        None  # flag to switch on and off processing of transient solution for field map
    )
    channel_ws: Optional[List[float]] = None  # wire width
    channel_hs: Optional[List[float]] = None  # wire height
    winding_order: Optional[List[int]] = Field(
        default=None, description="[1, 2, 3, 4, 5, 6, 7, 8]"
    )
    trim_from: Optional[List[int]] = None
    trim_to: Optional[List[int]] = None
    n_points_for_B_avg: Optional[List[int]] = (
        None  # number of points to extract for calculating average for B in the center of each wire turn
    )
    variable: Optional[str] = Field(
        default=None, description="Name of variable to post-process by gmsh for LEDET"
    )  # Name of variable to post-process by python Gmsh API, like B for magnetic flux density
    volume: Optional[str] = Field(
        default=None, description="Name of volume to post-process by gmsh for LEDET"
    )  # Name of volume to post-process by python Gmsh API, line Winding_1
    file_ext: Optional[str] = Field(
        default=None,
        description="Name of file extensions to output to by gmsh for LEDET",
    )  # Name of file extensions o post-process by python Gmsh API, like .pos


class CWSPostprocStaticOrTransient(BaseModel):
    process_static: Optional[bool] = Field(
        default=None,
        description="If true the postprocessing is performed, if false it is not performed",
    )
    process_transient: Optional[bool] = Field(
        default=None,
        description="If true the postprocessing is performed, if false it is not performed",
    )


class CWSPostprocTemperature(BaseModel):
    process_transient: Optional[bool] = (
        None  # flag to switch on and off processing of transient solution of temperature
    )


class CWSPostprocCircuitValues(BaseModel):
    process_static_and_transient: Optional[bool] = (
        None  # flag to switch on and off processing of static and transient solutions for circuit values
    )

class CWSStrandPostprocCleanup(BaseModel):
    """
    Level 3: Class for cleanup settings
    """
    remove_pre_file: bool = Field(
        default=False,
        description="Set True to remove the .pre-file after post-processing, to save disk space.",
    )
    remove_res_file: bool = Field(
        default=False,
        description="Set True to remove the .res-file after post-processing, to save disk space.",
    )
    remove_msh_file: bool = Field(
        default=False,
        description="Set True to remove the .msh-file after post-processing, to save disk space.",
    )

class CWSPostproc(BaseModel):
    """
    Class for FiQuS CWS input file
    """

    field_map: CWSPostproc_FieldMap = CWSPostproc_FieldMap()
    temperature_map: CWSPostprocTemperature = CWSPostprocTemperature()
    temperature_sensors: CWSPostprocTemperature = CWSPostprocTemperature()
    inductance: CWSPostprocStaticOrTransient = CWSPostprocStaticOrTransient()
    circuit_values: CWSPostprocCircuitValues = CWSPostprocCircuitValues()
    field_coils: CWSPostprocStaticOrTransient = CWSPostprocStaticOrTransient()
    cleanup: CWSStrandPostprocCleanup = CWSStrandPostprocCleanup()


class CWS(BaseModel):
    """
    Level 1: Class for FiQuS CWS
    """

    type: Literal["CWS"]
    geometry: CWSGeometry = CWSGeometry()
    mesh: CWSMesh = CWSMesh()
    solve: CWSSolve = CWSSolve()
    postproc: CWSPostproc = CWSPostproc()
