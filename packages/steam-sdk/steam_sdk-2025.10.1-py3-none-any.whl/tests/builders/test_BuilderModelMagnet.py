import os
import unittest
from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np

from steam_sdk.builders.BuilderLEDET import BuilderLEDET
from steam_sdk.builders.BuilderModel import BuilderModel
from steam_sdk.parsers.ParserLEDET import CompareLEDETParameters, ParserLEDET, check_for_differences
from steam_sdk.parsers.ParserMap2d import ParserMap2dFile
from steam_sdk.parsers.ParserProteCCT import CompareProteCCTParameters
from steam_sdk.utils.delete_if_existing import delete_if_existing
from steam_sdk.utils.read_settings_file import read_settings_file
from tests.TestHelpers import assert_equal_yaml


class TestBuilderModel(unittest.TestCase):

    @classmethod
    def setUpClass(cls) -> None:
        """
        This function is executed once before any tests in this class
        """
        delete_if_existing(os.path.join(os.path.dirname(__file__), 'output'), verbose=True)

    def setUp(self) -> None:
        """
            This function is executed before each test in this class
        """
        self.current_path = os.path.dirname(__file__)
        os.chdir(os.path.dirname(__file__))  # move the directory where this file is located
        print('\nCurrent folder:          {}'.format(self.current_path))
        print('Test is run from folder: {}'.format(os.getcwd()))

        absolute_path_settings_folder = str(Path(os.path.join(os.getcwd(), '../')).resolve())
        self.settings = read_settings_file(absolute_path_settings_folder=absolute_path_settings_folder, verbose=True)

    def tearDown(self) -> None:
        """
            This function is executed after each test in this class
        """
        os.chdir(self.current_path)  # go back to initial folder

        # Close all figures
        plt.close('all')


    def test_BuilderModel_initialization(self):
        """
            Check that an exception is raised when BuilderModel object is initialized without providing an input yaml file
        """
        with self.assertRaises(Exception) as context:
            BuilderModel(file_model_data=None, verbose=True)
        self.assertTrue('No file_model_data .yaml input file provided.' in str(context.exception))
        print(f'This exception was correctly raised: {context.exception}')

    def test_BuilderModel_readYaml_REFERENCE(self):
        """
            Check that DataLEDET object can be initialized and can read the reference blank yaml file generated by DataModelMagnet()
        """
        # arrange
        name_reference_file = 'data_model_magnet_REFERENCE_default.yaml'
        file_path = os.path.dirname(__file__)  # path to the parent directory (with respect to this file)
        reference_file = os.path.join(os.path.dirname(file_path), 'data', 'references', name_reference_file)
        print("Selected reference_file: {}".format(reference_file))

        # act
        BM = BuilderModel(file_model_data=reference_file, data_settings=self.settings, verbose=True)

        # assert
        # TODO: Add a sensible action to perform the test
        # This test is likely covered by ParserYaml test, consider removing.

    def test_BuilderModel_readYaml(self, magnet_name='MQXF_V2'):
        """
            Check that BuilderModel object can be initialized and can read a model input yaml file
            This test does not generate any output file
            magnet_name: can be any magnet name in the library
        """
        # arrange
        file_model_data = os.path.join('model_library', 'magnets', magnet_name, 'input', 'modelData_' + magnet_name + '.yaml')

        # act
        BM = BuilderModel(file_model_data=file_model_data, data_settings=self.settings, verbose=True)

        # assert
        # TODO: Add a sensible action to perform the test

    def test_BuilderModel_FiQuS(self, verbose: bool = False):
        """
            Check that BuilderModel object can be initialized, read a real model input yaml file, and generate a yaml
            file with all model data
        """
        # arrange
        #magnet_names = ['HTS1', 'MQXA', 'CWS_1', 'CAC_Strand_hexFilaments', 'CAC_Rutherford']
        magnet_names = [] # switching off this test as the same is already checked by test_ParserFiQuS
        software = 'FiQuS'
        for name in magnet_names:
            file_model_data = os.path.join('model_library', 'magnets', name, 'input', f'modelData_{name}.yaml')
            output_path = os.path.join('model_library', 'magnets', name, 'output')
            delete_if_existing(output_path, verbose=True)

            # act
            BM = BuilderModel(file_model_data=file_model_data, data_settings=self.settings, verbose=True)
            BM.buildFiQuS(sim_name=name, sim_number='', output_path=output_path, flag_plot_all=False, verbose=verbose)

            # # assert
            file_extensions_to_test = BM.parser_FiQuS.file_exts
            output_files = [os.path.join(output_path, f'{name}_{software}.{ext}') for ext in file_extensions_to_test]
            reference_files = [os.path.join('references', 'magnets', name, f'{name}_{software}_REFERENCE.{ext}') for ext in file_extensions_to_test]

            for output_file, reference_file in zip(output_files, reference_files):
                print(f'Comparing: Output file: {output_file} with reference file: {reference_file}.')
                assert_equal_yaml(output_file, reference_file)

    def test_BuilderModel_GEOM(self, verbose: bool = False):
        """
            Check that parser roxie creates correct .geom file. These files are used by FiQuS and PySIGMA
        """
        not_working = ['dummy_MBH_2in1_with_multiple_QH', 'MBH_4in1', 'MCBH_1AP', 'MU',]  # MU is bloc coil
        cos_theta = ['MQXA', 'MBH_1in1','FERMI_20T', 'MBH_2in1', 'MBRB', 'MBRC', 'MBRD', 'MBRS', 'MBX', 'MBXF', 'MB_2COILS', 'MCBCH_1AP', 'MCBCV_1AP', 'MCBV_1AP',
                     'MCBXH', 'MCBXV', 'MCBX_HV', 'MCBYH_1AP', 'MCBYV_1AP', 'MCD', 'MCDO', 'MCO', 'MCS', 'MDP_20T_CT_V28', 'MED_C_COMB', 'MLEC','MO', 'MO_1AP', 'MQMC_2in1', 'MQML_2in1', 'MQM_2in1',
                     'MQSX', 'MQS_1AP', 'MQTLH_1AP', 'MQTLI_1AP', 'MQT_1AP', 'MQXB', 'MQXF_V2', 'MQY_2in1', 'MQ_1AP', 'MSS_1AP', 'MS_1AP', 'FALCOND_C', 'FALCOND_C_MIN', 'FALCOND_C_MIN_COLLAR',
                     'FALCOND_C_COLLAR', 'FALCOND_C_COLLAR_HOLE', 'FALCOND_C_COLLAR_HOLE_POLE']
        common_coil =  ['SMC', 'RMM_V1', 'ERMC_V1']
        block_coil = ['HEPDipo_4COILS']
        cos_theta_with_ESC = ['FALCOND_C_ESC']
        cos_theta_with_ECLIQ = ['FALCOND_C_ECLIQ']

        magnet_names = cos_theta + common_coil + block_coil + cos_theta_with_ESC + cos_theta_with_ECLIQ
        software = 'FiQuS'
        for name in magnet_names:
            file_model_data = os.path.join('model_library', 'magnets', name, 'input', f'modelData_{name}.yaml')
            output_path = os.path.join('model_library', 'magnets', name, 'output')
            delete_if_existing(output_path, verbose=True)

            # act
            BM = BuilderModel(file_model_data=file_model_data, data_settings=self.settings, verbose=True)
            BM.buildFiQuS(sim_name=name, sim_number='', output_path=output_path, flag_plot_all=False, verbose=verbose)

            # # assert
            file_extensions_to_test = ["geom"]
            output_files = [os.path.join(output_path, f'{name}_{software}.{ext}') for ext in file_extensions_to_test]
            reference_files = [os.path.join('references', 'magnets', name, f'{name}_{software}_REFERENCE.{ext}') for ext
                               in file_extensions_to_test]

            for output_file, reference_file in zip(output_files, reference_files):
                print(f'Comparing: Output file: {output_file} with reference file: {reference_file}.')
                assert_equal_yaml(output_file, reference_file)


    def test_BuilderModel_PySIGMA(self):
        """
            Check that BuilderModel object can be initialized, read a real model input yaml file, and generate a yaml
            file with all model data
        """
        # arrange
        magnet_names = ['MQXA']
        software = 'SIGMA'
        sim_number = 1
        for magnet_name in magnet_names:
            file_model_data = str(Path(os.path.join('model_library', 'magnets', magnet_name, 'input', f'modelData_{magnet_name}.yaml')).resolve())
            output_path = str(Path(os.path.join('model_library', 'magnets', magnet_name, 'output', 'PySIGMA')).resolve())
            delete_if_existing(output_path, verbose=True)
            results_folder_name = 'output_folder'
            # act
            print(f'self.current_path before BM: {self.current_path}')
            BM = BuilderModel(file_model_data=file_model_data, data_settings=self.settings, verbose=True)
            BM.buildPySIGMA(sim_name=magnet_name, sim_number=sim_number, output_path=output_path, flag_plot_all=False)

            # assert
            file_extensions_to_test = BM.parser_SIGMA.file_exts
            output_files = [os.path.join(output_path, f'{magnet_name}_{sim_number}.{ext}') for ext in
                            file_extensions_to_test]
            reference_files = [
                os.path.join('references', 'magnets', magnet_name, f'{magnet_name}_{software}_REFERENCE.{ext}') for ext
                in file_extensions_to_test]

            for output_file, reference_file in zip(output_files, reference_files):
                output_file = Path(output_file).resolve()
                print(f'self.current_path after BM: {self.current_path}')
                reference_file_path = os.path.join(self.current_path, reference_file)
                print(f'Comparing: Output file: {output_file} with reference file: {reference_file_path}.')
                # assert_equal_yaml(output_file, reference_file_path, keys_to_ignore=['Sources'])

    def test_BuilderModel_LEDET_CCT(self):
        magnet_names = ['MCBRD']  # this is a small subset of tests for a lean pipeline
        file_type = '.yaml'
        for magnet_name in magnet_names:
            print('Magnet: {}'.format(magnet_name))
            self._compare_to_reference_LEDET(magnet_name, verbose=True, magnet_type='CCT_straight', file_type=file_type)

    def test_BuilderModel_LEDET_CWS(self):
        magnet_names = ['CCT_1']  # this is a small subset of tests for a lean pipeline
        for magnet_name in magnet_names:
            print('Magnet: {}'.format(magnet_name))
            self._compare_to_reference_LEDET(magnet_name, verbose=True, flag_plot_all=False, magnet_type='CWS')

    def test_BuilderModel_LEDET_solenoid(self):
        magnet_names = ['MLEC']  # this is a small subset of tests for a lean pipeline
        for magnet_name in magnet_names:
            print('Magnet: {}'.format(magnet_name))
            self._compare_to_reference_LEDET(magnet_name, verbose=True, magnet_type='solenoid')

    def test_BuilderModel_LEDET_multiple(self):
        # This is a list of magnets whose models fail this test on 2023/11/20
        magnet_names_to_check = ['MBH_1in1', # Parameter iContactAlongHeight_From has a length of 104 in file A and 108 in file B.      Parameter iContactAlongHeight_To has a length of 104 in file A and 108 in file B.
                         'MBH_4in1', # nT[elPairs_GroupTogether[p][0] - 1] != nT[elPairs_GroupTogether[p][1] - 1]: IndexError: list index out of range
                         'MCBX_HV', # el_order_half_turns, M_m
                         'MCBXH', # el_order_half_turns
                         'MCBXV', # el_order_half_turns
                         'MCBYV_1AP', # el_order_half_turns
                         'MCBH_1AP', # nT[elPairs_GroupTogether[p][0] - 1] != nT[elPairs_GroupTogether[p][1] - 1]: IndexError: list index out of range
                         'MCBV_1AP', # el_order_half_turns
                         'MCBCH_1AP', # el_order_half_turns
                         'MU', # rearrange_half_turns_ribbon     raise ValueError("Mixed Ribbon and Rutherford cables are not supported!") ValueError: Mixed Ribbon and Rutherford cables are not supported!
                         'HTS1', # addThermalConnections    iContactAlongHeight_From_to_add.append(p[0]) IndexError: tuple index out of range
                         ]
        print(f'magnet_names_to_check: {sorted(magnet_names_to_check)}')
        # MQY_2in1 causes memory issues when run on Gitlab
        magnet_names_working_but_test_on_gitlab_would_take_too_long = ['MCBYV_1AP', 'MCBCV_1AP', 'MCBH_1AP', 'MCBV_1AP', 'MCBCH_1AP', 'MU']
        magnet_names = ['MBRB', 'MQXF_V2', 'MQSX', 'MBRD', 'MBXF', 'MB_2COILS',
                        'MED_C_COMB', 'MO_1AP', 'MO', 'MS_1AP', 'MQT_1AP', 'MBH_1in1',
                        'MQTLH_1AP', 'MQTLI_1AP', 'MQS_1AP', 'MBRC',
                        'ERMC_V1', 'HEPDipo_4COILS', 'MCD', 'RMM_V1', 'MCBYH_1AP', 'MCS', 'MBX', 'MQXA',
                        'MBRS', 'MCBX_HV', 'MCBXH', 'MCBXV', 'CFD_600A',
                        'MQMC_2in1', 'MQM_2in1', 'MQML_2in1', 'MQ_1AP', 'MQXB', 'MQY_2in1', 'MCO', 'MCDO', 'MSS_1AP',
                        'SMC'
                        ]
        magnet_names = ['MBRB', 'MQXF_V2', 'MQSX', 'MS_1AP', 'MO_1AP', 'FERMI_20T', 'SMC']  # this is a small subset of tests for a lean pipeline

        for magnet_name in magnet_names:
            print('Magnet: {}'.format(magnet_name))
            self._compare_to_reference_LEDET(magnet_name, verbose=False)

    def test_BuilderModel_LEDET_multiple_QH_layers(self):
        magnet_names = ['dummy_MBH_2in1_with_multiple_QH']

        for magnet_name in magnet_names:
            print('Magnet: {}'.format(magnet_name))
            self._compare_to_reference_LEDET(magnet_name, verbose=False)

    def test_BuilderModel_LEDET_BotturaFitNbTi(self):
        magnet_names = ['dummy_MO_1AP_withBotturaFit']

        for magnet_name in magnet_names:
            print('Magnet: {}'.format(magnet_name))
            self._compare_to_reference_LEDET(magnet_name, verbose=False)

    # def test_BuilderModel_LEDET_dummy_TO_DELETE(self):
    #     magnet_names = ['dummy_all_materials']

        for magnet_name in magnet_names:
            print('Magnet: {}'.format(magnet_name))
            self._compare_to_reference_LEDET(magnet_name, verbose=False)

    def test_BuilderModel_LEDET_json(self, magnet_name='MQXF_V2', max_relative_error=1E-5, verbose=False):
        """
            Check that BuilderModel object can be initialized, read a real model input yaml file, and generate a json
            file that can be used as a LEDET input file

            Additionally, this test also checks that BuilderLEDET accepts a string as sim_number argument

            :param magnet_name: can be any magnet name in the library
        """
        # arrange
        file_model_data = os.path.join('model_library', 'magnets', magnet_name, 'input', 'modelData_' + magnet_name + '.yaml')
        output_path = os.path.join('output', 'test_LEDET_json', magnet_name)
        delete_if_existing(output_path, verbose=True)
        sim_number = '_string_attached_to_file_name'

        json_file_REFERENCE = os.path.join('references', 'magnets', magnet_name, magnet_name + "_REFERENCE.json")
        json_file_GENERATED = os.path.join(output_path, f'{magnet_name}{sim_number}.json')

        # act
        BM = BuilderModel(file_model_data=file_model_data, data_settings=self.settings, verbose=False)
        BM.buildLEDET(sim_name=magnet_name, sim_number=sim_number, output_path=output_path, flag_json=True, flag_plot_all=False, verbose=False)

        # assert: read reference json file, read generaed json file, and compare them
        builder_ledet_ref = BuilderLEDET(flag_build=False)
        pl_ref = ParserLEDET(builder_ledet_ref)
        pl_ref.read_from_json(json_file_REFERENCE, verbose=True)

        builder_ledet_out = BuilderLEDET(flag_build=False)
        pl_out = ParserLEDET(builder_ledet_out)
        pl_out.read_from_json(json_file_GENERATED, verbose=True)

        print(check_for_differences(pl_ref, pl_out, max_relative_error=max_relative_error, verbose=verbose))
        print(pl_ref.builder_ledet.Inputs)
        print(pl_out.builder_ledet.Inputs)

        self.assertFalse(check_for_differences(pl_ref, pl_out, max_relative_error=max_relative_error, verbose=verbose))

    def test_BuilderModel_LEDET_plotAll(self, magnet_name='MBRD'):
        self._compare_to_reference_LEDET(magnet_name, verbose=False, flag_plot_all=True)

    def test_BuilderModel_ProteCCT(self):
        magnet_names = ['MCBRD']
        for magnet_name in magnet_names:
            print('Magnet: {}'.format(magnet_name))
            self._compare_to_reference_ProteCCT(magnet_name, verbose=False)

    # def test_get_conductor_corners(self, magnet_name='MBRD'):
    #     file_model_data = os.path.join('model_library', 'magnets', magnet_name, 'input', 'modelData_' + magnet_name + '.yaml')
    #     output_path = os.path.join('model_library', 'magnets', magnet_name, 'output')
    #     BM = BuilderModel(file_model_data=file_model_data, data_settings=self.data_settings, output_path=output_path)
    #     BM.buildLEDET(flag_json=False, flag_plot_all=False, verbose=False)
    #     # RL = RoxieList(BM.roxie_data)
    #     # RL.x_insulated
    #     # RL.y_insulated
    #     # RL.x_bare
    #     # RL.y_bare
    #     # RL.i_conductor
    #     # RL.x_strand
    #     # RL.y_strand
    #     # RL.i_strand
    #     # RL.strand_to_halfTurn
    #     # TODO: Check that the corner position values are correct

    def test_BuilderModel_LEDET_inductance_fieldMaps_sets(self):
        # arrange - define input
        magnet_name = 'MBRB'
        sim_number = 911
        sim_set_csv = 912
        sim_set_map2d = 913
        suffix = '_All_WithIron_WithSelfField'
        verbose = False

        file_model_data = os.path.join('model_library', 'magnets', magnet_name, 'input', f'modelData_{magnet_name}.yaml')
        output_path = os.path.join('output', 'output_BuilderModel_LEDET_inductance_fieldMaps_sets')
        delete_if_existing(output_path, verbose=True)
        xlsx_file_GENERATED = os.path.join(output_path, f'{magnet_name}_{sim_number}.xlsx')
        yaml_file_GENERATED = os.path.join(output_path, f'{magnet_name}_{sim_number}.yaml')
        csv_file_GENERATED = os.path.join(output_path, f'{magnet_name}_selfMutualInductanceMatrix_{sim_set_csv}.csv')
        map2d_file_GENERATED = os.path.join(output_path, f'{magnet_name}{suffix}_{sim_set_map2d}.map2d')

        # arrange - initialize BuilderModel object and modify two keys
        BM = BuilderModel(file_model_data=file_model_data, data_settings=self.settings, verbose=verbose)
        BM.model_data.Options_LEDET.input_generation_options.selfMutualInductanceFileNumber = sim_set_csv
        BM.model_data.Options_LEDET.field_map_files.fieldMapNumber = sim_set_map2d

        # act

        BM.buildLEDET(sim_name=magnet_name, sim_number=sim_number, output_path=output_path, flag_plot_all=False, verbose=verbose)

        # assert
        self.assertTrue(os.path.isfile(xlsx_file_GENERATED))
        self.assertTrue(os.path.isfile(yaml_file_GENERATED))
        self.assertTrue(os.path.isfile(csv_file_GENERATED))
        self.assertTrue(os.path.isfile(map2d_file_GENERATED))

    def test_calc_electrical_order_manualEntries(self):
        """
            Check that calc_electrical_order() calculates correctly. The test use-case is for MQXF_V2 and the input variables are defined manually
        """
        # arrange
        el_order_half_turns_reference_MQXF_V2 = [129, 329, 130, 330, 131, 331, 132, 332, 133, 333, 134, 334, 135, 335,
                                                 136, 336, 137, 337, 138, 338, 139, 339, 140, 340, 141, 341, 142, 342,
                                                 143, 343, 144, 344, 145, 345, 146, 346, 147, 347, 148, 348, 149, 349,
                                                 150, 350, 128, 328, 127, 327, 126, 326, 125, 325, 124, 324, 123, 323,
                                                 122, 322, 121, 321, 120, 320, 119, 319, 118, 318, 117, 317, 116, 316,
                                                 115, 315, 114, 314, 113, 313, 112, 312, 111, 311, 110, 310, 109, 309,
                                                 108, 308, 107, 307, 106, 306, 105, 305, 104, 304, 103, 303, 102, 302,
                                                 101, 301, 251, 51, 252, 52, 253, 53, 254, 54, 255, 55, 256, 56, 257,
                                                 57, 258, 58, 259, 59, 260, 60, 261, 61, 262, 62, 263, 63, 264, 64, 265,
                                                 65, 266, 66, 267, 67, 268, 68, 269, 69, 270, 70, 271, 71, 272, 72, 273,
                                                 73, 274, 74, 275, 75, 276, 76, 277, 77, 278, 78, 300, 100, 299, 99,
                                                 298, 98, 297, 97, 296, 96, 295, 95, 294, 94, 293, 93, 292, 92, 291, 91,
                                                 290, 90, 289, 89, 288, 88, 287, 87, 286, 86, 285, 85, 284, 84, 283, 83,
                                                 282, 82, 281, 81, 280, 80, 279, 79, 351, 151, 352, 152, 353, 153, 354,
                                                 154, 355, 155, 356, 156, 357, 157, 358, 158, 359, 159, 360, 160, 361,
                                                 161, 362, 162, 363, 163, 364, 164, 365, 165, 366, 166, 367, 167, 368,
                                                 168, 369, 169, 370, 170, 371, 171, 372, 172, 373, 173, 374, 174, 375,
                                                 175, 376, 176, 377, 177, 378, 178, 400, 200, 399, 199, 398, 198, 397,
                                                 197, 396, 196, 395, 195, 394, 194, 393, 193, 392, 192, 391, 191, 390,
                                                 190, 389, 189, 388, 188, 387, 187, 386, 186, 385, 185, 384, 184, 383,
                                                 183, 382, 182, 381, 181, 380, 180, 379, 179, 29, 229, 30, 230, 31, 231,
                                                 32, 232, 33, 233, 34, 234, 35, 235, 36, 236, 37, 237, 38, 238, 39, 239,
                                                 40, 240, 41, 241, 42, 242, 43, 243, 44, 244, 45, 245, 46, 246, 47, 247,
                                                 48, 248, 49, 249, 50, 250, 28, 228, 27, 227, 26, 226, 25, 225, 24, 224,
                                                 23, 223, 22, 222, 21, 221, 20, 220, 19, 219, 18, 218, 17, 217, 16, 216,
                                                 15, 215, 14, 214, 13, 213, 12, 212, 11, 211, 10, 210, 9, 209, 8, 208,
                                                 7, 207, 6, 206, 5, 205, 4, 204, 3, 203, 2, 202, 1, 201]

        # Define test input variables
        test_flag_typeWindings = 'multipole'
        test_nT = [16, 12, 17, 5, 16, 12, 17, 5, 16, 12, 17, 5, 16, 12, 17, 5, 16, 12, 17, 5, 16, 12, 17, 5, 16, 12, 17,
                   5, 16, 12, 17, 5]
        test_elPairs_GroupTogether = [[11, 27], [12, 28], [10, 26], [9, 25], [21, 5], [22, 6], [24, 8], [23, 7],
                                      [29, 13], [30, 14], [32, 16], [31, 15], [3, 19], [4, 20], [2, 18], [1, 17]]
        test_elPairs_RevElOrder = [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]

        # Calculate more required variables (they would normally be calculated by the BuilderLEDET object)
        test_indexTstop = np.cumsum(test_nT)
        test_indexTstop = test_indexTstop.tolist()
        test_indexTstart = [1]
        for i in range(len(test_nT) - 1):
            test_indexTstart.extend([test_indexTstart[i] + test_nT[i]])

        # Assign test variables to an empty BuilderLEDET object
        file_model_data_DUMMY = os.path.join(os.path.dirname(os.getcwd()), 'data', 'references', 'data_model_magnet_REFERENCE_default.yaml')  # This is to basically initialize an empty object
        BM = BuilderModel(file_model_data=file_model_data_DUMMY, data_settings=self.settings, verbose=True)
        BM.model_data.GeneralParameters.magnet_type = test_flag_typeWindings
        BM.model_data.CoilWindings.electrical_pairs.group_together = test_elPairs_GroupTogether
        BM.model_data.CoilWindings.electrical_pairs.reversed = test_elPairs_RevElOrder
        BM.roxie_params.nT = test_nT
        BM.roxie_params.indexTstart = test_indexTstart
        BM.roxie_params.indexTstop = test_indexTstop
        BM.roxie_params.strandToGroup = None  # Only needed for plotting purposes. Not needed for this test
        BM.roxie_params.strandToHalfTurn = None  # Only needed for plotting purposes. Not needed for this test

        # act
        el_order_half_turns_test = BM.calc_electrical_order()

        # assert
        self.assertListEqual(list(el_order_half_turns_test), list(el_order_half_turns_reference_MQXF_V2))  # check values are correctly calculated
        self.assertListEqual(list(BM.el_order_half_turns), list(el_order_half_turns_reference_MQXF_V2))  # check values are correctly set

    ###############################################################################################
    # Helper methods
    def _compare_to_reference_LEDET(self, magnet_name, verbose=False, flag_plot_all=False, magnet_type='multipole', file_type: str = '.xlsx'):
        """
            Helper method called by other methods
            Check that BuilderModel object can be initialized, read a model input yaml file, and generate a LEDET model
            This test checks:
             - the content of the generated Excel file against a reference LEDET Excel file
             - the content of the generated csv file against a reference self-mutual inductance csv file
             - the content of the generated map2d file against a reference magnetic-field map map2d file

            magnet_name: can be any magnet name in the library
        """

        # arrange
        max_relative_error = 1e-6  # Maximum accepted relative error for excel, csv and map2d file comparison
        sim_number = 0

        file_model_data = os.path.join('model_library', 'magnets', magnet_name, 'input', f'modelData_{magnet_name}.yaml')
        output_path = os.path.join('model_library', 'magnets', magnet_name, 'output')
        delete_if_existing(output_path, verbose=True)
        input_file_REFERENCE = os.path.join('references', 'magnets', magnet_name, f'{magnet_name}_REFERENCE{file_type}')
        input_file_GENERATED = os.path.join('model_library', 'magnets', magnet_name, 'output', f'{magnet_name}_{sim_number}{file_type}')

        if magnet_type not in ['CCT_straight', 'CWS']:  # check also .map2d and selfMutualInductanceMatrix.csv files for non CCT magnets

            csv_file_REFERENCE = os.path.join('references', 'magnets', magnet_name, f'{magnet_name}_selfMutualInductanceMatrix_REFERENCE.csv')
            csv_file_GENERATED = os.path.join('model_library', 'magnets', magnet_name, 'output', f'{magnet_name}_selfMutualInductanceMatrix.csv')

            if magnet_name in ['MED_C_COMB']:
                suffix = '_All_WithIron_NoSelfField'
            else:
                suffix = '_All_WithIron_WithSelfField'
            if magnet_type == 'solenoid':
                suffix = '_All_NoIron_NoSelfField'

            map2d_file_REFERENCE = os.path.join('references', 'magnets', magnet_name, magnet_name + suffix + "_REFERENCE.map2d")
            map2d_file_GENERATED = os.path.join('model_library', 'magnets', magnet_name, 'output', magnet_name + suffix + ".map2d")

        # act
        BM = BuilderModel(file_model_data=file_model_data, data_settings=self.settings, verbose=verbose)
        BM.buildLEDET(sim_name=magnet_name, sim_number=sim_number, output_path=output_path, flag_plot_all=flag_plot_all, verbose=verbose)

        # assert 1 - Check that the generated LEDET file has the same input as the reference
        if file_type == '.xlsx':
            self.assertTrue(CompareLEDETParameters(input_file_GENERATED,
                                                   input_file_REFERENCE,
                                                   max_relative_error=max_relative_error, verbose=verbose))
        elif file_type == '.yaml':
            assert_equal_yaml(input_file_REFERENCE, input_file_GENERATED, check_for_same_order=True)

        if magnet_type not in ['CCT_straight', 'CWS']:  # check also .map2d and selfMutualInductanceMatrix.csv files for non CCT magnets

            # assert 2 - Check that the generated csv file differs from the reference by less than max_relative_error
            self._compare_two_csv_files(magnet_name, csv_file_REFERENCE, csv_file_GENERATED, max_relative_error=max_relative_error)

            # assert 3a - Check that the generated map2d file differs from the reference by less than max_relative_error
            values_REFERENCE = ParserMap2dFile(map2dFile=Path(map2d_file_REFERENCE)).parseRoxieMap2d(headerLines=1)
            values_GENERATED = ParserMap2dFile(map2dFile=Path(map2d_file_GENERATED)).parseRoxieMap2d(headerLines=1)
            np.testing.assert_allclose(values_GENERATED, values_REFERENCE, rtol=max_relative_error, atol=0)
            print(f"Files {map2d_file_REFERENCE} and {map2d_file_GENERATED} differ by less than {max_relative_error * 100}%.")

            # assert 3b - Check that the existing ...E.map2d files are correctly copied
            input_path = os.path.join('model_library', 'magnets', magnet_name, 'input')
            number_input_files = len([entry for entry in os.listdir(input_path) if os.path.isfile(os.path.join(input_path, entry))])

            for file in range(number_input_files + 1):
                path_map2d_E = os.path.join(input_path, f'{magnet_name}_E{file}.map2d')
                if os.path.isfile(path_map2d_E):
                    if magnet_name in ['MED_C_COMB']:
                        suffix = f'_E{file}_WithIron_NoSelfField'
                    else:
                        suffix = f'_E{file}_WithIron_WithSelfField'

                    if magnet_type == 'solenoid':
                        suffix = f'_E{file}NoIron_NoSelfField'

                    map2d_E_file_REFERENCE = os.path.join('references', 'magnets', magnet_name, f'{magnet_name}{suffix}_REFERENCE.map2d')
                    map2d_E_file_GENERATED = os.path.join('model_library', 'magnets', magnet_name, 'output', f'{magnet_name}{suffix}.map2d')
                    values_REFERENCE_E = ParserMap2dFile(map2dFile=Path(map2d_E_file_REFERENCE)).parseRoxieMap2d(headerLines=1)
                    values_GENERATED_E = ParserMap2dFile(map2dFile=Path(map2d_E_file_GENERATED)).parseRoxieMap2d(headerLines=1)
                    np.testing.assert_allclose(values_GENERATED_E, values_REFERENCE_E, rtol=max_relative_error, atol=0)
                    print(f"Files {map2d_E_file_REFERENCE} and {map2d_E_file_GENERATED} differ by less than {max_relative_error * 100}%.")

    def _compare_to_reference_ProteCCT(self, magnet_name, verbose=False):
        """
            Helper method called by other methods
            Check that BuilderModel object can be initialized, read a model input yaml file, and generate a ProteCCT model
            This test checks:
             - the content of the generated Excel file against a reference ProteCCT Excel file

            magnet_name: can be any magnet name in the library
        """

        # arrange
        max_relative_error = 1e-6  # Maximum accepted relative error for excel, csv and map2d file comparison
        sim_number = 0
        file_model_data = os.path.join('model_library', 'magnets', magnet_name, 'input', f'modelData_{magnet_name}.yaml')
        output_path = os.path.join('model_library', 'magnets', magnet_name, 'output', 'ProteCCT')
        delete_if_existing(output_path, verbose=True)
        input_file_REFERENCE = os.path.join('references', 'magnets', magnet_name, f'{magnet_name}_ProteCCT_REFERENCE.xlsx')
        input_file_GENERATED = os.path.join(output_path, f'{magnet_name}_{sim_number}.xlsx')

        # act
        BM = BuilderModel(file_model_data=file_model_data, data_settings=self.settings, verbose=verbose)
        BM.buildProteCCT(sim_name=magnet_name, sim_number=sim_number, output_path=output_path)

        # assert 1 - Check that the generated ProteCCT file has the same input as the reference
        self.assertTrue(CompareProteCCTParameters(input_file_GENERATED,
                                                   input_file_REFERENCE,
                                                   max_relative_error=max_relative_error, verbose=verbose))
        # # TODO: Write BuilderProteCCT.CompareProteCCTParameters

    def _compare_two_csv_files(self, magnet_name, path_generated=None, path_reference=None,
                               max_relative_error: float = 0):
        """
            Helper method called by other methods to compare csv files
            max_relative_error: Maximum accepted relative error [-]
        """

        # arrange
        if not path_generated:
            path_generated = os.path.join('output', magnet_name, magnet_name + "_selfMutualInductanceMatrix.csv")
        if not path_reference:
            path_reference = os.path.join('references', 'magnets', magnet_name, magnet_name + "_selfMutualInductanceMatrix_REFERENCE.csv")

        data_generated = np.genfromtxt(path_generated, dtype=float, delimiter=',', skip_header=1)
        data_reference = np.genfromtxt(path_reference, dtype=float, delimiter=',', skip_header=1)

        # Check that the number of elements in the generated matrix is the same as in the reference file
        if data_generated.size != data_reference.size:
            raise Exception('Generated csv file does not have the correct size.')

        relative_differences = np.abs(
            data_generated - data_reference) / data_reference  # Matrix with absolute values of relative differences between the two matrices
        max_relative_difference = np.max(np.max(relative_differences))  # Maximum relative difference in the matrix
        self.assertAlmostEqual(0, max_relative_difference,
                               delta=max_relative_error)  # Check that the maximum relative difference is below
        print("Files {} and {} differ by less than {}%.".format(path_generated, path_reference,
                                                                max_relative_difference * 100))

        # Compare the values inside the matrix and check they do not differ from the reference values by more than MAX_RELATIVE_ERROR, element by element [THIS IS REDUNDANT]
        # for row in range(len(data_generated)):
        #     for col in range(len(data_generated[row])):
        #         self.assertAlmostEqual(data_reference[row][col], data_generated[row][col], delta=max_relative_error*np.abs(data_reference[row][col]))
