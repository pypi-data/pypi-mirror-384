"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_core.ipynb.

# %% auto 0
__all__ = ['stripe_api_url', 'names', 'op2nm', 'StripeApi']

# %% ../nbs/01_core.ipynb 2
from fastcore.all import *
from .endpoints import eps
from .spec import docs_url
from inspect import Parameter, Signature

import re

# %% ../nbs/01_core.ipynb 4
stripe_api_url = 'https://api.stripe.com'

# %% ../nbs/01_core.ipynb 7
def _mk_param(name, **kwargs):
    kwargs.pop('description', None)
    return Parameter(name, kind=Parameter.POSITIONAL_OR_KEYWORD, **kwargs)

def _mk_sig(req_args, opt_args, anno_args):
    'req_args are args inside paths such as {account}, opt_args are query params, anno_args are payload params'
    params =  [_mk_param(k) for k in req_args]
    params += [_mk_param(**p) for p in opt_args + anno_args]
    return Signature(params)

# %% ../nbs/01_core.ipynb 10
def op2nm(op_id):
    'Parse the operation ID to get the resource and name'
    parts = re.findall(r'[A-Z][a-z]*', op_id)
    verb, *nm = [p.lower() for p in parts]
    res, nm = nm[0], nm[1:]
    nm += [verb]
    return res, nm

# %% ../nbs/01_core.ipynb 12
class _OAPIObj: pass

# %% ../nbs/01_core.ipynb 13
def _flatten_data(data, prefix=''):
    'Flatten a dictionary of data so that it can be used in a request body.'
    result = {}
    for k,v in data.items():
        key = f'{prefix}[{k}]' if prefix else k
        if isinstance(v, dict): result.update(_flatten_data(v, key))
        elif isinstance(v, list): 
            for i,item in enumerate(v):
                if isinstance(item, dict): result.update(_flatten_data(item, f'{key}[{i}]'))
                else: result[f'{key}[{i}]'] = item
        else: result[key] = v
    return result

# %% ../nbs/01_core.ipynb 15
names = lambda x: [o['name'] for o in x]

class _OAPIVerb(_OAPIObj):
    __slots__ = 'path verb res name summary pparams qparams url data doc_url hdrs client __doc__'.split()
    def __init__(self, path, verb, op_id, summary, qparams, data, doc_url, url, hdrs, client, kwargs={}):
        res, name = op2nm(op_id) # custom per oapi spec
        name = '_'.join(name)
        path, *_ = partial_format(path, **kwargs)
        pparams = stringfmt_names(path) # params inside path
        param_docs = '\n'.join(f"    {p['name']}: {p['description']}" for p in qparams + data)
        __doc__ = f"{summary}\n\nParameters:\n{param_docs}" if param_docs else summary
        store_attr()

    def __call__(self, *args, **kwargs):
        'Call the API endpoint with the given arguments'
        flds = self.pparams + names(self.qparams) + names(self.data)
        for a, b in zip(args, flds): kwargs[b] = a
        route_p, query_p, data_p = [{p: kwargs[p] for p in o if p in kwargs}
                                    for o in (self.pparams, names(self.qparams), names(self.data))]
        return self.client(self.path, self.verb, route=route_p, query=query_p, data=data_p)

    def __str__(self): return f'{self.res}.{self.name}{signature(self)}'
    @property
    def __signature__(self): return _mk_sig(self.pparams, self.qparams, self.data)
    __call__.__signature__ = __signature__

    def _repr_markdown_(self):
        return f'[{self.res}.{self.name}]({self.doc_url}){self.__signature__}: *{self.summary}*'
    __repr__ = _repr_markdown_

# %% ../nbs/01_core.ipynb 21
class _OAPIVerbGroup(_OAPIObj):
    def __init__(self, name, verbs):
        self.name,self.verbs = name,verbs
        for o in verbs: setattr(self, o.name, o)
    def __str__(self): return "\n".join(str(v) for v in self.verbs)
    def _repr_markdown_(self): return "\n".join(f'- {v._repr_markdown_()}' for v in self.verbs)

# %% ../nbs/01_core.ipynb 24
class StripeApi:
    def __init__(self, api_key=None, base_url=stripe_api_url):
        self.api_key,self.base_url = api_key,base_url
        self.hdrs = {'Authorization': f'Bearer {self.api_key}'}
        verbs = L(eps).map(lambda x: _OAPIVerb(**x, url=base_url, hdrs=self.hdrs, client=self))
        self.func_dict = {f'{o.path}:{o.verb.upper()}':o for o in verbs}
        self.groups = {k.replace('-','_'): _OAPIVerbGroup(k,v) for k,v in groupby(verbs, 'res').items()}
    
    def __call__(self, path:str, verb:str=None, headers:dict=None, route:dict=None, query:dict=None, data=None):
        'Call the API endpoint with the given arguments'
        headers = {**self.hdrs, **(headers or {})}
        if route:
            for k,v in route.items(): route[k] = quote(str(route[k]))
        if data: data = _flatten_data(data)
        res, self.recv_hdrs = urlsend(self.base_url + '/' + path, verb, headers=headers, return_headers=True,
                                      route=route or None, query=query or None, data=data or None, return_json=True,
                                      json_data=False)
        return dict2obj(res)
    
    def __dir__(self): return super().__dir__() + list(self.groups)
    def _repr_markdown_(self): return "\n".join(f"- [{o}]({docs_url + '/' + o})" for o in sorted(self.groups))
    def __getattr__(self,k): return self.groups[k] if 'groups' in vars(self) and k in self.groups else stop(AttributeError(k))
    def __getitem__(self, k):
        "Lookup and call an endpoint by path and verb (which defaults to 'GET')"
        a,b = k if isinstance(k,tuple) else (k,'GET')
        return self.func_dict[f'{a}:{b.upper()}']

# %% ../nbs/01_core.ipynb 42
@patch
def find_product(self:StripeApi, name: str):
    'Find a product by name'
    prods = L(self.products.get().data)
    return first(prods, lambda p: p.name == name)

# %% ../nbs/01_core.ipynb 44
@patch
def find_prices(self:StripeApi, product_id: str):
    'Find all prices associated with a product id'
    return L(self.prices.get().data).filter(lambda p: p.product == product_id)

# %% ../nbs/01_core.ipynb 46
@patch
def priced_product(self:StripeApi, product_name, amount_cents, currency='usd', recurring=None, description=None):
    "Create a product and price if they don't exist"
    prod_params = dict(name=product_name)
    if description: prod_params['description'] = description
    prod = self.find_product(product_name) or self.products.post(**prod_params)
    price_params = dict(product=prod.id, unit_amount=amount_cents, currency=currency)
    if recurring: price_params['recurring'] = recurring
    price = first(self.find_prices(prod.id)) or self.prices.post(**price_params)
    return prod, price

# %% ../nbs/01_core.ipynb 49
@patch
def one_time_payment(self:StripeApi, product_name, amount_cents, success_url, cancel_url, currency='usd', quantity=1, **kw):
    'Create a simple one-time payment checkout'
    _, price = self.priced_product(product_name, amount_cents, currency)
    return self.checkout.sessions_post(mode='payment', line_items=[dict(price=price.id, quantity=quantity)],
                                       automatic_tax={'enabled': True}, success_url=success_url, cancel_url=cancel_url, **kw)

# %% ../nbs/01_core.ipynb 52
@patch
def subscription(self:StripeApi, product_name, amount_cents, success_url, cancel_url,
                 currency='usd', interval='month', **kw):
    'Create a simple recurring subscription'
    _, price = self.priced_product(product_name, amount_cents, currency, recurring=dict(interval=interval))
    return self.checkout.sessions_post(mode='subscription', success_url=success_url, cancel_url=cancel_url,
                                       line_items=[dict(price=price.id, quantity=1)], **kw)
