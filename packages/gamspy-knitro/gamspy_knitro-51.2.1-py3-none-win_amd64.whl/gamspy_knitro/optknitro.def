*
* optknitro.def
*

presolve enumint 1059 1 1 4 Determine whether or not to use the Knitro presolver to try to simplify the model by removing variables or constraints
 0 1 (no) No presolve
 1 1 (yes) Knitro performs presolve
tuner enumint 1070 0 1 12 Indicates whether to invoke the Knitro-Tuner
 0 1 (off) Knitro Tuner turned off
 1 1 (on) Knitro Tuner enabled
blasoption enumint 1042 -1 1 1 Specifies the BLAS/LAPACK function library to use for basic vector and matrix computations
 -1 1 (auto) Automatically determine based on platform
 0 1 (knitro) Use Knitro version of netlib functions
 1 1 (intel) Use Intel MKL functions
 2 1 (dynamic) Use dynamic library of functions
 3 1 (blis) Use BLIS functions
 4 1 (apple) Use Apple Accelerate functions
blasoptionlib string 1045 "" 1 1 Specifies a dynamic library name that contains object code for BLAS/LAPACK functions
bndrange double 1112 1e+20 0 maxdouble 1 1 Specifies max limits on the magnitude of constraint and variable bounds
cg_maxit integer 1013 -1 -1 maxint 1 1 Determines the maximum allowable number of inner conjugate gradient (CG) iterations per Knitro minor iteration
cg_pmem integer 1103 10 0 maxint 1 1 Specifies the amount of nonzero elements per column of the Hessian of the Lagrangian which are retained when computing the incomplete Cholesky preconditioner
cg_precond enumint 1041 0 1 1 Specifies whether an incomplete Cholesky preconditioner is applied during CG iterations in barrier algorithms
 0 1 (no) Not applied
 1 1 (chol) Preconditioner is applied
cg_stoptol double 1099 0.01 0 maxdouble 1 1 Specifies the relative stopping tolerance used for the conjugate gradient (CG) subproblem solves
convex enumint 1114 -1 1 1 Declare the problem as convex by setting to 1 or non-convex by setting to 0
 -1 1 (auto) Knitro will try to determine this automatically, but may only be able to do so for simple model forms such as QPs or QCQPs.
 0 1 (no) Declare problem as non-convex
 1 1 (yes) Declare problem as convex
cpuplatform enumint 1120 -1 1 1 This option can be used to specify the target instruction set architecture for the machine on which Knitro is running
 -1 1 (auto) Determine automatically
 1 1 (compatible) Aim for more compatible performance across architectures
 2 1 (sse2) SSE2
 3 1 (avx) AVX
 4 1 (avx2) AVX-2
 5 1 (avx512) AVX-512 (experimental)
datacheck enumint 1087 0 1 1 Specifies whether to perform more extensive data checks to look for errors in the problem input to Knitro (in particular, this option looks for errors in the sparse Jacobian and/or sparse Hessian structure)
 0 1 (no) No extra data checks
 1 1 (yes) Perform extra data checks
delta double 1020 1 1e-14 maxdouble 1 1 Specifies the initial trust region radius scaling factor used to determine the initial trust region size
eval_cost enumint 1159 0 1 1 Use this option to tell Knitro the relative cost of performing callback (e.g. function, gradient and Hessian) evaluations
 0 1 (unspecified) Evaluation cost is not specified
 1 1 (inexpensive) Evaluation cost is relatively inexpensive
 2 1 (expensive) Evaluation cost is relatively expensive
honorbnds enumint 1002 -1 1 1 Indicates whether or not to enforce satisfaction of simple variable bounds throughout the optimization
 -1 1 (auto) Setting determined automatically by Knitro
 0 1 (no) Allow iterations to violate the bounds
 1 1 (always) Enforce bounds satisfaction of all iterates
 2 1 (initpt) Enforce bounds satisfaction of initial point
initpenalty double 1097 10 0 maxdouble 1 1 Specifies the initial penalty parameter used in the Knitro merit functions
initpt_strategy enumint 1158 -1 1 1 Specifies the initial point strategy used for the continuous algorithms
 -1 1 (auto) Automatic initial point strategy
 1 1 (basic) Try basic initial point strategy
 2 1 (advanced) Try more advanced initial point strategy
linesearch enumint 1095 0 1 1 Indicates which linesearch strategy to use for the Interior/Direct or SQP algorithm to search for a new acceptable iterate
 0 1 (auto) Let Knitro choose the linesearch method
 1 1 (backtrack) Backtracking linesearch
 2 1 (interpolate) Interpolation based linesearch
 3 1 (weakwolfe) Weak Wolfe linesearch
linesearch_maxtrials integer 1044 3 0 maxint 1 1 Indicates the maximum allowable number of trial points during the linesearch of the Interior/Direct or SQP algorithm before treating the linesearch step as a failure and generating a new step
linsolver enumint 1057 0 1 1 Indicates which linear solver to use to solve linear systems arising in Knitro algorithms
 0 1 (auto) Let Knitro choose the solver
 1 1 (internal) Use internal solver provided with Knitro
 2 1 (hybrid) Use a mixture of linear solvers depending on the linear systems
 3 1 (qr) Use dense QR solver always (only for small problems)
 4 1 (ma27) Use sparse HSL solver ma27 always
 5 1 (ma57) Use sparse HSL solver ma57 always
 6 1 (mklpardiso) Use sparse Intel MKL Pardiso solver always
 7 1 (ma97) Use parallel, deterministic HSL ma97 solver
 8 1 (ma86) Use parallel, non-deterministic HSL ma86 solver
 9 1 (apple) Use parallel, non-deterministic Apple Sparse Solver
linsolver_maxitref integer 1130 2 0 maxint 1 1 Indicates the maximum allowable number of iterative refinement steps applied when a linear system is solved inside Knitro
linsolver_nodeamalg integer 1145 0 0 maxint 1 1 Controls the node amalgamation setting for the MA57, MA86 and MA97 linear solvers
linsolver_ooc enumint 1076 0 1 1 Indicates whether to use Intel MKL PARDISO out-of-core solve of linear systems when \ref KNITROlinsolver "linsolver" = mklpardiso
 0 1 (no) Always use in-core version
 1 1 (maybe) Will use out-of-core version beyond a certain size
 2 1 (yes) Always use out-of-core version
linsolver_ordering enumint 1144 -1 1 1 Sets the ordering method used for the linear system solver
 -1 1 (auto) Automatically determine ordering procedure
 0 1 (best) Choose the best between AMD and METIS
 1 1 (amd) Use AMD ordering (min degree for MKL PARDISO)
 2 1 (metis) Use METIS ordering
linsolver_pivottol double 1029 1e-08 0 0.5 1 1 Specifies the initial pivot threshold used in factorization routines
linsolver_scaling enumint 1156 0 1 1 Enables scaling for the linear system solver
 0 1 (none) No scaling is applied in the linear system solves
 1 1 (always) Always apply scaling in the linear system solves
 2 1 (dynamic) Dynamically apply scaling in the linear system solves
lp_algorithm enumint 1170 -1 1 1 Indicates which algorithm to use to solve linear problems (LPs)
 -1 1 (auto) Let Knitro automatically decide.
 0 1 (nlp) Use algorithm specified in nlp_algorithm.
 1 1 (primalsimplex) Use Primal Simplex algorithm.
 2 1 (dualsimplex) Use Dual Simplex algorithm.
 3 1 (barrier) Use Interior-Point/Barrier algorithm.
 4 1 (pdlp) Use Primal-Dual Linear Programming algorithm.
ncvx_qcqp_init enumint 1139 -1 1 1 Specifies the initialization strategy used for non-convex QPs and QCQPs
 -1 1 (auto) Knitro will automatically determine the strategy.
 0 1 (none) No special initialization strategy is used.
 1 1 (linear) Initialize by solving a linear relaxation.
 2 1 (hybrid) Initialize by solving a hybrid formulation.
 3 1 (penalty) Initialize by solving a penalty formulation.
 4 1 (cvxquad) Initialize by solving a convex quadratic relaxation.
nlp_algorithm enumint 1003 2 1 1 Indicates which algorithm to use to solve nonlinear problems (e.g. NLPs, QPs, QCQPs)
 0 1 (auto) Let Knitro choose the algorithm
 1 1 (direct) Use Interior (barrier) Direct algorithm
 2 1 (cg) Use Interior (barrier) CG algorithm
 3 1 (active) Use Active Set SLQP algorithm
 4 1 (sqp) Use Active Set SQP algorithm
 5 1 (multi) Run multiple algorithms (perhaps in parallel)
 6 1 (al) Use Augmented Lagrangian algorithm
objrange double 1026 1e+20 0 maxdouble 1 1 Specifies the extreme limits of the objective function for purposes of determining unboundedness
restarts integer 1100 -1 -1 maxint 1 1 Specifies whether or not to enable automatic restarts in Knitro
restarts_maxit integer 1101 0 0 maxint 1 1 When restarts are enabled, this option can be used to specify a maximum number of iterations before enforcing a restart
scale enumint 1017 1 1 1 Specifies whether to perform problem scaling of the objective function, constraint functions, or possibly variables
 0 1 (no) No scaling done
 1 1 (user_internal) User, if defined, otherwise internal
 2 1 (user_none) User, if defined, otherwise none
 3 1 (internal) Knitro performs internal scaling
scale_vars enumint 1153 0 1 1 Specifies the strategy for scaling variables
 0 1 (none) Do not apply any variable scaling
 1 1 (bnds) Apply variable scaling based on their bound values
soc enumint 1019 1 1 1 Specifies whether or not to try second order corrections (SOC)
 0 1 (no) Never do second order corrections
 1 1 (maybe) SOC steps attempted on some iterations
 2 1 (yes) SOC steps always attempted when constraints are nonlinear
soltype enumint 1161 0 1 1 This option specifies the solution returned by Knitro
 0 1 (final) Return the final iterate
 1 1 (bestfeas) Return the best feasible iterate found
strat_warm_start enumint 1118 0 1 1 Specifies whether or not to invoke a warm-start strategy
 0 1 (no) No warm-start strategy is applied.
 1 1 (yes) Knitro will apply a warm-start strategy with special tunings.
bfgs_scaling enumint 1131 0 1 2 Specify the initial scaling to use for the BFGS or L-BFGS Hessian approximation
 0 1 (dynamic) Dynamically determine
 1 1 (invhess) Approximate scale of the inverse Hessian
 2 1 (hess) Approximate the scale of the Hessian
derivcheck enumint 1080 0 0 2 Determine whether or not to perform a derivative check on the model
 0 1 (none) No derivative check
 1 1 (first) Check first derivatives
 2 1 (second) Check second derivatives
 3 1 (all) Check all derivatives
derivcheck_terminate enumint 1088 1 0 2 Determine whether to always terminate after the derivative check or only when the derivative checker detects a possible error
 1 1 (error) Stop when there is an error detected
 2 1 (always) Always stop after the derivative check
derivcheck_tol double 1082 1e-06 0 maxdouble 0 2 Specifies the relative tolerance used for detecting derivative errors, when the Knitro derivative checker is enabled
derivcheck_type enumint 1081 1 0 2 Specifies whether to use forward or central finite differencing for the derivative checker when it is enabled
 1 1 (forward) Check using forward finite-differences
 2 1 (central) Check using central finite-differences
findiff_estnoise enumint 1140 0 1 2 This option can be used to enable an estimate of the noise in the model when using finite-difference gradients
 0 1 (no) No estimation of noise performed
 1 1 (yes) Estimate the noise and perhaps use it to determine a finite-difference steplength
 2 1 (withcurv) Estimate a curvature factor as well as the noise and perhaps use it to determine a finite-difference steplength
findiff_relstepsize double 1123 0 mindouble maxdouble 1 2 Specifies the relative stepsize used for finite-difference gradients during the optimization
gradopt enumint 1007 1 1 2 Specifies how to compute the gradients of the objective and constraint functions
 1 1 (exact) User supplies exact first derivatives
 2 1 (forward) Gradients computed by internal forward finite differences
 3 1 (central) Gradients computed by internal central finite differences
 4 1 (user_forward) Gradients computed by user-provided forward finite differences
 5 1 (user_central) Gradients computed by user-provided central finite differences
hessopt enumint 1008 0 1 2 Specifies how to compute the (approximate) Hessian of the Lagrangian
 0 1 (auto) Determined automatically by Knitro
 1 1 (exact) User supplies exact second derivatives
 2 1 (bfgs) Knitro computes a dense quasi-Newton BFGS Hessian
 3 1 (sr1) Knitro computes a dense quasi-Newton SR1 Hessian
 4 1 (product_findiff) Knitro computes Hessian-vector products by finite differences
 5 1 (product) User supplies exact Hessian-vector products
 6 1 (lbfgs) Knitro computes a limited-memory quasi-Newton BFGS Hessian
lmsize integer 1038 8 1 100 1 2 Specifies the number of limited memory pairs stored when approximating the Hessian using the limited-memory quasi-Newton BFGS option
feastol double 1022 -1 -1 maxdouble 1 3 Specifies the final relative stopping tolerance for the feasibility error
feastol_abs double 1023 -1 -1 maxdouble 1 3 Specifies the final absolute stopping tolerance for the feasibility error
findiff_terminate enumint 1119 1 1 3 This option specifies the termination criteria when using finite-difference gradients
 0 1 (none) No special termination
 1 1 (errest) Terminate on gradient error estimates
fstopval double 1086 maxdouble mindouble maxdouble 1 3 Used to implement a custom stopping condition based on the objective function value
ftol double 1090 1e-15 0 maxdouble 1 3 The optimization process will terminate if the relative change in the objective function is less than \ref KNITROftol "ftol" for \ref KNITROftol_iters "ftol_iters" consecutive feasible iterations
ftol_iters integer 1091 5 1 maxint 1 3 The optimization process will terminate if the relative change in the objective function is less than \ref KNITROftol "ftol" for \ref KNITROftol_iters "ftol_iters" consecutive feasible iterations
infeastol double 1056 1e-08 0 maxdouble 1 3 Specifies the (relative) tolerance used for declaring infeasibility of a model
infeastol_iters integer 1124 50 1 maxint 1 3 The optimization process will terminate if the relative change in the feasibility error is less than \ref KNITROinfeastol "infeastol" for \ref KNITROinfeastol_iters "infeastol_iters" consecutive infeas****
maxfevals integer 1085 -1 minint maxint 1 3 Specifies the maximum number of function evaluations before termination
maxit integer 1014 0 0 maxint 1 3 Specifies the maximum number of iterations before termination
maxtime double 1163 1e+08 0 maxdouble 1 3 Specifies, in seconds, the maximum allowable real time before termination
opttol double 1027 -1 -1 maxdouble 1 3 Specifies the final relative stopping tolerance for the KKT (optimality) error
opttol_abs double 1028 -1 -1 maxdouble 1 3 Specifies the final absolute stopping tolerance for the KKT (optimality) error
xtol double 1030 1e-12 0 maxdouble 1 3 The optimization process will terminate if the relative change in all components of the solution point estimate is less than \ref KNITROxtol "xtol" for \ref KNITROxtol_iters "xtol_iters"
xtol_iters integer 1094 0 0 maxint 1 3 The optimization process will terminate if the relative change in the solution estimate is less than \ref KNITROxtol "xtol" for \ref KNITROxtol_iters "xtol_iters" consecutive iterations
presolve_initpt enumint 1127 -1 1 4 Control whether the Knitro presolver can shift a user-supplied initial point
 -1 1 (auto) Determine automatically
 0 1 (noshift) Do not shift initial point in presolve
 1 1 (linshift) Allow shifting variables in linear constraints
 2 1 (anyshift) Allow shifting any variable
presolve_level enumint 1122 -1 1 4 Set the level of presolve operations to enable through the Knitro presolver
 -1 1 (auto) Determine automatically
 1 1 (level1) Most basic presolve
 2 1 (level2) More advanced presolve
presolve_passes integer 1121 10 0 maxint 1 4 Set a maximum limit on the number of passes through the Knitro presolve operations
presolve_tol double 1060 1e-06 0 maxdouble 1 4 Determines the tolerance used by the Knitro presolver to remove variables and constraints from the model
presolveop_redundant enumint 1143 1 1 4 Determine whether or not to enable the Knitro presolve operation to detect and remove redundant constraints
 0 1 (none) Do not detect redundant constraints
 1 1 (dupcon) Detect and remove duplicate constraints
 2 1 (depcon) Detect and remove linearly dependent constraints
presolveop_substitution enumint 1146 -1 1 4 Determine whether or not to enable the Knitro presolve operation to substitute out variables when possible
 -1 1 (auto) Automatic substitution procedure
 0 1 (none) No substitution
 1 1 (simple) Only doubleton equality substitutions
 2 1 (all) All possible substitutions
presolveop_substitution_tol double 1147 0.01 0 maxdouble 1 4 Tolerance for applying a substitution
presolveop_tighten enumint 1125 -1 1 4 Determine whether or not to enable the Knitro presolve operation to tighten variable bounds or coefficients
 -1 1 (auto) Automatically determined (may depend on the algorithm).
 0 1 (none) Do not tighten variable bounds (unless it removes a constraint).
 1 1 (varbnd) Enable tightening variable bounds always.
 2 1 (coef) Enable tightening coefficients in linear constraints.
 3 1 (all) Enable tightening variable bounds and coefficients.
bar_conic_enable enumint 1113 -1 1 5 Enable special treatments for conic constraints when using the Interior/Direct algorithm (has no affect when using the Interior/CG algorithm)
 -1 1 (auto) Let Knitro automatically choose the strategy.
 0 1 (none) Do not apply any special treatment for conic constraints.
 1 1 (soc) Apply special treatments for any Second Order Cone (SOC) constraints identified in the model.
bar_directinterval integer 1058 -1 -1 maxint 1 5 Controls the maximum number of consecutive conjugate gradient (CG) steps before Knitro will try to enforce that a step is taken using direct linear algebra
bar_feasible enumint 1006 0 1 5 Specifies whether special emphasis is placed on getting and staying feasible in the interior-point algorithms
 0 1 (no) No emphasis on feasibility
 1 1 (stay) Iterates must honor inequalities
 2 1 (get) Emphasize first getting feasible before optimizing
 3 1 (get_stay) Implement both options 1 and 2 above
bar_feasmodetol double 1021 0.0001 0 maxdouble 1 5 Specifies the tolerance in equation that determines whether Knitro will force subsequent iterates to remain feasible
bar_globalize enumint 1155 2 1 5 Specifies the globalization strategy used in the interior-point algorithms
 0 1 (none) Do not apply any globalization strategy
 1 1 (kkt) Apply a globalization strategy based on decreasing the KKT error
 2 1 (filter) Apply a globalization strategy using a filter based on the objective and constraint violation
bar_initmu double 1025 -1 mindouble maxdouble 1 5 Specifies the initial value for the barrier parameter \f$\mu\f$ used with the barrier algorithms
bar_initpi_mpec double 1093 0 0 maxdouble 1 5 Specifies the initial value for the MPEC penalty parameter \f$\pi\f$ used when solving problems with complementarity constraints using the barrier algorithms
bar_initpt enumint 1009 0 1 5 Indicates initial point strategy for x, slacks and multipliers when using a barrier algorithm
 0 1 (auto) Let Knitro choose the strategy
 1 1 (convex) Initial point strategy 1 (mainly for convex problems)
 2 1 (nearbnd) Initial point strategy staying closer to bounds
 3 1 (central) More central initial point strategy
bar_linsys enumint 1126 -1 1 5 Indicates which linear system form is used inside the Interior/Direct algorithm for computing primal-dual steps
 -1 1 (auto) Automatically determine
 0 1 (full) Full augmented system
 1 1 (slacks) Eliminate slacks
 2 1 (bounds) Also eliminate bounds
 3 1 (ineqs) Also eliminate inequalities
bar_linsys_storage enumint 1129 -1 1 5 Indicates how to store in memory the linear systems used inside the Interior/Direct algorithm for computing primal-dual steps
 -1 1 (auto) Automatically determine
 1 1 (lowmem) Use one storage location for multiple systems
 2 1 (normal) Store systems separately
bar_maxcorrectors integer 1117 -1 -1 maxint 1 5 Specifies the maximum number of corrector steps allowed for primal-dual steps
bar_maxcrossit integer 1039 0 0 maxint 1 5 Specifies the maximum number of crossover iterations before termination
bar_maxmu double 1154 1e+16 3e-16 1e+16 1 5 Specifies the maximum allowable value for the barrier parameter \f$\mu\f$ used with the barrier algorithms
bar_maxrefactor integer 1043 -1 -1 maxint 1 5 Indicates the maximum number of refactorizations of the KKT system per iteration of the Interior/Direct algorithm before reverting to a CG step
bar_mpec_heuristic enumint 1142 0 1 5 Specifies whether or not to use a heuristic approach when solving MPEC models with the barrier algorithm
 0 1 (no) No mpec heuristic enabled
 1 1 (yes) Mpec heuristic is enabled
bar_murule enumint 1004 0 1 5 Indicates which strategy to use for modifying the barrier parameter \f$mu\f$ in the barrier algorithms
 0 1 (auto) Let Knitro choose the strategy
 1 1 (monotone) Monotonically decrease the barrier parameter. Available for both barrier algorithms.
 2 1 (adaptive) Use an adaptive rule based on the complementarity gap to determine the value of the barrier parameter. Available for both barrier algorithms.
 3 1 (probing) Use a probing (affine-scaling) step to dynamically determine the barrier parameter. Available only for the Interior/Direct algorithm.
 4 1 (dampmpc) Use a Mehrotra predictor-corrector type rule to determine the barrier parameter, with safeguards on the corrector step. Available only for the Interior/Direct algorithm.
 5 1 (fullmpc) Use a Mehrotra predictor-corrector type rule to determine the barrier parameter, without safeguards on the corrector step. Available only for the Interior/Direct algorithm.
 6 1 (quality) Minimize a quality function at each iteration to determine the barrier parameter. Available only for the Interior/Direct algorithm.
bar_penaltycons enumint 1050 -1 1 5 Indicates whether a penalty approach is applied to the constraints
 -1 1 (auto) Let Knitro choose the strategy
 0 1 (none) Do not apply penalty approach to any constraints
 2 1 (all) Apply a penalty approach to all general constraints
 3 1 (equalities) Apply a penalty approach to equality constraints only
bar_penaltyrule enumint 1049 0 1 5 Indicates which penalty parameter strategy to use for determining whether or not to accept a trial iterate
 0 1 (auto) Let Knitro choose the strategy
 1 1 (single) Use single penalty parameter approach
 2 1 (flex) Use more tolerant flexible strategy
bar_refinement enumint 1079 0 1 5 Specifies whether to try to refine the barrier solution for better precision
 0 1 (no) Do not refine the barrier solution
 1 1 (yes) Try to refine the barrier solution
bar_relaxcons enumint 1077 2 1 5 Indicates whether a relaxation approach is applied to the constraints
 0 1 (none) Do not relax any constraints
 1 1 (eqs) Relax only equality constraints
 2 1 (ineqs) Relax only inequality constraints
 3 1 (all) Relax all general constraints
bar_slackboundpush double 1102 -1 mindouble maxdouble 1 5 Specifies the amount by which the barrier slack variables are initially pushed inside the bounds
bar_switchobj enumint 1104 1 1 5 Indicates which objective function to use when the barrier algorithms switch to a pure feasibility phase
 0 1 (none) No objective
 1 1 (scalarprox) Proximal point objective with scalar weighting
 2 1 (diagprox) Proximal point objective with diagonal weighting
bar_switchrule enumint 1061 -1 1 5 Indicates whether or not the barrier algorithms will allow switching from an optimality phase to a pure feasibility phase
 -1 1 (auto) Let Knitro choose the strategy
 0 1 (never) Never switch
 2 1 (moderate) Allow moderate switching
 3 1 (aggressive) More aggressive switching
bar_watchdog enumint 1089 0 1 5 Specifies whether to enable watchdog heuristic for barrier algorithms
 0 1 (no) No watchdog heuristic
 1 1 (yes) Allow watchdog heuristic to be used
act_lpalg enumint 1109 0 0 6 Indicates which algorithm to use to solve linear programming (LP) subproblems when using the Knitro Active Set or SQP algorithms
 0 1 (default) Use the default algorithm for the chosen LP solver.
 1 1 (primal) Use a primal simplex algorithm.
 2 1 (dual) Use a dual simplex algorithm.
 3 1 (barrier) Use a barrier/interior-point algorithm.
act_lpfeastol double 1098 1e-08 0 maxdouble 1 6 Specifies the feasibility tolerance used for linear programming subproblems solved when using the Active Set or SQP algorithms
act_lppenalty enumint 1111 1 1 6 Indicates whether to use a penalty formulation for linear programming subproblems in the Knitro Active Set or SQP algorithms
 1 1 (all) Penalize all constraints.
 2 1 (nonlinear) Penalize only nonlinear constraints.
 3 1 (dynamic) Dynamically choose which constraints to penalize.
act_lppresolve enumint 1110 0 1 6 Indicates whether to apply a presolve for linear programming subproblems in the Knitro Active Set or SQP algorithms
 0 1 (off) Presolve turned off for LP subproblems.
 1 1 (on) Presolve turned on for LP subproblems.
act_lpsolver enumint 1012 1 0 6 Indicates which linear programming simplex solver the Knitro Active Set or SQP algorithms use when solving internal LP subproblems
 1 1 (internal) Use internal LP solver
 2 1 (cplex) CPLEX (if user has a valid license)
 3 1 (xpress) XPRESS (if user has a valid license)
act_parametric enumint 1107 1 1 6 Indicates whether to use a parametric approach when solving linear programming (LP) subproblems when using the Knitro Active Set or SQP algorithms
 0 1 (no) Never
 1 1 (maybe) Use selectively
 2 1 (yes) Always use parametric approach
act_qpalg enumint 1092 0 1 6 Indicates which algorithm to use to solve quadratic programming (QP) subproblems when using the Knitro Active Set or SQP algorithms
 0 1 (auto) Let Knitro choose the algorithm
 1 1 (direct) Use Interior (barrier) Direct algorithm
 2 1 (cg) Use Interior (barrier) CG algorithm
 3 1 (active) Use Active Set SLQP algorithm
act_qppenalty enumint 1128 -1 1 6 Indicates whether to use a penalty formulation for quadratic programming subproblems in the Knitro SQP algorithm
 -1 1 (auto) Let Knitro automatically decide.
 0 1 (none) Do not penalize constraints in QP subproblems.
 1 1 (all) Penalize all constraints in QP subproblems.
cplexlibname string 1048 "" 0 6 See option \ref KNITROact_lpsolver "act_lpsolver"
xpresslibname string 1069 "" 0 6 See option \ref KNITROact_lpsolver "act_lpsolver"
mip_branchrule enumint 2002 0 1 7 Specifies which branching rule to use for MIP branch and bound procedure
 0 1 (auto) Let Knitro choose the rule
 1 1 (most_frac) Most fractional (most infeasible) variable
 2 1 (pseudocost) Use pseudo-cost value
 3 1 (strong) Use strong branching
mip_clique enumint 2038 -1 1 7 Specifies rules for adding clique cuts
 -1 1 (auto) Determine automatically
 0 1 (none) Do not add clique cuts
 1 1 (root) Add clique cuts at root node
 2 1 (tree) Add clique cuts in the whole tree
mip_cut_flowcover enumint 2053 -1 1 7 Specifies rules for adding flow cover cuts
 -1 1 (auto) Determine automatically
 0 1 (none) Do not add flow cover cuts
 1 1 (root) Add flow cover cuts at root node only
 2 1 (tree) Add flow cover cuts at any tree node
mip_cut_probing enumint 2052 -1 1 7 Specifies rules for adding probing cuts
 -1 1 (auto) Determine automatically
 0 1 (none) Do not add probing cuts
 1 1 (root) Add probing cuts at root node only
 2 1 (tree) Add probing cuts at any tree node
mip_cutfactor double 2035 1 0 maxdouble 1 7 This value specifies a limit on the number of cuts added to a node subproblem
mip_cutoff double 2044 maxdouble mindouble maxdouble 1 7 This value specifies the objective cutoff value for MIP
mip_cutoff_abs double 2059 1e-06 0 maxdouble 1 7 This value specifies the absolute improvement cutoff value for MIP
mip_cutoff_rel double 2060 0.0001 0 maxdouble 1 7 This value specifies the absolute improvement cutoff value for MIP
mip_cutting_plane enumint 2043 1 1 7 Specifies when to apply the cutting plane procedure
 0 1 (none) Do not perform cutting plane
 1 1 (root) Only perform root-cutting
mip_debug enumint 2013 0 0 7 Specifies debugging level for MIP solution
 0 1 (none) No MIP debugging info
 1 1 (all) Write debugging to the file kdbg_mip.log
mip_gomory enumint 2051 -1 1 7 Specifies rules for adding Gomory mixed-integer cuts
 -1 1 (auto) Determine automatically
 0 1 (none) Do not add gomory cuts
 1 1 (root) Add gomory cuts at root node only
 2 1 (tree) Add gomory cuts at any tree node
mip_gub_branch enumint 2015 0 1 7 Specifies whether or not to branch on generalized upper bounds (GUBs)
 0 1 (no) Do not branch on GUBs
 1 1 (yes) Branch on GUBs
mip_heuristic_diving integer 2042 -1 -1 31 1 7 Specifies whether or not to enable the MIP diving heuristic
mip_heuristic_feaspump enumint 2040 -1 1 7 Specifies whether or not to enable the MIP feasibility pump heuristic
 -1 1 (auto) Determine automatically
 0 1 (off) Feasibility pump heuristic is turned off
 1 1 (on) Feasibility pump heuristic is turned on
mip_heuristic_lns integer 2045 -1 -1 31 1 7 Specifies whether or not to enable the MIP large neighborhood search (LNS) heuristics
mip_heuristic_localsearch enumint 2054 -1 1 7 Specifies whether or not to enable the MIP local search heuristic
 -1 1 (auto) Determine automatically
 0 1 (off) MIP local search heuristic is turned off
 1 1 (on) MIP local search heuristic is turned on
mip_heuristic_maxit integer 2023 100 0 maxint 1 7 Specifies the maximum number of iterations to allow for MIP heuristic, if one is enabled
mip_heuristic_misqp enumint 2049 -1 1 7 Specifies whether or not to enable the MIP MISQP heuristic
 -1 1 (auto) Determine automatically
 0 1 (off) MISQP heuristic is turned off
 1 1 (on) MISQP heuristic is turned on
mip_heuristic_mpec enumint 2041 -1 1 7 Specifies whether or not to enable the MIP MPEC heuristic
 -1 1 (auto) Determine automatically
 0 1 (off) MPEC heuristic is turned off
 1 1 (on) MPEC heuristic is turned on
mip_heuristic_strategy enumint 2039 -1 1 7 Specifies the level of effort applied for the MIP heuristic search used to try to find an initial integer feasible point
 -1 1 (auto) Automatic strategy
 0 1 (none) No heuristics are used
 1 1 (basic) Try basic heuristics
 2 1 (advanced) Try more advanced heuristics
 3 1 (extensive) Try most extensive heuristics
mip_heuristic_terminate enumint 2033 1 1 7 Specifies the condition for terminating the MIP heuristic
 1 1 (feasible) Terminate at first feasible point
 2 1 (limit) Run heuristic until it hits limit
mip_implications enumint 2014 1 1 7 Specifies whether or not to add constraints to the MIP derived from logical implications
 0 1 (no) Do not add logical implications
 1 1 (yes) Add logical implications
mip_integer_tol double 2009 1e-08 0 1 1 7 This value specifies the threshold for deciding whether or not a variable is determined to be an integer
mip_intvar_strategy enumint 2030 0 1 7 Specifies how to handle integer variables
 0 1 (none) No special treatment
 1 1 (relax) Relax integer variables
 2 1 (mpec) Convert to mpec constraints
mip_knapsack enumint 2016 -1 1 7 Specifies rules for adding MIP knapsack cuts
 -1 1 (auto) Determine automatically
 0 1 (none) Do not add knapsack cuts
 1 1 (root) Add knapsack cuts derived in the root node
 2 1 (tree) Add knapsack cuts in the whole tree
mip_liftproject enumint 2047 -1 1 7 Specifies rules for adding lift and project cuts
 -1 1 (auto) Determine automatically
 0 1 (none) Do not add lift and project cuts
 1 1 (root) Add lift and project cuts at root node
mip_maxnodes integer 2021 0 0 maxint 1 7 Specifies the maximum number of nodes explored (0 means no limit)
mip_maxsolves integer 2008 0 0 maxint 1 7 Specifies the maximum number of subproblem solves allowed (0 means no limit)
mip_method enumint 2001 0 1 7 Specifies which MIP method to use
 0 1 (auto) Let Knitro choose the method
 1 1 (BB) Standard branch and bound
 3 1 (MISQP) Mixed-integer SQP
mip_mir enumint 2037 -1 1 7 Specifies rules for adding mixed-integer rounding cuts
 -1 1 (auto) Automatically determine whether to add mir cuts
 0 1 (none) Do not add mir cuts
 1 1 (root) Add mir cuts derived in the root node
 2 1 (tree) Add mir cuts in the whole tree
mip_multistart enumint 2046 0 1 7 Use to enable MIP multi-start at the branch-and-bound level
 0 1 (off) MIP multistart turned off
 1 1 (on) MIP multistart turned on
mip_node_lpalg enumint 2058 -1 1 7 Specifies which algorithm to use for standard node LP subproblem solves in MIP (same options as \ref KNITROlp_algorithm "lp_algorithm" user option)
 -1 1 (auto) Let Knitro automatically decide.
 0 1 (nlp) Use algorithm specified in mip_node_nlpalg.
 1 1 (primalsimplex) Use Primal Simplex algorithm.
 2 1 (dualsimplex) Use Dual Simplex algorithm.
 3 1 (barrier) Use Interior-Point/Barrier algorithm.
 4 1 (pdlp) Use Primal-Dual Linear Programming algorithm.
mip_node_nlpalg enumint 2032 0 1 7 Specifies which algorithm to use for standard node NLP subproblem solves in MIP (same options as \ref KNITROnlp_algorithm "nlp_algorithm" user option)
 0 1 (auto) Let Knitro choose the algorithm
 1 1 (direct) Use Interior (barrier) Direct algorithm
 2 1 (cg) Use Interior (barrier) CG algorithm
 3 1 (active) Use Active Set SLQP algorithm
 4 1 (sqp) Use Active Set SQP algorithm
 5 1 (multi) Run multiple algorithms (perhaps in parallel)
mip_numthreads integer 2048 0 0 maxint 1 7 Specify the number of threads to use for MIP branch-and-bound (when \ref KNITROmip_method "mip_method" = 1)
mip_opt_gap_abs double 2004 1e-06 -1 maxdouble 1 7 The absolute optimality gap stop tolerance for MIP
mip_opt_gap_rel double 2005 0.0001 -1 maxdouble 1 7 The relative optimality gap stop tolerance for MIP
mip_outinterval integer 2011 0 0 maxint 1 7 Specifies node printing interval for \ref KNITROmip_outlevel "mip_outlevel" when \ref KNITROmip_outlevel "mip_outlevel" &gt; 0
mip_outlevel enumint 2010 2 1 7 Specifies how much MIP information to print
 0 1 (none) Nothing
 1 1 (iters) One line for every node
 2 1 (iterstime) Also print accumulated time every node
 3 1 (root) Also print output from root node relaxation solve
mip_outsub enumint 2012 0 0 7 Specifies MIP subproblem solve debug output control
 0 1 (none) Do not print any debug output from subproblem solves.
 1 1 (yes) Subproblem debug output enabled, controlled by option `outlev`.
 2 1 (yesprob) Subproblem debug output enabled and print problem characteristics.
mip_pseudoinit enumint 2026 0 1 7 Specifies the method used to initialize pseudo-costs corresponding to variables that have not yet been branched on in the MIP method
 0 1 (auto) Let Knitro choose the method
 1 1 (ave) Use average value
 2 1 (strong) Use strong branching
mip_relaxable enumint 2031 1 1 7 Specifies whether integer variables are relaxable
 0 1 (none) Integer variables not relaxable
 1 1 (all) All integer variables are relaxable
mip_restart enumint 2050 1 1 7 Specifies whether to enable the MIP restart procedure
 0 1 (off) MIP restart turned off
 1 1 (on) MIP restart turned on
mip_root_lpalg enumint 2057 -1 1 7 Specifies which algorithm to use for root node LP subproblem solves in MIP (same options as \ref KNITROlp_algorithm "lp_algorithm" user option)
 -1 1 (auto) Let Knitro automatically decide.
 0 1 (nlp) Use algorithm specified in mip_root_nlpalg.
 1 1 (primalsimplex) Use Primal Simplex algorithm.
 2 1 (dualsimplex) Use Dual Simplex algorithm.
 3 1 (barrier) Use Interior-Point/Barrier algorithm.
 4 1 (pdlp) Use Primal-Dual Linear Programming algorithm.
mip_root_nlpalg enumint 2018 0 1 7 Specifies which algorithm to use for root node NLP solves in MIP (same options as \ref KNITROnlp_algorithm "nlp_algorithm" user option)
 0 1 (auto) Let Knitro choose the algorithm
 1 1 (direct) Use Interior (barrier) Direct algorithm
 2 1 (cg) Use Interior (barrier) CG algorithm
 3 1 (active) Use Active Set SLQP algorithm
 4 1 (sqp) Use Active Set SQP algorithm
 5 1 (multi) Run multiple algorithms (perhaps in parallel)
mip_rounding enumint 2017 -1 1 7 Specifies the MIP rounding rule to apply
 -1 1 (auto) Let Knitro choose the rule
 0 1 (none) Do not round if a node is infeasible
 2 1 (heur_only) Round using heuristic only (fast)
 3 1 (nlp_sometimes) Round and solve NLP if likely to succeed
 4 1 (nlp_always) Always round and solve NLP
mip_selectdir enumint 2034 0 1 7 Specifies the MIP node selection direction rule (for tiebreakers) for choosing the next node in the branch-and-bound tree
 0 1 (down) Choose the lesser-than node first
 1 1 (up) Choose the greater-than node first
mip_selectrule enumint 2003 0 1 7 Specifies the MIP select rule for choosing the next node in the branch-and-bound tree
 0 1 (auto) Let Knitro choose the rule
 1 1 (depth_first) Search the tree depth first
 2 1 (best_bound) Node with the best relaxation bound
 3 1 (combo_1) Depth first unless pruned, then best bound
mip_strong_candlim integer 2028 128 0 maxint 1 7 Specifies the maximum number of candidates to explore for MIP strong branching
mip_strong_level integer 2029 10 0 maxint 1 7 Specifies the maximum number of tree levels on which to perform MIP strong branching
mip_strong_maxit integer 2027 1000 0 maxint 1 7 Specifies the maximum number of iterations to allow for MIP strong branching solves
mip_sub_maxtime double 2055 1e+08 0 maxdouble 1 7 Specifies the maximum allowable real time in seconds for MIP node subproblems
mip_terminate enumint 2020 0 1 7 Specifies conditions for terminating the MIP algorithm
 0 1 (optimal) Terminate at optimum
 1 1 (feasible) Terminate at first integer feasible point
mip_zerohalf enumint 2036 -1 1 7 Specifies rules for adding zero-half cuts
 -1 1 (auto) Determine automatically
 0 1 (none) Do not add zero-half cuts
 1 1 (root) Add cuts derived in the root node
 2 1 (tree) Add zero-half cuts in the whole tree
ma_outsub enumint 1067 0 1 8 Enable writing algorithm output to files for the multi-algorithm (alg=5) procedure
 0 1 (none) No output from subproblem solves
 1 1 (yes) Subproblem output enabled, controlled by option outlev
ma_sub_maxtime double 1164 1e+08 0 maxdouble 1 8 Specifies, in seconds, the maximum allowable real time for multi-algorithm ("MA") subproblems (alg=5)
ma_terminate enumint 1063 1 1 8 Define the termination condition for the multi-algorithm (alg=5) procedure
 0 1 (all) Terminate after all algorithms complete
 1 1 (optimal) Terminate at first local optimum
 2 1 (feasible) Terminate at first feasible solution estimate
 3 1 (any) Terminate at first completed solve
ms_enable enumint 1033 0 1 9 Indicates whether Knitro will solve from multiple start points to find a better local minimum
 0 1 (no) Knitro solves from a single initial point
 1 1 (yes) Knitro solves using multiple start points
ms_initpt_cluster enumint 1149 0 1 9 The strategy for clustering initial points in multi-start
 0 1 (none) Do not apply clustering
 1 1 (sl) Apply single linkage based clustering
ms_maxbndrange double 1035 1000 0 maxdouble 1 9 Specifies the maximum range that an unbounded variable can take when determining new start points
ms_maxsolves integer 1034 0 0 maxint 1 9 Specifies how many start points to try in multi-start
ms_num_to_save integer 1051 0 0 maxint 1 9 Specifies the number of distinct feasible points to save in a file named knitro_mspoints
ms_numthreads integer 1137 0 0 maxint 1 9 Specify the number of threads to use for multi-start (when \ref KNITROms_enable "ms_enable" = 1)
ms_outsub enumint 1068 0 1 9 Enable writing algorithm output to files for the parallel multi-start procedure
 0 1 (none) No output from subproblem solves
 1 1 (yes) Subproblem output enabled, controlled by option outlev.
ms_savetol double 1052 1e-06 0 maxdouble 1 9 Specifies the tolerance for deciding if two feasible points are distinct
ms_seed integer 1066 0 0 maxint 1 9 Seed value used to generate random initial points in multi-start; should be a non-negative integer
ms_startptrange double 1055 1e+20 0 maxdouble 1 9 Specifies the maximum range that each variable can take when determining new start points
ms_sub_maxtime double 1165 1e+08 0 maxdouble 1 9 Specifies, in seconds, the maximum allowable real time for multi-start subproblems (i.e. local solves from a given initial point)
ms_terminate enumint 1054 4 1 9 Specifies the condition for terminating multi-start
 0 1 (maxsolves) Terminate after maxsolves
 1 1 (optimal) Terminate at first local optimum
 2 1 (feasible) Terminate at first feasible solution estimate
 3 1 (any) Terminate at first completed solve
 4 1 (rulebased) Terminate when the estimated probability of finding a new local solution is low
ms_terminaterule_tol double 1160 0 0 1 1 9 The tolerance in (0,1] for the rule-based termination of multi-start
blas_numthreads integer 1135 0 0 maxint 1 10 Specify the number of threads to use for BLAS operations when \ref KNITROblasoption "blasoption" = 1
conic_numthreads integer 1138 0 minint maxint 1 10 Specify the number of threads to use for operations in the conic algorithm (when \ref KNITRObar_conic_enable "bar_conic_enable" = 1)
linsolver_numthreads integer 1136 0 0 maxint 1 10 Specify the number of threads to use for linear system solve operations when \ref KNITROlinsolver "linsolver" = 6
debug enumint 1031 0 0 11 Controls the level of debugging output
 0 1 (none) No extra debugging
 1 1 (problem) Help debug solution of the problem
 2 1 (execution) Help debug execution of the solver
newpoint enumint 1001 0 1 11 Specifies additional action to take after every iteration in a solve of a continuous problem, or after every new incumbent of the NLPBB algorithm
 0 1 (none) No additional action
 1 1 (saveone) Save the latest new point to file knitro_newpoint.log
 2 1 (saveall) Append the latest new point to file knitro_newpoint.log
out_csvinfo enumint 1096 0 1 11 Controls whether or not to generates a file knitro_solve
 0 1 (no) No csv solution file is generated
 1 1 (yes) Generate a solution file knitro_solve.csv
out_csvname string 1106 "" 1 11 Use to specify a custom csv filename when using \ref KNITROout_csvinfo "out_csvinfo"
out_hints enumint 1115 1 1 11 Specifies whether to print diagnostic hints (e.g. about user option settings) after solving
 0 1 (no) Do not print any hints.
 1 1 (yes) Print diagnostic hints on occasion.
outappend enumint 1046 0 1 11 Specifies whether output should be started in a new file, or appended to existing files
 0 1 (no) Erase existing files when opening
 1 1 (yes) Append to existing files
outdir string 1047 "" 1 11 Specifies a single directory as the location to write all output files
outlev enumint 1015 2 1 11 Controls the level of output produced by Knitro
 0 1 (none) Nothing
 1 1 (summary) Only final summary information
 2 1 (iter_10) Information every 10 iterations is printed
 3 1 (iter) Information at each iteration is printed
 4 1 (iter_verbose) More verbose information at each iteration is printed
 5 1 (iter_x) In addition, values of solution vector (x) are printed
 6 1 (all) In addition, constraints (c) and multipliers (lambda)
outmode enumint 1016 0 1 11 Specifies where to direct the output from Knitro
 0 1 (screen) Directed to stdout
 1 1 (file) Directed to a file (default name knitro.log)
 2 1 (both) Both stdout and file (default name knitro.log)
outname string 1105 "" 1 11 Use to specify a custom filename when output is written to a file using \ref KNITROoutmode "outmode"
tuner_optionsfile string 1071 "" 1 12 Can be used to specify the location of a Tuner options file
tuner_outsub enumint 1074 0 1 12 Enable writing additional Tuner subproblem solve output to files for the Knitro-Tuner procedure (\ref KNITROtuner "tuner"=1)
 0 1 (none) No output from subproblem solves and no subproblem summary file
 1 1 (summary) Subproblem output summary directed to a file knitro_tuner_summary.log
 2 1 (all) Subproblem output enabled, controlled by option outlev.
tuner_sub_maxtime double 1166 1e+08 0 maxdouble 1 12 Specifies, in seconds, the maximum allowable real time for Knitro-Tuner subproblems (i.e. individual solves with a particular option setting)
tuner_terminate enumint 1075 0 1 12 Define the termination condition for the Knitro-Tuner procedure (\ref KNITROtuner "tuner"=1)
 0 1 (all) Terminate after all Tuner runs complete
 1 1 (optimal) Terminate at first local optimum
 2 1 (feasible) Terminate at first feasible solution estimate
 3 1 (any) Terminate at first completed solve
al_initpenalty double 1171 0 0 1e+16 1 13 Specifies the initial penalty parameter value used in the Augmented Lagrangian (AL) algorithm
al_maxpenalty double 1172 1e+10 0 1e+16 1 13 Specifies the maximum allowable penalty parameter value used in the Augmented Lagrangian (AL) algorithm
algorithm enumint 1003 0 1 1 Indicates which algorithm to use to solve the problem
 0 1 (auto) let Knitro automatically choose an algorithm, based on the problem characteristics.
 1 1 (direct) use the Interior/Direct algorithm.
 2 1 (cg) use the Interior/CG algorithm.
 3 1 (active) use the Active Set algorithm.
 4 1 (sqp) use the SQP algorithm.
 5 1 (multi) run all algorithms, perhaps in parallel (see Algorithms).
 6 1 (al) use the Augmented Lagrangian algorithm.
names boolean 0 0 1 1 Enable to pass variable and equation names to Knitro
newpoint_skip boolean 0 0 0 1 skip registering of newpoint callback: workaround for KNITRO bugs
option_file string 0 "" 1 1 additional option file name - read only by KNITRO solver lib
output_time boolean 0 0 1 1 print output on where time is used
qextractalg enumint 0 0 1 1 quadratic extraction algorithm in GAMS interface
 0 1 Automatic
 1 1 ThreePass: Uses a three-pass forward / backward / forward AD technique to compute function / gradient / Hessian values and a hybrid scheme for storage.
 2 1 DoubleForward: Uses forward-mode AD to compute and store function, gradient, and Hessian values at each node or stack level as required.  The gradients and Hessians are stored in linked lists.
 3 1 Concurrent: Uses ThreePass and DoubleForward in parallel. As soon as one finishes, the other one stops.
qextractdenseswitchfactor double 0 0.008 0 maxdouble 1 1 Sparse/dense factor for quadratic extraction algorithm in GAMS interface
qextractdenseswitchlog boolean 0 0 1 1 Enables additional information about sparse/dense factor choice in quadratic extraction algorithm in GAMS interface
threads integer 0 1 minint maxint 1 10 default thread count
useq boolean 0 1 0 1 consider quadratic equations as general nonlinear equations when disabled
uselsq boolean 0 0 0 1 use Knitro least-squares solver (CNS models only)
initvalues0 enumint 0 2 1 1 Enable use of initial guess for levels and marginals (first solve)
 0 1 Using no initial values
 1 1 Using all initial values
 2 1 Using only non-default initial values
initvalues enumint 0 1 1 1 Enable use of initial guess for levels and marginals (subsequent solves)
 0 1 Using no initial values
 1 1 Using all initial values
 2 1 Using only non-default initial values
*
* synonym section
*
feastolabs synonym feastol_abs
maxtime_cpu synonym maxtime
maxtime_real synonym maxtime
mip_maxtime_cpu synonym maxtime
mip_maxtime_real synonym maxtime
ma_maxtime_cpu synonym maxtime
ma_maxtime_real synonym maxtime
ms_maxtime_cpu synonym maxtime
ms_maxtime_real synonym maxtime
tuner_maxtime_cpu synonym maxtime
tuner_maxtime_real synonym maxtime
opttolabs synonym opttol_abs
bar_pencons synonym bar_penaltycons
bar_penrule synonym bar_penaltyrule
mip_integral_gap_abs synonym mip_opt_gap_abs
mip_integral_gap_rel synonym mip_opt_gap_rel
par_msnumthreads synonym ms_numthreads
par_blasnumthreads synonym blas_numthreads
par_lsnumthreads synonym linsolver_numthreads
par_numthreads synonym threads
numthreads synonym threads
iterlim synonym maxit
reslim synonym maxtime
nodlim synonym mip_maxnodes
optca synonym mip_opt_gap_abs
optcr synonym mip_opt_gap_rel
gthreads synonym threads
*
* deprecated section
*
synon deprecated
 algorithm
 par_numthreads
 bar_pencons
 bar_penrule
 mip_integral_gap_abs
 mip_integral_gap_rel
 par_msnumthreads
 par_blasnumthreads
 par_lsnumthreads
 maxtime_cpu
 maxtime_real
 mip_maxtime_cpu
 mip_maxtime_real
 ma_maxtime_cpu
 ma_maxtime_real
 ms_maxtime_cpu
 ms_maxtime_real
 tuner_maxtime_cpu
 tuner_maxtime_real
*
* Groups
* <group-ident> group <group-number <help-context> <help-text>
*
general group 1 1 General options
derivatives group 2 1 Derivative options
termination group 3 1 Termination options
presolve group 4 1 Presolve options
barrier group 5 1 Barrier options
activeset group 6 1 Active-set options
mip group 7 1 MIP options
multialgorithm group 8 1 Multi-algorithm options
multistart group 9 1 Multi-start options
parallelism group 10 1 Parallelism options
output group 11 1 Output options
tuner group 12 1 Tuner options
other group 13 1 Other options
*** End of file
