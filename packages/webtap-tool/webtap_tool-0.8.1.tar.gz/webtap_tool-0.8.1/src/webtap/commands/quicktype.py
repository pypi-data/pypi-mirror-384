"""Generate types and schemas from HTTP response bodies using quicktype."""

import json
import shutil
import subprocess
from datetime import datetime
from pathlib import Path
from webtap.app import app
from webtap.commands._builders import check_connection, success_response, error_response
from webtap.commands._code_generation import ensure_output_directory
from webtap.commands._tips import get_mcp_description


mcp_desc = get_mcp_description("quicktype")

# Header template for generated files
HEADER_TEMPLATE = """Generated by WebTap from event {event_id}
Source: {url}
Method: {method}
Generated: {timestamp}

Do not edit manually."""

# Comment syntax per language
COMMENT_STYLES = {
    "TypeScript": "//",
    "Python": "#",
    "Go": "//",
    "Rust": "//",
    "Java": "//",
    "Kotlin": "//",
    "Swift": "//",
    "C#": "//",
    "C++": "//",
    "Dart": "//",
    "Ruby": "#",
    "JSON Schema": None,  # No comments in JSON
}


def _run_quicktype(
    json_data: dict | list,
    output: str,
    type_name: str = None,  # pyright: ignore[reportArgumentType]
    just_types: bool = True,
    prefer_types: bool = True,
    options: dict = None,  # pyright: ignore[reportArgumentType]
) -> tuple[bool, str]:
    """Run quicktype CLI with given parameters.

    Args:
        json_data: JSON data to convert
        output: Output file path
        type_name: Top-level type name
        just_types: Generate only types, no serializers
        prefer_types: Use 'type' instead of 'interface' for TypeScript
        options: Additional quicktype flags

    Returns:
        Tuple of (success: bool, error_message: str)
    """
    # Check if quicktype is available
    if not shutil.which("quicktype"):
        return False, "quicktype CLI not found. Install with: npm install -g quicktype"

    # Determine language from file extension
    output_path = Path(output)
    ext = output_path.suffix.lower()

    # Build command
    cmd = ["quicktype", "-o", str(output), "--src-lang", "json", "--top-level", type_name]

    # Add opinionated defaults
    if just_types:
        cmd.append("--just-types")

    # TypeScript-specific options
    if ext in {".ts", ".tsx"} and prefer_types:
        cmd.append("--prefer-types")

    # Apply additional options
    for key, val in (options or {}).items():
        flag = f"--{key.replace('_', '-')}"
        if val is True:
            cmd.append(flag)
        elif val is not False and val is not None:
            cmd.extend([flag, str(val)])

    # Run quicktype
    try:
        subprocess.run(
            cmd,
            input=json.dumps(json_data, indent=2),
            capture_output=True,
            text=True,
            check=True,
            timeout=30,
        )
        return True, ""
    except subprocess.CalledProcessError as e:
        return False, f"quicktype failed: {e.stderr.strip() if e.stderr else str(e)}"
    except subprocess.TimeoutExpired:
        return False, "quicktype timed out (>30s)"
    except Exception as e:
        return False, f"Unexpected error: {str(e)}"


def _insert_header(state, event: int, output_path: Path, language: str) -> None:
    """Insert language-aware header comment into generated file.

    Args:
        state: WebTap state with CDP session
        event: Event row ID for metadata extraction
        output_path: Path to generated file
        language: Target language (e.g., "TypeScript", "Python")
    """
    if not HEADER_TEMPLATE or language not in COMMENT_STYLES:
        return

    comment_prefix = COMMENT_STYLES[language]
    if not comment_prefix:  # Skip languages without comments (e.g., JSON)
        return

    try:
        # Get event metadata
        event_result = state.cdp.query("SELECT event FROM events WHERE rowid = ?", [event])
        if not event_result:
            return

        event_data = json.loads(event_result[0][0])
        params = event_data.get("params", {})

        # Extract metadata from event
        request_data = params.get("request", {})
        response_data = params.get("response", {})

        metadata = {
            "event_id": event,
            "url": request_data.get("url") or response_data.get("url", "N/A"),
            "method": request_data.get("method", "N/A"),
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        }

        # Format header text with metadata
        header_text = HEADER_TEMPLATE.format(**metadata)

        # Apply comment syntax to each line
        header_lines = [
            f"{comment_prefix} {line}" if line.strip() else comment_prefix for line in header_text.split("\n")
        ]
        header = "\n".join(header_lines)

        # Prepend header to file
        content = output_path.read_text()
        output_path.write_text(header + "\n\n" + content)
    except Exception:
        # Silent failure - don't break generation if header fails
        pass


@app.command(display="markdown", fastmcp={"type": "tool", "description": mcp_desc} if mcp_desc else {"type": "tool"})
def quicktype(
    state,
    event: int,
    output: str,
    type_name: str,
    json_path: str = None,  # pyright: ignore[reportArgumentType]
    expr: str = None,  # pyright: ignore[reportArgumentType]
    just_types: bool = True,
    prefer_types: bool = True,
    options: dict = None,  # pyright: ignore[reportArgumentType]
) -> dict:  # pyright: ignore[reportArgumentType]
    """Generate types/schemas from request or response body using quicktype CLI.

    Args:
        event: Event row ID from network() or events()
        output: Output file path (extension determines language: .ts, .py, .go, etc.)
        type_name: Top-level type name (e.g., "User", "ApiResponse")
        json_path: Optional JSON path to extract nested data (e.g., "data[0]")
        expr: Optional Python expression to transform data (has 'body' and 'event' variables)
        just_types: Generate only types, no serializers (default: True)
        prefer_types: Use 'type' instead of 'interface' for TypeScript (default: True)
        options: Additional quicktype flags as dict (e.g., {"readonly": True, "nice_property_names": True})

    Examples:
        quicktype(123, "types/User.ts", "User")                                    # TypeScript interface
        quicktype(123, "models/customer.py", "Customer")                           # Python dataclass
        quicktype(123, "api.go", "ApiResponse")                                    # Go struct
        quicktype(123, "schema.json", "Schema")                                     # JSON Schema
        quicktype(123, "types.ts", "User", json_path="data[0]")                    # Extract nested
        quicktype(172, "types/Form.ts", "Form", expr="dict(urllib.parse.parse_qsl(body))")  # Parse form data
        quicktype(123, "types.ts", "User", options={"readonly": True})             # Advanced options

    Returns:
        Success message with generation details
    """
    if error := check_connection(state):
        return error

    # Prepare data via service layer
    result = state.service.body.prepare_for_generation(event, json_path, expr)
    if result.get("error"):
        return error_response(result["error"], suggestions=result.get("suggestions", []))

    data = result["data"]

    # Ensure output directory exists
    output_path = ensure_output_directory(output)

    # Run quicktype
    success, error_msg = _run_quicktype(
        json_data=data,
        output=str(output_path),
        type_name=type_name,
        just_types=just_types,
        prefer_types=prefer_types,
        options=options,
    )

    if not success:
        return error_response(
            error_msg,
            suggestions=[
                "Check that quicktype is installed: npm install -g quicktype",
                "Verify the JSON structure is valid",
                "Try simplifying the data with json_path",
            ],
        )

    # Detect language from extension
    ext = output_path.suffix.lower()
    lang_map = {
        ".ts": "TypeScript",
        ".tsx": "TypeScript",
        ".py": "Python",
        ".go": "Go",
        ".rs": "Rust",
        ".java": "Java",
        ".kt": "Kotlin",
        ".swift": "Swift",
        ".cs": "C#",
        ".cpp": "C++",
        ".dart": "Dart",
        ".rb": "Ruby",
        ".json": "JSON Schema",
    }
    language = lang_map.get(ext, "Unknown")

    # Add header comment with event metadata
    _insert_header(state, event, output_path, language)

    # Count lines in generated file
    try:
        file_content = output_path.read_text()
        line_count = len(file_content.splitlines())
    except Exception:
        line_count = "unknown"

    return success_response(
        "Types generated successfully",
        details={
            "Output": str(output_path),
            "Language": language,
            "Type Name": type_name,
            "Lines": line_count,
            "Size": f"{output_path.stat().st_size} bytes",
        },
    )
