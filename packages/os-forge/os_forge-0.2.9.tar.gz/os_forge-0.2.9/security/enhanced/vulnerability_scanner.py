#!/usr/bin/env python3
"""
Enhanced Vulnerability Scanner for OS Forge
Provides comprehensive security scanning capabilities
"""

import os
import re
import json
import hashlib
import subprocess
import logging
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
import yaml

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class Vulnerability:
    """Represents a security vulnerability"""
    id: str
    severity: str  # CRITICAL, HIGH, MEDIUM, LOW, INFO
    title: str
    description: str
    file_path: str
    line_number: Optional[int]
    cwe_id: Optional[str]
    cvss_score: Optional[float]
    remediation: str
    references: List[str]
    detected_at: datetime

@dataclass
class ScanResult:
    """Results of a security scan"""
    scan_id: str
    timestamp: datetime
    total_files_scanned: int
    vulnerabilities: List[Vulnerability]
    summary: Dict[str, int]
    scan_duration: float

class VulnerabilityScanner:
    """Enhanced vulnerability scanner with multiple detection methods"""
    
    def __init__(self, config_path: Optional[str] = None):
        self.config = self._load_config(config_path)
        self.vulnerability_patterns = self._load_vulnerability_patterns()
        self.secret_patterns = self._load_secret_patterns()
        self.dependency_scanner = DependencyScanner()
        
    def _load_config(self, config_path: Optional[str]) -> Dict[str, Any]:
        """Load scanner configuration"""
        default_config = {
            "scan_directories": ["./"],
            "exclude_patterns": [
                "**/node_modules/**",
                "**/.git/**",
                "**/venv/**",
                "**/env/**",
                "**/__pycache__/**",
                "**/.pytest_cache/**",
                "**/dist/**",
                "**/build/**",
                "**/*.pyc",
                "**/*.pyo",
                "**/*.log",
                "**/*.tmp"
            ],
            "file_extensions": [".py", ".js", ".ts", ".yaml", ".yml", ".json", ".sh", ".sql"],
            "max_file_size": 10 * 1024 * 1024,  # 10MB
            "enable_dependency_scan": True,
            "enable_secret_scan": True,
            "enable_code_analysis": True
        }
        
        if config_path and os.path.exists(config_path):
            try:
                with open(config_path, 'r') as f:
                    user_config = yaml.safe_load(f)
                    default_config.update(user_config)
            except Exception as e:
                logger.warning(f"Failed to load config from {config_path}: {e}")
                
        return default_config
    
    def _load_vulnerability_patterns(self) -> Dict[str, List[Dict]]:
        """Load vulnerability detection patterns"""
        return {
            "sql_injection": [
                {
                    "pattern": r"execute\s*\(\s*['\"].*%s.*['\"]",
                    "severity": "HIGH",
                    "title": "Potential SQL Injection",
                    "description": "Direct string formatting in SQL queries can lead to SQL injection",
                    "cwe_id": "CWE-89"
                },
                {
                    "pattern": r"cursor\.execute\s*\(\s*f['\"].*\{.*\}.*['\"]",
                    "severity": "HIGH",
                    "title": "F-string SQL Injection Risk",
                    "description": "F-string formatting in SQL queries without proper sanitization",
                    "cwe_id": "CWE-89"
                }
            ],
            "command_injection": [
                {
                    "pattern": r"os\.system\s*\(\s*.*\+.*\)",
                    "severity": "HIGH",
                    "title": "Command Injection via os.system",
                    "description": "String concatenation in os.system calls can lead to command injection",
                    "cwe_id": "CWE-78"
                },
                {
                    "pattern": r"subprocess\.call\s*\(\s*.*shell=True.*\)",
                    "severity": "MEDIUM",
                    "title": "Shell Injection Risk",
                    "description": "Using shell=True with subprocess can be dangerous",
                    "cwe_id": "CWE-78"
                }
            ],
            "path_traversal": [
                {
                    "pattern": r"open\s*\(\s*.*\+.*\)",
                    "severity": "MEDIUM",
                    "title": "Potential Path Traversal",
                    "description": "String concatenation in file operations can lead to path traversal",
                    "cwe_id": "CWE-22"
                }
            ],
            "hardcoded_secrets": [
                {
                    "pattern": r"password\s*=\s*['\"][^'\"]{8,}['\"]",
                    "severity": "CRITICAL",
                    "title": "Hardcoded Password",
                    "description": "Hardcoded password found in source code",
                    "cwe_id": "CWE-798"
                },
                {
                    "pattern": r"api_key\s*=\s*['\"][^'\"]{20,}['\"]",
                    "severity": "CRITICAL",
                    "title": "Hardcoded API Key",
                    "description": "Hardcoded API key found in source code",
                    "cwe_id": "CWE-798"
                },
                {
                    "pattern": r"secret\s*=\s*['\"][^'\"]{16,}['\"]",
                    "severity": "CRITICAL",
                    "title": "Hardcoded Secret",
                    "description": "Hardcoded secret found in source code",
                    "cwe_id": "CWE-798"
                }
            ],
            "weak_crypto": [
                {
                    "pattern": r"md5\s*\(",
                    "severity": "MEDIUM",
                    "title": "Weak Hash Function (MD5)",
                    "description": "MD5 is cryptographically broken and should not be used",
                    "cwe_id": "CWE-327"
                },
                {
                    "pattern": r"sha1\s*\(",
                    "severity": "MEDIUM",
                    "title": "Weak Hash Function (SHA1)",
                    "description": "SHA1 is cryptographically weak and should not be used for security purposes",
                    "cwe_id": "CWE-327"
                }
            ],
            "insecure_deserialization": [
                {
                    "pattern": r"pickle\.loads?\s*\(",
                    "severity": "HIGH",
                    "title": "Insecure Deserialization",
                    "description": "Pickle deserialization can lead to code execution",
                    "cwe_id": "CWE-502"
                }
            ]
        }
    
    def _load_secret_patterns(self) -> Dict[str, Dict]:
        """Load secret detection patterns"""
        return {
            "aws_access_key": {
                "pattern": r"AKIA[0-9A-Z]{16}",
                "severity": "CRITICAL",
                "title": "AWS Access Key ID",
                "description": "AWS Access Key ID found in code"
            },
            "aws_secret_key": {
                "pattern": r"[A-Za-z0-9/+=]{40}",
                "severity": "CRITICAL",
                "title": "AWS Secret Access Key",
                "description": "AWS Secret Access Key found in code"
            },
            "github_token": {
                "pattern": r"ghp_[A-Za-z0-9]{36}",
                "severity": "CRITICAL",
                "title": "GitHub Personal Access Token",
                "description": "GitHub Personal Access Token found in code"
            },
            "private_key": {
                "pattern": r"-----BEGIN (RSA |DSA |EC )?PRIVATE KEY-----",
                "severity": "CRITICAL",
                "title": "Private Key",
                "description": "Private key found in code"
            },
            "jwt_secret": {
                "pattern": r"jwt_secret\s*=\s*['\"][^'\"]{32,}['\"]",
                "severity": "HIGH",
                "title": "JWT Secret",
                "description": "JWT secret found in code"
            }
        }
    
    def scan_directory(self, directory: str = None) -> ScanResult:
        """Perform comprehensive security scan of directory"""
        start_time = datetime.now()
        scan_id = hashlib.md5(f"{start_time.isoformat()}{directory}".encode()).hexdigest()[:8]
        
        if directory is None:
            directory = self.config["scan_directories"][0]
            
        logger.info(f"Starting security scan {scan_id} of {directory}")
        
        vulnerabilities = []
        total_files_scanned = 0
        
        # Get files to scan
        files_to_scan = self._get_files_to_scan(directory)
        
        # Scan each file
        for file_path in files_to_scan:
            try:
                file_vulns = self._scan_file(file_path)
                vulnerabilities.extend(file_vulns)
                total_files_scanned += 1
            except Exception as e:
                logger.error(f"Error scanning {file_path}: {e}")
        
        # Dependency scan
        if self.config["enable_dependency_scan"]:
            dep_vulns = self.dependency_scanner.scan_dependencies()
            vulnerabilities.extend(dep_vulns)
        
        # Generate summary
        summary = self._generate_summary(vulnerabilities)
        
        scan_duration = (datetime.now() - start_time).total_seconds()
        
        result = ScanResult(
            scan_id=scan_id,
            timestamp=start_time,
            total_files_scanned=total_files_scanned,
            vulnerabilities=vulnerabilities,
            summary=summary,
            scan_duration=scan_duration
        )
        
        logger.info(f"Scan completed: {len(vulnerabilities)} vulnerabilities found in {total_files_scanned} files")
        return result
    
    def _get_files_to_scan(self, directory: str) -> List[str]:
        """Get list of files to scan based on configuration"""
        files = []
        
        for root, dirs, filenames in os.walk(directory):
            # Skip excluded directories
            dirs[:] = [d for d in dirs if not self._should_exclude_dir(d, root)]
            
            for filename in filenames:
                file_path = os.path.join(root, filename)
                
                if self._should_scan_file(file_path):
                    files.append(file_path)
        
        return files
    
    def _should_exclude_dir(self, dirname: str, root: str) -> bool:
        """Check if directory should be excluded"""
        rel_path = os.path.relpath(os.path.join(root, dirname))
        
        for pattern in self.config["exclude_patterns"]:
            if self._match_pattern(rel_path, pattern):
                return True
        return False
    
    def _should_scan_file(self, file_path: str) -> bool:
        """Check if file should be scanned"""
        # Check file extension
        ext = os.path.splitext(file_path)[1].lower()
        if ext not in self.config["file_extensions"]:
            return False
        
        # Check file size
        try:
            if os.path.getsize(file_path) > self.config["max_file_size"]:
                return False
        except OSError:
            return False
        
        # Check exclude patterns
        rel_path = os.path.relpath(file_path)
        for pattern in self.config["exclude_patterns"]:
            if self._match_pattern(rel_path, pattern):
                return False
        
        return True
    
    def _match_pattern(self, path: str, pattern: str) -> bool:
        """Simple pattern matching for file paths"""
        import fnmatch
        return fnmatch.fnmatch(path, pattern)
    
    def _scan_file(self, file_path: str) -> List[Vulnerability]:
        """Scan individual file for vulnerabilities"""
        vulnerabilities = []
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                lines = content.split('\n')
        except Exception as e:
            logger.error(f"Could not read {file_path}: {e}")
            return vulnerabilities
        
        # Scan for code vulnerabilities
        if self.config["enable_code_analysis"]:
            code_vulns = self._scan_code_patterns(file_path, content, lines)
            vulnerabilities.extend(code_vulns)
        
        # Scan for secrets
        if self.config["enable_secret_scan"]:
            secret_vulns = self._scan_secrets(file_path, content, lines)
            vulnerabilities.extend(secret_vulns)
        
        return vulnerabilities
    
    def _scan_code_patterns(self, file_path: str, content: str, lines: List[str]) -> List[Vulnerability]:
        """Scan for code vulnerability patterns"""
        vulnerabilities = []
        
        for vuln_type, patterns in self.vulnerability_patterns.items():
            for pattern_info in patterns:
                pattern = pattern_info["pattern"]
                matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)
                
                for match in matches:
                    line_number = content[:match.start()].count('\n') + 1
                    
                    vuln = Vulnerability(
                        id=f"{vuln_type}_{hash(match.group()) % 10000:04d}",
                        severity=pattern_info["severity"],
                        title=pattern_info["title"],
                        description=pattern_info["description"],
                        file_path=file_path,
                        line_number=line_number,
                        cwe_id=pattern_info.get("cwe_id"),
                        cvss_score=self._get_cvss_score(pattern_info["severity"]),
                        remediation=self._get_remediation(vuln_type),
                        references=self._get_references(vuln_type),
                        detected_at=datetime.now()
                    )
                    vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _scan_secrets(self, file_path: str, content: str, lines: List[str]) -> List[Vulnerability]:
        """Scan for hardcoded secrets"""
        vulnerabilities = []
        
        for secret_type, pattern_info in self.secret_patterns.items():
            pattern = pattern_info["pattern"]
            matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)
            
            for match in matches:
                line_number = content[:match.start()].count('\n') + 1
                
                vuln = Vulnerability(
                    id=f"secret_{secret_type}_{hash(match.group()) % 10000:04d}",
                    severity=pattern_info["severity"],
                    title=pattern_info["title"],
                    description=pattern_info["description"],
                    file_path=file_path,
                    line_number=line_number,
                    cwe_id="CWE-798",
                    cvss_score=self._get_cvss_score(pattern_info["severity"]),
                    remediation="Remove hardcoded secret and use environment variables or secure secret management",
                    references=["https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_credentials"],
                    detected_at=datetime.now()
                )
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _get_cvss_score(self, severity: str) -> float:
        """Convert severity to CVSS score"""
        severity_scores = {
            "CRITICAL": 9.0,
            "HIGH": 7.0,
            "MEDIUM": 5.0,
            "LOW": 3.0,
            "INFO": 1.0
        }
        return severity_scores.get(severity, 0.0)
    
    def _get_remediation(self, vuln_type: str) -> str:
        """Get remediation advice for vulnerability type"""
        remediations = {
            "sql_injection": "Use parameterized queries or prepared statements instead of string formatting",
            "command_injection": "Use subprocess with list arguments instead of shell=True, validate all inputs",
            "path_traversal": "Validate and sanitize file paths, use os.path.join for path construction",
            "hardcoded_secrets": "Use environment variables or secure secret management systems",
            "weak_crypto": "Use strong cryptographic algorithms like SHA-256 or bcrypt",
            "insecure_deserialization": "Use safe serialization formats like JSON or implement proper validation"
        }
        return remediations.get(vuln_type, "Review and fix the identified security issue")
    
    def _get_references(self, vuln_type: str) -> List[str]:
        """Get reference links for vulnerability type"""
        references = {
            "sql_injection": ["https://owasp.org/www-community/attacks/SQL_Injection"],
            "command_injection": ["https://owasp.org/www-community/attacks/Command_Injection"],
            "path_traversal": ["https://owasp.org/www-community/attacks/Path_Traversal"],
            "hardcoded_secrets": ["https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_credentials"],
            "weak_crypto": ["https://owasp.org/www-community/vulnerabilities/Weak_Cryptography"],
            "insecure_deserialization": ["https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data"]
        }
        return references.get(vuln_type, ["https://owasp.org/"])
    
    def _generate_summary(self, vulnerabilities: List[Vulnerability]) -> Dict[str, int]:
        """Generate vulnerability summary"""
        summary = {
            "CRITICAL": 0,
            "HIGH": 0,
            "MEDIUM": 0,
            "LOW": 0,
            "INFO": 0,
            "total": len(vulnerabilities)
        }
        
        for vuln in vulnerabilities:
            summary[vuln.severity] += 1
        
        return summary
    
    def export_results(self, result: ScanResult, output_format: str = "json", output_path: str = None) -> str:
        """Export scan results to file"""
        if output_path is None:
            timestamp = result.timestamp.strftime("%Y%m%d_%H%M%S")
            output_path = f"security_scan_{result.scan_id}_{timestamp}.{output_format}"
        
        if output_format.lower() == "json":
            self._export_json(result, output_path)
        elif output_format.lower() == "html":
            self._export_html(result, output_path)
        elif output_format.lower() == "csv":
            self._export_csv(result, output_path)
        else:
            raise ValueError(f"Unsupported output format: {output_format}")
        
        return output_path
    
    def _export_json(self, result: ScanResult, output_path: str):
        """Export results as JSON"""
        data = {
            "scan_id": result.scan_id,
            "timestamp": result.timestamp.isoformat(),
            "total_files_scanned": result.total_files_scanned,
            "scan_duration": result.scan_duration,
            "summary": result.summary,
            "vulnerabilities": [
                {
                    "id": v.id,
                    "severity": v.severity,
                    "title": v.title,
                    "description": v.description,
                    "file_path": v.file_path,
                    "line_number": v.line_number,
                    "cwe_id": v.cwe_id,
                    "cvss_score": v.cvss_score,
                    "remediation": v.remediation,
                    "references": v.references,
                    "detected_at": v.detected_at.isoformat()
                }
                for v in result.vulnerabilities
            ]
        }
        
        with open(output_path, 'w') as f:
            json.dump(data, f, indent=2)
    
    def _export_html(self, result: ScanResult, output_path: str):
        """Export results as HTML report"""
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>OS Forge Security Scan Report</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ background-color: #f0f0f0; padding: 20px; border-radius: 5px; }}
                .summary {{ margin: 20px 0; }}
                .severity-critical {{ color: #d32f2f; font-weight: bold; }}
                .severity-high {{ color: #f57c00; font-weight: bold; }}
                .severity-medium {{ color: #fbc02d; font-weight: bold; }}
                .severity-low {{ color: #388e3c; font-weight: bold; }}
                .severity-info {{ color: #1976d2; font-weight: bold; }}
                .vulnerability {{ border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }}
                .vuln-header {{ font-weight: bold; margin-bottom: 10px; }}
                .vuln-details {{ margin: 5px 0; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>OS Forge Security Scan Report</h1>
                <p><strong>Scan ID:</strong> {result.scan_id}</p>
                <p><strong>Timestamp:</strong> {result.timestamp.strftime('%Y-%m-%d %H:%M:%S')}</p>
                <p><strong>Files Scanned:</strong> {result.total_files_scanned}</p>
                <p><strong>Scan Duration:</strong> {result.scan_duration:.2f} seconds</p>
            </div>
            
            <div class="summary">
                <h2>Summary</h2>
                <p><span class="severity-critical">Critical:</span> {result.summary['CRITICAL']}</p>
                <p><span class="severity-high">High:</span> {result.summary['HIGH']}</p>
                <p><span class="severity-medium">Medium:</span> {result.summary['MEDIUM']}</p>
                <p><span class="severity-low">Low:</span> {result.summary['LOW']}</p>
                <p><span class="severity-info">Info:</span> {result.summary['INFO']}</p>
                <p><strong>Total:</strong> {result.summary['total']}</p>
            </div>
            
            <div class="vulnerabilities">
                <h2>Vulnerabilities</h2>
        """
        
        for vuln in result.vulnerabilities:
            html_content += f"""
                <div class="vulnerability">
                    <div class="vuln-header">
                        <span class="severity-{vuln.severity.lower()}">{vuln.severity}</span> - {vuln.title}
                    </div>
                    <div class="vuln-details"><strong>File:</strong> {vuln.file_path}</div>
                    <div class="vuln-details"><strong>Line:</strong> {vuln.line_number}</div>
                    <div class="vuln-details"><strong>Description:</strong> {vuln.description}</div>
                    <div class="vuln-details"><strong>Remediation:</strong> {vuln.remediation}</div>
                    {f'<div class="vuln-details"><strong>CWE:</strong> {vuln.cwe_id}</div>' if vuln.cwe_id else ''}
                    {f'<div class="vuln-details"><strong>CVSS Score:</strong> {vuln.cvss_score}</div>' if vuln.cvss_score else ''}
                </div>
            """
        
        html_content += """
            </div>
        </body>
        </html>
        """
        
        with open(output_path, 'w') as f:
            f.write(html_content)
    
    def _export_csv(self, result: ScanResult, output_path: str):
        """Export results as CSV"""
        import csv
        
        with open(output_path, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow([
                'ID', 'Severity', 'Title', 'Description', 'File Path', 'Line Number',
                'CWE ID', 'CVSS Score', 'Remediation', 'References', 'Detected At'
            ])
            
            for vuln in result.vulnerabilities:
                writer.writerow([
                    vuln.id,
                    vuln.severity,
                    vuln.title,
                    vuln.description,
                    vuln.file_path,
                    vuln.line_number,
                    vuln.cwe_id,
                    vuln.cvss_score,
                    vuln.remediation,
                    '; '.join(vuln.references),
                    vuln.detected_at.isoformat()
                ])


class DependencyScanner:
    """Scanner for dependency vulnerabilities"""
    
    def __init__(self):
        self.package_files = ["requirements.txt", "package.json", "Pipfile", "poetry.lock"]
    
    def scan_dependencies(self) -> List[Vulnerability]:
        """Scan for vulnerable dependencies"""
        vulnerabilities = []
        
        # Check for requirements.txt
        if os.path.exists("requirements.txt"):
            vulns = self._scan_python_dependencies()
            vulnerabilities.extend(vulns)
        
        # Check for package.json
        if os.path.exists("package.json"):
            vulns = self._scan_node_dependencies()
            vulnerabilities.extend(vulns)
        
        return vulnerabilities
    
    def _scan_python_dependencies(self) -> List[Vulnerability]:
        """Scan Python dependencies for known vulnerabilities"""
        vulnerabilities = []
        
        try:
            with open("requirements.txt", 'r') as f:
                requirements = f.read()
            
            # Check for known vulnerable packages
            vulnerable_packages = {
                "django": {"version": "<2.2.0", "cve": "CVE-2019-14234"},
                "flask": {"version": "<1.0.0", "cve": "CVE-2018-1000656"},
                "requests": {"version": "<2.20.0", "cve": "CVE-2018-18074"}
            }
            
            for package, info in vulnerable_packages.items():
                if package in requirements.lower():
                    vuln = Vulnerability(
                        id=f"dep_{package}_{hash(package) % 10000:04d}",
                        severity="MEDIUM",
                        title=f"Potentially Vulnerable Dependency: {package}",
                        description=f"Package {package} may have known vulnerabilities. Check for updates.",
                        file_path="requirements.txt",
                        line_number=None,
                        cwe_id="CWE-1104",
                        cvss_score=5.0,
                        remediation=f"Update {package} to the latest version and check for security advisories",
                        references=[f"https://nvd.nist.gov/vuln/detail/{info['cve']}"],
                        detected_at=datetime.now()
                    )
                    vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.error(f"Error scanning Python dependencies: {e}")
        
        return vulnerabilities
    
    def _scan_node_dependencies(self) -> List[Vulnerability]:
        """Scan Node.js dependencies for known vulnerabilities"""
        vulnerabilities = []
        
        try:
            with open("package.json", 'r') as f:
                package_data = json.load(f)
            
            dependencies = package_data.get("dependencies", {})
            
            # Check for known vulnerable packages
            vulnerable_packages = {
                "lodash": {"version": "<4.17.12", "cve": "CVE-2019-10744"},
                "express": {"version": "<4.17.0", "cve": "CVE-2019-10744"}
            }
            
            for package, info in vulnerable_packages.items():
                if package in dependencies:
                    vuln = Vulnerability(
                        id=f"dep_{package}_{hash(package) % 10000:04d}",
                        severity="MEDIUM",
                        title=f"Potentially Vulnerable Dependency: {package}",
                        description=f"Package {package} may have known vulnerabilities. Check for updates.",
                        file_path="package.json",
                        line_number=None,
                        cwe_id="CWE-1104",
                        cvss_score=5.0,
                        remediation=f"Update {package} to the latest version and run 'npm audit'",
                        references=[f"https://nvd.nist.gov/vuln/detail/{info['cve']}"],
                        detected_at=datetime.now()
                    )
                    vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.error(f"Error scanning Node.js dependencies: {e}")
        
        return vulnerabilities


def main():
    """CLI interface for vulnerability scanner"""
    import argparse
    
    parser = argparse.ArgumentParser(description="OS Forge Vulnerability Scanner")
    parser.add_argument("--directory", "-d", default="./", help="Directory to scan")
    parser.add_argument("--config", "-c", help="Configuration file path")
    parser.add_argument("--output", "-o", help="Output file path")
    parser.add_argument("--format", "-f", choices=["json", "html", "csv"], default="json", help="Output format")
    parser.add_argument("--verbose", "-v", action="store_true", help="Verbose output")
    
    args = parser.parse_args()
    
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    scanner = VulnerabilityScanner(args.config)
    result = scanner.scan_directory(args.directory)
    
    # Print summary
    print(f"\n=== Security Scan Results ===")
    print(f"Scan ID: {result.scan_id}")
    print(f"Files Scanned: {result.total_files_scanned}")
    print(f"Duration: {result.scan_duration:.2f}s")
    print(f"\nVulnerabilities Found:")
    for severity, count in result.summary.items():
        if severity != "total" and count > 0:
            print(f"  {severity}: {count}")
    print(f"  Total: {result.summary['total']}")
    
    # Export results
    if args.output or args.format != "json":
        output_path = scanner.export_results(result, args.format, args.output)
        print(f"\nResults exported to: {output_path}")
    
    return 0 if result.summary['CRITICAL'] == 0 and result.summary['HIGH'] == 0 else 1


if __name__ == "__main__":
    exit(main())
