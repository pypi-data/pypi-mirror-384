import logging
from logging.handlers import TimedRotatingFileHandler
import os
import sys
from typing import Optional

LOG_FORMAT = "[%(asctime)s.%(msecs)03d] %(levelname)-7s %(name)s : %(message)s"
LOG_FORMAT_DETAIL = "[%(asctime)s.%(msecs)03d] %(levelname)-7s %(module)s.%(funcName)s.%(lineno)d : %(message)s"
DATE_FORMAT = "%Y-%m-%d %H:%M:%S"

LOG_FILE = "logs/echoss.log"

# Set environment variable for Python IO encoding
os.environ["PYTHONIOENCODING"] = "utf-8"


def _get_console_handler(formatter):
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    # set utf-8 encoding
    return console_handler


def _get_file_handler(formatter, file_path, backup_count):
    file_handler = TimedRotatingFileHandler(file_path, when="midnight", backupCount=backup_count, encoding='utf-8')
    file_handler.setFormatter(formatter)
    return file_handler

def use_logger(logger_name='echoss'):
    """get parent logger in submodule python script
    :param logger_name: logger name

    :returns: logger of logger_name
    :raises RuntimeError when logger_name is not made
    """
    logger = logging.getLogger(logger_name)

    if logger.hasHandlers():
        return logger
    else:
        raise RuntimeError(f"{logger_name} is not created yet")

def get_logger(logger_name='echoss', logger_format=LOG_FORMAT, file_path=LOG_FILE, backup_count=0,
               use_console=True, level="DEBUG"):
    """
    create new echoss logger or replace old logger
    :param logger_name: logger name
    :param logger_format: logging format
    :param file_path: file path if File logging else None
    :param backup_count: if 0 keep all timed rotating log files, else only keep backup count number of files
    :param use_console: use console output or not
    :param level:  (str or int) set logging level

    :returns: generated logger
    :raises None
    """
    logger = logging.getLogger(logger_name)
    formatter = logging.Formatter(logger_format, datefmt=DATE_FORMAT)
    set_logger_level(logger, level)
    # with this pattern, it's rarely necessary to propagate the error up to parent
    logger.propagate = False

    # make file_path parent directory
    parent_dir = os.path.dirname(file_path)
    if parent_dir:
        os.makedirs(parent_dir, exist_ok=True)

    # Update or add console handler
    has_console_handler = False
    for handler in logger.handlers:
        if not isinstance(handler, TimedRotatingFileHandler) and isinstance(handler, logging.StreamHandler):
            if use_console:
                handler.setFormatter(formatter)
                has_console_handler = True
            else:
                # Remove StreamHandler
                logger.removeHandler(handler)
                handler.close()

    if use_console and not has_console_handler:
        logger.addHandler(_get_console_handler(formatter))

    # Update or add file handler
    file_handler_exists = False
    for handler in logger.handlers:
        if isinstance(handler, TimedRotatingFileHandler):
            # Check if the existing handler path matches the current file_path
            if handler.baseFilename == file_path:
                handler.setFormatter(formatter)
                file_handler_exists = True
            else:
                # Remove the old handler and close it
                logger.removeHandler(handler)
                handler.close()

    if file_path and not file_handler_exists:
        logger.addHandler(_get_file_handler(formatter, file_path, backup_count))

    return logger


def set_logger_level(logger, level):
    """
    :param logger: logger generated by get_logger()
    :param level: string like "DEBUG" or "INFO" or integer logging.DEBUG or logging.INFO
    :return: None
    :raises ValueError or TypeError if level invalid
    """
    if isinstance(level, str):
        level = level.upper()
        numeric_level = getattr(logging, level, None)
        if not isinstance(numeric_level, int):
            raise ValueError(f"Invalid log level: {level}")
    elif isinstance(level, int):
        numeric_level = level
    else:
        raise TypeError("Level must be an integer or string")

    logger.setLevel(numeric_level)


def modify_loggers_by_prefix(prefix, new_format: str=LOG_FORMAT, new_path: str=LOG_FILE,
                             backup_count: int=0, use_console=True, level="DEBUG"):
    """
    Modify loggers that logger name starting with a specific prefix.
    :param prefix: prefix of lgger name
    :param new_format: new logging format
    :param new_path: new file path if File logging else None
    :param backup_count: if 0 keep all timed rotating log files, else only keep backup count number of files
    :param use_console: use console output or not
    :param level: set logging level by level name or level number
    :return: first logger
    :raises None
    """

    # Iterate over all loggers in the logging manager
    is_first = True
    first_logger = None
    for logger_name in logging.Logger.manager.loggerDict.keys():
        if logger_name.startswith(prefix):
            current_logger = get_logger(logger_name, logger_format=new_format, file_path=new_path,
                       backup_count=backup_count, use_console=use_console, level=level)

            if is_first:
                is_first = False
                first_logger = current_logger
            if backup_count != 0:
                backup_count = 0

    return first_logger