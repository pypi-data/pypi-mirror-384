# coding: utf8
#
# Copyright 2023 CS GROUP
# Licensed to CS GROUP (CS) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# CS licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# This file was generated by stubgen-pyx v0.1.1
#
# Type checkers help ensure that you're using variables and functions in your code correctly.
# A stub file is a file containing a skeleton of the public interface of that Python module,
#   including classes, variables, functions - and most importantly, their types.
# For more information, please see:
# https://typing.python.org/en/latest/
# https://mypy.readthedocs.io/en/stable/stubgen.html
# https://github.com/python/mypy/wiki/Creating-Stubs-For-Python-Modules
# flake8: noqa
"""
Module for mathematic routines
"""

from typing import Callable

import numpy as np

RADIANS_SCALING_FACTORS: dict[str, float] = ...
TWO_PI: float = ...

class CoordinatePredictor:
    """
    Coordinates predictors class
    """

    def __init__(self, img_coords_flatten: np.ndarray, xy_coords: np.ndarray): ...
    def predict(self, xy_ground_coords: np.ndarray) -> np.ndarray:
        """computes the matrix positions estimates given ground coordinates"""

    def transform(self): ...

def angular_distance(view_1: np.ndarray, view_2: np.ndarray) -> np.ndarray:
    """
    Compute the angle between two cartesian vectors.

    :param np.ndarray view_1: 2D Array of first vectors in cartesian, shape (N,3)
    :param np.ndarray view_2: 2D Array of second vectors in cartesian, shape (N,3)
    :return: 1D Array of angles (in deg), shape (N,)
    """

def antimeridian_crossing(point1, point2) -> tuple[float, float]:
    """
    Compute the antimeridian crossing between two [lon, lat] points. Coordinates are expected in
    the longitude range [-180.0, +180.0]

    :param point1: first point
    :param point2: second point
    :return: the crossing (longitude, lattitude)
    """

def apply_rotation_on_vector(vec: np.ndarray, axe: np.ndarray, angle: float) -> np.ndarray:
    """
    Apply rotation on a vector via Rodrigues formula in 3D

    :param Vector we want to rotate: np.ndarray
    :param Axe around wich we want to rotate: np.ndarray
    :param Angle of the rotation (in rad): float
    :return: Rotated vector: : np.ndarray
    """

def collapse_siblings(arr: np.ndarray) -> np.ndarray:
    """
    Create a copy of input array (1D) where consecutive identical values are collapsed

    :param arr: input 1D array of "float64" type
    :return: output collapsed array
    """

def expand_siblings(arr: np.ndarray, input_collection) -> list:
    """
    Repeat the element in the input collection when siblings are present in the input array.

    :param arr: Input array (1D) containing siblings
    :param input_collection: Input collection to expand
    :return: Output collection expanded
    """

def extend_circular_lut(positions, values, start=0, end=360) -> tuple[np.ndarray, np.ndarray]:
    """
    Wrap a lookup table so that the range [start, end] is full covered, also ensuring that the LUT
    values at start and end are equal.

    :param positions: input X coordinates of the LUT, 1D, assumed to be sorted increasingly.
    :param values: output Y values of the LUT
    :param int start: minimum X coordinate to cover
    :param int end: maximum X coordinate to cover
    :return: tuple with extended positions and values
    """

def flatten_array(data: np.ndarray, last_dim: int | None = None) -> np.ndarray:
    """
    Reshape an array to flatten it as much as possible. If last_dim is specified, the output shape
    will be (x, last_dim). A check will be made so that the last
    dimension matches on the input array.

    Otherwise, a 1D array is output.

    :param data: input array
    :param last_dim: Freeze last dimension to a given value
    :return: reshaped array
    """

def get_roll_pitch_yaw_EF_axes(position: np.ndarray, velocity: np.ndarray) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
    """
    Returns normalised Earth Fixed axes
    position/velocity of shape (3,) or (3,1)

    :param position of the spacecraft: np.ndarray
    :param velocity of the spacecraft: np.ndarray

    :return: roll/pitch/yaw axes: tuple(np.ndarray,np.ndarray,np.ndarray)
    """

def is_sorted(x: np.ndarray) -> np.bool_:
    """
    O(N) helper function that returns whether a :class:`numpy.ndarray` is sorted.
    """

def numerical_jacobian(direct_mapping: Callable, coords: np.ndarray, epsilon: int = 1) -> np.ndarray:
    """
    The numerical_jacobian function computes the numerical approximation
    of the Jacobian of a given function f.
    The function uses finite differences to compute the Jacobian,
    which means it approximates the derivatives by taking the difference
    between the function's outputs for slightly perturbed inputs (by one).
    The function returns an np.ndarray of shape:

        (x.shape[0], x.shape[1], x.shape[1])

    where the third dimension represents the Jacobian matrix at each input
    point.
    The jacobian array is initialized to a zero array of the required shape,
    then it's iteratively populated by computing the finite differences.

    For each input point x[i, :], the function computes two perturbed input
    points x_plus_epsilon and x_minus_epsilon by adding and subtracting epsilon
    to/from the j-th component of x[i, :], respectively
    [according to the symmetric difference quotient
    (https://en.wikipedia.org/wiki/Symmetric_derivative) which is known
    to be more numerically stable than the ordinary finite difference formula].

    Then, the function evaluates f at both perturbed input points and computes
    the finite differences, which are used to estimate the partial derivative with
    respect to the j-th component of x[i, :].

    Finally, the estimates are stored in the jacobian array.

    :param callable direct_mapping: a function to compute the Jacobian of.
    :param np.ndarray coords:       an np.ndarray of input points for which to compute the Jacobian.
    :param int, optional epsilon: an integer representing the size of the perturbation applied to the input points (as
                                    the input points are integers). Defaults to 1.
    :return: The Jacobian array
    """

def quat_to_matrix(quat) -> np.ndarray:
    """
    Convert quaternion to rotation matrix

    :param quat: quaternion (a, b, c, d) with d the real part
    :return: 3x3 rotation matrix
    """

def reorder_euler_angles(angles: np.ndarray, euler_order: str) -> np.ndarray:
    """
    Re-order rotation angles to match the given order

    :param angles: Array of rotation angles (axes in the order X, Y, Z)
    :param euler_order: Sequence of rotation axes (default is "XYZ")
    """

def restore_array(arr: np.ndarray, shape, last_dim: int | None = None) -> np.ndarray:
    """
    Reshape an array to match the input shape. If last_dim is specified, the new shape is
    ('shape', last_dim).

    :param arr: Array to reshape
    :param shape: Target shape
    :param last_dim: Last dimension to append (optional)
    :return: reshaped array
    """

def rotation_matrix(angle, axis: str) -> np.ndarray:
    """
    Compute a 3x3 rotation matrix of a given angle around the given axis

    :param angle: rotation angle (in radians), both scalar and array types should be supported
    :param axis: Rotation axis ("x"/"y"/"z")
    :return: 3x3 rotation matrix (when angle is scalar). If angle is an (D1, ..., DN) array, the
             output dimensions are (D1, ..., DN, 3, 3)
    """

def slerp(frac: float, quat1, quat2) -> np.ndarray:
    """
    Quaternion SLERP interpolation between 2 quaternions

    :param frac: fraction to interpolate between quat1 and quat2
    :param quat1: first quaternion (size 4)
    :param quat2: second quaternion (size 4)
    :return: interpolated quaternion
    """

def slerp_n(positions: np.ndarray, table: np.ndarray) -> np.ndarray:
    """
    Quaternion SLERP interpolation. For each input position, a SLERP interpolation is computed
    from the table between the two consecutive rows around the input position. Examples:

        - position = 2.4  => quat = SLERP( 0.4, table[2], table[3] )
        - position = -0.2 => quat = SLERP( -0.2, table[0], table[1] )

    :param positions: positions to interpolate in the quaternion table (first axis), 1D array-like
    :param table: quaternion table, 2D array-like, expected shape is (n, 4)
    :return: interpolated quaternions
    """

def slerp_vec(frac: np.ndarray, quat1, quat2) -> np.ndarray:
    """
    Quaternion SLERP interpolation between 2 quaternions

    :param frac: (np.double) fractions to interpolate between quat1 and quat2 (size N)
    :param quat1: (np.double) first quaternions, size (N,4)
    :param quat2: (np.double) second quaternions, size (N,4)
    :return: interpolated quaternions, size (N,4)
    """

def spherical_triangle_height(side_a, side_b, side_c) -> float:
    """
    Compute the height "AX" based at side "a" in a spherical triangle defined from the 3 side angles.

    :param side_a: angle of side a of the triangle (in rad)
    :param side_b: angle of side b of the triangle (in rad)
    :param side_c: angle of side c of the triangle (in rad)
    :return: tuple with triangle height "AX" based at side "a" and angle of side "BX" (in radians)
    """

def vector3d_to_list(v3d) -> list[float]:
    """
    Converts a :class:`org.hipparchus.geometry.euclidean.threed.Vector3D` into an array.
    """
