# coding: utf-8

"""
    The Confluence Cloud REST API

    This document describes the REST API and resources provided by Confluence. The REST APIs are for developers who want to integrate Confluence into their application and for administrators who want to script interactions with the Confluence server.Confluence's REST APIs provide access to resources (data entities) via URI paths. To use a REST API, your application will make an HTTP request and parse the response. The response format is JSON. Your methods will be the standard HTTP methods like GET, PUT, POST and DELETE. Because the REST API is based on open standards, you can use any web development language to access the API.

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBytes, StrictInt, StrictStr, field_validator
from typing import List, Optional, Tuple, Union
from typing_extensions import Annotated
from devopso.clients.confluence_cloud.models.attachment_properties_update_body import AttachmentPropertiesUpdateBody
from devopso.clients.confluence_cloud.models.content import Content
from devopso.clients.confluence_cloud.models.content_array import ContentArray

from devopso.clients.confluence_cloud.api_client import ApiClient, RequestSerialized
from devopso.clients.confluence_cloud.api_response import ApiResponse
from devopso.clients.confluence_cloud.rest import RESTResponseType


class ContentAttachmentsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_attachment(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the content to add the attachment to.")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="The relative location and name of the attachment to be added to the content.")],
        minor_edit: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="If `minorEdits` is set to 'true', no notification email or activity stream will be generated when the attachment is added to the content.")],
        status: Annotated[Optional[StrictStr], Field(description="The status of the content that the attachment is being added to.")] = None,
        comment: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The comment for the attachment that is being added. If you specify a comment, then every file must have a comment and the comments must be in the same order as the files. Alternatively, don't specify any comments.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ContentArray:
        """Create attachment

        Adds an attachment to a piece of content. This method only adds a new attachment. If you want to update an existing attachment, use [Create or update attachments](#api-content-id-child-attachment-put).  Note, you must set a `X-Atlassian-Token: nocheck` header on the request for this method, otherwise it will be blocked. This protects against XSRF attacks, which is necessary as this method accepts multipart/form-data.  The media type 'multipart/form-data' is defined in [RFC 7578](https://www.ietf.org/rfc/rfc7578.txt). Most client libraries have classes that make it easier to implement multipart posts, like the [MultipartEntityBuilder](https://hc.apache.org/httpcomponents-client-5.1.x/current/httpclient5/apidocs/) Java class provided by Apache HTTP Components.  Note, according to [RFC 7578](https://tools.ietf.org/html/rfc7578#section-4.5), in the case where the form data is text, the charset parameter for the \"text/plain\" Content-Type may be used to indicate the character encoding used in that part. In the case of this API endpoint, the `comment` body parameter should be sent with `type=text/plain` and `charset=utf-8` values. This will force the charset to be UTF-8.  Example: This curl command attaches a file ('example.txt') to a container (id='123') with a comment and `minorEdits`=true.  ``` bash curl -D- \\   -u admin:admin \\   -X POST \\   -H 'X-Atlassian-Token: nocheck' \\   -F 'file=@\"example.txt\"' \\   -F 'minorEdit=\"true\"' \\   -F 'comment=\"Example attachment comment\"; type=text/plain; charset=utf-8' \\   https://myhost/wiki/rest/api/content/123/child/attachment ``` **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the content.

        :param id: The ID of the content to add the attachment to. (required)
        :type id: str
        :param file: The relative location and name of the attachment to be added to the content. (required)
        :type file: bytearray
        :param minor_edit: If `minorEdits` is set to 'true', no notification email or activity stream will be generated when the attachment is added to the content. (required)
        :type minor_edit: bytearray
        :param status: The status of the content that the attachment is being added to.
        :type status: str
        :param comment: The comment for the attachment that is being added. If you specify a comment, then every file must have a comment and the comments must be in the same order as the files. Alternatively, don't specify any comments.
        :type comment: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_attachment_serialize(
            id=id,
            file=file,
            minor_edit=minor_edit,
            status=status,
            comment=comment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ContentArray",
            '400': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_attachment_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the content to add the attachment to.")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="The relative location and name of the attachment to be added to the content.")],
        minor_edit: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="If `minorEdits` is set to 'true', no notification email or activity stream will be generated when the attachment is added to the content.")],
        status: Annotated[Optional[StrictStr], Field(description="The status of the content that the attachment is being added to.")] = None,
        comment: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The comment for the attachment that is being added. If you specify a comment, then every file must have a comment and the comments must be in the same order as the files. Alternatively, don't specify any comments.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ContentArray]:
        """Create attachment

        Adds an attachment to a piece of content. This method only adds a new attachment. If you want to update an existing attachment, use [Create or update attachments](#api-content-id-child-attachment-put).  Note, you must set a `X-Atlassian-Token: nocheck` header on the request for this method, otherwise it will be blocked. This protects against XSRF attacks, which is necessary as this method accepts multipart/form-data.  The media type 'multipart/form-data' is defined in [RFC 7578](https://www.ietf.org/rfc/rfc7578.txt). Most client libraries have classes that make it easier to implement multipart posts, like the [MultipartEntityBuilder](https://hc.apache.org/httpcomponents-client-5.1.x/current/httpclient5/apidocs/) Java class provided by Apache HTTP Components.  Note, according to [RFC 7578](https://tools.ietf.org/html/rfc7578#section-4.5), in the case where the form data is text, the charset parameter for the \"text/plain\" Content-Type may be used to indicate the character encoding used in that part. In the case of this API endpoint, the `comment` body parameter should be sent with `type=text/plain` and `charset=utf-8` values. This will force the charset to be UTF-8.  Example: This curl command attaches a file ('example.txt') to a container (id='123') with a comment and `minorEdits`=true.  ``` bash curl -D- \\   -u admin:admin \\   -X POST \\   -H 'X-Atlassian-Token: nocheck' \\   -F 'file=@\"example.txt\"' \\   -F 'minorEdit=\"true\"' \\   -F 'comment=\"Example attachment comment\"; type=text/plain; charset=utf-8' \\   https://myhost/wiki/rest/api/content/123/child/attachment ``` **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the content.

        :param id: The ID of the content to add the attachment to. (required)
        :type id: str
        :param file: The relative location and name of the attachment to be added to the content. (required)
        :type file: bytearray
        :param minor_edit: If `minorEdits` is set to 'true', no notification email or activity stream will be generated when the attachment is added to the content. (required)
        :type minor_edit: bytearray
        :param status: The status of the content that the attachment is being added to.
        :type status: str
        :param comment: The comment for the attachment that is being added. If you specify a comment, then every file must have a comment and the comments must be in the same order as the files. Alternatively, don't specify any comments.
        :type comment: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_attachment_serialize(
            id=id,
            file=file,
            minor_edit=minor_edit,
            status=status,
            comment=comment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ContentArray",
            '400': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_attachment_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the content to add the attachment to.")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="The relative location and name of the attachment to be added to the content.")],
        minor_edit: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="If `minorEdits` is set to 'true', no notification email or activity stream will be generated when the attachment is added to the content.")],
        status: Annotated[Optional[StrictStr], Field(description="The status of the content that the attachment is being added to.")] = None,
        comment: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The comment for the attachment that is being added. If you specify a comment, then every file must have a comment and the comments must be in the same order as the files. Alternatively, don't specify any comments.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create attachment

        Adds an attachment to a piece of content. This method only adds a new attachment. If you want to update an existing attachment, use [Create or update attachments](#api-content-id-child-attachment-put).  Note, you must set a `X-Atlassian-Token: nocheck` header on the request for this method, otherwise it will be blocked. This protects against XSRF attacks, which is necessary as this method accepts multipart/form-data.  The media type 'multipart/form-data' is defined in [RFC 7578](https://www.ietf.org/rfc/rfc7578.txt). Most client libraries have classes that make it easier to implement multipart posts, like the [MultipartEntityBuilder](https://hc.apache.org/httpcomponents-client-5.1.x/current/httpclient5/apidocs/) Java class provided by Apache HTTP Components.  Note, according to [RFC 7578](https://tools.ietf.org/html/rfc7578#section-4.5), in the case where the form data is text, the charset parameter for the \"text/plain\" Content-Type may be used to indicate the character encoding used in that part. In the case of this API endpoint, the `comment` body parameter should be sent with `type=text/plain` and `charset=utf-8` values. This will force the charset to be UTF-8.  Example: This curl command attaches a file ('example.txt') to a container (id='123') with a comment and `minorEdits`=true.  ``` bash curl -D- \\   -u admin:admin \\   -X POST \\   -H 'X-Atlassian-Token: nocheck' \\   -F 'file=@\"example.txt\"' \\   -F 'minorEdit=\"true\"' \\   -F 'comment=\"Example attachment comment\"; type=text/plain; charset=utf-8' \\   https://myhost/wiki/rest/api/content/123/child/attachment ``` **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the content.

        :param id: The ID of the content to add the attachment to. (required)
        :type id: str
        :param file: The relative location and name of the attachment to be added to the content. (required)
        :type file: bytearray
        :param minor_edit: If `minorEdits` is set to 'true', no notification email or activity stream will be generated when the attachment is added to the content. (required)
        :type minor_edit: bytearray
        :param status: The status of the content that the attachment is being added to.
        :type status: str
        :param comment: The comment for the attachment that is being added. If you specify a comment, then every file must have a comment and the comments must be in the same order as the files. Alternatively, don't specify any comments.
        :type comment: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_attachment_serialize(
            id=id,
            file=file,
            minor_edit=minor_edit,
            status=status,
            comment=comment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ContentArray",
            '400': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_attachment_serialize(
        self,
        id,
        file,
        minor_edit,
        status,
        comment,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if status is not None:
            
            _query_params.append(('status', status))
            
        # process the header parameters
        # process the form parameters
        if file is not None:
            _files['file'] = file
        if comment is not None:
            _files['comment'] = comment
        if minor_edit is not None:
            _files['minorEdit'] = minor_edit
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oAuthDefinitions'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/wiki/rest/api/content/{id}/child/attachment',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_or_update_attachments(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the content to add the attachment to.")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="The relative location and name of the attachment to be added to the content.")],
        minor_edit: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="If `minorEdits` is set to 'true', no notification email or activity stream will be generated when the attachment is added to the content.")],
        status: Annotated[Optional[StrictStr], Field(description="The status of the content that the attachment is being added to. This should always be set to 'current'.")] = None,
        comment: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The comment for the attachment that is being added. If you specify a comment, then every file must have a comment and the comments must be in the same order as the files. Alternatively, don't specify any comments.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ContentArray:
        """Create or update attachment

        Adds an attachment to a piece of content. If the attachment already exists for the content, then the attachment is updated (i.e. a new version of the attachment is created).  Note, you must set a `X-Atlassian-Token: nocheck` header on the request for this method, otherwise it will be blocked. This protects against XSRF attacks, which is necessary as this method accepts multipart/form-data.  The media type 'multipart/form-data' is defined in [RFC 7578](https://www.ietf.org/rfc/rfc7578.txt). Most client libraries have classes that make it easier to implement multipart posts, like the [MultipartEntityBuilder](https://hc.apache.org/httpcomponents-client-5.1.x/current/httpclient5/apidocs/) Java class provided by Apache HTTP Components.  Note, according to [RFC 7578](https://tools.ietf.org/html/rfc7578#section-4.5), in the case where the form data is text, the charset parameter for the \"text/plain\" Content-Type may be used to indicate the character encoding used in that part. In the case of this API endpoint, the `comment` body parameter should be sent with `type=text/plain` and `charset=utf-8` values. This will force the charset to be UTF-8.  Example: This curl command attaches a file ('example.txt') to a piece of content (id='123') with a comment and `minorEdits`=true. If the 'example.txt' file already exists, it will update it with a new version of the attachment.  ``` bash curl -D- \\   -u admin:admin \\   -X PUT \\   -H 'X-Atlassian-Token: nocheck' \\   -F 'file=@\"example.txt\"' \\   -F 'minorEdit=\"true\"' \\   -F 'comment=\"Example attachment comment\"; type=text/plain; charset=utf-8' \\   http://myhost/rest/api/content/123/child/attachment ``` **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the content.

        :param id: The ID of the content to add the attachment to. (required)
        :type id: str
        :param file: The relative location and name of the attachment to be added to the content. (required)
        :type file: bytearray
        :param minor_edit: If `minorEdits` is set to 'true', no notification email or activity stream will be generated when the attachment is added to the content. (required)
        :type minor_edit: bytearray
        :param status: The status of the content that the attachment is being added to. This should always be set to 'current'.
        :type status: str
        :param comment: The comment for the attachment that is being added. If you specify a comment, then every file must have a comment and the comments must be in the same order as the files. Alternatively, don't specify any comments.
        :type comment: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_or_update_attachments_serialize(
            id=id,
            file=file,
            minor_edit=minor_edit,
            status=status,
            comment=comment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ContentArray",
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_or_update_attachments_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the content to add the attachment to.")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="The relative location and name of the attachment to be added to the content.")],
        minor_edit: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="If `minorEdits` is set to 'true', no notification email or activity stream will be generated when the attachment is added to the content.")],
        status: Annotated[Optional[StrictStr], Field(description="The status of the content that the attachment is being added to. This should always be set to 'current'.")] = None,
        comment: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The comment for the attachment that is being added. If you specify a comment, then every file must have a comment and the comments must be in the same order as the files. Alternatively, don't specify any comments.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ContentArray]:
        """Create or update attachment

        Adds an attachment to a piece of content. If the attachment already exists for the content, then the attachment is updated (i.e. a new version of the attachment is created).  Note, you must set a `X-Atlassian-Token: nocheck` header on the request for this method, otherwise it will be blocked. This protects against XSRF attacks, which is necessary as this method accepts multipart/form-data.  The media type 'multipart/form-data' is defined in [RFC 7578](https://www.ietf.org/rfc/rfc7578.txt). Most client libraries have classes that make it easier to implement multipart posts, like the [MultipartEntityBuilder](https://hc.apache.org/httpcomponents-client-5.1.x/current/httpclient5/apidocs/) Java class provided by Apache HTTP Components.  Note, according to [RFC 7578](https://tools.ietf.org/html/rfc7578#section-4.5), in the case where the form data is text, the charset parameter for the \"text/plain\" Content-Type may be used to indicate the character encoding used in that part. In the case of this API endpoint, the `comment` body parameter should be sent with `type=text/plain` and `charset=utf-8` values. This will force the charset to be UTF-8.  Example: This curl command attaches a file ('example.txt') to a piece of content (id='123') with a comment and `minorEdits`=true. If the 'example.txt' file already exists, it will update it with a new version of the attachment.  ``` bash curl -D- \\   -u admin:admin \\   -X PUT \\   -H 'X-Atlassian-Token: nocheck' \\   -F 'file=@\"example.txt\"' \\   -F 'minorEdit=\"true\"' \\   -F 'comment=\"Example attachment comment\"; type=text/plain; charset=utf-8' \\   http://myhost/rest/api/content/123/child/attachment ``` **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the content.

        :param id: The ID of the content to add the attachment to. (required)
        :type id: str
        :param file: The relative location and name of the attachment to be added to the content. (required)
        :type file: bytearray
        :param minor_edit: If `minorEdits` is set to 'true', no notification email or activity stream will be generated when the attachment is added to the content. (required)
        :type minor_edit: bytearray
        :param status: The status of the content that the attachment is being added to. This should always be set to 'current'.
        :type status: str
        :param comment: The comment for the attachment that is being added. If you specify a comment, then every file must have a comment and the comments must be in the same order as the files. Alternatively, don't specify any comments.
        :type comment: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_or_update_attachments_serialize(
            id=id,
            file=file,
            minor_edit=minor_edit,
            status=status,
            comment=comment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ContentArray",
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_or_update_attachments_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the content to add the attachment to.")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="The relative location and name of the attachment to be added to the content.")],
        minor_edit: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="If `minorEdits` is set to 'true', no notification email or activity stream will be generated when the attachment is added to the content.")],
        status: Annotated[Optional[StrictStr], Field(description="The status of the content that the attachment is being added to. This should always be set to 'current'.")] = None,
        comment: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The comment for the attachment that is being added. If you specify a comment, then every file must have a comment and the comments must be in the same order as the files. Alternatively, don't specify any comments.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create or update attachment

        Adds an attachment to a piece of content. If the attachment already exists for the content, then the attachment is updated (i.e. a new version of the attachment is created).  Note, you must set a `X-Atlassian-Token: nocheck` header on the request for this method, otherwise it will be blocked. This protects against XSRF attacks, which is necessary as this method accepts multipart/form-data.  The media type 'multipart/form-data' is defined in [RFC 7578](https://www.ietf.org/rfc/rfc7578.txt). Most client libraries have classes that make it easier to implement multipart posts, like the [MultipartEntityBuilder](https://hc.apache.org/httpcomponents-client-5.1.x/current/httpclient5/apidocs/) Java class provided by Apache HTTP Components.  Note, according to [RFC 7578](https://tools.ietf.org/html/rfc7578#section-4.5), in the case where the form data is text, the charset parameter for the \"text/plain\" Content-Type may be used to indicate the character encoding used in that part. In the case of this API endpoint, the `comment` body parameter should be sent with `type=text/plain` and `charset=utf-8` values. This will force the charset to be UTF-8.  Example: This curl command attaches a file ('example.txt') to a piece of content (id='123') with a comment and `minorEdits`=true. If the 'example.txt' file already exists, it will update it with a new version of the attachment.  ``` bash curl -D- \\   -u admin:admin \\   -X PUT \\   -H 'X-Atlassian-Token: nocheck' \\   -F 'file=@\"example.txt\"' \\   -F 'minorEdit=\"true\"' \\   -F 'comment=\"Example attachment comment\"; type=text/plain; charset=utf-8' \\   http://myhost/rest/api/content/123/child/attachment ``` **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the content.

        :param id: The ID of the content to add the attachment to. (required)
        :type id: str
        :param file: The relative location and name of the attachment to be added to the content. (required)
        :type file: bytearray
        :param minor_edit: If `minorEdits` is set to 'true', no notification email or activity stream will be generated when the attachment is added to the content. (required)
        :type minor_edit: bytearray
        :param status: The status of the content that the attachment is being added to. This should always be set to 'current'.
        :type status: str
        :param comment: The comment for the attachment that is being added. If you specify a comment, then every file must have a comment and the comments must be in the same order as the files. Alternatively, don't specify any comments.
        :type comment: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_or_update_attachments_serialize(
            id=id,
            file=file,
            minor_edit=minor_edit,
            status=status,
            comment=comment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ContentArray",
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_or_update_attachments_serialize(
        self,
        id,
        file,
        minor_edit,
        status,
        comment,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if status is not None:
            
            _query_params.append(('status', status))
            
        # process the header parameters
        # process the form parameters
        if file is not None:
            _files['file'] = file
        if comment is not None:
            _files['comment'] = comment
        if minor_edit is not None:
            _files['minorEdit'] = minor_edit
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oAuthDefinitions'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/wiki/rest/api/content/{id}/child/attachment',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def download_attatchment(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the content that the attachment is attached to.")],
        attachment_id: Annotated[StrictStr, Field(description="The ID of the attachment to download.")],
        version: Annotated[Optional[StrictInt], Field(description="The version of the attachment. If this parameter is absent, the redirect URI will download the latest version of the attachment.")] = None,
        status: Annotated[Optional[List[StrictStr]], Field(description="The statuses allowed on the retrieved attachment. If this parameter is absent, it will default to `current`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Get URI to download attachment

        Redirects the client to a URL that serves an attachment's binary data.

        :param id: The ID of the content that the attachment is attached to. (required)
        :type id: str
        :param attachment_id: The ID of the attachment to download. (required)
        :type attachment_id: str
        :param version: The version of the attachment. If this parameter is absent, the redirect URI will download the latest version of the attachment.
        :type version: int
        :param status: The statuses allowed on the retrieved attachment. If this parameter is absent, it will default to `current`.
        :type status: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._download_attatchment_serialize(
            id=id,
            attachment_id=attachment_id,
            version=version,
            status=status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '302': None,
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def download_attatchment_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the content that the attachment is attached to.")],
        attachment_id: Annotated[StrictStr, Field(description="The ID of the attachment to download.")],
        version: Annotated[Optional[StrictInt], Field(description="The version of the attachment. If this parameter is absent, the redirect URI will download the latest version of the attachment.")] = None,
        status: Annotated[Optional[List[StrictStr]], Field(description="The statuses allowed on the retrieved attachment. If this parameter is absent, it will default to `current`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Get URI to download attachment

        Redirects the client to a URL that serves an attachment's binary data.

        :param id: The ID of the content that the attachment is attached to. (required)
        :type id: str
        :param attachment_id: The ID of the attachment to download. (required)
        :type attachment_id: str
        :param version: The version of the attachment. If this parameter is absent, the redirect URI will download the latest version of the attachment.
        :type version: int
        :param status: The statuses allowed on the retrieved attachment. If this parameter is absent, it will default to `current`.
        :type status: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._download_attatchment_serialize(
            id=id,
            attachment_id=attachment_id,
            version=version,
            status=status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '302': None,
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def download_attatchment_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the content that the attachment is attached to.")],
        attachment_id: Annotated[StrictStr, Field(description="The ID of the attachment to download.")],
        version: Annotated[Optional[StrictInt], Field(description="The version of the attachment. If this parameter is absent, the redirect URI will download the latest version of the attachment.")] = None,
        status: Annotated[Optional[List[StrictStr]], Field(description="The statuses allowed on the retrieved attachment. If this parameter is absent, it will default to `current`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get URI to download attachment

        Redirects the client to a URL that serves an attachment's binary data.

        :param id: The ID of the content that the attachment is attached to. (required)
        :type id: str
        :param attachment_id: The ID of the attachment to download. (required)
        :type attachment_id: str
        :param version: The version of the attachment. If this parameter is absent, the redirect URI will download the latest version of the attachment.
        :type version: int
        :param status: The statuses allowed on the retrieved attachment. If this parameter is absent, it will default to `current`.
        :type status: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._download_attatchment_serialize(
            id=id,
            attachment_id=attachment_id,
            version=version,
            status=status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '302': None,
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _download_attatchment_serialize(
        self,
        id,
        attachment_id,
        version,
        status,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'status': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        if attachment_id is not None:
            _path_params['attachmentId'] = attachment_id
        # process the query parameters
        if version is not None:
            
            _query_params.append(('version', version))
            
        if status is not None:
            
            _query_params.append(('status', status))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oAuthDefinitions'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/wiki/rest/api/content/{id}/child/attachment/{attachmentId}/download',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_attachment_data(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the content that the attachment is attached to.")],
        attachment_id: Annotated[StrictStr, Field(description="The ID of the attachment to update.")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="The relative location and name of the attachment to be added to the content.")],
        minor_edit: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="If `minorEdits` is set to 'true', no notification email or activity stream will be generated when the attachment is added to the content.")],
        comment: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The comment for the attachment that is being added. If you specify a comment, then every file must have a comment and the comments must be in the same order as the files. Alternatively, don't specify any comments.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Content:
        """Update attachment data

        Updates the binary data of an attachment, given the attachment ID, and optionally the comment and the minor edit field.  This method is essentially the same as [Create or update attachments](#api-content-id-child-attachment-put), except that it matches the attachment ID rather than the name.  Note, you must set a `X-Atlassian-Token: nocheck` header on the request for this method, otherwise it will be blocked. This protects against XSRF attacks, which is necessary as this method accepts multipart/form-data.  The media type 'multipart/form-data' is defined in [RFC 7578](https://www.ietf.org/rfc/rfc7578.txt). Most client libraries have classes that make it easier to implement multipart posts, like the [MultipartEntityBuilder](https://hc.apache.org/httpcomponents-client-5.1.x/current/httpclient5/apidocs/) Java class provided by Apache HTTP Components.  Note, according to [RFC 7578](https://tools.ietf.org/html/rfc7578#section-4.5), in the case where the form data is text, the charset parameter for the \"text/plain\" Content-Type may be used to indicate the character encoding used in that part. In the case of this API endpoint, the `comment` body parameter should be sent with `type=text/plain` and `charset=utf-8` values. This will force the charset to be UTF-8.  Example: This curl command updates an attachment (id='att456') that is attached to a piece of content (id='123') with a comment and `minorEdits`=true.  ``` bash curl -D- \\   -u admin:admin \\   -X POST \\   -H 'X-Atlassian-Token: nocheck' \\   -F 'file=@\"example.txt\"' \\   -F 'minorEdit=\"true\"' \\   -F 'comment=\"Example attachment comment\"; type=text/plain; charset=utf-8' \\   http://myhost/rest/api/content/123/child/attachment/att456/data ``` **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the content.

        :param id: The ID of the content that the attachment is attached to. (required)
        :type id: str
        :param attachment_id: The ID of the attachment to update. (required)
        :type attachment_id: str
        :param file: The relative location and name of the attachment to be added to the content. (required)
        :type file: bytearray
        :param minor_edit: If `minorEdits` is set to 'true', no notification email or activity stream will be generated when the attachment is added to the content. (required)
        :type minor_edit: bytearray
        :param comment: The comment for the attachment that is being added. If you specify a comment, then every file must have a comment and the comments must be in the same order as the files. Alternatively, don't specify any comments.
        :type comment: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_attachment_data_serialize(
            id=id,
            attachment_id=attachment_id,
            file=file,
            minor_edit=minor_edit,
            comment=comment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Content",
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_attachment_data_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the content that the attachment is attached to.")],
        attachment_id: Annotated[StrictStr, Field(description="The ID of the attachment to update.")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="The relative location and name of the attachment to be added to the content.")],
        minor_edit: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="If `minorEdits` is set to 'true', no notification email or activity stream will be generated when the attachment is added to the content.")],
        comment: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The comment for the attachment that is being added. If you specify a comment, then every file must have a comment and the comments must be in the same order as the files. Alternatively, don't specify any comments.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Content]:
        """Update attachment data

        Updates the binary data of an attachment, given the attachment ID, and optionally the comment and the minor edit field.  This method is essentially the same as [Create or update attachments](#api-content-id-child-attachment-put), except that it matches the attachment ID rather than the name.  Note, you must set a `X-Atlassian-Token: nocheck` header on the request for this method, otherwise it will be blocked. This protects against XSRF attacks, which is necessary as this method accepts multipart/form-data.  The media type 'multipart/form-data' is defined in [RFC 7578](https://www.ietf.org/rfc/rfc7578.txt). Most client libraries have classes that make it easier to implement multipart posts, like the [MultipartEntityBuilder](https://hc.apache.org/httpcomponents-client-5.1.x/current/httpclient5/apidocs/) Java class provided by Apache HTTP Components.  Note, according to [RFC 7578](https://tools.ietf.org/html/rfc7578#section-4.5), in the case where the form data is text, the charset parameter for the \"text/plain\" Content-Type may be used to indicate the character encoding used in that part. In the case of this API endpoint, the `comment` body parameter should be sent with `type=text/plain` and `charset=utf-8` values. This will force the charset to be UTF-8.  Example: This curl command updates an attachment (id='att456') that is attached to a piece of content (id='123') with a comment and `minorEdits`=true.  ``` bash curl -D- \\   -u admin:admin \\   -X POST \\   -H 'X-Atlassian-Token: nocheck' \\   -F 'file=@\"example.txt\"' \\   -F 'minorEdit=\"true\"' \\   -F 'comment=\"Example attachment comment\"; type=text/plain; charset=utf-8' \\   http://myhost/rest/api/content/123/child/attachment/att456/data ``` **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the content.

        :param id: The ID of the content that the attachment is attached to. (required)
        :type id: str
        :param attachment_id: The ID of the attachment to update. (required)
        :type attachment_id: str
        :param file: The relative location and name of the attachment to be added to the content. (required)
        :type file: bytearray
        :param minor_edit: If `minorEdits` is set to 'true', no notification email or activity stream will be generated when the attachment is added to the content. (required)
        :type minor_edit: bytearray
        :param comment: The comment for the attachment that is being added. If you specify a comment, then every file must have a comment and the comments must be in the same order as the files. Alternatively, don't specify any comments.
        :type comment: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_attachment_data_serialize(
            id=id,
            attachment_id=attachment_id,
            file=file,
            minor_edit=minor_edit,
            comment=comment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Content",
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_attachment_data_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the content that the attachment is attached to.")],
        attachment_id: Annotated[StrictStr, Field(description="The ID of the attachment to update.")],
        file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="The relative location and name of the attachment to be added to the content.")],
        minor_edit: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="If `minorEdits` is set to 'true', no notification email or activity stream will be generated when the attachment is added to the content.")],
        comment: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The comment for the attachment that is being added. If you specify a comment, then every file must have a comment and the comments must be in the same order as the files. Alternatively, don't specify any comments.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update attachment data

        Updates the binary data of an attachment, given the attachment ID, and optionally the comment and the minor edit field.  This method is essentially the same as [Create or update attachments](#api-content-id-child-attachment-put), except that it matches the attachment ID rather than the name.  Note, you must set a `X-Atlassian-Token: nocheck` header on the request for this method, otherwise it will be blocked. This protects against XSRF attacks, which is necessary as this method accepts multipart/form-data.  The media type 'multipart/form-data' is defined in [RFC 7578](https://www.ietf.org/rfc/rfc7578.txt). Most client libraries have classes that make it easier to implement multipart posts, like the [MultipartEntityBuilder](https://hc.apache.org/httpcomponents-client-5.1.x/current/httpclient5/apidocs/) Java class provided by Apache HTTP Components.  Note, according to [RFC 7578](https://tools.ietf.org/html/rfc7578#section-4.5), in the case where the form data is text, the charset parameter for the \"text/plain\" Content-Type may be used to indicate the character encoding used in that part. In the case of this API endpoint, the `comment` body parameter should be sent with `type=text/plain` and `charset=utf-8` values. This will force the charset to be UTF-8.  Example: This curl command updates an attachment (id='att456') that is attached to a piece of content (id='123') with a comment and `minorEdits`=true.  ``` bash curl -D- \\   -u admin:admin \\   -X POST \\   -H 'X-Atlassian-Token: nocheck' \\   -F 'file=@\"example.txt\"' \\   -F 'minorEdit=\"true\"' \\   -F 'comment=\"Example attachment comment\"; type=text/plain; charset=utf-8' \\   http://myhost/rest/api/content/123/child/attachment/att456/data ``` **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the content.

        :param id: The ID of the content that the attachment is attached to. (required)
        :type id: str
        :param attachment_id: The ID of the attachment to update. (required)
        :type attachment_id: str
        :param file: The relative location and name of the attachment to be added to the content. (required)
        :type file: bytearray
        :param minor_edit: If `minorEdits` is set to 'true', no notification email or activity stream will be generated when the attachment is added to the content. (required)
        :type minor_edit: bytearray
        :param comment: The comment for the attachment that is being added. If you specify a comment, then every file must have a comment and the comments must be in the same order as the files. Alternatively, don't specify any comments.
        :type comment: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_attachment_data_serialize(
            id=id,
            attachment_id=attachment_id,
            file=file,
            minor_edit=minor_edit,
            comment=comment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Content",
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_attachment_data_serialize(
        self,
        id,
        attachment_id,
        file,
        minor_edit,
        comment,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        if attachment_id is not None:
            _path_params['attachmentId'] = attachment_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if file is not None:
            _files['file'] = file
        if comment is not None:
            _files['comment'] = comment
        if minor_edit is not None:
            _files['minorEdit'] = minor_edit
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oAuthDefinitions'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/wiki/rest/api/content/{id}/child/attachment/{attachmentId}/data',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_attachment_properties(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the content that the attachment is attached to.")],
        attachment_id: Annotated[StrictStr, Field(description="The ID of the attachment to update.")],
        body: Annotated[AttachmentPropertiesUpdateBody, Field(description="The details of the attachment to be updated.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Content:
        """Update attachment properties

        Updates the attachment properties, i.e. the non-binary data of an attachment like the filename, media-type, comment, and parent container.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the content.

        :param id: The ID of the content that the attachment is attached to. (required)
        :type id: str
        :param attachment_id: The ID of the attachment to update. (required)
        :type attachment_id: str
        :param body: The details of the attachment to be updated. (required)
        :type body: AttachmentPropertiesUpdateBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_attachment_properties_serialize(
            id=id,
            attachment_id=attachment_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Content",
            '400': None,
            '403': None,
            '404': None,
            '409': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_attachment_properties_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the content that the attachment is attached to.")],
        attachment_id: Annotated[StrictStr, Field(description="The ID of the attachment to update.")],
        body: Annotated[AttachmentPropertiesUpdateBody, Field(description="The details of the attachment to be updated.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Content]:
        """Update attachment properties

        Updates the attachment properties, i.e. the non-binary data of an attachment like the filename, media-type, comment, and parent container.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the content.

        :param id: The ID of the content that the attachment is attached to. (required)
        :type id: str
        :param attachment_id: The ID of the attachment to update. (required)
        :type attachment_id: str
        :param body: The details of the attachment to be updated. (required)
        :type body: AttachmentPropertiesUpdateBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_attachment_properties_serialize(
            id=id,
            attachment_id=attachment_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Content",
            '400': None,
            '403': None,
            '404': None,
            '409': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_attachment_properties_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="The ID of the content that the attachment is attached to.")],
        attachment_id: Annotated[StrictStr, Field(description="The ID of the attachment to update.")],
        body: Annotated[AttachmentPropertiesUpdateBody, Field(description="The details of the attachment to be updated.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update attachment properties

        Updates the attachment properties, i.e. the non-binary data of an attachment like the filename, media-type, comment, and parent container.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the content.

        :param id: The ID of the content that the attachment is attached to. (required)
        :type id: str
        :param attachment_id: The ID of the attachment to update. (required)
        :type attachment_id: str
        :param body: The details of the attachment to be updated. (required)
        :type body: AttachmentPropertiesUpdateBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_attachment_properties_serialize(
            id=id,
            attachment_id=attachment_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Content",
            '400': None,
            '403': None,
            '404': None,
            '409': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_attachment_properties_serialize(
        self,
        id,
        attachment_id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        if attachment_id is not None:
            _path_params['attachmentId'] = attachment_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oAuthDefinitions'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/wiki/rest/api/content/{id}/child/attachment/{attachmentId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


