# coding: utf-8

"""
    The Confluence Cloud REST API

    This document describes the REST API and resources provided by Confluence. The REST APIs are for developers who want to integrate Confluence into their application and for administrators who want to script interactions with the Confluence server.Confluence's REST APIs provide access to resources (data entities) via URI paths. To use a REST API, your application will make an HTTP request and parse the response. The response format is JSON. Your methods will be the standard HTTP methods like GET, PUT, POST and DELETE. Because the REST API is based on open standards, you can use any web development language to access the API.

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from devopso.clients.confluence_cloud.models.content_body_create import ContentBodyCreate
from typing import Optional, Set
from typing_extensions import Self

class ContentBodyConversionInput(BaseModel):
    """
    ContentBodyConversionInput
    """ # noqa: E501
    to: StrictStr = Field(description="The name of the target format for the content body conversion.")
    allow_cache: Optional[StrictBool] = Field(default=False, description="If `false`, the cache will erase its current value and begin a new conversion. If `true`, the cache will not erase its current value, and will set the status of the async conversion to “RERUNNING”. Once the data is updated, the status will change to “COMPLETED”. Large macros that take a long time to convert and that need not be immediately up to date (e.g. a macro in which the new conversion result is the same as a previous conversion result that was completed within the last 5 minutes) should set this field to `true`. Cache values are stored per user per content body and expansions.", alias="allowCache")
    space_key_context: Optional[StrictStr] = Field(default=None, description="The space key used for resolving embedded content (page includes, files, and links) in the content body. For example, if the source content contains the link `<ac:link><ri:page ri:content-title=\"Example page\" /><ac:link>` and the `spaceKeyContext=TEST` parameter is provided, then the link will be converted into a link to the \"Example page\" page in the \"TEST\" space.", alias="spaceKeyContext")
    content_id_context: Optional[StrictStr] = Field(default=None, description="The content ID used to find the space for resolving embedded content (page includes, files, and links) in the content body. For example, if the source content contains the link `<ac:link><ri:page ri:content-title=\"Example page\" /><ac:link>` and the `contentIdContext=123` parameter is provided, then the link will be converted into a link to the \"Example page\" page in the same space that has the content with ID=123. Note that `spaceKeyContext` will be ignored if this parameter is provided.", alias="contentIdContext")
    embedded_content_render: Optional[StrictStr] = Field(default='current', description="Mode used for rendering embedded content, such as attachments. - `current` renders the embedded content using the latest version. - `version-at-save` renders the embedded content using the version at the time of save.", alias="embeddedContentRender")
    expand: Optional[List[StrictStr]] = Field(default=None, description="A multi-value, comma-separated parameter indicating which properties of the content to expand and populate. Expands are dependent on the `to` conversion format and may be irrelevant for certain conversions (e.g. `macroRenderedOutput` is redundant when converting to `view` format).   If rendering to `view` format, and the body content being converted includes arbitrary nested content (such as macros); then it is  necessary to include webresource expands in the request. Webresources for content body are the batched JS and CSS dependencies for any nested dynamic content (i.e. macros).  - `embeddedContent` returns metadata for nested content (e.g. page included using page include macro) - `mediaToken` returns JWT token for retrieving attachment data from Media API - `macroRenderedOutput` additionally converts body to view format - `webresource.superbatch.uris.js` returns all common JS dependencies as static URLs - `webresource.superbatch.uris.css` returns all common CSS dependencies as static URLs - `webresource.superbatch.uris.all` returns all common dependencies as static URLs - `webresource.superbatch.tags.all` returns all common JS dependencies as html `<script>` tags - `webresource.superbatch.tags.css` returns all common CSS dependencies as html `<style>` tags - `webresource.superbatch.tags.js` returns all common dependencies as html `<script>` and `<style>` tags - `webresource.uris.js` returns JS dependencies specific to conversion - `webresource.uris.css` returns CSS dependencies specific to conversion - `webresource.uris.all` returns all dependencies specific to conversion      - `webresource.tags.all` returns common JS dependencies as html `<script>` tags - `webresource.tags.css` returns common CSS dependencies as html `<style>` tags - `webresource.tags.js` returns common dependencies as html `<script>` and `<style>` tags")
    body: ContentBodyCreate
    __properties: ClassVar[List[str]] = ["to", "allowCache", "spaceKeyContext", "contentIdContext", "embeddedContentRender", "expand", "body"]

    @field_validator('embedded_content_render')
    def embedded_content_render_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['current', 'version-at-save']):
            raise ValueError("must be one of enum values ('current', 'version-at-save')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ContentBodyConversionInput from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of body
        if self.body:
            _dict['body'] = self.body.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ContentBodyConversionInput from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "to": obj.get("to"),
            "allowCache": obj.get("allowCache") if obj.get("allowCache") is not None else False,
            "spaceKeyContext": obj.get("spaceKeyContext"),
            "contentIdContext": obj.get("contentIdContext"),
            "embeddedContentRender": obj.get("embeddedContentRender") if obj.get("embeddedContentRender") is not None else 'current',
            "expand": obj.get("expand"),
            "body": ContentBodyCreate.from_dict(obj["body"]) if obj.get("body") is not None else None
        })
        return _obj


