"""This module provides the helper functions used to work with date and time data."""

from enum import StrEnum
from typing import Any
import datetime

import numpy as np
from numpy.typing import NDArray
from ataraxis_base_utilities import console

# The number of parts in a valid Date and Time (DT) string generated by this module.
_DT_STRING_PARTS = 7


class TimeUnits(StrEnum):
    """Stores the time units supported by the convert_time() function.

    Use this enumeration to specify the source and destination time units when calling the conversion function.
    """

    NANOSECOND = "ns"
    MICROSECOND = "us"
    MILLISECOND = "ms"
    SECOND = "s"
    MINUTE = "m"
    HOUR = "h"
    DAY = "d"


class TimestampFormats(StrEnum):
    """Stores the timestamp formats supported by the get_timestamp() and the convert_timestamp() functions.

    Use this enumeration when generating or converting timestamps.
    """

    STRING = "str"
    """A delimited date-and-time string. The timestamp is stored in the 'YYYY-MM-DD-HH-MM-SS-ssssss' format and uses 
    UTC timezone."""
    BYTES = "byte"
    """A NumPy byte array. The timestamp is stored as a 64-bit unsigned integer serialized using little endian scheme 
    that represents the number of microseconds elapsed since the UTC epoch onset."""
    INTEGER = "int"
    """The integer that represents the number of microseconds elapsed since the UTC epoch onset."""


def convert_time(
    time: float | np.integer[Any] | np.floating[Any],
    from_units: str | TimeUnits,
    to_units: str | TimeUnits,
    *,
    as_float: bool = False,
) -> float | np.float64:
    """Converts the input time value from the original units to the requested units.

    Notes:
        By default, this function returns the converted time value as a NumPy 64-bit floating scalar.

        The conversion uses 3 decimal places rounding.

    Args:
        time: The time-value to convert.
        from_units: The units used by the input data. Use one of the valid options defined in the TimeUnits enumeration:
            'ns' (nanoseconds), 'us' (microseconds), 'ms' (milliseconds), 's' (seconds), 'm' (minutes), 'h' (hours),
            'd' (days).
        to_units: The units to convert the input data to. Uses the same options as the 'from_units' argument.
        as_float: Determines whether to return the converted time as a Python floating object (if True) or a NumPy
            64-bit floating scalar type (if False).

    Returns:
        The converted time-value given in the requested time-units. Depending on the 'as_float' argument, the value is
        returned either as a Python float or a NumPy 64-bit floating scalar.

    Raises:
        ValueError: If 'from_units' or 'to_units' argument is not set to a valid time-option.
    """
    conversion_dict: dict[str, int | float] = {
        "d": 86400,  # seconds in a day
        "h": 3600,  # seconds in an hour
        "m": 60,  # seconds in a minute
        "s": 1,  # seconds in a second
        "ms": 0.001,  # seconds in a millisecond
        "us": 1e-6,  # seconds in a microsecond
        "ns": 1e-9,  # seconds in a nanosecond
    }

    # Verifies that unit-options are valid.
    if from_units not in conversion_dict:
        message = (
            f"Unsupported 'from_units' argument value ({from_units}) encountered when converting input time-values to "
            f"the requested time-format. Use one of the valid members defined in the TimeUnits enumeration: "
            f"{', '.join(tuple(TimeUnits))}."
        )
        console.error(message=message, error=ValueError)

    if to_units not in conversion_dict:
        message = (
            f"Unsupported 'to_units' argument value ({to_units}) encountered when converting input time-values to "
            f"the requested time-format. Use one of the valid members defined in the TimeUnits enumeration: "
            f"{', '.join(tuple(TimeUnits))}."
        )
        console.error(message=message, error=ValueError)

    # Converts the input value to a NumPy 64-bit floating point value. This prepares the data for processing and acts
    # as a check for whether the input value is NumPy-float-convertible (valid).
    time = np.float64(time)

    # Converts the time to the desired time format and rounds the resultant value to 3 decimal places.
    converted_time = np.round(
        (time * conversion_dict[from_units]) / conversion_dict[to_units],
        decimals=3,
    )

    # If requested, returns the converted value as a Python float. Otherwise, returns it as a NumPy 64-bit floating
    # scalar.
    if as_float:
        return float(converted_time)
    return converted_time


def get_timestamp(
    output_format: str | TimestampFormats = TimestampFormats.STRING, time_separator: str = "-"
) -> str | int | NDArray[np.uint8]:
    """Gets the current Coordinated Universal Time (UTC) timestamp (date and time) and returns it using the requested
    output format.

    Notes:
        The bytes'-converted timestamp is encoded using the little-endian format.

    Args:
        output_format: The format in which to return the timestamp. Use one of the valid options defined in the
            TimestampFormats enumeration: "str", "byte", or "int".
        time_separator: The separator to use for delimiting the date-and-time string. This is only used if the
            'output_format' argument is set to "str".

    Returns:
        The current UTC timestamp converted to the requested output format.

    Raises:
        TypeError: If the 'time_separator' argument is not a string.
        ValueError: If the 'output_format' argument is not set to a valid format option.

    """
    # Gets the atomic time using a timezone-aware query.
    now = datetime.datetime.now(datetime.UTC)

    # Converts UTC timestamp to microseconds elapsed since UTC epoch onset.
    microseconds = int(now.timestamp() * 1_000_000)

    # Integer format
    if output_format == TimestampFormats.INTEGER:
        return microseconds

    # NumPy bytes' array format
    if output_format == TimestampFormats.BYTES:
        # Converts to bytes' array using little-endian 64-bit integer
        return np.array([microseconds], dtype="<i8").view(np.uint8)

    # String format
    if output_format == TimestampFormats.STRING:
        # Verifies that time-separator is of a valid type
        if not isinstance(time_separator, str):
            message = (
                f"Invalid 'time_separator' argument type encountered when getting the current UTC timestamp. Expected "
                f"{type(str).__name__}, but encountered {time_separator} of type {type(time_separator).__name__}."
            )
            console.error(message=message, error=TypeError)

        # Formats the timestamp into a string using the requested delimiter and returns it to caller
        return now.strftime(
            f"%Y{time_separator}%m{time_separator}%d{time_separator}%H{time_separator}%M{time_separator}"
            f"%S{time_separator}%f"
        )
    # Unsupported output format
    message = (
        f"Unsupported 'format' argument value ({output_format}) encountered when getting the current UTC "
        f"timestamp. Use one of the valid members defined in the TimestampFormats enumeration: "
        f"{', '.join(tuple(TimestampFormats))}."
    )
    console.error(message=message, error=ValueError)
    # Fallback to appease mypy, should not be reachable.
    raise ValueError(message)  # pragma: no cover


def convert_timestamp(
    timestamp: str | int | NDArray[np.uint8],
    time_separator: str = "-",
    output_format: str | TimestampFormats = TimestampFormats.STRING,
) -> str | int | NDArray[np.uint8]:
    """Converts a timestamp generated by the get_timestamp() function into a different format.

    Notes:
        This method is primarily designed to decode byte-serialized timestamps produced by the get_timestamp() function
        into other formats.

    Args:
        timestamp: The timestamp value to convert.
        time_separator: The separator to use for delimiting the date-and-time string. This is used when parsing input
            date-and-time strings and when converting timestamps to the string format.
        output_format: The format in which to return the timestamp. Use one of the valid options defined in the
            TimestampFormats enumeration: "str", "byte", or "int".

    Returns:
        The timestamp converted to the requested format.

    Raises:
        TypeError: If the 'time_separator' argument is not a string, or if the 'timestamp' argument is not of a valid
            type.
        ValueError: If the 'output_format' argument is not set to a valid format option.
    """
    # Verify time_separator is valid
    if not isinstance(time_separator, str):
        message = (
            f"Invalid 'time_separator' argument type encountered when converting timestamp. "
            f"Expected {type(str).__name__}, but encountered {time_separator} of type {type(time_separator).__name__}."
        )
        console.error(message=message, error=TypeError)

    # Converts the input to microseconds based on the input type

    # Bytes' input
    microseconds: int = 0  # Pre-initializes the variable to appease mypy
    if isinstance(timestamp, np.ndarray):
        # Verifies that the timestamp is stored as a one-dimensional uint8 array.
        if timestamp.dtype != np.uint8 or timestamp.ndim != 1:
            message = (
                f"Invalid 'timestamp' argument type encountered when converting a bytes' timestamp. "
                f"Expected a one-dimensional uint8 numpy array, but got {timestamp} of type "
                f"{type(timestamp).__name__} with dtype {timestamp.dtype} and shape {timestamp.shape}."
            )
            console.error(message=message, error=TypeError)

        # Converts bytes' array to elapsed microseconds since UTC epoch onset
        microseconds = int(np.frombuffer(timestamp.tobytes(), dtype="<i8")[0])

    # Integer input
    elif isinstance(timestamp, int):
        microseconds = timestamp

    # String input
    elif isinstance(timestamp, str):
        # Parses the string timestamp using the provided separator
        try:
            # Expected format: YYYY-MM-DD-HH-MM-SS-ffffff (with custom separator)
            parts = timestamp.split(time_separator)
            if len(parts) != _DT_STRING_PARTS:
                message = (
                    f"Expected 7 parts in the timestamp string when converting a string timestamp, but encountered a "
                    f"{timestamp} string with {len(parts)}."
                )
                raise ValueError(message)

            # Parses each component
            year = int(parts[0])
            month = int(parts[1])
            day = int(parts[2])
            hour = int(parts[3])
            minute = int(parts[4])
            second = int(parts[5])
            microsecond = int(parts[6])

            # Creates a datetime object
            dt = datetime.datetime(year, month, day, hour, minute, second, microsecond, tzinfo=datetime.UTC)

            # Converts to microseconds since UTC epoch onset
            microseconds = int(dt.timestamp() * 1_000_000)

        except (ValueError, IndexError):
            message = (
                f"Invalid timestamp string format encountered when converting timestamp. "
                f"Expected format YYYY{time_separator}MM{time_separator}DD{time_separator}HH{time_separator}MM"
                f"{time_separator}SS{time_separator}ffffff, but got '{timestamp}'."
            )
            console.error(message=message, error=ValueError)

    else:
        message = (
            f"Invalid 'timestamp' argument type encountered when converting timestamp. "
            f"Expected string, integer, or NumPy array, but got {timestamp} of type {type(timestamp).__name__}."
        )
        console.error(message=message, error=TypeError)
        # Fallback to appease mypy, should not be reachable.
        raise TypeError(message)  # pragma: no cover

    # Converts microseconds to the requested output format

    # Integer format
    if output_format == TimestampFormats.INTEGER:
        return microseconds

    # NumPy bytes' array format
    if output_format == TimestampFormats.BYTES:
        # Converts to bytes' array using little-endian 64-bit integer
        return np.array([microseconds], dtype="<i8").view(np.uint8)

    # String format
    if output_format == TimestampFormats.STRING:
        # Splits into seconds and microseconds components
        seconds = float(microseconds) // 1_000_000
        microseconds_part = int(microseconds % 1_000_000)

        # Creates UTC datetime with microsecond precision
        timestamp_dt = datetime.datetime.fromtimestamp(seconds, tz=datetime.UTC).replace(microsecond=microseconds_part)

        # Formats with the specified separator and returns to caller
        return timestamp_dt.strftime(
            f"%Y{time_separator}%m{time_separator}%d{time_separator}%H{time_separator}%M{time_separator}"
            f"%S{time_separator}%f"
        )

    # Unsupported output format
    message = (
        f"Unsupported 'output_format' argument value ({output_format}) encountered when converting "
        f"timestamp. Use one of the valid members defined in the TimestampFormats enumeration: "
        f"{', '.join(tuple(TimestampFormats))}."
    )
    console.error(message=message, error=ValueError)
    # Fallback to appease mypy, should not be reachable.
    raise ValueError(message)  # pragma: no cover
