*
* optxpress.def
*

presolve enumint 8011000 1 1 3 Determines whether presolving should be performed prior to starting the main algorithm
 -1 1 Presolve applied, but a problem will not be declared infeasible if primal infeasibilities are detected. The problem will be solved by the LP optimization algorithm, returning an infeasible solution, which can sometimes be helpful.
 0 1 Presolve not applied.
 1 1 Presolve applied.
 2 1 Presolve applied, but redundant bounds are not removed. This can sometimes increase the efficiency of the barrier algorithm.
 3 1 Presolve is applied, and bounds detected to be redundant are always removed.
scaling integer 8010000 163 minint maxint 1 4 Bit-vector control determines how the Optimizer will rescale a model internally before optimization
 bit 0 = 1 Equivalent to \ref XPRESSscaling_rowScaling "scaling_rowScaling".
 bit 1 = 2 Equivalent to \ref XPRESSscaling_colScaling "scaling_colScaling".
 bit 2 = 4 Equivalent to \ref XPRESSscaling_rowScalingAgain "scaling_rowScalingAgain".
 bit 3 = 8 Equivalent to \ref XPRESSscaling_maximum "scaling_maximum".
 bit 4 = 16 Equivalent to \ref XPRESSscaling_curtisReid "scaling_curtisReid".
 bit 5 = 32 Equivalent to \ref XPRESSscaling_byMaxElemNotGeoMean "scaling_byMaxElemNotGeoMean".
 bit 6 = 64 Equivalent to \ref XPRESSscaling_bigM "scaling_bigM".
 bit 7 = 128 Equivalent to \ref XPRESSscaling_simplexObjScaling "scaling_simplexObjScaling".
 bit 8 = 256 Equivalent to \ref XPRESSscaling_ignoreQuadRowPart "scaling_ignoreQuadRowPart".
 bit 9 = 512 Equivalent to \ref XPRESSscaling_beforePresolve "scaling_beforePresolve".
 bit 10 = 1024 Equivalent to \ref XPRESSscaling_noScalingRowsUp "scaling_noScalingRowsUp".
 bit 11 = 2048 Equivalent to \ref XPRESSscaling_noScalingColsDown "scaling_noScalingColsDown".
 bit 12 = 4096 Equivalent to \ref XPRESSscaling_disableGlobalObjScaling "scaling_disableGlobalObjScaling".
 bit 13 = 8192 Equivalent to \ref XPRESSscaling_rhsScaling "scaling_rhsScaling".
 bit 14 = 16384 Equivalent to \ref XPRESSscaling_noAggressiveQScaling "scaling_noAggressiveQScaling".
 bit 15 = 32768 Equivalent to \ref XPRESSscaling_slackScaling "scaling_slackScaling".
solnpool string 0 "" 1 12 Solution pool file name
advBasis enumint 0 1 1 1 Use advanced basis provided by GAMS
 0 1 Do not load basis
 1 1 Load basis if suitable (decided by solver link)
 2 1 Force loading basis
algorithm string 0 "simplex" 0 1 Choose between simplex and barrier algorithm
basisOut string 0 "" 1 1 Directs optimizer to output an MPS basis file
fixoptfile string 0 "" 1 9 name of option file which is read just before solving the fixed problem
knitroOptFile string -12000000 "" 0 13 Option file for NLP solver \ref S_KNITRO "KNITRO"
loadMipSol boolean 0 0 1 9 Loads a MIP solution (the initial point)
mipCleanup boolean 0 1 1 9 Clean up the MIP solution (round-fix-solve) to get duals
mipstopexpr strlist 0 1 9 Stopping expression for branch and bound
mipTrace string 0 "" 1 9 Name of MIP trace file
mipTraceNode integer 0 100 0 maxint 1 9 Node interval between MIP trace file entries
mipTraceTime double 0 5 0 maxdouble 1 9 Time interval, in seconds, between MIP trace file entries
mpsOutputFile string 0 "" 1 1 Name of MPS output file
objGoodEnough double 0 0 mindouble maxdouble 0 9 Stop once an objective this good is found
qextractalg enumint 0 0 1 1 quadratic extraction algorithm in GAMS interface
 0 1 Automatic
 1 1 ThreePass: Uses a three-pass forward / backward / forward AD technique to compute function / gradient / Hessian values and a hybrid scheme for storage.
 2 1 DoubleForward: Uses forward-mode AD to compute and store function, gradient, and Hessian values at each node or stack level as required.  The gradients and Hessians are stored in linked lists.
 3 1 Concurrent: Uses ThreePass and DoubleForward in parallel. As soon as one finishes, the other one stops.
qextractdenseswitchfactor double 0 0.008 0 maxdouble 1 1 Sparse/dense factor for quadratic extraction algorithm in GAMS interface
qextractdenseswitchlog boolean 0 0 1 1 Enables additional information about sparse/dense factor choice in quadratic extraction algorithm in GAMS interface
reform boolean 0 1 0 1 Substitute out objective var and equ when possible
reRun boolean 0 0 1 1 Rerun with primal simplex when not optimal/feasible
reslim double 0 0 0 maxdouble 1 1 Overrides GAMS reslim option
secret strlist 0 0 1 Pass on secret XPRESS options
solnpoolCapacity integer 0 999999999 1 maxint 1 12 Limit on number of solutions to store
solnpoolCullRounds integer 0 999999999 0 maxint 1 12 Terminate solution generation after N culling rounds
solnpoolmerge string 0 "" 1 12 Solution pool file name for merged solutions
solnpoolnumsym integer 0 10 1 maxint 1 12 Maximum number of variable symbols when writing merged solutions
solnpoolPop enumint 0 1 1 12 Controls method used to populate the solution pool
 1 1 generate solutions using the normal search algorithm
 2 1 invoke the solution enumerator to generate solutions
solnpoolPrefix string 0 "soln" 1 12 File name prefix for GDX solution files
solnpoolVerbosity enumint 0 0 1 12 Controls verbosity of solution pool routines
 -1 1 no output
 0 1 output only messages coming from the XPRESS libraries
 1 1 add some messages logging the effect of solution pool options
 2 1 debugging mode
writePrtSol boolean 0 0 1 1 Directs optimizer to output a "printsol" file
xslp_multistartPreset enumint -12000000 0 1 21 Enable multistart
 0 1 Disable multistart preset.
 1 1 Generate \ref XPRESSxslp_multistart_maxSolves "xslp_multistart_maxSolves" number of random base points.
 2 1 Generate \ref XPRESSxslp_multistart_maxSolves "xslp_multistart_maxSolves" number of random base points, filtered by a merit function centred on initial feasibility.
 3 1 Load the most typical SLP tuning settings. A maximum of \ref XPRESSxslp_multistart_maxSolves "xslp_multistart_maxSolves" jobs are loaded.
 4 1 Load a comprehensive set of SLP tuning settings. A maximum of \ref XPRESSxslp_multistart_maxSolves "xslp_multistart_maxSolves" jobs are loaded.
cpuTime enumint 8133000 0 1 1 How time should be measured when timings are reported in the log and when checking against time limits
 -1 1 Disable the timer.
 0 1 Use elapsed time.
 1 1 Use process time.
extraCols integer 8005000 0 0 maxint 0 1 Initial number of extra columns to allow for in the matrix
extraElems integer 8006000 0 0 maxint 0 1 Initial number of extra matrix elements to allow for in the matrix, including coefficients for cuts
extraRows integer 8004000 0 0 maxint 0 1 Initial number of extra rows to allow for in the matrix, including cuts
lpIterLimit integer 8007000 maxint 0 maxint 1 1 Maximum number of iterations that will be performed by primal simplex or dual simplex before the optimization process terminates
lpRefineIterLimit integer 8094000 -1 -1 maxint 1 1 Simplex iteration limit the solution refiner can spend in attempting to increase the accuracy of an LP solution
maxScaleFactor integer 8275000 64 0 64 1 1 Determines the maximum scaling factor that can be applied during scaling
 0-64 The maximum is provided an exponent of a power of 2.
maxTime integer 8020000 0 minint maxint 0 1 Parameter is deprecated and will be removed in a future release
 0 No time limit.
 n<0 Stop in LP or MIP search after n seconds.
 n>0 If an integer solution has been found, stop MIP search after n seconds, otherwise continue until an integer solution is finally found.
mpsNameLength integer 8071000 0 0 maxint 1 1 Maximum length of MPS names in characters
outputLog enumint 8035000 1 1 1 Controls the level of output produced by the Optimizer during optimization
 0 1 Turn all output off.
 1 1 Print all messages.
 3 1 Print error and warning messages.
 4 1 Print error messages only.
outputTol double 7004000 1e-05 0 maxdouble 1 1 Zero tolerance on print values
randomSeed integer 8328000 1 minint maxint 1 1 Sets the initial seed to use for the pseudo-random number generator in the Optimizer
refineOps integer 8093000 19 minint maxint 1 1 Specifies when the solution refiner should be executed to reduce solution infeasibilities
 bit 0 = 1 Equivalent to \ref XPRESSrefineOps_lpOptimal "refineOps_lpOptimal".
 bit 1 = 2 Equivalent to \ref XPRESSrefineOps_mipSolution "refineOps_mipSolution".
 bit 3 = 8 Equivalent to \ref XPRESSrefineOps_mipNodeLp "refineOps_mipNodeLp".
 bit 4 = 16 Equivalent to \ref XPRESSrefineOps_lpPresolve "refineOps_lpPresolve".
 bit 5 = 32 Equivalent to \ref XPRESSrefineOps_iterativeRefiner "refineOps_iterativeRefiner".
 bit 6 = 64 Equivalent to \ref XPRESSrefineOps_refinerPrecision "refineOps_refinerPrecision".
 bit 7 = 128 Equivalent to \ref XPRESSrefineOps_refinerUsePrimal "refineOps_refinerUsePrimal".
 bit 8 = 256 Equivalent to \ref XPRESSrefineOps_refinerUseDual "refineOps_refinerUseDual".
 bit 9 = 512 Equivalent to \ref XPRESSrefineOps_mipFixGlobals "refineOps_mipFixGlobals".
 bit 10 = 1024 Equivalent to \ref XPRESSrefineOps_mipFixGlobalsTarget "refineOps_mipFixGlobalsTarget".
refineOps_lpOptimal boolean 8093001 1 1 1 Run the solution refiner on an optimal solution of a continuous problem
refineOps_mipSolution boolean 8093002 1 1 1 Run the solution refiner when a new solution is found during a tree search
refineOps_mipNodeLp boolean 8093004 0 1 1 Run the solution refiner on each node of the MIP search
refineOps_lpPresolve boolean 8093005 1 1 1 Run the solution refiner on an optimal solution before postsolve on a continuous problem
refineOps_iterativeRefiner boolean 8093006 0 1 1 Apply the iterative refiner to refine the solution
refineOps_refinerPrecision boolean 8093007 0 1 1 Use higher precision in the iterative refinement
refineOps_refinerUsePrimal boolean 8093008 0 1 1 If set, the iterative refiner will use the primal simplex algorithm
refineOps_refinerUseDual boolean 8093009 0 1 1 If set, the iterative refiner will use the dual simplex algorithm
refineOps_mipFixGlobals boolean 8093010 0 1 1 Refine MIP solutions such that rounding them keeps the problem feasible when reoptimized
refineOps_mipFixGlobalsTarget boolean 8093011 0 1 1 Attempt to refine MIP solutions such that rounding them keeps the problem feasible when reoptimized, but accept integers solutions even if refinement fails
trace integer 8130000 0 0 maxint 1 1 Display the infeasibility diagnosis during presolve
inputTol double 7143000 0 0 maxdouble 1 1 Tolerance on input values elements
clamping enumint 8301000 0 1 1 Bit-vector control allows for the adjustment of returned solution values such that they are always within bounds
 -1 1 Determined automatically.
 0 1 Equivalent to \ref XPRESSclamping_primal "clamping_primal".
 1 1 Equivalent to \ref XPRESSclamping_dual "clamping_dual".
 2 1 Equivalent to \ref XPRESSclamping_slacks "clamping_slacks".
 3 1 Equivalent to \ref XPRESSclamping_rdj "clamping_rdj".
clamping_primal boolean 8301001 0 1 1 Adjust primal solution to always be within primal bounds
clamping_dual boolean 8301002 0 1 1 Adjust primal slack values to always be within constraint bounds
clamping_slacks boolean 8301003 0 1 1 Adjust dual solution to always be within the dual bounds implied by the slacks
clamping_rdj boolean 8301004 0 1 1 Adjust reduced costs to always be within dual bounds implied by the primal solution
outputControls boolean 8424000 1 1 1 Toggles the printing of all control settings at the beginning of the search
 0 Turn off printing of user-specified control settings.
 1 Print controls.
ioTimeout integer 8442000 30 0 maxint 1 1 Maximum number of seconds to wait for an I/O operation before it is cancelled
numericalEmphasis enumint 8416000 -1 1 1 How much emphasis to place on numerical stability instead of solve speed
 -1 1 Automatic. The emphasis might be influenced by the setting of other controls.
 0 1 Emphasize speed.
 1 1 Mild emphasis on numerical stability.
 2 1 Medium emphasis on numerical stability.
 3 1 Strong emphasis on numerical stability.
globalBoundingBox double 7154000 1e+06 mindouble maxdouble 1 1 If a nonlinear problem cannot be solved due to appearing unbounded, it can automatically be regularized by the application of a bounding box on the variables
 0 Disabled. Problem will return unbounded.
 n<0 Enabled. Apply lower and upper bounds of this magnitude to all original variables if initial LP is unbounded.
 n>0 Enabled. Apply lower and upper bounds of this magnitude to all original and auxiliary variables if initial LP and first regularization are unbounded.
timeLimit double 7158000 1e+20 0 maxdouble 1 1 Maximum time in seconds that the Optimizer will run before it terminates, including the problem setup time and solution time
 >0 Stop LP or MIP search after the given number of seconds.
solTimeLimit double 7159000 1e+20 0 maxdouble 1 1 Maximum time in seconds that the Optimizer will run a MIP solve before it terminates, given that a solution has been found
 >0 If an integer solution has been found, stop MIP search after the given number of seconds, otherwise continue until an integer solution is finally found.
workLimit double 7167000 1e+20 0 maxdouble 1 1 Maximum work (measured in work units) that the Optimizer will run before it terminates
 >0 Stop LP or MIP search when the given number of work units is reached.
barCores integer 8202000 -1 -1 maxint 1 2 If set to a positive integer it determines the number of physical CPU cores assumed to be present in the system by the barrier and hybrid gradient algorithms
barOrderThreads integer 8187000 0 0 maxint 1 2 If set to a positive integer it determines the number of concurrent threads for the sparse matrix ordering algorithm in the Newton-barrier method
barThreads integer 8053000 -1 -1 maxint 1 2 If set to a positive integer it determines the number of threads implemented to run the Newton-barrier and hybrid gradient algorithms
cacheSize integer 8043000 -1 -1 maxint 0 2 Parameter is deprecated and will be removed in a future release
concurrentThreads integer 8274000 -1 -1 maxint 1 2 Determines the number of threads used by the concurrent solver
 -1 Determined automatically
 >0 Number of threads to use.
coresPerCpu integer 8296000 -1 -1 maxint 1 2 Used to override the detected value of the number of cores on a CPU
cpuPlatform enumint 8312000 -2 1 2 Newton Barrier: Selects the AMD, Intel x86 or ARM vectorization instruction set that Barrier should run optimized code for
 -2 1 Highest supported [Generic, SSE2, AVX or AVX2].
 -1 1 Highest supported solve path consistent code [Generic, SSE2 or AVX].
 0 1 Use generic code compatible with all CPUs.
 1 1 Use SSE2 / NEON optimized code.
 2 1 Use AVX optimized code.
 3 1 Use AVX2 optimized code.
crossoverThreads integer 8065000 -1 -1 maxint 1 2 Determines the maximum number of threads that parallel crossover is allowed to use
dualThreads integer 8334000 -1 -1 maxint 1 2 Determines the maximum number of threads that dual simplex is allowed to use
heurThreads integer 8276000 0 -1 maxint 1 2 Branch and Bound: Number of threads to dedicate to running heuristics during the root solve
 -1 Automatically determined from the \ref XPRESSthreads "threads" control.
 0 Disabled.
 >=1 Number of additional threads to dedicate to parallel heuristics.
l1Cache integer 8175000 -1 -1 maxint 0 2 Parameter is deprecated and will be removed in a future release
maxMemoryHard integer 8119000 0 0 maxint 1 2 Sets the maximum amount of memory in megabytes the optimizer should allocate
maxMemorySoft integer 8112000 0 0 maxint 1 2 When \ref XPRESSresourceStrategy "resourceStrategy" is enabled, this control sets the maximum amount of memory in megabytes the optimizer targets to allocate
mipThreads integer 8079000 -1 -1 maxint 1 2 If set to a positive integer it determines the number of threads implemented to run the parallel MIP code
relaxTreeMemoryLimit double 7105000 0.1 0 maxdouble 1 2 When the memory used by the branch and bound search tree exceeds the target specified by the \ref XPRESStreeMemoryLimit "treeMemoryLimit" control, the optimizer will try to reduce this by wr****
resourceStrategy boolean 8297000 0 1 2 Controls whether the optimizer is allowed to make nondeterministic decisions if memory is running low in an effort to preserve memory and finish the solve
 1 Allow the optimizer to change the solve path if necessary to preserve memory when getting close to one of the memory limits.
threads integer 8278000 -1 minint maxint 1 2 Default number of threads used during optimization
treeCompression integer 8243000 2 0 maxint 1 2 When writing nodes to the global file, the optimizer can try to use data-compression techniques to reduce the size of the tree file on disk
treeMemoryLimit integer 8242000 0 0 maxint 1 2 Soft limit, in megabytes, for the amount of memory to use in storing the branch and bound search tree
treeMemorySavingTarget double 7100000 0.4 0 maxdouble 1 2 When the memory used by the branch-and-bound search tree exceeds the limit specified by the \ref XPRESStreeMemoryLimit "treeMemoryLimit" control, the optimizer will try to save memory by w****
backgroundMaxThreads integer 8461000 -1 -1 maxint 1 2 Limit the number of threads to use in background jobs (for example in parallel to the root cut loop)
backgroundSelect integer 8463000 -1 -1 1 1 2 Bit-vector control to select which tasks to run in background jobs (for example in parallel to the root cut loop)
 bit 0 = 1 Feasibility jump heuristic.
 bit 1 = 2 Fast branch-and-bound heuristic.
 bit 2 = 4 Same as bit 1 but with some additional heuristics enabled.
 bit 3 = 8 Fix-propagate-repair heuristic.
heurSearchBackgroundSelect integer 8477000 -1 -1 maxint 1 2 Bit-vector control to select which large neighborhood searches to run in the background (for example in parallel to the root cut loop)
 bit 1 = 2 Enable L heuristic.
mipPresolve integer 8078000 -1 minint maxint 1 3 Branch and Bound: Type of integer processing to be performed
 bit 0 = 1 Equivalent to \ref XPRESSmipPresolve_reducedCostFixing "mipPresolve_reducedCostFixing".
 bit 1 = 2 Equivalent to \ref XPRESSmipPresolve_logicPreprocessing "mipPresolve_logicPreprocessing".
 bit 2 = 4 [Unused] This bit is no longer used to control probing. Refer to the integer control \ref XPRESSpreProbing "preProbing" for setting probing level during presolve.
 bit 3 = 8 Equivalent to \ref XPRESSmipPresolve_allowChangeBounds "mipPresolve_allowChangeBounds".
 bit 4 = 16 Equivalent to \ref XPRESSmipPresolve_dualReductions "mipPresolve_dualReductions".
 bit 5 = 32 Equivalent to \ref XPRESSmipPresolve_globalCoefTightening "mipPresolve_globalCoefTightening".
 bit 6 = 64 Equivalent to \ref XPRESSmipPresolve_objBasedReductions "mipPresolve_objBasedReductions".
 bit 7 = 128 Equivalent to \ref XPRESSmipPresolve_allowTreeRestart "mipPresolve_allowTreeRestart".
 bit 8 = 256 Equivalent to \ref XPRESSmipPresolve_symmetryReductions "mipPresolve_symmetryReductions".
mipPresolve_reducedCostFixing boolean 8078001 1 1 3 Reduced cost fixing will be performed at each node
mipPresolve_logicPreprocessing boolean 8078002 1 1 3 Primal reductions will be performed at each node
mipPresolve_allowChangeBounds boolean 8078004 1 1 3 If node preprocessing is allowed to change bounds on continuous columns
mipPresolve_dualReductions boolean 8078005 1 1 3 Dual reductions will be performed at each node
mipPresolve_globalCoefTightening boolean 8078006 1 1 3 Allow global (non-bound) tightening of the problem during the tree search
mipPresolve_objBasedReductions boolean 8078007 1 1 3 Objective function will be used to find reductions at each node
mipPresolve_allowTreeRestart boolean 8078008 1 1 3 [Unused] This bit is no longer used to control restarts
mipPresolve_symmetryReductions boolean 8078009 1 1 3 Allow that symmetry is used to presolve the node problem
rootPresolve enumint 8224000 -1 1 3 Determines if presolving should be performed on the problem after the tree search has finished with root cutting and heuristics
 -1 1 Let the optimizer decide if the problem should be presolved again.
 0 1 Disabled.
 1 1 Always presolve the root problem.
preCliqueStrategy integer 8247000 -1 -1 maxint 1 3 Determines how much effort to spend on clique covers in presolve
siftPresolveOps integer 8435000 -1 -1 maxint 1 3 Determines the presolve operations for solving the subproblems during the sifting algorithm
 -1 Use the \ref XPRESSpresolveOps "presolveOps" setting specified for the original problem.
 >=0 Use the value for the \ref XPRESSpresolveOps "presolveOps" parameter for solving the subproblems during the sifting algorithm.
preConfiguration enumint 8470000 -1 1 3 MIP Presolve: Determines whether binary rows with only few repeating coefficients should be reformulated
 -1 1 Automatically determined.
 0 1 Disable configuration presolving.
preConvertObjToCons enumint 8260000 -1 1 3 Presolve: Convert a linear or quadratic objective function into an objective transfer constraint
 -1 1 Automatically determined.
 0 1 Disable reformulation.
 1 1 Move only the quadratic part of the objective into a constraint.
 2 1 Move both the linear and quadratic parts of the objective into a constraint.
barPresolveOps integer 8286000 0 0 maxint 1 3 Newton barrier: Bit-vector controls the Newton-Barrier specific presolve operations
 bit 0 = 1 Equivalent to \ref XPRESSbarPresolveOps_standard "barPresolveOps_standard".
 bit 1 = 2 Equivalent to \ref XPRESSbarPresolveOps_extra "barPresolveOps_extra".
 bit 2 = 4 Equivalent to \ref XPRESSbarPresolveOps_full "barPresolveOps_full".
barPresolveOps_standard boolean 8286001 0 1 3 Use standard presolve
barPresolveOps_extra boolean 8286002 0 1 3 Extra effort is spent in barrier specific presolve
barPresolveOps_full boolean 8286003 0 1 3 Do full matrix eliminations (reduce matrix size)
dualize enumint 8144000 -1 1 3 For a linear problem or the initial linear relaxation of a MIP, determines whether to form and solve the dual problem
 -1 1 Determine automatically which version would be faster.
 0 1 Solve the original problem.
 1 1 Solve the dualized problem.
dualizeOps boolean 8097000 1 1 3 Bit-vector control for adjusting the behavior when a problem is dualized
 bit 0 = 1 Swap the simplex algorithm to run. If dual simplex is selected for the original problem then primal simplex will be run on the dualized problem, and simiarly if primal simplex is selected.
elimFillin integer 8073000 7 0 maxint 1 3 Amount of fill-in allowed when performing an elimination in presolve
elimTol double 7042000 0.001 0 maxdouble 1 3 Markowitz tolerance for the elimination phase of the presolve
indLinBigM double 7099000 100000 0 maxdouble 1 3 During presolve, indicator constraints will be linearized using a BigM coefficient whenever that BigM coefficient is small enough
indPreLinBigM double 7102000 100 0 maxdouble 1 3 During presolve, indicator constraints will be linearized using a BigM coefficient whenever that BigM coefficient is small enough
lpFolding enumint 8136000 -1 1 3 Simplex and barrier: Whether to fold an LP problem before solving it
 -1 1 Automatic.
 0 1 Disable LP folding.
 1 1 Enable LP folding. Attempt to fold all LP problems and MIP initial relaxations.
maxImpliedBound double 7120000 1e+08 0 maxdouble 1 3 Presolve: When tighter bounds are calculated during MIP preprocessing, only bounds whose absolute value are smaller than \ref XPRESSmaxImpliedBound "maxImpliedBound" will be applied to the problem
preAnalyticCenter enumint 8374000 -1 1 3 Determines if analytic centers should be computed and used for variable fixing and the generation of alternative reduced costs (-1: Auto 0: Off, 1: Fixing, 2: Redcost, 3: Both)
 -1 1 Automatic.
 0 1 Disable analytic center presolving.
 1 1 Use analytic center for variable fixing only.
 2 1 Use analytic center for reduced cost computation only.
 3 1 Use analytic centers for both, variable fixing and reduced cost computation.
preBasisRed enumint 8106000 0 1 3 Determines if a lattice basis reduction algorithm should be attempted as part of presolve
 -1 1 Automatic.
 0 1 Disable basis reduction.
 1 1 Enable basis reduction.
preBndRedCone enumint 8338000 -1 1 3 Determines if second order cone constraints should be used for inferring bound reductions on variables when solving a MIP
 -1 1 Automatic.
 0 1 Disable bound reductions from second order cone constraints.
 1 1 Enable bound reductions from second order cone constraints.
preBndRedQuad enumint 8337000 -1 1 3 Determines if convex quadratic constraints should be used for inferring bound reductions on variables when solving a MIP
 -1 1 Automatic.
 0 1 Disable bound reductions from quadratic constraints.
 1 1 Enable bound reductions from quadratic constraints.
preCoefElim enumint 8194000 2 1 3 Presolve: Specifies whether the optimizer should attempt to recombine constraints in order to reduce the number of non zero coefficients when presolving a mixed integer problem
 0 1 Disabled.
 1 1 Remove as many coefficients as possible.
 2 1 Cautious eliminations. Will not perform a reduction if it might destroy problem structure useful to e.g. heuristics or cutting.
preComponents enumint 8339000 -1 1 3 Presolve: Determines whether small independent components should be detected and solved as individual subproblems during root node processing
 -1 1 Automatically determined.
 0 1 Disable detection of independent components.
 1 1 Enable detection of independent components.
preComponentsEffort double 7124000 1 0 maxdouble 1 3 Presolve: Adjusts the overall effort for the independent component presolver
preConeDecomp enumint 8349000 -1 1 3 Presolve: Decompose regular and rotated cones with more than two elements and apply Outer Approximation on the resulting components
 -1 1 Automatically determined.
 0 1 Disable cone decomposition.
 1 1 Enable cone decomposition by replacing large cones with small ones in the presolved problem.
 2 1 Similar to 1, plus decomposition is enabled even if the cone variable is fixed.
 3 1 Cones are decomposed within the Outer Approximation domain only, i.e., the problem maintains the original cones.
preConvertSeparable enumint 8128000 -1 1 3 Presolve: Reformulate problems with a non-diagonal quadratic objective and/or constraints as diagonal quadratic or second-order conic constraints
 -1 1 Automatically determined.
 0 1 Disable reformulation.
 1 1 Enable reformulation to diagonal quadratic constraints.
 2 1 Enable reformulation to diagonal quadratic constraints and reduction to second-order cones.
preDomCol enumint 8195000 -1 1 3 Presolve: Determines the level of dominated column removal reductions to perform when presolving a mixed integer problem
 -1 1 Automatically determined.
 0 1 Disabled.
 1 1 Cautious strategy, limited effort looking for special structure.
 2 1 Same as 2 but checking all candidates.
 3 1 Includes 1 and 2 but also looks for more generic column domination.
preDomRow enumint 8281000 -1 1 3 Presolve: Determines the level of dominated row removal reductions to perform when presolving a problem
 -1 1 Automatically determined.
 0 1 Disabled.
 1 1 Cautious strategy.
 2 1 Medium strategy.
 3 1 Aggressive strategy. All candidate row combinations will be considered.
preDupRow enumint 8307000 -1 1 3 Presolve: Determines the type of duplicate rows to look for and eliminate when presolving a problem
 -1 1 Automatically determined.
 0 1 Do not eliminate duplicate rows.
 1 1 Eliminate only rows that are identical in all variables.
 2 1 Same as option 1 plus eliminate duplicate rows with simple penalty variable expressions. (MIP only).
 3 1 Same as option 2 plus eliminate duplicate rows with more complex penalty variable expressions. (MIP only).
preElimQuad enumint 8353000 -1 1 3 Presolve: Allows for elimination of quadratic variables via doubleton rows
 -1 1 Automatically determined.
 0 1 Do not eliminate duplicate rows.
 1 1 Eliminate at least one quadratic variable for each doubleton row.
preImplications enumint 8356000 -1 1 3 Presolve: Determines whether to use implication structures to remove redundant rows
 -1 1 Automatically determined.
 0 1 Do not use implications for sparsification.
 1 1 Use implications to remove reduandant rows.
preLinDep enumint 8333000 -1 1 3 Presolve: Determines whether to check for and remove linearly dependent equality constraints when presolving a problem
 -1 1 Automatically determined.
 0 1 Do not check for linearly dependent equality constraints.
 1 1 Check for and remove linearly dependent equality constraints.
preObjCutDetect boolean 8336000 1 1 3 Presolve: Determines whether to check for constraints that are parallel or near parallel to a linear objective function, and which can safely be removed
 0 Disable check and reductions.
 1 Enable check and reductions.
preProbing enumint 8238000 -1 1 3 Presolve: Amount of probing to perform on binary variables during presolve
 -1 1 Let the optimizer decide on the amount of probing.
 0 1 Disabled.
 1 1 Light probing — only few implications will be examined.
 2 1 Full probing — all implications for all binaries will be examined.
 3 1 Full probing and repeat as long as the problem is significantly reduced.
presolveMaxGrow double 7110000 0.1 0 maxdouble 1 3 Limit on how much the number of non-zero coefficients is allowed to grow during presolve, specified as a ratio of the number of non-zero coefficients in the original problem
presolveOps integer 8077000 511 minint maxint 1 3 Bit-vector control specifies the operations which are performed during the presolve
 bit 0 = 1 Equivalent to \ref XPRESSpresolveOps_singletonColRemoval "presolveOps_singletonColRemoval".
 bit 1 = 2 Equivalent to \ref XPRESSpresolveOps_singletonRowRemoval "presolveOps_singletonRowRemoval".
 bit 2 = 4 Equivalent to \ref XPRESSpresolveOps_forcingRowRemoval "presolveOps_forcingRowRemoval".
 bit 3 = 8 Equivalent to \ref XPRESSpresolveOps_dualReductions "presolveOps_dualReductions".
 bit 4 = 16 Equivalent to \ref XPRESSpresolveOps_redundantRowRemoval "presolveOps_redundantRowRemoval".
 bit 5 = 32 Equivalent to \ref XPRESSpresolveOps_duplicateColRemoval "presolveOps_duplicateColRemoval".
 bit 6 = 64 Equivalent to \ref XPRESSpresolveOps_duplicateRowRemoval "presolveOps_duplicateRowRemoval".
 bit 7 = 128 Equivalent to \ref XPRESSpresolveOps_strongDualReductions "presolveOps_strongDualReductions".
 bit 8 = 256 Equivalent to \ref XPRESSpresolveOps_variableEliminations "presolveOps_variableEliminations".
 bit 9 = 512 Equivalent to \ref XPRESSpresolveOps_noIpReductions "presolveOps_noIpReductions".
 bit 10 = 1024 Equivalent to \ref XPRESSpresolveOps_noGlobalDomainChange "presolveOps_noGlobalDomainChange".
 bit 11 = 2048 Equivalent to \ref XPRESSpresolveOps_noAdvIpReductions "presolveOps_noAdvIpReductions".
 bit 12 = 4096 Equivalent to \ref XPRESSpresolveOps_noIntVarEliminations "presolveOps_noIntVarEliminations".
 bit 13 = 8192 Equivalent to \ref XPRESSpresolveOps_noSolutionEnumeration "presolveOps_noSolutionEnumeration".
 bit 14 = 16384 Equivalent to \ref XPRESSpresolveOps_linDependRowRemoval "presolveOps_linDependRowRemoval".
 bit 15 = 32768 Equivalent to \ref XPRESSpresolveOps_noIntVarAndSosDetect "presolveOps_noIntVarAndSosDetect".
 bit 16 = 65536 Equivalent to \ref XPRESSpresolveOps_noImpliedBounds "presolveOps_noImpliedBounds".
 bit 17 = 131072 Equivalent to \ref XPRESSpresolveOps_noCliquePresolve "presolveOps_noCliquePresolve".
 bit 18 = 262144 Equivalent to \ref XPRESSpresolveOps_noMod2Reductions "presolveOps_noMod2Reductions".
presolveOps_singletonColRemoval boolean 8077001 1 1 3 Singleton column removal
presolveOps_singletonRowRemoval boolean 8077002 1 1 3 Singleton row removal
presolveOps_forcingRowRemoval boolean 8077003 1 1 3 Forcing row removal
presolveOps_dualReductions boolean 8077004 1 1 3 Dual reductions
presolveOps_redundantRowRemoval boolean 8077005 1 1 3 Redundant row removal
presolveOps_duplicateColRemoval boolean 8077006 1 1 3 Duplicate column removal
presolveOps_duplicateRowRemoval boolean 8077007 1 1 3 Duplicate row removal
presolveOps_strongDualReductions boolean 8077008 1 1 3 Strong dual reductions
presolveOps_variableEliminations boolean 8077009 1 1 3 Variable eliminations
presolveOps_noIpReductions boolean 8077010 0 1 3 No IP reductions
presolveOps_noGlobalDomainChange boolean 8077011 0 1 3 No domain changes for MIP entities (e.g., semi-continuous detection or shifting integers)
presolveOps_noAdvIpReductions boolean 8077012 0 1 3 No advanced IP reductions
presolveOps_linDependRowRemoval boolean 8077015 0 1 3 Linearly dependant row removal
presolveOps_noIntVarEliminations boolean 8077013 0 1 3 No eliminations on integers
presolveOps_noIntVarAndSosDetect boolean 8077016 0 1 3 No integer variable and SOS detection
presolveOps_noSolutionEnumeration boolean 8077014 0 1 3 No reductions based on solution enumeration
presolveOps_noImpliedBounds boolean 8077017 0 1 3 No implied bounds
presolveOps_noCliquePresolve boolean 8077018 0 1 3 No clique presolve
presolveOps_noMod2Reductions boolean 8077019 0 1 3 No mod2 presolve
presolvePasses integer 8183000 1 0 maxint 1 3 Number of reduction rounds to be performed in presolve
preFolding enumint 8410000 -1 1 3 Presolve: Determines if a folding procedure should be used to aggregate continuous columns in an equitable partition
 -1 1 Automatically determined.
 0 1 Disabled.
 1 1 Enabled.
autoScaling enumint 8406000 -1 1 4 Whether the Optimizer should automatically select between different scaling algorithms
 -1 1 Automatic.
 0 1 Disabled.
 1 1 Cautious strategy. Non-standard scaling will only be selected if it appears to be clearly superior.
 2 1 Moderate strategy.
 3 1 Aggressive strategy. Standard scaling will only be selected if it appears to be clearly superior.
barFreeScale double 7077000 1e-06 0 maxdouble 1 4 Defines how the barrier algorithm scales free variables
barObjScale double 7026000 -1 -1 maxdouble 1 4 Defines how the barrier scales the objective
 -1 Let the optimizer decide.
 0 Scale by geometric mean.
 >=0 Scale such that the largest objective coefficient&prime;s largest element does not exceed this number. In quadratic problems, the quadratic diagonal is used as reference valuses instead of the linear objective.
barRhsScale double 7027000 -1 -1 maxdouble 1 4 Defines how the barrier scales the right hand side
 -1 Let the optimizer decide.
 0 Scale by geometric mean.
 >=0 Scale such that the largest right hand side coefficient&prime;s largest element does not exceed this number.
objScaleFactor integer 8387000 0 0 maxint 1 4 Custom objective scaling factor, expressed as a power of 2
scaling_rowScaling boolean 8010001 1 1 4 Row scaling
scaling_colScaling boolean 8010002 1 1 4 Column scaling
scaling_rowScalingAgain boolean 8010003 0 1 4 Row scaling again
scaling_maximum boolean 8010004 0 1 4 Maximum
scaling_curtisReid boolean 8010005 0 1 4 Curtis-Reid
scaling_byMaxElemNotGeoMean boolean 8010006 1 1 4 0: scale by geometric mean
scaling_bigM boolean 8010007 0 1 4 Treat big-M rows as normal rows
scaling_simplexObjScaling boolean 8010008 1 1 4 Scale objective function for the simplex method
scaling_ignoreQuadRowPart boolean 8010009 0 1 4 Exclude the quadratic part of constraint when calculating scaling factors
scaling_beforePresolve boolean 8010010 0 1 4 Scale before presolve
scaling_noScalingRowsUp boolean 8010011 0 1 4 Do not scale rows up
scaling_noScalingColsDown boolean 8010012 0 1 4 Do not scale columns down
scaling_disableGlobalObjScaling boolean 8010013 0 1 4 Do not apply automatic objective scaling
scaling_rhsScaling boolean 8010014 0 1 4 RHS scaling
scaling_noAggressiveQScaling boolean 8010015 0 1 4 Disable aggressive quadratic scaling
scaling_slackScaling boolean 8010016 0 1 4 Enable explicit linear slack scaling
autoPerturb boolean 8084000 1 1 5 Simplex: Indicates whether automatic perturbation is performed
 0 No perturbation performed.
 1 Automatic perturbation is performed.
bigM double 7018000 1024 0 maxdouble 1 5 Infeasibility penalty used if the "Big M" method is implemented
bigMMethod boolean 8068000 1 1 5 Simplex: Whether to use the "Big M" method, or the standard phase I (achieving feasibility) and phase II (achieving optimality)
 0 For phase I / phase II.
 1 If "Big M" method to be used.
crash integer 8012000 2 0 maxint 1 5 Simplex: Determines the type of crash used when the algorithm begins
 0 Turns off all crash procedures.
 1 For singletons only (one pass).
 2 For singletons only (multi pass).
 3 Multiple passes through the matrix considering slacks.
 4 Multiple (&le; 10) passes through the matrix but only doing slacks at the very end.
 bit 0 = 1 Perform standard crash.
 bit 1 = 2 Perform additional numerical checks during crash.
 bit 2 = 4 Extend the set of column candidates for crash.
 bit 3 = 8 Extend the set of row candidates for crash.
 bit 4 = 16 Force crash, i.e., consider all suitable columns/rows as candidates for crash.
 n>10 As for value 4 but performing at most n - 10 passes.
defaultAlg enumint 8023000 1 1 5 Selects the algorithm that will be used to solve the LP
 1 1 Automatically determined.
 2 1 Dual simplex.
 3 1 Primal simplex.
 4 1 Newton barrier (or hybrid gradient, if \ref XPRESSbarAlg "barAlg"=4 is set).
dualGradient enumint 8145000 -1 1 5 Simplex: Dual simplex pricing method
 -1 1 Determined automatically.
 0 1 Devex.
 1 1 Steepest edge.
 2 1 Direct steepest edge.
 3 1 Sparse Devex.
dualPerturb double 7025000 -1 mindouble maxdouble 1 5 Factor by which the problem will be perturbed prior to optimization by dual simplex
dualStrategy integer 8174000 1 0 5 1 5 Bit-vector control specifies the dual simplex strategy
 bit 0 = 1 Switch to primal when re-optimization goes dual infeasible and numerically unstable.
 bit 1 = 2 When dual intend to switch to primal, stop the solve instead of switching to primal.
 bit 2 = 4 Use more aggressive cut-off in MIP search.
 bit 3 = 8 Use dual simplex to remove cost perturbations.
 bit 4 = 16 Enable more aggressive dual pivoting strategy.
 bit 5 = 32 Keep using dual simplex even when it&prime;s numerically unstable.
etaTol double 7007000 1e-13 0 maxdouble 1 5 Tolerance on eta elements
feasTol double 7003000 1e-06 0 maxdouble 1 5 Determines when a solution is treated as feasible
feasTolPerturb double 7132000 1e-06 0 maxdouble 1 5 Determines how much a feasible primal basic solution is allowed to be perturbed when performing basis changes
feasTolTarget double 7121000 0 mindouble maxdouble 1 5 Target feasibility tolerance for the solution refiner
forceParallelDual boolean 8265000 0 1 5 Dual simplex: Specifies whether the dual simplex solver should always use the parallel simplex algorithm
 0 Disabled.
 1 Enabled. Force the dual simplex solver to use the parallel algorithm.
invertFreq integer 8014000 -1 -1 maxint 1 5 Simplex: Frequency with which the basis will be inverted
invertMin integer 8015000 3 0 maxint 1 5 Simplex: Minimum number of iterations between full inversions of the basis matrix
lpFlags integer 8385000 0 minint maxint 1 5 Bit-vector control which defines the algorithm for solving an LP problem or the initial LP relaxation of a MIP problem
 bit 0 = 1 Equivalent to \ref XPRESSlpFlags_dual "lpFlags_dual".
 bit 1 = 2 Equivalent to \ref XPRESSlpFlags_primal "lpFlags_primal".
 bit 2 = 4 Equivalent to \ref XPRESSlpFlags_barrier "lpFlags_barrier".
 bit 3 = 8 Equivalent to \ref XPRESSlpFlags_network "lpFlags_network".
lpFlags_dual boolean 8385001 0 1 5 Use the dual simplex method
lpFlags_primal boolean 8385002 0 1 5 Use the primal simplex method
lpFlags_barrier boolean 8385003 0 1 5 Use the barrier method (or hybrid gradient method if \ref XPRESSbarAlg "barAlg"=4 is set)
lpFlags_network boolean 8385004 0 1 5 Use the network simplex method
lpLog integer 8009000 100 minint maxint 1 5 Simplex: Frequency at which the simplex log is printed
 0 Log displayed at the end of the optimization only.
 n<0 Detailed output every - n iterations.
 n>0 Summary output every n iterations.
lpLogDelay double 7127000 1 0 maxdouble 1 5 Time interval between two LP log lines
lpLogStyle boolean 8326000 1 1 5 Simplex: Style of the simplex log
 0 Simplex log is printed based on simplex iteration count, at a fixed frequency as specified by the \ref XPRESSlpLog "lpLog" control.
 1 Simplex log is printed based on an estimation of elapsed time, determined by an internal deterministic timer.
markowitzTol double 7047000 0.01 0 maxdouble 1 5 Markowitz tolerance used for the factorization of the basis matrix
matrixTol double 7001000 1e-09 0 maxdouble 1 5 Zero tolerance on matrix elements
optimalityTol double 7006000 1e-06 0 maxdouble 1 5 Simplex: Zero tolerance for reduced costs
optimalityTolTarget double 7122000 0 mindouble maxdouble 1 5 Target optimality tolerance for the solution refiner
penalty double 7016000 0 0 maxdouble 1 5 Minimum absolute penalty variable coefficient
pivotTol double 7002000 1e-09 0 maxdouble 1 5 Simplex: Zero tolerance for matrix elements
pricingAlg enumint 8013000 0 1 5 Simplex: Determines the primal simplex pricing method
 -1 1 Partial pricing.
 0 1 Determined automatically.
 1 1 Devex pricing.
 2 1 Steepest edge.
 3 1 Steepest edge with unit initial weights.
primalPerturb double 7024000 -1 mindouble maxdouble 1 5 Factor by which the problem will be perturbed prior to optimization by primal simplex
primalUnshift boolean 8252000 0 1 5 Determines whether primal is allowed to call dual to unshift
 0 Allow the dual algorithm to be used to unshift.
 1 Don&prime;t allow the dual algorithm to be used to unshift.
relPivotTol double 7008000 1e-06 0 maxdouble 1 5 Simplex: Minimum size of pivot element relative to largest element in column
sifting enumint 8319000 -1 1 5 Determines whether to enable sifting algorithm with the dual simplex method
 -1 1 Automatically determined.
 0 1 Disable sifting.
 1 1 Enable sifting.
siftPasses integer 8022000 4 0 maxint 1 5 Determines how quickly we allow to grow the worker problems during the sifting algorithm
netStallLimit integer 8412000 -1 -1 maxint 1 5 Limit the number of degenerate pivots of the network simplex algorithm, before switching to either primal or dual simplex, depending on \ref XPRESSalgAfterNetwork "algAfterNetwork"
 -1 Automatically determined limit
 0 No limit.
 n>0 Limit to n network simplex iterations.
siftSwitch integer 8425000 -1 -1 maxint 1 5 Determines which algorithm to use for solving the subproblems during sifting
 -1 Dual simplex.
 0 Barrier.
 >0 Use the barrier algorithm while the number of dual infeasibilities is larger than this value, otherwise use dual simplex.
ppFactor double 7069000 1 0 maxdouble 1 5 Partial pricing candidate list sizing parameter
algAfterNetwork enumint 8129000 -1 1 5 Algorithm to be used for the clean up step after the network simplex solver
 -1 1 Automatically determined.
 2 1 Dual simplex.
 3 1 Primal simplex.
primalOps integer 8231000 -1 minint maxint 1 5 Primal simplex: Allows fine tuning the variable selection in the primal simplex solver
 bit 0 = 1 Use aggressive dj scaling.
 bit 1 = 2 Conventional dj scaling.
 bit 2 = 4 Use reluctant switching back to partial pricing.
 bit 3 = 8 Use dynamic switching between cheap and expensive pricing strategies.
 bit 4 = 16 Keep solving even after potential cycling is detected.
eigenvalueTol double 7097000 1e-06 0 maxdouble 1 6 Quadratic matrix is considered not to be positive semi-definite, if its smallest eigenvalue is smaller than the negative of this value
ifCheckConvexity boolean 8251000 1 1 6 Determines if the convexity of the problem is checked before optimization
 0 Turn off convexity checking.
 1 Turn on convexity checking.
qSimplexOps integer 8288000 0 0 maxint 1 6 Controls the behavior of the quadratic simplex solvers via a bit-vector
 bit 0 = 1 Force traditional primal first phase.
 bit 1 = 2 Force BigM primal first phase.
 bit 2 = 4 Force traditional dual first phase.
 bit 3 = 8 Force BigM dual first phase.
 bit 4 = 16 Always use artificial bounds in dual.
 bit 5 = 32 Use original problem basis only when warmstarting the KKT.
 bit 6 = 64 Skip the primal bound flips for ranged primals (might cause more trouble than good if the bounds are very large).
 bit 7 = 128 Also do the single pivot crash.
 bit 8 = 256 Do not apply aggressive perturbation in dual.
 bit 9 = 512 Applies standard scaling to the KKT system.
 bit 10 = 1024 Do not fall back to using Barrier in case of numerical difficulties with quadratic simplex during a MIP solve.
 bit 11 = 2048 Use primal simplex to solve the phase 1 feasibility problem before applying quadratic primal simplex.
 bit 12 = 4096 Use dual simplex to solve the phase 1 feasibility problem before applying quadratic primal simplex.
 bit 13 = 8192 Use barrier algorithm to solve the phase 1 feasibility problem before applying quadratic primal simplex.
 bit 14 = 16384 Use partial pricing.
 bit 15 = 32768 Use full pricing.
 bit 16 = 65536 Perform cleanup if a superbasic solution is provided for warm-start.
quadraticUnshift enumint 8284000 -1 1 6 Determines whether an extra solution purification step is called after a solution found by the quadratic simplex (either primal or dual)
 -1 1 Determined automatically.
 0 1 No purification step.
 1 1 Always do the purification step.
repairIndefInitEq boolean 8254000 1 1 6 Controls if the optimizer should make indefinite quadratic matrices positive definite when it is possible
 0 Repair if possible.
 1 Do not repair.
backTrack enumint 8027000 3 1 9 Branch and Bound: Specifies how to select the next node to work on when a full backtrack is performed
 -1 1 Automatically determined.
 1 1 Unused.
 2 1 Select the node with the best estimated solution.
 3 1 Select the node with the best bound on the solution.
 4 1 Select the deepest node in the search tree (equivalent to depth-first search).
 5 1 Select the highest node in the search tree (equivalent to breadth-first search).
 6 1 Select the earliest node created.
 7 1 Select the latest node created.
 8 1 Select a node randomly.
 9 1 Select the node whose LP relaxation contains the fewest number of infeasible MIP entities.
 10 1 Combination of 2 and 9.
 11 1 Combination of 2 and 4.
 12 1 Combination of 3 and 4.
backtrackTie enumint 8266000 -1 1 9 Branch and Bound: Specifies how to break ties when selecting the next node to work on when a full backtrack is performed
 -1 1 Default selection.
 1 1 Unused.
 2 1 Select the node with the best estimated solution.
 3 1 Select the node with the best bound on the solution.
 4 1 Select the deepest node in the search tree (equivalent to depth-first search).
 5 1 Select the highest node in the search tree (equivalent to breadth-first search).
 6 1 Select the earliest node created.
 7 1 Select the latest node created.
 8 1 Select a node randomly.
 9 1 Select the node whose LP relaxation contains the fewest number of infeasible MIP entities.
 10 1 Combination of 2 and 9.
 11 1 Combination of 2 and 4.
 12 1 Combination of 3 and 4.
branchChoice enumint 8162000 0 1 9 Once a MIP entity has been selected for branching, this control determines which of the branches is solved first
 0 1 Minimum estimate branch first.
 1 1 Maximum estimate branch first.
 2 1 If an incumbent solution exists, solve the branch satisfied by that solution first. Otherwise solve the minimum estimate branch first (option 0).
 3 1 Solve first the branch that forces the value of the branching variable to move farther away from the value it had at the root node. If the branching entity is not a simple variable, solve the minimum estimate branch first (option 0).
branchDisj enumint 8267000 -1 1 9 Branch and Bound: Determines whether the optimizer should attempt to branch on general split disjunctions during the branch and bound search
 -1 1 Automatic selection of the strategy.
 0 1 Disabled.
 1 1 Cautious strategy. Disjunctive branches will be created only for general integers with a wide range.
 2 1 Moderate strategy.
 3 1 Aggressive strategy. Disjunctive branches will be created for both binaries and integers.
branchStructural enumint 8282000 -1 1 9 Branch and Bound: Determines whether the optimizer should search for special structure in the problem to branch on during the branch and bound search
 -1 1 Automatically determined.
 0 1 Disabled.
 1 1 Enabled.
breadthFirst integer 8082000 11 0 maxint 1 9 Number of nodes to include in the best-first search before switching to the local first search (\ref XPRESSnodeSelection "nodeSelection" = 4)
deterministic integer 8232000 1 0 2 1 9 Selects whether to use a deterministic or opportunistic mode when solving a problem using multiple threads
 0 Use opportunistic mode.
 1 Use deterministic mode.
 2 Use deterministic mode, except allow the initial concurrent continuous solve of a MIP to be opportunistic.
feasibilityPump enumint 8193000 -1 1 9 Branch and Bound: Decides if the Feasibility Pump heuristic should be run at the root node
 -1 1 Automatic.
 0 1 Turned off.
 1 1 Always try the Feasibility Pump.
 2 1 Try the Feasibility Pump only if other heuristics have failed to find an integer solution.
genConsDualReductions boolean 8395000 1 1 9 Parameter specifies whether dual reductions should be applied to reduce the number of columns and rows added when transforming general constraints to MIP structs
 0 Disabled. No dual reductions, add columns and rows.
 1 Enabled. Only add neccessary columns and rows, drop those implied by the objective sense.
historyCosts enumint 8206000 -1 1 9 Branch and Bound: How to update the pseudo cost for a MIP entity when a strong branch or a regular branch is applied
 -1 1 Automatically determined.
 0 1 No update.
 1 1 Update using only regular branches from the root to the current node.
 2 1 Same as 1, but update with strong branching results as well.
 3 1 Update using any regular branching or strong branching information from all nodes solves before the current node.
localChoice enumint 8170000 3 1 9 Controls when to perform a local backtrack between the two child nodes during a dive in the branch and bound tree
 1 1 Never backtrack from the first child, unless it is dropped (infeasible or cut off).
 2 1 Always solve both child nodes before deciding which child to continue with.
 3 1 Automatically determined.
maxLocalBacktrack integer 8257000 -1 -1 maxint 1 9 Branch-and-Bound: How far back up the current dive path the optimizer is allowed to look for a local backtrack candidate node
 -1 Automatic.
 n>0 Local backtrack limit.
maxMipSol integer 8021000 0 0 maxint 1 9 Branch and Bound: Limit on the number of integer solutions to be found by the Optimizer
maxMipTasks integer 8347000 -1 -1 maxint 1 9 Branch-and-Bound: The maximum number of tasks to run in parallel during a MIP solve
 -1 Task limit determined automatically from \ref XPRESSmipThreads "mipThreads".
 >0 Fixed task limit.
maxNode integer 8018000 maxint 0 maxint 1 9 Branch and Bound: Maximum number of nodes that will be explored
mipAbsCutoff double 7013000 0 mindouble maxdouble 1 9 Branch and Bound: If the user knows that they are interested only in values of the objective function which are better than some value, this can be assigned to \ref XPRESSmipAbsCutoff "mipAbsC****
mipAbsStop double 7019000 0 0 maxdouble 1 9 Branch and Bound: Absolute tolerance determining whether the tree search will continue or not
mipAddCutoff double 7012000 0 mindouble maxdouble 1 9 Branch and Bound: Amount to add to the objective function of the best integer solution found to give the new CURRMIPCUTOFF
mipDualReductions enumint 8392000 1 1 9 Branch and Bound: Limits operations that can reduce the MIP solution space
 0 1 Prevent all dual reductions.
 1 1 Allow all dual reductions.
 2 1 Allow dual reductions on continuous variables only.
mipFracReduce enumint 8270000 -1 1 9 Branch and Bound: Specifies how often the optimizer should run a heuristic to reduce the number of fractional integer variables in the node LP solutions
 -1 1 Automatic.
 0 1 Disabled.
 1 1 Run before and after cutting on the root node.
 2 1 Run also during root cutting.
 3 1 Run also during the tree search.
mipKappaFreq integer 8386000 0 0 maxint 1 9 Branch and Bound: Specifies how frequently the basis condition number (also known as kappa) should be calculated during the branch-and-bound search
 0 Do not calculate condition numbers.
 1 Calculate conditions numbers on every node, including after each round of root cutting.
 n>1 Calculate a condition number once per node of every n&prime;th level of the branch-and-bound tree.
mipLog integer 8028000 -100 minint maxint 1 9 MIP log print control
 0 No printout during MIP tree search.
 1 Only print out summary statement at the end.
 2 Print out detailed log at all solutions found.
 3 Print out detailed log at each node.
 -n Print out summary log at each n th node.
mipRampUp enumint 8255000 -1 1 9 Controls the strategy used by the parallel MIP solver during the ramp-up phase of a branch-and-bound tree search
 -1 1 Automatically determined.
 0 1 No special treatment during the ramp-up phase. Always run with the maximal number of tasks.
 1 1 Limit the number of tasks until the initial dives have completed.
mipRefineIterLimit integer 8095000 -1 -1 maxint 1 9 Defines an effort limit expressed as simplex iterations for the MIP solution refiner
mipRelCutoff double 7014000 0 0 maxdouble 1 9 Branch and Bound: Percentage of the incumbent value to be added to the value of the objective function when an integer solution is found, to give the new value of CURRMIPCUTOFF
mipRelStop double 7020000 0.0001 0 maxdouble 1 9 Branch and Bound: Determines when the branch and bound tree search will terminate
mipRestart enumint 8290000 -1 1 9 Branch and Bound: Controls strategy for in-tree restarts
 -1 1 Determined automatically (XPRS_MIPRESTART_DEFAULT).
 0 1 Disable in-tree restarts (XPRS_MIPRESTART_OFF).
 1 1 Allow in-tree restarts at normal aggressiveness (XPRS_MIPRESTART_MODERATE).
 2 1 Allow in-tree restarts at higher aggressiveness (more likely to trigger a restart) (XPRS_MIPRESTART_AGGRESSIVE).
mipTol double 7009000 5e-06 0 maxdouble 1 9 Branch and Bound: Tolerance within which a decision variable&prime;s value is considered to be integral
mipToltarget double 7010000 0 mindouble maxdouble 1 9 Target \ref XPRESSmipTol "mipTol" value used by the automatic MIP solution refiner as defined by \ref XPRESSrefineOps "refineOps"
miqcpAlg enumint 8125000 -1 1 9 Determines which algorithm is to be used to solve mixed integer quadratic constrained and mixed integer second order cone problems
 -1 1 Determined automatically.
 0 1 Use the barrier algorithm in the branch and bound algorithm.
 1 1 Use outer approximations in the branch and bound algorithm.
nodeSelection enumint 8026000 4 1 9 Branch and Bound: Determines which nodes will be considered for solution once the current node has been solved
 1 1 Local first: Choose between descendant and sibling nodes if available; choose from all outstanding nodes otherwise.
 2 1 Best first: Choose from all outstanding nodes.
 3 1 Local depth first: Choose between descendant and sibling nodes if available; choose from the deepest nodes otherwise.
 4 1 Best first, then local first: Best first is used for the first \ref XPRESSbreadthFirst "breadthFirst" nodes, after which local first is used.
 5 1 Pure depth first: Choose from the deepest outstanding nodes.
pseudoCost double 7015000 0.01 0 maxdouble 1 9 Branch and Bound: Default pseudo cost used in estimation of the degradation associated with an unexplored node in the tree search
qcRootAlg enumint 8127000 -1 1 9 Determines which algorithm is to be used to solve the root of a mixed integer quadratic constrained or mixed integer second order cone problem, when outer approximation is used
 -1 1 Determined automatically.
 0 1 Use the barrier algorithm.
 1 1 Use the dual simplex on a relaxation of the problem constructed using outer approximation.
sbBest integer 8147000 -1 -1 maxint 1 9 Number of infeasible MIP entities to initialize pseudo costs for on each node
 -1 Determined automatically.
 0 Disable strong branching.
 n>0 Perform strong branching on up to n entities at each node.
sbEffort double 7086000 1 0 maxdouble 1 9 Adjusts the overall amount of effort when using strong branching to select an infeasible MIP entity to branch on
sbEstimate integer 8198000 -1 -1 6 1 9 Branch and Bound: How to calculate pseudo costs from the local node when selecting an infeasible MIP entity to branch on
 -1 Automatically determined.
 1-6 Different variants of local pseudo costs.
sbIterLimit integer 8146000 -1 -1 maxint 1 9 Number of dual iterations to perform the strong branching for each entity
sbSelect integer 8164000 -2 -2 maxint 1 9 Size of the candidate list of MIP entities for strong branching
 -2 Automatic (low effort).
 -1 Automatic (high effort).
 n>=0 Include n entities in the candidate list (but always at least \ref XPRESSsbBest "sbBest" candidates).
sleepOnThreadWait enumint 8302000 -1 0 9 Parameter is deprecated and will be removed in a future release
 -1 1 Automatically determined depending on the CPU the Optimizer is running on.
 0 1 Keep the threads busy when waiting for work.
 1 1 Put the threads into a wait state when waiting for work.
sosRefTol double 7005000 1e-06 0 maxdouble 1 9 Minimum relative gap between the ordering values of elements in a special ordered set
symmetry enumint 8118000 1 1 9 Adjusts the overall amount of effort for symmetry detection
 0 1 No symmetry detection.
 1 1 Conservative effort.
 2 1 Intensive symmetry search.
symSelect integer 8117000 -1 -1 1 1 9 Adjusts the overall amount of effort for symmetry detection
 0 Search the whole matrix (otherwise the 0, 1 and -1 coefficients only).
 1 Search all entities (otherwise binaries only).
varSelection enumint 8025000 -1 1 9 Branch and Bound: Determines the formula used to calculate the estimate of each integer variable, and thus which integer variable is selected to be branched on at a given node
 -1 1 Determined automatically.
 1 1 The minimum of the &prime;up&prime; and &prime;down&prime; pseudo costs.
 2 1 The &prime;up&prime; pseudo cost plus the &prime;down&prime; pseudo cost.
 3 1 The maximum of the &prime;up&prime; and &prime;down&prime; pseudo costs, plus twice the minimum of the &prime;up&prime; and &prime;down&prime; pseudo costs.
 4 1 The maximum of the &prime;up&prime; and &prime;down&prime; pseudo costs.
 5 1 The &prime;down&prime; pseudo cost.
 6 1 The &prime;up&prime; pseudo cost.
 7 1 A weighted combination of the &prime;up&prime; and &prime;down&prime; pseudo costs, where the weights depend on how fractional the variable is.
 8 1 The product of the &prime;up&prime; and &prime;down&prime; pseudo costs.
mipRestartGapThreshold double 7140000 0.02 0 1 1 9 Branch and Bound: Initial gap threshold to delay in-tree restart
nodeProbingEffort double 7141000 1 0 maxdouble 1 9 Adjusts the overall level of node probing
mipRestartFactor double 7145000 1 0 maxdouble 1 9 Branch and Bound: Fine tune initial conditions to trigger an in-tree restart
genConsAbsTransformation enumint 8408000 -1 1 9 Specifies the reformulation method for absolute value general constraints at the beginning of the search
 -1 1 Automatic.
 0 1 Use a formulation based on indicator constraints.
 1 1 Use a formulation based on SOS1-constraints.
mipComponents enumint 8421000 -1 1 9 Determines whether disconnected components in a MIP should be solved as separate MIPs
 -1 1 Automatic - let the solver decide.
 0 1 Disable solving disconnected components separately.
 1 1 Solve disconnected components separately.
mipConcurrentNodes integer 8422000 -1 -1 maxint 1 9 Sets the node limit for when a winning solve is selected when concurrent MIP solves are enabled
 -1 Automatic - let the solver decide on a node limit.
 >0 Number of nodes each concurrent solve should complete before a winner is selected.
mipConcurrentSolves integer 8423000 0 -1 maxint 1 9 Selects the number of concurrent solves to start for a MIP
 -1 Enabled. The number of concurrent solves depends on \ref XPRESSmipThreads "mipThreads".
 n>1 Enabled. The number of concurrent solves to start is given by n.
 0, 1 Disabled
maxStallTime double 8443000 0 0 maxdouble 1 9 Maximum time in seconds that the Optimizer will continue to search for improving solution after finding a new incumbent
 0 No stall time limit.
 >0 If an integer solution has been found, stop MIP search after the given number of seconds without a new incumbent. No effect as long as no solution was found.
conflictCuts enumint 8292000 -1 1 10 Branch and Bound: Specifies how cautious or aggressive the optimizer should be when searching for and applying conflict cuts
 -1 1 Automatic.
 0 1 Disable conflict cuts.
 1 1 Cautious application of conflict cuts.
 2 1 Medium application of conflict cuts.
 3 1 Aggressive application of conflict cuts.
coverCuts integer 8134000 -1 -1 maxint 1 10 Branch and Bound: Number of rounds of lifted cover inequalities at the root node
cutDepth integer 8139000 -1 -1 maxint 1 10 Branch and Bound: Sets the maximum depth in the tree search at which cuts will be generated
cutFactor double 7091000 -1 -1 maxdouble 1 10 Limit on the number of cuts and cut coefficients the optimizer is allowed to add to the matrix during tree search
 -1 Let the optimizer decide on the maximum amount of cuts based on \ref XPRESScutStrategy "cutStrategy".
 >=0 Multiple of number of rows and coefficients to use.
cutFreq integer 8116000 -1 -1 maxint 1 10 Branch and Bound: Frequency at which cuts are generated in the tree search
cutSelect integer 8142000 -1 minint maxint 1 10 Bit-vector providing detailed control of the cuts created for the root node of a MIP solve
 bit 5 = 32 Equivalent to \ref XPRESScutSelect_clique "cutSelect_clique".
 bit 6 = 64 Equivalent to \ref XPRESScutSelect_mir "cutSelect_mir".
 bit 7 = 128 Equivalent to \ref XPRESScutSelect_cover "cutSelect_cover".
 bit 8 = 256 Equivalent to \ref XPRESScutSelect_mirRowAggregation "cutSelect_mirRowAggregation".
 bit 11 = 2048 Equivalent to \ref XPRESScutSelect_flowpath "cutSelect_flowpath".
 bit 12 = 4096 Equivalent to \ref XPRESScutSelect_implication "cutSelect_implication".
 bit 13 = 8192 Equivalent to \ref XPRESScutSelect_liftAndProject "cutSelect_liftAndProject".
 bit 14 = 16384 Equivalent to \ref XPRESScutSelect_disableCutRows "cutSelect_disableCutRows".
 bit 15 = 32768 Equivalent to \ref XPRESScutSelect_gubCover "cutSelect_gubCover".
 bit 16 = 65536 Equivalent to \ref XPRESScutSelect_zeroHalf "cutSelect_zeroHalf".
 bit 17 = 131072 Equivalent to \ref XPRESScutSelect_indicator "cutSelect_indicator".
 bit 18 = 262144 Equivalent to \ref XPRESScutSelect_gomory "cutSelect_gomory".
 bit 20 = 1048576 Equivalent to \ref XPRESScutSelect_farkas "cutSelect_farkas".
cutSelect_clique boolean 8142006 1 1 10 Clique cuts
cutSelect_mir boolean 8142007 1 1 10 Mixed Integer Rounding (MIR) cuts
cutSelect_cover boolean 8142008 1 1 10 Lifted cover cuts
cutSelect_mirRowAggregation boolean 8142009 1 1 10 Turn on row aggregation for MIR cuts
cutSelect_flowpath boolean 8142012 1 1 10 Flow path cuts
cutSelect_implication boolean 8142013 1 1 10 Implication cuts
cutSelect_liftAndProject boolean 8142014 1 1 10 Turn on automatic Lift-and-Project cutting strategy
cutSelect_disableCutRows boolean 8142015 1 1 10 Disable cutting from cut rows
cutSelect_gubCover boolean 8142016 1 1 10 Lifted GUB cover cuts
cutSelect_zeroHalf boolean 8142017 1 1 10 Zero-half cuts
cutSelect_indicator boolean 8142018 1 1 10 Indicator constraint cuts
cutSelect_gomory boolean 8142019 1 1 10 Strong Chvatal-Gomory cuts
cutSelect_farkas boolean 8142021 1 1 10 Farkas cuts
cutStrategy enumint 8138000 -1 1 10 Branch and Bound: Cut strategy
 -1 1 Automatic selection of the cut strategy.
 0 1 No cuts.
 1 1 Conservative cut strategy.
 2 1 Moderate cut strategy.
 3 1 Aggressive cut strategy.
gomCuts integer 8135000 -1 -1 maxint 1 10 Branch and Bound: Number of rounds of Gomory or lift-and-project cuts at the root node
lnpBest integer 8160000 50 0 maxint 1 10 Number of infeasible MIP entities to create lift-and-project cuts for during each round of Gomory cuts at the root node (see \ref XPRESSgomCuts "gomCuts")
lnpIterLimit integer 8161000 -1 -1 maxint 1 10 Number of iterations to perform in improving each lift-and-project cut
maxCutTime double 8149000 0 0 maxdouble 1 10 Maximum amount of time allowed for generation of cutting planes and reoptimization
 0 No time limit.
 >0 Stop cut generation after the given number of seconds.
qcCuts integer 8126000 -1 -1 maxint 1 10 Branch and Bound: Limit on the number of rounds of outer approximation cuts generated for the root node, when solving a mixed integer quadratic constrained or mixed integer second order conic problem with ****
treeCoverCuts integer 8140000 -1 -1 maxint 1 10 Branch and Bound: Number of rounds of lifted cover inequalities generated at nodes other than the root node in the tree
treeCutSelect integer 8143000 -1 minint maxint 1 10 Bit-vector providing detailed control of the cuts created during the tree search of a MIP solve
 bit 5 = 32 Equivalent to \ref XPRESStreeCutSelect_clique "treeCutSelect_clique".
 bit 6 = 64 Equivalent to \ref XPRESStreeCutSelect_mir "treeCutSelect_mir".
 bit 7 = 128 Equivalent to \ref XPRESStreeCutSelect_cover "treeCutSelect_cover".
 bit 8 = 256 Equivalent to \ref XPRESStreeCutSelect_mirRowAggregation "treeCutSelect_mirRowAggregation".
 bit 11 = 2048 Equivalent to \ref XPRESStreeCutSelect_flowpath "treeCutSelect_flowpath".
 bit 12 = 4096 Equivalent to \ref XPRESStreeCutSelect_implication "treeCutSelect_implication".
 bit 13 = 8192 Equivalent to \ref XPRESStreeCutSelect_liftAndProject "treeCutSelect_liftAndProject".
 bit 14 = 16384 Equivalent to \ref XPRESStreeCutSelect_disableCutRows "treeCutSelect_disableCutRows".
 bit 15 = 32768 Equivalent to \ref XPRESStreeCutSelect_gubCover "treeCutSelect_gubCover".
 bit 16 = 65536 Equivalent to \ref XPRESStreeCutSelect_zeroHalf "treeCutSelect_zeroHalf".
 bit 17 = 131072 Equivalent to \ref XPRESStreeCutSelect_indicator "treeCutSelect_indicator".
 bit 18 = 262144 Equivalent to \ref XPRESStreeCutSelect_gomory "treeCutSelect_gomory".
 bit 20 = 1048576 Equivalent to \ref XPRESStreeCutSelect_farkas "treeCutSelect_farkas".
treeCutSelect_clique boolean 8143006 1 1 10 Clique cuts
treeCutSelect_mir boolean 8143007 1 1 10 Mixed Integer Rounding (MIR) cuts
treeCutSelect_cover boolean 8143008 1 1 10 Lifted cover cuts
treeCutSelect_mirRowAggregation boolean 8143009 1 1 10 Turn on row aggregation for MIR cuts
treeCutSelect_flowpath boolean 8143012 1 1 10 Flow path cuts
treeCutSelect_implication boolean 8143013 1 1 10 Implication cuts
treeCutSelect_liftAndProject boolean 8143014 1 1 10 Turn on automatic Lift and Project cutting strategy
treeCutSelect_disableCutRows boolean 8143015 1 1 10 Disable cutting from cut rows
treeCutSelect_gubCover boolean 8143016 1 1 10 Lifted GUB cover cuts
treeCutSelect_zeroHalf boolean 8143017 1 1 10 Zero-half cuts
treeCutSelect_indicator boolean 8143018 1 1 10 Indicator constraint cuts
treeCutSelect_gomory boolean 8143019 1 1 10 Strong Chvatal-Gomory cuts
treeCutSelect_farkas boolean 8143021 1 1 10 Farkas cuts
treeGomCuts integer 8141000 -1 -1 maxint 1 10 Branch and Bound: Number of rounds of Gomory cuts generated at nodes other than the first node in the tree
treeQCCuts integer 8331000 -1 -1 maxint 1 10 Branch and Bound: Limit on the number of rounds of outer approximation cuts generated for nodes other than the root node, when solving a mixed integer quadratic constrained or mixed integer second orde****
autoCutting enumint 8446000 -1 1 10 Automatically decide whether to generate cutting planes at local nodes in the tree
 -1 1 Automatic.
 0 1 Disabled.
 1 1 Enabled.
mcfCutStrategy enumint 8486000 -1 1 10 Level of Multi-Commodity Flow (MCF) cutting planes separation: This specifies how much aggresively MCF cuts should be separated
 -1 1 Automatic - let the Optimizer decide.
 0 1 Separation of MCF cuts disabled.
 1 1 Moderate separation of MCF cuts.
 2 1 Aggressive separation of MCF cuts.
heurBeforeLp enumint 8280000 -1 1 11 Branch and Bound: Determines whether primal heuristics should be run before the initial LP relaxation has been solved
 -1 1 Automatic - let the optimizer decide if heuristics should be run.
 0 1 Disabled.
 1 1 Enabled.
heurDiveIterLimit double 7128000 -1 mindouble maxdouble 1 11 Branch and Bound: Simplex iteration limit for reoptimizing during the diving heuristic
 0 No iteration limit.
 >=1 Fixed iteration limit.
 <0 Automatic selection of the iteration limit based on the problem size. The absolute value is used as a multiplier on the automatic selection.
heurDiveRandomize double 7089000 0 0 1 1 11 Level of randomization to apply in the diving heuristic
 0.0-1.0 Amount of randomization (0.0=none, 1.0=full)
heurDiveSoftRounding enumint 8215000 -1 1 11 Branch and Bound: Enables a more cautious strategy for the diving heuristic, where it tries to push binaries and integer variables to their bounds using the objective, instead of directly fixing them
 -1 1 Automatic selection.
 0 1 Do not use soft rounding.
 1 1 Cautious use of the soft rounding strategy.
 2 1 More aggressive use of the soft rounding strategy.
heurDiveSpeedUp integer 8197000 -1 -2 4 1 11 Branch and Bound: Changes the emphasis of the diving heuristic from solution quality to diving speed
 -2 Automatic selection biased towards quality
 -1 Automatic selection biased towards speed.
 0-4 Manual emphasis bias from emphasis on quality (0) to emphasis on speed (4).
heurDiveStrategy integer 8177000 -1 -1 18 1 11 Branch and Bound: Chooses the strategy for the diving heuristic
 -1 Automatic selection of strategy.
 0 Disables the diving heuristic.
 1-18 Available pre-set strategies for rounding infeasible MIP entities and reoptimizing during the heuristic dive.
heurForceSpecialObj boolean 8350000 0 1 11 Branch and Bound: Whether local search heuristics without objective or with an auxiliary objective should always be used, despite the automatic selection of the Optimizer
 0 Disabled.
 1 Enabled. Run special objective heuristics on large problems and even if incumbent exists.
heurFreq integer 8155000 -1 -1 maxint 1 11 Branch and Bound: Frequency at which heuristics are used in the tree search
heurSearchEffort double 7090000 1 0 maxdouble 1 11 Adjusts the overall level of the local search heuristics
heurSearchFreq integer 8196000 -1 -1 maxint 1 11 Branch and Bound: How often the local search heuristic should be run in the tree
 -1 Automatic.
 0 Disabled in the tree.
 n>0 Number of nodes between each run.
heurSearchRootCutFreq integer 8351000 -1 -1 maxint 1 11 How frequently to run the local search heuristic during root cutting
 -1 Automatic.
 0 Disabled heuristic during cutting.
 n>0 Number of cutting rounds between each run.
heurSearchRootSelect integer 8216000 117 0 maxint 1 11 Bit-vector control for selecting which local search heuristics to apply on the root node of a MIP solve
 bit 0 = 1 Local search with a large neighborhood. Potentially slow but is good for finding solutions that differs significantly from the incumbent.
 bit 1 = 2 Local search with a small neighborhood centered around a node LP solution.
 bit 2 = 4 Local search with a small neighborhood centered around an integer solution. This heuristic will often provide smaller, incremental improvements to an incumbent solution.
 bit 3 = 8 Local search with a neighborhood set up through the combination of multiple integer solutions.
 bit 4 = 16 Unused
 bit 5 = 32 Local search without an objective function. Called seldom and only when no feasible solution is available.
 bit 6 = 64 Local search with an auxiliary objective function. Called seldom and only when no feasible solution is available.
heurSearchTreeSelect integer 8217000 17 0 maxint 1 11 Bit-vector control for selecting which local search heuristics to apply during the tree search of a MIP solve
 bit 0 = 1 Local search with a large neighborhood. Potentially slow but is good for finding solutions that differs significantly from the incumbent.
 bit 1 = 2 Local search with a small neighborhood centered around a node LP solution.
 bit 2 = 4 Local search with a small neighborhood centered around an integer solution. This heuristic will often provide smaller, incremental improvements to an incumbent solution.
 bit 3 = 8 Local search with a neighborhood set up through the combination of multiple integer solutions.
 bit 4 = 16 Unused
 bit 5 = 32 Local search without an objective function. Called seldom and only when no feasible solution is available.
 bit 6 = 64 Local search with an auxiliary objective function. Called seldom and only when no feasible solution is available.
heurEmphasis enumint 8427000 -1 1 11 Branch and Bound: Specifies an emphasis for the search w.r.t. primal heuristics and other procedures that affect the speed of convergence of the primal-dual gap
 -1 1 Optimizer default strategy.
 0 1 Disables all heuristics.
 1 1 Focus on reducing the primal-dual gap in the early part of the search.
 2 1 Extremely aggressive search heuristics.
feasibilityJump integer 8471000 -1 -1 3 1 11 MIP: Decides if the Feasibility Jump heuristic should be run
 -1 Use automatic settings.
 0 Turned off.
 1 Run the heuristic on models with all integer variables.
 2 Run the heuristic on models in which all non-integer variables have bounds [0,1].
 3 Run the heuristic on models in which all non-integer variables have integer bounds.
heurShiftProp enumint 8479000 -1 1 11 Determines whether the Shift-and-propagate primal heuristic should be executed
 -1 1 The solver decides if Shift-and-propagate should be run. This is the default setting.
 0 1 Shift-and-propagate is disabled.
 1 1 Shift-and-propagate is enabled.
preRootThreads integer 8490000 -1 -1 maxint 1 11 Specifies an explicit number of threads that should be used for the Pre-root parallel heuristic phase
 -1 Use all available threads.
 0 Disable pre-root parallel heuristics.
 n>0 Use the specified number of threads, superseding the value of \ref XPRESSthreads "threads"
preRootEffort double 7173000 -1 -2 maxdouble 1 11 Dial for the work spent during the Pre-root parallel heuristic phase
 -2 Enable Pre-root parallel heuristics without a specific work limit for this phase. The phase will terminate if a different limit is hit, or if it runs out of heuristic work to do.
 -1 Enablement of Pre-root parallel heuristics is subject to \ref XPRESSheurEmphasis "heurEmphasis".
 0 Disable Pre-root parallel heuristics.
 x>0 Enable Pre-root parallel heuristics with a work limit dependent on problem characteristics, using x as a factor to dial this work limit up or down.
preRootWorklimit double 7172000 -1 -1 maxdouble 1 11 Set an explicit work limit in work units for the Pre-root parallel heuristic phase
 -1 No explicit work limit for the Pre-root parallel heuristic phase. If enabled, the work limit for this phase is controlled via \ref XPRESSpreRootEffort "preRootEffort".
 0 Disable Pre-root parallel heuristics.
 x>0 Enable Pre-root parallel heuristics with an explicit work limit of x work units. If set, this work limit has precedence over any work limit set by \ref XPRESSpreRootEffort "preRootEffort".
solnpoolCullDiversity integer 6602000 -1 -1 maxint 1 12 Cull N solutions based on solution diversity
solnpoolCullObj integer 6601000 -1 -1 maxint 1 12 Cull N solutions based on objective values
solnpoolDupPolicy enumint 6203000 0 1 12 Policy to use when handling storage of duplicate solutions
 0 1 Keep all: All solutions are kept including duplicates.
 1 1 Continuous: All variables are compared with an exact match. Duplicate solutions are discarded.
 2 1 Discrete and continuous separate: Both the discrete component of a solution pair and the continuous solution variables are compared. The continuous variables are compared with an exact match. Duplicate solutions are discarded.
 3 1 Discrete only: Only the discrete component of a solution pair is compared. Duplicate solutions are discarded.
algAfterCrossover enumint 8208000 1 1 7 Algorithm to be used for the final clean up step after the crossover
 1 1 Automatically determined.
 2 1 Dual simplex.
 3 1 Primal simplex.
 4 1 Concurrent.
barAlg enumint 8315000 -1 1 7 Determines which barrier algorithm is used to solve the problem
 -1 1 Determined automatically.
 0 1 Unused.
 1 1 Use the infeasible-start barrier algorithm.
 2 1 Use the homogeneous self-dual barrier algorithm.
 3 1 Start with 2 and optionally switch to 1 during the execution.
 4 1 Use the hybrid gradient algorithm.
barCrash integer 8211000 4 0 6 1 7 Newton barrier and hybrid gradient: Determines the type of crash used for the crossover
 0 Turns off all crash procedures.
 1-6 Available strategies with 1 being conservative and 6 being aggressive.
barDualStop double 7034000 0 0 maxdouble 1 7 Newton barrier and hybrid gradient: Convergence parameter, representing the tolerance for dual infeasibilities
barFailIterLimit integer 8398000 0 0 maxint 1 7 Newton barrier: Maximum number of consecutive iterations that fail to improve the solution in the barrier algorithm
 0 Determined automatically
 >0 Maximum number of consecutive barrier iterations allowed without progress.
barGapStop double 7033000 0 0 maxdouble 1 7 Newton barrier and hybrid gradient: Convergence parameter, representing the tolerance for the relative duality gap
barGapTarget double 7073000 0 0 maxdouble 1 7 Newton barrier: Target tolerance for the relative duality gap
barIndefLimit integer 8153000 15 1 maxint 1 7 Newton Barrier: Limits the number of consecutive indefinite barrier iterations that will be performed
barIterLimit integer 8045000 500 0 maxint 1 7 Newton barrier: Maximum number of iterations
barKernel double 7130000 0 mindouble maxdouble 1 7 Newton barrier: Defines how centrality is weighted in the barrier algorithm
 >=+1.0 Increases the emphasis on centrality when larger value is set.
 <=-1.0 Selects a value adaptively in every iteration from [+1, -\ref XPRESSbarKernel "barKernel"].
barOrder enumint 8080000 0 1 7 Newton barrier: Controls the Cholesky factorization in the Newton-Barrier
 0 1 Choose automatically.
 1 1 Minimum degree method. This selects diagonal elements with the smallest number of nonzeros in their rows or columns.
 2 1 Minimum local fill method. This considers the adjacency graph of nonzeros in the matrix and seeks to eliminate nodes that minimize the creation of new edges.
 3 1 Nested dissection method. This considers the adjacency graph and recursively seeks to separate it into non-adjacent pieces.
barOutput boolean 8047000 1 1 7 Newton barrier and hybrid gradient: Level of solution output provided
 0 No output.
 1 At each iteration.
barPrimalStop double 7035000 0 0 maxdouble 1 7 Newton barrier and hybrid gradient: Convergence parameter, indicating the tolerance for primal infeasibilities
barRegularize integer 8163000 -1 minint maxint 1 7 Bit-vector control determines how the barrier algorithm applies regularization on the KKT system
 bit 0 = 1 Standard regularization is turned on/off.
 bit 1 = 2 Reduced regularization is turned on/off. This option reduces the perturbation effect of the standard regularization.
 bit 2 = 4 Forces to keep dependent rows in the KKT system.
 bit 3 = 8 Forces to preserve degenerate rows in the KKT system.
 bit 4 = 16 Restrict regularization to infeasible iterates.
 bit 5 = 32 Disable iterative regularizations.
 bit 6 = 64 Apply iterative regularization more often.
barStart enumint 8180000 0 1 7 Controls the computation of the starting point and warm-starting for the Newton barrier and the hybrid gradient algorithms
 -1 1 Uses the existing solution for warm-start if one is available.
 0 1 Warm-start is disabled; the starting point is determined automatically from the next three options.
 1 1 Uses simple heuristics to compute the starting point based on the magnitudes of the matrix entries.
 2 1 Uses the pseudoinverse of the constraint matrix to determine primal and dual initial solutions. Less sensitive to scaling and numerically more robust, but in several case less efficient than 1.
 3 1 Uses the unit starting point for the homogeneous self-dual barrier algorithm.
barStepStop double 7036000 1e-16 0 maxdouble 1 7 Newton barrier: Convergence parameter, representing the minimal step size
choleskyAlg integer 8046000 -1 -1 maxint 1 7 Newton barrier: Type of Cholesky factorization used; bit-vector-control
 bit 0 = 1 Matrix blocking: 0: automatic setting; 1: manual setting.
 bit 1 = 2 If manual selection of matrix blocking: 0: multi-pass; 1: single-pass.
 bit 2 = 4 Nonseparable QP relaxation: 0: off; 1: on.
 bit 3 = 8 Corrector weight: 0: automatic setting; 1: manual setting.
 bit 4 = 16 If manual selection of corrector weight: 0: off; 1: on.
 bit 5 = 32 Refinement: 0: automatic setting; 1: manual setting.
 bit 6 = 64 Preconditioned conjugate gradient method (PCGM): 0: PCGM off; 1: PCGM on.
 bit 7 = 128 Preconditioned quasi minimal residual (QMR) to refine solution: 0: QMR off; 1: QMR on.
 bit 8 = 256 Perform refinement on the augmented system 0: off; 1: on.
 bit 9 = 512 Force highest accuracy in refinement 0: off; 1: on.
choleskyTol double 7032000 1e-15 0 maxdouble 1 7 Newton barrier: Tolerance for pivot elements in the Cholesky decomposition of the normal equations coefficient matrix, computed at each iteration of the barrier algorithm
crossover enumint 8044000 -1 1 7 Newton barrier and hybrid gradient: Determines whether the barrier method will cross over to the simplex method when at optimal solution has been found, to provide an end basis and advanced sensitivity analysis in****
 -1 1 Determined automatically.
 0 1 No crossover.
 1 1 Primal crossover first.
 2 1 Dual crossover first.
crossoverAccuracyTol double 7023000 1e-06 0 maxdouble 1 7 Newton barrier: Determines how crossover adjusts the default relative pivot tolerance
crossoverIterLimit integer 8104000 2147483647 0 maxint 1 7 Newton barrier and hybrid gradient: Maximum number of iterations that will be performed in the crossover procedure before the optimization process terminates
crossoverOps integer 8060000 0 0 maxint 1 7 Newton barrier and hybrid gradient: Bit-vector for adjusting the behavior of the crossover procedure
 bit 0 = 1 Returned solution when the crossover terminates prematurely: 0: Return the last basis from the crossover; 1: Return the barrier solution.
 bit 1 = 2 Select the crossover stages to be performed: 0: Perform both crossover stages; 1: Skip second crossover stage.
 bit 2 = 4 Set crossover behaviour: 0: Force to perform all pivots; 1: Skip pivots that are numerically less reliable.
 bit 3 = 8 Set crossover behaviour: 0: Perform standard crossover; 1: Perform a slower, but numerically more careful crossover.
denseColLimit integer 8086000 0 0 maxint 1 7 Newton barrier: Controls trigger point for special treatment of dense columns in Cholesky factorization
barRefIter integer 8431000 0 0 maxint 1 7 Newton barrier: After terminating the barrier algorithm, further refinement steps can be performed
barPerturb double 7011000 0 0 maxdouble 1 7 Newton barrier: In numerically challenging cases it is often advantageous to apply perturbations on the KKT system to improve its numerical properties
barObjPerturb double 7146000 1e-06 mindouble maxdouble 1 7 Defines how the barrier perturbs the objective
 0 Turn off objective perturbation.
 >0 Let the optimizer decide if the objective is perturbed or not and use the parameter value as the scale of the perturbation.
 <0 Always perturb the objective by the absolute value of the parameter.
barHGExtrapolate double 7166000 0.15 0 maxdouble 1 7 Extrapolation parameter for the hybrid gradient algorithm
barHGOps integer 8483000 8 0 maxint 1 7 Bit-vector control options for the hybrid gradient algorithm
 bit 0 = 1 Equivalent to \ref XPRESSbarHGOps_asymAvg "barHGOps_asymAvg".
 bit 1 = 2 Equivalent to \ref XPRESSbarHGOps_startL1 "barHGOps_startL1".
 bit 2 = 4 Equivalent to \ref XPRESSbarHGOps_startL2 "barHGOps_startL2".
 bit 3 = 8 Equivalent to \ref XPRESSbarHGOps_startLInf "barHGOps_startLInf".
 bit 4 = 16 Unused.
 bit 5 = 32 Equivalent to \ref XPRESSbarHGOps_omegaContract "barHGOps_omegaContract".
 bit 6 = 64 Equivalent to \ref XPRESSbarHGOps_omegaInf "barHGOps_omegaInf".
barHGOps_asymAvg boolean 8483001 0 1 7 Use an asymmetric average for the primal averaging
barHGOps_startL1 boolean 8483002 0 1 7 Use the 1-norm of the coefficient matrix in normalizing the initial solution
barHGOps_startL2 boolean 8483003 0 1 7 Use the 2-norm of the coefficient matrix in normalizing the initial solution
barHGOps_startLInf boolean 8483004 1 1 7 Use the infinity norm of the coefficient matrix in normalizing the initial solution
barHGOps_omegaContract boolean 8483006 0 1 7 Contract omega towards 1 if the infeasibility is small enough
barHGOps_omegaInf boolean 8483007 0 1 7 Omega is based on the infeasibility
barHGMaxRestarts integer 8484000 1250 0 maxint 1 7 Maximum number of restarts in the hybrid gradient algorithm
barIterative integer 8492000 -2 -2 maxint 1 7 Maximum number of barrier iterations in which an iterative solver is used instead of the Cholesky decomposition
 -2 Automatically determined.
 -1 Turn iterative solver off.
 0 Use iterative solver for the starting point computation.
 n>0 Try to apply iterative solver for the first n barrier iterations.
globalNumInitNLPCuts integer 8449000 -1 -1 maxint 1 8 Specifies the maximum number of tangent cuts when setting up the initial relaxation during a global solve
globalLSHeurStrategy enumint 8464000 -1 1 8 When integer-feasible (for MINLP, any solution for NLP) but nonlinear-infeasible solutions are encountered within a global solve, the integer variables can be fixed and a local solver can be called on t****
 -1 1 Automatic selection of the strategy.
 0 1 Never run a local solver on a partially fixed solution.
 1 1 Conservative strategy.
 2 1 Moderate strategy.
 3 1 Aggressive strategy.
heurSearchCopyControls enumint 8480000 1 1 8 Select how user-set controls should affect local search heuristics
 0 1 Do not copy any user-set controls
 1 1 Automatic - Let the Optimizer decide which user-set controls to copy
 2 1 Copy all user-set controls
globalNLPCuts integer 8481000 -1 -1 maxint 1 8 Limit on the number of rounds of outer approximation and convexification cuts generated for the root node, when solving an (MI)NLP to global optimality
globalTreeNLPCuts integer 8482000 -1 -1 maxint 1 8 Limit on the number of rounds of outer approximation and convexification cuts generated for each node in the tree, when solving an (MI)NLP to global optimality
xslp_algorithm integer 12301000 166 minint maxint 1 13 Bit map describing the SLP algorithm(s) to be used
 bit 0 = 1 Equivalent to \ref XPRESSxslp_algorithm_noStepBounds "xslp_algorithm_noStepBounds".
 bit 1 = 2 Equivalent to \ref XPRESSxslp_algorithm_stepBoundsAsRequired "xslp_algorithm_stepBoundsAsRequired".
 bit 2 = 4 Equivalent to \ref XPRESSxslp_algorithm_estimateStepBounds "xslp_algorithm_estimateStepBounds".
 bit 3 = 8 Equivalent to \ref XPRESSxslp_algorithm_dynamicDamping "xslp_algorithm_dynamicDamping".
 bit 4 = 16 Equivalent to \ref XPRESSxslp_algorithm_holdValues "xslp_algorithm_holdValues".
 bit 5 = 32 Equivalent to \ref XPRESSxslp_algorithm_retainPreviousValue "xslp_algorithm_retainPreviousValue".
 bit 6 = 64 Equivalent to \ref XPRESSxslp_algorithm_resetDeltaZ "xslp_algorithm_resetDeltaZ".
 bit 7 = 128 Equivalent to \ref XPRESSxslp_algorithm_quickConvergenceCheck "xslp_algorithm_quickConvergenceCheck".
 bit 8 = 256 Equivalent to \ref XPRESSxslp_algorithm_escalatePenalties "xslp_algorithm_escalatePenalties".
 bit 9 = 512 Equivalent to \ref XPRESSxslp_algorithm_switchToPrimal "xslp_algorithm_switchToPrimal".
 bit 11 = 2048 Equivalent to \ref XPRESSxslp_algorithm_maxCostOption "xslp_algorithm_maxCostOption".
 bit 12 = 4096 Equivalent to \ref XPRESSxslp_algorithm_residualErrors "xslp_algorithm_residualErrors".
 bit 13 = 8192 Equivalent to \ref XPRESSxslp_algorithm_noLPPolishing "xslp_algorithm_noLPPolishing".
 bit 14 = 16384 Equivalent to \ref XPRESSxslp_algorithm_cascadeBounds "xslp_algorithm_cascadeBounds".
 bit 15 = 32768 Equivalent to \ref XPRESSxslp_algorithm_clampExtendedActiveSB "xslp_algorithm_clampExtendedActiveSB".
 bit 16 = 65536 Equivalent to \ref XPRESSxslp_algorithm_clampExtendedAll "xslp_algorithm_clampExtendedAll".
xslp_algorithm_cascadeBounds boolean 12301015 0 1 13 Step bounds are updated to accomodate cascaded values (otherwise cascaded values are pushed to respect step bounds)
xslp_algorithm_clampExtendedActiveSB boolean 12301016 0 1 13 Apply clamping when converged on extended criteria only with some variables having active step bounds
xslp_algorithm_clampExtendedAll boolean 12301017 0 1 13 Apply clamping when converged on extended criteria only
xslp_algorithm_dynamicDamping boolean 12301004 0 1 13 Use dynamic damping
xslp_algorithm_escalatePenalties boolean 12301009 0 1 13 Escalate penalties
xslp_algorithm_estimateStepBounds boolean 12301003 1 1 13 Estimate step bounds from early SLP iterations
xslp_algorithm_holdValues boolean 12301005 0 1 13 Do not update values which are converged within strict tolerance
xslp_algorithm_maxCostOption boolean 12301012 0 1 13 Continue optimizing after penalty cost reaches maximum
xslp_algorithm_noLPPolishing boolean 12301014 0 1 13 Skip the solution polishing step if the LP postsolve returns a slightly infeasible, but claimed optimal solution
xslp_algorithm_noStepBounds boolean 12301001 0 1 13 Do not apply step bounds
xslp_algorithm_quickConvergenceCheck boolean 12301008 1 1 13 Quick convergence check
xslp_algorithm_resetDeltaZ boolean 12301007 0 1 13 Reset \ref XPRESSxslp_delta_z "xslp_delta_z" to zero when converged and continue SLP
xslp_algorithm_residualErrors boolean 12301013 0 1 13 Accept a solution which has converged even if there are still significant active penalty error vectors
xslp_algorithm_retainPreviousValue boolean 12301006 1 1 13 Retain previous value when cascading if determining row is zero
xslp_algorithm_stepBoundsAsRequired boolean 12301002 1 1 13 Apply step bounds to SLP delta vectors only when required
xslp_algorithm_switchToPrimal boolean 12301010 0 1 13 Use the primal simplex algorithm when all error vectors become inactive
xslp_calcThreads integer 12405000 -1 -1 1 1 13 Number of threads used for formula and derivatives evaluations
xslp_filter integer 12387000 3 minint maxint 1 13 Bit map for controlling solution updates
 bit 0 = 1 Equivalent to \ref XPRESSxslp_filterKeepBest "xslp_filterKeepBest".
 bit 1 = 2 Equivalent to \ref XPRESSxslp_filterCascade "xslp_filterCascade".
 bit 2 = 4 Equivalent to \ref XPRESSxslp_filterZeroLineSearch "xslp_filterZeroLineSearch".
 bit 3 = 8 Equivalent to \ref XPRESSxslp_filterZeroLineSearchTR "xslp_filterZeroLineSearchTR".
xslp_filterKeepBest boolean 12387001 1 1 13 Retain best solution according to the merit function
xslp_filterCascade boolean 12387002 1 1 13 Check cascaded solutions against improvements in the merit function
xslp_filterZeroLineSearch boolean 12387003 0 1 13 Force minimum step sizes in line search
xslp_filterZeroLineSearchTR boolean 12387004 0 1 13 Accept the trust region step is the line search returns a zero step size
xslp_findIV enumint 12413000 -1 1 13 Option for running a heuristic to find a feasible initial point
 -1 1 Automatic (default).
 0 1 Disable the heuristic.
 1 1 Enable the heuristic.
xslp_infinity double 12119000 1e+10 0 maxdouble 1 13 Value returned by a divide-by-zero in a formula
xslp_nlpSolver enumint 12417000 -1 1 13 Controls whether to call FICO Xpress Global or one of the local solvers
 -1 1 If the license allows and there are no user functions or multistart jobs, FICO Xpress Global will be called, otherwise a local solver.
 1 1 The algorithm selected by \ref XPRESSxslp_solver "xslp_solver" will be used to find a locally optimal solution
 2 1 FICO Xpress Global will be used to find a globally optimal solution
xslp_primalIntegralRef double 12175000 1e+20 mindouble maxdouble 1 13 Reference solution value to take into account when calculating the primal integral
xslp_scale enumint 12367000 1 1 13 When to re-scale the SLP problem
 0 1 No re-scaling.
 1 1 Re-scale every SLP iteration up to \ref XPRESSxslp_scaleCount "xslp_scaleCount" iterations after the end of barrier optimization.
 2 1 Re-scale every SLP iteration up to \ref XPRESSxslp_scaleCount "xslp_scaleCount" iterations in total.
 3 1 Re-scale every SLP iteration until primal simplex is automatically invoked.
 4 1 Re-scale every SLP iteration.
 5 1 Re-scale every \ref XPRESSxslp_scaleCount "xslp_scaleCount" SLP iterations.
 6 1 Re-scale every \ref XPRESSxslp_scaleCount "xslp_scaleCount" SLP iterations after the end of barrier optimization.
xslp_scaleCount integer 12368000 0 0 maxint 1 13 Iteration limit used in determining when to re-scale the SLP matrix
xslp_solver enumint 12352000 -1 1 13 Selects the library to use for local solves
 -1 1 Automatic selection, based on model characteristics and solver availability
 0 1 Use Xpress-SLP (always available)
 1 1 Use Knitro if available
 2 1 Use Xpress-Optimizer if possible (convex quadratic problems only)
xslp_threads integer 12406000 -1 -1 maxint 1 13 Default number of threads to be used
xslp_zero double 12123000 1e-15 0 maxdouble 1 13 Absolute tolerance
xslp_primalIntegralAlpha double 12176000 0 0 maxdouble 1 13 Decay term for primal integral computation
xslp_linQuadBR enumint 12414000 -1 1 14 Use linear and quadratic constraints and objective function to further reduce bounds on all variables
 -1 1 Automatic selection
 0 1 Disable
 1 1 Enable
xslp_postsolve integer 12398000 -1 -1 1 1 14 Determines whether postsolving should be performed automatically
 -1 Postsolve if the problem could be solved to optimality/infeasibility.
 0 Do not automatically postsolve.
 1 Postsolve automatically.
xslp_presolve enumint 12344000 -1 1 14 Determines whether presolving should be performed on the nonlinear problem prior to starting the main algorithm
 -1 1 Disable nonlinear presolve if and only if Optimizer presolve is disabled.
 0 1 Disable nonlinear presolve.
 1 1 Activate nonlinear presolve.
 2 1 Low memory presolve. Original problem is not restored by postsolve and dual solution may not be completely postsolved.
xslp_presolveLevel enumint 12402000 4 1 14 Determines the level of changes presolve may carry out on the problem and whether column/row indices may change
 1 1 Individual rows only presolve, no dropped columns/rows or index changes, no nonlinear transformations (XSLP_PRESOLVELEVEL_LOCALIZED).
 2 1 All linear presolve that does not drop columns/rows, no index changes, no nonlinear transformations (XSLP_PRESOLVELEVEL_BASIC).
 3 1 Full linear presolve including dropping columns/rows and index changes, no nonlinear transformations (XSLP_PRESOLVELEVEL_LINEAR).
 4 1 Full presolve (XSLP_PRESOLVELEVEL_FULL).
xslp_presolveOps integer 12393000 2104 minint maxint 1 14 Bitmap indicating the SLP presolve actions to be taken
 bit 0 = 1 Equivalent to \ref XPRESSxslp_presolveOps_general "xslp_presolveOps_general".
 bit 1 = 2 Equivalent to \ref XPRESSxslp_presolveOps_fixZero "xslp_presolveOps_fixZero".
 bit 2 = 4 Equivalent to \ref XPRESSxslp_presolveOps_fixAll "xslp_presolveOps_fixAll".
 bit 3 = 8 Equivalent to \ref XPRESSxslp_presolveOps_setBounds "xslp_presolveOps_setBounds".
 bit 4 = 16 Equivalent to \ref XPRESSxslp_presolveOps_intBounds "xslp_presolveOps_intBounds".
 bit 5 = 32 Equivalent to \ref XPRESSxslp_presolveOps_domain "xslp_presolveOps_domain".
 bit 8 = 256 Equivalent to \ref XPRESSxslp_presolveOps_noCoefficients "xslp_presolveOps_noCoefficients".
 bit 9 = 512 Equivalent to \ref XPRESSxslp_presolveOps_noDeltas "xslp_presolveOps_noDeltas".
 bit 10 = 1024 Equivalent to \ref XPRESSxslp_presolveOps_noDualSide "xslp_presolveOps_noDualSide".
 bit 11 = 2048 Equivalent to \ref XPRESSxslp_presolveOps_eliminations "xslp_presolveOps_eliminations".
 bit 12 = 4096 Equivalent to \ref XPRESSxslp_presolveOps_noLinear "xslp_presolveOps_noLinear".
 bit 13 = 8192 Equivalent to \ref XPRESSxslp_presolveOps_noSimplifier "xslp_presolveOps_noSimplifier".
xslp_presolveOps_domain boolean 12393006 1 1 14 Bound tightening based on function domains
xslp_presolveOps_eliminations boolean 12393012 1 1 14 Allow eliminations on determined variables
xslp_presolveOps_fixAll boolean 12393003 0 1 14 Explicitly fix all columns identified as fixed
xslp_presolveOps_fixZero boolean 12393002 0 1 14 Explicitly fix columns identified as fixed to zero
xslp_presolveOps_general boolean 12393001 0 1 14 Generic SLP presolve
xslp_presolveOps_intBounds boolean 12393005 1 1 14 MISLP bound tightening
xslp_presolveOps_noCoefficients boolean 12393009 0 1 14 Do not presolve coefficients
xslp_presolveOps_noDeltas boolean 12393010 0 1 14 Do not remove delta variables
xslp_presolveOps_noDualSide boolean 12393011 0 1 14 Avoid reductions that can not be dual postsolved
xslp_presolveOps_setBounds boolean 12393004 1 1 14 SLP bound tightening
xslp_presolveOps_noLinear boolean 12393013 0 1 14 Avoid performing linear reductions at the nlp level
xslp_presolveOps_noSimplifier boolean 12393014 0 1 14 Avoid simplifying nonlinear expressions
xslp_presolveZero double 12193000 1e-09 0 maxdouble 1 14 Minimum absolute value for a variable which is identified as nonzero during SLP presolve
xslp_probing enumint 12403000 -1 1 14 Determines whether probing on a subset of variables should be performed prior to starting the main algorithm
 -1 1 Automatic.
 0 1 Disable SLP probing.
 1 1 Activate SLP probing only on binary variables.
 2 1 Activate SLP probing only on binary or unbounded integer variables.
 3 1 Activate SLP probing only on binary or integer variables.
 4 1 Activate SLP probing only on binary, integer variables, and unbounded continuous variables.
 5 1 Activate SLP probing on any variable.
xslp_presolve_elimTol double 12206000 0.001 0 maxdouble 1 14 Tolerance for nonlinear eliminations during SLP presolve
xslp_boundThreshold double 12214000 1e+10 0 maxdouble 1 14 Maximum size of a bound that can be introduced by nonlinear presolve
xslp_augmentation integer 12302000 12 minint maxint 1 15 Bit map describing the SLP augmentation method(s) to be used
 bit 0 = 1 Equivalent to \ref XPRESSxslp_augmentation_minimum "xslp_augmentation_minimum".
 bit 1 = 2 Equivalent to \ref XPRESSxslp_augmentation_evenHanded "xslp_augmentation_evenHanded".
 bit 2 = 4 Equivalent to \ref XPRESSxslp_augmentation_equalityErrorVectors "xslp_augmentation_equalityErrorVectors".
 bit 3 = 8 Equivalent to \ref XPRESSxslp_augmentation_allErrorVectors "xslp_augmentation_allErrorVectors".
 bit 4 = 16 Equivalent to \ref XPRESSxslp_augmentation_penaltyDeltaVectors "xslp_augmentation_penaltyDeltaVectors".
 bit 5 = 32 Equivalent to \ref XPRESSxslp_augmentation_aMeanWeight "xslp_augmentation_aMeanWeight".
 bit 6 = 64 Equivalent to \ref XPRESSxslp_augmentation_sbFromValues "xslp_augmentation_sbFromValues".
 bit 7 = 128 Equivalent to \ref XPRESSxslp_augmentation_sbFromAbsValues "xslp_augmentation_sbFromAbsValues".
 bit 8 = 256 Equivalent to \ref XPRESSxslp_augmentation_stepBoundRows "xslp_augmentation_stepBoundRows".
 bit 9 = 512 Equivalent to \ref XPRESSxslp_augmentation_allRowErrorVectors "xslp_augmentation_allRowErrorVectors".
 bit 10 = 1024 Equivalent to \ref XPRESSxslp_augmentation_noUpdateIfOnlyIV "xslp_augmentation_noUpdateIfOnlyIV".
 bit 12 = 4096 Equivalent to \ref XPRESSxslp_augmentation_slpSkipIVLPHeuristics "xslp_augmentation_slpSkipIVLPHeuristics".
xslp_augmentation_allErrorVectors boolean 12302004 1 1 15 Penalty error vectors on all non-linear inequality constraints
xslp_augmentation_allRowErrorVectors boolean 12302010 0 1 15 Penalty error vectors on all constraints
xslp_augmentation_aMeanWeight boolean 12302006 0 1 15 Use arithmetic means to estimate penalty weights
xslp_augmentation_equalityErrorVectors boolean 12302003 1 1 15 Penalty error vectors on all non-linear equality constraints
xslp_augmentation_evenHanded boolean 12302002 0 1 15 Even handed augmentation
xslp_augmentation_minimum boolean 12302001 0 1 15 Minimum augmentation
xslp_augmentation_noUpdateIfOnlyIV boolean 12302011 0 1 15 Intial values do not imply an SLP variable
xslp_augmentation_penaltyDeltaVectors boolean 12302005 0 1 15 Penalty vectors to exceed step bounds
xslp_augmentation_sbFromAbsValues boolean 12302008 0 1 15 Estimate step bounds from absolute values of row coefficients
xslp_augmentation_sbFromValues boolean 12302007 0 1 15 Estimate step bounds from values of row coefficients
xslp_augmentation_stepBoundRows boolean 12302009 0 1 15 Row-based step bounds
xslp_augmentation_slpSkipIVLPHeuristics boolean 12302013 0 1 15 Avoid running an LP around fixed initial values trying to get feasible
xslp_delta_x double 12152000 1e-06 0 maxdouble 1 15 Minimum absolute value of delta coefficients to be retained
xslp_feasTolTarget double 12172000 0 0 maxdouble 1 15 When set, this defines a target feasibility tolerance to which the linearizations are solved to
xslp_matrixTol double 12194000 0 0 maxdouble 0 15 Nonzero tolerance for dropping coefficients from the linearization
xslp_optimalityTolTarget double 12173000 0 0 maxdouble 1 15 When set, this defines a target optimality tolerance to which the linearizations are solved to
xslp_unfinishedLimit integer 12376000 3 0 maxint 1 15 Number of consecutive SLP iterations that may have an unfinished status before the solve is terminated
xslp_zeroCriterion integer 12378000 0 minint maxint 1 15 Bitmap determining the behavior of the placeholder deletion procedure
 bit 0 = 1 Equivalent to \ref XPRESSxslp_zeroCriterion_nbSLPVar "xslp_zeroCriterion_nbSLPVar".
 bit 1 = 2 Equivalent to \ref XPRESSxslp_zeroCriterion_nbDelta "xslp_zeroCriterion_nbDelta".
 bit 2 = 4 Equivalent to \ref XPRESSxslp_zeroCriterion_slpVarNBUpdateRow "xslp_zeroCriterion_slpVarNBUpdateRow".
 bit 3 = 8 Equivalent to \ref XPRESSxslp_zeroCriterion_deltaNBUpdateRow "xslp_zeroCriterion_deltaNBUpdateRow".
 bit 4 = 16 Equivalent to \ref XPRESSxslp_zeroCriterion_deltaNBDRRow "xslp_zeroCriterion_deltaNBDRRow".
 bit 5 = 32 Equivalent to \ref XPRESSxslp_zeroCriterion_print "xslp_zeroCriterion_print".
xslp_zeroCriterionCount integer 12380000 0 0 maxint 1 15 Number of consecutive times a placeholder entry is zero before being considered for deletion
xslp_zeroCriterion_deltaNBDRRow boolean 12378005 0 1 15 Remove placeholders in a basic delta variable if the determining row for the corresponding SLP variable is nonbasic
xslp_zeroCriterion_deltaNBUpdateRow boolean 12378004 0 1 15 Remove placeholders in a basic delta variable if its update row is nonbasic and the corresponding SLP variable is nonbasic
xslp_zeroCriterion_nbDelta boolean 12378002 0 1 15 Remove placeholders in nonbasic delta variables
xslp_zeroCriterion_nbSLPVar boolean 12378001 0 1 15 Remove placeholders in nonbasic SLP variables
xslp_zeroCriterion_print boolean 12378006 0 1 15 Print information about zero placeholders
xslp_zeroCriterion_slpVarNBUpdateRow boolean 12378003 0 1 15 Remove placeholders in a basic SLP variable if its update row is nonbasic
xslp_zeroCriterionStart integer 12379000 0 0 maxint 1 15 SLP iteration at which criteria for deletion of placeholder entries are first activated
xslp_barCrossOverStart integer 12408000 0 0 maxint 1 16 Default crossover activation behaviour for barrier start
xslp_barLimit integer 12303000 0 0 maxint 1 16 Number of initial SLP iterations using the barrier method
xslp_barStallingLimit integer 12409000 3 0 maxint 1 16 Number of iterations to allow numerical failures in barrier before switching to dual
xslp_barStallingObjLimit integer 12410000 3 0 maxint 1 16 Number of iterations over which to measure the objective change for barrier iterations with no crossover
xslp_barStallingTol double 12212000 0.05 0 maxdouble 1 16 Required change in the objective when progress is measured in barrier iterations without crossover
xslp_barStartOps integer 12411000 -1 minint maxint 1 16 Controls behaviour when the barrier is used to solve the linearizations
 bit 0 = 1 Equivalent to \ref XPRESSxslp_barStartOps_stallingObjective "xslp_barStartOps_stallingObjective".
 bit 1 = 2 Equivalent to \ref XPRESSxslp_barStartOps_stallingNumerical "xslp_barStartOps_stallingNumerical".
 bit 2 = 4 Equivalent to \ref XPRESSxslp_barStartOps_allowInteriorSol "xslp_barStartOps_allowInteriorSol".
xslp_barStartOps_allowInteriorSol boolean 12411003 1 1 16 If a non-vertex converged solution found by barrier without crossover can be returned as a final solution
xslp_barStartOps_stallingNumerical boolean 12411002 1 1 16 Fall back to dual simplex if too many numerical problems are reported by the barrier
xslp_barStartOps_stallingObjective boolean 12411001 1 1 16 Check objective progress when no crossover is applied
xslp_deltaCost double 12109000 200 0 maxdouble 1 17 Initial penalty cost multiplier for penalty delta vectors
xslp_deltaCostFactor double 12139000 1.3 1 maxdouble 1 17 Factor for increasing cost multiplier on total penalty delta vectors
xslp_deltaMaxCost double 12110000 1e+20 0 maxdouble 1 17 Maximum penalty cost multiplier for penalty delta vectors
xslp_enforceCostShrink double 12203000 1e-05 0 1 1 17 Factor by which to decrease the current penalty multiplier when enforcing rows
xslp_enforceMaxCost double 12202000 1e+11 0 maxdouble 1 17 Maximum penalty cost in the objective before enforcing most violating rows
xslp_errorCost double 12113000 200 0 maxdouble 1 17 Initial penalty cost multiplier for penalty error vectors
xslp_errorCostFactor double 12140000 1.3 1 maxdouble 1 17 Factor for increasing cost multiplier on total penalty error vectors
xslp_errorMaxCost double 12114000 1e+20 0 maxdouble 1 17 Maximum penalty cost multiplier for penalty error vectors
xslp_errorTol_a double 12116000 1e-05 0 maxdouble 1 17 Absolute tolerance for error vectors
xslp_errorTol_p double 12141000 0.0001 0 maxdouble 1 17 Absolute tolerance for printing error vectors
xslp_escalation double 12169000 1.25 1 maxdouble 1 17 Factor for increasing cost multiplier on individual penalty error vectors
xslp_eTol_a double 12180000 0.0001 mindouble maxdouble 1 17 Absolute tolerance on penalty vectors
xslp_eTol_r double 12181000 0.0001 mindouble maxdouble 1 17 Relative tolerance on penalty vectors
xslp_evTol_a double 12182000 -1 mindouble maxdouble 1 17 Absolute tolerance on total penalty costs
xslp_evTol_r double 12183000 -1 mindouble maxdouble 1 17 Relative tolerance on total penalty costs
xslp_granularity double 12157000 4 1 maxdouble 1 17 Base for calculating penalty costs
xslp_maxWeight double 12120000 100 0 maxdouble 1 17 Maximum penalty weight for delta or error vectors
xslp_minWeight double 12121000 0.01 0 maxdouble 1 17 Minimum penalty weight for delta or error vectors
xslp_objToPenaltyCost double 12170000 0 0 maxdouble 1 17 Factor to estimate initial penalty costs from objective function
xslp_penaltyInfoStart integer 12384000 3 0 maxint 1 17 Iteration from which to record row penalty information
xslp_clampShrink double 12188000 0.3 0 1 1 18 Shrink ratio used to impose strict convergence on variables converged in extended criteria only
xslp_clampValidationTol_a double 12186000 1e-06 0 maxdouble 1 18 Absolute validation tolerance for applying \ref XPRESSxslp_clampShrink "xslp_clampShrink"
xslp_clampValidationTol_r double 12187000 1e-06 0 maxdouble 1 18 Relative validation tolerance for applying \ref XPRESSxslp_clampShrink "xslp_clampShrink"
xslp_defaultStepBound double 12136000 16 0 maxdouble 1 18 Minimum initial value for the step bound of an SLP variable if none is explicitly given
xslp_djTol double 12112000 1e-06 0 maxdouble 1 18 Tolerance on DJ value for determining if a variable is at its step bound
xslp_expand double 12118000 2 1 maxdouble 1 18 Multiplier to increase a step bound
xslp_minSBFactor double 12185000 1 0 maxdouble 1 18 Factor by which step bounds can be decreased beneath \ref XPRESSxslp_aTol_a "xslp_aTol_a"
xslp_sameCount integer 12317000 3 0 maxint 1 18 Number of steps reaching the step bound in the same direction before step bounds are increased
xslp_sbStart integer 12320000 8 0 maxint 1 18 SLP iteration after which step bounds are first applied
xslp_shrink double 12122000 0.5 0 1 1 18 Multiplier to reduce a step bound
xslp_shrinkBias double 12171000 0 mindouble maxdouble 1 18 Defines an overwrite / adjustment of step bounds for improving iterations
xslp_damp double 12103000 1 0 1 1 19 Damping factor for updating values of variables
xslp_dampExpand double 12104000 1 0 1 1 19 Multiplier to increase damping factor during dynamic damping
xslp_dampMax double 12137000 1 0 1 1 19 Maximum value for the damping factor of a variable during dynamic damping
xslp_dampMin double 12138000 1 0 1 1 19 Minimum value for the damping factor of a variable during dynamic damping
xslp_dampShrink double 12105000 1 0 1 1 19 Multiplier to decrease damping factor during dynamic damping
xslp_dampStart integer 12308000 0 0 maxint 1 19 SLP iteration at which damping is activated
xslp_lsIterLimit integer 12382000 0 0 maxint 1 19 Number of iterations in the line search
xslp_lsPatternLimit integer 12381000 0 0 maxint 1 19 Number of iterations in the pattern search preceding the line search
xslp_lsStart integer 12383000 8 0 maxint 1 19 Iteration in which to active the line search
xslp_lsZeroLimit integer 12389000 5 0 maxint 1 19 Maximum number of zero length line search steps before line search is deactivated
xslp_meritLambda double 12197000 0 0 maxdouble 1 19 Factor by which the net objective is taken into account in the merit function
xslp_sameDamp integer 12319000 3 0 maxint 1 19 Number of steps in same direction before damping factor is increased
xslp_aTol_a double 12125000 -1 mindouble maxdouble 1 20 Absolute delta convergence tolerance
xslp_aTol_r double 12126000 -1 mindouble maxdouble 1 20 Relative delta convergence tolerance
xslp_convergenceOps integer 12377000 39935 minint maxint 1 20 Bit map describing which convergence tests should be carried out
 bit 0 = 1 Equivalent to \ref XPRESSxslp_convergenceOps_cTol "xslp_convergenceOps_cTol".
 bit 1 = 2 Equivalent to \ref XPRESSxslp_convergenceOps_aTol "xslp_convergenceOps_aTol".
 bit 2 = 4 Equivalent to \ref XPRESSxslp_convergenceOps_mTol "xslp_convergenceOps_mTol".
 bit 3 = 8 Equivalent to \ref XPRESSxslp_convergenceOps_iTol "xslp_convergenceOps_iTol".
 bit 4 = 16 Equivalent to \ref XPRESSxslp_convergenceOps_sTol "xslp_convergenceOps_sTol".
 bit 5 = 32 Equivalent to \ref XPRESSxslp_convergenceOps_user "xslp_convergenceOps_user".
 bit 6 = 64 Equivalent to \ref XPRESSxslp_convergenceOps_vTol "xslp_convergenceOps_vTol".
 bit 7 = 128 Equivalent to \ref XPRESSxslp_convergenceOps_xTol "xslp_convergenceOps_xTol".
 bit 8 = 256 Equivalent to \ref XPRESSxslp_convergenceOps_oTol "xslp_convergenceOps_oTol".
 bit 9 = 512 Equivalent to \ref XPRESSxslp_convergenceOps_wTol "xslp_convergenceOps_wTol".
 bit 10 = 1024 Equivalent to \ref XPRESSxslp_convergenceOps_extendedScaling "xslp_convergenceOps_extendedScaling".
 bit 11 = 2048 Equivalent to \ref XPRESSxslp_convergenceOps_validation "xslp_convergenceOps_validation".
 bit 12 = 4096 Equivalent to \ref XPRESSxslp_convergenceOps_validationK "xslp_convergenceOps_validationK".
 bit 13 = 8192 Equivalent to \ref XPRESSxslp_convergenceOps_noQuadCheck "xslp_convergenceOps_noQuadCheck".
 bit 15 = 32768 Equivalent to \ref XPRESSxslp_convergenceOps_requireOTolR "xslp_convergenceOps_requireOTolR".
xslp_convergenceOps_aTol boolean 12377002 1 1 20 Execute the delta tolerance checks
xslp_convergenceOps_cTol boolean 12377001 1 1 20 Execute the closure tolerance checks
xslp_convergenceOps_extendedScaling boolean 12377011 0 1 20 Take scaling of individual variables / rows into account
xslp_convergenceOps_iTol boolean 12377004 1 1 20 Execute the impact tolerance checks
xslp_convergenceOps_mTol boolean 12377003 1 1 20 Execute the matrix tolerance checks
xslp_convergenceOps_oTol boolean 12377009 1 1 20 Execute the objective range + active step bound check
xslp_convergenceOps_sTol boolean 12377005 1 1 20 Execute the slack impact tolerance checks
xslp_convergenceOps_validation boolean 12377012 1 1 20 Execute the validation target convergence checks
xslp_convergenceOps_validationK boolean 12377013 1 1 20 Execute the first order optimality target convergence checks
xslp_convergenceOps_vTol boolean 12377007 1 1 20 Execute the objective range checks
xslp_convergenceOps_wTol boolean 12377010 1 1 20 Execute the convergence continuation check
xslp_convergenceOps_xTol boolean 12377008 1 1 20 Execute the objective range + constraint activity check
xslp_convergenceOps_user boolean 12377006 1 1 20 Check for user provided convergence
xslp_convergenceOps_noQuadCheck boolean 12377014 0 1 20 Allow convex quadratic problems to converge on extended criteria
xslp_convergenceOps_requireOTolR boolean 12377016 1 1 20 Do not declare converged if still sufficient improvement in objective
xslp_cTol double 12124000 -1 mindouble maxdouble 1 20 Closure convergence tolerance
xslp_ecfCheck enumint 12369000 1 1 20 Check feasibility at the point of linearization for extended convergence criteria
 0 1 No check (extended criteria are always used);
 1 1 Check until one infeasible constraint is found;
 2 1 Check all constraints.
xslp_ecfTol_a double 12189000 -1 mindouble maxdouble 1 20 Absolute tolerance on testing feasibility at the point of linearization
xslp_ecfTol_r double 12190000 -1 mindouble maxdouble 1 20 Relative tolerance on testing feasibility at the point of linearization
xslp_infeasLimit integer 12314000 3 0 maxint 1 20 Maximum number of consecutive infeasible SLP iterations which can occur before Xpress-SLP terminates
xslp_iterLimit integer 12315000 1000 -1 maxint 1 20 Maximum number of SLP iterations
xslp_iTol_a double 12129000 -1 mindouble maxdouble 1 20 Absolute impact convergence tolerance
xslp_iTol_r double 12130000 -1 mindouble maxdouble 1 20 Relative impact convergence tolerance
xslp_mTol_a double 12127000 -1 mindouble maxdouble 1 20 Absolute effective matrix element convergence tolerance
xslp_mTol_r double 12128000 -1 mindouble maxdouble 1 20 Relative effective matrix element convergence tolerance
xslp_mvTol double 12133000 -1 mindouble maxdouble 1 20 Marginal value tolerance for determining if a constraint is slack
xslp_oCount integer 12333000 5 0 maxint 1 20 Number of SLP iterations over which to measure objective function variation for static objective (2) convergence criterion
xslp_oTol_a double 12150000 -1 mindouble maxdouble 1 20 Absolute static objective (2) convergence tolerance
xslp_oTol_r double 12151000 -1 mindouble maxdouble 1 20 Relative static objective (2) convergence tolerance
xslp_sTol_a double 12131000 -1 mindouble maxdouble 1 20 Absolute slack convergence tolerance
xslp_sTol_r double 12132000 -1 mindouble maxdouble 1 20 Relative slack convergence tolerance
xslp_stopOutOfRange boolean 12354000 0 1 20 Stop optimization and return error code if internal function argument is out of range
xslp_validationTarget_k double 12210000 1e-06 0 maxdouble 1 20 Optimality target tolerance
xslp_validationTarget_r double 12209000 1e-06 0 maxdouble 1 20 Feasiblity target tolerance
xslp_vCount integer 12356000 0 0 maxint 1 20 Number of SLP iterations over which to measure static objective (3) convergence
xslp_vLimit integer 12357000 0 0 maxint 1 20 Number of SLP iterations after which static objective (3) convergence testing starts
xslp_vTol_a double 12177000 -1 mindouble maxdouble 1 20 Absolute static objective (3) convergence tolerance
xslp_vTol_r double 12178000 -1 mindouble maxdouble 1 20 Relative static objective (3) convergence tolerance
xslp_wCount integer 12374000 0 0 maxint 1 20 Number of SLP iterations over which to measure the objective for the extended convergence continuation criterion
xslp_wTol_a double 12191000 -1 mindouble maxdouble 1 20 Absolute extended convergence continuation tolerance
xslp_wTol_r double 12192000 -1 mindouble maxdouble 1 20 Relative extended convergence continuation tolerance
xslp_xCount integer 12321000 5 0 maxint 1 20 Number of SLP iterations over which to measure static objective (1) convergence
xslp_xLimit integer 12322000 100 0 maxint 1 20 Number of SLP iterations up to which static objective (1) convergence testing is performed
xslp_xTol_a double 12134000 -1 mindouble maxdouble 1 20 Absolute static objective function (1) tolerance
xslp_xTol_r double 12135000 -1 mindouble maxdouble 1 20 Relative static objective function (1) tolerance
xslp_validationTol_a double 12165000 1e-05 0 maxdouble 1 20 Absolute tolerance for the XSLPvalidate procedure (may be used by Xpress Global internally)
xslp_validationTol_r double 12166000 1e-05 0 maxdouble 1 20 Relative tolerance for the XSLPvalidate procedure (may be used by Xpress Global internally)
xslp_validationTol_k double 12205000 1e-05 0 maxdouble 1 20 Relative tolerance for the XSLPvalidatekkt procedure (may be used by Xpress Global internally)
xslp_validationFactor double 12211000 0.001 0 maxdouble 1 20 Minimum improvement in validation targets to continue iterating
xslp_msMaxBoundRange double 12204000 1000 0 maxdouble 1 21 Defines the maximum range inside which initial points are generated by multistart presets
xslp_multistart_maxSolves integer 12364000 -1 -1 maxint 1 21 Maximum number of jobs to create during the multistart search
xslp_multistart_maxTime integer 12365000 0 0 maxint 1 21 Maximum total time to be spent in the mutlistart search
xslp_multistart_poolsize integer 12397000 2 0 maxint 1 21 Maximum number of problem objects allowed to pool up before synchronization in the deterministic multistart
xslp_multistart_seed integer 12396000 0 minint maxint 1 21 Random seed used for the automatic generation of initial point when loading multistart presets
xslp_multistart_threads integer 12363000 -1 -1 maxint 1 21 Maximum number of threads to be used in multistart
xslp_cdTol_a double 12200000 1e-08 0 maxdouble 1 22 Absolute tolerance for deducing constant derivatives
xslp_cdTol_r double 12201000 1e-08 0 maxdouble 1 22 Relative tolerance for deducing constant derivatives
xslp_delta_a double 12106000 0.001 0 maxdouble 1 22 Absolute perturbation of values for calculating numerical derivatives
xslp_delta_r double 12107000 0.001 0 maxdouble 1 22 Relative perturbation of values for calculating numerical derivatives
xslp_delta_z double 12108000 1e-05 0 maxdouble 1 22 Tolerance used when calculating derivatives
xslp_delta_zero double 12184000 -1 mindouble maxdouble 1 22 Absolute zero acceptance tolerance used when calculating derivatives
xslp_deltaZLimit integer 12311000 0 0 maxint 1 22 Number of SLP iterations during which to apply \ref XPRESSxslp_delta_z "xslp_delta_z"
xslp_derivatives boolean 12373000 1 1 22 Bitmap describing the method of calculating derivatives
 bit 0 = 1 Analytic derivatives where possible
 bit 1 = 2 Avoid embedding numerical derivatives of instantiated functions into analytic derivatives
xslp_hessian integer 12361000 -1 -1 3 1 22 Second order differentiation mode when using analytical derivatives
 1 Numerical derivatives (finite difference)
 2 Symbolic differentiation
 3 Automatic differentiation
 -1,0 Automatic selection
xslp_jacobian integer 12360000 -1 -1 3 1 22 First order differentiation mode when using analytical derivatives
 1 Numerical derivatives (finite difference)
 2 Symbolic differentiation
 3 Automatic differentiation
 -1,0 Automatic selection
xslp_delta_infinity double 12174000 1e+15 0 maxdouble 1 22 Maximum value for partial derivatives
xslp_analyze integer 12332000 0 minint maxint 1 23 Bit map activating additional options supporting model / solution path analysis
 bit 3 = 8 Equivalent to \ref XPRESSxslp_analyze_extendedFinalSummary "xslp_analyze_extendedFinalSummary".
 bit 4 = 16 Equivalent to \ref XPRESSxslp_analyze_infeasibleIteration "xslp_analyze_infeasibleIteration".
 bit 6 = 64 Equivalent to \ref XPRESSxslp_analyze_saveLinearizations "xslp_analyze_saveLinearizations".
 bit 7 = 128 Equivalent to \ref XPRESSxslp_analyze_saveIterBasis "xslp_analyze_saveIterBasis".
 bit 8 = 256 Equivalent to \ref XPRESSxslp_analyze_saveFile "xslp_analyze_saveFile".
xslp_analyze_extendedFinalSummary boolean 12332004 0 1 23 Include an extended iteration summary
xslp_analyze_infeasibleIteration boolean 12332005 0 1 23 Run infeasibility analysis on infeasible iterations
xslp_analyze_saveFile boolean 12332009 0 1 23 Create an Xpress SLP save file at every \ref XPRESSxslp_autosave "xslp_autosave" iterations
xslp_analyze_saveIterBasis boolean 12332008 0 1 23 Write the initial basis of the linearizations to disk at every \ref XPRESSxslp_autosave "xslp_autosave" iterations
xslp_analyze_saveLinearizations boolean 12332007 0 1 23 Write the linearizations to disk at every \ref XPRESSxslp_autosave "xslp_autosave" iterations
xslp_autosave integer 12330000 0 0 maxint 1 23 Frequency with which to save the model
xslp_log enumint 12316000 0 1 23 Level of printing during SLP iterations
 -1 1 None
 0 1 Minimal
 1 1 Normal: iteration, penalty vectors
 2 1 Omit from convergence log any variables which have converged
 3 1 Omit from convergence log any variables which have already converged (except variables on step bounds)
 4 1 Include all variables in convergence log
 5 1 Include user function call communications in the log
xslp_slpLog integer 12346000 1 0 maxint 1 23 Frequency with which SLP status is printed
xslp_mipAlgorithm integer 12336000 17 minint maxint 1 24 Bitmap describing the MISLP algorithms to be used
 bit 0 = 1 Equivalent to \ref XPRESSxslp_mipAlgorithm_initialSLP "xslp_mipAlgorithm_initialSLP".
 bit 2 = 4 Equivalent to \ref XPRESSxslp_mipAlgorithm_initialRelaxSLP "xslp_mipAlgorithm_initialRelaxSLP".
 bit 3 = 8 Equivalent to \ref XPRESSxslp_mipAlgorithm_initialFixSLP "xslp_mipAlgorithm_initialFixSLP".
 bit 4 = 16 Equivalent to \ref XPRESSxslp_mipAlgorithm_nodeRelaxSLP "xslp_mipAlgorithm_nodeRelaxSLP".
 bit 5 = 32 Equivalent to \ref XPRESSxslp_mipAlgorithm_nodeFixSLP "xslp_mipAlgorithm_nodeFixSLP".
 bit 6 = 64 Equivalent to \ref XPRESSxslp_mipAlgorithm_nodeLimitSLP "xslp_mipAlgorithm_nodeLimitSLP".
 bit 7 = 128 Equivalent to \ref XPRESSxslp_mipAlgorithm_finalRelaxSLP "xslp_mipAlgorithm_finalRelaxSLP".
 bit 8 = 256 Equivalent to \ref XPRESSxslp_mipAlgorithm_finalFixSLP "xslp_mipAlgorithm_finalFixSLP".
 bit 9 = 512 Equivalent to \ref XPRESSxslp_mipAlgorithm_withinSLP "xslp_mipAlgorithm_withinSLP".
 bit 10 = 1024 Equivalent to \ref XPRESSxslp_mipAlgorithm_slpThenMIP "xslp_mipAlgorithm_slpThenMIP".
xslp_mipAlgorithm_finalFixSLP boolean 12336009 0 1 24 Fix step bounds according to \ref XPRESSxslp_mipFixStepBounds "xslp_mipFixStepBounds" after MIP solution is found
xslp_mipAlgorithm_finalRelaxSLP boolean 12336008 0 1 24 Relax step bounds according to \ref XPRESSxslp_mipRelaxStepBounds "xslp_mipRelaxStepBounds" after MIP solution is found
xslp_mipAlgorithm_initialFixSLP boolean 12336004 0 1 24 Fix step bounds according to \ref XPRESSxslp_mipFixStepBounds "xslp_mipFixStepBounds" after initial node
xslp_mipAlgorithm_initialRelaxSLP boolean 12336003 0 1 24 Relax step bounds according to \ref XPRESSxslp_mipRelaxStepBounds "xslp_mipRelaxStepBounds" after initial node
xslp_mipAlgorithm_initialSLP boolean 12336001 1 1 24 Solve initial SLP to convergence
xslp_mipAlgorithm_nodeFixSLP boolean 12336006 0 1 24 Fix step bounds according to \ref XPRESSxslp_mipFixStepBounds "xslp_mipFixStepBounds" at each node
xslp_mipAlgorithm_nodeLimitSLP boolean 12336007 0 1 24 Limit iterations at each node to \ref XPRESSxslp_mipIterLimit "xslp_mipIterLimit"
xslp_mipAlgorithm_nodeRelaxSLP boolean 12336005 1 1 24 Relax step bounds according to \ref XPRESSxslp_mipRelaxStepBounds "xslp_mipRelaxStepBounds" at each node
xslp_mipAlgorithm_slpThenMIP boolean 12336011 0 1 24 Use MIP on converged SLP solution and then SLP on the resulting MIP solution
xslp_mipAlgorithm_withinSLP boolean 12336010 0 1 24 Use MIP at each SLP iteration instead of SLP at each node
xslp_mipCutOff_a double 12158000 1e-05 0 maxdouble 1 24 Absolute objective function cutoff for MIP termination
xslp_mipCutOffCount integer 12370000 5 0 maxint 1 24 Number of SLP iterations to check when considering a node for cutting off
xslp_mipCutOffLimit integer 12340000 10 0 maxint 1 24 Number of SLP iterations to check when considering a node for cutting off
xslp_mipCutOff_r double 12159000 1e-05 0 maxdouble 1 24 Absolute objective function cutoff for MIP termination
xslp_cutStrategy integer 12310000 0 -1 3 1 24 Determines whihc cuts to apply in the MISLP search when the default SLP-in-MIP strategy is used
xslp_mipDefaultAlgorithm integer 12343000 3 1 5 1 24 Default algorithm to be used during the tree search in MISLP
xslp_mipErrorTol_a double 12198000 0 0 maxdouble 1 24 Absolute penalty error cost tolerance for MIP cut-off
xslp_mipErrorTol_r double 12199000 0 0 maxdouble 1 24 Relative penalty error cost tolerance for MIP cut-off
xslp_mipFixStepBounds integer 12338000 0 minint maxint 1 24 Bitmap describing the step-bound fixing strategy during MISLP
 bit 0 = 1 Equivalent to \ref XPRESSxslp_mipFixStepBounds_structNotCoef "xslp_mipFixStepBounds_structNotCoef".
 bit 1 = 2 Equivalent to \ref XPRESSxslp_mipFixStepBounds_structAll "xslp_mipFixStepBounds_structAll".
 bit 2 = 4 Equivalent to \ref XPRESSxslp_mipFixStepBounds_coefOnly "xslp_mipFixStepBounds_coefOnly".
 bit 3 = 8 Equivalent to \ref XPRESSxslp_mipFixStepBounds_coef "xslp_mipFixStepBounds_coef".
xslp_mipFixStepBounds_coef boolean 12338004 0 1 24 Fix step bounds on SLP variables appearing in coefficients
xslp_mipFixStepBounds_coefOnly boolean 12338003 0 1 24 Fix step bounds on SLP variables appearing only in coefficients
xslp_mipFixStepBounds_structAll boolean 12338002 0 1 24 Fix step bounds on all structural SLP variables
xslp_mipFixStepBounds_structNotCoef boolean 12338001 0 1 24 Fix step bounds on structural SLP variables which are not in coefficients
xslp_heurStrategy enumint 12400000 -1 1 24 Branch and Bound: MINLP heuristic strategy
 -1 1 Automatic selection of heuristic strategy.
 0 1 No heuristics.
 1 1 Basic heuristic strategy.
 2 1 Enhanced heuristic strategy.
 3 1 Extensive heuristic strategy.
 4 1 Run all heuristics without effort limits.
xslp_mipIterLimit integer 12339000 0 0 maxint 1 24 Maximum number of SLP iterations at each node
xslp_mipLog integer 12347000 0 0 maxint 1 24 Frequency with which MIP status is printed
xslp_mipOCount integer 12341000 5 0 maxint 1 24 Number of SLP iterations at each node over which to measure objective function variation
xslp_mipOTol_a double 12160000 1e-05 0 maxdouble 1 24 Absolute objective function tolerance for MIP termination
xslp_mipOTol_r double 12161000 1e-05 0 maxdouble 1 24 Relative objective function tolerance for MIP termination
xslp_mipRelaxStepBounds integer 12337000 15 minint maxint 1 24 Bitmap describing the step-bound relaxation strategy during MISLP
 bit 0 = 1 Equivalent to \ref XPRESSxslp_mipRelaxStepBounds_structNotCoef "xslp_mipRelaxStepBounds_structNotCoef".
 bit 1 = 2 Equivalent to \ref XPRESSxslp_mipRelaxStepBounds_structAll "xslp_mipRelaxStepBounds_structAll".
 bit 2 = 4 Equivalent to \ref XPRESSxslp_mipRelaxStepBounds_coefOnly "xslp_mipRelaxStepBounds_coefOnly".
 bit 3 = 8 Equivalent to \ref XPRESSxslp_mipRelaxStepBounds_coef "xslp_mipRelaxStepBounds_coef".
xslp_mipRelaxStepBounds_coef boolean 12337004 1 1 24 Relax step bounds on SLP variables appearing in coefficients
xslp_mipRelaxStepBounds_coefOnly boolean 12337003 1 1 24 Relax step bounds on SLP variables appearing only in coefficients
xslp_mipRelaxStepBounds_structAll boolean 12337002 1 1 24 Relax step bounds on all structural SLP variables
xslp_mipRelaxStepBounds_structNotCoef boolean 12337001 1 1 24 Relax step bounds on structural SLP variables which are not in coefficients
knitro_algorithm integer 0 2 0 5 1 25 Which algorithm to use.
knitro_bar_directinterval integer 0 -1 -1 maxint 1 25 When using the Interior/Direct algorithm, this parameter controls the maximum number of consecutive CG steps before trying to force the algorithm to take a direct step again. (negative implies****
knitro_bar_feasible integer 0 0 0 3 1 25 Whether feasibility is given special emphasis.
knitro_bar_feasmodetol double 0 0.0001 0 maxdouble 1 25 Specifies the tolerance for entering the stay feasible mode (only valid when bar_feasible = stay or bar_feasible = get_stay).
knitro_bar_initmu double 0 -1 mindouble maxdouble 1 25 Initial value for the barrier parameter (non-positive implies auto).
knitro_bar_initpt integer 0 0 0 3 1 25 Strategy for setting initial x, lambda and slacks with barrier algorithms. This option only affects the initial x value when not provided by user.
knitro_bar_maxcrossit integer 0 0 0 maxint 1 25 Maximum number of crossover iterations to allow for barrier algorithms.
knitro_bar_maxrefactor integer 0 -1 -1 maxint 1 25 Maximum number of refactorizations of the KKT system per iteration of the Interior Direct algorithm before reverting to a CG step. (negative implies auto; only used for alg=1).
knitro_bar_murule integer 0 0 0 6 1 25 Which barrier parameter update strategy.
knitro_bar_switchrule integer 0 -1 -1 3 1 25 Switching rule strategy for barrier algorithms that controls switching between optimality and feasibility phases.
knitro_blasoption integer 0 -1 -1 4 1 25 Which BLAS/LAPACK library to use.  Intel MKL library is only available on some platforms; see the User Manual for details.
knitro_delta double 0 1 1e-14 maxdouble 1 25 Initial trust region radius scaling factor, used to determine the initial trust region size.
knitro_feastol double 0 1e-06 0 maxdouble 1 25 Specifies the final relative stopping tolerance for the feasibility error. Smaller values of feastol result in a higher degree of accuracy in the solution with respect to feasibility.
knitro_gradopt integer 0 1 1 5 1 25 How to compute/approximate the gradient of the objective and constraint functions.
knitro_hessopt integer 0 0 0 6 1 25 How to compute/approximate the Hessian of the Lagrangian.
knitro_honorbnds integer 0 -1 -1 2 1 25 Whether to enforce satisfaction of simple bounds at all iterations.
knitro_infeastol double 0 1e-08 0 maxdouble 1 25 Specifies relative stopping tolerance used to declare infeasibility.
knitro_linsolver integer 0 0 0 8 1 25 Which linear system solver to use.
knitro_lmsize integer 0 10 1 100 1 25 Number of limited memory pairs to store when Hessian choice is lbfgs.
knitro_maxit integer 0 0 0 maxint 1 25 Maximum number of iterations to allow (if 0 then \ref S_KNITRO "KNITRO" determines the best value). Default values are 10000 for NLP and 3000 for MIP.
knitro_mip_branchrule integer 0 0 0 3 1 25 Specifies the MIP branching rule for choosing a variable.
knitro_mip_gub_branch integer 0 0 0 1 1 25 Whether to branch on generalized upper bounds (GUBs).
knitro_mip_knapsack integer 0 -1 -1 2 1 25 Specifies rules for adding MIP knapsack cuts.
knitro_mip_lpalg integer 0 0 0 3 1 25 Specifies which algorithm to use for LP subproblem solves in MIP.
knitro_mip_maxnodes integer 0 0 0 maxint 1 25 Maximum number of nodes explored (0 means no limit).
knitro_mip_method integer 0 0 0 3 1 25 Which MIP method to use.
knitro_mip_outinterval integer 0 0 0 maxint 1 25 Specifies printing interval for mip_outlevel. 1 = print every node 2 = print every 2nd node N = print every Nth node
knitro_mip_outlevel integer 0 2 0 3 1 25 How much MIP information to print.
knitro_mip_pseudoinit integer 0 0 0 2 1 25 How to initialize pseudo-costs.
knitro_mip_rootalg integer 0 0 0 5 1 25 Specifies which algorithm to use for the root node solve in MIP
knitro_mip_rounding integer 0 -1 -1 4 1 25 Specifies the MIP rounding rule to apply.
knitro_mip_selectrule integer 0 0 0 3 1 25 Specifies the MIP select rule for choosing a node.
knitro_mip_strong_candlim integer 0 128 0 maxint 1 25 Maximum number of candidates to explore for MIP strong branching.
knitro_mip_strong_level integer 0 10 0 maxint 1 25 Maximum number of levels on which to perform MIP strong branching.
knitro_mip_strong_maxit integer 0 1000 0 maxint 1 25 Maximum number of iterations to allow for MIP strong branching solves.
knitro_objrange double 0 1e+20 0 maxdouble 1 25 Valid range of objective values.
knitro_opttol double 0 1e-06 0 maxdouble 1 25 Specifies the final relative stopping tolerance for the KKT (optimality) error. Smaller values of opttol result in a higher degree of accuracy in the solution with respect to optimality.
knitro_outlev integer 0 2 0 6 1 25 Specifies the verbosity of output.
knitro_presolve integer 0 1 0 1 1 25 Whether to apply any presolve operations to the model.
knitro_presolve_tol double 0 1e-06 0 maxdouble 1 25 Specifies the tolerance used to determine whether or not deduced bounds from the presolve operation are infeasible.
knitro_scale integer 0 1 0 3 1 25 Whether to perform scaling of the problem.
knitro_soc integer 0 1 0 2 1 25 Whether to use the Second Order Correction (SOC) option.
knitro_xtol double 0 1e-12 0 maxdouble 1 25 Step size tolerance used for terminating the optimization.
*
* synonym section
*
iterlim synonym lpIterLimit
*
* indicator section
*
indic  indicator
*
* deprecated section
*
XPRESS_38_01 deprecated
 xslp_matrixTol
XPRESS_41_01 deprecated
 maxTime
 cacheSize
 l1Cache
 sleepOnThreadWait
XPRESS_50_01 deprecated
 algorithm
 objGoodEnough
 reform
 secret
XPRESS_51_01 deprecated
 knitroOptFile
*
* Groups
* <group-ident> group <group-number <help-context> <help-text>
*
general group 1 1 General LP / MIP / QP Options
hardware group 2 1 Hardware Related Options
presolve group 3 1 Presolve Options
scaling group 4 1 Scaling Options
LP group 5 1 LP Options
QP group 6 1 QP Options
barrier group 7 1 Newton-barrier Options
global group 8 1 Global Solver Options
MIP group 9 1 MIP Options
MIP_cuts group 10 1 MIP Cuts Options
MIP_heuristic group 11 1 MIP Heuristics Options
solnpool group 12 1 MIP Solution Pool Options
SLP group 13 1 General NLP / MINLP Options
SLP_presolve group 14 1 NLP Presolve Options
SLP_augment group 15 1 NLP Augmentation and Linearization Options
SLP_barrier group 16 1 NLP Barrier Options
SLP_penalty group 17 1 NLP Penalty Options
SLP_stepbounds group 18 1 NLP Step Bounds Options
SLP_varupdate group 19 1 NLP Variable Update Options
SLP_termination group 20 1 NLP Termination Options
SLP_multistart group 21 1 NLP Multistart Options
SLP_diff group 22 1 NLP Derivative Options
SLP_log group 23 1 NLP Log Options
MISLP group 24 1 MINLP Options
knitro group 25 1 KNITRO Options
*** End of file
