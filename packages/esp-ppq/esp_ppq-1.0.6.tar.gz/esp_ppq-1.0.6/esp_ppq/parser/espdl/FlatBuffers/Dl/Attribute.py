# automatically generated by the FlatBuffers compiler, do not modify

# namespace: Dl

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class Attribute(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Attribute()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsAttribute(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Attribute
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Attribute
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Attribute
    def RefAttrName(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Attribute
    def DocString(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Attribute
    def AttrType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Attribute
    def F(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = o + self._tab.Pos
            from FlatBuffers.Dl.AttributeF import AttributeF
            obj = AttributeF()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def I(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            x = o + self._tab.Pos
            from FlatBuffers.Dl.AttributeI import AttributeI
            obj = AttributeI()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def S(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Attribute
    def SAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Attribute
    def SLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Attribute
    def SIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

    # Attribute
    def T(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from FlatBuffers.Dl.Tensor import Tensor
            obj = Tensor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def G(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from FlatBuffers.Dl.Graph import Graph
            obj = Graph()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def Tp(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from FlatBuffers.Dl.TypeInfo import TypeInfo
            obj = TypeInfo()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def Floats(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Float32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Attribute
    def FloatsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Float32Flags, o)
        return 0

    # Attribute
    def FloatsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Attribute
    def FloatsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        return o == 0

    # Attribute
    def Ints(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int64Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 8))
        return 0

    # Attribute
    def IntsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int64Flags, o)
        return 0

    # Attribute
    def IntsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Attribute
    def IntsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        return o == 0

    # Attribute
    def Strings(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Attribute
    def StringsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Attribute
    def StringsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        return o == 0

    # Attribute
    def Tensors(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from FlatBuffers.Dl.Tensor import Tensor
            obj = Tensor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def TensorsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Attribute
    def TensorsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        return o == 0

    # Attribute
    def Graphs(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from FlatBuffers.Dl.Graph import Graph
            obj = Graph()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def GraphsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Attribute
    def GraphsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        return o == 0

    # Attribute
    def TypeProtos(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from FlatBuffers.Dl.TypeInfo import TypeInfo
            obj = TypeInfo()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Attribute
    def TypeProtosLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Attribute
    def TypeProtosIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        return o == 0

def AttributeStart(builder):
    builder.StartObject(16)

def Start(builder):
    AttributeStart(builder)

def AttributeAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def AddName(builder, name):
    AttributeAddName(builder, name)

def AttributeAddRefAttrName(builder, refAttrName):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(refAttrName), 0)

def AddRefAttrName(builder, refAttrName):
    AttributeAddRefAttrName(builder, refAttrName)

def AttributeAddDocString(builder, docString):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(docString), 0)

def AddDocString(builder, docString):
    AttributeAddDocString(builder, docString)

def AttributeAddAttrType(builder, attrType):
    builder.PrependInt32Slot(3, attrType, 0)

def AddAttrType(builder, attrType):
    AttributeAddAttrType(builder, attrType)

def AttributeAddF(builder, f):
    builder.PrependStructSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(f), 0)

def AddF(builder, f):
    AttributeAddF(builder, f)

def AttributeAddI(builder, i):
    builder.PrependStructSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(i), 0)

def AddI(builder, i):
    AttributeAddI(builder, i)

def AttributeAddS(builder, s):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(s), 0)

def AddS(builder, s):
    AttributeAddS(builder, s)

def AttributeStartSVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def StartSVector(builder, numElems):
    return AttributeStartSVector(builder, numElems)

def AttributeAddT(builder, t):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(t), 0)

def AddT(builder, t):
    AttributeAddT(builder, t)

def AttributeAddG(builder, g):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(g), 0)

def AddG(builder, g):
    AttributeAddG(builder, g)

def AttributeAddTp(builder, tp):
    builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(tp), 0)

def AddTp(builder, tp):
    AttributeAddTp(builder, tp)

def AttributeAddFloats(builder, floats):
    builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(floats), 0)

def AddFloats(builder, floats):
    AttributeAddFloats(builder, floats)

def AttributeStartFloatsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartFloatsVector(builder, numElems):
    return AttributeStartFloatsVector(builder, numElems)

def AttributeAddInts(builder, ints):
    builder.PrependUOffsetTRelativeSlot(11, flatbuffers.number_types.UOffsetTFlags.py_type(ints), 0)

def AddInts(builder, ints):
    AttributeAddInts(builder, ints)

def AttributeStartIntsVector(builder, numElems):
    return builder.StartVector(8, numElems, 8)

def StartIntsVector(builder, numElems):
    return AttributeStartIntsVector(builder, numElems)

def AttributeAddStrings(builder, strings):
    builder.PrependUOffsetTRelativeSlot(12, flatbuffers.number_types.UOffsetTFlags.py_type(strings), 0)

def AddStrings(builder, strings):
    AttributeAddStrings(builder, strings)

def AttributeStartStringsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartStringsVector(builder, numElems):
    return AttributeStartStringsVector(builder, numElems)

def AttributeAddTensors(builder, tensors):
    builder.PrependUOffsetTRelativeSlot(13, flatbuffers.number_types.UOffsetTFlags.py_type(tensors), 0)

def AddTensors(builder, tensors):
    AttributeAddTensors(builder, tensors)

def AttributeStartTensorsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartTensorsVector(builder, numElems):
    return AttributeStartTensorsVector(builder, numElems)

def AttributeAddGraphs(builder, graphs):
    builder.PrependUOffsetTRelativeSlot(14, flatbuffers.number_types.UOffsetTFlags.py_type(graphs), 0)

def AddGraphs(builder, graphs):
    AttributeAddGraphs(builder, graphs)

def AttributeStartGraphsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartGraphsVector(builder, numElems):
    return AttributeStartGraphsVector(builder, numElems)

def AttributeAddTypeProtos(builder, typeProtos):
    builder.PrependUOffsetTRelativeSlot(15, flatbuffers.number_types.UOffsetTFlags.py_type(typeProtos), 0)

def AddTypeProtos(builder, typeProtos):
    AttributeAddTypeProtos(builder, typeProtos)

def AttributeStartTypeProtosVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartTypeProtosVector(builder, numElems):
    return AttributeStartTypeProtosVector(builder, numElems)

def AttributeEnd(builder):
    return builder.EndObject()

def End(builder):
    return AttributeEnd(builder)

import FlatBuffers.Dl.AttributeF
import FlatBuffers.Dl.AttributeI
import FlatBuffers.Dl.Graph
import FlatBuffers.Dl.Tensor
import FlatBuffers.Dl.TypeInfo
try:
    from typing import List, Optional
except:
    pass

class AttributeT(object):

    # AttributeT
    def __init__(self):
        self.name = None  # type: str
        self.refAttrName = None  # type: str
        self.docString = None  # type: str
        self.attrType = 0  # type: int
        self.f = None  # type: Optional[FlatBuffers.Dl.AttributeF.AttributeFT]
        self.i = None  # type: Optional[FlatBuffers.Dl.AttributeI.AttributeIT]
        self.s = None  # type: List[int]
        self.t = None  # type: Optional[FlatBuffers.Dl.Tensor.TensorT]
        self.g = None  # type: Optional[FlatBuffers.Dl.Graph.GraphT]
        self.tp = None  # type: Optional[FlatBuffers.Dl.TypeInfo.TypeInfoT]
        self.floats = None  # type: List[float]
        self.ints = None  # type: List[int]
        self.strings = None  # type: List[str]
        self.tensors = None  # type: List[FlatBuffers.Dl.Tensor.TensorT]
        self.graphs = None  # type: List[FlatBuffers.Dl.Graph.GraphT]
        self.typeProtos = None  # type: List[FlatBuffers.Dl.TypeInfo.TypeInfoT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        attribute = Attribute()
        attribute.Init(buf, pos)
        return cls.InitFromObj(attribute)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, attribute):
        x = AttributeT()
        x._UnPack(attribute)
        return x

    # AttributeT
    def _UnPack(self, attribute):
        if attribute is None:
            return
        self.name = attribute.Name()
        self.refAttrName = attribute.RefAttrName()
        self.docString = attribute.DocString()
        self.attrType = attribute.AttrType()
        if attribute.F() is not None:
            self.f = FlatBuffers.Dl.AttributeF.AttributeFT.InitFromObj(attribute.F())
        if attribute.I() is not None:
            self.i = FlatBuffers.Dl.AttributeI.AttributeIT.InitFromObj(attribute.I())
        if not attribute.SIsNone():
            if np is None:
                self.s = []
                for i in range(attribute.SLength()):
                    self.s.append(attribute.S(i))
            else:
                self.s = attribute.SAsNumpy()
        if attribute.T() is not None:
            self.t = FlatBuffers.Dl.Tensor.TensorT.InitFromObj(attribute.T())
        if attribute.G() is not None:
            self.g = FlatBuffers.Dl.Graph.GraphT.InitFromObj(attribute.G())
        if attribute.Tp() is not None:
            self.tp = FlatBuffers.Dl.TypeInfo.TypeInfoT.InitFromObj(attribute.Tp())
        if not attribute.FloatsIsNone():
            if np is None:
                self.floats = []
                for i in range(attribute.FloatsLength()):
                    self.floats.append(attribute.Floats(i))
            else:
                self.floats = attribute.FloatsAsNumpy()
        if not attribute.IntsIsNone():
            if np is None:
                self.ints = []
                for i in range(attribute.IntsLength()):
                    self.ints.append(attribute.Ints(i))
            else:
                self.ints = attribute.IntsAsNumpy()
        if not attribute.StringsIsNone():
            self.strings = []
            for i in range(attribute.StringsLength()):
                self.strings.append(attribute.Strings(i))
        if not attribute.TensorsIsNone():
            self.tensors = []
            for i in range(attribute.TensorsLength()):
                if attribute.Tensors(i) is None:
                    self.tensors.append(None)
                else:
                    tensor_ = FlatBuffers.Dl.Tensor.TensorT.InitFromObj(attribute.Tensors(i))
                    self.tensors.append(tensor_)
        if not attribute.GraphsIsNone():
            self.graphs = []
            for i in range(attribute.GraphsLength()):
                if attribute.Graphs(i) is None:
                    self.graphs.append(None)
                else:
                    graph_ = FlatBuffers.Dl.Graph.GraphT.InitFromObj(attribute.Graphs(i))
                    self.graphs.append(graph_)
        if not attribute.TypeProtosIsNone():
            self.typeProtos = []
            for i in range(attribute.TypeProtosLength()):
                if attribute.TypeProtos(i) is None:
                    self.typeProtos.append(None)
                else:
                    typeInfo_ = FlatBuffers.Dl.TypeInfo.TypeInfoT.InitFromObj(attribute.TypeProtos(i))
                    self.typeProtos.append(typeInfo_)

    # AttributeT
    def Pack(self, builder):
        if self.name is not None:
            name = builder.CreateString(self.name)
        if self.refAttrName is not None:
            refAttrName = builder.CreateString(self.refAttrName)
        if self.docString is not None:
            docString = builder.CreateString(self.docString)
        if self.s is not None:
            if np is not None and type(self.s) is np.ndarray:
                s = builder.CreateNumpyVector(self.s)
            else:
                AttributeStartSVector(builder, len(self.s))
                for i in reversed(range(len(self.s))):
                    builder.PrependUint8(self.s[i])
                s = builder.EndVector()
        if self.t is not None:
            t = self.t.Pack(builder)
        if self.g is not None:
            g = self.g.Pack(builder)
        if self.tp is not None:
            tp = self.tp.Pack(builder)
        if self.floats is not None:
            if np is not None and type(self.floats) is np.ndarray:
                floats = builder.CreateNumpyVector(self.floats)
            else:
                AttributeStartFloatsVector(builder, len(self.floats))
                for i in reversed(range(len(self.floats))):
                    builder.PrependFloat32(self.floats[i])
                floats = builder.EndVector()
        if self.ints is not None:
            if np is not None and type(self.ints) is np.ndarray:
                ints = builder.CreateNumpyVector(self.ints)
            else:
                AttributeStartIntsVector(builder, len(self.ints))
                for i in reversed(range(len(self.ints))):
                    builder.PrependInt64(self.ints[i])
                ints = builder.EndVector()
        if self.strings is not None:
            stringslist = []
            for i in range(len(self.strings)):
                stringslist.append(builder.CreateString(self.strings[i]))
            AttributeStartStringsVector(builder, len(self.strings))
            for i in reversed(range(len(self.strings))):
                builder.PrependUOffsetTRelative(stringslist[i])
            strings = builder.EndVector()
        if self.tensors is not None:
            tensorslist = []
            for i in range(len(self.tensors)):
                tensorslist.append(self.tensors[i].Pack(builder))
            AttributeStartTensorsVector(builder, len(self.tensors))
            for i in reversed(range(len(self.tensors))):
                builder.PrependUOffsetTRelative(tensorslist[i])
            tensors = builder.EndVector()
        if self.graphs is not None:
            graphslist = []
            for i in range(len(self.graphs)):
                graphslist.append(self.graphs[i].Pack(builder))
            AttributeStartGraphsVector(builder, len(self.graphs))
            for i in reversed(range(len(self.graphs))):
                builder.PrependUOffsetTRelative(graphslist[i])
            graphs = builder.EndVector()
        if self.typeProtos is not None:
            typeProtoslist = []
            for i in range(len(self.typeProtos)):
                typeProtoslist.append(self.typeProtos[i].Pack(builder))
            AttributeStartTypeProtosVector(builder, len(self.typeProtos))
            for i in reversed(range(len(self.typeProtos))):
                builder.PrependUOffsetTRelative(typeProtoslist[i])
            typeProtos = builder.EndVector()
        AttributeStart(builder)
        if self.name is not None:
            AttributeAddName(builder, name)
        if self.refAttrName is not None:
            AttributeAddRefAttrName(builder, refAttrName)
        if self.docString is not None:
            AttributeAddDocString(builder, docString)
        AttributeAddAttrType(builder, self.attrType)
        if self.f is not None:
            f = self.f.Pack(builder)
            AttributeAddF(builder, f)
        if self.i is not None:
            i = self.i.Pack(builder)
            AttributeAddI(builder, i)
        if self.s is not None:
            AttributeAddS(builder, s)
        if self.t is not None:
            AttributeAddT(builder, t)
        if self.g is not None:
            AttributeAddG(builder, g)
        if self.tp is not None:
            AttributeAddTp(builder, tp)
        if self.floats is not None:
            AttributeAddFloats(builder, floats)
        if self.ints is not None:
            AttributeAddInts(builder, ints)
        if self.strings is not None:
            AttributeAddStrings(builder, strings)
        if self.tensors is not None:
            AttributeAddTensors(builder, tensors)
        if self.graphs is not None:
            AttributeAddGraphs(builder, graphs)
        if self.typeProtos is not None:
            AttributeAddTypeProtos(builder, typeProtos)
        attribute = AttributeEnd(builder)
        return attribute
