// defer to types in global.d.ts
// this local... naming is to workaround a TypeScript limitation that
// doesn't allow referring explicitly to global names (thus cannot override here)
// IMPROVE: invert relationship for global.d.ts looks here instead
import * as IO from 'io-ts';

type localJsonScalar = JsonScalar
type localJsonValue = JsonValue
type localObjectId = ObjectId

export type {
  localJsonScalar as JsonScalar,
  localJsonValue as JsonValue,
  localObjectId as ObjectId,
}

export const IOObjectId = IO.Integer;
export const IOJsonScalar = IO.union([IO.string, IO.number, IO.boolean, IO.null]);
export const IOJsonValue: IO.Type<JsonValue> = IO.recursion('JsonValue', () =>
  IO.union([
    IOJsonScalar,
    IO.record(IO.string, IOJsonValue),
    IO.array(IOJsonValue),
  ]),
);

// Testing this approach to get strongly typed strings. If it proves
// useful we should elevant to type_spec. The same is possible in Python
export interface nominal<T> {
  "nominal structural brand": T
}
