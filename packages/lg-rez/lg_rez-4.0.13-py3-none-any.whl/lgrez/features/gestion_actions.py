"""lg-rez / features / Gestion des actions

Liste, cr√©ation, suppression, ouverture, fermeture d'actions

"""

import datetime
from typing import Literal

from lgrez import config, commons
from lgrez.blocs import tools
from lgrez.bdd import Action, BaseAction, Tache, Utilisation, ActionTrigger, Joueur


def add_action(
    joueur: Joueur, base: BaseAction, cooldown: int = 0, charges: int | None = None, active: bool = True
) -> Action:
    """Enregistre une action et programme son ouverture le cas √©ch√©ant.

    Si une action existe d√©j√† pour ce joueur et cette base, la modifie ; sinon, en cr√©e une nouvelle.

    Args:
        joueur, base, cooldown, charges, active: Param√®tres de l'action.
    """
    action = Action.query.filter_by(joueur=joueur, base=base).first()
    if action:
        action.cooldown = cooldown
        action.charges = charges
        action.active = active
        action.update()
    else:
        action = Action(joueur=joueur, base=base, cooldown=cooldown, charges=charges, active=active)
        action.add()

    # Ajout t√¢che ouverture
    if action.base.trigger_debut == ActionTrigger.temporel:
        # Temporel : on programme
        Tache(
            timestamp=tools.next_occurrence(action.base.heure_debut),
            commande="open action",
            parameters={"id": action.id},
            action=action,
        ).add()

    elif action.base.trigger_debut == ActionTrigger.perma:
        # Perma : ON LANCE DIRECT (sera repouss√© si jeu ferm√©)
        Tache(
            timestamp=datetime.datetime.now(), commande="open action", parameters={"id": action.id}, action=action
        ).add()

    return action


def delete_action(action: Action) -> None:
    """Archive une action et annule les t√¢ches en cours li√©es.

    Depuis la version 2.1, l'action n'est plus supprim√©e mais est pass√©e √† :attr:`~.bdd.Action.active` = ``False``.

    Args:
        action: L'action √† supprimer.
    """
    # Suppression t√¢ches li√©es √† l'action
    if action.taches:
        Tache.delete(*action.taches)

    if action.is_open:
        action.utilisation_ouverte.close()

    action.active = False
    action.update()
    # action.delete()


async def open_action(action: Action) -> None:
    """Ouvre l'action.

    Args:
        action: L'action √† ouvrir.

    Op√©rations r√©alis√©es :
        - V√©rification des conditions (cooldown, charges...) et reprogrammation si n√©cessaire ;
        - Gestion des t√¢ches planifi√©es (planifie remind/close si applicable) ;
        - Information du joueur.
    """
    joueur = action.joueur
    chan = joueur.private_chan

    # V√©rification base
    if not action.base:
        await tools.log(f"{action} : pas de base, exit")
        return

    # V√©rification active
    if not action.active:
        await tools.log(f"{action} : inactive, exit (pas de reprogrammation)")
        return

    # V√©rification cooldown
    if action.cooldown > 0:  # Action en cooldown
        action.cooldown = action.cooldown - 1
        config.session.commit()
        await tools.log(f"{action} : en cooldown, exit (reprogrammation si temporel).")
        if action.base.trigger_debut == ActionTrigger.temporel:
            # Programmation action du lendemain
            ts = tools.next_occurrence(action.base.heure_debut)
            Tache(timestamp=ts, commande="open action", parameters={"id": action.id}, action=action).add()
        return

    # V√©rification role_actif
    if not joueur.role_actif:
        # role_actif == False : on reprogramme la t√¢che au lendemain tanpis
        await tools.log(f"{action} : role_actif == False, exit (reprogrammation si temporel).")
        if action.base.trigger_debut == ActionTrigger.temporel:
            ts = tools.next_occurrence(action.base.heure_debut)
            Tache(timestamp=ts, commande="open action", parameters={"id": action.id}, action=action).add()
        return

    # V√©rification charges
    if action.charges == 0:
        # Plus de charges, mais action maintenue en base car refill / ...
        await tools.log(f"{action} : plus de charges, exit (reprogrammation si temporel).")
        return

    # Action "automatiques" (passives : notaire...) :
    # lance la proc√©dure de cl√¥ture / r√©solution
    if action.base.trigger_fin == ActionTrigger.auto:
        if action.base.trigger_debut == ActionTrigger.temporel:
            await tools.log(
                f"Action {action.base.slug} pour {joueur.nom} pas vraiment automatique, {config.Role.mj.mention} "
                f"VENEZ M'AIDER JE PANIQUE üò± (comme je suis vraiment sympa je vous file son chan, {chan.mention})"
            )
        else:
            await tools.log(f"{action} : automatique, appel processus de cl√¥ture")

        await close_action(action)
        return

    # Tous tests pr√©liminaires n'ont pas return ==> Vraie action √† lancer

    # Calcul heure de fin (si applicable)
    heure_fin = None
    if action.base.trigger_fin == ActionTrigger.temporel:
        heure_fin = action.base.heure_fin
        ts = tools.next_occurrence(heure_fin)
    elif action.base.trigger_fin == ActionTrigger.delta:
        # Si delta, on calcule la vraie heure de fin (pas modifi√© en base)
        delta = action.base.heure_fin
        ts = datetime.datetime.now() + datetime.timedelta(hours=delta.hour, minutes=delta.minute, seconds=delta.second)
        heure_fin = ts.time()

    # Programmation remind / close
    if action.base.trigger_fin in [ActionTrigger.temporel, ActionTrigger.delta]:
        remind_ts = ts - datetime.timedelta(minutes=30)
        Tache(timestamp=remind_ts, commande="remind action", parameters={"id": action.id}, action=action).add()
        Tache(timestamp=ts, commande="close action", parameters={"id": action.id}, action=action).add()
    elif action.base.trigger_fin == ActionTrigger.perma:
        # Action permanente : fermer pour le WE
        # ou rappel / r√©initialisation chaque jour
        ts_matin = tools.next_occurrence(datetime.time(hour=7))
        ts_pause = tools.debut_pause()
        if ts_matin < ts_pause:
            # R√©open le lendamain
            Tache(timestamp=ts_matin, commande="open action", parameters={"id": action.id}, action=action).add()
        else:
            # Sauf si pause d'ici l√†
            Tache(timestamp=ts_pause, commande="close action", parameters={"id": action.id}, action=action).add()

    # Information du joueur
    if action.is_open:  # d√©j√† ouverte
        await chan.send(
            f"{tools.montre()}  Rappel : tu peux utiliser quand tu le souhaites "
            f"ton action {tools.code(action.base.slug)} !  {config.Emoji.action}\n"
            + (f"Tu as jusqu'√† {heure_fin} pour le faire. \n" if heure_fin else "")
            + tools.ital(f"Utilise `/action` pour agir.")
        )
    else:
        # on ouvre !
        util = Utilisation(action=action)
        util.add()
        util.open()
        await chan.send(
            f"{tools.montre()}  Tu peux maintenant utiliser ton action "
            f"{tools.code(action.base.slug)} !  {config.Emoji.action}\n"
            + (f"Tu as jusqu'√† {heure_fin} pour le faire. \n" if heure_fin else "")
            + tools.ital(f"Utilise `/action` pour agir.")
        )

    config.session.commit()


async def close_action(action: Action) -> None:
    """Ferme l'action.

    Args:
        action: L'action √† enregistrer.

    Op√©rations r√©alis√©es :
        - Archivage si n√©cessaire ;
        - Gestion des t√¢ches planifi√©es (planifie prochaine ouverture si applicable) ;
        - Information du joueur (si charge-- seulement).
    """
    joueur = action.joueur
    chan = joueur.private_chan

    # V√©rification base
    if not action.base:
        await tools.log(f"{action} : pas de base, exit")
        return

    # V√©rification active
    if not action.active:
        await tools.log(f"{action} : inactive, exit")
        return

    # V√©rification ouverte
    if not action.is_open:
        await tools.log(f"{action} : pas ouverte, exit")
        return

    deleted = False
    if not action.is_waiting:  # d√©cision prise
        # R√©solution de l'action
        # (pour l'instant juste charge -= 1 et suppression le cas √©ch√©ant)
        if action.charges:
            action.charges = action.charges - 1
            pcs = " pour cette semaine" if "weekends" in action.base.refill else ""
            await chan.send(f"Il te reste {action.charges} charge(s){pcs}.")

            if action.charges == 0 and not action.base.refill:
                delete_action(action)
                deleted = True

    if not deleted:
        # Si l'action a √©t√© faite et a un cooldown, on le met
        if (not action.is_waiting) and (action.base.base_cooldown > 0):
            action.cooldown = action.base.base_cooldown

        action.utilisation_ouverte.close()

        # Programmation prochaine ouverture
        if action.base.trigger_debut == ActionTrigger.temporel:
            ts = tools.next_occurrence(action.base.heure_debut)
            Tache(timestamp=ts, commande="open action", parameters={"id": action.id}, action=action).add()
        elif action.base.trigger_debut == ActionTrigger.perma:
            # Action permanente : ouvrir apr√®s le WE
            ts = tools.fin_pause()
            Tache(timestamp=ts, commande="open action", parameters={"id": action.id}, action=action).add()

    config.session.commit()


def get_actions(
    quoi: Literal["open", "close", "remind"], trigger: ActionTrigger, heure: datetime.time | None = None
) -> list[Action]:
    """Renvoie les actions r√©pondant √† un d√©clencheur donn√©.

    Args:
        quoi: Type d'op√©ration en cours :

          - ``"open"`` : ouverture, :attr:`Action.is_open` doit √™tre faux;
          - ``"close"`` :  fermeture, :attr:`Action.is_open` doit √™tre vrai;
          - ``"remind"`` : rappel, :attr:`Action.is_waiting` doit √™tre vrai.

        trigger: valeur de ``Action.trigger_debut/fin`` √† d√©tecter.
        heure: si ``trigger == "temporel"``, ajoute la condition ``Action.heure_debut/fin == heure``.

    Returns:
        La liste des actions correspondantes.
    """
    filter = Action.active.is_(True).join(Action.base)

    if quoi == "open":
        filter &= (BaseAction.trigger_debut == trigger) & ~Action.is_open
    elif quoi == "close":
        filter &= (BaseAction.trigger_fin == trigger) & Action.is_open
    elif quoi == "remind":
        filter &= (BaseAction.trigger_fin == trigger) & Action.is_waiting
    else:
        raise commons.UserInputError("quoi", f"bad value: '{quoi}'")

    if trigger == ActionTrigger.temporel:
        if not heure:
            raise commons.UserInputError("quand", "merci de pr√©ciser une heure")

        if quoi == "open":
            filter &= BaseAction.heure_debut == heure
        else:  # close / remind
            filter &= BaseAction.heure_fin == heure

    return Action.query.filter(filter).all()
