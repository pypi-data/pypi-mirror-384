from typing import Annotated, Callable, Literal

import pydantic
from desc import equilibrium as desc_equilibrium
from desc import grid as desc_grid
from desc import magnetic_fields as desc_magnetic_fields
from desc import objectives as desc_objectives


class QPInitialGuessSettings(pydantic.BaseModel):
    major_radius: pydantic.PositiveFloat = 1.0
    """Average major radius.

    Constant term in the R coordinate.
    """
    aspect_ratio: pydantic.PositiveFloat = 10.0
    """The aspect ratio of the equilibrium."""
    mirror_ratio: Annotated[float, pydantic.Field(gt=0.0, le=1.0)] = 0.2
    """Mirror ratio generated by toroidal variation of the cross-sectional area."""
    elongation: float = 3.0
    """Elongation of the elliptical surface = major axis / minor axis."""
    torsion: float = 0.0
    """Vertical extent of the magnetic axis Z coordinate.

    Coefficient of sin(2*phi).
    """
    n_field_periods: pydantic.PositiveInt = 1
    """Number of field periods."""
    is_stellarator_symmetric: bool = True
    """Whether the equilibrium is stellarator symmetric."""
    is_iota_positive: bool = False
    """Whether the rotational transform should be positive or negative."""


class NearAxisExpansionInitialGuessSettings(pydantic.BaseModel):
    aspect_ratio: pydantic.PositiveFloat = 10.0
    """Aspect ratio of the equilibrium."""
    max_elongation: pydantic.PositiveFloat = 7.0
    """Maximum elongation of the equilibrium."""
    rotational_transform: float = 0.5
    """Rotational transform of the equilibrium."""
    mirror_ratio: Annotated[float, pydantic.Field(gt=0.0, le=1.0)] = 0.2
    """Mirror ratio generated by toroidal variation of the cross-sectional area."""
    n_field_periods: pydantic.PositiveInt = 1
    """Number of field periods."""
    max_poloidal_mode: pydantic.PositiveInt = 2
    """Maximum poloidal mode number."""
    max_toroidal_mode: pydantic.PositiveInt = 3
    """Maximum toroidal mode number."""


AnyInitialGuessSettings = QPInitialGuessSettings | NearAxisExpansionInitialGuessSettings


class DescEquilibriumSettings(pydantic.BaseModel):
    psi: float = 3e-2
    max_toroidal_mode: int = 4
    max_poloidal_mode: int = 4
    check_orientation: bool = True


class ElongationObjectiveSettings(pydantic.BaseModel):
    name: str = "elongation"
    weight: float = 1.0
    target_kind: Literal["target", "upper_bound"] = "upper_bound"
    """Whether the goal is a target or an upper bound."""

    def create_term(self) -> Callable:
        """Create the objective function term."""

        def term(
            equilibrium: desc_equilibrium.Equilibrium, goal: float
        ) -> desc_objectives.Elongation:
            target = goal if self.target_kind == "target" else None
            bounds = (0, goal) if self.target_kind == "upper_bound" else None

            return desc_objectives.Elongation(
                eq=equilibrium,
                target=target,
                bounds=bounds,
                weight=self.weight,  # type: ignore
                name=self.name,
            )

        return term


class AspectRatioObjectiveSettings(pydantic.BaseModel):
    weight: float = 1.0
    name: str = "aspect_ratio"
    target_kind: Literal["target", "upper_bound"] = "upper_bound"
    """Whether the goal is a target or an upper bound."""

    def create_term(self) -> Callable:
        """Create the objective function term."""

        def term(
            equilibrium: desc_equilibrium.Equilibrium, goal: float
        ) -> desc_objectives.AspectRatio:
            target = goal if self.target_kind == "target" else None
            bounds = (0, goal) if self.target_kind == "upper_bound" else None

            return desc_objectives.AspectRatio(
                eq=equilibrium,
                target=target,
                bounds=bounds,
                weight=self.weight,  # type: ignore
                name=self.name,
            )

        return term


class RotationalTransformObjectiveSettings(pydantic.BaseModel):
    weight: float = 1.0
    name: str = "rotational_transform"
    target_kind: Literal["target", "upper_bound"] = "target"
    """Whether the goal is a target or an upper bound."""

    def create_term(self) -> Callable:
        """Create the objective function term."""

        def term(
            equilibrium: desc_equilibrium.Equilibrium, goal: float
        ) -> desc_objectives.RotationalTransform:
            target = goal if self.target_kind == "target" else None
            bounds = (0, goal) if self.target_kind == "upper_bound" else None

            return desc_objectives.RotationalTransform(
                eq=equilibrium,
                target=target,
                bounds=bounds,
                weight=self.weight,  # type: ignore
                name=self.name,
            )

        return term


class OmnigenityObjeciveSettings(pydantic.BaseModel):
    weight: float = 1.0
    name: str = "omnigenity"
    eq_lcfs_grid_rho: float = 1.0
    eq_lcfs_grid_M_factor: int = 4
    eq_lcfs_grid_N_factor: int = 4
    eta_weight: float = 1.0

    def create_term(self) -> Callable:
        """Create the objective function term."""

        def term(
            equilibrium: desc_equilibrium.Equilibrium,
            field: desc_magnetic_fields.OmnigenousField,
        ) -> desc_objectives.Omnigenity:
            eq_lcfs_grid = desc_grid.LinearGrid(
                rho=self.eq_lcfs_grid_rho,  # type: ignore
                M=self.eq_lcfs_grid_M_factor * equilibrium.M,
                N=self.eq_lcfs_grid_N_factor * equilibrium.N,
                NFP=equilibrium.NFP,
                sym=False,  # TODO(scadena): revise this assumption from tutorial
            )

            return desc_objectives.Omnigenity(
                eq=equilibrium,
                field=field,
                field_fixed=True,
                eq_grid=eq_lcfs_grid,
                weight=self.weight,  # type: ignore
                name=self.name,
            )

        return term


class DescObjectiveFunctionSettings(pydantic.BaseModel):
    aspect_ratio_settings: AspectRatioObjectiveSettings | None = (
        AspectRatioObjectiveSettings()
    )  # noqa: E501
    elongation_settings: ElongationObjectiveSettings | None = (
        ElongationObjectiveSettings()
    )  # noqa: E501
    rotational_transform_settings: RotationalTransformObjectiveSettings | None = (
        RotationalTransformObjectiveSettings()
    )
    omnigenity_settings: OmnigenityObjeciveSettings | None = (
        OmnigenityObjeciveSettings()
    )  # noqa: E501

    def get_objective(
        self,
        equilibrium: desc_equilibrium.Equilibrium,
        field: desc_magnetic_fields.OmnigenousField,
        aspect_ratio: float | None = None,
        elongation: float | None = None,
        rotational_transform: float | None = None,
    ) -> desc_objectives.ObjectiveFunction:
        """Get the objective function from the settings."""
        terms = []
        if self.aspect_ratio_settings is not None and aspect_ratio is not None:
            terms.append(
                self.aspect_ratio_settings.create_term()(equilibrium, goal=aspect_ratio)
            )
        if self.elongation_settings is not None and elongation is not None:
            terms.append(
                self.elongation_settings.create_term()(equilibrium, goal=elongation)
            )
        if (
            self.rotational_transform_settings is not None
            and rotational_transform is not None
        ):  # noqa: E501
            terms.append(
                self.rotational_transform_settings.create_term()(
                    equilibrium,
                    goal=-rotational_transform,  # Change sign due to DESC convention # noqa: E501
                )
            )
        if self.omnigenity_settings is not None:
            terms.append(
                self.omnigenity_settings.create_term()(equilibrium, field=field)
            )

        objective = desc_objectives.ObjectiveFunction(objectives=terms)
        objective.build()
        return objective


class DescOptimizerSettings(pydantic.BaseModel):
    name: str = "lsq-auglag"
    maxiter: int = 200
    verbose: int = 3


class DescOmnigenousFieldOptimizationSettings(pydantic.BaseModel):
    initial_guess_settings: AnyInitialGuessSettings = QPInitialGuessSettings()
    equilibrium_settings: DescEquilibriumSettings = DescEquilibriumSettings()
    objective_settings: DescObjectiveFunctionSettings = DescObjectiveFunctionSettings()
    optimizer_settings: DescOptimizerSettings = DescOptimizerSettings()
