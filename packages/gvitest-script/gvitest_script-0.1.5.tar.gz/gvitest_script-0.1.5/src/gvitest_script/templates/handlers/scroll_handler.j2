{# æ»šåŠ¨åŠ¨ä½œå¤„ç†æ¨¡æ¿ - æ”¯æŒæ™ºèƒ½æ»šåŠ¨åŒºåŸŸè¯†åˆ«å’Œå¤šç§æ»šåŠ¨æ–¹å¼ #}

{# æ»šåŠ¨åŠ¨ä½œå¤„ç†å‡½æ•° #}
def handle_scroll_action(step_data, device, runner_dir, screenshot_count, previous_after_screenshot=None):
    """
    å¤„ç†æ»šåŠ¨åŠ¨ä½œ - æ”¯æŒæ™ºèƒ½æ»šåŠ¨åŒºåŸŸè¯†åˆ«å’Œå¤šç§æ»šåŠ¨æ–¹å¼
    
    Args:
        step_data: æ­¥éª¤ä¸Šä¸‹æ–‡å¯¹è±¡
        device: uiautomator2è®¾å¤‡å¯¹è±¡
        runner_dir: è¿è¡Œç›®å½•è·¯å¾„
        screenshot_count: æˆªå›¾è®¡æ•°
        previous_after_screenshot: å‰ä¸€æ­¥çš„æ‰§è¡Œåæˆªå›¾è·¯å¾„ï¼Œç”¨äºä¼˜åŒ–æˆªå›¾æ€§èƒ½
    
    Returns:
        Dict: æ‰§è¡Œç»“æœ
    """
    logging.info("å¼€å§‹æ‰§è¡Œæ­¥éª¤ %s: %s" % (step_data.get('step_number', 0), step_data.get('step_name', 'æœªçŸ¥æ­¥éª¤')))

    step_name = step_data.get('step_name', 'æ»šåŠ¨æ“ä½œ')
    operation_type = step_data.get('operation_type', 'scroll')
    # å…¼å®¹ä¸¤ç§æ•°æ®ç»“æ„ï¼šç›´æ¥åœ¨æ ¹çº§åˆ«çš„element_infoå’Œåœ¨parametersä¸­çš„element_info
    element_info = step_data.get('element_info', {}) or step_data.get('parameters', {}).get('element_info', {})
    
    # è·å–æ»šåŠ¨å‚æ•°
    direction = element_info.get('direction', 'down')
    distance = element_info.get('distance', 800)
    scroll_type = element_info.get('scroll_type', 'vertical')
    
    logging.info(f"å¼€å§‹æ‰§è¡Œæ»šåŠ¨æ“ä½œ: {step_name}, æ–¹å‘: {direction}, è·ç¦»: {distance}")
    
    try:
        # æ‰§è¡Œå‰æ— éœ€ç­‰å¾…UIç¨³å®šï¼Œç›´æ¥è¿›è¡Œæ“ä½œ
        
        # ä¼˜åŒ–æˆªå›¾é€»è¾‘ï¼šå¦‚æœæœ‰å‰ä¸€æ­¥çš„æˆªå›¾ï¼Œå°±å¤ç”¨å®ƒ
        step_number = step_data.get('step_number', 0)
        
        if previous_after_screenshot:
            # ä½¿ç”¨å‰ä¸€æ­¥çš„åæˆªå›¾ä½œä¸ºå½“å‰æ­¥éª¤çš„å‰æˆªå›¾ï¼Œé¿å…é‡å¤æˆªå›¾
            before_execution_screenshot_path = previous_after_screenshot
            logging.info(f"ğŸ“¸ å¤ç”¨å‰ä¸€æ­¥æˆªå›¾ä½œä¸ºæ‰§è¡Œå‰æˆªå›¾: {before_execution_screenshot_path}")
        else:
            # ç¬¬ä¸€æ­¥æˆ–æ²¡æœ‰å‰ä¸€æ­¥æˆªå›¾æ—¶ï¼Œéœ€è¦æ–°æˆªå›¾
            before_execution_screenshot_path = take_screenshot_and_save(
                device, runner_dir, f"before_step{step_number}", "æ‰§è¡Œå‰æˆªå›¾ - ç”¨äºè®°å½•æ»šåŠ¨å‰çŠ¶æ€"
            )
        
        # æ›´æ–°æ­¥éª¤æ‰§è¡Œå‰æˆªå›¾ä¿¡æ¯
        step_data['before_execution_screenshot_path'] = before_execution_screenshot_path
        

        
        # æ‰§è¡Œæ»šåŠ¨æ“ä½œ
        logging.info(f"æ‰§è¡Œæ»šåŠ¨æ“ä½œï¼Œæ–¹å‘: {direction}, è·ç¦»: {distance}")
        

        
        # æ ¹æ®æ»šåŠ¨ç±»å‹å’Œæ–¹å‘æ‰§è¡Œ
        if scroll_type == 'vertical':
            if direction.lower() in ['down', 'up']:
                device.swipe_ext(direction.lower(), scale=distance/1000.0)
            else:
                logging.warning(f"å‚ç›´æ»šåŠ¨ä¸æ”¯æŒæ–¹å‘: {direction}ï¼Œä½¿ç”¨é»˜è®¤down")
                device.swipe_ext("down", scale=distance/1000.0)
        elif scroll_type == 'horizontal':
            if direction.lower() in ['left', 'right']:
                device.swipe_ext(direction.lower(), scale=distance/1000.0)
            else:
                logging.warning(f"æ°´å¹³æ»šåŠ¨ä¸æ”¯æŒæ–¹å‘: {direction}ï¼Œä½¿ç”¨é»˜è®¤right")
                device.swipe_ext("right", scale=distance/1000.0)
        else:
            # é»˜è®¤ä½¿ç”¨åæ ‡æ»šåŠ¨
            screen_info = device.info
            screen_width = screen_info.get('displayWidth', 1080)
            screen_height = screen_info.get('displayHeight', 1920)
            
            start_x = screen_width // 2
            start_y = screen_height // 2
            
            if direction.lower() == 'down':
                end_x, end_y = start_x, start_y - distance
            elif direction.lower() == 'up':
                end_x, end_y = start_x, start_y + distance
            elif direction.lower() == 'left':
                end_x, end_y = start_x + distance, start_y
            elif direction.lower() == 'right':
                end_x, end_y = start_x - distance, start_y
            else:
                end_x, end_y = start_x, start_y - distance
            
            device.swipe(start_x, start_y, end_x, end_y, duration=0.5)
        
        # ç­‰å¾…æ»šåŠ¨å®Œæˆ
        time.sleep(0.5)
        
        # ç­‰å¾…UIç¨³å®šåè¿›è¡Œæ‰§è¡Œåæˆªå›¾
        logging.info("ç­‰å¾…åŠ¨ä½œæ‰§è¡Œå®ŒæˆåUIç¨³å®š...")
        ui_stable = wait_for_ui_stability(device, timeout=1.0)
        if not ui_stable:
            logging.warning("æ‰§è¡ŒåUIç¨³å®šæ£€æŸ¥è¶…æ—¶ï¼Œç»§ç»­æˆªå›¾")
        
        # æ‰§è¡Œåæˆªå›¾ï¼ˆç”¨äºå“åº”éªŒè¯ï¼‰
        after_execution_screenshot_path = take_screenshot_and_save(
            device, runner_dir, f"after_step{step_number}", "æ‰§è¡Œåæˆªå›¾ - ç”¨äºéªŒè¯æ»šåŠ¨ç»“æœ"
        )
        step_data['after_execution_screenshot_path'] = after_execution_screenshot_path
        
        logging.info("æ­¥éª¤ %s å®Œæˆ: %s, æˆåŠŸ: %s" % (step_data.get('step_number', 0), step_data.get('step_name', 'æœªçŸ¥æ­¥éª¤'), True))
        
        logging.info(f"âœ… æ»šåŠ¨æ“ä½œæ‰§è¡Œå®Œæˆ: {step_name}")
        return {
            "status": "success",
            "message": f"æ»šåŠ¨æ“ä½œæ‰§è¡ŒæˆåŠŸ: {direction} {distance}px",
            "scroll_direction": direction,
            "scroll_distance": distance,
            "scroll_type": scroll_type,
            "screenshots": {
                "before_execution": step_data.get('before_execution_screenshot_path'),
                "after_execution": after_execution_screenshot_path
            },

        }
        
    except Exception as e:
        error_msg = f"æ»šåŠ¨æ“ä½œæ‰§è¡Œå¤±è´¥: {e}"
        logging.error(error_msg)
        

        
        # ç¡®ä¿æœ‰æˆªå›¾è®°å½•é”™è¯¯çŠ¶æ€
        if not step_data.get('before_execution_screenshot_path'):
            try:
                error_screenshot_path = take_screenshot_and_save(
                    device, runner_dir, f"error_{operation_type}", "é”™è¯¯æˆªå›¾ - è®°å½•æ»šåŠ¨æ“ä½œå¤±è´¥æ—¶çš„ç•Œé¢çŠ¶æ€"
                )
                step_data['before_execution_screenshot_path'] = error_screenshot_path
            except Exception as screenshot_error:
                logging.error(f"é”™è¯¯æˆªå›¾å¤±è´¥: {screenshot_error}")
        
        logging.error("æ­¥éª¤ %s æ‰§è¡Œé”™è¯¯: %s, é”™è¯¯: %s" % (step_data.get('step_number', 0), step_data.get('step_name', 'æœªçŸ¥æ­¥éª¤'), error_msg))
        
        return {
            "status": "failed",
            "message": error_msg,

        }


{# æ™ºèƒ½è¯†åˆ«æ»šåŠ¨åŒºåŸŸå‡½æ•° #}
def find_scrollable_region(device, scroll_area_config, target_element_config):
    """
    æ™ºèƒ½è¯†åˆ«æ»šåŠ¨åŒºåŸŸ
    
    Args:
        device: è®¾å¤‡å¯¹è±¡
        scroll_area_config: æ»šåŠ¨åŒºåŸŸé…ç½®
        target_element_config: ç›®æ ‡å…ƒç´ é…ç½®
    
    Returns:
        Dict: æ»šåŠ¨åŒºåŸŸä¿¡æ¯
    """
    try:
        # æ–¹æ³•1ï¼šä½¿ç”¨æŒ‡å®šçš„æ»šåŠ¨åŒºåŸŸåæ ‡
        if scroll_area_config.get('bounds'):
            bounds = scroll_area_config['bounds']
            if all(key in bounds for key in ['left', 'top', 'right', 'bottom']):
                return {
                    'found': True,
                    'bounds': bounds,
                    'method': 'æŒ‡å®šåæ ‡åŒºåŸŸ'
                }
        
        # æ–¹æ³•2ï¼šé€šè¿‡å…ƒç´ åæ ‡å®šä¹‰æ»šåŠ¨åŒºåŸŸ
        if scroll_area_config.get('start_x') is not None:
            start_x = scroll_area_config.get('start_x', 0)
            start_y = scroll_area_config.get('start_y', 0)
            width = scroll_area_config.get('width', 0)
            height = scroll_area_config.get('height', 0)
            
            if width > 0 and height > 0:
                return {
                    'found': True,
                    'bounds': {
                        'left': start_x,
                        'top': start_y,
                        'right': start_x + width,
                        'bottom': start_y + height
                    },
                    'method': 'å…ƒç´ åæ ‡åŒºåŸŸ'
                }
        
        # æ–¹æ³•3ï¼šæŸ¥æ‰¾å¯æ»šåŠ¨çš„UIå…ƒç´ 
        try:
            scrollable_elements = device(scrollable=True)
            if scrollable_elements.exists:
                first_scrollable = scrollable_elements[0]
                bounds = first_scrollable.info['bounds']
                return {
                    'found': True,
                    'bounds': bounds,
                    'method': 'å¯æ»šåŠ¨UIå…ƒç´ '
                }
        except Exception as scrollable_error:
            logging.debug(f"æŸ¥æ‰¾å¯æ»šåŠ¨å…ƒç´ å¤±è´¥: {scrollable_error}")
        
        # æ–¹æ³•4ï¼šé€šè¿‡ç±»åæŸ¥æ‰¾å¸¸è§çš„æ»šåŠ¨å®¹å™¨
        scroll_container_classes = [
            'RecyclerView', 'ListView', 'ScrollView', 
            'NestedScrollView', 'ViewPager', 'GridView'
        ]
        
        for class_name in scroll_container_classes:
            try:
                elements = device(className=class_name)
                if elements.exists:
                    first_element = elements[0]
                    bounds = first_element.info['bounds']
                    return {
                        'found': True,
                        'bounds': bounds,
                        'method': 'æ»šåŠ¨å®¹å™¨ç±»: ' + class_name
                    }
            except:
                continue
        
        # æ–¹æ³•5ï¼šé€šè¿‡IDæŸ¥æ‰¾æ»šåŠ¨åŒºåŸŸ
        scroll_ids = ['recycler_view', 'list_view', 'scroll_view', 'content']
        for scroll_id in scroll_ids:
            try:
                element = device(resourceId=scroll_id)
                if element.exists:
                    bounds = element.info['bounds']
                    return {
                        'found': True,
                        'bounds': bounds,
                        'method': 'æ»šåŠ¨ID: ' + scroll_id
                    }
            except:
                continue
        
        return {
            'found': False,
            'reason': 'æœªæ‰¾åˆ°åˆé€‚çš„æ»šåŠ¨åŒºåŸŸ'
        }
        
    except Exception as e:
        return {
            'found': False,
                                    'reason': 'æŸ¥æ‰¾æ»šåŠ¨åŒºåŸŸå¼‚å¸¸: ' + str(e)
        }


{# æ»‘åŠ¨æ–¹å¼æ»šåŠ¨å‡½æ•° #}
def perform_swipe_scroll(device, direction, bounds, steps, element_info):
    """
    æ‰§è¡Œæ»‘åŠ¨æ–¹å¼æ»šåŠ¨
    
    Args:
        device: è®¾å¤‡å¯¹è±¡
        direction: æ»šåŠ¨æ–¹å‘
        bounds: æ»šåŠ¨åŒºåŸŸè¾¹ç•Œ
        steps: æ»šåŠ¨æ­¥æ•°
        element_info: å…ƒç´ ä¿¡æ¯
    
    Returns:
        Tuple: (success, details)
    """
    try:
        center_x = (bounds['left'] + bounds['right']) // 2
        center_y = (bounds['top'] + bounds['bottom']) // 2
        region_width = bounds['right'] - bounds['left']
        region_height = bounds['bottom'] - bounds['top']
        
        # è®¡ç®—æ»šåŠ¨è·ç¦»
        scroll_distance_ratio = element_info.get('distance_ratio', 0.6)
        duration = element_info.get('duration', 0.5)
        
        success_count = 0
        
        for i in range(steps):
            try:
                if direction == 'down':
                    start_x = center_x
                    start_y = center_y + int(region_height * 0.2)
                    end_x = center_x
                    end_y = center_y - int(region_height * scroll_distance_ratio)
                    
                elif direction == 'up':
                    start_x = center_x
                    start_y = center_y - int(region_height * 0.2)
                    end_x = center_x
                    end_y = center_y + int(region_height * scroll_distance_ratio)
                    
                elif direction == 'left':
                    start_x = center_x + int(region_width * 0.2)
                    start_y = center_y
                    end_x = center_x - int(region_width * scroll_distance_ratio)
                    end_y = center_y
                    
                elif direction == 'right':
                    start_x = center_x - int(region_width * 0.2)
                    start_y = center_y
                    end_x = center_x + int(region_width * scroll_distance_ratio)
                    end_y = center_y
                    
                else:
                    return False, f"ä¸æ”¯æŒçš„æ»šåŠ¨æ–¹å‘: {direction}"
                
                # æ‰§è¡Œæ»‘åŠ¨
                device.swipe(start_x, start_y, end_x, end_y, duration=duration)
                success_count += 1
                
                # æ»šåŠ¨é—´éš”
                if i < steps - 1:
                    time.sleep(0.3)
                    
            except Exception as swipe_error:
                logging.warning(f"ç¬¬{i+1}æ¬¡æ»‘åŠ¨å¤±è´¥: {swipe_error}")
        
        success = success_count > 0
        details = f"{direction}æ–¹å‘æ»‘åŠ¨æ»šåŠ¨ï¼ŒæˆåŠŸ{success_count}/{steps}æ¬¡"
        
        return success, details
        
    except Exception as e:
        return False, f"æ»‘åŠ¨æ»šåŠ¨å¼‚å¸¸: {e}"


{# å¿«é€Ÿæ»‘åŠ¨æ–¹å¼æ»šåŠ¨å‡½æ•° #}
def perform_fling_scroll(device, direction, bounds, steps, element_info):
    """
    æ‰§è¡Œå¿«é€Ÿæ»‘åŠ¨æ–¹å¼æ»šåŠ¨
    
    Args:
        device: è®¾å¤‡å¯¹è±¡
        direction: æ»šåŠ¨æ–¹å‘
        bounds: æ»šåŠ¨åŒºåŸŸè¾¹ç•Œ
        steps: æ»šåŠ¨æ­¥æ•°
        element_info: å…ƒç´ ä¿¡æ¯
    
    Returns:
        Tuple: (success, details)
    """
    try:
        center_x = (bounds['left'] + bounds['right']) // 2
        center_y = (bounds['top'] + bounds['bottom']) // 2
        
        # å¿«é€Ÿæ»‘åŠ¨å‚æ•°
        velocity = element_info.get('velocity', 1000)  # æ»‘åŠ¨é€Ÿåº¦
        
        success_count = 0
        
        for i in range(steps):
            try:
                if direction in ['down', 'up']:
                    # å‚ç›´æ–¹å‘å¿«é€Ÿæ»‘åŠ¨
                    if direction == 'down':
                        device.fling.vert.forward(steps=1)
                    else:
                        device.fling.vert.backward(steps=1)
                        
                elif direction in ['left', 'right']:
                    # æ°´å¹³æ–¹å‘å¿«é€Ÿæ»‘åŠ¨
                    if direction == 'right':
                        device.fling.horiz.forward(steps=1)
                    else:
                        device.fling.horiz.backward(steps=1)
                
                success_count += 1
                
                # å¿«é€Ÿæ»‘åŠ¨é—´éš”
                if i < steps - 1:
                    time.sleep(0.5)
                    
            except Exception as fling_error:
                logging.warning(f"ç¬¬{i+1}æ¬¡å¿«é€Ÿæ»‘åŠ¨å¤±è´¥: {fling_error}")
        
        success = success_count > 0
        details = f"{direction}æ–¹å‘å¿«é€Ÿæ»‘åŠ¨ï¼ŒæˆåŠŸ{success_count}/{steps}æ¬¡"
        
        return success, details
        
    except Exception as e:
        return False, f"å¿«é€Ÿæ»‘åŠ¨å¼‚å¸¸: {e}"


{# æ»šè½®æ–¹å¼æ»šåŠ¨å‡½æ•° #}
def perform_wheel_scroll(device, direction, center_x, center_y, steps, element_info):
    """
    æ‰§è¡Œæ»šè½®æ–¹å¼æ»šåŠ¨
    
    Args:
        device: è®¾å¤‡å¯¹è±¡
        direction: æ»šåŠ¨æ–¹å‘
        center_x: ä¸­å¿ƒXåæ ‡
        center_y: ä¸­å¿ƒYåæ ‡
        steps: æ»šåŠ¨æ­¥æ•°
        element_info: å…ƒç´ ä¿¡æ¯
    
    Returns:
        Tuple: (success, details)
    """
    try:
        # æ»šè½®æ»šåŠ¨ï¼ˆæ¨¡æ‹Ÿé¼ æ ‡æ»šè½®ï¼Œé€‚ç”¨äºæ”¯æŒçš„è®¾å¤‡ï¼‰
        scroll_amount = element_info.get('scroll_amount', 3)
        
        success_count = 0
        
        for i in range(steps):
            try:
                # ä½¿ç”¨shellå‘½ä»¤æ¨¡æ‹Ÿæ»šè½®æ»šåŠ¨
                if direction == 'down':
                    cmd = f"input motionevent DOWN {center_x} {center_y} && sleep 0.1 && input motionevent UP {center_x} {center_y}"
                elif direction == 'up':
                    cmd = f"input motionevent DOWN {center_x} {center_y} && sleep 0.1 && input motionevent UP {center_x} {center_y}"
                else:
                    return False, f"æ»šè½®ä¸æ”¯æŒæ°´å¹³æ–¹å‘: {direction}"
                
                # æ‰§è¡Œshellå‘½ä»¤
                result = run_adb_command(cmd, timeout=5)
                if result.get('success'):
                    success_count += 1
                
                # æ»šè½®é—´éš”
                if i < steps - 1:
                    time.sleep(0.2)
                    
            except Exception as wheel_error:
                logging.warning(f"ç¬¬{i+1}æ¬¡æ»šè½®æ»šåŠ¨å¤±è´¥: {wheel_error}")
        
        success = success_count > 0
        details = f"{direction}æ–¹å‘æ»šè½®æ»šåŠ¨ï¼ŒæˆåŠŸ{success_count}/{steps}æ¬¡"
        
        return success, details
        
    except Exception as e:
        return False, f"æ»šè½®æ»šåŠ¨å¼‚å¸¸: {e}" 