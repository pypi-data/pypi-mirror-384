{# 滑动动作处理模板 - 支持多种滑动方向和智能距离计算 #}

{# 滑动动作处理函数 #}
def handle_swipe_action(step_data, device, runner_dir, screenshot_count, previous_after_screenshot=None):
    """
    处理滑动动作 - 支持多种滑动方向和智能距离计算
    
    Args:
        step_data: 步骤上下文对象
        device: uiautomator2设备对象
        runner_dir: 运行目录路径
        screenshot_count: 截图计数
        previous_after_screenshot: 前一步的执行后截图路径，用于优化截图性能
    
    Returns:
        Dict: 执行结果
    """
    logging.info("开始执行步骤 %s: %s" % (step_data.get('step_number', 0), step_data.get('step_name', '未知步骤')))

    step_name = step_data.get('step_name', '滑动操作')
    operation_type = step_data.get('operation_type', 'swipe')
    # 兼容两种数据结构：直接在根级别的element_info和在parameters中的element_info
    element_info = step_data.get('element_info', {}) or step_data.get('parameters', {}).get('element_info', {})
    
    logging.info(f"开始执行滑动操作: {step_name}")
    
    try:
        # 执行前无需等待UI稳定，直接进行操作
        
        # 优化截图逻辑：如果有前一步的截图，就复用它
        step_number = step_data.get('step_number', 0)
        
        if previous_after_screenshot:
            # 使用前一步的后截图作为当前步骤的前截图，避免重复截图
            before_execution_screenshot_path = previous_after_screenshot
            logging.info(f"📸 复用前一步截图作为执行前截图: {before_execution_screenshot_path}")
        else:
            # 第一步或没有前一步截图时，需要新截图
            before_execution_screenshot_path = take_screenshot_and_save(
                device, runner_dir, f"before_step{step_number}", "执行前截图 - 用于记录滑动前状态"
            )
        
        # 更新步骤执行前截图信息
        step_data['before_execution_screenshot_path'] = before_execution_screenshot_path
        
        # 获取滑动参数 - 只使用精确坐标
        start_x = element_info.get('start_x')
        start_y = element_info.get('start_y')
        end_x = element_info.get('end_x')
        end_y = element_info.get('end_y')
        duration = 0.5  # 固定滑动持续时间
        
        # 验证必需参数
        if start_x is None or start_y is None or end_x is None or end_y is None:
            error_msg = "缺少滑动坐标参数: 需要 start_x, start_y, end_x, end_y"
            logging.error(error_msg)
            return {"status": "failed", "message": error_msg}
        
        # 获取设备屏幕信息用于坐标验证
        device_info = get_device_info(device)
        screen_width = device_info.get('display_width', 1920)
        screen_height = device_info.get('display_height', 1080)
        
        # 验证坐标有效性
        if not (0 <= start_x <= screen_width and 0 <= start_y <= screen_height and
                0 <= end_x <= screen_width and 0 <= end_y <= screen_height):
            error_msg = f"滑动坐标超出屏幕范围: ({start_x}, {start_y}) -> ({end_x}, {end_y}), 屏幕: {screen_width}x{screen_height}"
            logging.error(error_msg)
            return {"status": "failed", "message": error_msg}
        
        logging.info(f"使用精确坐标滑动: ({start_x}, {start_y}) -> ({end_x}, {end_y})")
        

        
        # 执行滑动或拖拽操作
        if operation_type == 'drag':
            logging.info(f"执行拖拽: ({start_x}, {start_y}) -> ({end_x}, {end_y})")
            device.drag(start_x, start_y, end_x, end_y)
        else:
            logging.info(f"执行滑动: ({start_x}, {start_y}) -> ({end_x}, {end_y}), 持续时间: {duration}s")
            device.swipe_points([(start_x, start_y), (end_x, end_y),(end_x + 20, end_y + 20)], duration=duration)
        
        # 等待滑动完成
        time.sleep(0.5)
        
        # 等待UI稳定后进行执行后截图
        logging.info("等待动作执行完成后UI稳定...")
        ui_stable = wait_for_ui_stability(device, timeout=1.0)
        if not ui_stable:
            logging.warning("执行后UI稳定检查超时，继续截图")
        
        # 执行后截图（统一为所有滑动操作添加）
        after_swipe_path = take_screenshot_and_save(
            device, runner_dir, f"after_step{step_number}", "执行后截图 - 用于验证滑动结果"
        )
        step_data['after_execution_screenshot_path'] = after_swipe_path
        
        # 可选：验证滑动效果
        verify_swipe = element_info.get('verify_swipe', False)
        swipe_verification_success = True
        
        if verify_swipe:
            logging.info("验证滑动效果...")
            try:
                # 等待UI稳定
                time.sleep(0.5)
                
                # 简单的图像差异检测（使用文件路径比较）
                if before_execution_screenshot_path != after_swipe_path:
                    logging.info("✅ 滑动效果验证通过：屏幕内容发生变化")
                    swipe_verification_success = True
                else:
                    logging.warning("⚠️ 滑动效果验证失败：屏幕内容无明显变化")
                    swipe_verification_success = False
                    
            except Exception as verify_error:
                logging.warning(f"滑动效果验证异常: {verify_error}")
                swipe_verification_success = False
        
        logging.info("步骤 %s 完成: %s, 成功: %s" % (step_data.get('step_number', 0), step_data.get('step_name', '未知步骤'), swipe_verification_success))
        
        operation_name = "拖拽" if operation_type == 'drag' else "滑动"
        logging.info(f"✅ {operation_name}操作完成: {step_name}")
        return {
            "status": "success",
            "message": f"{operation_name}操作成功",
            "start_coordinates": (start_x, start_y),
            "end_coordinates": (end_x, end_y),
            "coordinate_method": "精确坐标",
            "duration": duration,
            "verification_passed": swipe_verification_success,
            "screenshots": {
                "before_execution": step_data.get('before_execution_screenshot_path'),
                "after_execution": after_swipe_path
            },

        }
        
    except Exception as e:
        operation_name = "拖拽" if operation_type == 'drag' else "滑动"
        error_msg = f"{operation_name}操作失败: " + str(e)
        logging.error(error_msg)
        
        # 实时状态更新：错误处理
        
        
        # 确保有截图记录错误状态
        if not step_data.get('before_execution_screenshot_path'):
            try:
                error_screenshot_path = take_screenshot_and_save(
                    device, runner_dir, f"error_{operation_type}", "错误截图 - 记录滑动操作失败时的界面状态"
                )
                step_data['before_execution_screenshot_path'] = error_screenshot_path
            except Exception as screenshot_error:
                logging.error(f"错误截图失败: {screenshot_error}")
        
        logging.error("步骤 %s 执行错误: %s, 错误: %s" % (step_data.get('step_number', 0), step_data.get('step_name', '未知步骤'), error_msg))
        
        return {
            "status": "failed",
            "message": error_msg,
            "start_coordinates": (start_x, start_y) if 'start_x' in locals() else None,
            "end_coordinates": (end_x, end_y) if 'end_x' in locals() else None,
            "checkpoint_context": {
                "operation_completed": False,
                "error_occurred": True,
                "error_message": error_msg,
                "operation_mode": step_data.get('mode', 'manual'),

            }
        }

