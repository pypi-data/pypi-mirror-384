def url_from_path(file_path):
    """
    å°†æ–‡ä»¶è·¯å¾„è½¬æ¢ä¸ºURLæ ¼å¼
    """
    try:
        if hasattr(file_path, 'name'):
            return f"/static/{file_path.name}"
        else:
            return f"/static/{Path(file_path).name}"
    except Exception as e:
        logging.error(f"è·¯å¾„è½¬URLå¤±è´¥: {e}")
        return ""

def take_screenshot_and_save(device, runner_dir: str, prefix: str = "screenshot", purpose: str = "") -> str:
    """
    æ‰§è¡Œæˆªå›¾å¹¶ä¿å­˜åˆ°æœ¬åœ°ç›®å½•
    
    Args:
        device: uiautomator2è®¾å¤‡å¯¹è±¡
        runner_dir: æˆªå›¾ä¿å­˜ç›®å½•
        prefix: æˆªå›¾æ–‡ä»¶å‰ç¼€
        purpose: æˆªå›¾ç”¨é€”è¯´æ˜ï¼Œå¦‚"æ‰§è¡Œå‰æˆªå›¾"ã€"æ‰§è¡Œåæˆªå›¾"ç­‰
    
    Returns:
        str: æˆªå›¾æ–‡ä»¶è·¯å¾„ï¼Œå¤±è´¥æ—¶è¿”å›ç©ºå­—ç¬¦ä¸²
    """
    try:
        from datetime import datetime
        purpose_text = f" - {purpose}" if purpose else ""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S_%f")[:-3]  # ç²¾ç¡®åˆ°æ¯«ç§’
        logging.info(f"ğŸ“¸ æ­£åœ¨æˆªå›¾{purpose_text} (æ—¶é—´æˆ³: {timestamp})")
        
        # ç¡®ä¿æˆªå›¾ç›®å½•å­˜åœ¨
        runner_path = Path(runner_dir)
        images_dir = runner_path / "images"
        images_dir.mkdir(parents=True, exist_ok=True)
        
        # ç”Ÿæˆå¸¦æ—¶é—´æˆ³çš„æˆªå›¾æ–‡ä»¶å
        screenshot_filename = f"{prefix}_{timestamp}.png"
        screenshot_path = images_dir / screenshot_filename
        
        # æ‰§è¡Œæˆªå›¾
        screenshot_result = take_screenshot(device, screenshot_path, purpose)
        
        if screenshot_result.get("status") != "success":
            logging.error(f"âŒ æˆªå›¾å¤±è´¥{purpose_text}: {screenshot_result.get('message', 'æœªçŸ¥é”™è¯¯')}")
            return ""
        
        logging.info(f"âœ… æˆªå›¾ä¿å­˜æˆåŠŸ{purpose_text}: {screenshot_path}")
        return str(screenshot_path)
        
    except Exception as e:
        logging.error(f"âŒ æˆªå›¾å¤±è´¥{purpose_text}: {e}")
        return ""



def take_screenshot(device, screenshot_path: Path, purpose: str = "") -> Dict[str, Any]:
    """
    æ‰§è¡Œæˆªå›¾æ“ä½œ
    
    Args:
        device: uiautomator2è®¾å¤‡å¯¹è±¡
        screenshot_path: æˆªå›¾ä¿å­˜è·¯å¾„
        purpose: æˆªå›¾ç”¨é€”è¯´æ˜
    
    Returns:
        Dict[str, Any]: {"status": "success/error", "message": "...", "path": "..."}
    """
    try:
        purpose_text = f"({purpose})" if purpose else ""
        logging.info(f"æ­£åœ¨æˆªå›¾åˆ°{purpose_text}: {screenshot_path}")
        
        # ç¡®ä¿ç›®å½•å­˜åœ¨
        screenshot_path.parent.mkdir(parents=True, exist_ok=True)
        
        # æ‰§è¡Œæˆªå›¾ - ä½¿ç”¨uiautomator2çš„æˆªå›¾åŠŸèƒ½
        device.screenshot(str(screenshot_path))
        
        # éªŒè¯æˆªå›¾æ–‡ä»¶æ˜¯å¦ç”Ÿæˆ
        if not screenshot_path.exists():
            return {
                "status": "error",
                "message": "æˆªå›¾æ–‡ä»¶æœªç”Ÿæˆ",
                "path": str(screenshot_path)
            }
        
        # æ£€æŸ¥æ–‡ä»¶å¤§å°
        file_size = screenshot_path.stat().st_size
        if file_size == 0:
            return {
                "status": "error", 
                "message": "æˆªå›¾æ–‡ä»¶ä¸ºç©º",
                "path": str(screenshot_path)
            }
        
        logging.info(f"æˆªå›¾æˆåŠŸ: {screenshot_path} (å¤§å°: {file_size} bytes)")
        return {
            "status": "success",
            "message": "æˆªå›¾æˆåŠŸ",
            "path": str(screenshot_path),
            "size": file_size
        }
        
    except Exception as e:
        error_message = f"æˆªå›¾æ“ä½œå¤±è´¥: {str(e)}"
        logging.error(error_message)
        return {
            "status": "error",
            "message": error_message,
            "path": str(screenshot_path) if screenshot_path else ""
        }

def match_template(image, template, method=cv2.TM_CCOEFF_NORMED):
    """
    æ¨¡æ¿åŒ¹é…è¾…åŠ©å‡½æ•°
    
    Args:
        image: æºå›¾åƒ
        template: æ¨¡æ¿å›¾åƒ
        method: åŒ¹é…æ–¹æ³•ï¼Œé»˜è®¤ä¸ºcv2.TM_CCOEFF_NORMED
        
    Returns:
        Tuple: (top_left, bottom_right, confidence)
    """
    h, w = template.shape[:2]
    result = cv2.matchTemplate(image, template, method)
    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

    confidence = max_val if method not in [cv2.TM_SQDIFF, cv2.TM_SQDIFF_NORMED] else min_val

    if method in [cv2.TM_SQDIFF, cv2.TM_SQDIFF_NORMED]:
        top_left = min_loc
    else:
        top_left = max_loc

    bottom_right = (top_left[0] + w, top_left[1] + h)
    return top_left, bottom_right, confidence

def match_template_with_blocks(detect_img, medium_img, block_size=(3, 3), threshold=0.8):
    """
    ä½¿ç”¨åˆ†å—åŒ¹é…ä¸­å›¾åœ¨ç›®æ ‡å›¾åƒä¸­çš„ä½ç½®ã€‚
    è¿”å›åŒ¹é…ä½ç½®å’Œå—åŒ¹é…ç½®ä¿¡åº¦ï¼ˆåŒ¹é…æˆåŠŸçš„å—æ¯”ä¾‹ï¼‰ã€‚
    """
    # é¦–å…ˆè¿›è¡Œæ•´ä¸ªä¸­å›¾çš„åˆæ­¥åŒ¹é…ï¼Œä½¿ç”¨è¾ƒä½é˜ˆå€¼
    prelim_threshold = threshold * 0.6  # åˆæ­¥åŒ¹é…é˜ˆå€¼è¾ƒä½
    top_left, bottom_right, conf = match_template(detect_img, medium_img)
    if conf < prelim_threshold:
        return None, 0.0

    # å°†ä¸­å›¾åˆ‡åˆ†æˆå—
    h, w = medium_img.shape[:2]
    block_h = h // block_size[0]
    block_w = w // block_size[1]
    total_blocks = block_size[0] * block_size[1]
    matched_blocks = 0

    for i in range(block_size[0]):
        for j in range(block_size[1]):
            # æˆªå–ä¸­å›¾çš„å°å—
            y1 = i * block_h
            y2 = y1 + block_h
            x1 = j * block_w
            x2 = x1 + block_w
            block = medium_img[y1:y2, x1:x2]
            
            # å¦‚æœå—ä¸ºç©ºï¼Œè·³è¿‡
            if block.size == 0:
                continue
                
            # åœ¨ç›®æ ‡å›¾åƒä¸­å¯¹åº”ä½ç½®æˆªå–ç›¸åŒå¤§å°çš„åŒºåŸŸ
            detect_y1 = top_left[1] + y1
            detect_y2 = detect_y1 + block_h
            detect_x1 = top_left[0] + x1
            detect_x2 = detect_x1 + block_w
            # ç¡®ä¿ä¸è¶Šç•Œ
            if detect_y2 > detect_img.shape[0] or detect_x2 > detect_img.shape[1]:
                continue
            detect_block = detect_img[detect_y1:detect_y2, detect_x1:detect_x2]
            
            # å¦‚æœå—å¤§å°ä¸åŒ¹é…ï¼Œè·³è¿‡
            if block.shape[:2] != detect_block.shape[:2]:
                continue
            
            # åŒ¹é…å°å—
            _, _, block_conf = match_template(detect_block, block)
            if block_conf >= threshold:
                matched_blocks += 1

    block_confidence = matched_blocks / total_blocks
    return top_left, block_confidence



def locate_small_via_dynamic_medium(
        reference_image_data,  # æˆªå–å°å›¾æ—¶çš„å¤§å›¾
        target_image_data,     # æ“ä½œçš„ç›®æ ‡ï¼ˆæˆªå‡ºçš„å°å›¾ï¼‰
        target_bbox,           # æˆªå–å°å›¾æ—¶å°å›¾çš„åæ ‡ [x1, y1, x2, y2]
        detect_image_data,     # æœ€åè¦æ£€æµ‹çš„å›¾åƒ
        roi_coordinates=None,  # æ£€æµ‹åŒºåŸŸ (x1, y1, x2, y2)ï¼ŒNone è¡¨ç¤ºå…¨å›¾
        threshold=0.7,
        block_size=(3,3)):
    """
    å›¾åƒå®šä½å‡½æ•° 
    å½“ roi_coordinates=None æ—¶ â†’ é€»è¾‘ä¸æ—§ç‰ˆä¸€è‡´ï¼›
    å½“ roi_coordinates!=None æ—¶ â†’ ä½¿ç”¨ ROI + åæ ‡ç¼©æ”¾ çš„æ–°é€»è¾‘ã€‚
    """
    try:
        logger.info("å¼€å§‹ä¸‰æ­¥åŒ¹é…ç®—æ³•...")
        logger.info(f"å‚è€ƒå›¾åƒ: {reference_image_data}")
        logger.info(f"ç›®æ ‡å›¾åƒ: {target_image_data}")
        logger.info(f"æ£€æµ‹å›¾åƒ: {detect_image_data}")
        logger.info(f"ç›®æ ‡è¾¹ç•Œæ¡†: {target_bbox}")
        logger.info(f"ROIåŒºåŸŸ: {roi_coordinates}")

        # è¯»å–å›¾åƒ
        reference_image = cv2.imread(reference_image_data)
        target_image = cv2.imread(target_image_data)
        detect_image = cv2.imread(detect_image_data)

        if any(img is None for img in [reference_image, target_image, detect_image]):
            logger.error("å›¾åƒåŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥è·¯å¾„")
            return None

        # åŸºæœ¬å°ºå¯¸
        detect_h, detect_w = detect_image.shape[:2]
        reference_h, reference_w = reference_image.shape[:2]
        target_x1, target_y1, target_x2, target_y2 = target_bbox

        # ========== ROI æ ¡éªŒ ==========
        if roi_coordinates:
            roi_x1, roi_y1, roi_x2, roi_y2 = roi_coordinates
            roi_valid = (
                roi_x1 >= 0 and roi_x1 < roi_x2 and
                roi_y1 >= 0 and roi_y1 < roi_y2 
            )

            if roi_valid:
                roi_x1 = int(max(0, min(roi_x1, detect_w)))
                roi_y1 = int(max(0, min(roi_y1, detect_h)))
                roi_x2 = int(min(max(roi_x1 + 50, roi_x2), detect_w))
                roi_y2 = int(min(max(roi_y1 + 50, roi_y2), detect_h))
                logger.info(f"ä½¿ç”¨æœ‰æ•ˆROIåŒºåŸŸ: ({roi_x1}, {roi_y1}, {roi_x2}, {roi_y2})")
            else:
                roi_x1, roi_y1, roi_x2, roi_y2 = 0, 0, detect_w, detect_h
                logger.warning(f"ROIåŒºåŸŸæ— æ•ˆæˆ–æœªè¦†ç›–ç›®æ ‡åŒºåŸŸï¼Œå°†ä½¿ç”¨å…¨å›¾")
        else:
            roi_x1, roi_y1, roi_x2, roi_y2 = 0, 0, detect_w, detect_h
            logger.info("æœªæä¾›ROIåæ ‡ï¼Œä½¿ç”¨å…¨å›¾æ£€æµ‹")

        # ========== åˆ†æ”¯ 1ï¼šROI=å…¨å›¾ï¼ˆå³ roi_coordinates æ— æˆ–æ— æ•ˆï¼‰ ==========
        if (roi_x1, roi_y1, roi_x2, roi_y2) == (0, 0, detect_w, detect_h):
            logger.info("æ‰§è¡Œæ—§é€»è¾‘ï¼ˆæ— ç¼©æ”¾ï¼‰")

            x1, y1, x2, y2 = map(round, target_bbox)
            img_h, img_w = reference_image.shape[:2]

            # æ„é€ ä¸­å›¾
            extend = 100
            medium_y1 = max(0, y1 - extend)
            medium_y2 = min(img_h, y2 + extend)
            medium_x1 = 0
            medium_x2 = img_w
            medium_img = reference_image[medium_y1:medium_y2, medium_x1:medium_x2]

            # Step1: é˜”å¤§æ„Ÿå—åŸŸ
            medium_top_left, block_confidence = match_template_with_blocks(detect_image, medium_img, block_size, threshold)
            if medium_top_left is None or block_confidence < threshold:
                return None  # ä¸­å›¾åŒ¹é…å¤±è´¥


            # Step2: å°å›¾åŒ¹é…
            small_top_left, small_bottom_right, small_conf = match_template(medium_img, target_image)
            if small_conf < threshold:
                logger.warning("å°å›¾åŒ¹é…å¤±è´¥")
                return None

            # Step3: åæ ‡æ˜ å°„
            final_bbox = (
                medium_top_left[0] + small_top_left[0],
                medium_top_left[1] + small_top_left[1],
                medium_top_left[0] + small_bottom_right[0],
                medium_top_left[1] + small_bottom_right[1],
            )
            logger.info(f"æˆåŠŸå®šä½ç›®æ ‡ï¼Œä½ç½®: {final_bbox}")
            return final_bbox

        # ========== åˆ†æ”¯ 2ï¼šROI æœ‰æ•ˆ â†’ æ–°é€»è¾‘ ==========
        detect_roi = detect_image[roi_y1:roi_y2, roi_x1:roi_x2]
        roi_w, roi_h = roi_x2 - roi_x1, roi_y2 - roi_y1

        # ç¼©æ”¾æ¯”ä¾‹
        scale_x = roi_w / reference_w
        scale_y = roi_h / reference_h

        # ç¼©æ”¾å°å›¾
        target_w = int((target_x2 - target_x1) * scale_x)
        target_h = int((target_y2 - target_y1) * scale_y)
        scaled_target_image = cv2.resize(target_image, (target_w, target_h))

        # ç¼©æ”¾å‚è€ƒå›¾
        scaled_reference_image = cv2.resize(reference_image, (roi_w, roi_h))
        scaled_x1 = round(target_x1 * scale_x)
        scaled_y1 = round(target_y1 * scale_y)
        scaled_x2 = round(target_x2 * scale_x)
        scaled_y2 = round(target_y2 * scale_y)

        # æ„é€ ä¸­å›¾
        extend = 100
        medium_y1 = max(0, scaled_y1 - extend)
        medium_y2 = min(roi_h, scaled_y2 + extend)
        medium_x1 = max(0, scaled_x1 - extend)
        medium_x2 = min(roi_w, scaled_x2 + extend)
        medium_img = scaled_reference_image[medium_y1:medium_y2, medium_x1:medium_x2]

        # Step1: ä¸­å›¾åŒ¹é…
        medium_top_left, medium_bottom_right, medium_conf = match_template(detect_roi, medium_img)
        if medium_conf < threshold:
            logger.warning("ä¸­å›¾åŒ¹é…å¤±è´¥")
            return None

        # Step2: å°å›¾åŒ¹é…
        small_top_left, small_bottom_right, small_conf = match_template(medium_img, scaled_target_image)
        if small_conf < threshold:
            logger.warning("å°å›¾åŒ¹é…å¤±è´¥")
            return None

        # Step3: æ˜ å°„å› detect åŸå›¾
        final_bbox = (
            medium_top_left[0] + small_top_left[0] + roi_x1,
            medium_top_left[1] + small_top_left[1] + roi_y1,
            medium_top_left[0] + small_bottom_right[0] + roi_x1,
            medium_top_left[1] + small_bottom_right[1] + roi_y1,
        )
        logger.info(f"æˆåŠŸå®šä½ç›®æ ‡ï¼Œä½ç½®: {final_bbox}")
        return final_bbox

    except Exception as e:
        logger.error(f"å®šä½è¿‡ç¨‹å‡ºé”™: {str(e)}", exc_info=True)
        return None


def extract_screen_from_camera_image(image_path, output_path=None):
    """
    ä»æ‘„åƒå¤´æ‹æ‘„çš„å›¾åƒä¸­æå–å±å¹•åŒºåŸŸ
    
    Args:
        image_path: æ‘„åƒå¤´å›¾åƒè·¯å¾„
        output_path: æå–çš„å±å¹•åŒºåŸŸä¿å­˜è·¯å¾„ï¼ˆå¯é€‰ï¼‰
        
    Returns:
        Tuple: (å±å¹•å›¾åƒè·¯å¾„, å±å¹•è¾¹ç•Œæ¡†) æˆ– None
    """
    try:
        from pathlib import Path
        
        image_path = Path(image_path)
        
        if not image_path.exists():
            logging.error(f"å›¾åƒæ–‡ä»¶ä¸å­˜åœ¨: {image_path}")
            return None
        
        # è¯»å–å›¾åƒ
        image = cv2.imread(str(image_path))
        if image is None:
            logging.error(f"æ— æ³•è¯»å–å›¾åƒ: {image_path}")
            return None
            
        logging.info(f"å¼€å§‹ä»æ‘„åƒå¤´å›¾åƒä¸­æå–å±å¹•åŒºåŸŸ: {image_path}")
        logging.info(f"åŸå§‹å›¾åƒå°ºå¯¸: {image.shape}")
        
        # è¾¹ç¼˜æ£€æµ‹æ–¹æ³•
        screen_rect, confidence = _detect_screen_by_edges(image)
        
        if screen_rect is None or confidence < 0.3:
            logging.warning(f"å±å¹•æ£€æµ‹å¤±è´¥ï¼Œç½®ä¿¡åº¦: {confidence}")
            return None
        
        logging.info(f"å±å¹•æ£€æµ‹æˆåŠŸï¼Œç½®ä¿¡åº¦: {confidence:.3f}")
        
        # æå–å±å¹•åŒºåŸŸ
        screen_image = _extract_screen_region(image, screen_rect)
        
        # ç¡®å®šä¿å­˜è·¯å¾„
        if output_path is None:
            output_path = image_path.parent / f"screen_{image_path.stem}.png"
        else:
            output_path = Path(output_path)
        
        # ä¿å­˜å±å¹•åŒºåŸŸ
        output_path.parent.mkdir(parents=True, exist_ok=True)
        cv2.imwrite(str(output_path), screen_image)
        
        logging.info(f"å±å¹•åŒºåŸŸå·²ä¿å­˜: {output_path}")
        logging.info(f"æå–çš„å±å¹•å°ºå¯¸: {screen_image.shape}")
        
        return str(output_path), screen_rect
        
    except Exception as e:
        logging.error(f"å±å¹•æå–å¤±è´¥: {image_path}, é”™è¯¯: {e}")
        return None


def _detect_screen_by_edges(image):
    """
    ä½¿ç”¨è¾¹ç¼˜æ£€æµ‹æ–¹æ³•æ£€æµ‹å±å¹•åŒºåŸŸï¼ˆå†…è”å®ç°ï¼‰
    """
    try:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        
        # é«˜æ–¯æ¨¡ç³Š
        blurred = cv2.GaussianBlur(gray, (5, 5), 0)
        
        # Cannyè¾¹ç¼˜æ£€æµ‹
        edges = cv2.Canny(blurred, 50, 150)
        
        # å½¢æ€å­¦æ“ä½œ
        kernel = np.ones((3, 3), np.uint8)
        edges = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, kernel)
        
        # æŸ¥æ‰¾è½®å»“
        contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        # ç­›é€‰è½®å»“
        screen_candidates = []
        for contour in contours:
            area = cv2.contourArea(contour)
            if area < 50000:  # å±å¹•åº”è¯¥è¶³å¤Ÿå¤§
                continue
                
            # è¿‘ä¼¼è½®å»“
            epsilon = 0.02 * cv2.arcLength(contour, True)
            approx = cv2.approxPolyDP(contour, epsilon, True)
            
            # æ£€æŸ¥æ˜¯å¦ä¸ºçŸ©å½¢ï¼ˆ4ä¸ªé¡¶ç‚¹ï¼‰
            if len(approx) == 4:
                # è®¡ç®—çŸ©å½¢æ€§
                rect = cv2.boundingRect(approx)
                aspect_ratio = rect[2] / rect[3]
                
                # å±å¹•é€šå¸¸æ˜¯æ¨ªå±æˆ–ç«–å±
                if 0.5 < aspect_ratio < 2.0:
                    screen_candidates.append((contour, area, rect))
        
        if screen_candidates:
            # é€‰æ‹©é¢ç§¯æœ€å¤§çš„
            best_contour, best_area, best_rect = max(screen_candidates, key=lambda x: x[1])
            confidence = min(1.0, best_area / (image.shape[0] * image.shape[1]) * 3)
            
            return best_rect, confidence
        
        return None, 0.0
        
    except Exception as e:
        logging.error(f"è¾¹ç¼˜æ£€æµ‹å¤±è´¥: {e}")
        return None, 0.0


def _extract_screen_region(image, rect):
    """
    æå–å±å¹•åŒºåŸŸï¼ˆå†…è”å®ç°ï¼‰
    """
    x, y, w, h = rect
    
    # æ·»åŠ ä¸€äº›è¾¹è·
    margin = 10
    x = max(0, x - margin)
    y = max(0, y - margin)
    w = min(image.shape[1] - x, w + 2 * margin)
    h = min(image.shape[0] - y, h + 2 * margin)
    
    screen_image = image[y:y+h, x:x+w]
    return screen_image
