def evaluate_condition_expression(condition, expression, can_file_path=None):
    """
    è¯„ä¼°æ¡ä»¶è¡¨è¾¾å¼
    
    æ”¯æŒçš„æ¡ä»¶è¡¨è¾¾å¼æ ¼å¼ï¼š
    - ç®€å•æ¡ä»¶: "[BAffi]"
    - ANDé€»è¾‘: "[BAffi] && [8DAZR]"
    - ORé€»è¾‘: "[BAffi] || [8DAZR]"
    - å¤æ‚ç»„åˆ: "([BAffi] || [8DAZR]) && [XY123]"
    - åµŒå¥—æ‹¬å·: "(([BAffi] && [8DAZR]) || [XY123]) && [ABC12]"
    
    Args:
        condition: æ¡ä»¶åˆ—è¡¨ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªValidationModel
        expression: æ¡ä»¶è¡¨è¾¾å¼å­—ç¬¦ä¸²ï¼Œæ”¯æŒ &&ã€||ã€() è¿ç®—ç¬¦
        can_file_path: CANä¿¡å·æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼‰ï¼Œç”¨äºCANæ¡ä»¶éªŒè¯
    
    Returns:
        bool: æ¡ä»¶æ˜¯å¦æ»¡è¶³
    
    Note:
        æ­¤å‡½æ•°ä¾èµ–è„šæœ¬ä¸­çš„å…¨å±€å˜é‡: device, runner_dir, screenshot_count
    """
    try:
        # å¦‚æœæ²¡æœ‰æ¡ä»¶åˆ—è¡¨ï¼Œç›´æ¥è¿”å›True
        if not condition:
            return True
        
        # å¦‚æœæ²¡æœ‰è¡¨è¾¾å¼ï¼Œé»˜è®¤æ‰€æœ‰æ¡ä»¶éƒ½è¦æ»¡è¶³ï¼ˆANDé€»è¾‘ï¼‰
        if not expression or not expression.strip():
            return _evaluate_all_conditions(condition, can_file_path)
        
        # è§£æå¹¶è¯„ä¼°è¡¨è¾¾å¼
        return _evaluate_expression(condition, expression.strip(), can_file_path)
        
    except Exception as e:
        logging.error(f"æ¡ä»¶è¡¨è¾¾å¼è¯„ä¼°å¼‚å¸¸: {e}")
        return False


def _evaluate_all_conditions(condition, can_file_path=None):
    """
    è¯„ä¼°æ‰€æœ‰æ¡ä»¶ï¼ˆANDé€»è¾‘ï¼‰
    
    Args:
        condition: æ¡ä»¶åˆ—è¡¨
        can_file_path: CANä¿¡å·æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼‰
    
    Returns:
        bool: æ‰€æœ‰æ¡ä»¶æ˜¯å¦éƒ½æ»¡è¶³
    """
    try:
        # ä½¿ç”¨è„šæœ¬å…¨å±€å˜é‡
        global device, runner_dir, screenshot_count
        
        for validation_model in condition:
            # è·å–CANæ–‡ä»¶è·¯å¾„ï¼ˆå¦‚æœæ˜¯CANæ¡ä»¶éœ€è¦ï¼‰
            current_can_file_path = can_file_path if validation_model.get('data_source') == 'can_signal' else None
            
            result = validate_validation_model(
                validation_model=validation_model,
                device=device,
                runner_dir=runner_dir,
                screenshot_count=screenshot_count,
                can_file_path=current_can_file_path
            )
            if not result.get('is_pass', False):
                return False
        return True
    except Exception as e:
        logging.error(f"è¯„ä¼°æ‰€æœ‰æ¡ä»¶å¼‚å¸¸: {e}")
        return False


def _evaluate_expression(condition, expression, can_file_path=None):
    """
    è§£æå¹¶è¯„ä¼°æ¡ä»¶è¡¨è¾¾å¼
    
    Args:
        condition: æ¡ä»¶åˆ—è¡¨
        expression: æ¡ä»¶è¡¨è¾¾å¼å­—ç¬¦ä¸²
        can_file_path: CANä¿¡å·æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼‰
    
    Returns:
        bool: è¡¨è¾¾å¼è¯„ä¼°ç»“æœ
    """
    # åˆ›å»ºæ¡ä»¶æ˜ å°„è¡¨
    condition_map = _create_condition_map(condition, can_file_path)
    
    # è§£æè¡¨è¾¾å¼
    return _parse_expression(expression, condition_map)


def _create_condition_map(condition, can_file_path=None):
    """
    åˆ›å»ºæ¡ä»¶æ˜ å°„è¡¨ï¼Œå°†æ¡ä»¶åˆ—è¡¨è½¬æ¢ä¸ºåç§°åˆ°ç»“æœçš„æ˜ å°„
    
    æ”¯æŒçš„æ¡ä»¶ç±»å‹ï¼š
    1. ValidationModel: éªŒè¯æ¨¡å‹ï¼ˆé¢„æœŸç»“æœéªŒè¯æˆ–æ§åˆ¶æµæ¡ä»¶åˆ¤æ–­ï¼‰
    2. ç®€å•æ¡ä»¶: åŒ…å« is_pass å­—æ®µçš„ç®€å•æ¡ä»¶å¯¹è±¡
    3. å¸ƒå°”æ¡ä»¶: ç›´æ¥åŒ…å«å¸ƒå°”å€¼çš„æ¡ä»¶å¯¹è±¡
    
    æ˜ å°„ç­–ç•¥ï¼š
    - ä¼˜å…ˆä½¿ç”¨æ¡ä»¶çš„ id å­—æ®µä½œä¸ºé”®
    - å¦‚æœæ²¡æœ‰ idï¼Œåˆ™ä½¿ç”¨é»˜è®¤çš„ condition1, condition2, ... å‘½å
    
    Args:
        condition: æ¡ä»¶åˆ—è¡¨ï¼Œæ¯ä¸ªå…ƒç´ å¯èƒ½æ˜¯ValidationModelæˆ–å…¶ä»–ç±»å‹çš„æ¡ä»¶
    
    Returns:
        Dict[str, bool]: æ¡ä»¶åç§°åˆ°éªŒè¯ç»“æœçš„æ˜ å°„
        
    Note:
        æ­¤å‡½æ•°ä¾èµ–è„šæœ¬å…¨å±€å˜é‡: device, runner_dir, screenshot_count
    """
    condition_map = {}
    
    try:
        # ä½¿ç”¨è„šæœ¬å…¨å±€å˜é‡
        global device, runner_dir, screenshot_count
        
        logging.info(f"å¼€å§‹åˆ›å»ºæ¡ä»¶æ˜ å°„ï¼Œæ•°é‡: {len(condition)}")
        
        # é¦–å…ˆåˆ†ç¦» CAN æ¡ä»¶å’Œé CAN æ¡ä»¶
        can_conditions = []
        other_conditions = []
        
        for condition_item in condition:
            data_source = condition_item.get('data_source', '')
            validation_type = condition_item.get('validation_type', '')
            
            if data_source == 'can_signal' and validation_type == 'signal':
                can_conditions.append(condition_item)
            else:
                other_conditions.append(condition_item)
        
        # æ‰¹é‡å¤„ç† CAN æ¡ä»¶
        if can_conditions:
            logging.info(f"å¤„ç† {len(can_conditions)} ä¸ª CAN æ¡ä»¶")
            
            if can_file_path:
                # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
                import os
                if not os.path.exists(can_file_path):
                    logging.error(f"CANé‡‡é›†æ–‡ä»¶ä¸å­˜åœ¨: {can_file_path}")
                    # æ‰€æœ‰CANæ¡ä»¶è®¾ä¸ºFalse
                    for can_condition in can_conditions:
                        condition_id = can_condition.get('id', 'unknown')
                        condition_map[condition_id] = False
                        logging.info(f"condition={condition_id}, result=False")
                else:
                    # æ„é€  judge_signal éœ€è¦çš„æ ¼å¼
                    target_signals = []
                    for can_condition in can_conditions:
                        target_signals.append({
                            "title": can_condition.get('can_title'),
                            "values": can_condition.get('can_values', []),
                            "logic_id": can_condition.get('id')
                        })
                    
                    # ä¸€æ¬¡æ€§è°ƒç”¨ judge_signal å¤„ç†æ‰€æœ‰ CAN æ¡ä»¶
                    judge_results = judge_signal(target_signals, can_file_path)
                    
                    # å°†ç»“æœæ˜ å°„åˆ°æ¡ä»¶æ˜ å°„è¡¨
                    for result in judge_results:
                        condition_id = result.get('id')
                        is_pass = result.get('is_pass', False)
                        condition_map[condition_id] = is_pass
                        logging.info(f"condition={condition_id}, result={is_pass}")
            else:
                logging.warning("æœªæ‰¾åˆ° CAN æ–‡ä»¶è·¯å¾„ï¼Œæ‰€æœ‰ CAN æ¡ä»¶è®¾ä¸º False")
                for can_condition in can_conditions:
                    condition_id = can_condition.get('id', 'unknown')
                    condition_map[condition_id] = False
        
        # å¤„ç†é CAN æ¡ä»¶
        for i, condition_item in enumerate(other_conditions):
            # ç¡®å®šæ¡ä»¶åç§°ï¼ˆä¼˜å…ˆçº§ï¼šid > é»˜è®¤åç§°ï¼‰
            condition_name = None
            if condition_item.get('id'):
                condition_name = condition_item['id']
            else:
                condition_name = f"condition{i+1}"
            
            # ç®€æ´æ—¥å¿—ï¼Œä»…è®°å½•æœ€ç»ˆç»“æœ
            
            # åˆ¤æ–­æ¡ä»¶ç±»å‹å¹¶è¯„ä¼°
            if _is_validation_model(condition_item):
                # ä¼ ç»Ÿçš„ ValidationModel éªŒè¯
                result = validate_validation_model(
                    validation_model=condition_item,
                    device=device,
                    runner_dir=runner_dir,
                    screenshot_count=screenshot_count
                )
                is_pass = result.get('is_pass', False)
                condition_map[condition_name] = is_pass
                logging.info(f"condition={condition_name}, result={is_pass}")
                    
            elif _is_simple_condition(condition_item):
                # ç®€å•æ¡ä»¶ç±»å‹ï¼šç›´æ¥è·å–is_passå­—æ®µ
                is_pass = condition_item.get('is_pass', False)
                condition_map[condition_name] = is_pass
                logging.info(f"condition={condition_name}, result={is_pass}")
                    
            elif _is_boolean_condition(condition_item):
                # å¸ƒå°”æ¡ä»¶ç±»å‹ï¼šç›´æ¥è·å–å¸ƒå°”å€¼
                value = condition_item.get('value', False)
                condition_map[condition_name] = value
                logging.info(f"condition={condition_name}, result={value}")
                    
            else:
                # æœªçŸ¥ç±»å‹ï¼šè®°å½•è­¦å‘Šå¹¶é»˜è®¤ä¸ºFalse
                logging.warning(f"âŒ æ¡ä»¶ {i+1} [{condition_name}] æœªçŸ¥çš„æ¡ä»¶ç±»å‹: {type(condition_item)}, å†…å®¹: {condition_item}")
                condition_map[condition_name] = False
        
        # æ¡ä»¶æ˜ å°„åˆ›å»ºå®Œæˆ
        return condition_map
    except Exception as e:
        logging.error(f"åˆ›å»ºæ¡ä»¶æ˜ å°„å¼‚å¸¸: {e}")
        return {}


def _is_validation_model(condition_item):
    """
    åˆ¤æ–­æ˜¯å¦ä¸ºValidationModelç±»å‹
    
    Args:
        condition_item: æ¡ä»¶é¡¹
    
    Returns:
        bool: æ˜¯å¦ä¸ºValidationModel
    """
    # æ£€æŸ¥æ˜¯å¦åŒ…å«ValidationModelçš„ç‰¹å¾å­—æ®µ
    validation_fields = [
        'data_source', 'validation_type', 'expect_exists', 
        'target_image_path', 'reference_image_path', 'target_text',
        'can_title', 'can_values'  # æ·»åŠ  CAN ç›¸å…³å­—æ®µ
    ]
    return any(field in condition_item for field in validation_fields)


def _is_simple_condition(condition_item):
    """
    åˆ¤æ–­æ˜¯å¦ä¸ºç®€å•æ¡ä»¶ç±»å‹ï¼ˆåŒ…å«is_passå­—æ®µï¼‰
    
    Args:
        condition_item: æ¡ä»¶é¡¹
    
    Returns:
        bool: æ˜¯å¦ä¸ºç®€å•æ¡ä»¶
    """
    return 'is_pass' in condition_item


def _is_boolean_condition(condition_item):
    """
    åˆ¤æ–­æ˜¯å¦ä¸ºå¸ƒå°”æ¡ä»¶ç±»å‹ï¼ˆåŒ…å«valueå­—æ®µï¼‰
    
    Args:
        condition_item: æ¡ä»¶é¡¹
    
    Returns:
        bool: æ˜¯å¦ä¸ºå¸ƒå°”æ¡ä»¶
    """
    return 'value' in condition_item and isinstance(condition_item['value'], bool)


def _parse_expression(expression, condition_map):
    """
    è§£ææ¡ä»¶è¡¨è¾¾å¼
    
    æ”¯æŒçš„è¯­æ³•ï¼š
    - [BAffi]: å•ä¸ªæ¡ä»¶
    - [BAffi] && [8DAZR]: ANDé€»è¾‘
    - [BAffi] || [8DAZR]: ORé€»è¾‘
    - ([BAffi] || [8DAZR]) && [XY123]: å¤æ‚ç»„åˆ
    - true/false: å­—é¢å€¼
    
    Args:
        expression: æ¡ä»¶è¡¨è¾¾å¼å­—ç¬¦ä¸²
        condition_map: æ¡ä»¶æ˜ å°„è¡¨
    
    Returns:
        bool: è¡¨è¾¾å¼è¯„ä¼°ç»“æœ
    """
    import re
    
    try:
        
        # é¢„å¤„ç†è¡¨è¾¾å¼ï¼Œæ ‡å‡†åŒ–ç©ºæ ¼
        expression = re.sub(r'\s+', ' ', expression.strip())
        
        # å¤„ç†ç‰¹æ®Šçš„å­—é¢å€¼
        if expression.lower() == 'true':
            return True
        elif expression.lower() == 'false':
            return False
        
        # å¤„ç†æ‹¬å·
        original_expression = expression
        while '(' in expression:
            expression = _evaluate_parentheses(expression, condition_map)
        
        # å¤„ç†ANDå’ŒORé€»è¾‘
        result = _evaluate_logical_expression(expression, condition_map)
        return result
        
    except Exception as e:
        logging.error(f"âŒ è¡¨è¾¾å¼è§£æå¼‚å¸¸: {e}")
        return False


def _evaluate_parentheses(expression, condition_map):
    """
    å¤„ç†æ‹¬å·å†…çš„è¡¨è¾¾å¼
    
    Args:
        expression: åŒ…å«æ‹¬å·çš„è¡¨è¾¾å¼
        condition_map: æ¡ä»¶æ˜ å°„è¡¨
    
    Returns:
        str: å¤„ç†åçš„è¡¨è¾¾å¼
    """
    # æ‰¾åˆ°æœ€å†…å±‚çš„æ‹¬å·
    start = expression.rfind('(')
    if start == -1:
        return expression
    
    end = expression.find(')', start)
    if end == -1:
        return expression
    
    # æå–æ‹¬å·å†…çš„è¡¨è¾¾å¼
    inner_expr = expression[start + 1:end]
    
    # è¯„ä¼°æ‹¬å·å†…çš„è¡¨è¾¾å¼
    inner_result = _evaluate_logical_expression(inner_expr, condition_map)
    
    # æ›¿æ¢æ‹¬å·å†…çš„è¡¨è¾¾å¼ä¸ºç»“æœ
    result_str = "true" if inner_result else "false"
    new_expression = expression[:start] + result_str + expression[end + 1:]
    
    return new_expression


def _evaluate_logical_expression(expression, condition_map):
    """
    è¯„ä¼°é€»è¾‘è¡¨è¾¾å¼ï¼ˆAND/ORï¼‰
    
    Args:
        expression: é€»è¾‘è¡¨è¾¾å¼
        condition_map: æ¡ä»¶æ˜ å°„è¡¨
    
    Returns:
        bool: é€»è¾‘è¡¨è¾¾å¼ç»“æœ
    """
    # åˆ†å‰²è¡¨è¾¾å¼ä¸ºæ¡ä»¶åˆ—è¡¨
    conditions = _split_expression(expression)
    logging.info(f"ğŸ”§ åˆ†å‰²è¡¨è¾¾å¼ä¸ºæ¡ä»¶åˆ—è¡¨: {conditions}")
    
    if not conditions:
        logging.info(f"ğŸ“‹ æ²¡æœ‰æ¡ä»¶ï¼Œè¿”å› True")
        return True
    
    # å¦‚æœåªæœ‰ä¸€ä¸ªæ¡ä»¶
    if len(conditions) == 1:
        logging.info(f"ğŸ“‹ åªæœ‰ä¸€ä¸ªæ¡ä»¶ï¼Œç›´æ¥è¯„ä¼°")
        result = _evaluate_single_condition(conditions[0]['condition'], condition_map)
        logging.info(f"âœ… å•ä¸ªæ¡ä»¶è¯„ä¼°ç»“æœ: {result}")
        return result
    
    # å¤„ç†å¤šä¸ªæ¡ä»¶çš„é€»è¾‘ç»„åˆ
    logging.info(f"ğŸ”§ å¤„ç†å¤šä¸ªæ¡ä»¶çš„é€»è¾‘ç»„åˆï¼Œæ¡ä»¶æ•°é‡: {len(conditions)}")
    result = _evaluate_single_condition(conditions[0]['condition'], condition_map)
    logging.info(f"ğŸ“‹ åˆå§‹æ¡ä»¶ç»“æœ: {result}")
    
    for i in range(1, len(conditions)):
        operator = conditions[i].get('operator')
        condition = conditions[i].get('condition')
        
        logging.info(f"ğŸ”§ å¤„ç†ç¬¬ {i+1} ä¸ªæ¡ä»¶: {condition} (æ“ä½œç¬¦: {operator})")
        
        if operator == '&&':
            next_result = _evaluate_single_condition(condition, condition_map)
            logging.info(f"ğŸ”§ ANDæ“ä½œ: {result} && {next_result} = {result and next_result}")
            result = result and next_result
        elif operator == '||':
            next_result = _evaluate_single_condition(condition, condition_map)
            logging.info(f"ğŸ”§ ORæ“ä½œ: {result} || {next_result} = {result or next_result}")
            result = result or next_result
    
    logging.info(f"âœ… é€»è¾‘è¡¨è¾¾å¼æœ€ç»ˆç»“æœ: {result}")
    return result


def _split_expression(expression):
    """
    åˆ†å‰²è¡¨è¾¾å¼ä¸ºæ¡ä»¶åˆ—è¡¨
    
    Args:
        expression: é€»è¾‘è¡¨è¾¾å¼
    
    Returns:
        List[Dict[str, str]]: æ¡ä»¶åˆ—è¡¨ï¼Œæ¯ä¸ªå…ƒç´ åŒ…å«conditionå’Œoperator
    """
    import re
    
    # ç§»é™¤å¤šä½™ç©ºæ ¼
    expression = expression.strip()
    
    # åˆ†å‰²ANDå’ŒORæ“ä½œï¼Œæ”¯æŒæ“ä½œç¬¦å‰åæœ‰æ— ç©ºæ ¼çš„æƒ…å†µ
    parts = re.split(r'\s*(&&|\|\|)\s*', expression)
    
    conditions = []
    for i, part in enumerate(parts):
        if i == 0:
            # ç¬¬ä¸€ä¸ªæ¡ä»¶
            conditions.append({'condition': part.strip()})
        elif i % 2 == 1:
            # æ“ä½œç¬¦
            operator = part
            if i + 1 < len(parts):
                next_condition = parts[i + 1].strip()
                conditions.append({
                    'operator': operator,
                    'condition': next_condition
                })
    
    return conditions


def _evaluate_single_condition(condition, condition_map):
    """
    è¯„ä¼°å•ä¸ªæ¡ä»¶
    
    æ”¯æŒçš„æ¡ä»¶æ ¼å¼ï¼š
    - [id]: æ–¹æ‹¬å·åŒ…å›´çš„æ¡ä»¶IDï¼Œå¦‚ [BAffi]ã€[8DAZR]
    - true/false: å¸ƒå°”å­—é¢é‡
    
    Args:
        condition: å•ä¸ªæ¡ä»¶å­—ç¬¦ä¸²
        condition_map: æ¡ä»¶æ˜ å°„è¡¨
    
    Returns:
        bool: æ¡ä»¶è¯„ä¼°ç»“æœ
    """
    condition = condition.strip()
    logging.info(f"ğŸ” è¯„ä¼°å•ä¸ªæ¡ä»¶: '{condition}'")
    
    # å¤„ç†å¸ƒå°”å­—é¢é‡ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰
    if condition.lower() == 'true':
        logging.info(f"âœ… æ¡ä»¶ä¸ºå¸ƒå°”å­—é¢é‡ 'true'ï¼Œè¿”å› True")
        return True
    elif condition.lower() == 'false':
        logging.info(f"âŒ æ¡ä»¶ä¸ºå¸ƒå°”å­—é¢é‡ 'false'ï¼Œè¿”å› False")
        return False
    
    # å¤„ç† [id] æ ¼å¼çš„æ¡ä»¶
    if condition.startswith('[') and condition.endswith(']'):
        # æå–æ–¹æ‹¬å·å†…çš„id
        condition_id = condition[1:-1]
        logging.info(f"ğŸ” å¤„ç†æ–¹æ‹¬å·æ ¼å¼æ¡ä»¶ï¼Œæå–ID: '{condition_id}'")
        
        # æŸ¥æ‰¾æ¡ä»¶æ˜ å°„ï¼ˆä¼˜å…ˆæŸ¥æ‰¾ä¸å¸¦æ–¹æ‹¬å·çš„IDï¼‰
        if condition_id in condition_map:
            result = condition_map[condition_id]
            logging.info(f"âœ… æ‰¾åˆ°æ¡ä»¶ID '{condition_id}'ï¼Œç»“æœ: {result}")
            return result
        
        # å¦‚æœæ‰¾ä¸åˆ°ï¼Œå°è¯•æŸ¥æ‰¾å¸¦æ–¹æ‹¬å·çš„å®Œæ•´ID
        if condition in condition_map:
            result = condition_map[condition]
            logging.info(f"âœ… æ‰¾åˆ°å®Œæ•´æ¡ä»¶ '{condition}'ï¼Œç»“æœ: {result}")
            return result
        
        # å¦‚æœéƒ½æ‰¾ä¸åˆ°æ¡ä»¶ï¼Œè¿”å›False
        logging.warning(f"âŒ æœªæ‰¾åˆ°æ¡ä»¶ID '{condition_id}' æˆ– '{condition}'")
        return False
    
    # å…¼å®¹å¤„ç†ï¼šç›´æ¥æŸ¥æ‰¾æ¡ä»¶æ˜ å°„ï¼ˆç”¨äºå‘åå…¼å®¹ï¼‰
    if condition in condition_map:
        result = condition_map[condition]
        logging.info(f"âœ… ç›´æ¥æ‰¾åˆ°æ¡ä»¶ '{condition}'ï¼Œç»“æœ: {result}")
        return result
    
    # å¦‚æœæ‰¾ä¸åˆ°æ¡ä»¶ï¼Œè¿”å›False
    logging.warning(f"âŒ æœªæ‰¾åˆ°æ¡ä»¶ '{condition}'")
    return False


def validate_expression_syntax(expression):
    """
    éªŒè¯è¡¨è¾¾å¼è¯­æ³•æ˜¯å¦æ­£ç¡®
    
    Args:
        expression: æ¡ä»¶è¡¨è¾¾å¼å­—ç¬¦ä¸²
    
    Returns:
        Dict[str, Any]: éªŒè¯ç»“æœ
    """
    try:
        # æ£€æŸ¥æ‹¬å·åŒ¹é…
        if not _check_parentheses_balance(expression):
            return {
                "is_valid": False,
                "error": "æ‹¬å·ä¸åŒ¹é…",
                "expression": expression
            }
        
        # æ£€æŸ¥æ“ä½œç¬¦è¯­æ³•
        if not _check_operator_syntax(expression):
            return {
                "is_valid": False,
                "error": "æ“ä½œç¬¦è¯­æ³•é”™è¯¯",
                "expression": expression
            }
        
        return {
            "is_valid": True,
            "expression": expression
        }
        
    except Exception as e:
        return {
            "is_valid": False,
            "error": f"è¯­æ³•éªŒè¯å¼‚å¸¸: {e}",
            "expression": expression
        }


def _check_parentheses_balance(expression):
    """
    æ£€æŸ¥æ‹¬å·æ˜¯å¦åŒ¹é…
    
    Args:
        expression: è¡¨è¾¾å¼å­—ç¬¦ä¸²
    
    Returns:
        bool: æ‹¬å·æ˜¯å¦åŒ¹é…
    """
    stack = []
    
    for char in expression:
        if char == '(':
            stack.append(char)
        elif char == ')':
            if not stack:
                return False
            stack.pop()
    
    return len(stack) == 0


def _check_operator_syntax(expression):
    """
    æ£€æŸ¥æ“ä½œç¬¦è¯­æ³•æ˜¯å¦æ­£ç¡®
    
    Args:
        expression: è¡¨è¾¾å¼å­—ç¬¦ä¸²
    
    Returns:
        bool: æ“ä½œç¬¦è¯­æ³•æ˜¯å¦æ­£ç¡®
    """
    import re
    
    # æ£€æŸ¥è¿ç»­æ“ä½œç¬¦
    if re.search(r'(&&|\|\|)\s*(&&|\|\|)', expression):
        return False
    
    # æ£€æŸ¥æ“ä½œç¬¦åœ¨å¼€å¤´æˆ–ç»“å°¾
    if re.match(r'^\s*(&&|\|\|)', expression) or re.search(r'(&&|\|\|)\s*$', expression):
        return False
    
    return True


def format_expression(expression):
    """
    æ ¼å¼åŒ–æ¡ä»¶è¡¨è¾¾å¼ï¼Œæ ‡å‡†åŒ–ç©ºæ ¼å’Œæ ¼å¼
    
    Args:
        expression: åŸå§‹è¡¨è¾¾å¼
    
    Returns:
        str: æ ¼å¼åŒ–åçš„è¡¨è¾¾å¼
    """
    import re
    
    try:
        # ç§»é™¤å¤šä½™ç©ºæ ¼
        expression = re.sub(r'\s+', ' ', expression.strip())
        
        # æ ‡å‡†åŒ–æ“ä½œç¬¦å‘¨å›´çš„ç©ºæ ¼
        expression = re.sub(r'\s*(&&|\|\|)\s*', r' \1 ', expression)
        
        # æ ‡å‡†åŒ–æ‹¬å·å‘¨å›´çš„ç©ºæ ¼
        expression = re.sub(r'\s*\(\s*', '(', expression)
        expression = re.sub(r'\s*\)\s*', ')', expression)
        
        # ä¿®å¤æ‹¬å·åçš„æ“ä½œç¬¦ç©ºæ ¼
        expression = re.sub(r'\)\s*(&&|\|\|)', r') \1', expression)
        
        # ç§»é™¤å¼€å¤´å’Œç»“å°¾çš„ç©ºæ ¼
        expression = expression.strip()
        
        return expression
        
    except Exception as e:
        logging.error(f"æ ¼å¼åŒ–è¡¨è¾¾å¼å¼‚å¸¸: {e}")
        return expression


def get_expression_variables(expression):
    """
    æå–è¡¨è¾¾å¼ä¸­çš„å˜é‡å
    
    æ”¯æŒ [id] æ ¼å¼çš„æ¡ä»¶å¼•ç”¨ï¼Œæå–æ–¹æ‹¬å·å†…çš„ id
    
    Args:
        expression: æ¡ä»¶è¡¨è¾¾å¼å­—ç¬¦ä¸²
    
    Returns:
        List[str]: å˜é‡ååˆ—è¡¨ï¼ˆä¸åŒ…å«æ–¹æ‹¬å·ï¼‰
    """
    import re
    
    try:
        # ç§»é™¤æ‹¬å·å’Œæ“ä½œç¬¦
        cleaned = re.sub(r'[()&|]', ' ', expression)
        
        # åˆ†å‰²å¹¶æå–å˜é‡å
        variables = []
        for part in cleaned.split():
            part = part.strip()
            if part and part not in ['true', 'false', '&&', '||']:
                # å¤„ç† [id] æ ¼å¼
                if part.startswith('[') and part.endswith(']'):
                    # æå–æ–¹æ‹¬å·å†…çš„ id
                    variable_id = part[1:-1]
                    if variable_id:  # ç¡®ä¿ä¸æ˜¯ç©ºçš„æ–¹æ‹¬å·
                        variables.append(variable_id)
                else:
                    # å‘åå…¼å®¹ï¼šç›´æ¥çš„å˜é‡å
                    variables.append(part)
        
        # å»é‡
        return list(set(variables))
        
    except Exception as e:
        logging.error(f"æå–è¡¨è¾¾å¼å˜é‡å¼‚å¸¸: {e}")
        return []







