def get_device_info(device):
    """
    è·å–è®¾å¤‡ä¿¡æ¯ {# åŸºç¡€å·¥å…·å‡½æ•°æ¨¡æ¿ - ä¼˜åŒ–ç‰ˆæœ¬ #}
    """
    try:
        info = device.info
        device_info = {
            "display_width": info.get("displayWidth", 1920),
            "display_height": info.get("displayHeight", 1080),
            "current_package": info.get("currentPackageName", ""),
            "sdk_version": info.get("sdkInt", 0),
            "device_model": info.get("productName", "unknown")
        }
        logging.info(f"è®¾å¤‡ä¿¡æ¯: {device_info}")
        return device_info
    except Exception as e:
        logging.error(f"è·å–è®¾å¤‡ä¿¡æ¯å¤±è´¥: {e}")
        return {
            "display_width": 1920,
            "display_height": 1080,
            "current_package": "",
            "sdk_version": 0,
            "device_model": "unknown"
        }

def check_text_input_state(device):
    """
    æ£€æŸ¥æ–‡æœ¬è¾“å…¥çŠ¶æ€
    """
    try:
        # æ£€æŸ¥æ˜¯å¦æœ‰è¾“å…¥æ³•æ¿€æ´»
        keyboard_shown = _is_keyboard_shown(device)
        
        # æ£€æŸ¥æ˜¯å¦æœ‰ç„¦ç‚¹çš„å¯ç¼–è¾‘å…ƒç´ 
        focused_editable = False
        try:
            focused_element = device(focused=True)
            if focused_element.exists:
                element_info = focused_element.info
                focused_editable = element_info.get('editable', False)
        except:
            pass
        
        # æ£€æŸ¥æ˜¯å¦æœ‰å¯ç¼–è¾‘å…ƒç´ å­˜åœ¨
        editable_exists = False
        try:
            editable_elements = device(editable=True)
            editable_exists = editable_elements.exists
        except:
            pass
        
        input_state = {
            "is_input_active": keyboard_shown or focused_editable,
            "keyboard_shown": keyboard_shown,
            "focused_editable": focused_editable,
            "editable_exists": editable_exists
        }
        
        logging.debug(f"è¾“å…¥çŠ¶æ€æ£€æŸ¥: {input_state}")
        return input_state
        
    except Exception as e:
        logging.error(f"æ£€æŸ¥è¾“å…¥çŠ¶æ€å¤±è´¥: {e}")
        return {
            "is_input_active": False,
            "keyboard_shown": False,
            "focused_editable": False,
            "editable_exists": False
        }

def run_adb_command(cmd, timeout=10):
    """
    æ‰§è¡ŒADBå‘½ä»¤
    
    Args:
        cmd: è¦æ‰§è¡Œçš„å‘½ä»¤
        timeout: è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
    
    Returns:
        Dict: æ‰§è¡Œç»“æœ {"success": bool, "output": str, "error": str}
    """
    try:
        import subprocess
        import threading
        import time
        
        result = {"success": False, "output": "", "error": ""}
        
        # ä½¿ç”¨subprocessæ‰§è¡Œå‘½ä»¤
        process = subprocess.Popen(
            cmd,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        
        # è®¾ç½®è¶…æ—¶
        try:
            stdout, stderr = process.communicate(timeout=timeout)
            result["success"] = process.returncode == 0
            result["output"] = stdout
            result["error"] = stderr
        except subprocess.TimeoutExpired:
            process.kill()
            result["error"] = f"å‘½ä»¤æ‰§è¡Œè¶…æ—¶ ({timeout}ç§’)"
        
        return result
        
    except Exception as e:
        return {"success": False, "output": "", "error": str(e)}


def _is_keyboard_shown(device):
    """
    æ£€æŸ¥è½¯é”®ç›˜æ˜¯å¦æ˜¾ç¤º
    """
    try:
        # æ–¹æ³•1ï¼šæ£€æŸ¥è¾“å…¥æ³•åŒ…å
        ime_packages = [
            "com.android.inputmethod",
            "com.google.android.inputmethod",
            "com.samsung.android.honeyboard",
            "com.sohu.inputmethod.sogou",
            "com.baidu.input",
            "com.iflytek.inputmethod"
        ]
        
        current_package = device.info.get("currentPackageName", "")
        if any(ime_pkg in current_package for ime_pkg in ime_packages):
            return True
        
        # æ–¹æ³•2ï¼šæ£€æŸ¥é”®ç›˜ç›¸å…³å…ƒç´ 
        keyboard_indicators = [
            "keyboard", "inputmethod", "ime",
            "è¾“å…¥æ³•", "é”®ç›˜", "æœç´¢"
        ]
        
        try:
            dump = device.dump_hierarchy()
            if dump:
                dump_lower = dump.lower()
                if any(indicator in dump_lower for indicator in keyboard_indicators):
                    return True
        except:
            pass
        
        # æ–¹æ³•3ï¼šæ£€æŸ¥å±å¹•é«˜åº¦å˜åŒ–ï¼ˆç®€åŒ–ç‰ˆï¼‰
        try:
            screen_info = device.info
            display_height = screen_info.get("displayHeight", 0)
            if display_height > 0:
                # ç®€åŒ–åˆ¤æ–­ï¼šå¦‚æœå±å¹•é«˜åº¦æ˜æ˜¾å°äºæ ‡å‡†å€¼ï¼Œå¯èƒ½æ˜¯é”®ç›˜æ˜¾ç¤º
                # è¿™é‡Œåªæ˜¯ä¸€ä¸ªç®€å•çš„å¯å‘å¼åˆ¤æ–­
                pass
        except:
            pass
        
        return False
        
    except Exception as e:
        logging.debug(f"é”®ç›˜æ£€æŸ¥å¼‚å¸¸: {e}")
        return False

def wait_for_ui_stability(device, timeout=1.5):
    """
    ç­‰å¾…UIç¨³å®š - ä¼˜åŒ–ç‰ˆæœ¬ï¼Œå‡å°‘ç­‰å¾…æ—¶é—´
    """
    try:
        logging.debug(f"ç­‰å¾…UIç¨³å®šï¼Œè¶…æ—¶: {timeout}ç§’")
        
        # ä¼˜åŒ–çš„UIç¨³å®šæ£€æŸ¥
        stable_count = 0
        required_stable = 1  # åªéœ€è¦1æ¬¡æ£€æŸ¥ç¨³å®šå³å¯ï¼ˆé™ä½è¦æ±‚ï¼‰
        check_interval = 0.3  # æ¯0.3ç§’æ£€æŸ¥ä¸€æ¬¡ï¼ˆæé«˜æ£€æŸ¥é¢‘ç‡ï¼‰
        max_checks = int(timeout / check_interval)
        
        prev_dump = None
        
        for i in range(max_checks):
            try:
                # è·å–å½“å‰UIçŠ¶æ€
                current_dump = device.dump_hierarchy()
                
                if prev_dump is not None:
                    # æ¯”è¾ƒUIæ˜¯å¦å‘ç”Ÿå˜åŒ–
                    if current_dump == prev_dump:
                        stable_count += 1
                        if stable_count >= required_stable:
                            logging.debug(f"UIå·²ç¨³å®š (æ£€æŸ¥{i+1}æ¬¡)")
                            return True
                    else:
                        stable_count = 0  # é‡ç½®ç¨³å®šè®¡æ•°
                
                prev_dump = current_dump
                time.sleep(check_interval)
                
            except Exception as check_error:
                logging.debug(f"UIç¨³å®šæ£€æŸ¥å¼‚å¸¸: {check_error}")
                time.sleep(check_interval)
                continue
        
        logging.warning(f"UIç¨³å®šæ£€æŸ¥è¶…æ—¶ ({timeout}ç§’)")
        return False
        
    except Exception as e:
        logging.error(f"UIç¨³å®šæ£€æŸ¥å¤±è´¥: {e}")
        return False

def format_duration(seconds):
    """
    æ ¼å¼åŒ–æŒç»­æ—¶é—´
    """
    if seconds < 60:
        return f"{seconds:.2f}ç§’"
    elif seconds < 3600:
        minutes = int(seconds // 60)
        remaining_seconds = seconds % 60
        return f"{minutes}åˆ†{remaining_seconds:.2f}ç§’"
    else:
        hours = int(seconds // 3600)
        remaining_minutes = int((seconds % 3600) // 60)
        remaining_seconds = seconds % 60
        return f"{hours}å°æ—¶{remaining_minutes}åˆ†{remaining_seconds:.2f}ç§’"


# CAN é‡‡é›†ç”Ÿå‘½å‘¨æœŸç®¡ç†
can_capture_threads = {}  # å…¨å±€é‡‡é›†çŠ¶æ€ç®¡ç†å­—å…¸

def start_can_capture(task_id: str, can_capture_config: dict, runner_dir: str):
    """
    å¯åŠ¨æŒ‡å®šä»»åŠ¡çš„CANä¿¡å·é‡‡é›†çº¿ç¨‹
    
    Args:
        task_id: ä»»åŠ¡ID (å¦‚: drive_task, login_task)
        can_capture_config: CANé‡‡é›†é…ç½®
        runner_dir: è¿è¡Œç›®å½•è·¯å¾„ (å¦‚: /workspace/{script_id}/runner)
    
    Returns:
        str: é‡‡é›†æ–‡ä»¶è·¯å¾„
    """
    import threading
    import os
    from pathlib import Path
    
    # æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨é‡‡é›†
    if task_id in can_capture_threads:
        logging.warning(f"ä»»åŠ¡ {task_id} çš„CANé‡‡é›†å·²åœ¨è¿è¡Œ")
        return can_capture_threads[task_id]['file_path']
    
    # è·å–é‡‡é›†é…ç½®
    channel_list = can_capture_config.get('channel_list', [])
    ip = can_capture_config.get('ip', '127.0.0.1')
    
    # è‡ªåŠ¨ç”Ÿæˆæ–‡ä»¶è·¯å¾„ï¼ˆä½¿ç”¨æ—¶é—´æˆ³é¿å…é‡å¤ï¼‰
    can_dir = os.path.join(runner_dir, 'can_signals')
    os.makedirs(can_dir, exist_ok=True)
    
    # ä½¿ç”¨æ—¶é—´æˆ³ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
    timestamp = int(time.time() * 1000)  # æ¯«ç§’çº§æ—¶é—´æˆ³
    file_path = os.path.join(can_dir, f'{task_id}_signals_{timestamp}.txt')
    
    # åˆ›å»ºåœæ­¢äº‹ä»¶
    stop_event = threading.Event()
    
    # å¯åŠ¨é‡‡é›†çº¿ç¨‹
    capture_thread = threading.Thread(
        target=get_signal,
        args=(channel_list, file_path, stop_event, ip),
        daemon=True,
        name=f"CAN_Capture_{task_id}"
    )
    
    # è®°å½•é‡‡é›†çŠ¶æ€
    can_capture_threads[task_id] = {
        'thread': capture_thread,
        'stop_event': stop_event,
        'file_path': file_path,
        'channel_list': channel_list,
        'ip': ip,
        'start_time': time.time()
    }
    
    # é¢„åˆ›å»ºé‡‡é›†æ–‡ä»¶ï¼Œé¿å…å¯åŠ¨åç«‹å³è¯»å–æ—¶ä¸å­˜åœ¨
    try:
        Path(file_path).touch(exist_ok=True)
    except Exception as e:
        logging.warning(f"é¢„åˆ›å»ºCANé‡‡é›†æ–‡ä»¶å¤±è´¥: {e}")

    # å¯åŠ¨çº¿ç¨‹
    capture_thread.start()
    
    logging.info(f"âœ… å¯åŠ¨CANé‡‡é›†: ä»»åŠ¡={task_id}, é€šé“={channel_list}, æ–‡ä»¶={file_path}")
    
    return file_path


def stop_can_capture(task_id: str):
    """
    åœæ­¢æŒ‡å®šä»»åŠ¡çš„CANé‡‡é›†ï¼Œæ¸…ç†èµ„æº
    
    Args:
        task_id: ä»»åŠ¡ID
    
    Returns:
        bool: æ˜¯å¦æˆåŠŸåœæ­¢
    """
    if task_id not in can_capture_threads:
        logging.warning(f"ä»»åŠ¡ {task_id} çš„CANé‡‡é›†æœªåœ¨è¿è¡Œ")
        return False
    
    capture_info = can_capture_threads[task_id]
    
    # è®¾ç½®åœæ­¢äº‹ä»¶
    capture_info['stop_event'].set()
    
    # ç­‰å¾…çº¿ç¨‹ç»“æŸ
    try:
        capture_info['thread'].join(timeout=5.0)
        if capture_info['thread'].is_alive():
            logging.warning(f"CANé‡‡é›†çº¿ç¨‹ {task_id} æœªåœ¨è¶…æ—¶æ—¶é—´å†…ç»“æŸ")
        else:
            logging.info(f"âœ… CANé‡‡é›†çº¿ç¨‹ {task_id} å·²æ­£å¸¸ç»“æŸ")
    except Exception as e:
        logging.error(f"ç­‰å¾…CANé‡‡é›†çº¿ç¨‹ç»“æŸæ—¶å‡ºé”™: {e}")
    
    # è®¡ç®—é‡‡é›†æ—¶é•¿
    duration = time.time() - capture_info['start_time']
    
    # æ¸…ç†çŠ¶æ€
    del can_capture_threads[task_id]
    
    logging.info(f"ğŸ”„ åœæ­¢CANé‡‡é›†: ä»»åŠ¡={task_id}, æŒç»­æ—¶é—´={duration:.2f}ç§’")
    
    return True


def get_current_can_file_path(task_id: str) -> str:
    """
    è·å–å½“å‰ä»»åŠ¡çš„é‡‡é›†æ–‡ä»¶è·¯å¾„
    
    Args:
        task_id: ä»»åŠ¡ID
    
    Returns:
        str: æ–‡ä»¶è·¯å¾„ï¼Œå¦‚æœæœªåœ¨é‡‡é›†åˆ™è¿”å›ç©ºå­—ç¬¦ä¸²
    """
    if task_id in can_capture_threads:
        return can_capture_threads[task_id]['file_path']
    return ""


def check_remaining_verify_steps(action_sequence: list, current_index: int, task_id: str) -> bool:
    """
    æ£€æŸ¥æ˜¯å¦è¿˜æœ‰åç»­éªŒè¯æ­¥éª¤
    
    Args:
        action_sequence: åŠ¨ä½œåºåˆ—åˆ—è¡¨
        current_index: å½“å‰æ­¥éª¤ç´¢å¼•
        task_id: ä»»åŠ¡ID
    
    Returns:
        bool: æ˜¯å¦è¿˜æœ‰åç»­éªŒè¯æ­¥éª¤
    """
    # ä»å½“å‰ä½ç½®å‘åæŸ¥æ‰¾
    for i in range(current_index + 1, len(action_sequence)):
        step = action_sequence[i]
        
        # æ£€æŸ¥æ˜¯å¦æ˜¯ç›¸åŒä»»åŠ¡çš„éªŒè¯æ­¥éª¤
        if (step.get('source_task_id') == task_id and 
            step.get('verify_after') == True):
            return True
    
    return False


def is_can_capture_running(task_id: str) -> bool:
    """
    æ£€æŸ¥æŒ‡å®šä»»åŠ¡çš„CANé‡‡é›†æ˜¯å¦æ­£åœ¨è¿è¡Œ
    
    Args:
        task_id: ä»»åŠ¡ID
    
    Returns:
        bool: æ˜¯å¦æ­£åœ¨è¿è¡Œ
    """
    return task_id in can_capture_threads


def get_can_capture_status(task_id: str) -> dict:
    """
    è·å–CANé‡‡é›†çŠ¶æ€ä¿¡æ¯
    
    Args:
        task_id: ä»»åŠ¡ID
    
    Returns:
        dict: é‡‡é›†çŠ¶æ€ä¿¡æ¯
    """
    if task_id not in can_capture_threads:
        return {
            'running': False,
            'task_id': task_id
        }
    
    capture_info = can_capture_threads[task_id]
    duration = time.time() - capture_info['start_time']
    
    return {
        'running': True,
        'task_id': task_id,
        'file_path': capture_info['file_path'],
        'channel_list': capture_info['channel_list'],
        'ip': capture_info['ip'],
        'duration': duration,
        'thread_alive': capture_info['thread'].is_alive()
    }

