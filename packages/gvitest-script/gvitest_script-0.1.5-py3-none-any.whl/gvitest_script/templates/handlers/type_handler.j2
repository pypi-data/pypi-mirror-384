{# è¾“å…¥åŠ¨ä½œå¤„ç†æ¨¡æ¿ - ä¸“æ³¨äºæ“ä½œæ‰§è¡Œ #}

{# è¾“å…¥åŠ¨ä½œå¤„ç†å‡½æ•° #}
def handle_type_action(step_data, device, runner_dir, screenshot_count, previous_after_screenshot=None):
    """
    å¤„ç†æ–‡æœ¬è¾“å…¥åŠ¨ä½œ - ä¸“æ³¨äºæ“ä½œæ‰§è¡Œ
    
    Args:
        step_data: æ­¥éª¤ä¸Šä¸‹æ–‡å¯¹è±¡
        device: uiautomator2è®¾å¤‡å¯¹è±¡
        runner_dir: è¿è¡Œç›®å½•è·¯å¾„
        screenshot_count: æˆªå›¾è®¡æ•°
        previous_after_screenshot: å‰ä¸€æ­¥çš„æ‰§è¡Œåæˆªå›¾è·¯å¾„ï¼Œç”¨äºä¼˜åŒ–æˆªå›¾æ€§èƒ½
    
    Returns:
        Dict: æ‰§è¡Œç»“æœ
    """
    logging.info("å¼€å§‹æ‰§è¡Œæ­¥éª¤ %s: %s" % (step_data.get('step_number', 0), step_data.get('step_name', 'æœªçŸ¥æ­¥éª¤')))

    step_name = step_data.get('step_name', 'æ–‡æœ¬è¾“å…¥')
    operation_type = step_data.get('operation_type', 'type')
    # å…¼å®¹ä¸¤ç§æ•°æ®ç»“æ„ï¼šç›´æ¥åœ¨æ ¹çº§åˆ«çš„element_infoå’Œåœ¨parametersä¸­çš„element_info
    element_info = step_data.get('element_info', {}) or step_data.get('parameters', {}).get('element_info', {})
    
    # è·å–è¦è¾“å…¥çš„æ–‡æœ¬
    input_text = element_info.get('text', '')
    if not input_text:
        error_msg = "ç¼ºå°‘è¾“å…¥æ–‡æœ¬å†…å®¹"
        logging.error(error_msg)
        logging.error("æ­¥éª¤ %s æ‰§è¡Œé”™è¯¯: %s, é”™è¯¯: %s" % (step_data.get('step_number', 0), step_data.get('step_name', 'æœªçŸ¥æ­¥éª¤'), error_msg))
        return {
            "status": "failed", 
            "message": error_msg,

        }
    
    logging.info(f"å¼€å§‹æ‰§è¡Œæ–‡æœ¬è¾“å…¥: {step_name}, æ–‡æœ¬: '{input_text}'")
    
    try:
        # æ‰§è¡Œå‰æ— éœ€ç­‰å¾…UIç¨³å®šï¼Œç›´æ¥è¿›è¡Œæ“ä½œ
        
        # ä¼˜åŒ–æˆªå›¾é€»è¾‘ï¼šå¦‚æœæœ‰å‰ä¸€æ­¥çš„æˆªå›¾ï¼Œå°±å¤ç”¨å®ƒ
        step_number = step_data.get('step_number', 0)
        
        if previous_after_screenshot:
            # ä½¿ç”¨å‰ä¸€æ­¥çš„åæˆªå›¾ä½œä¸ºå½“å‰æ­¥éª¤çš„å‰æˆªå›¾ï¼Œé¿å…é‡å¤æˆªå›¾
            before_execution_screenshot_path = previous_after_screenshot
            logging.info(f"ğŸ“¸ å¤ç”¨å‰ä¸€æ­¥æˆªå›¾ä½œä¸ºæ‰§è¡Œå‰æˆªå›¾: {before_execution_screenshot_path}")
        else:
            # ç¬¬ä¸€æ­¥æˆ–æ²¡æœ‰å‰ä¸€æ­¥æˆªå›¾æ—¶ï¼Œéœ€è¦æ–°æˆªå›¾
            before_execution_screenshot_path = take_screenshot_and_save(
                device, runner_dir, f"before_step{step_number}", "æ‰§è¡Œå‰æˆªå›¾ - ç”¨äºè¾“å…¥æ¡†å®šä½"
            )
        
        # æ›´æ–°æ­¥éª¤æ‰§è¡Œå‰æˆªå›¾ä¿¡æ¯
        step_data['before_execution_screenshot_path'] = before_execution_screenshot_path
        

        
        # æ™ºèƒ½æŸ¥æ‰¾è¾“å…¥æ¡†
        input_found, input_coordinates, search_method = find_input_field_smart(device, element_info)
        
        if not input_found:
            logging.warning(f"æ™ºèƒ½æŸ¥æ‰¾è¾“å…¥æ¡†å¤±è´¥: {search_method}")
            # å›é€€åˆ°åŸºæœ¬çš„æ¿€æ´»æ–¹æ³•
            input_field_activated = activate_input_field(device, element_info, before_execution_screenshot_path)
        else:
            logging.info(f"æ™ºèƒ½æŸ¥æ‰¾è¾“å…¥æ¡†æˆåŠŸ: {search_method}, åæ ‡: {input_coordinates}")
            # ä½¿ç”¨æ™ºèƒ½æŸ¥æ‰¾åˆ°çš„åæ ‡è¿›è¡Œæ¿€æ´»
            element_info['start_x'] = input_coordinates[0]
            element_info['start_y'] = input_coordinates[1]
            input_field_activated = activate_input_field(device, element_info, before_execution_screenshot_path)
        
        # æ¸…ç©ºç°æœ‰å†…å®¹ï¼ˆå¯é€‰ï¼‰
        clear_existing = element_info.get('clear_existing', True)
        clear_success = True
        if clear_existing:
            logging.info("æ¸…ç©ºç°æœ‰å†…å®¹...")
            try:
                device.send_keys("", clear=True)
                time.sleep(0.2)
            except Exception as clear_error:
                logging.warning(f"æ¸…ç©ºå†…å®¹å¤±è´¥: {clear_error}")
                clear_success = False
        

        
        # æ‰§è¡Œæ–‡æœ¬è¾“å…¥
        logging.info(f"è¾“å…¥æ–‡æœ¬: '{input_text}'")
        device.send_keys(input_text)
        time.sleep(0.5)  # ç­‰å¾…è¾“å…¥å®Œæˆ
        
        # ç­‰å¾…UIç¨³å®šåè¿›è¡Œæ‰§è¡Œåæˆªå›¾
        logging.info("ç­‰å¾…åŠ¨ä½œæ‰§è¡Œå®ŒæˆåUIç¨³å®š...")
        ui_stable = wait_for_ui_stability(device, timeout=1.0)
        if not ui_stable:
            logging.warning("æ‰§è¡ŒåUIç¨³å®šæ£€æŸ¥è¶…æ—¶ï¼Œç»§ç»­æˆªå›¾")
        
        # æ‰§è¡Œåæˆªå›¾ï¼ˆç”¨äºå“åº”éªŒè¯ï¼‰
        after_execution_screenshot_path = take_screenshot_and_save(
            device, runner_dir, f"after_step{step_number}", "æ‰§è¡Œåæˆªå›¾ - ç”¨äºéªŒè¯è¾“å…¥ç»“æœ"
        )
        step_data['after_execution_screenshot_path'] = after_execution_screenshot_path
        

        
        # éªŒè¯è¾“å…¥ç»“æœ
        verification_result = verify_text_input(device, input_text, tolerance=0.8)
        
        # è®°å½•æ‰§è¡ŒçŠ¶æ€
        activation_method = "å·²æ¿€æ´»" if input_field_activated['success'] else f"æ¿€æ´»å¤±è´¥({input_field_activated['method']})"
        search_info = f"æŸ¥æ‰¾æ–¹æ³•: {search_method}" if input_found else "æœªæ‰¾åˆ°è¾“å…¥æ¡†"
        verification_info = f"éªŒè¯: {verification_result['reason']}" if verification_result['success'] else f"éªŒè¯å¤±è´¥: {verification_result['reason']}"
        
        execution_detail = f"æ–‡æœ¬è¾“å…¥æ‰§è¡Œå®Œæˆ: '{input_text}', è¾“å…¥æ¡†çŠ¶æ€: {activation_method}, {search_info}, {verification_info}"
        
        logging.info("æ­¥éª¤ %s å®Œæˆ: %s, æˆåŠŸ: %s" % (step_data.get('step_number', 0), step_data.get('step_name', 'æœªçŸ¥æ­¥éª¤'), True))
        
        logging.info(f"âœ… æ–‡æœ¬è¾“å…¥æ“ä½œæ‰§è¡Œå®Œæˆ: {step_name}")
        return {
            "status": "success",
            "message": f"æ–‡æœ¬è¾“å…¥æ‰§è¡ŒæˆåŠŸ: '{input_text}'",
            "input_activated": input_field_activated['success'],
            "activation_method": input_field_activated['method'],
            "input_found": input_found,
            "search_method": search_method,
            "verification_result": verification_result,
            "text": input_text,
            "execution_detail": execution_detail,
            "screenshots": {
                "before_execution": step_data.get('before_execution_screenshot_path'),
                "after_execution": after_execution_screenshot_path
            },

        }
        
    except Exception as e:
        error_msg = "æ–‡æœ¬è¾“å…¥æ‰§è¡Œå¤±è´¥: " + str(e)
        logging.error(error_msg)
        

        
        # ç¡®ä¿æœ‰æˆªå›¾è®°å½•é”™è¯¯çŠ¶æ€
        if not step_data.get('before_execution_screenshot_path'):
            try:
                error_screenshot_path = take_screenshot_and_save(
                    device, runner_dir, f"error_{operation_type}", "é”™è¯¯æˆªå›¾ - è®°å½•è¾“å…¥æ“ä½œå¤±è´¥æ—¶çš„ç•Œé¢çŠ¶æ€"
                )
                step_data['before_execution_screenshot_path'] = error_screenshot_path
            except Exception as screenshot_error:
                logging.error(f"é”™è¯¯æˆªå›¾å¤±è´¥: {screenshot_error}")
        
        logging.error("æ­¥éª¤ %s æ‰§è¡Œé”™è¯¯: %s, é”™è¯¯: %s" % (step_data.get('step_number', 0), step_data.get('step_name', 'æœªçŸ¥æ­¥éª¤'), error_msg))
        
        return {
            "status": "failed",
            "message": error_msg,
            "text": input_text,

        }


{# è¾“å…¥æ¡†æ¿€æ´»å‡½æ•° - ä¼˜åŒ–ç‰ˆæœ¬ #}
def activate_input_field(device, element_info, screenshot_path):
    """
    å°è¯•æ¿€æ´»è¾“å…¥æ¡†
    
    Args:
        device: è®¾å¤‡å¯¹è±¡
        element_info: å…ƒç´ ä¿¡æ¯
        screenshot_path: å½“å‰æˆªå›¾è·¯å¾„
    
    Returns:
        Dict: æ¿€æ´»ç»“æœ {"success": bool, "method": str}
    """
    try:
        # æ£€æŸ¥æ˜¯å¦å·²ç»æ¿€æ´»
        input_state = check_text_input_state(device)
        if input_state.get('is_input_active', False):
            logging.info("âœ… è¾“å…¥æ¡†å·²å¤„äºæ¿€æ´»çŠ¶æ€")
            return {"success": True, "method": "å·²æ¿€æ´»"}
        
        # æ–¹æ³•1ï¼šé€šè¿‡åæ ‡ç‚¹å‡»æ¿€æ´»
        target_x = element_info.get('start_x')
        target_y = element_info.get('start_y')
        width = element_info.get('width', 0)
        height = element_info.get('height', 0)
        
        if target_x is not None and target_y is not None:
            if width > 0 and height > 0:
                click_x = target_x + width / 2
                click_y = target_y + height / 2
            else:
                click_x = target_x
                click_y = target_y
            
            logging.info(f"å°è¯•åæ ‡ç‚¹å‡»æ¿€æ´»: ({click_x}, {click_y})")
            device.click(click_x, click_y)
            time.sleep(0.5)
            
            # æ£€æŸ¥æ¿€æ´»ç»“æœ
            state_after_click = check_text_input_state(device)
            if state_after_click.get('is_input_active', False):
                return {"success": True, "method": "åæ ‡ç‚¹å‡»"}
        
        # æ–¹æ³•2ï¼šæ™ºèƒ½å®šä½ç‚¹å‡»æ¿€æ´» - ä½¿ç”¨æ–‡ä»¶è·¯å¾„
        icon_path = element_info.get('icon_path')
        # reference_image_pathåº”è¯¥æ˜¯å½•åˆ¶æ—¶çš„å¤§å›¾ï¼Œå³screenshot_path
        # æ³¨æ„ï¼šè¿™é‡Œæ— æ³•ç›´æ¥è®¿é—®step_dataï¼Œéœ€è¦ä»element_infoä¸­è·å–å½•åˆ¶æ—¶çš„æˆªå›¾è·¯å¾„
        reference_screenshot_path = element_info.get('screenshot_path')  # å½•åˆ¶æ—¶çš„æˆªå›¾è·¯å¾„
        # ä½¿ç”¨ä¼ å…¥çš„æ‰§è¡Œå‰æˆªå›¾è·¯å¾„
        
        if icon_path and reference_screenshot_path and screenshot_path:
            logging.info("å°è¯•æ™ºèƒ½å®šä½æ¿€æ´»...")
            try:
                bbox = element_info.get('bbox', [])
                if bbox and len(bbox) == 4:
                    found_coords = locate_small_via_dynamic_medium(
                        reference_image_data=reference_screenshot_path,
                        target_image_data=icon_path,
                        target_bbox=bbox,
                        detect_image_data=screenshot_path
                    )
                    
                    if found_coords:
                        x1, y1, x2, y2 = found_coords
                        click_x = (x1 + x2) / 2
                        click_y = (y1 + y2) / 2
                        
                        logging.info(f"æ™ºèƒ½å®šä½ç‚¹å‡»æ¿€æ´»: ({click_x:.1f}, {click_y:.1f})")
                        device.click(click_x, click_y)
                        time.sleep(0.5)
                        
                        state_after_smart = check_text_input_state(device)
                        if state_after_smart.get('is_input_active', False):
                            return {"success": True, "method": "æ™ºèƒ½å®šä½"}
                    else:
                        logging.info("æ™ºèƒ½å®šä½æœªæ‰¾åˆ°ç›®æ ‡å…ƒç´ ")
                else:
                    logging.warning("ç¼ºå°‘æœ‰æ•ˆçš„è¾¹ç•Œæ¡†ä¿¡æ¯")
                        
            except Exception as smart_error:
                logging.warning(f"æ™ºèƒ½å®šä½æ¿€æ´»å¤±è´¥: {smart_error}")
        
        # æ–¹æ³•3ï¼šæŸ¥æ‰¾å¯ç¼–è¾‘å…ƒç´ 
        logging.info("å°è¯•æŸ¥æ‰¾å¯ç¼–è¾‘å…ƒç´ ...")
        try:
            editable_elements = device(editable=True)
            if editable_elements.exists:
                first_editable = editable_elements[0]
                first_editable.click()
                time.sleep(0.5)
                
                state_after_editable = check_text_input_state(device)
                if state_after_editable.get('is_input_active', False):
                    return {"success": True, "method": "å¯ç¼–è¾‘å…ƒç´ "}
                    
        except Exception as editable_error:
            logging.warning(f"æŸ¥æ‰¾å¯ç¼–è¾‘å…ƒç´ å¤±è´¥: {editable_error}")
        
        # æ–¹æ³•4ï¼šå°è¯•å¸¸è§è¾“å…¥æ¡†ç±»å
        input_classes = ['EditText', 'TextField', 'TextInputLayout']
        for class_name in input_classes:
            try:
                element = device(className=class_name)
                if element.exists:
                    element.click()
                    time.sleep(0.5)
                    
                    state_after_class = check_text_input_state(device)
                    if state_after_class.get('is_input_active', False):
                        return {"success": True, "method": f"ç±»å: {class_name}"}
                        
            except Exception as class_error:
                logging.debug(f"ç±»å {class_name} æ¿€æ´»å¤±è´¥: {class_error}")
                continue
        
        logging.warning("æ‰€æœ‰è¾“å…¥æ¡†æ¿€æ´»æ–¹æ³•éƒ½å¤±è´¥")
        return {"success": False, "method": "æ‰€æœ‰æ–¹æ³•å¤±è´¥"}
        
    except Exception as e:
        logging.error(f"è¾“å…¥æ¡†æ¿€æ´»å¼‚å¸¸: {e}")
        return {"success": False, "method": f"æ¿€æ´»å¼‚å¸¸: {e}"}


{# æ™ºèƒ½è¾“å…¥æ¡†æŸ¥æ‰¾å‡½æ•° #}
def find_input_field_smart(device, element_info):
    """
    æ™ºèƒ½æŸ¥æ‰¾è¾“å…¥æ¡†
    
    Args:
        device: è®¾å¤‡å¯¹è±¡
        element_info: å…ƒç´ ä¿¡æ¯
    
    Returns:
        Tuple: (found, coordinates, method)
    """
    try:
        # æ–¹æ³•1ï¼šé€šè¿‡åæ ‡æŸ¥æ‰¾
        target_x = element_info.get('start_x')
        target_y = element_info.get('start_y')
        
        if target_x is not None and target_y is not None:
            width = element_info.get('width', 0)
            height = element_info.get('height', 0)
            
            if width > 0 and height > 0:
                center_x = target_x + width / 2
                center_y = target_y + height / 2
            else:
                center_x = target_x
                center_y = target_y
            
            return True, (center_x, center_y), "åæ ‡å®šä½"
        
        # æ–¹æ³•2ï¼šé€šè¿‡æ–‡æœ¬æŸ¥æ‰¾è¾“å…¥æ¡†
        placeholder_text = element_info.get('placeholder', '')
        hint_text = element_info.get('hint', '')
        
        if placeholder_text:
            try:
                element = device(text=placeholder_text)
                if element.exists:
                    bounds = element.info['bounds']
                    center_x = (bounds['left'] + bounds['right']) / 2
                    center_y = (bounds['top'] + bounds['bottom']) / 2
                    return True, (center_x, center_y), f"å ä½ç¬¦æ–‡æœ¬: {placeholder_text}"
            except:
                pass
        
        if hint_text:
            try:
                element = device(description=hint_text)
                if element.exists:
                    bounds = element.info['bounds']
                    center_x = (bounds['left'] + bounds['right']) / 2
                    center_y = (bounds['top'] + bounds['bottom']) / 2
                    return True, (center_x, center_y), f"æç¤ºæ–‡æœ¬: {hint_text}"
            except:
                pass
        
        # æ–¹æ³•3ï¼šæŸ¥æ‰¾å¯ç¼–è¾‘å…ƒç´ 
        try:
            editable_elements = device(editable=True)
            if editable_elements.exists:
                first_editable = editable_elements[0]
                bounds = first_editable.info['bounds']
                center_x = (bounds['left'] + bounds['right']) / 2
                center_y = (bounds['top'] + bounds['bottom']) / 2
                return True, (center_x, center_y), "å¯ç¼–è¾‘å…ƒç´ "
        except:
            pass
        
        # æ–¹æ³•4ï¼šæŸ¥æ‰¾è¾“å…¥æ¡†ç±»å…ƒç´ 
        input_classes = ['EditText', 'TextField', 'TextInputLayout']
        for class_name in input_classes:
            try:
                element = device(className=class_name)
                if element.exists:
                    bounds = element.info['bounds']
                    center_x = (bounds['left'] + bounds['right']) / 2
                    center_y = (bounds['top'] + bounds['bottom']) / 2
                    return True, (center_x, center_y), f"ç±»å: {class_name}"
            except:
                continue
        
        return False, None, "æœªæ‰¾åˆ°è¾“å…¥æ¡†"
        
    except Exception as e:
        logging.error(f"æ™ºèƒ½æŸ¥æ‰¾è¾“å…¥æ¡†å¼‚å¸¸: {e}")
        return False, None, f"æŸ¥æ‰¾å¼‚å¸¸: {e}"


{# è¾“å…¥éªŒè¯å‡½æ•° #}
def verify_text_input(device, expected_text, tolerance=0.8):
    """
    éªŒè¯æ–‡æœ¬è¾“å…¥ç»“æœ
    
    Args:
        device: è®¾å¤‡å¯¹è±¡
        expected_text: æœŸæœ›çš„æ–‡æœ¬
        tolerance: å®¹é”™ç‡
    
    Returns:
        Dict: éªŒè¯ç»“æœ
    """
    try:
        # è·å–å½“å‰ç„¦ç‚¹å…ƒç´ çš„æ–‡æœ¬
        current_text = ""
        
        try:
            focused_element = device(focused=True)
            if focused_element.exists:
                current_text = focused_element.get_text()
        except:
            pass
        
        # å¦‚æœæ²¡æœ‰ç„¦ç‚¹å…ƒç´ ï¼Œå°è¯•è·å–æ‰€æœ‰å¯ç¼–è¾‘å…ƒç´ çš„æ–‡æœ¬
        if not current_text:
            try:
                editable_elements = device(editable=True)
                if editable_elements.exists:
                    for element in editable_elements:
                        text = element.get_text()
                        if text and expected_text in text:
                            current_text = text
                            break
            except:
                pass
        
        # éªŒè¯æ–‡æœ¬åŒ¹é…
        if not current_text:
            return {
            "success": False,
            "reason": "æ— æ³•è·å–è¾“å…¥æ¡†æ–‡æœ¬",
                "expected": expected_text,
                "actual": ""
            }
        
        # å®Œå…¨åŒ¹é…
        if current_text == expected_text:
            return {
                "success": True,
                "reason": "æ–‡æœ¬å®Œå…¨åŒ¹é…",
                "expected": expected_text,
                "actual": current_text
            }
        
        # åŒ…å«åŒ¹é…
        if expected_text in current_text:
            return {
                "success": True,
                "reason": "æ–‡æœ¬åŒ…å«åŒ¹é…",
                "expected": expected_text,
                "actual": current_text
            }
        
        # ç›¸ä¼¼åº¦åŒ¹é…
        similarity = len(set(expected_text) & set(current_text)) / len(set(expected_text) | set(current_text))
        if similarity >= tolerance:
            return {
                "success": True,
                "reason": f"æ–‡æœ¬ç›¸ä¼¼åº¦åŒ¹é… ({similarity:.2f})",
                "expected": expected_text,
                "actual": current_text,
                "similarity": similarity
            }
        
        return {
            "success": False,
            "reason": f"æ–‡æœ¬ä¸åŒ¹é… (ç›¸ä¼¼åº¦: {similarity:.2f})",
            "expected": expected_text,
            "actual": current_text,
            "similarity": similarity
        }
        
    except Exception as e:
        return {
            "success": False,
            "reason": f"éªŒè¯å¼‚å¸¸: {e}",
            "expected": expected_text,
            "actual": ""
        } 