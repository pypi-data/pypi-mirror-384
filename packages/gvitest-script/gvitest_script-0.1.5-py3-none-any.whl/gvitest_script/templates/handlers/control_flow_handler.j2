{# æ§åˆ¶æµå¤„ç†å™¨æ¨¡æ¿ - æ”¯æŒif/for/whileæ§åˆ¶ç»“æ„ #}

{# å¯¼å…¥å­æ­¥éª¤æ£€æŸ¥ç‚¹éªŒè¯å® #}
{% from 'main/sub_action_checkpoint_validation.j2' import execute_sub_action_checkpoint_validation %}

{# validate_validation_modelå‡½æ•°å·²åœ¨base/validation_utils.j2ä¸­å®šä¹‰ï¼Œæ— éœ€é‡å¤å¯¼å…¥ #}

def handle_control_flow_action(step_data, device, runner_dir, screenshot_count):
    """
    æ§åˆ¶æµå¤„ç†å™¨ - å¤„ç†if/for/whileç­‰æ§åˆ¶ç»“æ„
    
    Args:
        step_data: æ­¥éª¤æ•°æ®
        device: è®¾å¤‡å¯¹è±¡
        runner_dir: è¿è¡Œç›®å½•
        screenshot_count: æˆªå›¾è®¡æ•°
    
    Returns:
        Dict: æ‰§è¡Œç»“æœ
    """
    try:
        control_flow_config = step_data.get('control_flow_config', {})
        control_type = control_flow_config.get('control_type', '').lower()
        
        logging.info(f"æ‰§è¡Œæ§åˆ¶æµ: {control_type} - {step_data.get('step_name', 'æœªçŸ¥æ­¥éª¤')}")
        
        if control_type == 'if_elseif_else':
            return handle_if_elseif_else_control_flow(step_data, device, runner_dir, screenshot_count)
        elif control_type == 'for':
            return handle_for_control_flow(step_data, device, runner_dir, screenshot_count)
        elif control_type == 'while':
            return handle_while_control_flow(step_data, device, runner_dir, screenshot_count)
        else:
            return {
                "status": "failed",
                "message": f"ä¸æ”¯æŒçš„æ§åˆ¶æµç±»å‹: {control_type}",
                "step_name": step_data.get('step_name', 'æœªçŸ¥æ­¥éª¤'),
                "screenshots": {
                    "before_execution": None,
                    "after_execution": None
                }
            }
    except Exception as e:
        logging.error(f"æ§åˆ¶æµæ‰§è¡Œå¼‚å¸¸: {e}")
        return {
            "status": "failed",
            "message": f"æ§åˆ¶æµæ‰§è¡Œå¼‚å¸¸: {e}",
            "step_name": step_data.get('step_name', 'æœªçŸ¥æ­¥éª¤'),
            "screenshots": {
                "before_execution": None,
                "after_execution": None
            }
        }


def handle_if_elseif_else_control_flow(step_data, device, runner_dir, screenshot_count):
    """
    å¤„ç†if-elseif-elseæ¡ä»¶åˆ†æ”¯é€»è¾‘
    
    Args:
        step_data: æ­¥éª¤æ•°æ®
        device: è®¾å¤‡å¯¹è±¡
        runner_dir: è¿è¡Œç›®å½•
        screenshot_count: æˆªå›¾è®¡æ•°
    
    Returns:
        Dict: æ‰§è¡Œç»“æœ
    """
    try:
        control_flow_config = step_data.get('control_flow_config', {})
        branches = control_flow_config.get('branches', [])
        
        logging.info(f"æ‰§è¡Œif_elseif_elseæ§åˆ¶æµ: {step_data.get('step_name', 'æœªçŸ¥æ­¥éª¤')}")
        
        # éå†æ‰€æœ‰åˆ†æ”¯ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„åˆ†æ”¯
        for i, branch in enumerate(branches):
            expression = branch.get('expression', '')
            conditions = branch.get('conditions', [])  # ä¿®å¤ï¼šä½¿ç”¨'conditions'ä»¥ä¿æŒä¸€è‡´æ€§
            steps = branch.get('steps', [])
            
            logging.info(f"æ£€æŸ¥åˆ†æ”¯ {i+1}: {expression}")
            logging.info(f"åˆ†æ”¯ {i+1} æ¡ä»¶è¯¦æƒ…:")
            for j, condition in enumerate(conditions):
                condition_id = condition.get('id', f'condition_{j+1}')
                target_text = condition.get('target_text', '')
                expect_exists = condition.get('expect_exists', True)
                validation_type = condition.get('validation_type', 'text')
                data_source = condition.get('data_source', 'adb_screenshot')
                logging.info(f"  æ¡ä»¶ {j+1} [{condition_id}]: æ£€æµ‹'{target_text}' (ç±»å‹:{validation_type}, æ¥æº:{data_source}, æœŸæœ›å­˜åœ¨:{expect_exists})")
            
            # ========== CAN é‡‡é›†å¯åŠ¨ ==========
            try:
                source_task_id = step_data.get('source_task_id', '')
                # åˆ¤æ–­æ˜¯å¦åŒ…å« CAN æ¡ä»¶
                has_can_condition = False
                for cond in conditions:
                    ds = (cond.get('data_source') or '').lower()
                    vt = (cond.get('validation_type') or '').lower()
                    if ds == 'can_signal' or vt in ('can', 'signal'):
                        has_can_condition = True
                        break

                # è¯»å– can_capture é…ç½®
                can_capture_config = None
                try:
                    can_capture_config = branch.get('can_capture') if isinstance(branch, dict) else None
                except Exception:
                    can_capture_config = None
                if not can_capture_config:
                    try:
                        can_capture_config = getattr(branch, 'can_capture', None)
                    except Exception:
                        can_capture_config = None

                if source_task_id and has_can_condition and can_capture_config and not is_can_capture_running(source_task_id):
                    logging.info(f"ğŸ¯ æ§åˆ¶æµ(åˆ†æ”¯)æ£€æµ‹åˆ° CAN æ¡ä»¶ï¼Œå¯åŠ¨ä»»åŠ¡ {source_task_id} çš„ CAN é‡‡é›†...")
                    try:
                        start_can_capture(source_task_id, can_capture_config, str(runner_dir))
                        logging.info(f"âœ… å·²è°ƒç”¨å¯åŠ¨ CAN é‡‡é›†: task={source_task_id}")
                    except Exception as can_start_error:
                        logging.error(f"âŒ æ§åˆ¶æµåˆ†æ”¯å¯åŠ¨ CAN é‡‡é›†å¤±è´¥: {can_start_error}")
                elif source_task_id and has_can_condition and not can_capture_config:
                    logging.warning(f"âš ï¸ æ£€æµ‹åˆ° CAN æ¡ä»¶ä½†æœªæä¾› can_capture é…ç½®ï¼ˆåˆ†æ”¯çº§ï¼‰ï¼Œæ— æ³•å¯åŠ¨é‡‡é›†")
            except Exception as _can_prepare_err:
                logging.warning(f"æ§åˆ¶æµåˆ†æ”¯ CAN é‡‡é›†å‡†å¤‡å¼‚å¸¸: {_can_prepare_err}")

            # è¯„ä¼°æ¡ä»¶è¡¨è¾¾å¼
            logging.info(f"å¼€å§‹è¯„ä¼°åˆ†æ”¯ {i+1} çš„æ¡ä»¶è¡¨è¾¾å¼: {expression}")
            # è·å–å½“å‰ CAN æ–‡ä»¶è·¯å¾„å¹¶éšè¯„ä¼°ä¼ å…¥
            current_can_file_path = None
            try:
                source_task_id = step_data.get('source_task_id', '')
                if source_task_id:
                    current_can_file_path = get_current_can_file_path(source_task_id)
                    if current_can_file_path:
                        logging.info(f"ğŸš— æ§åˆ¶æµåˆ†æ”¯ä½¿ç”¨ CAN æ–‡ä»¶: {current_can_file_path}")
            except Exception:
                current_can_file_path = None

            condition_result = evaluate_control_flow_condition(
                expression, conditions, device, runner_dir, screenshot_count, can_file_path=current_can_file_path
            )
            logging.info(f"åˆ†æ”¯ {i+1} æ¡ä»¶è¯„ä¼°ç»“æœ: {condition_result}")
            
            if condition_result:
                logging.info(f"åˆ†æ”¯ {i+1} æ¡ä»¶æ»¡è¶³ï¼Œæ‰§è¡Œæ­¥éª¤")
                
                # æ‰§è¡Œåˆ†æ”¯ä¸­çš„æ­¥éª¤ - ä½¿ç”¨ç»Ÿä¸€çš„å­æ­¥éª¤æ‰§è¡Œå‡½æ•°
                branch_previous_after_screenshot = None  # åˆ†æ”¯å†…çš„æˆªå›¾ä¼˜åŒ–
                executed_sub_steps = []  # æ”¶é›†å®é™…æ‰§è¡Œçš„å­æ­¥éª¤
                
                for step_index, step in enumerate(steps):
                    # ä¸ºåˆ†æ”¯ä¸­çš„å­æ­¥éª¤åˆ›å»ºå‰¯æœ¬å¹¶æ›´æ–°æ­¥éª¤ç¼–å·
                    branch_step = step.copy()
                    original_step_number = step.get('step_number', step_index)
                    branch_step['step_number'] = f"{original_step_number}_branch{i}"
                    
                    result = execute_sub_action_with_checkpoint(
                        branch_step, device, runner_dir, screenshot_count, branch_previous_after_screenshot
                    )
                    
                    if result.get('status') == 'error':
                        return result
                    
                    # æ›´æ–°åˆ†æ”¯å†…çš„æˆªå›¾ä¼˜åŒ–å‚æ•°
                    if result and result.get('screenshots'):
                        branch_previous_after_screenshot = result['screenshots'].get('after_execution')
                    
                    # æ”¶é›†å·²æ‰§è¡Œçš„å­æ­¥éª¤ï¼ˆåŒ…å«æ‰§è¡Œåçš„çŠ¶æ€ï¼‰
                    executed_sub_steps.append(branch_step)
                
                return {
                    "status": "success",
                    "message": f"if_elseif_elseåˆ†æ”¯ {i+1} æ‰§è¡ŒæˆåŠŸ",
                    "branch_index": i,
                    "step_name": step_data.get('step_name', 'æœªçŸ¥æ­¥éª¤'),
                    "screenshots": {
                        "before_execution": None,
                        "after_execution": None
                    },
                    "executed_sub_steps": executed_sub_steps  # ä¿å­˜å®é™…æ‰§è¡Œçš„å­æ­¥éª¤
                }
        
        # æ²¡æœ‰åˆ†æ”¯æ»¡è¶³æ¡ä»¶
        logging.info("æ²¡æœ‰åˆ†æ”¯æ»¡è¶³æ¡ä»¶")
        return {
            "status": "success",
            "message": "æ²¡æœ‰åˆ†æ”¯æ»¡è¶³æ¡ä»¶",
            "step_name": step_data.get('step_name', 'æœªçŸ¥æ­¥éª¤'),
            "screenshots": {
                "before_execution": None,
                "after_execution": None
            },
            "executed_sub_steps": []  # æ²¡æœ‰æ‰§è¡Œçš„å­æ­¥éª¤
        }
        
    except Exception as e:
        logging.error(f"if_elseif_elseæ§åˆ¶æµæ‰§è¡Œå¼‚å¸¸: {e}")
        return {
            "status": "failed",
            "message": f"if_elseif_elseæ§åˆ¶æµæ‰§è¡Œå¼‚å¸¸: {e}",
            "step_name": step_data.get('step_name', 'æœªçŸ¥æ­¥éª¤'),
            "screenshots": {
                "before_execution": None,
                "after_execution": None
            },

        }


def handle_for_control_flow(step_data, device, runner_dir, screenshot_count):
    """
    å¤„ç†forå¾ªç¯é€»è¾‘ - ç®€åŒ–ç‰ˆï¼Œåªæ”¯æŒcount
    
    Args:
        step_data: æ­¥éª¤æ•°æ®
        device: è®¾å¤‡å¯¹è±¡
        runner_dir: è¿è¡Œç›®å½•
        screenshot_count: æˆªå›¾è®¡æ•°
    
    Returns:
        Dict: æ‰§è¡Œç»“æœ
    """
    try:
        control_flow_config = step_data.get('control_flow_config', {})
        for_config = control_flow_config.get('for_config', {})
        loop_body = control_flow_config.get('loop_body', [])
        
        variable = for_config.get('variable', 'count')
        
        # ç®€å•çš„é…ç½®ä¼˜å…ˆçº§ï¼švalues > count > é»˜è®¤
        values = for_config.get('values', [])
        count_config = for_config.get('count', 0)
        
        if values:
            # ä½¿ç”¨valuesæ–¹å¼
            range_values = values
            count = len(range_values)
            logging.info(f"ä½¿ç”¨valuesé…ç½®: {range_values}")
        elif count_config > 0:
            # ä½¿ç”¨countæ–¹å¼
            count = count_config
            range_values = list(range(1, count + 1))
            logging.info(f"ä½¿ç”¨counté…ç½®: å¾ªç¯{count}æ¬¡ â†’ {range_values}")
        else:
            # é»˜è®¤æ‰§è¡Œ1æ¬¡
            count = 1
            range_values = [1]
            logging.info(f"ä½¿ç”¨é»˜è®¤é…ç½®: {range_values}")
        
        logging.info(f"æ‰§è¡Œforå¾ªç¯: {step_data.get('step_name', 'æœªçŸ¥æ­¥éª¤')} - å¾ªç¯{count}æ¬¡, å–å€¼: {range_values}")
        
        # æ‰§è¡Œå¾ªç¯ä½“
        loop_previous_after_screenshot = None  # å¾ªç¯å†…çš„æˆªå›¾ä¼˜åŒ–
        executed_sub_steps = []  # æ”¶é›†æ‰€æœ‰å®é™…æ‰§è¡Œçš„å­æ­¥éª¤
        
        for i, loop_value in enumerate(range_values):
            logging.info(f"forå¾ªç¯ç¬¬ {i+1}/{count} æ¬¡è¿­ä»£, {variable}={loop_value}")
            
            # è®¾ç½®å¾ªç¯å˜é‡
            loop_context = {
                'index': i,
                'iteration': i + 1,
                'count': count,
                'current_value': loop_value,
                variable: loop_value  # åŠ¨æ€è®¾ç½®å˜é‡å
            }
            
            # æ‰§è¡Œå¾ªç¯ä½“ä¸­çš„æ­¥éª¤ - ä½¿ç”¨ç»Ÿä¸€çš„å­æ­¥éª¤æ‰§è¡Œå‡½æ•°
            for step_index, step in enumerate(loop_body):
                # ä¸ºæ¯æ¬¡è¿­ä»£çš„å­æ­¥éª¤åˆ›å»ºå‰¯æœ¬å¹¶æ›´æ–°æ­¥éª¤ç¼–å·
                iteration_step = step.copy()
                original_step_number = step.get('step_number', step_index)
                iteration_step['step_number'] = f"{original_step_number}_iter{i+1}"
                
                result = execute_sub_action_with_checkpoint(
                    iteration_step, device, runner_dir, screenshot_count, loop_previous_after_screenshot
                )
                
                if result.get('status') == 'error':
                    return result
                
                # æ›´æ–°å¾ªç¯å†…çš„æˆªå›¾ä¼˜åŒ–å‚æ•°
                if result and result.get('screenshots'):
                    loop_previous_after_screenshot = result['screenshots'].get('after_execution')
                
                # æ”¶é›†å·²æ‰§è¡Œçš„å­æ­¥éª¤ï¼ˆåŒ…å«æ‰§è¡Œåçš„çŠ¶æ€ï¼‰
                executed_sub_steps.append(iteration_step)
        
        return {
            "status": "success",
            "message": f"forå¾ªç¯æ‰§è¡Œå®Œæˆï¼Œå…±æ‰§è¡Œ{count}æ¬¡",
            "iterations": count,
            "step_name": step_data.get('step_name', 'æœªçŸ¥æ­¥éª¤'),
            "screenshots": {
                "before_execution": None,
                "after_execution": None
            },
            "executed_sub_steps": executed_sub_steps  # ä¿å­˜æ‰€æœ‰å®é™…æ‰§è¡Œçš„å­æ­¥éª¤
        }
        
    except Exception as e:
        logging.error(f"foræ§åˆ¶æµæ‰§è¡Œå¼‚å¸¸: {e}")
        return {
            "status": "failed",
            "message": f"foræ§åˆ¶æµæ‰§è¡Œå¼‚å¸¸: {e}",
            "step_name": step_data.get('step_name', 'æœªçŸ¥æ­¥éª¤'),
            "screenshots": {
                "before_execution": None,
                "after_execution": None
            },

        }


def handle_while_control_flow(step_data, device, runner_dir, screenshot_count):
    """
    å¤„ç†whileå¾ªç¯é€»è¾‘
    
    Args:
        step_data: æ­¥éª¤æ•°æ®
        device: è®¾å¤‡å¯¹è±¡
        runner_dir: è¿è¡Œç›®å½•
        screenshot_count: æˆªå›¾è®¡æ•°
    
    Returns:
        Dict: æ‰§è¡Œç»“æœ
    """
    try:
        control_flow_config = step_data.get('control_flow_config', {})
        while_config = control_flow_config.get('while_config', {})
        loop_body = control_flow_config.get('loop_body', [])
        
        # ğŸ” è°ƒè¯•ï¼šæ‰“å°æ•°æ®ç»“æ„
        logging.info(f"ğŸ” è°ƒè¯•whileå¾ªç¯æ•°æ®ç»“æ„:")
        logging.info(f"   control_flow_config keys: {list(control_flow_config.keys()) if control_flow_config else 'None'}")
        logging.info(f"   while_config keys: {list(while_config.keys()) if while_config else 'None'}")
        logging.info(f"   while_configå†…å®¹: {while_config}")
        
        expression = while_config.get('expression', '')
        conditions = while_config.get('conditions', [])
        max_iterations = while_config.get('max_iterations')  # å¯é€‰å‚æ•°
        
        logging.info(f"   è§£æç»“æœ - expression: '{expression}', conditionsæ•°é‡: {len(conditions)}")
        if max_iterations is not None:
            logging.info(f"   æœ€å¤§è¿­ä»£æ¬¡æ•°: {max_iterations}")
        else:
            logging.info(f"   æœ€å¤§è¿­ä»£æ¬¡æ•°: æ— é™åˆ¶")
        
        logging.info(f"æ‰§è¡Œwhileå¾ªç¯: {step_data.get('step_name', 'æœªçŸ¥æ­¥éª¤')}")
        
        iteration_count = 0
        
        # å¾ªç¯å‰ï¼šè‹¥æœ‰ CAN æ¡ä»¶
        try:
            source_task_id = step_data.get('source_task_id', '')
            has_can_condition = False
            for cond in conditions:
                ds = (cond.get('data_source') or '').lower()
                vt = (cond.get('validation_type') or '').lower()
                if ds == 'can_signal' or vt in ('can', 'signal'):
                    has_can_condition = True
                    break

            # è¯»å– can_capture é…ç½®
            can_capture_config = while_config.get('can_capture')
            if source_task_id and has_can_condition and can_capture_config and not is_can_capture_running(source_task_id):
                logging.info(f"ğŸ¯ æ§åˆ¶æµ(while)æ£€æµ‹åˆ° CAN æ¡ä»¶ï¼Œå¯åŠ¨ä»»åŠ¡ {source_task_id} çš„ CAN é‡‡é›†...")
                try:
                    start_can_capture(source_task_id, can_capture_config, str(runner_dir))
                except Exception as can_start_error:
                    logging.error(f"âŒ æ§åˆ¶æµ while å¯åŠ¨ CAN é‡‡é›†å¤±è´¥: {can_start_error}")
        except Exception as _can_prepare_err:
            logging.warning(f"æ§åˆ¶æµ while CAN é‡‡é›†å‡†å¤‡å¼‚å¸¸: {_can_prepare_err}")

        # æ‰§è¡Œwhileå¾ªç¯
        loop_previous_after_screenshot = None  # å¾ªç¯å†…çš„æˆªå›¾ä¼˜åŒ–
        executed_sub_steps = []  # æ”¶é›†æ‰€æœ‰å®é™…æ‰§è¡Œçš„å­æ­¥éª¤
        while True:
            # æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æœ€å¤§è¿­ä»£æ¬¡æ•°
            if max_iterations is not None and iteration_count >= max_iterations:
                logging.warning(f"whileå¾ªç¯è¾¾åˆ°æœ€å¤§è¿­ä»£æ¬¡æ•°: {max_iterations}")
                break
            
            # ğŸ”„ å…ˆæ£€æŸ¥å¾ªç¯æ¡ä»¶ï¼Œæ¡ä»¶ä¸æ»¡è¶³åˆ™é€€å‡º
            logging.info(f"æ£€æŸ¥whileå¾ªç¯æ¡ä»¶: {expression}")
            logging.info(f"æ£€æŸ¥whileå¾ªç¯æ¡ä»¶: {conditions}")
            # è·å–å½“å‰ CAN æ–‡ä»¶è·¯å¾„å¹¶éšè¯„ä¼°ä¼ å…¥
            current_can_file_path = None
            try:
                source_task_id = step_data.get('source_task_id', '')
                if source_task_id:
                    current_can_file_path = get_current_can_file_path(source_task_id)
                    if current_can_file_path:
                        logging.info(f"ğŸš— æ§åˆ¶æµ while ä½¿ç”¨ CAN æ–‡ä»¶: {current_can_file_path}")
            except Exception:
                current_can_file_path = None

            condition_satisfied = evaluate_control_flow_condition(
                expression, conditions, device, runner_dir, screenshot_count, can_file_path=current_can_file_path
            )
            
            if not condition_satisfied:
                logging.info(f"whileå¾ªç¯æ¡ä»¶ä¸æ»¡è¶³ï¼Œé€€å‡ºå¾ªç¯ (å·²æ‰§è¡Œ{iteration_count}æ¬¡)")
                break
            
            iteration_count += 1
            logging.info(f"whileå¾ªç¯ç¬¬ {iteration_count} æ¬¡è¿­ä»£ (æ¡ä»¶æ»¡è¶³: {expression})")
            
            # æ‰§è¡Œå¾ªç¯ä½“ä¸­çš„æ­¥éª¤ - ä½¿ç”¨ç»Ÿä¸€çš„å­æ­¥éª¤æ‰§è¡Œå‡½æ•°
            for step_index, step in enumerate(loop_body):
                # ä¸ºæ¯æ¬¡è¿­ä»£çš„å­æ­¥éª¤åˆ›å»ºå‰¯æœ¬å¹¶æ›´æ–°æ­¥éª¤ç¼–å·
                iteration_step = step.copy()
                original_step_number = step.get('step_number', step_index)
                iteration_step['step_number'] = f"{original_step_number}_while_iter{iteration_count+1}"
                
                result = execute_sub_action_with_checkpoint(
                    iteration_step, device, runner_dir, screenshot_count, loop_previous_after_screenshot
                )
                
                if result.get('status') == 'error':
                    logging.error(f"whileå¾ªç¯ä½“æ­¥éª¤æ‰§è¡Œå¤±è´¥: {result.get('message', '')}")
                    return result
                
                # æ›´æ–°å¾ªç¯å†…çš„æˆªå›¾ä¼˜åŒ–å‚æ•°
                if result and result.get('screenshots'):
                    loop_previous_after_screenshot = result['screenshots'].get('after_execution')
                
                # æ”¶é›†å·²æ‰§è¡Œçš„å­æ­¥éª¤ï¼ˆåŒ…å«æ‰§è¡Œåçš„çŠ¶æ€ï¼‰
                executed_sub_steps.append(iteration_step)
            
            # çŸ­æš‚ç­‰å¾…ï¼Œé¿å…æ— é™å¾ªç¯
            time.sleep(0.1)
        
        return {
            "status": "success",
            "message": f"whileå¾ªç¯æ‰§è¡Œå®Œæˆï¼Œå…±æ‰§è¡Œ{iteration_count}æ¬¡",
            "iterations": iteration_count,
            "step_name": step_data.get('step_name', 'æœªçŸ¥æ­¥éª¤'),
            "screenshots": {
                "before_execution": None,
                "after_execution": None
            },
            "executed_sub_steps": executed_sub_steps  # ä¿å­˜æ‰€æœ‰å®é™…æ‰§è¡Œçš„å­æ­¥éª¤
        }
        
    except Exception as e:
        logging.error(f"whileæ§åˆ¶æµæ‰§è¡Œå¼‚å¸¸: {e}")
        return {
            "status": "failed",
            "message": f"whileæ§åˆ¶æµæ‰§è¡Œå¼‚å¸¸: {e}",
            "step_name": step_data.get('step_name', 'æœªçŸ¥æ­¥éª¤'),
            "screenshots": {
                "before_execution": None,
                "after_execution": None
            },

        }


def execute_sub_action_with_checkpoint(step_data, device, runner_dir, screenshot_count, previous_after_screenshot=None):
    """
    æ‰§è¡Œæ§åˆ¶æµä¸­çš„å­æ­¥éª¤ - ä½¿ç”¨ç»Ÿä¸€çš„æ£€æŸ¥ç‚¹éªŒè¯å®
    
    ç›´æ¥å¤ç”¨main_execution_loop.j2ä¸­çš„æ£€æŸ¥ç‚¹éªŒè¯é€»è¾‘ï¼Œç¡®ä¿ä¸€è‡´æ€§
    
    Args:
        step_data: æ­¥éª¤æ•°æ®
        device: è®¾å¤‡å¯¹è±¡
        runner_dir: è¿è¡Œç›®å½•
        screenshot_count: æˆªå›¾è®¡æ•°
        previous_after_screenshot: å‰ä¸€æ­¥çš„æ‰§è¡Œåæˆªå›¾è·¯å¾„
    
    Returns:
        Dict: æ‰§è¡Œç»“æœ
    """
    step_number = step_data.get('step_number', 0)
    step_name = step_data.get('step_name', 'æœªçŸ¥å­æ­¥éª¤')
    operation_type = step_data.get('operation_type', 'unknown')
    
    logging.info(f"æ‰§è¡Œæ§åˆ¶æµå­æ­¥éª¤ {step_number}: {step_name} ({operation_type})")
    
    # è®¾ç½®å­æ­¥éª¤ä¸ºè¿è¡ŒçŠ¶æ€
    step_data['status'] = 'running'
    
    try:
        # ==================== å­æ­¥éª¤æ£€æŸ¥ç‚¹éªŒè¯ ====================
        # ä½¿ç”¨ä¸“é—¨çš„å­æ­¥éª¤æ£€æŸ¥ç‚¹éªŒè¯å®
        {{ execute_sub_action_checkpoint_validation(step_data, device, runner_dir, screenshot_count, previous_after_screenshot) }}
        
        if not checkpoint_passed:
            # æ£€æŸ¥ç‚¹éªŒè¯å¤±è´¥ï¼Œè·³è¿‡åŠ¨ä½œæ‰§è¡Œ
            logging.error(f"âŒ å­æ­¥éª¤ {step_number} æ£€æŸ¥ç‚¹éªŒè¯å¤±è´¥: {checkpoint_result.get('detail', 'æœªçŸ¥åŸå› ')}")
            step_data['status'] = 'failed'
            step_data['checkpoint'] = checkpoint_result
            step_data['execution_result'] = {
                "message": f"æ£€æŸ¥ç‚¹éªŒè¯å¤±è´¥ï¼Œè·³è¿‡åŠ¨ä½œæ‰§è¡Œ: {checkpoint_result.get('detail', 'æœªçŸ¥åŸå› ')}",
                "screenshots": {
                    "before_execution": checkpoint_result.get('screenshot_path', ''),
                    "after_execution": ""
                },
                "duration": 0
            }
            
            # è¿”å›å¤±è´¥ç»“æœï¼Œä½†ä¸æ˜¯errorï¼ˆå…è®¸æ§åˆ¶æµç»§ç»­ï¼‰
            return {
                "status": "failed",
                "message": f"å­æ­¥éª¤æ£€æŸ¥ç‚¹éªŒè¯å¤±è´¥: {checkpoint_result.get('detail', 'æœªçŸ¥åŸå› ')}",
                "step_name": step_name,
                "checkpoint_failed": True
            }
        
        # æ£€æŸ¥ç‚¹éªŒè¯é€šè¿‡ï¼Œæ‰§è¡ŒåŠ¨ä½œ
        logging.info(f"å­æ­¥éª¤ {step_number} æ£€æŸ¥ç‚¹éªŒè¯é€šè¿‡ï¼Œæ‰§è¡ŒåŠ¨ä½œ...")
        result = execute_action(step_data, device, runner_dir, screenshot_count, previous_after_screenshot)
        
        # åˆ¤æ–­æ‰§è¡Œç»“æœçŠ¶æ€
        execution_success = result.get('status') == 'success'
        
        # æ›´æ–°å­æ­¥éª¤çŠ¶æ€å’Œæ£€æŸ¥ç‚¹ä¿¡æ¯
        if execution_success:
            step_data['status'] = 'success'
        else:
            step_data['status'] = 'failed'
        
        # æ›´æ–°æ£€æŸ¥ç‚¹ä¿¡æ¯
        step_data['checkpoint'] = checkpoint_result
        
        return result
    
    except Exception as step_error:
        logging.error(f"å­æ­¥éª¤ {step_number} æ‰§è¡Œå¼‚å¸¸: {step_error}")
        step_data['status'] = 'failed'
        step_data['checkpoint'] = {
            "type": step_data.get("checkpoint", {}).get("type", "none"),
            "is_pass": False,
            "detail": f"å­æ­¥éª¤æ‰§è¡Œå¼‚å¸¸: {step_error}",
            "screenshot_path": "",
            "executed_at": ""
        }
        
        return {
            "status": "error",
            "message": f"å­æ­¥éª¤æ‰§è¡Œå¼‚å¸¸: {step_error}",
            "step_name": step_name,
            "exception": True
        }


def evaluate_control_flow_condition(expression, conditions, device=None, runner_dir=None, screenshot_count=0, can_file_path=None):
    """
    è¯„ä¼°æ§åˆ¶æµæ¡ä»¶è¡¨è¾¾å¼
    
    Args:
        expression: è¡¨è¾¾å¼å­—ç¬¦ä¸²
        conditions: æ¡ä»¶åˆ—è¡¨
        device: è®¾å¤‡å¯¹è±¡
        runner_dir: è¿è¡Œç›®å½•
        screenshot_count: æˆªå›¾è®¡æ•°
    
    Returns:
        bool: æ¡ä»¶æ˜¯å¦æ»¡è¶³
    """
    try:
        # evaluate_condition_expressionå‡½æ•°å·²åœ¨base/expression_utils.j2ä¸­å®šä¹‰
        
        # å¦‚æœæœ‰è¡¨è¾¾å¼å’Œæ¡ä»¶ï¼Œä½¿ç”¨è¡¨è¾¾å¼è¯„ä¼°å‡½æ•°
        if expression and conditions:
            logging.info(f"ğŸ” å¼€å§‹è¯„ä¼°æ¡ä»¶è¡¨è¾¾å¼: {expression}")
            logging.info(f"ğŸ“‹ æ¡ä»¶æ•°é‡: {len(conditions)}")
            
            # è¯¦ç»†è®°å½•æ¯ä¸ªæ¡ä»¶çš„ä¿¡æ¯
            for i, condition in enumerate(conditions):
                condition_id = condition.get('id', f'condition_{i+1}')
                target_text = condition.get('target_text', '')
                expect_exists = condition.get('expect_exists', True)
                validation_type = condition.get('validation_type', 'text')
                data_source = condition.get('data_source', 'adb_screenshot')
                timeout = condition.get('timeout', 0)
                wait_time = condition.get('wait_time', 0)
                
                logging.info(f"  ğŸ“ æ¡ä»¶ {i+1} [{condition_id}]:")
                logging.info(f"     - æ£€æµ‹æ–‡æœ¬: '{target_text}'")
                logging.info(f"     - éªŒè¯ç±»å‹: {validation_type}")
                logging.info(f"     - æ•°æ®æ¥æº: {data_source}")
                logging.info(f"     - æœŸæœ›å­˜åœ¨: {expect_exists}")
                logging.info(f"     - è¶…æ—¶æ—¶é—´: {timeout}ç§’")
                logging.info(f"     - ç­‰å¾…æ—¶é—´: {wait_time}ç§’")
            
            logging.info(f"ğŸ”„ è°ƒç”¨æ¡ä»¶è¡¨è¾¾å¼è¯„ä¼°å‡½æ•°...")
            result = evaluate_condition_expression(
                condition=conditions,
                expression=expression,
                can_file_path=can_file_path
            )
            # resultå·²ç»æ˜¯å¸ƒå°”å€¼ï¼Œç›´æ¥ä½¿ç”¨
            logging.info(f"âœ… æ¡ä»¶è¯„ä¼°å®Œæˆï¼Œç»“æœ: {result}")
            return result
        
        # å¦‚æœåªæœ‰æ¡ä»¶åˆ—è¡¨ï¼ŒéªŒè¯æ‰€æœ‰æ¡ä»¶
        elif conditions:
            logging.info(f"éªŒè¯æ¡ä»¶åˆ—è¡¨ï¼Œæ¡ä»¶æ•°é‡: {len(conditions)}")
            for i, condition in enumerate(conditions):
                target_text = condition.get('target_text', '')
                expect_exists = condition.get('expect_exists', True)
                logging.info(f"  éªŒè¯æ¡ä»¶{i+1}: æ£€æµ‹æ–‡æœ¬'{target_text}' expect_exists={expect_exists}")
                
                # é’ˆå¯¹ CAN æ¡ä»¶ä¼ å…¥ CAN æ–‡ä»¶è·¯å¾„
                per_condition_can_file = can_file_path if (condition.get('data_source') == 'can_signal' or (condition.get('validation_type', '').lower() in ('can', 'signal'))) else None

                result = validate_validation_model(
                    validation_model=condition,
                    device=device,
                    runner_dir=runner_dir,
                    screenshot_count=screenshot_count,
                    can_file_path=per_condition_can_file
                )
                
                is_pass = result.get('is_pass', False)
                details = result.get('details', 'æ— è¯¦ç»†ä¿¡æ¯')
                logging.info(f"  æ¡ä»¶{i+1}æ£€æµ‹ç»“æœ: is_pass={is_pass}, è¯¦æƒ…={details}")
                
                if not is_pass:
                    logging.info(f"æ¡ä»¶{i+1}ä¸æ»¡è¶³ï¼Œè¿”å›False")
                    return False
            logging.info("æ‰€æœ‰æ¡ä»¶éƒ½æ»¡è¶³ï¼Œè¿”å›True")
            return True
        
        # å¦‚æœåªæœ‰è¡¨è¾¾å¼å­—ç¬¦ä¸²ï¼Œè¿›è¡Œç®€å•è¯„ä¼°
        elif expression:
            # TODO: å®ç°æ›´å¤æ‚çš„è¡¨è¾¾å¼è§£æ
            # å½“å‰ä½¿ç”¨ç®€å•çš„å­—ç¬¦ä¸²åŒ¹é…
            return bool(expression.strip())
        
        return True
        
    except Exception as e:
        logging.error(f"æ§åˆ¶æµæ¡ä»¶è¡¨è¾¾å¼è¯„ä¼°å¼‚å¸¸: {e}")
        return False


 
 