# Copyright (c) 2023 - 2025 Chair for Design Automation, TUM
# Copyright (c) 2025 Munich Quantum Software Company GmbH
# All rights reserved.
#
# SPDX-License-Identifier: MIT
#
# Licensed under the MIT License

"""Python bindings for superconducting module."""

from enum import Enum
from typing import Any, ClassVar, overload

from mqt.core.ir import QuantumComputation

class Arch(Enum):
    IBMQ_Bogota = ...
    IBMQ_Casablanca = ...
    IBMQ_London = ...
    IBMQ_Tokyo = ...
    IBMQ_Yorktown = ...
    IBM_QX4 = ...
    IBM_QX5 = ...
    Rigetti_Agave = ...
    Rigetti_Aspen = ...

class Architecture:
    """Class representing device/backend information."""
    class Properties:
        """Class representing properties of an architecture."""

        name: str
        num_qubits: int

        def __init__(self) -> None: ...
        def get_calibration_date(self, qubit: int) -> str: ...
        def get_frequency(self, qubit: int) -> float: ...
        def get_readout_error(self, qubit: int) -> float: ...
        def get_single_qubit_error(self, qubit: int, operation: str) -> float: ...
        def get_t1(self, qubit: int) -> float: ...
        def get_t2(self, qubit: int) -> float: ...
        def get_two_qubit_error(self, control: int, target: int, operation: str = ...) -> float: ...
        def json(self) -> dict[str, Any]: ...
        def set_calibration_date(self, qubit: int, calibration_date: str) -> None: ...
        def set_frequency(self, qubit: int, qubit_frequency: float) -> None: ...
        def set_readout_error(self, qubit: int, readout_error_rate: float) -> None: ...
        def set_single_qubit_error(self, qubit: int, operation: str, error_rate: float) -> None: ...
        def set_t1(self, qubit: int, t1: float) -> None: ...
        def set_t2(self, qubit: int, t2: float) -> None: ...
        def set_two_qubit_error(self, control: int, target: int, error_rate: float, operation: str = ...) -> None: ...

    coupling_map: set[tuple[int, int]]
    name: str
    num_qubits: int
    properties: Properties

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, num_qubits: int, coupling_map: set[tuple[int, int]]) -> None: ...
    @overload
    def __init__(self, num_qubits: int, coupling_map: set[tuple[int, int]], properties: Properties) -> None: ...
    @overload
    def load_coupling_map(self, available_architecture: Arch) -> None: ...
    @overload
    def load_coupling_map(self, coupling_map_file: str) -> None: ...
    @overload
    def load_properties(self, properties: Properties) -> None: ...
    @overload
    def load_properties(self, properties: str) -> None: ...

class CircuitInfo:
    """Circuit information."""

    cnots: int
    direction_reverse: int
    gates: int
    layers: int
    total_fidelity: float
    total_log_fidelity: float
    name: str
    qubits: int
    single_qubit_gates: int
    swaps: int

    def __init__(self) -> None: ...

class CommanderGrouping:
    __members__: ClassVar[dict[CommanderGrouping, int]] = ...  # read-only
    fixed2: ClassVar[CommanderGrouping] = ...
    fixed3: ClassVar[CommanderGrouping] = ...
    halves: ClassVar[CommanderGrouping] = ...
    logarithm: ClassVar[CommanderGrouping] = ...

    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    @overload
    def __init__(self, arg0: CommanderGrouping) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Configuration:
    """Class representing the configuration for the mapping."""

    add_measurements_to_mapped_circuit: bool
    add_barriers_between_layers: bool
    heuristic: Heuristic
    commander_grouping: CommanderGrouping
    enable_limits: bool
    encoding: Encoding
    first_lookahead_factor: float
    include_WCNF: bool  # noqa: N815
    initial_layout: InitialLayout
    iterative_bidirectional_routing: bool
    iterative_bidirectional_routing_passes: int
    layering: Layering
    automatic_layer_splits: bool
    automatic_layer_splits_node_limit: int
    early_termination: EarlyTermination
    early_termination_limit: int
    lookahead_heuristic: LookaheadHeuristic
    lookahead_factor: float
    lookaheads: int
    method: Method
    post_mapping_optimizations: bool
    pre_mapping_optimizations: bool
    subgraph: set[int]
    swap_limit: int
    swap_reduction: SwapReduction
    timeout: int
    use_subsets: bool
    verbose: bool
    debug: bool
    data_logging_path: str

    def __init__(self) -> None: ...
    def json(self) -> dict[str, Any]: ...

class EarlyTermination:
    __members__: ClassVar[dict[EarlyTermination, int]] = ...  # read-only
    none: ClassVar[EarlyTermination] = ...
    expanded_nodes: ClassVar[EarlyTermination] = ...
    expanded_nodes_after_first_solution: ClassVar[EarlyTermination] = ...
    expanded_nodes_after_current_optimal_solution: ClassVar[EarlyTermination] = ...
    solution_nodes: ClassVar[EarlyTermination] = ...
    solution_nodes_after_current_optimal_solution: ClassVar[EarlyTermination] = ...

    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    @overload
    def __init__(self, arg0: EarlyTermination) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Encoding(Enum):
    bimander = ...
    commander = ...
    naive = ...

class InitialLayout(Enum):
    dynamic = ...
    identity = ...
    static = ...

class Heuristic(Enum):
    gate_count_max_distance = ...
    gate_count_sum_distance = ...
    gate_count_sum_distance_minus_shared_swaps = ...
    gate_count_max_distance_or_sum_distance_minus_shared_swaps = ...
    fidelity_best_location = ...

class LookaheadHeuristic(Enum):
    none = ...
    gate_count_max_distance = ...
    gate_count_sum_distance = ...

class Layering(Enum):
    disjoint_qubits = ...
    individual_gates = ...
    odd_gates = ...
    qubit_triangle = ...
    disjoint_2q_blocks = ...

class HeuristicBenchmarkInfo:
    expanded_nodes: int
    generated_nodes: int
    seconds_per_node: float
    average_branching_factor: float
    effective_branching_factor: float

    def __init__(self) -> None: ...
    def json(self) -> dict[str, Any]: ...

class LayerHeuristicBenchmarkInfo:
    expanded_nodes: int
    generated_nodes: int
    expanded_nodes_after_first_solution: int
    expanded_nodes_after_optimal_solution: int
    solution_nodes: int
    solution_nodes_after_optimal_solution: int
    solution_depth: int
    seconds_per_node: float
    average_branching_factor: float
    effective_branching_factor: float
    early_termination: bool

    def __init__(self) -> None: ...
    def json(self) -> dict[str, Any]: ...

class MappingResults:
    """Class representing the results of a mapping."""

    configuration: Configuration
    input: CircuitInfo
    mapped_circuit: str
    output: CircuitInfo
    time: float
    timeout: bool
    wcnf: str
    heuristic_benchmark: HeuristicBenchmarkInfo
    layer_heuristic_benchmark: LayerHeuristicBenchmarkInfo

    def __init__(self) -> None: ...
    def json(self) -> dict[str, Any]: ...

class Method(Enum):
    exact = ...
    heuristic = ...

class SwapReduction(Enum):
    coupling_limit = ...
    custom = ...
    increasing = ...
    none = ...

def map(  # noqa: A001
    circ: QuantumComputation, arch: Architecture, config: Configuration
) -> tuple[QuantumComputation, MappingResults]:
    """Map a quantum circuit to an architecture.

    Args:
        circ: The quantum circuit to map.
        arch: The architecture to map to.
        config: The mapping configuration.

    Returns:
        A tuple containing the mapped circuit and the mapping results.
    """
