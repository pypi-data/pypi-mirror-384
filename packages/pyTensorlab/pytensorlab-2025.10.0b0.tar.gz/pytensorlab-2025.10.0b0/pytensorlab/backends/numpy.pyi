from collections.abc import Sequence
from typing import Any, Literal, overload

from numpy.typing import ArrayLike
from scipy.sparse.linalg import LinearOperator

from pytensorlab.typing import ArrayType, MatrixType, VectorType
from pytensorlab.typing.core import MatrixLike, Sequenceable

def cond(A: MatrixType) -> float: ...
@overload
def eig(A: MatrixType, B: MatrixType | None) -> tuple[VectorType, MatrixType]: ...
@overload
def eig(
    A: MatrixType, B: MatrixType | None, left: Literal[True], right: Literal[True]
) -> tuple[VectorType, MatrixType, MatrixType]: ...
@overload
def eig(
    A: MatrixType, B: MatrixType | None, left: Literal[False], right: Literal[True]
) -> tuple[VectorType, MatrixType]: ...
@overload
def eig(
    A: MatrixType, B: MatrixType | None, left: Literal[True], right: Literal[False]
) -> tuple[VectorType, MatrixType]: ...
@overload
def eig(
    A: MatrixType, B: MatrixType | None, left: Literal[False], right: Literal[False]
) -> tuple[VectorType]: ...
def eigh(
    A: MatrixType, B: MatrixType | None = ...
) -> tuple[VectorType, MatrixType]: ...
def eigsh(
    A: MatrixType | LinearOperator, k: int | None
) -> tuple[VectorType, MatrixType]: ...
def eigvalsh(A: MatrixLike) -> VectorType: ...
def svdvals(A: MatrixType) -> VectorType: ...
@overload
def einsum(
    subscripts: str,
    *operands: ArrayType,
    optimize: Literal["greedy"] | Literal["optimal"] | bool
) -> ArrayType: ...
@overload
def einsum(
    *operands: ArrayType | tuple[int, ...],
    optimize: Literal["greedy"] | Literal["optimal"] | bool
) -> ArrayType: ...
def inv(A: MatrixType) -> MatrixType: ...
def iscomplexobj(x: Any) -> bool: ...
@overload
def lstsq(
    A: MatrixType, B: VectorType, rcond: float | None = ...
) -> tuple[VectorType, ArrayType, int, ArrayType]: ...
@overload
def lstsq(
    A: MatrixType, B: MatrixType, rcond: float | None = ...
) -> tuple[MatrixType, ArrayType, int, ArrayType]: ...
@overload
def lstsq(
    A: MatrixType, B: ArrayType, rcond: float | None = ...
) -> tuple[ArrayType, ArrayType, int, ArrayType]: ...
@overload
def norm(A: ArrayType, ord: int | None = ..., *, axis: None = ...) -> float: ...
@overload
def norm(A: ArrayType, ord: int | None = ..., *, axis: int) -> ArrayType: ...
@overload
def norm(A: ArrayType, ord: int, axis: int) -> ArrayType: ...
def norm2(A: VectorType) -> float: ...
def orth(A: MatrixType) -> MatrixType: ...
def pinv(A: MatrixType) -> MatrixType: ...
def pad(
    array: ArrayType,
    pad_width: Sequenceable[int] | Sequenceable[tuple[int, int]],
    mode: str = ...,
) -> ArrayType: ...
@overload
def qr(A: MatrixType) -> MatrixType: ...
@overload
def qr(A: MatrixType, mode: Literal["r"]) -> MatrixType: ...
@overload
def qr(
    A: MatrixType, mode: Literal["reduced", "complete", "raw"]
) -> tuple[MatrixType, MatrixType]: ...
def solve(A: MatrixType, B: MatrixType) -> MatrixType: ...
def solve_hermitian(A: MatrixType, B: MatrixType) -> MatrixType: ...
def svd(
    A: MatrixType, full_matrices: bool = ...
) -> tuple[MatrixType, VectorType, MatrixType]: ...
def tensordot(
    a: ArrayType,
    b: ArrayType,
    axes: int | ArrayLike | Sequence[int] = ...,
) -> ArrayType: ...

__ALL__: list[str]
