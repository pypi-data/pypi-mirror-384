"""Implementations of core operations for dense tensors."""

import math
from collections.abc import Generator, Iterator, Sequence
from typing import Literal

import numpy as np

import pytensorlab.backends.numpy as tlb
from pytensorlab.typing import (
    ArrayType,
    Axis,
    IndexLike,
    MatrixType,
    NumberType,
    Shape,
    VectorType,
)

from ..random.rng import get_rng

# note: np.ndarray has to be used instead of ArrayType, as a class is needed for the
# single dispatch and register decorators.
from ..util.indextricks import normalize_index
from ..util.utils import argsort, noisy
from .core import (
    _mat2tens,
    _mtkronprod_single,
    _mtkrprod_all,
    _mtkrprod_single,
    _tmprod,
    _tvprod,
    frob,
    getitem,
    tens2mat,
)


@_mtkrprod_single.register
def _mtkrprod_single_for_array(
    T: np.ndarray, U: Sequence[MatrixType], axis: int, conjugate: bool = True
) -> MatrixType:
    if conjugate:
        U = [u.conj() for u in U]

    N = T.ndim
    dir = N - 1 if axis == 0 else 0
    U1 = np.multiply.reduce([u for k, u in enumerate(U) if k >= N and k != axis])
    T = tlb.tensordot(U[dir] * U1, T, ((0, dir)))
    if axis < 0:
        axis = N + axis
    if axis >= N:
        axis = N
        T.shape = (*T.shape, 1)

    def _contract(
        T: ArrayType | Generator[ArrayType, None, None] | Iterator[ArrayType],
        U: ArrayType,
        dir: int = 0,
    ) -> Generator[ArrayType, None, None]:
        for slice, vec in zip(T, U.T):
            yield tlb.tensordot(slice, vec, (dir, 0))

    TG = iter(T)
    for i in range(1, axis):
        TG = _contract(TG, U[i], 0)
    for i in range(N - (2 if axis == 0 else 1), axis, -1):
        TG = _contract(TG, U[i], -1)

    return np.stack(list(TG), 1)


@_mtkrprod_all.register
def _mtkrprod_all_for_array(
    T: np.ndarray, U: Sequence[MatrixType], conjugate: bool = True
) -> Sequence[MatrixType]:
    # Implementation notes:
    # ---------------------
    # For each r, a tree is constructed as follows:
    #
    #               N       1
    #             /   \      \
    #          N-1     1      2
    #         /   \     \      \
    #       N-2    1     2      3
    #                 ...
    #      / \   \         \      \
    #     2   1   2   ...   N-1    N-1
    #
    # At each level, the left-most node is binary, splitting the path in
    # right-to-left contractions (left branch) and left-to-right contractions
    # (right branch). Because the procedure starts with a unfolded tensor times
    # matrix product, there is one loose branch (1 - 2 - 3 - ... - N-1) which is
    # not generated by _buildtree (it is added separately in _createfactors).
    #
    # The products corresponding to 1xR factors are handled outside of the tree
    # as well.
    #
    # Generators are used to reduce the memory footprint. _createfactors ensures
    # all factor vectors are computed and put in the right order.
    if conjugate:
        U = [u.conj() for u in U]

    def _buildtree(
        S: ArrayType, U: Sequence[ArrayType], r: int
    ) -> Generator[ArrayType, None, None]:
        """Build computation tree for rank-1 term."""
        # Leaf
        if len(U) == 1:
            yield S
            return

        # Create right branch
        tmp = tlb.tensordot(S, U[-1][:, r], (-1, 0))
        yield from _buildtree(tmp, U[:-1], r)

        # Create left branch
        for u in U[:-1]:
            S = tlb.tensordot(S, u[:, r], (0, 0))
        yield S

    def _createvectors(
        T: ArrayType, U: Sequence[ArrayType]
    ) -> Generator[Generator, None, None]:
        """Create generator of factor vectors."""
        for r, slice in enumerate(T):
            yield _buildtree(slice, U[:-1], r)

    def _createfactors(
        vectors: Sequence[Generator],
    ) -> Generator[MatrixType, None, None]:
        """Create generator of factor matrices."""
        for _ in range(T.ndim - 1):
            yield np.stack([next(v) for v in vectors], 1)

        # Add last factor matrix which is computed outside of the iterator.
        Ulast = _mtkrprod_single(T, U[: T.ndim], T.ndim - 1, conjugate=False)
        yield Ulast * U1

        # Add 1xR modes
        Ulast = np.sum(U[T.ndim - 1] * Ulast, 0, keepdims=True)
        for n in range(T.ndim, len(U)):
            yield Ulast * np.multiply.reduce(
                [U[k] for k in range(T.ndim, len(U)) if k != n], 0
            )

    U1 = np.multiply.reduce(U[T.ndim :], 0)
    T0 = tlb.tensordot(U[T.ndim - 1] * U1, T, ((0, -1)))
    return list(_createfactors(list(_createvectors(T0, U[: T.ndim]))))


@_mtkronprod_single.register
def _mtkronprod_single_for_array(
    T: np.ndarray,
    factors: Sequence[MatrixType],
    axis: int,
    transpose: Literal["T", "H"] | None = None,
) -> MatrixType:
    if transpose == "T":
        factors = [u.T for u in factors]
    elif transpose == "H":
        factors = [u.conj().T for u in factors]

    for i in range(axis):
        T = tlb.tensordot(T, factors[i].conj(), axes=(0, 0))

    for i in range(axis + 1, T.ndim):
        T = tlb.tensordot(T, factors[i].conj(), axes=(1, 0))

    return tens2mat(T, 0)


@frob.register
def _frob_array(T: np.ndarray, squared: bool = False) -> float:
    nrm = tlb.norm(T)
    return nrm**2 if squared else nrm


@noisy.register
def _noisy_array(A: np.ndarray, snr: float, _rng=None) -> ArrayType:
    _rng = get_rng(_rng)

    N = _rng.standard_normal(A.shape)
    if tlb.iscomplexobj(A):
        N = N + 1j * _rng.standard_normal(A.shape)
    return A + tlb.norm(A) / tlb.norm(N) * 10 ** (-snr / 20) * N


@_tmprod.register
def _tmprod_array(
    T: np.ndarray, matrices: Sequence[MatrixType], axes: Axis
) -> ArrayType:
    # Sort key:
    # For minimal flop:  (1 / m.shape[1] - 1 / m.shape[0])
    # For least memory:  (1 / m.shape[1] - 1 / m.shape[0]) * m.shape[0]
    # Soft middle:       (1 / m.shape[1] - 1 / m.shape[0]) * math.sqrt(m.shape[0])
    # 0.5 factor is added to disincentivize middle mode products.
    if not matrices:
        return T
    nrow, ncol = zip(*(m.shape for m in matrices))
    ismiddle_axes = (0 < ax < T.ndim - 1 for ax in axes)
    weight = [
        (1 / nc - 1 / ((ismiddle * 0.5 + 1) * nr)) * math.sqrt(nr)
        for nr, nc, ismiddle in zip(nrow, ncol, ismiddle_axes)
    ]
    order = argsort(weight)
    for i in order:
        T = _tmprod_array_single(T, matrices[i], axes[i])
    return T


def _tmprod_array_single(T: ArrayType, M: MatrixType, axis: int) -> ArrayType:
    prod_shape = (*T.shape[: axis + 1], math.prod(T.shape[axis + 1 :]))
    Tr = T.reshape(prod_shape)
    if M.shape[0] > prod_shape[-1]:
        # Perform permutation to last mode (used by tensordot and einsum).
        Trt = Tr.transpose(*range(axis), axis + 1, axis).reshape(-1, T.shape[axis])
        shape = (*T.shape[:axis], *T.shape[axis + 1 :], M.shape[0])
        perm = (*range(axis), T.ndim - 1, *range(axis, T.ndim - 1))
        return (Trt @ M.T).reshape(shape).transpose(perm)
    else:
        # No permutation.
        shape = (*T.shape[:axis], M.shape[0], *T.shape[axis + 1 :])
        return (M @ Tr).reshape(shape)


@_tvprod.register
def _tvprod_array(
    T: np.ndarray, vectors: Sequence[VectorType], axes: Axis
) -> ArrayType | NumberType:
    matrices: tuple[MatrixType, ...] = tuple(v[np.newaxis, :] for v in vectors)
    res = _tmprod_array(T, matrices, axes)
    res = np.squeeze(res, axes)
    if len(axes) == T.ndim and hasattr(res, "__getitem__"):
        return res.item()
    return res


@_mat2tens.register
def _mat2tens_array(
    matrix: np.ndarray, shape: Shape, row: Axis, col: Axis
) -> ArrayType:
    newshape = tuple(shape[i] for i in tuple(row) + tuple(col))
    order = argsort(tuple(row) + tuple(col))
    return np.transpose(matrix.reshape(newshape), order)


@getitem.register
def _getitem_array(T: np.ndarray, key: IndexLike) -> ArrayType:
    normalized_key = normalize_index(key, T.shape)

    def _generator(
        key, shape
    ) -> Generator[Sequence[bool | int] | ArrayType, None, None]:
        shape_iter = iter(shape)
        for k in key:
            if k is None:
                continue
            s = next(shape_iter)
            yield k if isinstance(k, tuple) else np.arange(s, dtype=int)

    T = T[np.ix_(*tuple(_generator(normalized_key, T.shape)))]  # type:ignore

    # perform normal indexing
    final_key = tuple(
        slice(None) if isinstance(k, tuple) else k for k in normalized_key
    )
    return T[final_key]
