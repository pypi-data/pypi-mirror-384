/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_ALLOCATEAMDGPUSHAREDMEMORY
#define GEN_PASS_DECL_CONVERTBUILTINFUNCTOLLVM
#define GEN_PASS_DECL_CONVERTTRITONAMDGPUTOLLVM
#define GEN_PASS_DECL_OPTIMIZEAMDLDSUSAGE
#define GEN_PASS_DECL_TRITONAMDGPUINSERTINSTRUCTIONSCHEDHINTS
#define GEN_PASS_DECL_TRITONAMDGPULOWERINSTRUCTIONSCHEDHINTS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// AllocateAMDGPUSharedMemory
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ALLOCATEAMDGPUSHAREDMEMORY
std::unique_ptr<::mlir::Pass> createAllocateAMDGPUSharedMemory();
#undef GEN_PASS_DECL_ALLOCATEAMDGPUSHAREDMEMORY
#endif // GEN_PASS_DECL_ALLOCATEAMDGPUSHAREDMEMORY
#ifdef GEN_PASS_DEF_ALLOCATEAMDGPUSHAREDMEMORY

namespace impl {
  std::unique_ptr<::mlir::Pass> createAllocateAMDGPUSharedMemory();
} // namespace impl
namespace impl {

template <typename DerivedT>
class AllocateAMDGPUSharedMemoryBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = AllocateAMDGPUSharedMemoryBase;

  AllocateAMDGPUSharedMemoryBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  AllocateAMDGPUSharedMemoryBase(const AllocateAMDGPUSharedMemoryBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  AllocateAMDGPUSharedMemoryBase& operator=(const AllocateAMDGPUSharedMemoryBase &) = delete;
  AllocateAMDGPUSharedMemoryBase(AllocateAMDGPUSharedMemoryBase &&) = delete;
  AllocateAMDGPUSharedMemoryBase& operator=(AllocateAMDGPUSharedMemoryBase &&) = delete;
  ~AllocateAMDGPUSharedMemoryBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("allocate-amdgpu-shared-memory");
  }
  ::llvm::StringRef getArgument() const override { return "allocate-amdgpu-shared-memory"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Add metadata for shared memory allocation)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AllocateAMDGPUSharedMemory");
  }
  ::llvm::StringRef getName() const override { return "AllocateAMDGPUSharedMemory"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AllocateAMDGPUSharedMemoryBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createAllocateAMDGPUSharedMemory() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createAllocateAMDGPUSharedMemory() {
  return impl::createAllocateAMDGPUSharedMemory();
}
#undef GEN_PASS_DEF_ALLOCATEAMDGPUSHAREDMEMORY
#endif // GEN_PASS_DEF_ALLOCATEAMDGPUSHAREDMEMORY

//===----------------------------------------------------------------------===//
// ConvertBuiltinFuncToLLVM
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTBUILTINFUNCTOLLVM
struct ConvertBuiltinFuncToLLVMOptions {
  bool ftz = true;
};
#undef GEN_PASS_DECL_CONVERTBUILTINFUNCTOLLVM
#endif // GEN_PASS_DECL_CONVERTBUILTINFUNCTOLLVM
#ifdef GEN_PASS_DEF_CONVERTBUILTINFUNCTOLLVM
namespace impl {

template <typename DerivedT>
class ConvertBuiltinFuncToLLVMBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertBuiltinFuncToLLVMBase;

  ConvertBuiltinFuncToLLVMBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertBuiltinFuncToLLVMBase(const ConvertBuiltinFuncToLLVMBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ConvertBuiltinFuncToLLVMBase& operator=(const ConvertBuiltinFuncToLLVMBase &) = delete;
  ConvertBuiltinFuncToLLVMBase(ConvertBuiltinFuncToLLVMBase &&) = delete;
  ConvertBuiltinFuncToLLVMBase& operator=(ConvertBuiltinFuncToLLVMBase &&) = delete;
  ~ConvertBuiltinFuncToLLVMBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-builtin-func-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-builtin-func-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Convert Builtin Func to LLVM)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertBuiltinFuncToLLVM");
  }
  ::llvm::StringRef getName() const override { return "ConvertBuiltinFuncToLLVM"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertBuiltinFuncToLLVMBase<DerivedT>)

  ConvertBuiltinFuncToLLVMBase(ConvertBuiltinFuncToLLVMOptions options) : ConvertBuiltinFuncToLLVMBase() {
    ftz = std::move(options.ftz);
  }
protected:
  ::mlir::Pass::Option<bool> ftz{*this, "ftz", ::llvm::cl::desc(R"PO(flush denorms for math functions)PO"), ::llvm::cl::init(true)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTBUILTINFUNCTOLLVM
#endif // GEN_PASS_DEF_CONVERTBUILTINFUNCTOLLVM

//===----------------------------------------------------------------------===//
// ConvertTritonAMDGPUToLLVM
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTTRITONAMDGPUTOLLVM
struct ConvertTritonAMDGPUToLLVMOptions {
  std::string arch = "";
  bool ftz = true;
};
#undef GEN_PASS_DECL_CONVERTTRITONAMDGPUTOLLVM
#endif // GEN_PASS_DECL_CONVERTTRITONAMDGPUTOLLVM
#ifdef GEN_PASS_DEF_CONVERTTRITONAMDGPUTOLLVM
namespace impl {

template <typename DerivedT>
class ConvertTritonAMDGPUToLLVMBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertTritonAMDGPUToLLVMBase;

  ConvertTritonAMDGPUToLLVMBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertTritonAMDGPUToLLVMBase(const ConvertTritonAMDGPUToLLVMBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ConvertTritonAMDGPUToLLVMBase& operator=(const ConvertTritonAMDGPUToLLVMBase &) = delete;
  ConvertTritonAMDGPUToLLVMBase(ConvertTritonAMDGPUToLLVMBase &&) = delete;
  ConvertTritonAMDGPUToLLVMBase& operator=(ConvertTritonAMDGPUToLLVMBase &&) = delete;
  ~ConvertTritonAMDGPUToLLVMBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-triton-amdgpu-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-triton-amdgpu-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Convert TritonGPU to LLVM)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertTritonAMDGPUToLLVM");
  }
  ::llvm::StringRef getName() const override { return "ConvertTritonAMDGPUToLLVM"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::math::MathDialect>();
    registry.insert<mlir::gpu::GPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::triton::TritonDialect>();
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::ROCDL::ROCDLDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertTritonAMDGPUToLLVMBase<DerivedT>)

  ConvertTritonAMDGPUToLLVMBase(ConvertTritonAMDGPUToLLVMOptions options) : ConvertTritonAMDGPUToLLVMBase() {
    arch = std::move(options.arch);
    ftz = std::move(options.ftz);
  }
protected:
  ::mlir::Pass::Option<std::string> arch{*this, "arch", ::llvm::cl::desc(R"PO(gfx target device architecture, e.g., gfx942)PO"), ::llvm::cl::init("")};
  ::mlir::Pass::Option<bool> ftz{*this, "ftz", ::llvm::cl::desc(R"PO(flush denorms for math functions)PO"), ::llvm::cl::init(true)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTTRITONAMDGPUTOLLVM
#endif // GEN_PASS_DEF_CONVERTTRITONAMDGPUTOLLVM

//===----------------------------------------------------------------------===//
// OptimizeAMDLDSUsage
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_OPTIMIZEAMDLDSUSAGE
struct OptimizeAMDLDSUsageOptions {
  std::string targetArch;
  int customLDSLimit = 0;
};
#undef GEN_PASS_DECL_OPTIMIZEAMDLDSUSAGE
#endif // GEN_PASS_DECL_OPTIMIZEAMDLDSUSAGE
#ifdef GEN_PASS_DEF_OPTIMIZEAMDLDSUSAGE
namespace impl {

template <typename DerivedT>
class OptimizeAMDLDSUsageBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = OptimizeAMDLDSUsageBase;

  OptimizeAMDLDSUsageBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  OptimizeAMDLDSUsageBase(const OptimizeAMDLDSUsageBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  OptimizeAMDLDSUsageBase& operator=(const OptimizeAMDLDSUsageBase &) = delete;
  OptimizeAMDLDSUsageBase(OptimizeAMDLDSUsageBase &&) = delete;
  OptimizeAMDLDSUsageBase& operator=(OptimizeAMDLDSUsageBase &&) = delete;
  ~OptimizeAMDLDSUsageBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("optimize-amd-lds-usage");
  }
  ::llvm::StringRef getArgument() const override { return "optimize-amd-lds-usage"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Minimize LDS usage)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OptimizeAMDLDSUsage");
  }
  ::llvm::StringRef getName() const override { return "OptimizeAMDLDSUsage"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OptimizeAMDLDSUsageBase<DerivedT>)

  OptimizeAMDLDSUsageBase(OptimizeAMDLDSUsageOptions options) : OptimizeAMDLDSUsageBase() {
    targetArch = std::move(options.targetArch);
    customLDSLimit = std::move(options.customLDSLimit);
  }
protected:
  ::mlir::Pass::Option<std::string> targetArch{*this, "target-arch", ::llvm::cl::desc(R"PO(gfx target device architecture, e.g., gfx942)PO")};
  ::mlir::Pass::Option<int> customLDSLimit{*this, "lds-limit", ::llvm::cl::desc(R"PO(custom limit of LDS consumption, if not provided, maximum LDS size is used)PO"), ::llvm::cl::init(0)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_OPTIMIZEAMDLDSUSAGE
#endif // GEN_PASS_DEF_OPTIMIZEAMDLDSUSAGE

//===----------------------------------------------------------------------===//
// TritonAMDGPUInsertInstructionSchedHints
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONAMDGPUINSERTINSTRUCTIONSCHEDHINTS
struct TritonAMDGPUInsertInstructionSchedHintsOptions {
  std::string variant = "none";
};
#undef GEN_PASS_DECL_TRITONAMDGPUINSERTINSTRUCTIONSCHEDHINTS
#endif // GEN_PASS_DECL_TRITONAMDGPUINSERTINSTRUCTIONSCHEDHINTS
#ifdef GEN_PASS_DEF_TRITONAMDGPUINSERTINSTRUCTIONSCHEDHINTS
namespace impl {

template <typename DerivedT>
class TritonAMDGPUInsertInstructionSchedHintsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonAMDGPUInsertInstructionSchedHintsBase;

  TritonAMDGPUInsertInstructionSchedHintsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonAMDGPUInsertInstructionSchedHintsBase(const TritonAMDGPUInsertInstructionSchedHintsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonAMDGPUInsertInstructionSchedHintsBase& operator=(const TritonAMDGPUInsertInstructionSchedHintsBase &) = delete;
  TritonAMDGPUInsertInstructionSchedHintsBase(TritonAMDGPUInsertInstructionSchedHintsBase &&) = delete;
  TritonAMDGPUInsertInstructionSchedHintsBase& operator=(TritonAMDGPUInsertInstructionSchedHintsBase &&) = delete;
  ~TritonAMDGPUInsertInstructionSchedHintsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-amdgpu-insert-instruction-sched-hints");
  }
  ::llvm::StringRef getArgument() const override { return "triton-amdgpu-insert-instruction-sched-hints"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Insert instruction scheduling hints after the dot ops in the main loop)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonAMDGPUInsertInstructionSchedHints");
  }
  ::llvm::StringRef getName() const override { return "TritonAMDGPUInsertInstructionSchedHints"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::triton::amdgpu::TritonAMDGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonAMDGPUInsertInstructionSchedHintsBase<DerivedT>)

  TritonAMDGPUInsertInstructionSchedHintsBase(TritonAMDGPUInsertInstructionSchedHintsOptions options) : TritonAMDGPUInsertInstructionSchedHintsBase() {
    variant = std::move(options.variant);
  }
protected:
  ::mlir::Pass::Option<std::string> variant{*this, "variant", ::llvm::cl::desc(R"PO(instruction scheduling variant)PO"), ::llvm::cl::init("none")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONAMDGPUINSERTINSTRUCTIONSCHEDHINTS
#endif // GEN_PASS_DEF_TRITONAMDGPUINSERTINSTRUCTIONSCHEDHINTS

//===----------------------------------------------------------------------===//
// TritonAMDGPULowerInstructionSchedHints
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONAMDGPULOWERINSTRUCTIONSCHEDHINTS
struct TritonAMDGPULowerInstructionSchedHintsOptions {
  std::string arch = "";
  int32_t numStages = 2;
};
#undef GEN_PASS_DECL_TRITONAMDGPULOWERINSTRUCTIONSCHEDHINTS
#endif // GEN_PASS_DECL_TRITONAMDGPULOWERINSTRUCTIONSCHEDHINTS
#ifdef GEN_PASS_DEF_TRITONAMDGPULOWERINSTRUCTIONSCHEDHINTS
namespace impl {

template <typename DerivedT>
class TritonAMDGPULowerInstructionSchedHintsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonAMDGPULowerInstructionSchedHintsBase;

  TritonAMDGPULowerInstructionSchedHintsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonAMDGPULowerInstructionSchedHintsBase(const TritonAMDGPULowerInstructionSchedHintsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonAMDGPULowerInstructionSchedHintsBase& operator=(const TritonAMDGPULowerInstructionSchedHintsBase &) = delete;
  TritonAMDGPULowerInstructionSchedHintsBase(TritonAMDGPULowerInstructionSchedHintsBase &&) = delete;
  TritonAMDGPULowerInstructionSchedHintsBase& operator=(TritonAMDGPULowerInstructionSchedHintsBase &&) = delete;
  ~TritonAMDGPULowerInstructionSchedHintsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-amdgpu-lower-insert-instruction-sched-hints");
  }
  ::llvm::StringRef getArgument() const override { return "triton-amdgpu-lower-insert-instruction-sched-hints"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lower instruction scheduling hints to LLVM intrinsics)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonAMDGPULowerInstructionSchedHints");
  }
  ::llvm::StringRef getName() const override { return "TritonAMDGPULowerInstructionSchedHints"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::ROCDL::ROCDLDialect>();
    registry.insert<mlir::triton::amdgpu::TritonAMDGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonAMDGPULowerInstructionSchedHintsBase<DerivedT>)

  TritonAMDGPULowerInstructionSchedHintsBase(TritonAMDGPULowerInstructionSchedHintsOptions options) : TritonAMDGPULowerInstructionSchedHintsBase() {
    arch = std::move(options.arch);
    numStages = std::move(options.numStages);
  }
protected:
  ::mlir::Pass::Option<std::string> arch{*this, "arch", ::llvm::cl::desc(R"PO(gfx target device architecture, e.g., gfx942)PO"), ::llvm::cl::init("")};
  ::mlir::Pass::Option<int32_t> numStages{*this, "num_stages", ::llvm::cl::desc(R"PO(number of pipeline stages)PO"), ::llvm::cl::init(2)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONAMDGPULOWERINSTRUCTIONSCHEDHINTS
#endif // GEN_PASS_DEF_TRITONAMDGPULOWERINSTRUCTIONSCHEDHINTS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// AllocateAMDGPUSharedMemory Registration
//===----------------------------------------------------------------------===//

inline void registerAllocateAMDGPUSharedMemory() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createAllocateAMDGPUSharedMemory();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAllocateAMDGPUSharedMemoryPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createAllocateAMDGPUSharedMemory();
  });
}

//===----------------------------------------------------------------------===//
// ConvertBuiltinFuncToLLVM Registration
//===----------------------------------------------------------------------===//

inline void registerConvertBuiltinFuncToLLVM() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::createConvertBuiltinFuncToLLVMPass(/*ftz=*/true);
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertBuiltinFuncToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::createConvertBuiltinFuncToLLVMPass(/*ftz=*/true);
  });
}

//===----------------------------------------------------------------------===//
// ConvertTritonAMDGPUToLLVM Registration
//===----------------------------------------------------------------------===//

inline void registerConvertTritonAMDGPUToLLVM() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::createConvertTritonAMDGPUToLLVMPass("", /*ftz=*/true);
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertTritonAMDGPUToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::createConvertTritonAMDGPUToLLVMPass("", /*ftz=*/true);
  });
}

//===----------------------------------------------------------------------===//
// OptimizeAMDLDSUsage Registration
//===----------------------------------------------------------------------===//

inline void registerOptimizeAMDLDSUsage() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::AMD::createOptimizeLDSUsagePass("");
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerOptimizeAMDLDSUsagePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::AMD::createOptimizeLDSUsagePass("");
  });
}

//===----------------------------------------------------------------------===//
// TritonAMDGPUInsertInstructionSchedHints Registration
//===----------------------------------------------------------------------===//

inline void registerTritonAMDGPUInsertInstructionSchedHints() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::createTritonAMDGPUInsertInstructionSchedHintsPass(/*variant=*/"");
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonAMDGPUInsertInstructionSchedHintsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::createTritonAMDGPUInsertInstructionSchedHintsPass(/*variant=*/"");
  });
}

//===----------------------------------------------------------------------===//
// TritonAMDGPULowerInstructionSchedHints Registration
//===----------------------------------------------------------------------===//

inline void registerTritonAMDGPULowerInstructionSchedHints() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::createTritonAMDGPULowerInstructionSchedHintsPass(/*arch=*/"",/*numStages=*/2);
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonAMDGPULowerInstructionSchedHintsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::createTritonAMDGPULowerInstructionSchedHintsPass(/*arch=*/"",/*numStages=*/2);
  });
}

//===----------------------------------------------------------------------===//
// TritonAMDGPUToLLVM Registration
//===----------------------------------------------------------------------===//

inline void registerTritonAMDGPUToLLVMPasses() {
  registerAllocateAMDGPUSharedMemory();
  registerConvertBuiltinFuncToLLVM();
  registerConvertTritonAMDGPUToLLVM();
  registerOptimizeAMDLDSUsage();
  registerTritonAMDGPUInsertInstructionSchedHints();
  registerTritonAMDGPULowerInstructionSchedHints();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class AllocateAMDGPUSharedMemoryBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = AllocateAMDGPUSharedMemoryBase;

  AllocateAMDGPUSharedMemoryBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  AllocateAMDGPUSharedMemoryBase(const AllocateAMDGPUSharedMemoryBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  AllocateAMDGPUSharedMemoryBase& operator=(const AllocateAMDGPUSharedMemoryBase &) = delete;
  AllocateAMDGPUSharedMemoryBase(AllocateAMDGPUSharedMemoryBase &&) = delete;
  AllocateAMDGPUSharedMemoryBase& operator=(AllocateAMDGPUSharedMemoryBase &&) = delete;
  ~AllocateAMDGPUSharedMemoryBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("allocate-amdgpu-shared-memory");
  }
  ::llvm::StringRef getArgument() const override { return "allocate-amdgpu-shared-memory"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Add metadata for shared memory allocation)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AllocateAMDGPUSharedMemory");
  }
  ::llvm::StringRef getName() const override { return "AllocateAMDGPUSharedMemory"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AllocateAMDGPUSharedMemoryBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertBuiltinFuncToLLVMBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertBuiltinFuncToLLVMBase;

  ConvertBuiltinFuncToLLVMBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertBuiltinFuncToLLVMBase(const ConvertBuiltinFuncToLLVMBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ConvertBuiltinFuncToLLVMBase& operator=(const ConvertBuiltinFuncToLLVMBase &) = delete;
  ConvertBuiltinFuncToLLVMBase(ConvertBuiltinFuncToLLVMBase &&) = delete;
  ConvertBuiltinFuncToLLVMBase& operator=(ConvertBuiltinFuncToLLVMBase &&) = delete;
  ~ConvertBuiltinFuncToLLVMBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-builtin-func-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-builtin-func-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Convert Builtin Func to LLVM)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertBuiltinFuncToLLVM");
  }
  ::llvm::StringRef getName() const override { return "ConvertBuiltinFuncToLLVM"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertBuiltinFuncToLLVMBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> ftz{*this, "ftz", ::llvm::cl::desc(R"PO(flush denorms for math functions)PO"), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class ConvertTritonAMDGPUToLLVMBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertTritonAMDGPUToLLVMBase;

  ConvertTritonAMDGPUToLLVMBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertTritonAMDGPUToLLVMBase(const ConvertTritonAMDGPUToLLVMBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ConvertTritonAMDGPUToLLVMBase& operator=(const ConvertTritonAMDGPUToLLVMBase &) = delete;
  ConvertTritonAMDGPUToLLVMBase(ConvertTritonAMDGPUToLLVMBase &&) = delete;
  ConvertTritonAMDGPUToLLVMBase& operator=(ConvertTritonAMDGPUToLLVMBase &&) = delete;
  ~ConvertTritonAMDGPUToLLVMBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-triton-amdgpu-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-triton-amdgpu-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Convert TritonGPU to LLVM)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertTritonAMDGPUToLLVM");
  }
  ::llvm::StringRef getName() const override { return "ConvertTritonAMDGPUToLLVM"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::math::MathDialect>();
    registry.insert<mlir::gpu::GPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::triton::TritonDialect>();
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::ROCDL::ROCDLDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertTritonAMDGPUToLLVMBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> arch{*this, "arch", ::llvm::cl::desc(R"PO(gfx target device architecture, e.g., gfx942)PO"), ::llvm::cl::init("")};
  ::mlir::Pass::Option<bool> ftz{*this, "ftz", ::llvm::cl::desc(R"PO(flush denorms for math functions)PO"), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class OptimizeAMDLDSUsageBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = OptimizeAMDLDSUsageBase;

  OptimizeAMDLDSUsageBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  OptimizeAMDLDSUsageBase(const OptimizeAMDLDSUsageBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  OptimizeAMDLDSUsageBase& operator=(const OptimizeAMDLDSUsageBase &) = delete;
  OptimizeAMDLDSUsageBase(OptimizeAMDLDSUsageBase &&) = delete;
  OptimizeAMDLDSUsageBase& operator=(OptimizeAMDLDSUsageBase &&) = delete;
  ~OptimizeAMDLDSUsageBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("optimize-amd-lds-usage");
  }
  ::llvm::StringRef getArgument() const override { return "optimize-amd-lds-usage"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Minimize LDS usage)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OptimizeAMDLDSUsage");
  }
  ::llvm::StringRef getName() const override { return "OptimizeAMDLDSUsage"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OptimizeAMDLDSUsageBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> targetArch{*this, "target-arch", ::llvm::cl::desc(R"PO(gfx target device architecture, e.g., gfx942)PO")};
  ::mlir::Pass::Option<int> customLDSLimit{*this, "lds-limit", ::llvm::cl::desc(R"PO(custom limit of LDS consumption, if not provided, maximum LDS size is used)PO"), ::llvm::cl::init(0)};
};

template <typename DerivedT>
class TritonAMDGPUInsertInstructionSchedHintsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonAMDGPUInsertInstructionSchedHintsBase;

  TritonAMDGPUInsertInstructionSchedHintsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonAMDGPUInsertInstructionSchedHintsBase(const TritonAMDGPUInsertInstructionSchedHintsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonAMDGPUInsertInstructionSchedHintsBase& operator=(const TritonAMDGPUInsertInstructionSchedHintsBase &) = delete;
  TritonAMDGPUInsertInstructionSchedHintsBase(TritonAMDGPUInsertInstructionSchedHintsBase &&) = delete;
  TritonAMDGPUInsertInstructionSchedHintsBase& operator=(TritonAMDGPUInsertInstructionSchedHintsBase &&) = delete;
  ~TritonAMDGPUInsertInstructionSchedHintsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-amdgpu-insert-instruction-sched-hints");
  }
  ::llvm::StringRef getArgument() const override { return "triton-amdgpu-insert-instruction-sched-hints"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Insert instruction scheduling hints after the dot ops in the main loop)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonAMDGPUInsertInstructionSchedHints");
  }
  ::llvm::StringRef getName() const override { return "TritonAMDGPUInsertInstructionSchedHints"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::triton::amdgpu::TritonAMDGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonAMDGPUInsertInstructionSchedHintsBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> variant{*this, "variant", ::llvm::cl::desc(R"PO(instruction scheduling variant)PO"), ::llvm::cl::init("none")};
};

template <typename DerivedT>
class TritonAMDGPULowerInstructionSchedHintsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonAMDGPULowerInstructionSchedHintsBase;

  TritonAMDGPULowerInstructionSchedHintsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonAMDGPULowerInstructionSchedHintsBase(const TritonAMDGPULowerInstructionSchedHintsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonAMDGPULowerInstructionSchedHintsBase& operator=(const TritonAMDGPULowerInstructionSchedHintsBase &) = delete;
  TritonAMDGPULowerInstructionSchedHintsBase(TritonAMDGPULowerInstructionSchedHintsBase &&) = delete;
  TritonAMDGPULowerInstructionSchedHintsBase& operator=(TritonAMDGPULowerInstructionSchedHintsBase &&) = delete;
  ~TritonAMDGPULowerInstructionSchedHintsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-amdgpu-lower-insert-instruction-sched-hints");
  }
  ::llvm::StringRef getArgument() const override { return "triton-amdgpu-lower-insert-instruction-sched-hints"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lower instruction scheduling hints to LLVM intrinsics)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonAMDGPULowerInstructionSchedHints");
  }
  ::llvm::StringRef getName() const override { return "TritonAMDGPULowerInstructionSchedHints"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::ROCDL::ROCDLDialect>();
    registry.insert<mlir::triton::amdgpu::TritonAMDGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonAMDGPULowerInstructionSchedHintsBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> arch{*this, "arch", ::llvm::cl::desc(R"PO(gfx target device architecture, e.g., gfx942)PO"), ::llvm::cl::init("")};
  ::mlir::Pass::Option<int32_t> numStages{*this, "num_stages", ::llvm::cl::desc(R"PO(number of pipeline stages)PO"), ::llvm::cl::init(2)};
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
