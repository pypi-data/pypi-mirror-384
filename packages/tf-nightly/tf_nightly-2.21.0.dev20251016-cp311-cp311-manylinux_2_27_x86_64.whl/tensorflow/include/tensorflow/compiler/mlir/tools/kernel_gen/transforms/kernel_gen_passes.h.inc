/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_BROADCASTPROPAGATIONPASS
#define GEN_PASS_DECL_BUFFERREUSEPASS
#define GEN_PASS_DECL_COPYCLEANUPPASS
#define GEN_PASS_DECL_EMBEDTFFRAMEWORKPASS
#define GEN_PASS_DECL_FUNCTOJITINVOCATIONPASS
#define GEN_PASS_DECL_FUSEINNERPARALLELLOOPSPASS
#define GEN_PASS_DECL_GPUKERNELTOBLOBPASS
#define GEN_PASS_DECL_KERNELGENFINALBUFFERIZEPASS
#define GEN_PASS_DECL_LEGALIZETENSORRESHAPEPASS
#define GEN_PASS_DECL_MERGEASSUMINGOPSPASS
#define GEN_PASS_DECL_PARALLELLOOPSTOSEQUENTIAL
#define GEN_PASS_DECL_PROPAGATESHAPEKNOWLEDGETOKERNELS
#define GEN_PASS_DECL_PROPAGATETFABIKNOWLEDGETOKERNELS
#define GEN_PASS_DECL_REWRITETFFRAMEWORKASSERT
#define GEN_PASS_DECL_SHAPESIMPLIFICATIONPASS
#define GEN_PASS_DECL_SHAPETODESCRIPTORSPASS
#define GEN_PASS_DECL_TFKERNELTOLLVMPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// BroadcastPropagationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_BROADCASTPROPAGATIONPASS
std::unique_ptr<::mlir::Pass> createBroadcastPropagationPass();
#undef GEN_PASS_DECL_BROADCASTPROPAGATIONPASS
#endif // GEN_PASS_DECL_BROADCASTPROPAGATIONPASS
#ifdef GEN_PASS_DEF_BROADCASTPROPAGATIONPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createBroadcastPropagationPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class BroadcastPropagationPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = BroadcastPropagationPassBase;

  BroadcastPropagationPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BroadcastPropagationPassBase(const BroadcastPropagationPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  BroadcastPropagationPassBase& operator=(const BroadcastPropagationPassBase &) = delete;
  BroadcastPropagationPassBase(BroadcastPropagationPassBase &&) = delete;
  BroadcastPropagationPassBase& operator=(BroadcastPropagationPassBase &&) = delete;
  ~BroadcastPropagationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-broadcast-propagation");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-broadcast-propagation"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Move dynamic broadcasts up over element-wise operations and broadcast the operands rather than the result. This will eventually allow for larger fusions.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BroadcastPropagationPass");
  }
  ::llvm::StringRef getName() const override { return "BroadcastPropagationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BroadcastPropagationPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createBroadcastPropagationPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createBroadcastPropagationPass() {
  return impl::createBroadcastPropagationPass();
}
#undef GEN_PASS_DEF_BROADCASTPROPAGATIONPASS
#endif // GEN_PASS_DEF_BROADCASTPROPAGATIONPASS

//===----------------------------------------------------------------------===//
// BufferReusePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_BUFFERREUSEPASS
#undef GEN_PASS_DECL_BUFFERREUSEPASS
#endif // GEN_PASS_DECL_BUFFERREUSEPASS
#ifdef GEN_PASS_DEF_BUFFERREUSEPASS
namespace impl {

template <typename DerivedT>
class BufferReusePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = BufferReusePassBase;

  BufferReusePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BufferReusePassBase(const BufferReusePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  BufferReusePassBase& operator=(const BufferReusePassBase &) = delete;
  BufferReusePassBase(BufferReusePassBase &&) = delete;
  BufferReusePassBase& operator=(BufferReusePassBase &&) = delete;
  ~BufferReusePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("buffer-reuse");
  }
  ::llvm::StringRef getArgument() const override { return "buffer-reuse"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass to find and annotate candidates for buffer reuse.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BufferReusePass");
  }
  ::llvm::StringRef getName() const override { return "BufferReusePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BufferReusePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_BUFFERREUSEPASS
#endif // GEN_PASS_DEF_BUFFERREUSEPASS

//===----------------------------------------------------------------------===//
// CopyCleanupPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_COPYCLEANUPPASS
#undef GEN_PASS_DECL_COPYCLEANUPPASS
#endif // GEN_PASS_DECL_COPYCLEANUPPASS
#ifdef GEN_PASS_DEF_COPYCLEANUPPASS
namespace impl {

template <typename DerivedT>
class CopyCleanupPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = CopyCleanupPassBase;

  CopyCleanupPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CopyCleanupPassBase(const CopyCleanupPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  CopyCleanupPassBase& operator=(const CopyCleanupPassBase &) = delete;
  CopyCleanupPassBase(CopyCleanupPassBase &&) = delete;
  CopyCleanupPassBase& operator=(CopyCleanupPassBase &&) = delete;
  ~CopyCleanupPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("copy-cleanup");
  }
  ::llvm::StringRef getArgument() const override { return "copy-cleanup"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass to remove copies which are consumed by a GenericOp.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CopyCleanupPass");
  }
  ::llvm::StringRef getName() const override { return "CopyCleanupPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CopyCleanupPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_COPYCLEANUPPASS
#endif // GEN_PASS_DEF_COPYCLEANUPPASS

//===----------------------------------------------------------------------===//
// EmbedTFFrameworkPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EMBEDTFFRAMEWORKPASS
#undef GEN_PASS_DECL_EMBEDTFFRAMEWORKPASS
#endif // GEN_PASS_DECL_EMBEDTFFRAMEWORKPASS
#ifdef GEN_PASS_DEF_EMBEDTFFRAMEWORKPASS
namespace impl {

template <typename DerivedT>
class EmbedTFFrameworkPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = EmbedTFFrameworkPassBase;

  EmbedTFFrameworkPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  EmbedTFFrameworkPassBase(const EmbedTFFrameworkPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  EmbedTFFrameworkPassBase& operator=(const EmbedTFFrameworkPassBase &) = delete;
  EmbedTFFrameworkPassBase(EmbedTFFrameworkPassBase &&) = delete;
  EmbedTFFrameworkPassBase& operator=(EmbedTFFrameworkPassBase &&) = delete;
  ~EmbedTFFrameworkPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("embed-tf-framework");
  }
  ::llvm::StringRef getArgument() const override { return "embed-tf-framework"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass to embed TF Framework for allocation and assertions,)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("EmbedTFFrameworkPass");
  }
  ::llvm::StringRef getName() const override { return "EmbedTFFrameworkPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(EmbedTFFrameworkPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EMBEDTFFRAMEWORKPASS
#endif // GEN_PASS_DEF_EMBEDTFFRAMEWORKPASS

//===----------------------------------------------------------------------===//
// FuncToJITInvocationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FUNCTOJITINVOCATIONPASS
struct FuncToJITInvocationPassOptions {
  ::llvm::SmallVector<int64_t> tile_sizes_;
  ::llvm::SmallVector<int64_t> unroll_factors_;
  bool enable_ftz_;
  bool index_64bit_;
  bool cpu_codegen_;
  bool jit_i64_indexed_for_large_tensors_ = false;
};
#undef GEN_PASS_DECL_FUNCTOJITINVOCATIONPASS
#endif // GEN_PASS_DECL_FUNCTOJITINVOCATIONPASS
#ifdef GEN_PASS_DEF_FUNCTOJITINVOCATIONPASS
namespace impl {

template <typename DerivedT>
class FuncToJITInvocationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FuncToJITInvocationPassBase;

  FuncToJITInvocationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FuncToJITInvocationPassBase(const FuncToJITInvocationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  FuncToJITInvocationPassBase& operator=(const FuncToJITInvocationPassBase &) = delete;
  FuncToJITInvocationPassBase(FuncToJITInvocationPassBase &&) = delete;
  FuncToJITInvocationPassBase& operator=(FuncToJITInvocationPassBase &&) = delete;
  ~FuncToJITInvocationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("func-to-jit-invocation");
  }
  ::llvm::StringRef getArgument() const override { return "func-to-jit-invocation"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass to rewrite a function to JIT invocations)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FuncToJITInvocationPass");
  }
  ::llvm::StringRef getName() const override { return "FuncToJITInvocationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::kernel_gen::tf_framework::TFFrameworkDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<shape::ShapeDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FuncToJITInvocationPassBase<DerivedT>)

  FuncToJITInvocationPassBase(FuncToJITInvocationPassOptions options) : FuncToJITInvocationPassBase() {
    tile_sizes_ = std::move(options.tile_sizes_);
    unroll_factors_ = std::move(options.unroll_factors_);
    enable_ftz_ = std::move(options.enable_ftz_);
    index_64bit_ = std::move(options.index_64bit_);
    cpu_codegen_ = std::move(options.cpu_codegen_);
    jit_i64_indexed_for_large_tensors_ = std::move(options.jit_i64_indexed_for_large_tensors_);
  }
protected:
  ::mlir::Pass::ListOption<int64_t> tile_sizes_{*this, "tile-sizes", ::llvm::cl::desc(R"PO(Tiling sizes)PO"), llvm::cl::ZeroOrMore};
  ::mlir::Pass::ListOption<int64_t> unroll_factors_{*this, "unroll-factors", ::llvm::cl::desc(R"PO(Unrolling in each tile dimension)PO"), llvm::cl::ZeroOrMore};
  ::mlir::Pass::Option<bool> enable_ftz_{*this, "enable-ftz", ::llvm::cl::desc(R"PO(Enable the denormal flush to zero mode when generating code)PO")};
  ::mlir::Pass::Option<bool> index_64bit_{*this, "index_64bit", ::llvm::cl::desc(R"PO(Enable the 64 bit indexing for GPU kernels)PO")};
  ::mlir::Pass::Option<bool> cpu_codegen_{*this, "cpu-codegen", ::llvm::cl::desc(R"PO(CPU codegen (false implies GPU))PO")};
  ::mlir::Pass::Option<bool> jit_i64_indexed_for_large_tensors_{*this, "jit_i64_indexed_for_large_tensors", ::llvm::cl::desc(R"PO(Enable JIT compilation of i64-indexed kernels for large input tensors.)PO"), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_FUNCTOJITINVOCATIONPASS
#endif // GEN_PASS_DEF_FUNCTOJITINVOCATIONPASS

//===----------------------------------------------------------------------===//
// FuseInnerParallelLoopsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FUSEINNERPARALLELLOOPSPASS
#undef GEN_PASS_DECL_FUSEINNERPARALLELLOOPSPASS
#endif // GEN_PASS_DECL_FUSEINNERPARALLELLOOPSPASS
#ifdef GEN_PASS_DEF_FUSEINNERPARALLELLOOPSPASS
namespace impl {

template <typename DerivedT>
class FuseInnerParallelLoopsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FuseInnerParallelLoopsPassBase;

  FuseInnerParallelLoopsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FuseInnerParallelLoopsPassBase(const FuseInnerParallelLoopsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  FuseInnerParallelLoopsPassBase& operator=(const FuseInnerParallelLoopsPassBase &) = delete;
  FuseInnerParallelLoopsPassBase(FuseInnerParallelLoopsPassBase &&) = delete;
  FuseInnerParallelLoopsPassBase& operator=(FuseInnerParallelLoopsPassBase &&) = delete;
  ~FuseInnerParallelLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("fuse-inner-parallel-loops");
  }
  ::llvm::StringRef getArgument() const override { return "fuse-inner-parallel-loops"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Limited pass to forward stores to loads.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FuseInnerParallelLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "FuseInnerParallelLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FuseInnerParallelLoopsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_FUSEINNERPARALLELLOOPSPASS
#endif // GEN_PASS_DEF_FUSEINNERPARALLELLOOPSPASS

//===----------------------------------------------------------------------===//
// GpuKernelToBlobPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GPUKERNELTOBLOBPASS
struct GpuKernelToBlobPassOptions {
  std::string blob_annotation_ = "gpu.binary_blob";
  ::llvm::SmallVector<std::string> architectures_;
  bool generate_fatbin_ = true;
  bool print_ptx_ = false;
  bool print_llvmir_ = false;
};
#undef GEN_PASS_DECL_GPUKERNELTOBLOBPASS
#endif // GEN_PASS_DECL_GPUKERNELTOBLOBPASS
#ifdef GEN_PASS_DEF_GPUKERNELTOBLOBPASS
namespace impl {

template <typename DerivedT>
class GpuKernelToBlobPassBase : public ::mlir::OperationPass<gpu::GPUModuleOp> {
public:
  using Base = GpuKernelToBlobPassBase;

  GpuKernelToBlobPassBase() : ::mlir::OperationPass<gpu::GPUModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  GpuKernelToBlobPassBase(const GpuKernelToBlobPassBase &other) : ::mlir::OperationPass<gpu::GPUModuleOp>(other) {}
  GpuKernelToBlobPassBase& operator=(const GpuKernelToBlobPassBase &) = delete;
  GpuKernelToBlobPassBase(GpuKernelToBlobPassBase &&) = delete;
  GpuKernelToBlobPassBase& operator=(GpuKernelToBlobPassBase &&) = delete;
  ~GpuKernelToBlobPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gpu-kernel-to-blob");
  }
  ::llvm::StringRef getArgument() const override { return "gpu-kernel-to-blob"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass to annotate GPU Module with its PTX)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GpuKernelToBlobPass");
  }
  ::llvm::StringRef getName() const override { return "GpuKernelToBlobPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GpuKernelToBlobPassBase<DerivedT>)

  GpuKernelToBlobPassBase(GpuKernelToBlobPassOptions options) : GpuKernelToBlobPassBase() {
    blob_annotation_ = std::move(options.blob_annotation_);
    architectures_ = std::move(options.architectures_);
    generate_fatbin_ = std::move(options.generate_fatbin_);
    print_ptx_ = std::move(options.print_ptx_);
    print_llvmir_ = std::move(options.print_llvmir_);
  }
protected:
  ::mlir::Pass::Option<std::string> blob_annotation_{*this, "blob-annotation", ::llvm::cl::desc(R"PO(Blob attribute name)PO"), ::llvm::cl::init("gpu.binary_blob")};
  ::mlir::Pass::ListOption<std::string> architectures_{*this, "arch", ::llvm::cl::desc(R"PO(GPU architectures)PO")};
  ::mlir::Pass::Option<bool> generate_fatbin_{*this, "generate-fatbin", ::llvm::cl::desc(R"PO(Bundle machine code for the different architectures in one fatbin.)PO"), ::llvm::cl::init(true)};
  ::mlir::Pass::Option<bool> print_ptx_{*this, "print-ptx", ::llvm::cl::desc(R"PO(Print generated PTX code per target architecture.)PO"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> print_llvmir_{*this, "print-llvmir", ::llvm::cl::desc(R"PO(Print llvm ir when lowering code per target architecture.)PO"), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_GPUKERNELTOBLOBPASS
#endif // GEN_PASS_DEF_GPUKERNELTOBLOBPASS

//===----------------------------------------------------------------------===//
// KernelgenFinalBufferizePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_KERNELGENFINALBUFFERIZEPASS
#undef GEN_PASS_DECL_KERNELGENFINALBUFFERIZEPASS
#endif // GEN_PASS_DECL_KERNELGENFINALBUFFERIZEPASS
#ifdef GEN_PASS_DEF_KERNELGENFINALBUFFERIZEPASS
namespace impl {

template <typename DerivedT>
class KernelgenFinalBufferizePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = KernelgenFinalBufferizePassBase;

  KernelgenFinalBufferizePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  KernelgenFinalBufferizePassBase(const KernelgenFinalBufferizePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  KernelgenFinalBufferizePassBase& operator=(const KernelgenFinalBufferizePassBase &) = delete;
  KernelgenFinalBufferizePassBase(KernelgenFinalBufferizePassBase &&) = delete;
  KernelgenFinalBufferizePassBase& operator=(KernelgenFinalBufferizePassBase &&) = delete;
  ~KernelgenFinalBufferizePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("kernelgen-final-bufferize");
  }
  ::llvm::StringRef getArgument() const override { return "kernelgen-final-bufferize"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass to transform late operations on values to buffer based ones.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("KernelgenFinalBufferizePass");
  }
  ::llvm::StringRef getName() const override { return "KernelgenFinalBufferizePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(KernelgenFinalBufferizePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_KERNELGENFINALBUFFERIZEPASS
#endif // GEN_PASS_DEF_KERNELGENFINALBUFFERIZEPASS

//===----------------------------------------------------------------------===//
// LegalizeTensorReshapePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LEGALIZETENSORRESHAPEPASS
std::unique_ptr<::mlir::Pass> createLegalizeTensorReshapePass();
#undef GEN_PASS_DECL_LEGALIZETENSORRESHAPEPASS
#endif // GEN_PASS_DECL_LEGALIZETENSORRESHAPEPASS
#ifdef GEN_PASS_DEF_LEGALIZETENSORRESHAPEPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createLegalizeTensorReshapePass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class LegalizeTensorReshapePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LegalizeTensorReshapePassBase;

  LegalizeTensorReshapePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeTensorReshapePassBase(const LegalizeTensorReshapePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  LegalizeTensorReshapePassBase& operator=(const LegalizeTensorReshapePassBase &) = delete;
  LegalizeTensorReshapePassBase(LegalizeTensorReshapePassBase &&) = delete;
  LegalizeTensorReshapePassBase& operator=(LegalizeTensorReshapePassBase &&) = delete;
  ~LegalizeTensorReshapePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("legalize-tensor-reshape");
  }
  ::llvm::StringRef getArgument() const override { return "legalize-tensor-reshape"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Legalize tensor.reshape to mhlo.dynamic_reshape)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeTensorReshapePass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeTensorReshapePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeTensorReshapePassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createLegalizeTensorReshapePass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createLegalizeTensorReshapePass() {
  return impl::createLegalizeTensorReshapePass();
}
#undef GEN_PASS_DEF_LEGALIZETENSORRESHAPEPASS
#endif // GEN_PASS_DEF_LEGALIZETENSORRESHAPEPASS

//===----------------------------------------------------------------------===//
// MergeAssumingOpsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MERGEASSUMINGOPSPASS
std::unique_ptr<::mlir::Pass> createMergeAssumingOpsPass();
#undef GEN_PASS_DECL_MERGEASSUMINGOPSPASS
#endif // GEN_PASS_DECL_MERGEASSUMINGOPSPASS
#ifdef GEN_PASS_DEF_MERGEASSUMINGOPSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createMergeAssumingOpsPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class MergeAssumingOpsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = MergeAssumingOpsPassBase;

  MergeAssumingOpsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MergeAssumingOpsPassBase(const MergeAssumingOpsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  MergeAssumingOpsPassBase& operator=(const MergeAssumingOpsPassBase &) = delete;
  MergeAssumingOpsPassBase(MergeAssumingOpsPassBase &&) = delete;
  MergeAssumingOpsPassBase& operator=(MergeAssumingOpsPassBase &&) = delete;
  ~MergeAssumingOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-merge-assuming-ops");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-merge-assuming-ops"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Prepare moving dynamic broadcasts up over element-wise operations and broadcast the operands rather than the result. This will eventually allow for larger fusions.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MergeAssumingOpsPass");
  }
  ::llvm::StringRef getName() const override { return "MergeAssumingOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MergeAssumingOpsPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createMergeAssumingOpsPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createMergeAssumingOpsPass() {
  return impl::createMergeAssumingOpsPass();
}
#undef GEN_PASS_DEF_MERGEASSUMINGOPSPASS
#endif // GEN_PASS_DEF_MERGEASSUMINGOPSPASS

//===----------------------------------------------------------------------===//
// ParallelLoopsToSequential
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PARALLELLOOPSTOSEQUENTIAL
#undef GEN_PASS_DECL_PARALLELLOOPSTOSEQUENTIAL
#endif // GEN_PASS_DECL_PARALLELLOOPSTOSEQUENTIAL
#ifdef GEN_PASS_DEF_PARALLELLOOPSTOSEQUENTIAL
namespace impl {

template <typename DerivedT>
class ParallelLoopsToSequentialBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ParallelLoopsToSequentialBase;

  ParallelLoopsToSequentialBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ParallelLoopsToSequentialBase(const ParallelLoopsToSequentialBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ParallelLoopsToSequentialBase& operator=(const ParallelLoopsToSequentialBase &) = delete;
  ParallelLoopsToSequentialBase(ParallelLoopsToSequentialBase &&) = delete;
  ParallelLoopsToSequentialBase& operator=(ParallelLoopsToSequentialBase &&) = delete;
  ~ParallelLoopsToSequentialBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("parallel-loops-to-sequential");
  }
  ::llvm::StringRef getArgument() const override { return "parallel-loops-to-sequential"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass to convert scf::ParallelOp to scf::ForOp)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ParallelLoopsToSequential");
  }
  ::llvm::StringRef getName() const override { return "ParallelLoopsToSequential"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ParallelLoopsToSequentialBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PARALLELLOOPSTOSEQUENTIAL
#endif // GEN_PASS_DEF_PARALLELLOOPSTOSEQUENTIAL

//===----------------------------------------------------------------------===//
// PropagateShapeKnowledgeToKernels
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PROPAGATESHAPEKNOWLEDGETOKERNELS
#undef GEN_PASS_DECL_PROPAGATESHAPEKNOWLEDGETOKERNELS
#endif // GEN_PASS_DECL_PROPAGATESHAPEKNOWLEDGETOKERNELS
#ifdef GEN_PASS_DEF_PROPAGATESHAPEKNOWLEDGETOKERNELS
namespace impl {

template <typename DerivedT>
class PropagateShapeKnowledgeToKernelsBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = PropagateShapeKnowledgeToKernelsBase;

  PropagateShapeKnowledgeToKernelsBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  PropagateShapeKnowledgeToKernelsBase(const PropagateShapeKnowledgeToKernelsBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  PropagateShapeKnowledgeToKernelsBase& operator=(const PropagateShapeKnowledgeToKernelsBase &) = delete;
  PropagateShapeKnowledgeToKernelsBase(PropagateShapeKnowledgeToKernelsBase &&) = delete;
  PropagateShapeKnowledgeToKernelsBase& operator=(PropagateShapeKnowledgeToKernelsBase &&) = delete;
  ~PropagateShapeKnowledgeToKernelsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("propagate-shape-knowledge-to-kernels");
  }
  ::llvm::StringRef getArgument() const override { return "propagate-shape-knowledge-to-kernels"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass to propagate shape information into kernels)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PropagateShapeKnowledgeToKernels");
  }
  ::llvm::StringRef getName() const override { return "PropagateShapeKnowledgeToKernels"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PropagateShapeKnowledgeToKernelsBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PROPAGATESHAPEKNOWLEDGETOKERNELS
#endif // GEN_PASS_DEF_PROPAGATESHAPEKNOWLEDGETOKERNELS

//===----------------------------------------------------------------------===//
// PropagateTfAbiKnowledgeToKernels
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PROPAGATETFABIKNOWLEDGETOKERNELS
#undef GEN_PASS_DECL_PROPAGATETFABIKNOWLEDGETOKERNELS
#endif // GEN_PASS_DECL_PROPAGATETFABIKNOWLEDGETOKERNELS
#ifdef GEN_PASS_DEF_PROPAGATETFABIKNOWLEDGETOKERNELS
namespace impl {

template <typename DerivedT>
class PropagateTfAbiKnowledgeToKernelsBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = PropagateTfAbiKnowledgeToKernelsBase;

  PropagateTfAbiKnowledgeToKernelsBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  PropagateTfAbiKnowledgeToKernelsBase(const PropagateTfAbiKnowledgeToKernelsBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  PropagateTfAbiKnowledgeToKernelsBase& operator=(const PropagateTfAbiKnowledgeToKernelsBase &) = delete;
  PropagateTfAbiKnowledgeToKernelsBase(PropagateTfAbiKnowledgeToKernelsBase &&) = delete;
  PropagateTfAbiKnowledgeToKernelsBase& operator=(PropagateTfAbiKnowledgeToKernelsBase &&) = delete;
  ~PropagateTfAbiKnowledgeToKernelsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("propagate-tf-abi-knowledge-to-kernels");
  }
  ::llvm::StringRef getArgument() const override { return "propagate-tf-abi-knowledge-to-kernels"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass to propagate tensorflow ABI knowledge to kernels)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PropagateTfAbiKnowledgeToKernels");
  }
  ::llvm::StringRef getName() const override { return "PropagateTfAbiKnowledgeToKernels"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PropagateTfAbiKnowledgeToKernelsBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PROPAGATETFABIKNOWLEDGETOKERNELS
#endif // GEN_PASS_DEF_PROPAGATETFABIKNOWLEDGETOKERNELS

//===----------------------------------------------------------------------===//
// RewriteTFFrameworkAssert
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REWRITETFFRAMEWORKASSERT
#undef GEN_PASS_DECL_REWRITETFFRAMEWORKASSERT
#endif // GEN_PASS_DECL_REWRITETFFRAMEWORKASSERT
#ifdef GEN_PASS_DEF_REWRITETFFRAMEWORKASSERT
namespace impl {

template <typename DerivedT>
class RewriteTFFrameworkAssertBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = RewriteTFFrameworkAssertBase;

  RewriteTFFrameworkAssertBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteTFFrameworkAssertBase(const RewriteTFFrameworkAssertBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  RewriteTFFrameworkAssertBase& operator=(const RewriteTFFrameworkAssertBase &) = delete;
  RewriteTFFrameworkAssertBase(RewriteTFFrameworkAssertBase &&) = delete;
  RewriteTFFrameworkAssertBase& operator=(RewriteTFFrameworkAssertBase &&) = delete;
  ~RewriteTFFrameworkAssertBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("rewrite-tf-framework-assert");
  }
  ::llvm::StringRef getArgument() const override { return "rewrite-tf-framework-assert"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass to rewrite TFAssertOps to CondBranchOp)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteTFFrameworkAssert");
  }
  ::llvm::StringRef getName() const override { return "RewriteTFFrameworkAssert"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<cf::ControlFlowDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteTFFrameworkAssertBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REWRITETFFRAMEWORKASSERT
#endif // GEN_PASS_DEF_REWRITETFFRAMEWORKASSERT

//===----------------------------------------------------------------------===//
// ShapeSimplificationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SHAPESIMPLIFICATIONPASS
std::unique_ptr<::mlir::Pass> createShapeSimplificationPass();
#undef GEN_PASS_DECL_SHAPESIMPLIFICATIONPASS
#endif // GEN_PASS_DECL_SHAPESIMPLIFICATIONPASS
#ifdef GEN_PASS_DEF_SHAPESIMPLIFICATIONPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createShapeSimplificationPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ShapeSimplificationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ShapeSimplificationPassBase;

  ShapeSimplificationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ShapeSimplificationPassBase(const ShapeSimplificationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ShapeSimplificationPassBase& operator=(const ShapeSimplificationPassBase &) = delete;
  ShapeSimplificationPassBase(ShapeSimplificationPassBase &&) = delete;
  ShapeSimplificationPassBase& operator=(ShapeSimplificationPassBase &&) = delete;
  ~ShapeSimplificationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("shape-simplification");
  }
  ::llvm::StringRef getArgument() const override { return "shape-simplification"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Simplify shape ops)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ShapeSimplificationPass");
  }
  ::llvm::StringRef getName() const override { return "ShapeSimplificationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ShapeSimplificationPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createShapeSimplificationPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createShapeSimplificationPass() {
  return impl::createShapeSimplificationPass();
}
#undef GEN_PASS_DEF_SHAPESIMPLIFICATIONPASS
#endif // GEN_PASS_DEF_SHAPESIMPLIFICATIONPASS

//===----------------------------------------------------------------------===//
// ShapeToDescriptorsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SHAPETODESCRIPTORSPASS
#undef GEN_PASS_DECL_SHAPETODESCRIPTORSPASS
#endif // GEN_PASS_DECL_SHAPETODESCRIPTORSPASS
#ifdef GEN_PASS_DEF_SHAPETODESCRIPTORSPASS
namespace impl {

template <typename DerivedT>
class ShapeToDescriptorsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ShapeToDescriptorsPassBase;

  ShapeToDescriptorsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ShapeToDescriptorsPassBase(const ShapeToDescriptorsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ShapeToDescriptorsPassBase& operator=(const ShapeToDescriptorsPassBase &) = delete;
  ShapeToDescriptorsPassBase(ShapeToDescriptorsPassBase &&) = delete;
  ShapeToDescriptorsPassBase& operator=(ShapeToDescriptorsPassBase &&) = delete;
  ~ShapeToDescriptorsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("shape-to-descriptors");
  }
  ::llvm::StringRef getArgument() const override { return "shape-to-descriptors"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass to transform shape computations to descriptors)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ShapeToDescriptorsPass");
  }
  ::llvm::StringRef getName() const override { return "ShapeToDescriptorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ShapeToDescriptorsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SHAPETODESCRIPTORSPASS
#endif // GEN_PASS_DEF_SHAPETODESCRIPTORSPASS

//===----------------------------------------------------------------------===//
// TFKernelToLLVMPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TFKERNELTOLLVMPASS
struct TFKernelToLLVMPassOptions {
  std::string blob_annotation_ = "gpu.binary_blob";
};
#undef GEN_PASS_DECL_TFKERNELTOLLVMPASS
#endif // GEN_PASS_DECL_TFKERNELTOLLVMPASS
#ifdef GEN_PASS_DEF_TFKERNELTOLLVMPASS
namespace impl {

template <typename DerivedT>
class TFKernelToLLVMPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TFKernelToLLVMPassBase;

  TFKernelToLLVMPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TFKernelToLLVMPassBase(const TFKernelToLLVMPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TFKernelToLLVMPassBase& operator=(const TFKernelToLLVMPassBase &) = delete;
  TFKernelToLLVMPassBase(TFKernelToLLVMPassBase &&) = delete;
  TFKernelToLLVMPassBase& operator=(TFKernelToLLVMPassBase &&) = delete;
  ~TFKernelToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-kernel-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "tf-kernel-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass for applying LLVM legalization patterns.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TFKernelToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "TFKernelToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TFKernelToLLVMPassBase<DerivedT>)

  TFKernelToLLVMPassBase(TFKernelToLLVMPassOptions options) : TFKernelToLLVMPassBase() {
    blob_annotation_ = std::move(options.blob_annotation_);
  }
protected:
  ::mlir::Pass::Option<std::string> blob_annotation_{*this, "blob-annotation", ::llvm::cl::desc(R"PO(Blob attribute name)PO"), ::llvm::cl::init("gpu.binary_blob")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TFKERNELTOLLVMPASS
#endif // GEN_PASS_DEF_TFKERNELTOLLVMPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// BroadcastPropagationPass Registration
//===----------------------------------------------------------------------===//

inline void registerBroadcastPropagationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createBroadcastPropagationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerBroadcastPropagationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createBroadcastPropagationPass();
  });
}

//===----------------------------------------------------------------------===//
// BufferReusePass Registration
//===----------------------------------------------------------------------===//

inline void registerBufferReusePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateBufferReusePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerBufferReusePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateBufferReusePass();
  });
}

//===----------------------------------------------------------------------===//
// CopyCleanupPass Registration
//===----------------------------------------------------------------------===//

inline void registerCopyCleanupPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateCopyCleanupPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerCopyCleanupPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateCopyCleanupPass();
  });
}

//===----------------------------------------------------------------------===//
// EmbedTFFrameworkPass Registration
//===----------------------------------------------------------------------===//

inline void registerEmbedTFFrameworkPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_framework::CreateEmbedTFFrameworkPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerEmbedTFFrameworkPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_framework::CreateEmbedTFFrameworkPass();
  });
}

//===----------------------------------------------------------------------===//
// FuncToJITInvocationPass Registration
//===----------------------------------------------------------------------===//

inline void registerFuncToJITInvocationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateFuncToJITInvocationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFuncToJITInvocationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateFuncToJITInvocationPass();
  });
}

//===----------------------------------------------------------------------===//
// FuseInnerParallelLoopsPass Registration
//===----------------------------------------------------------------------===//

inline void registerFuseInnerParallelLoopsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateFuseInnerParallelLoopsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFuseInnerParallelLoopsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateFuseInnerParallelLoopsPass();
  });
}

//===----------------------------------------------------------------------===//
// GpuKernelToBlobPass Registration
//===----------------------------------------------------------------------===//

inline void registerGpuKernelToBlobPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateGpuKernelToBlobPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGpuKernelToBlobPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateGpuKernelToBlobPass();
  });
}

//===----------------------------------------------------------------------===//
// KernelgenFinalBufferizePass Registration
//===----------------------------------------------------------------------===//

inline void registerKernelgenFinalBufferizePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateKernelgenFinalBufferizePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerKernelgenFinalBufferizePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateKernelgenFinalBufferizePass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeTensorReshapePass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeTensorReshapePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeTensorReshapePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLegalizeTensorReshapePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeTensorReshapePass();
  });
}

//===----------------------------------------------------------------------===//
// MergeAssumingOpsPass Registration
//===----------------------------------------------------------------------===//

inline void registerMergeAssumingOpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createMergeAssumingOpsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMergeAssumingOpsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createMergeAssumingOpsPass();
  });
}

//===----------------------------------------------------------------------===//
// ParallelLoopsToSequential Registration
//===----------------------------------------------------------------------===//

inline void registerParallelLoopsToSequential() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateParallelLoopsToSequential();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerParallelLoopsToSequentialPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateParallelLoopsToSequential();
  });
}

//===----------------------------------------------------------------------===//
// PropagateShapeKnowledgeToKernels Registration
//===----------------------------------------------------------------------===//

inline void registerPropagateShapeKnowledgeToKernels() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreatePropagateShapeKnowledgeToKernels();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerPropagateShapeKnowledgeToKernelsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreatePropagateShapeKnowledgeToKernels();
  });
}

//===----------------------------------------------------------------------===//
// PropagateTfAbiKnowledgeToKernels Registration
//===----------------------------------------------------------------------===//

inline void registerPropagateTfAbiKnowledgeToKernels() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreatePropagateTfAbiKnowledgeToKernels();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerPropagateTfAbiKnowledgeToKernelsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreatePropagateTfAbiKnowledgeToKernels();
  });
}

//===----------------------------------------------------------------------===//
// RewriteTFFrameworkAssert Registration
//===----------------------------------------------------------------------===//

inline void registerRewriteTFFrameworkAssert() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_framework::CreateRewriteTFFrameworkAssert();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRewriteTFFrameworkAssertPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_framework::CreateRewriteTFFrameworkAssert();
  });
}

//===----------------------------------------------------------------------===//
// ShapeSimplificationPass Registration
//===----------------------------------------------------------------------===//

inline void registerShapeSimplificationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createShapeSimplificationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerShapeSimplificationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createShapeSimplificationPass();
  });
}

//===----------------------------------------------------------------------===//
// ShapeToDescriptorsPass Registration
//===----------------------------------------------------------------------===//

inline void registerShapeToDescriptorsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateShapeToDescriptorsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerShapeToDescriptorsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateShapeToDescriptorsPass();
  });
}

//===----------------------------------------------------------------------===//
// TFKernelToLLVMPass Registration
//===----------------------------------------------------------------------===//

inline void registerTFKernelToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateTFKernelToLLVMPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTFKernelToLLVMPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateTFKernelToLLVMPass();
  });
}

//===----------------------------------------------------------------------===//
// KernelGen Registration
//===----------------------------------------------------------------------===//

inline void registerKernelGenPasses() {
  registerBroadcastPropagationPass();
  registerBufferReusePass();
  registerCopyCleanupPass();
  registerEmbedTFFrameworkPass();
  registerFuncToJITInvocationPass();
  registerFuseInnerParallelLoopsPass();
  registerGpuKernelToBlobPass();
  registerKernelgenFinalBufferizePass();
  registerLegalizeTensorReshapePass();
  registerMergeAssumingOpsPass();
  registerParallelLoopsToSequential();
  registerPropagateShapeKnowledgeToKernels();
  registerPropagateTfAbiKnowledgeToKernels();
  registerRewriteTFFrameworkAssert();
  registerShapeSimplificationPass();
  registerShapeToDescriptorsPass();
  registerTFKernelToLLVMPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class BroadcastPropagationPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = BroadcastPropagationPassBase;

  BroadcastPropagationPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BroadcastPropagationPassBase(const BroadcastPropagationPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  BroadcastPropagationPassBase& operator=(const BroadcastPropagationPassBase &) = delete;
  BroadcastPropagationPassBase(BroadcastPropagationPassBase &&) = delete;
  BroadcastPropagationPassBase& operator=(BroadcastPropagationPassBase &&) = delete;
  ~BroadcastPropagationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-broadcast-propagation");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-broadcast-propagation"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Move dynamic broadcasts up over element-wise operations and broadcast the operands rather than the result. This will eventually allow for larger fusions.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BroadcastPropagationPass");
  }
  ::llvm::StringRef getName() const override { return "BroadcastPropagationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BroadcastPropagationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class BufferReusePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = BufferReusePassBase;

  BufferReusePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BufferReusePassBase(const BufferReusePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  BufferReusePassBase& operator=(const BufferReusePassBase &) = delete;
  BufferReusePassBase(BufferReusePassBase &&) = delete;
  BufferReusePassBase& operator=(BufferReusePassBase &&) = delete;
  ~BufferReusePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("buffer-reuse");
  }
  ::llvm::StringRef getArgument() const override { return "buffer-reuse"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass to find and annotate candidates for buffer reuse.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BufferReusePass");
  }
  ::llvm::StringRef getName() const override { return "BufferReusePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BufferReusePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class CopyCleanupPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = CopyCleanupPassBase;

  CopyCleanupPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CopyCleanupPassBase(const CopyCleanupPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  CopyCleanupPassBase& operator=(const CopyCleanupPassBase &) = delete;
  CopyCleanupPassBase(CopyCleanupPassBase &&) = delete;
  CopyCleanupPassBase& operator=(CopyCleanupPassBase &&) = delete;
  ~CopyCleanupPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("copy-cleanup");
  }
  ::llvm::StringRef getArgument() const override { return "copy-cleanup"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass to remove copies which are consumed by a GenericOp.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CopyCleanupPass");
  }
  ::llvm::StringRef getName() const override { return "CopyCleanupPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CopyCleanupPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class EmbedTFFrameworkPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = EmbedTFFrameworkPassBase;

  EmbedTFFrameworkPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  EmbedTFFrameworkPassBase(const EmbedTFFrameworkPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  EmbedTFFrameworkPassBase& operator=(const EmbedTFFrameworkPassBase &) = delete;
  EmbedTFFrameworkPassBase(EmbedTFFrameworkPassBase &&) = delete;
  EmbedTFFrameworkPassBase& operator=(EmbedTFFrameworkPassBase &&) = delete;
  ~EmbedTFFrameworkPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("embed-tf-framework");
  }
  ::llvm::StringRef getArgument() const override { return "embed-tf-framework"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass to embed TF Framework for allocation and assertions,)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("EmbedTFFrameworkPass");
  }
  ::llvm::StringRef getName() const override { return "EmbedTFFrameworkPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(EmbedTFFrameworkPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class FuncToJITInvocationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FuncToJITInvocationPassBase;

  FuncToJITInvocationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FuncToJITInvocationPassBase(const FuncToJITInvocationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  FuncToJITInvocationPassBase& operator=(const FuncToJITInvocationPassBase &) = delete;
  FuncToJITInvocationPassBase(FuncToJITInvocationPassBase &&) = delete;
  FuncToJITInvocationPassBase& operator=(FuncToJITInvocationPassBase &&) = delete;
  ~FuncToJITInvocationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("func-to-jit-invocation");
  }
  ::llvm::StringRef getArgument() const override { return "func-to-jit-invocation"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass to rewrite a function to JIT invocations)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FuncToJITInvocationPass");
  }
  ::llvm::StringRef getName() const override { return "FuncToJITInvocationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::kernel_gen::tf_framework::TFFrameworkDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<shape::ShapeDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FuncToJITInvocationPassBase<DerivedT>)

protected:
  ::mlir::Pass::ListOption<int64_t> tile_sizes_{*this, "tile-sizes", ::llvm::cl::desc(R"PO(Tiling sizes)PO"), llvm::cl::ZeroOrMore};
  ::mlir::Pass::ListOption<int64_t> unroll_factors_{*this, "unroll-factors", ::llvm::cl::desc(R"PO(Unrolling in each tile dimension)PO"), llvm::cl::ZeroOrMore};
  ::mlir::Pass::Option<bool> enable_ftz_{*this, "enable-ftz", ::llvm::cl::desc(R"PO(Enable the denormal flush to zero mode when generating code)PO")};
  ::mlir::Pass::Option<bool> index_64bit_{*this, "index_64bit", ::llvm::cl::desc(R"PO(Enable the 64 bit indexing for GPU kernels)PO")};
  ::mlir::Pass::Option<bool> cpu_codegen_{*this, "cpu-codegen", ::llvm::cl::desc(R"PO(CPU codegen (false implies GPU))PO")};
  ::mlir::Pass::Option<bool> jit_i64_indexed_for_large_tensors_{*this, "jit_i64_indexed_for_large_tensors", ::llvm::cl::desc(R"PO(Enable JIT compilation of i64-indexed kernels for large input tensors.)PO"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class FuseInnerParallelLoopsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FuseInnerParallelLoopsPassBase;

  FuseInnerParallelLoopsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FuseInnerParallelLoopsPassBase(const FuseInnerParallelLoopsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  FuseInnerParallelLoopsPassBase& operator=(const FuseInnerParallelLoopsPassBase &) = delete;
  FuseInnerParallelLoopsPassBase(FuseInnerParallelLoopsPassBase &&) = delete;
  FuseInnerParallelLoopsPassBase& operator=(FuseInnerParallelLoopsPassBase &&) = delete;
  ~FuseInnerParallelLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("fuse-inner-parallel-loops");
  }
  ::llvm::StringRef getArgument() const override { return "fuse-inner-parallel-loops"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Limited pass to forward stores to loads.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FuseInnerParallelLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "FuseInnerParallelLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FuseInnerParallelLoopsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class GpuKernelToBlobPassBase : public ::mlir::OperationPass<gpu::GPUModuleOp> {
public:
  using Base = GpuKernelToBlobPassBase;

  GpuKernelToBlobPassBase() : ::mlir::OperationPass<gpu::GPUModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  GpuKernelToBlobPassBase(const GpuKernelToBlobPassBase &other) : ::mlir::OperationPass<gpu::GPUModuleOp>(other) {}
  GpuKernelToBlobPassBase& operator=(const GpuKernelToBlobPassBase &) = delete;
  GpuKernelToBlobPassBase(GpuKernelToBlobPassBase &&) = delete;
  GpuKernelToBlobPassBase& operator=(GpuKernelToBlobPassBase &&) = delete;
  ~GpuKernelToBlobPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gpu-kernel-to-blob");
  }
  ::llvm::StringRef getArgument() const override { return "gpu-kernel-to-blob"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass to annotate GPU Module with its PTX)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GpuKernelToBlobPass");
  }
  ::llvm::StringRef getName() const override { return "GpuKernelToBlobPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GpuKernelToBlobPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> blob_annotation_{*this, "blob-annotation", ::llvm::cl::desc(R"PO(Blob attribute name)PO"), ::llvm::cl::init("gpu.binary_blob")};
  ::mlir::Pass::ListOption<std::string> architectures_{*this, "arch", ::llvm::cl::desc(R"PO(GPU architectures)PO")};
  ::mlir::Pass::Option<bool> generate_fatbin_{*this, "generate-fatbin", ::llvm::cl::desc(R"PO(Bundle machine code for the different architectures in one fatbin.)PO"), ::llvm::cl::init(true)};
  ::mlir::Pass::Option<bool> print_ptx_{*this, "print-ptx", ::llvm::cl::desc(R"PO(Print generated PTX code per target architecture.)PO"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> print_llvmir_{*this, "print-llvmir", ::llvm::cl::desc(R"PO(Print llvm ir when lowering code per target architecture.)PO"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class KernelgenFinalBufferizePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = KernelgenFinalBufferizePassBase;

  KernelgenFinalBufferizePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  KernelgenFinalBufferizePassBase(const KernelgenFinalBufferizePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  KernelgenFinalBufferizePassBase& operator=(const KernelgenFinalBufferizePassBase &) = delete;
  KernelgenFinalBufferizePassBase(KernelgenFinalBufferizePassBase &&) = delete;
  KernelgenFinalBufferizePassBase& operator=(KernelgenFinalBufferizePassBase &&) = delete;
  ~KernelgenFinalBufferizePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("kernelgen-final-bufferize");
  }
  ::llvm::StringRef getArgument() const override { return "kernelgen-final-bufferize"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass to transform late operations on values to buffer based ones.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("KernelgenFinalBufferizePass");
  }
  ::llvm::StringRef getName() const override { return "KernelgenFinalBufferizePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(KernelgenFinalBufferizePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LegalizeTensorReshapePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LegalizeTensorReshapePassBase;

  LegalizeTensorReshapePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeTensorReshapePassBase(const LegalizeTensorReshapePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  LegalizeTensorReshapePassBase& operator=(const LegalizeTensorReshapePassBase &) = delete;
  LegalizeTensorReshapePassBase(LegalizeTensorReshapePassBase &&) = delete;
  LegalizeTensorReshapePassBase& operator=(LegalizeTensorReshapePassBase &&) = delete;
  ~LegalizeTensorReshapePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("legalize-tensor-reshape");
  }
  ::llvm::StringRef getArgument() const override { return "legalize-tensor-reshape"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Legalize tensor.reshape to mhlo.dynamic_reshape)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeTensorReshapePass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeTensorReshapePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeTensorReshapePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MergeAssumingOpsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = MergeAssumingOpsPassBase;

  MergeAssumingOpsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MergeAssumingOpsPassBase(const MergeAssumingOpsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  MergeAssumingOpsPassBase& operator=(const MergeAssumingOpsPassBase &) = delete;
  MergeAssumingOpsPassBase(MergeAssumingOpsPassBase &&) = delete;
  MergeAssumingOpsPassBase& operator=(MergeAssumingOpsPassBase &&) = delete;
  ~MergeAssumingOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("mhlo-merge-assuming-ops");
  }
  ::llvm::StringRef getArgument() const override { return "mhlo-merge-assuming-ops"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Prepare moving dynamic broadcasts up over element-wise operations and broadcast the operands rather than the result. This will eventually allow for larger fusions.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MergeAssumingOpsPass");
  }
  ::llvm::StringRef getName() const override { return "MergeAssumingOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MergeAssumingOpsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ParallelLoopsToSequentialBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ParallelLoopsToSequentialBase;

  ParallelLoopsToSequentialBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ParallelLoopsToSequentialBase(const ParallelLoopsToSequentialBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ParallelLoopsToSequentialBase& operator=(const ParallelLoopsToSequentialBase &) = delete;
  ParallelLoopsToSequentialBase(ParallelLoopsToSequentialBase &&) = delete;
  ParallelLoopsToSequentialBase& operator=(ParallelLoopsToSequentialBase &&) = delete;
  ~ParallelLoopsToSequentialBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("parallel-loops-to-sequential");
  }
  ::llvm::StringRef getArgument() const override { return "parallel-loops-to-sequential"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass to convert scf::ParallelOp to scf::ForOp)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ParallelLoopsToSequential");
  }
  ::llvm::StringRef getName() const override { return "ParallelLoopsToSequential"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ParallelLoopsToSequentialBase<DerivedT>)

protected:
};

template <typename DerivedT>
class PropagateShapeKnowledgeToKernelsBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = PropagateShapeKnowledgeToKernelsBase;

  PropagateShapeKnowledgeToKernelsBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  PropagateShapeKnowledgeToKernelsBase(const PropagateShapeKnowledgeToKernelsBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  PropagateShapeKnowledgeToKernelsBase& operator=(const PropagateShapeKnowledgeToKernelsBase &) = delete;
  PropagateShapeKnowledgeToKernelsBase(PropagateShapeKnowledgeToKernelsBase &&) = delete;
  PropagateShapeKnowledgeToKernelsBase& operator=(PropagateShapeKnowledgeToKernelsBase &&) = delete;
  ~PropagateShapeKnowledgeToKernelsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("propagate-shape-knowledge-to-kernels");
  }
  ::llvm::StringRef getArgument() const override { return "propagate-shape-knowledge-to-kernels"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass to propagate shape information into kernels)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PropagateShapeKnowledgeToKernels");
  }
  ::llvm::StringRef getName() const override { return "PropagateShapeKnowledgeToKernels"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PropagateShapeKnowledgeToKernelsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class PropagateTfAbiKnowledgeToKernelsBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = PropagateTfAbiKnowledgeToKernelsBase;

  PropagateTfAbiKnowledgeToKernelsBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  PropagateTfAbiKnowledgeToKernelsBase(const PropagateTfAbiKnowledgeToKernelsBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  PropagateTfAbiKnowledgeToKernelsBase& operator=(const PropagateTfAbiKnowledgeToKernelsBase &) = delete;
  PropagateTfAbiKnowledgeToKernelsBase(PropagateTfAbiKnowledgeToKernelsBase &&) = delete;
  PropagateTfAbiKnowledgeToKernelsBase& operator=(PropagateTfAbiKnowledgeToKernelsBase &&) = delete;
  ~PropagateTfAbiKnowledgeToKernelsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("propagate-tf-abi-knowledge-to-kernels");
  }
  ::llvm::StringRef getArgument() const override { return "propagate-tf-abi-knowledge-to-kernels"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass to propagate tensorflow ABI knowledge to kernels)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PropagateTfAbiKnowledgeToKernels");
  }
  ::llvm::StringRef getName() const override { return "PropagateTfAbiKnowledgeToKernels"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PropagateTfAbiKnowledgeToKernelsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class RewriteTFFrameworkAssertBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = RewriteTFFrameworkAssertBase;

  RewriteTFFrameworkAssertBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteTFFrameworkAssertBase(const RewriteTFFrameworkAssertBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  RewriteTFFrameworkAssertBase& operator=(const RewriteTFFrameworkAssertBase &) = delete;
  RewriteTFFrameworkAssertBase(RewriteTFFrameworkAssertBase &&) = delete;
  RewriteTFFrameworkAssertBase& operator=(RewriteTFFrameworkAssertBase &&) = delete;
  ~RewriteTFFrameworkAssertBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("rewrite-tf-framework-assert");
  }
  ::llvm::StringRef getArgument() const override { return "rewrite-tf-framework-assert"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass to rewrite TFAssertOps to CondBranchOp)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteTFFrameworkAssert");
  }
  ::llvm::StringRef getName() const override { return "RewriteTFFrameworkAssert"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<cf::ControlFlowDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteTFFrameworkAssertBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ShapeSimplificationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ShapeSimplificationPassBase;

  ShapeSimplificationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ShapeSimplificationPassBase(const ShapeSimplificationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ShapeSimplificationPassBase& operator=(const ShapeSimplificationPassBase &) = delete;
  ShapeSimplificationPassBase(ShapeSimplificationPassBase &&) = delete;
  ShapeSimplificationPassBase& operator=(ShapeSimplificationPassBase &&) = delete;
  ~ShapeSimplificationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("shape-simplification");
  }
  ::llvm::StringRef getArgument() const override { return "shape-simplification"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Simplify shape ops)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ShapeSimplificationPass");
  }
  ::llvm::StringRef getName() const override { return "ShapeSimplificationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ShapeSimplificationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ShapeToDescriptorsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ShapeToDescriptorsPassBase;

  ShapeToDescriptorsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ShapeToDescriptorsPassBase(const ShapeToDescriptorsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  ShapeToDescriptorsPassBase& operator=(const ShapeToDescriptorsPassBase &) = delete;
  ShapeToDescriptorsPassBase(ShapeToDescriptorsPassBase &&) = delete;
  ShapeToDescriptorsPassBase& operator=(ShapeToDescriptorsPassBase &&) = delete;
  ~ShapeToDescriptorsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("shape-to-descriptors");
  }
  ::llvm::StringRef getArgument() const override { return "shape-to-descriptors"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass to transform shape computations to descriptors)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ShapeToDescriptorsPass");
  }
  ::llvm::StringRef getName() const override { return "ShapeToDescriptorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ShapeToDescriptorsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TFKernelToLLVMPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TFKernelToLLVMPassBase;

  TFKernelToLLVMPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TFKernelToLLVMPassBase(const TFKernelToLLVMPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TFKernelToLLVMPassBase& operator=(const TFKernelToLLVMPassBase &) = delete;
  TFKernelToLLVMPassBase(TFKernelToLLVMPassBase &&) = delete;
  TFKernelToLLVMPassBase& operator=(TFKernelToLLVMPassBase &&) = delete;
  ~TFKernelToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-kernel-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "tf-kernel-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Pass for applying LLVM legalization patterns.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TFKernelToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "TFKernelToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TFKernelToLLVMPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> blob_annotation_{*this, "blob-annotation", ::llvm::cl::desc(R"PO(Blob attribute name)PO"), ::llvm::cl::init("gpu.binary_blob")};
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
