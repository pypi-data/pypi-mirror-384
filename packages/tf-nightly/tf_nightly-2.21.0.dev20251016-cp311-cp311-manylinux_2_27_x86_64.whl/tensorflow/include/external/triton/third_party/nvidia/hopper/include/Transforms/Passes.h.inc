/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_NVGPUTESTWSCODEPARTITION
#define GEN_PASS_DECL_NVGPUTESTWSDATAPARTITION
#define GEN_PASS_DECL_NVGPUTESTWSTASKIDPROPAGATE
#define GEN_PASS_DECL_NVGPUTESTWSTASKPARTITION
#define GEN_PASS_DECL_NVGPUWARPSPECIALIZATION
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// NVGPUTestWSCodePartition
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_NVGPUTESTWSCODEPARTITION
struct NVGPUTestWSCodePartitionOptions {
  int32_t numBuffers = 0;
  int32_t numWarpGroups = 0;
  int32_t requestedRegisters = 232;
};
std::unique_ptr<::mlir::Pass> createNVGPUTestWSCodePartition();
std::unique_ptr<::mlir::Pass> createNVGPUTestWSCodePartition(NVGPUTestWSCodePartitionOptions options);
#undef GEN_PASS_DECL_NVGPUTESTWSCODEPARTITION
#endif // GEN_PASS_DECL_NVGPUTESTWSCODEPARTITION
#ifdef GEN_PASS_DEF_NVGPUTESTWSCODEPARTITION

namespace impl {
  std::unique_ptr<::mlir::Pass> createNVGPUTestWSCodePartition();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createNVGPUTestWSCodePartition(NVGPUTestWSCodePartitionOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class NVGPUTestWSCodePartitionBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = NVGPUTestWSCodePartitionBase;

  NVGPUTestWSCodePartitionBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  NVGPUTestWSCodePartitionBase(const NVGPUTestWSCodePartitionBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  NVGPUTestWSCodePartitionBase& operator=(const NVGPUTestWSCodePartitionBase &) = delete;
  NVGPUTestWSCodePartitionBase(NVGPUTestWSCodePartitionBase &&) = delete;
  NVGPUTestWSCodePartitionBase& operator=(NVGPUTestWSCodePartitionBase &&) = delete;
  ~NVGPUTestWSCodePartitionBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("nvgpu-test-ws-code-partition");
  }
  ::llvm::StringRef getArgument() const override { return "nvgpu-test-ws-code-partition"; }

  ::llvm::StringRef getDescription() const override { return R"PD(test warp specialization code partition)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("NVGPUTestWSCodePartition");
  }
  ::llvm::StringRef getName() const override { return "NVGPUTestWSCodePartition"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
    registry.insert<mlir::triton::nvws::NVWSDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(NVGPUTestWSCodePartitionBase<DerivedT>)

  NVGPUTestWSCodePartitionBase(NVGPUTestWSCodePartitionOptions options) : NVGPUTestWSCodePartitionBase() {
    numBuffers = std::move(options.numBuffers);
    numWarpGroups = std::move(options.numWarpGroups);
    requestedRegisters = std::move(options.requestedRegisters);
  }
protected:
  ::mlir::Pass::Option<int32_t> numBuffers{*this, "num-buffers", ::llvm::cl::desc(R"PO(number of buffering for producer-consumer)PO"), ::llvm::cl::init(0)};
  ::mlir::Pass::Option<int32_t> numWarpGroups{*this, "num-warp-groups", ::llvm::cl::desc(R"PO(number of warp groups for warp specialization)PO"), ::llvm::cl::init(0)};
  ::mlir::Pass::Option<int32_t> requestedRegisters{*this, "requested-registers", ::llvm::cl::desc(R"PO(number of register requested for computation group)PO"), ::llvm::cl::init(232)};
private:

  friend std::unique_ptr<::mlir::Pass> createNVGPUTestWSCodePartition() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createNVGPUTestWSCodePartition(NVGPUTestWSCodePartitionOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createNVGPUTestWSCodePartition() {
  return impl::createNVGPUTestWSCodePartition();
}

std::unique_ptr<::mlir::Pass> createNVGPUTestWSCodePartition(NVGPUTestWSCodePartitionOptions options) {
  return impl::createNVGPUTestWSCodePartition(std::move(options));
}
#undef GEN_PASS_DEF_NVGPUTESTWSCODEPARTITION
#endif // GEN_PASS_DEF_NVGPUTESTWSCODEPARTITION

//===----------------------------------------------------------------------===//
// NVGPUTestWSDataPartition
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_NVGPUTESTWSDATAPARTITION
struct NVGPUTestWSDataPartitionOptions {
  int32_t numWarpGroups = 0;
};
std::unique_ptr<::mlir::Pass> createNVGPUTestWSDataPartition();
std::unique_ptr<::mlir::Pass> createNVGPUTestWSDataPartition(NVGPUTestWSDataPartitionOptions options);
#undef GEN_PASS_DECL_NVGPUTESTWSDATAPARTITION
#endif // GEN_PASS_DECL_NVGPUTESTWSDATAPARTITION
#ifdef GEN_PASS_DEF_NVGPUTESTWSDATAPARTITION

namespace impl {
  std::unique_ptr<::mlir::Pass> createNVGPUTestWSDataPartition();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createNVGPUTestWSDataPartition(NVGPUTestWSDataPartitionOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class NVGPUTestWSDataPartitionBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = NVGPUTestWSDataPartitionBase;

  NVGPUTestWSDataPartitionBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  NVGPUTestWSDataPartitionBase(const NVGPUTestWSDataPartitionBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  NVGPUTestWSDataPartitionBase& operator=(const NVGPUTestWSDataPartitionBase &) = delete;
  NVGPUTestWSDataPartitionBase(NVGPUTestWSDataPartitionBase &&) = delete;
  NVGPUTestWSDataPartitionBase& operator=(NVGPUTestWSDataPartitionBase &&) = delete;
  ~NVGPUTestWSDataPartitionBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("nvgpu-test-ws-data-partition");
  }
  ::llvm::StringRef getArgument() const override { return "nvgpu-test-ws-data-partition"; }

  ::llvm::StringRef getDescription() const override { return R"PD(test warp specialization data partition)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("NVGPUTestWSDataPartition");
  }
  ::llvm::StringRef getName() const override { return "NVGPUTestWSDataPartition"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(NVGPUTestWSDataPartitionBase<DerivedT>)

  NVGPUTestWSDataPartitionBase(NVGPUTestWSDataPartitionOptions options) : NVGPUTestWSDataPartitionBase() {
    numWarpGroups = std::move(options.numWarpGroups);
  }
protected:
  ::mlir::Pass::Option<int32_t> numWarpGroups{*this, "num-warp-groups", ::llvm::cl::desc(R"PO(number of warp groups for warp specialization)PO"), ::llvm::cl::init(0)};
private:

  friend std::unique_ptr<::mlir::Pass> createNVGPUTestWSDataPartition() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createNVGPUTestWSDataPartition(NVGPUTestWSDataPartitionOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createNVGPUTestWSDataPartition() {
  return impl::createNVGPUTestWSDataPartition();
}

std::unique_ptr<::mlir::Pass> createNVGPUTestWSDataPartition(NVGPUTestWSDataPartitionOptions options) {
  return impl::createNVGPUTestWSDataPartition(std::move(options));
}
#undef GEN_PASS_DEF_NVGPUTESTWSDATAPARTITION
#endif // GEN_PASS_DEF_NVGPUTESTWSDATAPARTITION

//===----------------------------------------------------------------------===//
// NVGPUTestWSTaskIdPropagate
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_NVGPUTESTWSTASKIDPROPAGATE
struct NVGPUTestWSTaskIdPropagateOptions {
  int32_t numWarpGroups = 0;
};
std::unique_ptr<::mlir::Pass> createNVGPUTestWSTaskIdPropagate();
std::unique_ptr<::mlir::Pass> createNVGPUTestWSTaskIdPropagate(NVGPUTestWSTaskIdPropagateOptions options);
#undef GEN_PASS_DECL_NVGPUTESTWSTASKIDPROPAGATE
#endif // GEN_PASS_DECL_NVGPUTESTWSTASKIDPROPAGATE
#ifdef GEN_PASS_DEF_NVGPUTESTWSTASKIDPROPAGATE

namespace impl {
  std::unique_ptr<::mlir::Pass> createNVGPUTestWSTaskIdPropagate();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createNVGPUTestWSTaskIdPropagate(NVGPUTestWSTaskIdPropagateOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class NVGPUTestWSTaskIdPropagateBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = NVGPUTestWSTaskIdPropagateBase;

  NVGPUTestWSTaskIdPropagateBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  NVGPUTestWSTaskIdPropagateBase(const NVGPUTestWSTaskIdPropagateBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  NVGPUTestWSTaskIdPropagateBase& operator=(const NVGPUTestWSTaskIdPropagateBase &) = delete;
  NVGPUTestWSTaskIdPropagateBase(NVGPUTestWSTaskIdPropagateBase &&) = delete;
  NVGPUTestWSTaskIdPropagateBase& operator=(NVGPUTestWSTaskIdPropagateBase &&) = delete;
  ~NVGPUTestWSTaskIdPropagateBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("nvgpu-test-taskid-propagate");
  }
  ::llvm::StringRef getArgument() const override { return "nvgpu-test-taskid-propagate"; }

  ::llvm::StringRef getDescription() const override { return R"PD(test warp specialization task id propagation)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("NVGPUTestWSTaskIdPropagate");
  }
  ::llvm::StringRef getName() const override { return "NVGPUTestWSTaskIdPropagate"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(NVGPUTestWSTaskIdPropagateBase<DerivedT>)

  NVGPUTestWSTaskIdPropagateBase(NVGPUTestWSTaskIdPropagateOptions options) : NVGPUTestWSTaskIdPropagateBase() {
    numWarpGroups = std::move(options.numWarpGroups);
  }
protected:
  ::mlir::Pass::Option<int32_t> numWarpGroups{*this, "num-warp-groups", ::llvm::cl::desc(R"PO(number of warp groups for warp specialization)PO"), ::llvm::cl::init(0)};
private:

  friend std::unique_ptr<::mlir::Pass> createNVGPUTestWSTaskIdPropagate() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createNVGPUTestWSTaskIdPropagate(NVGPUTestWSTaskIdPropagateOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createNVGPUTestWSTaskIdPropagate() {
  return impl::createNVGPUTestWSTaskIdPropagate();
}

std::unique_ptr<::mlir::Pass> createNVGPUTestWSTaskIdPropagate(NVGPUTestWSTaskIdPropagateOptions options) {
  return impl::createNVGPUTestWSTaskIdPropagate(std::move(options));
}
#undef GEN_PASS_DEF_NVGPUTESTWSTASKIDPROPAGATE
#endif // GEN_PASS_DEF_NVGPUTESTWSTASKIDPROPAGATE

//===----------------------------------------------------------------------===//
// NVGPUTestWSTaskPartition
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_NVGPUTESTWSTASKPARTITION
struct NVGPUTestWSTaskPartitionOptions {
  int32_t numWarpGroups = 0;
};
std::unique_ptr<::mlir::Pass> createNVGPUTestWSTaskPartition();
std::unique_ptr<::mlir::Pass> createNVGPUTestWSTaskPartition(NVGPUTestWSTaskPartitionOptions options);
#undef GEN_PASS_DECL_NVGPUTESTWSTASKPARTITION
#endif // GEN_PASS_DECL_NVGPUTESTWSTASKPARTITION
#ifdef GEN_PASS_DEF_NVGPUTESTWSTASKPARTITION

namespace impl {
  std::unique_ptr<::mlir::Pass> createNVGPUTestWSTaskPartition();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createNVGPUTestWSTaskPartition(NVGPUTestWSTaskPartitionOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class NVGPUTestWSTaskPartitionBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = NVGPUTestWSTaskPartitionBase;

  NVGPUTestWSTaskPartitionBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  NVGPUTestWSTaskPartitionBase(const NVGPUTestWSTaskPartitionBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  NVGPUTestWSTaskPartitionBase& operator=(const NVGPUTestWSTaskPartitionBase &) = delete;
  NVGPUTestWSTaskPartitionBase(NVGPUTestWSTaskPartitionBase &&) = delete;
  NVGPUTestWSTaskPartitionBase& operator=(NVGPUTestWSTaskPartitionBase &&) = delete;
  ~NVGPUTestWSTaskPartitionBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("nvgpu-test-ws-task-partition");
  }
  ::llvm::StringRef getArgument() const override { return "nvgpu-test-ws-task-partition"; }

  ::llvm::StringRef getDescription() const override { return R"PD(test warp specialization task partition)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("NVGPUTestWSTaskPartition");
  }
  ::llvm::StringRef getName() const override { return "NVGPUTestWSTaskPartition"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(NVGPUTestWSTaskPartitionBase<DerivedT>)

  NVGPUTestWSTaskPartitionBase(NVGPUTestWSTaskPartitionOptions options) : NVGPUTestWSTaskPartitionBase() {
    numWarpGroups = std::move(options.numWarpGroups);
  }
protected:
  ::mlir::Pass::Option<int32_t> numWarpGroups{*this, "num-warp-groups", ::llvm::cl::desc(R"PO(number of warp groups for warp specialization)PO"), ::llvm::cl::init(0)};
private:

  friend std::unique_ptr<::mlir::Pass> createNVGPUTestWSTaskPartition() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createNVGPUTestWSTaskPartition(NVGPUTestWSTaskPartitionOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createNVGPUTestWSTaskPartition() {
  return impl::createNVGPUTestWSTaskPartition();
}

std::unique_ptr<::mlir::Pass> createNVGPUTestWSTaskPartition(NVGPUTestWSTaskPartitionOptions options) {
  return impl::createNVGPUTestWSTaskPartition(std::move(options));
}
#undef GEN_PASS_DEF_NVGPUTESTWSTASKPARTITION
#endif // GEN_PASS_DEF_NVGPUTESTWSTASKPARTITION

//===----------------------------------------------------------------------===//
// NVGPUWarpSpecialization
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_NVGPUWARPSPECIALIZATION
struct NVGPUWarpSpecializationOptions {
  int32_t numStages = 0;
  bool dumpIntermediateSteps = false;
};
std::unique_ptr<::mlir::Pass> createNVGPUWarpSpecialization();
std::unique_ptr<::mlir::Pass> createNVGPUWarpSpecialization(NVGPUWarpSpecializationOptions options);
#undef GEN_PASS_DECL_NVGPUWARPSPECIALIZATION
#endif // GEN_PASS_DECL_NVGPUWARPSPECIALIZATION
#ifdef GEN_PASS_DEF_NVGPUWARPSPECIALIZATION

namespace impl {
  std::unique_ptr<::mlir::Pass> createNVGPUWarpSpecialization();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createNVGPUWarpSpecialization(NVGPUWarpSpecializationOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class NVGPUWarpSpecializationBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = NVGPUWarpSpecializationBase;

  NVGPUWarpSpecializationBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  NVGPUWarpSpecializationBase(const NVGPUWarpSpecializationBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  NVGPUWarpSpecializationBase& operator=(const NVGPUWarpSpecializationBase &) = delete;
  NVGPUWarpSpecializationBase(NVGPUWarpSpecializationBase &&) = delete;
  NVGPUWarpSpecializationBase& operator=(NVGPUWarpSpecializationBase &&) = delete;
  ~NVGPUWarpSpecializationBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("nvgpu-warp-specialization");
  }
  ::llvm::StringRef getArgument() const override { return "nvgpu-warp-specialization"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Automatic Warp specialization for NVIDIA GPU)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("NVGPUWarpSpecialization");
  }
  ::llvm::StringRef getName() const override { return "NVGPUWarpSpecialization"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(NVGPUWarpSpecializationBase<DerivedT>)

  NVGPUWarpSpecializationBase(NVGPUWarpSpecializationOptions options) : NVGPUWarpSpecializationBase() {
    numStages = std::move(options.numStages);
    dumpIntermediateSteps = std::move(options.dumpIntermediateSteps);
  }
protected:
  ::mlir::Pass::Option<int32_t> numStages{*this, "num-stages", ::llvm::cl::desc(R"PO(number of buffers for warp specialization)PO"), ::llvm::cl::init(0)};
  ::mlir::Pass::Option<bool> dumpIntermediateSteps{*this, "dump-intermediate-steps", ::llvm::cl::desc(R"PO(Dump intermediate steps)PO"), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createNVGPUWarpSpecialization() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createNVGPUWarpSpecialization(NVGPUWarpSpecializationOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createNVGPUWarpSpecialization() {
  return impl::createNVGPUWarpSpecialization();
}

std::unique_ptr<::mlir::Pass> createNVGPUWarpSpecialization(NVGPUWarpSpecializationOptions options) {
  return impl::createNVGPUWarpSpecialization(std::move(options));
}
#undef GEN_PASS_DEF_NVGPUWARPSPECIALIZATION
#endif // GEN_PASS_DEF_NVGPUWARPSPECIALIZATION
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// NVGPUTestWSCodePartition Registration
//===----------------------------------------------------------------------===//

inline void registerNVGPUTestWSCodePartition() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createNVGPUTestWSCodePartition();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerNVGPUTestWSCodePartitionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createNVGPUTestWSCodePartition();
  });
}

//===----------------------------------------------------------------------===//
// NVGPUTestWSDataPartition Registration
//===----------------------------------------------------------------------===//

inline void registerNVGPUTestWSDataPartition() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createNVGPUTestWSDataPartition();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerNVGPUTestWSDataPartitionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createNVGPUTestWSDataPartition();
  });
}

//===----------------------------------------------------------------------===//
// NVGPUTestWSTaskIdPropagate Registration
//===----------------------------------------------------------------------===//

inline void registerNVGPUTestWSTaskIdPropagate() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createNVGPUTestWSTaskIdPropagate();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerNVGPUTestWSTaskIdPropagatePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createNVGPUTestWSTaskIdPropagate();
  });
}

//===----------------------------------------------------------------------===//
// NVGPUTestWSTaskPartition Registration
//===----------------------------------------------------------------------===//

inline void registerNVGPUTestWSTaskPartition() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createNVGPUTestWSTaskPartition();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerNVGPUTestWSTaskPartitionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createNVGPUTestWSTaskPartition();
  });
}

//===----------------------------------------------------------------------===//
// NVGPUWarpSpecialization Registration
//===----------------------------------------------------------------------===//

inline void registerNVGPUWarpSpecialization() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createNVGPUWarpSpecialization();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerNVGPUWarpSpecializationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createNVGPUWarpSpecialization();
  });
}

//===----------------------------------------------------------------------===//
// NVHopperTransforms Registration
//===----------------------------------------------------------------------===//

inline void registerNVHopperTransformsPasses() {
  registerNVGPUTestWSCodePartition();
  registerNVGPUTestWSDataPartition();
  registerNVGPUTestWSTaskIdPropagate();
  registerNVGPUTestWSTaskPartition();
  registerNVGPUWarpSpecialization();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class NVGPUTestWSCodePartitionBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = NVGPUTestWSCodePartitionBase;

  NVGPUTestWSCodePartitionBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  NVGPUTestWSCodePartitionBase(const NVGPUTestWSCodePartitionBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  NVGPUTestWSCodePartitionBase& operator=(const NVGPUTestWSCodePartitionBase &) = delete;
  NVGPUTestWSCodePartitionBase(NVGPUTestWSCodePartitionBase &&) = delete;
  NVGPUTestWSCodePartitionBase& operator=(NVGPUTestWSCodePartitionBase &&) = delete;
  ~NVGPUTestWSCodePartitionBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("nvgpu-test-ws-code-partition");
  }
  ::llvm::StringRef getArgument() const override { return "nvgpu-test-ws-code-partition"; }

  ::llvm::StringRef getDescription() const override { return R"PD(test warp specialization code partition)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("NVGPUTestWSCodePartition");
  }
  ::llvm::StringRef getName() const override { return "NVGPUTestWSCodePartition"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
    registry.insert<mlir::triton::nvws::NVWSDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(NVGPUTestWSCodePartitionBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int32_t> numBuffers{*this, "num-buffers", ::llvm::cl::desc(R"PO(number of buffering for producer-consumer)PO"), ::llvm::cl::init(0)};
  ::mlir::Pass::Option<int32_t> numWarpGroups{*this, "num-warp-groups", ::llvm::cl::desc(R"PO(number of warp groups for warp specialization)PO"), ::llvm::cl::init(0)};
  ::mlir::Pass::Option<int32_t> requestedRegisters{*this, "requested-registers", ::llvm::cl::desc(R"PO(number of register requested for computation group)PO"), ::llvm::cl::init(232)};
};

template <typename DerivedT>
class NVGPUTestWSDataPartitionBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = NVGPUTestWSDataPartitionBase;

  NVGPUTestWSDataPartitionBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  NVGPUTestWSDataPartitionBase(const NVGPUTestWSDataPartitionBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  NVGPUTestWSDataPartitionBase& operator=(const NVGPUTestWSDataPartitionBase &) = delete;
  NVGPUTestWSDataPartitionBase(NVGPUTestWSDataPartitionBase &&) = delete;
  NVGPUTestWSDataPartitionBase& operator=(NVGPUTestWSDataPartitionBase &&) = delete;
  ~NVGPUTestWSDataPartitionBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("nvgpu-test-ws-data-partition");
  }
  ::llvm::StringRef getArgument() const override { return "nvgpu-test-ws-data-partition"; }

  ::llvm::StringRef getDescription() const override { return R"PD(test warp specialization data partition)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("NVGPUTestWSDataPartition");
  }
  ::llvm::StringRef getName() const override { return "NVGPUTestWSDataPartition"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(NVGPUTestWSDataPartitionBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int32_t> numWarpGroups{*this, "num-warp-groups", ::llvm::cl::desc(R"PO(number of warp groups for warp specialization)PO"), ::llvm::cl::init(0)};
};

template <typename DerivedT>
class NVGPUTestWSTaskIdPropagateBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = NVGPUTestWSTaskIdPropagateBase;

  NVGPUTestWSTaskIdPropagateBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  NVGPUTestWSTaskIdPropagateBase(const NVGPUTestWSTaskIdPropagateBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  NVGPUTestWSTaskIdPropagateBase& operator=(const NVGPUTestWSTaskIdPropagateBase &) = delete;
  NVGPUTestWSTaskIdPropagateBase(NVGPUTestWSTaskIdPropagateBase &&) = delete;
  NVGPUTestWSTaskIdPropagateBase& operator=(NVGPUTestWSTaskIdPropagateBase &&) = delete;
  ~NVGPUTestWSTaskIdPropagateBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("nvgpu-test-taskid-propagate");
  }
  ::llvm::StringRef getArgument() const override { return "nvgpu-test-taskid-propagate"; }

  ::llvm::StringRef getDescription() const override { return R"PD(test warp specialization task id propagation)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("NVGPUTestWSTaskIdPropagate");
  }
  ::llvm::StringRef getName() const override { return "NVGPUTestWSTaskIdPropagate"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(NVGPUTestWSTaskIdPropagateBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int32_t> numWarpGroups{*this, "num-warp-groups", ::llvm::cl::desc(R"PO(number of warp groups for warp specialization)PO"), ::llvm::cl::init(0)};
};

template <typename DerivedT>
class NVGPUTestWSTaskPartitionBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = NVGPUTestWSTaskPartitionBase;

  NVGPUTestWSTaskPartitionBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  NVGPUTestWSTaskPartitionBase(const NVGPUTestWSTaskPartitionBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  NVGPUTestWSTaskPartitionBase& operator=(const NVGPUTestWSTaskPartitionBase &) = delete;
  NVGPUTestWSTaskPartitionBase(NVGPUTestWSTaskPartitionBase &&) = delete;
  NVGPUTestWSTaskPartitionBase& operator=(NVGPUTestWSTaskPartitionBase &&) = delete;
  ~NVGPUTestWSTaskPartitionBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("nvgpu-test-ws-task-partition");
  }
  ::llvm::StringRef getArgument() const override { return "nvgpu-test-ws-task-partition"; }

  ::llvm::StringRef getDescription() const override { return R"PD(test warp specialization task partition)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("NVGPUTestWSTaskPartition");
  }
  ::llvm::StringRef getName() const override { return "NVGPUTestWSTaskPartition"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(NVGPUTestWSTaskPartitionBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int32_t> numWarpGroups{*this, "num-warp-groups", ::llvm::cl::desc(R"PO(number of warp groups for warp specialization)PO"), ::llvm::cl::init(0)};
};

template <typename DerivedT>
class NVGPUWarpSpecializationBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = NVGPUWarpSpecializationBase;

  NVGPUWarpSpecializationBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  NVGPUWarpSpecializationBase(const NVGPUWarpSpecializationBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  NVGPUWarpSpecializationBase& operator=(const NVGPUWarpSpecializationBase &) = delete;
  NVGPUWarpSpecializationBase(NVGPUWarpSpecializationBase &&) = delete;
  NVGPUWarpSpecializationBase& operator=(NVGPUWarpSpecializationBase &&) = delete;
  ~NVGPUWarpSpecializationBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("nvgpu-warp-specialization");
  }
  ::llvm::StringRef getArgument() const override { return "nvgpu-warp-specialization"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Automatic Warp specialization for NVIDIA GPU)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("NVGPUWarpSpecialization");
  }
  ::llvm::StringRef getName() const override { return "NVGPUWarpSpecialization"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(NVGPUWarpSpecializationBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int32_t> numStages{*this, "num-stages", ::llvm::cl::desc(R"PO(number of buffers for warp specialization)PO"), ::llvm::cl::init(0)};
  ::mlir::Pass::Option<bool> dumpIntermediateSteps{*this, "dump-intermediate-steps", ::llvm::cl::desc(R"PO(Dump intermediate steps)PO"), ::llvm::cl::init(false)};
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
