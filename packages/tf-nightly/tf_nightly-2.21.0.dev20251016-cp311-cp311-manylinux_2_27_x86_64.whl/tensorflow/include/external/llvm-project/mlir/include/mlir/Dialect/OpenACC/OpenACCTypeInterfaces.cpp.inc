/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Interface Definitions                                                      *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/


/// Returns the pointer to the `var` if recoverable (such as in cases
/// where the current operation is a load from a memory slot).
::mlir::TypedValue<::mlir::acc::PointerLikeType> mlir::acc::MappableType::getVarPtr(::mlir::Value var) const {
      return getImpl()->getVarPtr(getImpl(), *this, var);
  }

/// Returns the size in bytes when computable. If this is an array-like
/// type, avoiding passing `accBounds` ensures a computation of the size
/// of whole type.
::std::optional<::llvm::TypeSize> mlir::acc::MappableType::getSizeInBytes(::mlir::Value var, ::mlir::ValueRange accBounds, const ::mlir::DataLayout & dataLayout) const {
      return getImpl()->getSizeInBytes(getImpl(), *this, var, accBounds, dataLayout);
  }

/// Returns the offset in bytes when computable.
::std::optional<::int64_t> mlir::acc::MappableType::getOffsetInBytes(::mlir::Value var, ::mlir::ValueRange accBounds, const ::mlir::DataLayout & dataLayout) const {
      return getImpl()->getOffsetInBytes(getImpl(), *this, var, accBounds, dataLayout);
  }

/// Returns explicit `acc.bounds` operations that envelop the whole
/// data structure. These operations are inserted using the provided builder
/// at the location set before calling this API.
::llvm::SmallVector<::mlir::Value> mlir::acc::MappableType::generateAccBounds(::mlir::Value var, ::mlir::OpBuilder & builder) const {
      return getImpl()->generateAccBounds(getImpl(), *this, var, builder);
  }

/// Returns the OpenACC type category.
::mlir::acc::VariableTypeCategory mlir::acc::MappableType::getTypeCategory(::mlir::Value var) const {
      return getImpl()->getTypeCategory(getImpl(), *this, var);
  }

/// Generates the operations that would be normally placed in a recipe's
/// init region. It inserts at the builder's current location.
/// It can be used either to directly "inline" the init region
/// or if the caller sets the insertion point to inside a recipe body,
/// it fills it in. This does not generate the `acc.yield` that normally
/// would terminate a recipe.
/// 
/// The `extents` are optional and can be empty - it is only when a
/// slice of the private variable needs allocation.
/// The `initVal` can be empty - it is primarily needed for reductions
/// to ensure the variable is also initialized with appropriate value.
/// 
/// If the return value is empty, it means that recipe body was not
/// successfully generated.
::mlir::Value mlir::acc::MappableType::generatePrivateInit(::mlir::OpBuilder & builder, ::mlir::Location loc, ::mlir::TypedValue<::mlir::acc::MappableType> var, ::llvm::StringRef varName, ::mlir::ValueRange extents, ::mlir::Value initVal) const {
      return getImpl()->generatePrivateInit(getImpl(), *this, builder, loc, var, varName, extents, initVal);
  }

/// Returns the pointee type or null if the pointer has no pointee type
::mlir::Type mlir::acc::PointerLikeType::getElementType() const {
      return getImpl()->getElementType(getImpl(), *this);
  }

/// Returns the type category of the pointee. The `var` is provided because
/// a dialect's type system may be incomplete. For example, consider a
/// dialect which computes interior pointers - so a float array element
/// may be represented as `ptr<f32>`. The type system says the pointee
/// is `f32` but this is not a scalar from the point-of-view of OpenACC.
/// It is an array element and thus the appropriate type category is
/// "array" - therefore being able to look up how a variable is computed
/// is important for a complete type determination.
/// The `varType` is provided in cases where a dialect's type system
/// erased the target type.
::mlir::acc::VariableTypeCategory mlir::acc::PointerLikeType::getPointeeTypeCategory(::mlir::TypedValue<::mlir::acc::PointerLikeType> varPtr, ::mlir::Type varType) const {
      return getImpl()->getPointeeTypeCategory(getImpl(), *this, varPtr, varType);
  }

/// Generates allocation operations for the pointer-like type. It will create
/// an allocate that produces memory space for an instance of the current type.
/// 
/// The `varName` parameter is optional and can be used to provide a name
/// for the allocated variable. If the current type is represented
/// in a way that it does not capture the pointee type, `varType` must be
/// passed in to provide the necessary type information.
/// 
/// The `originalVar` parameter is optional but enables support for dynamic
/// types (e.g., dynamic memrefs). When provided, implementations can extract
/// runtime dimension information from the original variable to create
/// allocations with matching dynamic sizes.
/// 
/// Returns a Value representing the result of the allocation. If no value
/// is returned, it means the allocation was not successfully generated.
::mlir::Value mlir::acc::PointerLikeType::genAllocate(::mlir::OpBuilder & builder, ::mlir::Location loc, ::llvm::StringRef varName, ::mlir::Type varType, ::mlir::Value originalVar) const {
      return getImpl()->genAllocate(getImpl(), *this, builder, loc, varName, varType, originalVar);
  }

/// Generates deallocation operations for the pointer-like type. It deallocates
/// the instance provided.
/// 
/// The `varPtr` parameter is required and must represent an instance that was
/// previously allocated. If the current type is represented in a way that it
/// does not capture the pointee type, `varType` must be passed in to provide
/// the necessary type information. Nothing is generated in case the allocate
/// is `alloca`-like.
/// 
/// Returns true if deallocation was successfully generated or successfully
/// deemed as not needed to be generated, false otherwise.
bool mlir::acc::PointerLikeType::genFree(::mlir::OpBuilder & builder, ::mlir::Location loc, ::mlir::TypedValue<::mlir::acc::PointerLikeType> varPtr, ::mlir::Type varType) const {
      return getImpl()->genFree(getImpl(), *this, builder, loc, varPtr, varType);
  }

/// Generates copy operations for the pointer-like type. It copies the memory
/// from the source to the destination. Typically used to initialize one
/// variable of this type from another.
/// 
/// The `destination` and `source` parameters represent the target and source
/// instances respectively. If the current type is represented in a way that it
/// does not capture the pointee type, `varType` must be passed in to provide
/// the necessary type information.
/// 
/// Returns true if copy was successfully generated, false otherwise.
bool mlir::acc::PointerLikeType::genCopy(::mlir::OpBuilder & builder, ::mlir::Location loc, ::mlir::TypedValue<::mlir::acc::PointerLikeType> destination, ::mlir::TypedValue<::mlir::acc::PointerLikeType> source, ::mlir::Type varType) const {
      return getImpl()->genCopy(getImpl(), *this, builder, loc, destination, source, varType);
  }
