/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_CONVERTFLOATAMDPASS
#define GEN_PASS_DECL_CONVERTFLOATNVIDIAPASS
#define GEN_PASS_DECL_CONVERTINDEXTYPEPASS
#define GEN_PASS_DECL_LOWERXLASHAREDPASS
#define GEN_PASS_DECL_OPTIMIZELOOPSPASS
#define GEN_PASS_DECL_PEELLOOPSPASS
#define GEN_PASS_DECL_RECOVEREXP2PASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// ConvertFloatAMDPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTFLOATAMDPASS
struct ConvertFloatAMDPassOptions {
  std::string gpu_device_info_;
};
#undef GEN_PASS_DECL_CONVERTFLOATAMDPASS
#endif // GEN_PASS_DECL_CONVERTFLOATAMDPASS
#ifdef GEN_PASS_DEF_CONVERTFLOATAMDPASS
namespace impl {

template <typename DerivedT>
class ConvertFloatAMDPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertFloatAMDPassBase;

  ConvertFloatAMDPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertFloatAMDPassBase(const ConvertFloatAMDPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ConvertFloatAMDPassBase& operator=(const ConvertFloatAMDPassBase &) = delete;
  ConvertFloatAMDPassBase(ConvertFloatAMDPassBase &&) = delete;
  ConvertFloatAMDPassBase& operator=(ConvertFloatAMDPassBase &&) = delete;
  ~ConvertFloatAMDPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-convert-float-amd");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-convert-float-amd"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Convert floating point types using AMDGCN intrinsics.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertFloatAMDPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertFloatAMDPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertFloatAMDPassBase<DerivedT>)

  ConvertFloatAMDPassBase(ConvertFloatAMDPassOptions options) : ConvertFloatAMDPassBase() {
    gpu_device_info_ = std::move(options.gpu_device_info_);
  }
protected:
  ::mlir::Pass::Option<std::string> gpu_device_info_{*this, "gpu_device_info", ::llvm::cl::desc(R"PO(Serialized stream_executor::GPUDeviceInfo proto.)PO")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTFLOATAMDPASS
#endif // GEN_PASS_DEF_CONVERTFLOATAMDPASS

//===----------------------------------------------------------------------===//
// ConvertFloatNvidiaPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTFLOATNVIDIAPASS
struct ConvertFloatNvidiaPassOptions {
  int compute_capability_major_ = 0;
  int compute_capability_minor_ = 0;
  int ptx_version_major_ = 0;
  int ptx_version_minor_ = 0;
};
#undef GEN_PASS_DECL_CONVERTFLOATNVIDIAPASS
#endif // GEN_PASS_DECL_CONVERTFLOATNVIDIAPASS
#ifdef GEN_PASS_DEF_CONVERTFLOATNVIDIAPASS
namespace impl {

template <typename DerivedT>
class ConvertFloatNvidiaPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertFloatNvidiaPassBase;

  ConvertFloatNvidiaPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertFloatNvidiaPassBase(const ConvertFloatNvidiaPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ConvertFloatNvidiaPassBase& operator=(const ConvertFloatNvidiaPassBase &) = delete;
  ConvertFloatNvidiaPassBase(ConvertFloatNvidiaPassBase &&) = delete;
  ConvertFloatNvidiaPassBase& operator=(ConvertFloatNvidiaPassBase &&) = delete;
  ~ConvertFloatNvidiaPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-convert-float-nvidia");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-convert-float-nvidia"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Convert floating point types using NVPTX intrinsics.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertFloatNvidiaPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertFloatNvidiaPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertFloatNvidiaPassBase<DerivedT>)

  ConvertFloatNvidiaPassBase(ConvertFloatNvidiaPassOptions options) : ConvertFloatNvidiaPassBase() {
    compute_capability_major_ = std::move(options.compute_capability_major_);
    compute_capability_minor_ = std::move(options.compute_capability_minor_);
    ptx_version_major_ = std::move(options.ptx_version_major_);
    ptx_version_minor_ = std::move(options.ptx_version_minor_);
  }
protected:
  ::mlir::Pass::Option<int> compute_capability_major_{*this, "compute_capability_major", ::llvm::cl::desc(R"PO(CUDA compute capability major version.)PO"), ::llvm::cl::init(0)};
  ::mlir::Pass::Option<int> compute_capability_minor_{*this, "compute_capability_minor", ::llvm::cl::desc(R"PO(CUDA compute capability minor version.)PO"), ::llvm::cl::init(0)};
  ::mlir::Pass::Option<int> ptx_version_major_{*this, "ptx_version_major", ::llvm::cl::desc(R"PO(PTX version major.)PO"), ::llvm::cl::init(0)};
  ::mlir::Pass::Option<int> ptx_version_minor_{*this, "ptx_version_minor", ::llvm::cl::desc(R"PO(PTX version minor.)PO"), ::llvm::cl::init(0)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTFLOATNVIDIAPASS
#endif // GEN_PASS_DEF_CONVERTFLOATNVIDIAPASS

//===----------------------------------------------------------------------===//
// ConvertIndexTypePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTINDEXTYPEPASS
#undef GEN_PASS_DECL_CONVERTINDEXTYPEPASS
#endif // GEN_PASS_DECL_CONVERTINDEXTYPEPASS
#ifdef GEN_PASS_DEF_CONVERTINDEXTYPEPASS
namespace impl {

template <typename DerivedT>
class ConvertIndexTypePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertIndexTypePassBase;

  ConvertIndexTypePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertIndexTypePassBase(const ConvertIndexTypePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ConvertIndexTypePassBase& operator=(const ConvertIndexTypePassBase &) = delete;
  ConvertIndexTypePassBase(ConvertIndexTypePassBase &&) = delete;
  ConvertIndexTypePassBase& operator=(ConvertIndexTypePassBase &&) = delete;
  ~ConvertIndexTypePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-convert-index-type");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-convert-index-type"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Converts index types to module data layout index type.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertIndexTypePass");
  }
  ::llvm::StringRef getName() const override { return "ConvertIndexTypePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertIndexTypePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTINDEXTYPEPASS
#endif // GEN_PASS_DEF_CONVERTINDEXTYPEPASS

//===----------------------------------------------------------------------===//
// LowerXlaSharedPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERXLASHAREDPASS
#undef GEN_PASS_DECL_LOWERXLASHAREDPASS
#endif // GEN_PASS_DECL_LOWERXLASHAREDPASS
#ifdef GEN_PASS_DEF_LOWERXLASHAREDPASS
namespace impl {

template <typename DerivedT>
class LowerXlaSharedPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LowerXlaSharedPassBase;

  LowerXlaSharedPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerXlaSharedPassBase(const LowerXlaSharedPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  LowerXlaSharedPassBase& operator=(const LowerXlaSharedPassBase &) = delete;
  LowerXlaSharedPassBase(LowerXlaSharedPassBase &&) = delete;
  LowerXlaSharedPassBase& operator=(LowerXlaSharedPassBase &&) = delete;
  ~LowerXlaSharedPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-lower-xla-shared");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-lower-xla-shared"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowers XLA shared dialect ops to XLA GPU ops.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerXlaSharedPass");
  }
  ::llvm::StringRef getName() const override { return "LowerXlaSharedPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<xla::XlaDialect>();
    registry.insert<mlir::gpu::GPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerXlaSharedPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOWERXLASHAREDPASS
#endif // GEN_PASS_DEF_LOWERXLASHAREDPASS

//===----------------------------------------------------------------------===//
// OptimizeLoopsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_OPTIMIZELOOPSPASS
#undef GEN_PASS_DECL_OPTIMIZELOOPSPASS
#endif // GEN_PASS_DECL_OPTIMIZELOOPSPASS
#ifdef GEN_PASS_DEF_OPTIMIZELOOPSPASS
namespace impl {

template <typename DerivedT>
class OptimizeLoopsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = OptimizeLoopsPassBase;

  OptimizeLoopsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  OptimizeLoopsPassBase(const OptimizeLoopsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  OptimizeLoopsPassBase& operator=(const OptimizeLoopsPassBase &) = delete;
  OptimizeLoopsPassBase(OptimizeLoopsPassBase &&) = delete;
  OptimizeLoopsPassBase& operator=(OptimizeLoopsPassBase &&) = delete;
  ~OptimizeLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-optimize-loops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-optimize-loops"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Unrolls and pipelines loops.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OptimizeLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "OptimizeLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::vector::VectorDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
    registry.insert<xla::XlaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OptimizeLoopsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_OPTIMIZELOOPSPASS
#endif // GEN_PASS_DEF_OPTIMIZELOOPSPASS

//===----------------------------------------------------------------------===//
// PeelLoopsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PEELLOOPSPASS
#undef GEN_PASS_DECL_PEELLOOPSPASS
#endif // GEN_PASS_DECL_PEELLOOPSPASS
#ifdef GEN_PASS_DEF_PEELLOOPSPASS
namespace impl {

template <typename DerivedT>
class PeelLoopsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = PeelLoopsPassBase;

  PeelLoopsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  PeelLoopsPassBase(const PeelLoopsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  PeelLoopsPassBase& operator=(const PeelLoopsPassBase &) = delete;
  PeelLoopsPassBase(PeelLoopsPassBase &&) = delete;
  PeelLoopsPassBase& operator=(PeelLoopsPassBase &&) = delete;
  ~PeelLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-peel-loops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-peel-loops"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Peels xla_gpu.loop.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PeelLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "PeelLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<xla::gpu::XlaGpuDialect>();
    registry.insert<xla::XlaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PeelLoopsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PEELLOOPSPASS
#endif // GEN_PASS_DEF_PEELLOOPSPASS

//===----------------------------------------------------------------------===//
// RecoverExp2Pass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_RECOVEREXP2PASS
#undef GEN_PASS_DECL_RECOVEREXP2PASS
#endif // GEN_PASS_DECL_RECOVEREXP2PASS
#ifdef GEN_PASS_DEF_RECOVEREXP2PASS
namespace impl {

template <typename DerivedT>
class RecoverExp2PassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = RecoverExp2PassBase;

  RecoverExp2PassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  RecoverExp2PassBase(const RecoverExp2PassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  RecoverExp2PassBase& operator=(const RecoverExp2PassBase &) = delete;
  RecoverExp2PassBase(RecoverExp2PassBase &&) = delete;
  RecoverExp2PassBase& operator=(RecoverExp2PassBase &&) = delete;
  ~RecoverExp2PassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-recover-exp2");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-recover-exp2"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Recovers exp2(x) from exp(x*log(2)))PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RecoverExp2Pass");
  }
  ::llvm::StringRef getName() const override { return "RecoverExp2Pass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::math::MathDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RecoverExp2PassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_RECOVEREXP2PASS
#endif // GEN_PASS_DEF_RECOVEREXP2PASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// ConvertFloatAMDPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertFloatAMDPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateConvertFloatAMDPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertFloatAMDPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateConvertFloatAMDPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertFloatNvidiaPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertFloatNvidiaPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateConvertFloatNvidiaPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertFloatNvidiaPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateConvertFloatNvidiaPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertIndexTypePass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertIndexTypePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateConvertIndexTypePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertIndexTypePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateConvertIndexTypePass();
  });
}

//===----------------------------------------------------------------------===//
// LowerXlaSharedPass Registration
//===----------------------------------------------------------------------===//

inline void registerLowerXlaSharedPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLowerXlaSharedPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerXlaSharedPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLowerXlaSharedPass();
  });
}

//===----------------------------------------------------------------------===//
// OptimizeLoopsPass Registration
//===----------------------------------------------------------------------===//

inline void registerOptimizeLoopsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateOptimizeLoopsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerOptimizeLoopsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateOptimizeLoopsPass();
  });
}

//===----------------------------------------------------------------------===//
// PeelLoopsPass Registration
//===----------------------------------------------------------------------===//

inline void registerPeelLoopsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreatePeelLoopsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerPeelLoopsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreatePeelLoopsPass();
  });
}

//===----------------------------------------------------------------------===//
// RecoverExp2Pass Registration
//===----------------------------------------------------------------------===//

inline void registerRecoverExp2Pass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateRecoverExp2Pass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRecoverExp2PassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateRecoverExp2Pass();
  });
}

//===----------------------------------------------------------------------===//
// GpuFusionTransforms Registration
//===----------------------------------------------------------------------===//

inline void registerGpuFusionTransformsPasses() {
  registerConvertFloatAMDPass();
  registerConvertFloatNvidiaPass();
  registerConvertIndexTypePass();
  registerLowerXlaSharedPass();
  registerOptimizeLoopsPass();
  registerPeelLoopsPass();
  registerRecoverExp2Pass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class ConvertFloatAMDPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertFloatAMDPassBase;

  ConvertFloatAMDPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertFloatAMDPassBase(const ConvertFloatAMDPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ConvertFloatAMDPassBase& operator=(const ConvertFloatAMDPassBase &) = delete;
  ConvertFloatAMDPassBase(ConvertFloatAMDPassBase &&) = delete;
  ConvertFloatAMDPassBase& operator=(ConvertFloatAMDPassBase &&) = delete;
  ~ConvertFloatAMDPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-convert-float-amd");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-convert-float-amd"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Convert floating point types using AMDGCN intrinsics.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertFloatAMDPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertFloatAMDPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertFloatAMDPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> gpu_device_info_{*this, "gpu_device_info", ::llvm::cl::desc(R"PO(Serialized stream_executor::GPUDeviceInfo proto.)PO")};
};

template <typename DerivedT>
class ConvertFloatNvidiaPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertFloatNvidiaPassBase;

  ConvertFloatNvidiaPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertFloatNvidiaPassBase(const ConvertFloatNvidiaPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ConvertFloatNvidiaPassBase& operator=(const ConvertFloatNvidiaPassBase &) = delete;
  ConvertFloatNvidiaPassBase(ConvertFloatNvidiaPassBase &&) = delete;
  ConvertFloatNvidiaPassBase& operator=(ConvertFloatNvidiaPassBase &&) = delete;
  ~ConvertFloatNvidiaPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-convert-float-nvidia");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-convert-float-nvidia"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Convert floating point types using NVPTX intrinsics.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertFloatNvidiaPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertFloatNvidiaPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertFloatNvidiaPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int> compute_capability_major_{*this, "compute_capability_major", ::llvm::cl::desc(R"PO(CUDA compute capability major version.)PO"), ::llvm::cl::init(0)};
  ::mlir::Pass::Option<int> compute_capability_minor_{*this, "compute_capability_minor", ::llvm::cl::desc(R"PO(CUDA compute capability minor version.)PO"), ::llvm::cl::init(0)};
  ::mlir::Pass::Option<int> ptx_version_major_{*this, "ptx_version_major", ::llvm::cl::desc(R"PO(PTX version major.)PO"), ::llvm::cl::init(0)};
  ::mlir::Pass::Option<int> ptx_version_minor_{*this, "ptx_version_minor", ::llvm::cl::desc(R"PO(PTX version minor.)PO"), ::llvm::cl::init(0)};
};

template <typename DerivedT>
class ConvertIndexTypePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertIndexTypePassBase;

  ConvertIndexTypePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertIndexTypePassBase(const ConvertIndexTypePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ConvertIndexTypePassBase& operator=(const ConvertIndexTypePassBase &) = delete;
  ConvertIndexTypePassBase(ConvertIndexTypePassBase &&) = delete;
  ConvertIndexTypePassBase& operator=(ConvertIndexTypePassBase &&) = delete;
  ~ConvertIndexTypePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-convert-index-type");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-convert-index-type"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Converts index types to module data layout index type.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertIndexTypePass");
  }
  ::llvm::StringRef getName() const override { return "ConvertIndexTypePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertIndexTypePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LowerXlaSharedPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LowerXlaSharedPassBase;

  LowerXlaSharedPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerXlaSharedPassBase(const LowerXlaSharedPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  LowerXlaSharedPassBase& operator=(const LowerXlaSharedPassBase &) = delete;
  LowerXlaSharedPassBase(LowerXlaSharedPassBase &&) = delete;
  LowerXlaSharedPassBase& operator=(LowerXlaSharedPassBase &&) = delete;
  ~LowerXlaSharedPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-lower-xla-shared");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-lower-xla-shared"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowers XLA shared dialect ops to XLA GPU ops.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerXlaSharedPass");
  }
  ::llvm::StringRef getName() const override { return "LowerXlaSharedPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<xla::XlaDialect>();
    registry.insert<mlir::gpu::GPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerXlaSharedPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class OptimizeLoopsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = OptimizeLoopsPassBase;

  OptimizeLoopsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  OptimizeLoopsPassBase(const OptimizeLoopsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  OptimizeLoopsPassBase& operator=(const OptimizeLoopsPassBase &) = delete;
  OptimizeLoopsPassBase(OptimizeLoopsPassBase &&) = delete;
  OptimizeLoopsPassBase& operator=(OptimizeLoopsPassBase &&) = delete;
  ~OptimizeLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-optimize-loops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-optimize-loops"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Unrolls and pipelines loops.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OptimizeLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "OptimizeLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::vector::VectorDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
    registry.insert<xla::XlaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OptimizeLoopsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class PeelLoopsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = PeelLoopsPassBase;

  PeelLoopsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  PeelLoopsPassBase(const PeelLoopsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  PeelLoopsPassBase& operator=(const PeelLoopsPassBase &) = delete;
  PeelLoopsPassBase(PeelLoopsPassBase &&) = delete;
  PeelLoopsPassBase& operator=(PeelLoopsPassBase &&) = delete;
  ~PeelLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-peel-loops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-peel-loops"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Peels xla_gpu.loop.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PeelLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "PeelLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<xla::gpu::XlaGpuDialect>();
    registry.insert<xla::XlaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PeelLoopsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class RecoverExp2PassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = RecoverExp2PassBase;

  RecoverExp2PassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  RecoverExp2PassBase(const RecoverExp2PassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  RecoverExp2PassBase& operator=(const RecoverExp2PassBase &) = delete;
  RecoverExp2PassBase(RecoverExp2PassBase &&) = delete;
  RecoverExp2PassBase& operator=(RecoverExp2PassBase &&) = delete;
  ~RecoverExp2PassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-recover-exp2");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-recover-exp2"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Recovers exp2(x) from exp(x*log(2)))PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RecoverExp2Pass");
  }
  ::llvm::StringRef getName() const override { return "RecoverExp2Pass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::math::MathDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RecoverExp2PassBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
