/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_TRITONGPUACCELERATEMATMUL
#define GEN_PASS_DECL_TRITONGPUASSIGNLATENCIES
#define GEN_PASS_DECL_TRITONGPUAUTOMATICWARPSPECIALIZATION
#define GEN_PASS_DECL_TRITONGPUCOALESCE
#define GEN_PASS_DECL_TRITONGPUCOALESCEASYNCCOPY
#define GEN_PASS_DECL_TRITONGPUCOMBINETENSORSELECTANDIF
#define GEN_PASS_DECL_TRITONGPUF32DOTTC
#define GEN_PASS_DECL_TRITONGPUFUSENESTEDLOOPS
#define GEN_PASS_DECL_TRITONGPUHOISTTMEMALLOC
#define GEN_PASS_DECL_TRITONGPULOADMMASPECIALIZATION
#define GEN_PASS_DECL_TRITONGPUOPTIMIZEACCUMULATORINIT
#define GEN_PASS_DECL_TRITONGPUOPTIMIZEDOTOPERANDS
#define GEN_PASS_DECL_TRITONGPUOPTIMIZEPARTITIONWARPS
#define GEN_PASS_DECL_TRITONGPUOPTIMIZETHREADLOCALITY
#define GEN_PASS_DECL_TRITONGPUPARTITIONLOOPS
#define GEN_PASS_DECL_TRITONGPUPARTITIONSCHEDULING
#define GEN_PASS_DECL_TRITONGPUPIPELINE
#define GEN_PASS_DECL_TRITONGPUPREFETCH
#define GEN_PASS_DECL_TRITONGPUREDUCEDATADUPLICATION
#define GEN_PASS_DECL_TRITONGPUREMOVELAYOUTCONVERSIONS
#define GEN_PASS_DECL_TRITONGPUREORDERINSTRUCTIONS
#define GEN_PASS_DECL_TRITONGPUREWRITEPARTITIONDEPENDENCIES
#define GEN_PASS_DECL_TRITONGPUSCHEDULELOOPS
#define GEN_PASS_DECL_TRITONGPUTESTPIPELINELOWERLOOP
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// TritonGPUAccelerateMatmul
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUACCELERATEMATMUL
std::unique_ptr<::mlir::Pass> createTritonGPUAccelerateMatmul();
#undef GEN_PASS_DECL_TRITONGPUACCELERATEMATMUL
#endif // GEN_PASS_DECL_TRITONGPUACCELERATEMATMUL
#ifdef GEN_PASS_DEF_TRITONGPUACCELERATEMATMUL

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUAccelerateMatmul();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPUAccelerateMatmulBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUAccelerateMatmulBase;

  TritonGPUAccelerateMatmulBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUAccelerateMatmulBase(const TritonGPUAccelerateMatmulBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUAccelerateMatmulBase& operator=(const TritonGPUAccelerateMatmulBase &) = delete;
  TritonGPUAccelerateMatmulBase(TritonGPUAccelerateMatmulBase &&) = delete;
  TritonGPUAccelerateMatmulBase& operator=(TritonGPUAccelerateMatmulBase &&) = delete;
  ~TritonGPUAccelerateMatmulBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-accelerate-matmul");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-accelerate-matmul"; }

  ::llvm::StringRef getDescription() const override { return R"PD(accelerate matmul)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUAccelerateMatmul");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUAccelerateMatmul"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUAccelerateMatmulBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPUAccelerateMatmul() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPUAccelerateMatmul() {
  return impl::createTritonGPUAccelerateMatmul();
}
#undef GEN_PASS_DEF_TRITONGPUACCELERATEMATMUL
#endif // GEN_PASS_DEF_TRITONGPUACCELERATEMATMUL

//===----------------------------------------------------------------------===//
// TritonGPUAssignLatencies
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUASSIGNLATENCIES
struct TritonGPUAssignLatenciesOptions {
  int32_t numStages = 3;
};
std::unique_ptr<::mlir::Pass> createTritonGPUAssignLatencies();
std::unique_ptr<::mlir::Pass> createTritonGPUAssignLatencies(TritonGPUAssignLatenciesOptions options);
#undef GEN_PASS_DECL_TRITONGPUASSIGNLATENCIES
#endif // GEN_PASS_DECL_TRITONGPUASSIGNLATENCIES
#ifdef GEN_PASS_DEF_TRITONGPUASSIGNLATENCIES

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUAssignLatencies();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUAssignLatencies(TritonGPUAssignLatenciesOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPUAssignLatenciesBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUAssignLatenciesBase;

  TritonGPUAssignLatenciesBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUAssignLatenciesBase(const TritonGPUAssignLatenciesBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUAssignLatenciesBase& operator=(const TritonGPUAssignLatenciesBase &) = delete;
  TritonGPUAssignLatenciesBase(TritonGPUAssignLatenciesBase &&) = delete;
  TritonGPUAssignLatenciesBase& operator=(TritonGPUAssignLatenciesBase &&) = delete;
  ~TritonGPUAssignLatenciesBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-assign-latencies");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-assign-latencies"; }

  ::llvm::StringRef getDescription() const override { return R"PD(assign latencies to interesting ops ahead of pipelining)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUAssignLatencies");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUAssignLatencies"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUAssignLatenciesBase<DerivedT>)

  TritonGPUAssignLatenciesBase(TritonGPUAssignLatenciesOptions options) : TritonGPUAssignLatenciesBase() {
    numStages = std::move(options.numStages);
  }
protected:
  ::mlir::Pass::Option<int32_t> numStages{*this, "num-stages", ::llvm::cl::desc(R"PO(number of pipeline stages)PO"), ::llvm::cl::init(3)};
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPUAssignLatencies() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createTritonGPUAssignLatencies(TritonGPUAssignLatenciesOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPUAssignLatencies() {
  return impl::createTritonGPUAssignLatencies();
}

std::unique_ptr<::mlir::Pass> createTritonGPUAssignLatencies(TritonGPUAssignLatenciesOptions options) {
  return impl::createTritonGPUAssignLatencies(std::move(options));
}
#undef GEN_PASS_DEF_TRITONGPUASSIGNLATENCIES
#endif // GEN_PASS_DEF_TRITONGPUASSIGNLATENCIES

//===----------------------------------------------------------------------===//
// TritonGPUAutomaticWarpSpecialization
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUAUTOMATICWARPSPECIALIZATION
struct TritonGPUAutomaticWarpSpecializationOptions {
  int32_t numStages = 3;
};
std::unique_ptr<::mlir::Pass> createTritonGPUAutomaticWarpSpecialization();
std::unique_ptr<::mlir::Pass> createTritonGPUAutomaticWarpSpecialization(TritonGPUAutomaticWarpSpecializationOptions options);
#undef GEN_PASS_DECL_TRITONGPUAUTOMATICWARPSPECIALIZATION
#endif // GEN_PASS_DECL_TRITONGPUAUTOMATICWARPSPECIALIZATION
#ifdef GEN_PASS_DEF_TRITONGPUAUTOMATICWARPSPECIALIZATION

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUAutomaticWarpSpecialization();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUAutomaticWarpSpecialization(TritonGPUAutomaticWarpSpecializationOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPUAutomaticWarpSpecializationBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUAutomaticWarpSpecializationBase;

  TritonGPUAutomaticWarpSpecializationBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUAutomaticWarpSpecializationBase(const TritonGPUAutomaticWarpSpecializationBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUAutomaticWarpSpecializationBase& operator=(const TritonGPUAutomaticWarpSpecializationBase &) = delete;
  TritonGPUAutomaticWarpSpecializationBase(TritonGPUAutomaticWarpSpecializationBase &&) = delete;
  TritonGPUAutomaticWarpSpecializationBase& operator=(TritonGPUAutomaticWarpSpecializationBase &&) = delete;
  ~TritonGPUAutomaticWarpSpecializationBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-automatic-warp-specialization");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-automatic-warp-specialization"; }

  ::llvm::StringRef getDescription() const override { return R"PD(automatic warp specialization of loops)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUAutomaticWarpSpecialization");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUAutomaticWarpSpecialization"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
    registry.insert<triton::nvws::NVWSDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUAutomaticWarpSpecializationBase<DerivedT>)

  TritonGPUAutomaticWarpSpecializationBase(TritonGPUAutomaticWarpSpecializationOptions options) : TritonGPUAutomaticWarpSpecializationBase() {
    numStages = std::move(options.numStages);
  }
protected:
  ::mlir::Pass::Option<int32_t> numStages{*this, "num-stages", ::llvm::cl::desc(R"PO(number of pipeline stages)PO"), ::llvm::cl::init(3)};
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPUAutomaticWarpSpecialization() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createTritonGPUAutomaticWarpSpecialization(TritonGPUAutomaticWarpSpecializationOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPUAutomaticWarpSpecialization() {
  return impl::createTritonGPUAutomaticWarpSpecialization();
}

std::unique_ptr<::mlir::Pass> createTritonGPUAutomaticWarpSpecialization(TritonGPUAutomaticWarpSpecializationOptions options) {
  return impl::createTritonGPUAutomaticWarpSpecialization(std::move(options));
}
#undef GEN_PASS_DEF_TRITONGPUAUTOMATICWARPSPECIALIZATION
#endif // GEN_PASS_DEF_TRITONGPUAUTOMATICWARPSPECIALIZATION

//===----------------------------------------------------------------------===//
// TritonGPUCoalesce
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUCOALESCE
std::unique_ptr<::mlir::Pass> createTritonGPUCoalesce();
#undef GEN_PASS_DECL_TRITONGPUCOALESCE
#endif // GEN_PASS_DECL_TRITONGPUCOALESCE
#ifdef GEN_PASS_DEF_TRITONGPUCOALESCE

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUCoalesce();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPUCoalesceBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUCoalesceBase;

  TritonGPUCoalesceBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUCoalesceBase(const TritonGPUCoalesceBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUCoalesceBase& operator=(const TritonGPUCoalesceBase &) = delete;
  TritonGPUCoalesceBase(TritonGPUCoalesceBase &&) = delete;
  TritonGPUCoalesceBase& operator=(TritonGPUCoalesceBase &&) = delete;
  ~TritonGPUCoalesceBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-coalesce");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-coalesce"; }

  ::llvm::StringRef getDescription() const override { return R"PD(coalesce)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUCoalesce");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUCoalesce"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUCoalesceBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPUCoalesce() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPUCoalesce() {
  return impl::createTritonGPUCoalesce();
}
#undef GEN_PASS_DEF_TRITONGPUCOALESCE
#endif // GEN_PASS_DEF_TRITONGPUCOALESCE

//===----------------------------------------------------------------------===//
// TritonGPUCoalesceAsyncCopy
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUCOALESCEASYNCCOPY
std::unique_ptr<::mlir::Pass> createTritonGPUCoalesceAsyncCopy();
#undef GEN_PASS_DECL_TRITONGPUCOALESCEASYNCCOPY
#endif // GEN_PASS_DECL_TRITONGPUCOALESCEASYNCCOPY
#ifdef GEN_PASS_DEF_TRITONGPUCOALESCEASYNCCOPY

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUCoalesceAsyncCopy();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPUCoalesceAsyncCopyBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUCoalesceAsyncCopyBase;

  TritonGPUCoalesceAsyncCopyBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUCoalesceAsyncCopyBase(const TritonGPUCoalesceAsyncCopyBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUCoalesceAsyncCopyBase& operator=(const TritonGPUCoalesceAsyncCopyBase &) = delete;
  TritonGPUCoalesceAsyncCopyBase(TritonGPUCoalesceAsyncCopyBase &&) = delete;
  TritonGPUCoalesceAsyncCopyBase& operator=(TritonGPUCoalesceAsyncCopyBase &&) = delete;
  ~TritonGPUCoalesceAsyncCopyBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-coalesce-async-copy");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-coalesce-async-copy"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Improve coalescing for async global to local copies)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUCoalesceAsyncCopy");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUCoalesceAsyncCopy"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUCoalesceAsyncCopyBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPUCoalesceAsyncCopy() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPUCoalesceAsyncCopy() {
  return impl::createTritonGPUCoalesceAsyncCopy();
}
#undef GEN_PASS_DEF_TRITONGPUCOALESCEASYNCCOPY
#endif // GEN_PASS_DEF_TRITONGPUCOALESCEASYNCCOPY

//===----------------------------------------------------------------------===//
// TritonGPUCombineTensorSelectAndIf
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUCOMBINETENSORSELECTANDIF
std::unique_ptr<::mlir::Pass> createTritonGPUCombineTensorSelectAndIf();
#undef GEN_PASS_DECL_TRITONGPUCOMBINETENSORSELECTANDIF
#endif // GEN_PASS_DECL_TRITONGPUCOMBINETENSORSELECTANDIF
#ifdef GEN_PASS_DEF_TRITONGPUCOMBINETENSORSELECTANDIF

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUCombineTensorSelectAndIf();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPUCombineTensorSelectAndIfBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUCombineTensorSelectAndIfBase;

  TritonGPUCombineTensorSelectAndIfBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUCombineTensorSelectAndIfBase(const TritonGPUCombineTensorSelectAndIfBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUCombineTensorSelectAndIfBase& operator=(const TritonGPUCombineTensorSelectAndIfBase &) = delete;
  TritonGPUCombineTensorSelectAndIfBase(TritonGPUCombineTensorSelectAndIfBase &&) = delete;
  TritonGPUCombineTensorSelectAndIfBase& operator=(TritonGPUCombineTensorSelectAndIfBase &&) = delete;
  ~TritonGPUCombineTensorSelectAndIfBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-combine-tensor-select-and-if");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-combine-tensor-select-and-if"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Combine tensor select and if)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUCombineTensorSelectAndIf");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUCombineTensorSelectAndIf"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUCombineTensorSelectAndIfBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPUCombineTensorSelectAndIf() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPUCombineTensorSelectAndIf() {
  return impl::createTritonGPUCombineTensorSelectAndIf();
}
#undef GEN_PASS_DEF_TRITONGPUCOMBINETENSORSELECTANDIF
#endif // GEN_PASS_DEF_TRITONGPUCOMBINETENSORSELECTANDIF

//===----------------------------------------------------------------------===//
// TritonGPUF32DotTC
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUF32DOTTC
std::unique_ptr<::mlir::Pass> createTritonGPUF32DotTC();
#undef GEN_PASS_DECL_TRITONGPUF32DOTTC
#endif // GEN_PASS_DECL_TRITONGPUF32DOTTC
#ifdef GEN_PASS_DEF_TRITONGPUF32DOTTC

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUF32DotTC();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPUF32DotTCBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUF32DotTCBase;

  TritonGPUF32DotTCBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUF32DotTCBase(const TritonGPUF32DotTCBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUF32DotTCBase& operator=(const TritonGPUF32DotTCBase &) = delete;
  TritonGPUF32DotTCBase(TritonGPUF32DotTCBase &&) = delete;
  TritonGPUF32DotTCBase& operator=(TritonGPUF32DotTCBase &&) = delete;
  ~TritonGPUF32DotTCBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-F32DotTC");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-F32DotTC"; }

  ::llvm::StringRef getDescription() const override { return R"PD(3xTF32 trick)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUF32DotTC");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUF32DotTC"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUF32DotTCBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPUF32DotTC() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPUF32DotTC() {
  return impl::createTritonGPUF32DotTC();
}
#undef GEN_PASS_DEF_TRITONGPUF32DOTTC
#endif // GEN_PASS_DEF_TRITONGPUF32DOTTC

//===----------------------------------------------------------------------===//
// TritonGPUFuseNestedLoops
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUFUSENESTEDLOOPS
std::unique_ptr<::mlir::Pass> createTritonGPUFuseNestedLoops();
#undef GEN_PASS_DECL_TRITONGPUFUSENESTEDLOOPS
#endif // GEN_PASS_DECL_TRITONGPUFUSENESTEDLOOPS
#ifdef GEN_PASS_DEF_TRITONGPUFUSENESTEDLOOPS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUFuseNestedLoops();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPUFuseNestedLoopsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUFuseNestedLoopsBase;

  TritonGPUFuseNestedLoopsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUFuseNestedLoopsBase(const TritonGPUFuseNestedLoopsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUFuseNestedLoopsBase& operator=(const TritonGPUFuseNestedLoopsBase &) = delete;
  TritonGPUFuseNestedLoopsBase(TritonGPUFuseNestedLoopsBase &&) = delete;
  TritonGPUFuseNestedLoopsBase& operator=(TritonGPUFuseNestedLoopsBase &&) = delete;
  ~TritonGPUFuseNestedLoopsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-fuse-nested-loops");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-fuse-nested-loops"; }

  ::llvm::StringRef getDescription() const override { return R"PD(fuse nested loops for pipelining)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUFuseNestedLoops");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUFuseNestedLoops"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::ub::UBDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUFuseNestedLoopsBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPUFuseNestedLoops() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPUFuseNestedLoops() {
  return impl::createTritonGPUFuseNestedLoops();
}
#undef GEN_PASS_DEF_TRITONGPUFUSENESTEDLOOPS
#endif // GEN_PASS_DEF_TRITONGPUFUSENESTEDLOOPS

//===----------------------------------------------------------------------===//
// TritonGPUHoistTMEMAlloc
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUHOISTTMEMALLOC
struct TritonGPUHoistTMEMAllocOptions {
  bool hoistOutOfIf = false;
};
std::unique_ptr<::mlir::Pass> createTritonGPUHoistTMEMAlloc();
std::unique_ptr<::mlir::Pass> createTritonGPUHoistTMEMAlloc(TritonGPUHoistTMEMAllocOptions options);
#undef GEN_PASS_DECL_TRITONGPUHOISTTMEMALLOC
#endif // GEN_PASS_DECL_TRITONGPUHOISTTMEMALLOC
#ifdef GEN_PASS_DEF_TRITONGPUHOISTTMEMALLOC

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUHoistTMEMAlloc();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUHoistTMEMAlloc(TritonGPUHoistTMEMAllocOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPUHoistTMEMAllocBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUHoistTMEMAllocBase;

  TritonGPUHoistTMEMAllocBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUHoistTMEMAllocBase(const TritonGPUHoistTMEMAllocBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUHoistTMEMAllocBase& operator=(const TritonGPUHoistTMEMAllocBase &) = delete;
  TritonGPUHoistTMEMAllocBase(TritonGPUHoistTMEMAllocBase &&) = delete;
  TritonGPUHoistTMEMAllocBase& operator=(TritonGPUHoistTMEMAllocBase &&) = delete;
  ~TritonGPUHoistTMEMAllocBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-hoist-tmem-alloc");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-hoist-tmem-alloc"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Hoist TMEM allocations out of the loop. This is a preparation for the loop lowering.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUHoistTMEMAlloc");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUHoistTMEMAlloc"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUHoistTMEMAllocBase<DerivedT>)

  TritonGPUHoistTMEMAllocBase(TritonGPUHoistTMEMAllocOptions options) : TritonGPUHoistTMEMAllocBase() {
    hoistOutOfIf = std::move(options.hoistOutOfIf);
  }
protected:
  ::mlir::Pass::Option<bool> hoistOutOfIf{*this, "hoist-out-of-if", ::llvm::cl::desc(R"PO(Hoist TMEM allocations out of if statements)PO"), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPUHoistTMEMAlloc() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createTritonGPUHoistTMEMAlloc(TritonGPUHoistTMEMAllocOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPUHoistTMEMAlloc() {
  return impl::createTritonGPUHoistTMEMAlloc();
}

std::unique_ptr<::mlir::Pass> createTritonGPUHoistTMEMAlloc(TritonGPUHoistTMEMAllocOptions options) {
  return impl::createTritonGPUHoistTMEMAlloc(std::move(options));
}
#undef GEN_PASS_DEF_TRITONGPUHOISTTMEMALLOC
#endif // GEN_PASS_DEF_TRITONGPUHOISTTMEMALLOC

//===----------------------------------------------------------------------===//
// TritonGPULoadMMASpecialization
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPULOADMMASPECIALIZATION
struct TritonGPULoadMMASpecializationOptions {
  int32_t numStages = 3;
};
std::unique_ptr<::mlir::Pass> createTritonGPULoadMMASpecialization();
std::unique_ptr<::mlir::Pass> createTritonGPULoadMMASpecialization(TritonGPULoadMMASpecializationOptions options);
#undef GEN_PASS_DECL_TRITONGPULOADMMASPECIALIZATION
#endif // GEN_PASS_DECL_TRITONGPULOADMMASPECIALIZATION
#ifdef GEN_PASS_DEF_TRITONGPULOADMMASPECIALIZATION

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPULoadMMASpecialization();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPULoadMMASpecialization(TritonGPULoadMMASpecializationOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPULoadMMASpecializationBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPULoadMMASpecializationBase;

  TritonGPULoadMMASpecializationBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPULoadMMASpecializationBase(const TritonGPULoadMMASpecializationBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPULoadMMASpecializationBase& operator=(const TritonGPULoadMMASpecializationBase &) = delete;
  TritonGPULoadMMASpecializationBase(TritonGPULoadMMASpecializationBase &&) = delete;
  TritonGPULoadMMASpecializationBase& operator=(TritonGPULoadMMASpecializationBase &&) = delete;
  ~TritonGPULoadMMASpecializationBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-load-mma-specialization");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-load-mma-specialization"; }

  ::llvm::StringRef getDescription() const override { return R"PD(load MMA specialization)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPULoadMMASpecialization");
  }
  ::llvm::StringRef getName() const override { return "TritonGPULoadMMASpecialization"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPULoadMMASpecializationBase<DerivedT>)

  TritonGPULoadMMASpecializationBase(TritonGPULoadMMASpecializationOptions options) : TritonGPULoadMMASpecializationBase() {
    numStages = std::move(options.numStages);
  }
protected:
  ::mlir::Pass::Option<int32_t> numStages{*this, "num-stages", ::llvm::cl::desc(R"PO(number of pipeline stages)PO"), ::llvm::cl::init(3)};
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPULoadMMASpecialization() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createTritonGPULoadMMASpecialization(TritonGPULoadMMASpecializationOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPULoadMMASpecialization() {
  return impl::createTritonGPULoadMMASpecialization();
}

std::unique_ptr<::mlir::Pass> createTritonGPULoadMMASpecialization(TritonGPULoadMMASpecializationOptions options) {
  return impl::createTritonGPULoadMMASpecialization(std::move(options));
}
#undef GEN_PASS_DEF_TRITONGPULOADMMASPECIALIZATION
#endif // GEN_PASS_DEF_TRITONGPULOADMMASPECIALIZATION

//===----------------------------------------------------------------------===//
// TritonGPUOptimizeAccumulatorInit
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUOPTIMIZEACCUMULATORINIT
std::unique_ptr<::mlir::Pass> createTritonGPUOptimizeAccumulatorInit();
#undef GEN_PASS_DECL_TRITONGPUOPTIMIZEACCUMULATORINIT
#endif // GEN_PASS_DECL_TRITONGPUOPTIMIZEACCUMULATORINIT
#ifdef GEN_PASS_DEF_TRITONGPUOPTIMIZEACCUMULATORINIT

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUOptimizeAccumulatorInit();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPUOptimizeAccumulatorInitBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUOptimizeAccumulatorInitBase;

  TritonGPUOptimizeAccumulatorInitBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUOptimizeAccumulatorInitBase(const TritonGPUOptimizeAccumulatorInitBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUOptimizeAccumulatorInitBase& operator=(const TritonGPUOptimizeAccumulatorInitBase &) = delete;
  TritonGPUOptimizeAccumulatorInitBase(TritonGPUOptimizeAccumulatorInitBase &&) = delete;
  TritonGPUOptimizeAccumulatorInitBase& operator=(TritonGPUOptimizeAccumulatorInitBase &&) = delete;
  ~TritonGPUOptimizeAccumulatorInitBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-optimize-accumulator-init");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-optimize-accumulator-init"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Replace accumulator zero-initialization with the flag indicating first use of the accumulator)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUOptimizeAccumulatorInit");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUOptimizeAccumulatorInit"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUOptimizeAccumulatorInitBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPUOptimizeAccumulatorInit() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPUOptimizeAccumulatorInit() {
  return impl::createTritonGPUOptimizeAccumulatorInit();
}
#undef GEN_PASS_DEF_TRITONGPUOPTIMIZEACCUMULATORINIT
#endif // GEN_PASS_DEF_TRITONGPUOPTIMIZEACCUMULATORINIT

//===----------------------------------------------------------------------===//
// TritonGPUOptimizeDotOperands
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUOPTIMIZEDOTOPERANDS
struct TritonGPUOptimizeDotOperandsOptions {
  bool hoistLayoutConversion = true;
};
std::unique_ptr<::mlir::Pass> createTritonGPUOptimizeDotOperands();
std::unique_ptr<::mlir::Pass> createTritonGPUOptimizeDotOperands(TritonGPUOptimizeDotOperandsOptions options);
#undef GEN_PASS_DECL_TRITONGPUOPTIMIZEDOTOPERANDS
#endif // GEN_PASS_DECL_TRITONGPUOPTIMIZEDOTOPERANDS
#ifdef GEN_PASS_DEF_TRITONGPUOPTIMIZEDOTOPERANDS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUOptimizeDotOperands();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUOptimizeDotOperands(TritonGPUOptimizeDotOperandsOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPUOptimizeDotOperandsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUOptimizeDotOperandsBase;

  TritonGPUOptimizeDotOperandsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUOptimizeDotOperandsBase(const TritonGPUOptimizeDotOperandsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUOptimizeDotOperandsBase& operator=(const TritonGPUOptimizeDotOperandsBase &) = delete;
  TritonGPUOptimizeDotOperandsBase(TritonGPUOptimizeDotOperandsBase &&) = delete;
  TritonGPUOptimizeDotOperandsBase& operator=(TritonGPUOptimizeDotOperandsBase &&) = delete;
  ~TritonGPUOptimizeDotOperandsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-optimize-dot-operands");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-optimize-dot-operands"; }

  ::llvm::StringRef getDescription() const override { return R"PD(fuse transpositions)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUOptimizeDotOperands");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUOptimizeDotOperands"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUOptimizeDotOperandsBase<DerivedT>)

  TritonGPUOptimizeDotOperandsBase(TritonGPUOptimizeDotOperandsOptions options) : TritonGPUOptimizeDotOperandsBase() {
    hoistLayoutConversion = std::move(options.hoistLayoutConversion);
  }
protected:
  ::mlir::Pass::Option<bool> hoistLayoutConversion{*this, "hoist-layout-conversion", ::llvm::cl::desc(R"PO(whether to move conver to dot operand earlier pass elementwise ops)PO"), ::llvm::cl::init(true)};
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPUOptimizeDotOperands() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createTritonGPUOptimizeDotOperands(TritonGPUOptimizeDotOperandsOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPUOptimizeDotOperands() {
  return impl::createTritonGPUOptimizeDotOperands();
}

std::unique_ptr<::mlir::Pass> createTritonGPUOptimizeDotOperands(TritonGPUOptimizeDotOperandsOptions options) {
  return impl::createTritonGPUOptimizeDotOperands(std::move(options));
}
#undef GEN_PASS_DEF_TRITONGPUOPTIMIZEDOTOPERANDS
#endif // GEN_PASS_DEF_TRITONGPUOPTIMIZEDOTOPERANDS

//===----------------------------------------------------------------------===//
// TritonGPUOptimizePartitionWarps
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUOPTIMIZEPARTITIONWARPS
std::unique_ptr<::mlir::Pass> createTritonGPUOptimizePartitionWarps();
#undef GEN_PASS_DECL_TRITONGPUOPTIMIZEPARTITIONWARPS
#endif // GEN_PASS_DECL_TRITONGPUOPTIMIZEPARTITIONWARPS
#ifdef GEN_PASS_DEF_TRITONGPUOPTIMIZEPARTITIONWARPS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUOptimizePartitionWarps();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPUOptimizePartitionWarpsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUOptimizePartitionWarpsBase;

  TritonGPUOptimizePartitionWarpsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUOptimizePartitionWarpsBase(const TritonGPUOptimizePartitionWarpsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUOptimizePartitionWarpsBase& operator=(const TritonGPUOptimizePartitionWarpsBase &) = delete;
  TritonGPUOptimizePartitionWarpsBase(TritonGPUOptimizePartitionWarpsBase &&) = delete;
  TritonGPUOptimizePartitionWarpsBase& operator=(TritonGPUOptimizePartitionWarpsBase &&) = delete;
  ~TritonGPUOptimizePartitionWarpsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-optimize-partition-warps");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-optimize-partition-warps"; }

  ::llvm::StringRef getDescription() const override { return R"PD(optimize the number of warps assigned to partitions)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUOptimizePartitionWarps");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUOptimizePartitionWarps"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUOptimizePartitionWarpsBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPUOptimizePartitionWarps() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPUOptimizePartitionWarps() {
  return impl::createTritonGPUOptimizePartitionWarps();
}
#undef GEN_PASS_DEF_TRITONGPUOPTIMIZEPARTITIONWARPS
#endif // GEN_PASS_DEF_TRITONGPUOPTIMIZEPARTITIONWARPS

//===----------------------------------------------------------------------===//
// TritonGPUOptimizeThreadLocality
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUOPTIMIZETHREADLOCALITY
std::unique_ptr<::mlir::Pass> createTritonGPUOptimizeThreadLocality();
#undef GEN_PASS_DECL_TRITONGPUOPTIMIZETHREADLOCALITY
#endif // GEN_PASS_DECL_TRITONGPUOPTIMIZETHREADLOCALITY
#ifdef GEN_PASS_DEF_TRITONGPUOPTIMIZETHREADLOCALITY

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUOptimizeThreadLocality();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPUOptimizeThreadLocalityBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUOptimizeThreadLocalityBase;

  TritonGPUOptimizeThreadLocalityBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUOptimizeThreadLocalityBase(const TritonGPUOptimizeThreadLocalityBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUOptimizeThreadLocalityBase& operator=(const TritonGPUOptimizeThreadLocalityBase &) = delete;
  TritonGPUOptimizeThreadLocalityBase(TritonGPUOptimizeThreadLocalityBase &&) = delete;
  TritonGPUOptimizeThreadLocalityBase& operator=(TritonGPUOptimizeThreadLocalityBase &&) = delete;
  ~TritonGPUOptimizeThreadLocalityBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-optimize-thread-locality");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-optimize-thread-locality"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Reduce the cost of synchronization between threads in an SM)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUOptimizeThreadLocality");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUOptimizeThreadLocality"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUOptimizeThreadLocalityBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPUOptimizeThreadLocality() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPUOptimizeThreadLocality() {
  return impl::createTritonGPUOptimizeThreadLocality();
}
#undef GEN_PASS_DEF_TRITONGPUOPTIMIZETHREADLOCALITY
#endif // GEN_PASS_DEF_TRITONGPUOPTIMIZETHREADLOCALITY

//===----------------------------------------------------------------------===//
// TritonGPUPartitionLoops
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUPARTITIONLOOPS
std::unique_ptr<::mlir::Pass> createTritonGPUPartitionLoops();
#undef GEN_PASS_DECL_TRITONGPUPARTITIONLOOPS
#endif // GEN_PASS_DECL_TRITONGPUPARTITIONLOOPS
#ifdef GEN_PASS_DEF_TRITONGPUPARTITIONLOOPS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUPartitionLoops();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPUPartitionLoopsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUPartitionLoopsBase;

  TritonGPUPartitionLoopsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUPartitionLoopsBase(const TritonGPUPartitionLoopsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUPartitionLoopsBase& operator=(const TritonGPUPartitionLoopsBase &) = delete;
  TritonGPUPartitionLoopsBase(TritonGPUPartitionLoopsBase &&) = delete;
  TritonGPUPartitionLoopsBase& operator=(TritonGPUPartitionLoopsBase &&) = delete;
  ~TritonGPUPartitionLoopsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-partition-loops");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-partition-loops"; }

  ::llvm::StringRef getDescription() const override { return R"PD(split scheduled loops into `ttg.warp_specialize`)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUPartitionLoops");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUPartitionLoops"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<triton::nvws::NVWSDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUPartitionLoopsBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPUPartitionLoops() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPUPartitionLoops() {
  return impl::createTritonGPUPartitionLoops();
}
#undef GEN_PASS_DEF_TRITONGPUPARTITIONLOOPS
#endif // GEN_PASS_DEF_TRITONGPUPARTITIONLOOPS

//===----------------------------------------------------------------------===//
// TritonGPUPartitionScheduling
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUPARTITIONSCHEDULING
std::unique_ptr<::mlir::Pass> createTritonGPUPartitionScheduling();
#undef GEN_PASS_DECL_TRITONGPUPARTITIONSCHEDULING
#endif // GEN_PASS_DECL_TRITONGPUPARTITIONSCHEDULING
#ifdef GEN_PASS_DEF_TRITONGPUPARTITIONSCHEDULING

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUPartitionScheduling();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPUPartitionSchedulingBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUPartitionSchedulingBase;

  TritonGPUPartitionSchedulingBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUPartitionSchedulingBase(const TritonGPUPartitionSchedulingBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUPartitionSchedulingBase& operator=(const TritonGPUPartitionSchedulingBase &) = delete;
  TritonGPUPartitionSchedulingBase(TritonGPUPartitionSchedulingBase &&) = delete;
  TritonGPUPartitionSchedulingBase& operator=(TritonGPUPartitionSchedulingBase &&) = delete;
  ~TritonGPUPartitionSchedulingBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-partition-scheduling");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-partition-scheduling"; }

  ::llvm::StringRef getDescription() const override { return R"PD(warp specialization partitioning pass)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUPartitionScheduling");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUPartitionScheduling"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUPartitionSchedulingBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPUPartitionScheduling() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPUPartitionScheduling() {
  return impl::createTritonGPUPartitionScheduling();
}
#undef GEN_PASS_DEF_TRITONGPUPARTITIONSCHEDULING
#endif // GEN_PASS_DEF_TRITONGPUPARTITIONSCHEDULING

//===----------------------------------------------------------------------===//
// TritonGPUPipeline
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUPIPELINE
struct TritonGPUPipelineOptions {
  int32_t numStages = 3;
  bool dumpIntermediateSteps = false;
};
std::unique_ptr<::mlir::Pass> createTritonGPUPipeline();
std::unique_ptr<::mlir::Pass> createTritonGPUPipeline(TritonGPUPipelineOptions options);
#undef GEN_PASS_DECL_TRITONGPUPIPELINE
#endif // GEN_PASS_DECL_TRITONGPUPIPELINE
#ifdef GEN_PASS_DEF_TRITONGPUPIPELINE

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUPipeline();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUPipeline(TritonGPUPipelineOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPUPipelineBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUPipelineBase;

  TritonGPUPipelineBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUPipelineBase(const TritonGPUPipelineBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUPipelineBase& operator=(const TritonGPUPipelineBase &) = delete;
  TritonGPUPipelineBase(TritonGPUPipelineBase &&) = delete;
  TritonGPUPipelineBase& operator=(TritonGPUPipelineBase &&) = delete;
  ~TritonGPUPipelineBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-pipeline");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-pipeline"; }

  ::llvm::StringRef getDescription() const override { return R"PD(pipeline)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUPipeline");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUPipeline"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUPipelineBase<DerivedT>)

  TritonGPUPipelineBase(TritonGPUPipelineOptions options) : TritonGPUPipelineBase() {
    numStages = std::move(options.numStages);
    dumpIntermediateSteps = std::move(options.dumpIntermediateSteps);
  }
protected:
  ::mlir::Pass::Option<int32_t> numStages{*this, "num-stages", ::llvm::cl::desc(R"PO(number of pipeline stages)PO"), ::llvm::cl::init(3)};
  ::mlir::Pass::Option<bool> dumpIntermediateSteps{*this, "dump-intermediate-steps", ::llvm::cl::desc(R"PO(Dump intermediate steps)PO"), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPUPipeline() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createTritonGPUPipeline(TritonGPUPipelineOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPUPipeline() {
  return impl::createTritonGPUPipeline();
}

std::unique_ptr<::mlir::Pass> createTritonGPUPipeline(TritonGPUPipelineOptions options) {
  return impl::createTritonGPUPipeline(std::move(options));
}
#undef GEN_PASS_DEF_TRITONGPUPIPELINE
#endif // GEN_PASS_DEF_TRITONGPUPIPELINE

//===----------------------------------------------------------------------===//
// TritonGPUPrefetch
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUPREFETCH
std::unique_ptr<::mlir::Pass> createTritonGPUPrefetch();
#undef GEN_PASS_DECL_TRITONGPUPREFETCH
#endif // GEN_PASS_DECL_TRITONGPUPREFETCH
#ifdef GEN_PASS_DEF_TRITONGPUPREFETCH

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUPrefetch();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPUPrefetchBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUPrefetchBase;

  TritonGPUPrefetchBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUPrefetchBase(const TritonGPUPrefetchBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUPrefetchBase& operator=(const TritonGPUPrefetchBase &) = delete;
  TritonGPUPrefetchBase(TritonGPUPrefetchBase &&) = delete;
  TritonGPUPrefetchBase& operator=(TritonGPUPrefetchBase &&) = delete;
  ~TritonGPUPrefetchBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-prefetch");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-prefetch"; }

  ::llvm::StringRef getDescription() const override { return R"PD(prefetch)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUPrefetch");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUPrefetch"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUPrefetchBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPUPrefetch() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPUPrefetch() {
  return impl::createTritonGPUPrefetch();
}
#undef GEN_PASS_DEF_TRITONGPUPREFETCH
#endif // GEN_PASS_DEF_TRITONGPUPREFETCH

//===----------------------------------------------------------------------===//
// TritonGPUReduceDataDuplication
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUREDUCEDATADUPLICATION
std::unique_ptr<::mlir::Pass> createTritonGPUReduceDataDuplication();
#undef GEN_PASS_DECL_TRITONGPUREDUCEDATADUPLICATION
#endif // GEN_PASS_DECL_TRITONGPUREDUCEDATADUPLICATION
#ifdef GEN_PASS_DEF_TRITONGPUREDUCEDATADUPLICATION

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUReduceDataDuplication();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPUReduceDataDuplicationBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUReduceDataDuplicationBase;

  TritonGPUReduceDataDuplicationBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUReduceDataDuplicationBase(const TritonGPUReduceDataDuplicationBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUReduceDataDuplicationBase& operator=(const TritonGPUReduceDataDuplicationBase &) = delete;
  TritonGPUReduceDataDuplicationBase(TritonGPUReduceDataDuplicationBase &&) = delete;
  TritonGPUReduceDataDuplicationBase& operator=(TritonGPUReduceDataDuplicationBase &&) = delete;
  ~TritonGPUReduceDataDuplicationBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-reduce-data-duplication");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-reduce-data-duplication"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Reduce data duplication in register by decomposing convert[distributed -> dotOperand] into convert[distributed -> shared -> dotOperand])PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUReduceDataDuplication");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUReduceDataDuplication"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUReduceDataDuplicationBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPUReduceDataDuplication() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPUReduceDataDuplication() {
  return impl::createTritonGPUReduceDataDuplication();
}
#undef GEN_PASS_DEF_TRITONGPUREDUCEDATADUPLICATION
#endif // GEN_PASS_DEF_TRITONGPUREDUCEDATADUPLICATION

//===----------------------------------------------------------------------===//
// TritonGPURemoveLayoutConversions
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUREMOVELAYOUTCONVERSIONS
std::unique_ptr<::mlir::Pass> createTritonGPURemoveLayoutConversions();
#undef GEN_PASS_DECL_TRITONGPUREMOVELAYOUTCONVERSIONS
#endif // GEN_PASS_DECL_TRITONGPUREMOVELAYOUTCONVERSIONS
#ifdef GEN_PASS_DEF_TRITONGPUREMOVELAYOUTCONVERSIONS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPURemoveLayoutConversions();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPURemoveLayoutConversionsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPURemoveLayoutConversionsBase;

  TritonGPURemoveLayoutConversionsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPURemoveLayoutConversionsBase(const TritonGPURemoveLayoutConversionsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPURemoveLayoutConversionsBase& operator=(const TritonGPURemoveLayoutConversionsBase &) = delete;
  TritonGPURemoveLayoutConversionsBase(TritonGPURemoveLayoutConversionsBase &&) = delete;
  TritonGPURemoveLayoutConversionsBase& operator=(TritonGPURemoveLayoutConversionsBase &&) = delete;
  ~TritonGPURemoveLayoutConversionsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-remove-layout-conversions");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-remove-layout-conversions"; }

  ::llvm::StringRef getDescription() const override { return R"PD(remove superfluous layout conversions)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPURemoveLayoutConversions");
  }
  ::llvm::StringRef getName() const override { return "TritonGPURemoveLayoutConversions"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPURemoveLayoutConversionsBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPURemoveLayoutConversions() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPURemoveLayoutConversions() {
  return impl::createTritonGPURemoveLayoutConversions();
}
#undef GEN_PASS_DEF_TRITONGPUREMOVELAYOUTCONVERSIONS
#endif // GEN_PASS_DEF_TRITONGPUREMOVELAYOUTCONVERSIONS

//===----------------------------------------------------------------------===//
// TritonGPUReorderInstructions
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUREORDERINSTRUCTIONS
std::unique_ptr<::mlir::Pass> createTritonGPUReorderInstructions();
#undef GEN_PASS_DECL_TRITONGPUREORDERINSTRUCTIONS
#endif // GEN_PASS_DECL_TRITONGPUREORDERINSTRUCTIONS
#ifdef GEN_PASS_DEF_TRITONGPUREORDERINSTRUCTIONS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUReorderInstructions();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPUReorderInstructionsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUReorderInstructionsBase;

  TritonGPUReorderInstructionsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUReorderInstructionsBase(const TritonGPUReorderInstructionsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUReorderInstructionsBase& operator=(const TritonGPUReorderInstructionsBase &) = delete;
  TritonGPUReorderInstructionsBase(TritonGPUReorderInstructionsBase &&) = delete;
  TritonGPUReorderInstructionsBase& operator=(TritonGPUReorderInstructionsBase &&) = delete;
  ~TritonGPUReorderInstructionsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-reorder-instructions");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-reorder-instructions"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Reorder instructions)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUReorderInstructions");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUReorderInstructions"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUReorderInstructionsBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPUReorderInstructions() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPUReorderInstructions() {
  return impl::createTritonGPUReorderInstructions();
}
#undef GEN_PASS_DEF_TRITONGPUREORDERINSTRUCTIONS
#endif // GEN_PASS_DEF_TRITONGPUREORDERINSTRUCTIONS

//===----------------------------------------------------------------------===//
// TritonGPURewritePartitionDependencies
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUREWRITEPARTITIONDEPENDENCIES
std::unique_ptr<::mlir::Pass> createTritonGPURewritePartitionDependencies();
#undef GEN_PASS_DECL_TRITONGPUREWRITEPARTITIONDEPENDENCIES
#endif // GEN_PASS_DECL_TRITONGPUREWRITEPARTITIONDEPENDENCIES
#ifdef GEN_PASS_DEF_TRITONGPUREWRITEPARTITIONDEPENDENCIES

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPURewritePartitionDependencies();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPURewritePartitionDependenciesBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPURewritePartitionDependenciesBase;

  TritonGPURewritePartitionDependenciesBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPURewritePartitionDependenciesBase(const TritonGPURewritePartitionDependenciesBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPURewritePartitionDependenciesBase& operator=(const TritonGPURewritePartitionDependenciesBase &) = delete;
  TritonGPURewritePartitionDependenciesBase(TritonGPURewritePartitionDependenciesBase &&) = delete;
  TritonGPURewritePartitionDependenciesBase& operator=(TritonGPURewritePartitionDependenciesBase &&) = delete;
  ~TritonGPURewritePartitionDependenciesBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-rewrite-partition-dependencies");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-rewrite-partition-dependencies"; }

  ::llvm::StringRef getDescription() const override { return R"PD(test pass for rewriting partition dependencies)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPURewritePartitionDependencies");
  }
  ::llvm::StringRef getName() const override { return "TritonGPURewritePartitionDependencies"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
    registry.insert<mlir::triton::nvws::NVWSDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPURewritePartitionDependenciesBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPURewritePartitionDependencies() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPURewritePartitionDependencies() {
  return impl::createTritonGPURewritePartitionDependencies();
}
#undef GEN_PASS_DEF_TRITONGPUREWRITEPARTITIONDEPENDENCIES
#endif // GEN_PASS_DEF_TRITONGPUREWRITEPARTITIONDEPENDENCIES

//===----------------------------------------------------------------------===//
// TritonGPUScheduleLoops
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUSCHEDULELOOPS
std::unique_ptr<::mlir::Pass> createTritonGPUScheduleLoops();
#undef GEN_PASS_DECL_TRITONGPUSCHEDULELOOPS
#endif // GEN_PASS_DECL_TRITONGPUSCHEDULELOOPS
#ifdef GEN_PASS_DEF_TRITONGPUSCHEDULELOOPS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUScheduleLoops();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPUScheduleLoopsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUScheduleLoopsBase;

  TritonGPUScheduleLoopsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUScheduleLoopsBase(const TritonGPUScheduleLoopsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUScheduleLoopsBase& operator=(const TritonGPUScheduleLoopsBase &) = delete;
  TritonGPUScheduleLoopsBase(TritonGPUScheduleLoopsBase &&) = delete;
  TritonGPUScheduleLoopsBase& operator=(TritonGPUScheduleLoopsBase &&) = delete;
  ~TritonGPUScheduleLoopsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-schedule-loops");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-schedule-loops"; }

  ::llvm::StringRef getDescription() const override { return R"PD(software pipeline loop scheduling)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUScheduleLoops");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUScheduleLoops"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUScheduleLoopsBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPUScheduleLoops() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPUScheduleLoops() {
  return impl::createTritonGPUScheduleLoops();
}
#undef GEN_PASS_DEF_TRITONGPUSCHEDULELOOPS
#endif // GEN_PASS_DEF_TRITONGPUSCHEDULELOOPS

//===----------------------------------------------------------------------===//
// TritonGPUTestPipelineLowerLoop
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUTESTPIPELINELOWERLOOP
std::unique_ptr<::mlir::Pass> createTritonGPUTestPipelineLowerLoop();
#undef GEN_PASS_DECL_TRITONGPUTESTPIPELINELOWERLOOP
#endif // GEN_PASS_DECL_TRITONGPUTESTPIPELINELOWERLOOP
#ifdef GEN_PASS_DEF_TRITONGPUTESTPIPELINELOWERLOOP

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonGPUTestPipelineLowerLoop();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonGPUTestPipelineLowerLoopBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUTestPipelineLowerLoopBase;

  TritonGPUTestPipelineLowerLoopBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUTestPipelineLowerLoopBase(const TritonGPUTestPipelineLowerLoopBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUTestPipelineLowerLoopBase& operator=(const TritonGPUTestPipelineLowerLoopBase &) = delete;
  TritonGPUTestPipelineLowerLoopBase(TritonGPUTestPipelineLowerLoopBase &&) = delete;
  TritonGPUTestPipelineLowerLoopBase& operator=(TritonGPUTestPipelineLowerLoopBase &&) = delete;
  ~TritonGPUTestPipelineLowerLoopBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-test-pipeline-lower-loop");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-test-pipeline-lower-loop"; }

  ::llvm::StringRef getDescription() const override { return R"PD(test lowering a loop for software pipelining)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUTestPipelineLowerLoop");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUTestPipelineLowerLoop"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUTestPipelineLowerLoopBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTritonGPUTestPipelineLowerLoop() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonGPUTestPipelineLowerLoop() {
  return impl::createTritonGPUTestPipelineLowerLoop();
}
#undef GEN_PASS_DEF_TRITONGPUTESTPIPELINELOWERLOOP
#endif // GEN_PASS_DEF_TRITONGPUTESTPIPELINELOWERLOOP
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// TritonGPUAccelerateMatmul Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUAccelerateMatmul() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUAccelerateMatmul();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUAccelerateMatmulPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUAccelerateMatmul();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUAssignLatencies Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUAssignLatencies() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUAssignLatencies();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUAssignLatenciesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUAssignLatencies();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUAutomaticWarpSpecialization Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUAutomaticWarpSpecialization() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUAutomaticWarpSpecialization();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUAutomaticWarpSpecializationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUAutomaticWarpSpecialization();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUCoalesce Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUCoalesce() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUCoalesce();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUCoalescePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUCoalesce();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUCoalesceAsyncCopy Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUCoalesceAsyncCopy() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUCoalesceAsyncCopy();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUCoalesceAsyncCopyPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUCoalesceAsyncCopy();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUCombineTensorSelectAndIf Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUCombineTensorSelectAndIf() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUCombineTensorSelectAndIf();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUCombineTensorSelectAndIfPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUCombineTensorSelectAndIf();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUF32DotTC Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUF32DotTC() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUF32DotTC();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUF32DotTCPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUF32DotTC();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUFuseNestedLoops Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUFuseNestedLoops() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUFuseNestedLoops();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUFuseNestedLoopsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUFuseNestedLoops();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUHoistTMEMAlloc Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUHoistTMEMAlloc() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUHoistTMEMAlloc();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUHoistTMEMAllocPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUHoistTMEMAlloc();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPULoadMMASpecialization Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPULoadMMASpecialization() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPULoadMMASpecialization();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPULoadMMASpecializationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPULoadMMASpecialization();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUOptimizeAccumulatorInit Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUOptimizeAccumulatorInit() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUOptimizeAccumulatorInit();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUOptimizeAccumulatorInitPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUOptimizeAccumulatorInit();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUOptimizeDotOperands Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUOptimizeDotOperands() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUOptimizeDotOperands();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUOptimizeDotOperandsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUOptimizeDotOperands();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUOptimizePartitionWarps Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUOptimizePartitionWarps() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUOptimizePartitionWarps();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUOptimizePartitionWarpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUOptimizePartitionWarps();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUOptimizeThreadLocality Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUOptimizeThreadLocality() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUOptimizeThreadLocality();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUOptimizeThreadLocalityPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUOptimizeThreadLocality();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUPartitionLoops Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUPartitionLoops() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUPartitionLoops();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUPartitionLoopsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUPartitionLoops();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUPartitionScheduling Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUPartitionScheduling() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUPartitionScheduling();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUPartitionSchedulingPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUPartitionScheduling();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUPipeline Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUPipeline() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUPipeline();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUPipelinePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUPipeline();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUPrefetch Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUPrefetch() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUPrefetch();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUPrefetchPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUPrefetch();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUReduceDataDuplication Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUReduceDataDuplication() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUReduceDataDuplication();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUReduceDataDuplicationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUReduceDataDuplication();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPURemoveLayoutConversions Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPURemoveLayoutConversions() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPURemoveLayoutConversions();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPURemoveLayoutConversionsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPURemoveLayoutConversions();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUReorderInstructions Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUReorderInstructions() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUReorderInstructions();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUReorderInstructionsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUReorderInstructions();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPURewritePartitionDependencies Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPURewritePartitionDependencies() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPURewritePartitionDependencies();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPURewritePartitionDependenciesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPURewritePartitionDependencies();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUScheduleLoops Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUScheduleLoops() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUScheduleLoops();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUScheduleLoopsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUScheduleLoops();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUTestPipelineLowerLoop Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUTestPipelineLowerLoop() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUTestPipelineLowerLoop();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUTestPipelineLowerLoopPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonGPUTestPipelineLowerLoop();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPU Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUPasses() {
  registerTritonGPUAccelerateMatmul();
  registerTritonGPUAssignLatencies();
  registerTritonGPUAutomaticWarpSpecialization();
  registerTritonGPUCoalesce();
  registerTritonGPUCoalesceAsyncCopy();
  registerTritonGPUCombineTensorSelectAndIf();
  registerTritonGPUF32DotTC();
  registerTritonGPUFuseNestedLoops();
  registerTritonGPUHoistTMEMAlloc();
  registerTritonGPULoadMMASpecialization();
  registerTritonGPUOptimizeAccumulatorInit();
  registerTritonGPUOptimizeDotOperands();
  registerTritonGPUOptimizePartitionWarps();
  registerTritonGPUOptimizeThreadLocality();
  registerTritonGPUPartitionLoops();
  registerTritonGPUPartitionScheduling();
  registerTritonGPUPipeline();
  registerTritonGPUPrefetch();
  registerTritonGPUReduceDataDuplication();
  registerTritonGPURemoveLayoutConversions();
  registerTritonGPUReorderInstructions();
  registerTritonGPURewritePartitionDependencies();
  registerTritonGPUScheduleLoops();
  registerTritonGPUTestPipelineLowerLoop();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class TritonGPUAccelerateMatmulBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUAccelerateMatmulBase;

  TritonGPUAccelerateMatmulBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUAccelerateMatmulBase(const TritonGPUAccelerateMatmulBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUAccelerateMatmulBase& operator=(const TritonGPUAccelerateMatmulBase &) = delete;
  TritonGPUAccelerateMatmulBase(TritonGPUAccelerateMatmulBase &&) = delete;
  TritonGPUAccelerateMatmulBase& operator=(TritonGPUAccelerateMatmulBase &&) = delete;
  ~TritonGPUAccelerateMatmulBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-accelerate-matmul");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-accelerate-matmul"; }

  ::llvm::StringRef getDescription() const override { return R"PD(accelerate matmul)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUAccelerateMatmul");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUAccelerateMatmul"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUAccelerateMatmulBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUAssignLatenciesBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUAssignLatenciesBase;

  TritonGPUAssignLatenciesBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUAssignLatenciesBase(const TritonGPUAssignLatenciesBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUAssignLatenciesBase& operator=(const TritonGPUAssignLatenciesBase &) = delete;
  TritonGPUAssignLatenciesBase(TritonGPUAssignLatenciesBase &&) = delete;
  TritonGPUAssignLatenciesBase& operator=(TritonGPUAssignLatenciesBase &&) = delete;
  ~TritonGPUAssignLatenciesBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-assign-latencies");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-assign-latencies"; }

  ::llvm::StringRef getDescription() const override { return R"PD(assign latencies to interesting ops ahead of pipelining)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUAssignLatencies");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUAssignLatencies"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUAssignLatenciesBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int32_t> numStages{*this, "num-stages", ::llvm::cl::desc(R"PO(number of pipeline stages)PO"), ::llvm::cl::init(3)};
};

template <typename DerivedT>
class TritonGPUAutomaticWarpSpecializationBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUAutomaticWarpSpecializationBase;

  TritonGPUAutomaticWarpSpecializationBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUAutomaticWarpSpecializationBase(const TritonGPUAutomaticWarpSpecializationBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUAutomaticWarpSpecializationBase& operator=(const TritonGPUAutomaticWarpSpecializationBase &) = delete;
  TritonGPUAutomaticWarpSpecializationBase(TritonGPUAutomaticWarpSpecializationBase &&) = delete;
  TritonGPUAutomaticWarpSpecializationBase& operator=(TritonGPUAutomaticWarpSpecializationBase &&) = delete;
  ~TritonGPUAutomaticWarpSpecializationBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-automatic-warp-specialization");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-automatic-warp-specialization"; }

  ::llvm::StringRef getDescription() const override { return R"PD(automatic warp specialization of loops)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUAutomaticWarpSpecialization");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUAutomaticWarpSpecialization"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
    registry.insert<triton::nvws::NVWSDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUAutomaticWarpSpecializationBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int32_t> numStages{*this, "num-stages", ::llvm::cl::desc(R"PO(number of pipeline stages)PO"), ::llvm::cl::init(3)};
};

template <typename DerivedT>
class TritonGPUCoalesceBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUCoalesceBase;

  TritonGPUCoalesceBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUCoalesceBase(const TritonGPUCoalesceBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUCoalesceBase& operator=(const TritonGPUCoalesceBase &) = delete;
  TritonGPUCoalesceBase(TritonGPUCoalesceBase &&) = delete;
  TritonGPUCoalesceBase& operator=(TritonGPUCoalesceBase &&) = delete;
  ~TritonGPUCoalesceBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-coalesce");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-coalesce"; }

  ::llvm::StringRef getDescription() const override { return R"PD(coalesce)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUCoalesce");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUCoalesce"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUCoalesceBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUCoalesceAsyncCopyBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUCoalesceAsyncCopyBase;

  TritonGPUCoalesceAsyncCopyBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUCoalesceAsyncCopyBase(const TritonGPUCoalesceAsyncCopyBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUCoalesceAsyncCopyBase& operator=(const TritonGPUCoalesceAsyncCopyBase &) = delete;
  TritonGPUCoalesceAsyncCopyBase(TritonGPUCoalesceAsyncCopyBase &&) = delete;
  TritonGPUCoalesceAsyncCopyBase& operator=(TritonGPUCoalesceAsyncCopyBase &&) = delete;
  ~TritonGPUCoalesceAsyncCopyBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-coalesce-async-copy");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-coalesce-async-copy"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Improve coalescing for async global to local copies)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUCoalesceAsyncCopy");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUCoalesceAsyncCopy"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUCoalesceAsyncCopyBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUCombineTensorSelectAndIfBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUCombineTensorSelectAndIfBase;

  TritonGPUCombineTensorSelectAndIfBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUCombineTensorSelectAndIfBase(const TritonGPUCombineTensorSelectAndIfBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUCombineTensorSelectAndIfBase& operator=(const TritonGPUCombineTensorSelectAndIfBase &) = delete;
  TritonGPUCombineTensorSelectAndIfBase(TritonGPUCombineTensorSelectAndIfBase &&) = delete;
  TritonGPUCombineTensorSelectAndIfBase& operator=(TritonGPUCombineTensorSelectAndIfBase &&) = delete;
  ~TritonGPUCombineTensorSelectAndIfBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-combine-tensor-select-and-if");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-combine-tensor-select-and-if"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Combine tensor select and if)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUCombineTensorSelectAndIf");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUCombineTensorSelectAndIf"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUCombineTensorSelectAndIfBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUF32DotTCBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUF32DotTCBase;

  TritonGPUF32DotTCBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUF32DotTCBase(const TritonGPUF32DotTCBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUF32DotTCBase& operator=(const TritonGPUF32DotTCBase &) = delete;
  TritonGPUF32DotTCBase(TritonGPUF32DotTCBase &&) = delete;
  TritonGPUF32DotTCBase& operator=(TritonGPUF32DotTCBase &&) = delete;
  ~TritonGPUF32DotTCBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-F32DotTC");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-F32DotTC"; }

  ::llvm::StringRef getDescription() const override { return R"PD(3xTF32 trick)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUF32DotTC");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUF32DotTC"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUF32DotTCBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUFuseNestedLoopsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUFuseNestedLoopsBase;

  TritonGPUFuseNestedLoopsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUFuseNestedLoopsBase(const TritonGPUFuseNestedLoopsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUFuseNestedLoopsBase& operator=(const TritonGPUFuseNestedLoopsBase &) = delete;
  TritonGPUFuseNestedLoopsBase(TritonGPUFuseNestedLoopsBase &&) = delete;
  TritonGPUFuseNestedLoopsBase& operator=(TritonGPUFuseNestedLoopsBase &&) = delete;
  ~TritonGPUFuseNestedLoopsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-fuse-nested-loops");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-fuse-nested-loops"; }

  ::llvm::StringRef getDescription() const override { return R"PD(fuse nested loops for pipelining)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUFuseNestedLoops");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUFuseNestedLoops"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::ub::UBDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUFuseNestedLoopsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUHoistTMEMAllocBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUHoistTMEMAllocBase;

  TritonGPUHoistTMEMAllocBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUHoistTMEMAllocBase(const TritonGPUHoistTMEMAllocBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUHoistTMEMAllocBase& operator=(const TritonGPUHoistTMEMAllocBase &) = delete;
  TritonGPUHoistTMEMAllocBase(TritonGPUHoistTMEMAllocBase &&) = delete;
  TritonGPUHoistTMEMAllocBase& operator=(TritonGPUHoistTMEMAllocBase &&) = delete;
  ~TritonGPUHoistTMEMAllocBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-hoist-tmem-alloc");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-hoist-tmem-alloc"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Hoist TMEM allocations out of the loop. This is a preparation for the loop lowering.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUHoistTMEMAlloc");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUHoistTMEMAlloc"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUHoistTMEMAllocBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> hoistOutOfIf{*this, "hoist-out-of-if", ::llvm::cl::desc(R"PO(Hoist TMEM allocations out of if statements)PO"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class TritonGPULoadMMASpecializationBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPULoadMMASpecializationBase;

  TritonGPULoadMMASpecializationBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPULoadMMASpecializationBase(const TritonGPULoadMMASpecializationBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPULoadMMASpecializationBase& operator=(const TritonGPULoadMMASpecializationBase &) = delete;
  TritonGPULoadMMASpecializationBase(TritonGPULoadMMASpecializationBase &&) = delete;
  TritonGPULoadMMASpecializationBase& operator=(TritonGPULoadMMASpecializationBase &&) = delete;
  ~TritonGPULoadMMASpecializationBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-load-mma-specialization");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-load-mma-specialization"; }

  ::llvm::StringRef getDescription() const override { return R"PD(load MMA specialization)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPULoadMMASpecialization");
  }
  ::llvm::StringRef getName() const override { return "TritonGPULoadMMASpecialization"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPULoadMMASpecializationBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int32_t> numStages{*this, "num-stages", ::llvm::cl::desc(R"PO(number of pipeline stages)PO"), ::llvm::cl::init(3)};
};

template <typename DerivedT>
class TritonGPUOptimizeAccumulatorInitBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUOptimizeAccumulatorInitBase;

  TritonGPUOptimizeAccumulatorInitBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUOptimizeAccumulatorInitBase(const TritonGPUOptimizeAccumulatorInitBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUOptimizeAccumulatorInitBase& operator=(const TritonGPUOptimizeAccumulatorInitBase &) = delete;
  TritonGPUOptimizeAccumulatorInitBase(TritonGPUOptimizeAccumulatorInitBase &&) = delete;
  TritonGPUOptimizeAccumulatorInitBase& operator=(TritonGPUOptimizeAccumulatorInitBase &&) = delete;
  ~TritonGPUOptimizeAccumulatorInitBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-optimize-accumulator-init");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-optimize-accumulator-init"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Replace accumulator zero-initialization with the flag indicating first use of the accumulator)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUOptimizeAccumulatorInit");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUOptimizeAccumulatorInit"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUOptimizeAccumulatorInitBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUOptimizeDotOperandsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUOptimizeDotOperandsBase;

  TritonGPUOptimizeDotOperandsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUOptimizeDotOperandsBase(const TritonGPUOptimizeDotOperandsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUOptimizeDotOperandsBase& operator=(const TritonGPUOptimizeDotOperandsBase &) = delete;
  TritonGPUOptimizeDotOperandsBase(TritonGPUOptimizeDotOperandsBase &&) = delete;
  TritonGPUOptimizeDotOperandsBase& operator=(TritonGPUOptimizeDotOperandsBase &&) = delete;
  ~TritonGPUOptimizeDotOperandsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-optimize-dot-operands");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-optimize-dot-operands"; }

  ::llvm::StringRef getDescription() const override { return R"PD(fuse transpositions)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUOptimizeDotOperands");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUOptimizeDotOperands"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUOptimizeDotOperandsBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> hoistLayoutConversion{*this, "hoist-layout-conversion", ::llvm::cl::desc(R"PO(whether to move conver to dot operand earlier pass elementwise ops)PO"), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class TritonGPUOptimizePartitionWarpsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUOptimizePartitionWarpsBase;

  TritonGPUOptimizePartitionWarpsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUOptimizePartitionWarpsBase(const TritonGPUOptimizePartitionWarpsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUOptimizePartitionWarpsBase& operator=(const TritonGPUOptimizePartitionWarpsBase &) = delete;
  TritonGPUOptimizePartitionWarpsBase(TritonGPUOptimizePartitionWarpsBase &&) = delete;
  TritonGPUOptimizePartitionWarpsBase& operator=(TritonGPUOptimizePartitionWarpsBase &&) = delete;
  ~TritonGPUOptimizePartitionWarpsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-optimize-partition-warps");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-optimize-partition-warps"; }

  ::llvm::StringRef getDescription() const override { return R"PD(optimize the number of warps assigned to partitions)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUOptimizePartitionWarps");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUOptimizePartitionWarps"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUOptimizePartitionWarpsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUOptimizeThreadLocalityBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUOptimizeThreadLocalityBase;

  TritonGPUOptimizeThreadLocalityBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUOptimizeThreadLocalityBase(const TritonGPUOptimizeThreadLocalityBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUOptimizeThreadLocalityBase& operator=(const TritonGPUOptimizeThreadLocalityBase &) = delete;
  TritonGPUOptimizeThreadLocalityBase(TritonGPUOptimizeThreadLocalityBase &&) = delete;
  TritonGPUOptimizeThreadLocalityBase& operator=(TritonGPUOptimizeThreadLocalityBase &&) = delete;
  ~TritonGPUOptimizeThreadLocalityBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-optimize-thread-locality");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-optimize-thread-locality"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Reduce the cost of synchronization between threads in an SM)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUOptimizeThreadLocality");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUOptimizeThreadLocality"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUOptimizeThreadLocalityBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUPartitionLoopsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUPartitionLoopsBase;

  TritonGPUPartitionLoopsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUPartitionLoopsBase(const TritonGPUPartitionLoopsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUPartitionLoopsBase& operator=(const TritonGPUPartitionLoopsBase &) = delete;
  TritonGPUPartitionLoopsBase(TritonGPUPartitionLoopsBase &&) = delete;
  TritonGPUPartitionLoopsBase& operator=(TritonGPUPartitionLoopsBase &&) = delete;
  ~TritonGPUPartitionLoopsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-partition-loops");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-partition-loops"; }

  ::llvm::StringRef getDescription() const override { return R"PD(split scheduled loops into `ttg.warp_specialize`)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUPartitionLoops");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUPartitionLoops"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<triton::nvws::NVWSDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUPartitionLoopsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUPartitionSchedulingBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUPartitionSchedulingBase;

  TritonGPUPartitionSchedulingBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUPartitionSchedulingBase(const TritonGPUPartitionSchedulingBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUPartitionSchedulingBase& operator=(const TritonGPUPartitionSchedulingBase &) = delete;
  TritonGPUPartitionSchedulingBase(TritonGPUPartitionSchedulingBase &&) = delete;
  TritonGPUPartitionSchedulingBase& operator=(TritonGPUPartitionSchedulingBase &&) = delete;
  ~TritonGPUPartitionSchedulingBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-partition-scheduling");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-partition-scheduling"; }

  ::llvm::StringRef getDescription() const override { return R"PD(warp specialization partitioning pass)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUPartitionScheduling");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUPartitionScheduling"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUPartitionSchedulingBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUPipelineBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUPipelineBase;

  TritonGPUPipelineBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUPipelineBase(const TritonGPUPipelineBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUPipelineBase& operator=(const TritonGPUPipelineBase &) = delete;
  TritonGPUPipelineBase(TritonGPUPipelineBase &&) = delete;
  TritonGPUPipelineBase& operator=(TritonGPUPipelineBase &&) = delete;
  ~TritonGPUPipelineBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-pipeline");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-pipeline"; }

  ::llvm::StringRef getDescription() const override { return R"PD(pipeline)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUPipeline");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUPipeline"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUPipelineBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int32_t> numStages{*this, "num-stages", ::llvm::cl::desc(R"PO(number of pipeline stages)PO"), ::llvm::cl::init(3)};
  ::mlir::Pass::Option<bool> dumpIntermediateSteps{*this, "dump-intermediate-steps", ::llvm::cl::desc(R"PO(Dump intermediate steps)PO"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class TritonGPUPrefetchBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUPrefetchBase;

  TritonGPUPrefetchBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUPrefetchBase(const TritonGPUPrefetchBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUPrefetchBase& operator=(const TritonGPUPrefetchBase &) = delete;
  TritonGPUPrefetchBase(TritonGPUPrefetchBase &&) = delete;
  TritonGPUPrefetchBase& operator=(TritonGPUPrefetchBase &&) = delete;
  ~TritonGPUPrefetchBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-prefetch");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-prefetch"; }

  ::llvm::StringRef getDescription() const override { return R"PD(prefetch)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUPrefetch");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUPrefetch"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUPrefetchBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUReduceDataDuplicationBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUReduceDataDuplicationBase;

  TritonGPUReduceDataDuplicationBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUReduceDataDuplicationBase(const TritonGPUReduceDataDuplicationBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUReduceDataDuplicationBase& operator=(const TritonGPUReduceDataDuplicationBase &) = delete;
  TritonGPUReduceDataDuplicationBase(TritonGPUReduceDataDuplicationBase &&) = delete;
  TritonGPUReduceDataDuplicationBase& operator=(TritonGPUReduceDataDuplicationBase &&) = delete;
  ~TritonGPUReduceDataDuplicationBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-reduce-data-duplication");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-reduce-data-duplication"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Reduce data duplication in register by decomposing convert[distributed -> dotOperand] into convert[distributed -> shared -> dotOperand])PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUReduceDataDuplication");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUReduceDataDuplication"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUReduceDataDuplicationBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPURemoveLayoutConversionsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPURemoveLayoutConversionsBase;

  TritonGPURemoveLayoutConversionsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPURemoveLayoutConversionsBase(const TritonGPURemoveLayoutConversionsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPURemoveLayoutConversionsBase& operator=(const TritonGPURemoveLayoutConversionsBase &) = delete;
  TritonGPURemoveLayoutConversionsBase(TritonGPURemoveLayoutConversionsBase &&) = delete;
  TritonGPURemoveLayoutConversionsBase& operator=(TritonGPURemoveLayoutConversionsBase &&) = delete;
  ~TritonGPURemoveLayoutConversionsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-remove-layout-conversions");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-remove-layout-conversions"; }

  ::llvm::StringRef getDescription() const override { return R"PD(remove superfluous layout conversions)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPURemoveLayoutConversions");
  }
  ::llvm::StringRef getName() const override { return "TritonGPURemoveLayoutConversions"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPURemoveLayoutConversionsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUReorderInstructionsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUReorderInstructionsBase;

  TritonGPUReorderInstructionsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUReorderInstructionsBase(const TritonGPUReorderInstructionsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUReorderInstructionsBase& operator=(const TritonGPUReorderInstructionsBase &) = delete;
  TritonGPUReorderInstructionsBase(TritonGPUReorderInstructionsBase &&) = delete;
  TritonGPUReorderInstructionsBase& operator=(TritonGPUReorderInstructionsBase &&) = delete;
  ~TritonGPUReorderInstructionsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-reorder-instructions");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-reorder-instructions"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Reorder instructions)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUReorderInstructions");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUReorderInstructions"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUReorderInstructionsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPURewritePartitionDependenciesBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPURewritePartitionDependenciesBase;

  TritonGPURewritePartitionDependenciesBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPURewritePartitionDependenciesBase(const TritonGPURewritePartitionDependenciesBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPURewritePartitionDependenciesBase& operator=(const TritonGPURewritePartitionDependenciesBase &) = delete;
  TritonGPURewritePartitionDependenciesBase(TritonGPURewritePartitionDependenciesBase &&) = delete;
  TritonGPURewritePartitionDependenciesBase& operator=(TritonGPURewritePartitionDependenciesBase &&) = delete;
  ~TritonGPURewritePartitionDependenciesBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-rewrite-partition-dependencies");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-rewrite-partition-dependencies"; }

  ::llvm::StringRef getDescription() const override { return R"PD(test pass for rewriting partition dependencies)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPURewritePartitionDependencies");
  }
  ::llvm::StringRef getName() const override { return "TritonGPURewritePartitionDependencies"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
    registry.insert<mlir::triton::nvws::NVWSDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPURewritePartitionDependenciesBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUScheduleLoopsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUScheduleLoopsBase;

  TritonGPUScheduleLoopsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUScheduleLoopsBase(const TritonGPUScheduleLoopsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUScheduleLoopsBase& operator=(const TritonGPUScheduleLoopsBase &) = delete;
  TritonGPUScheduleLoopsBase(TritonGPUScheduleLoopsBase &&) = delete;
  TritonGPUScheduleLoopsBase& operator=(TritonGPUScheduleLoopsBase &&) = delete;
  ~TritonGPUScheduleLoopsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-schedule-loops");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-schedule-loops"; }

  ::llvm::StringRef getDescription() const override { return R"PD(software pipeline loop scheduling)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUScheduleLoops");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUScheduleLoops"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUScheduleLoopsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUTestPipelineLowerLoopBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUTestPipelineLowerLoopBase;

  TritonGPUTestPipelineLowerLoopBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUTestPipelineLowerLoopBase(const TritonGPUTestPipelineLowerLoopBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonGPUTestPipelineLowerLoopBase& operator=(const TritonGPUTestPipelineLowerLoopBase &) = delete;
  TritonGPUTestPipelineLowerLoopBase(TritonGPUTestPipelineLowerLoopBase &&) = delete;
  TritonGPUTestPipelineLowerLoopBase& operator=(TritonGPUTestPipelineLowerLoopBase &&) = delete;
  ~TritonGPUTestPipelineLowerLoopBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-test-pipeline-lower-loop");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-test-pipeline-lower-loop"; }

  ::llvm::StringRef getDescription() const override { return R"PD(test lowering a loop for software pipelining)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUTestPipelineLowerLoop");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUTestPipelineLowerLoop"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::triton::nvidia_gpu::TritonNvidiaGPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUTestPipelineLowerLoopBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
