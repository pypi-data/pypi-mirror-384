/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_TOSAATTACHTARGET
#define GEN_PASS_DECL_TOSACONVERTINTEGERTYPETOSIGNLESS
#define GEN_PASS_DECL_TOSAINFERSHAPESPASS
#define GEN_PASS_DECL_TOSALAYERWISECONSTANTFOLDPASS
#define GEN_PASS_DECL_TOSAMAKEBROADCASTABLEPASS
#define GEN_PASS_DECL_TOSAOPTIONALDECOMPOSITIONSPASS
#define GEN_PASS_DECL_TOSAREDUCETRANSPOSES
#define GEN_PASS_DECL_TOSAVALIDATION
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// TosaAttachTarget
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSAATTACHTARGET
struct TosaAttachTargetOptions {
  mlir::tosa::Level level = mlir::tosa::Level::eightK;
  ::llvm::SmallVector<std::string> profiles;
  ::llvm::SmallVector<std::string> extensions;
};
std::unique_ptr<::mlir::Pass> createTosaAttachTarget();
std::unique_ptr<::mlir::Pass> createTosaAttachTarget(TosaAttachTargetOptions options);
#undef GEN_PASS_DECL_TOSAATTACHTARGET
#endif // GEN_PASS_DECL_TOSAATTACHTARGET
#ifdef GEN_PASS_DEF_TOSAATTACHTARGET

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaAttachTarget();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaAttachTarget(TosaAttachTargetOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaAttachTargetBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TosaAttachTargetBase;

  TosaAttachTargetBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaAttachTargetBase(const TosaAttachTargetBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TosaAttachTargetBase& operator=(const TosaAttachTargetBase &) = delete;
  TosaAttachTargetBase(TosaAttachTargetBase &&) = delete;
  TosaAttachTargetBase& operator=(TosaAttachTargetBase &&) = delete;
  ~TosaAttachTargetBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-attach-target");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-attach-target"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Attach tosa.target_env information to the given module.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaAttachTarget");
  }
  ::llvm::StringRef getName() const override { return "TosaAttachTarget"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<func::FuncDialect>();
    registry.insert<tosa::TosaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaAttachTargetBase<DerivedT>)

  TosaAttachTargetBase(TosaAttachTargetOptions options) : TosaAttachTargetBase() {
    level = std::move(options.level);
    profiles = std::move(options.profiles);
    extensions = std::move(options.extensions);
  }
protected:
  ::mlir::Pass::Option<mlir::tosa::Level> level{*this, "level", ::llvm::cl::desc(R"PO(The TOSA level that operators should conform to. A TOSA level defines operator argument ranges that an implementation shall support.)PO"), ::llvm::cl::init(mlir::tosa::Level::eightK), ::llvm::cl::values(
                clEnumValN(mlir::tosa::Level::eightK, "8k",
                  "Ranges are expected to be sufficient for applications with frame "
                  "sizes up to 8K."),
                clEnumValN(mlir::tosa::Level::none, "none",
                  "Allows the full range of arguments specified by the operations according "
                  "to the operation data types.")
                )};
  ::mlir::Pass::ListOption<std::string> profiles{*this, "profiles", ::llvm::cl::desc(R"PO(The TOSA profile(s) that operators should conform to. TOSA profiles enable efficient implementation on different classes of device. Each profile is an independent set of operations and data type combinations.)PO")};
  ::mlir::Pass::ListOption<std::string> extensions{*this, "extensions", ::llvm::cl::desc(R"PO(The TOSA extension(s) that operators should conform to. TOSA profile extensions define optional operation and data type combinations.)PO")};
private:

  friend std::unique_ptr<::mlir::Pass> createTosaAttachTarget() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createTosaAttachTarget(TosaAttachTargetOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaAttachTarget() {
  return impl::createTosaAttachTarget();
}

std::unique_ptr<::mlir::Pass> createTosaAttachTarget(TosaAttachTargetOptions options) {
  return impl::createTosaAttachTarget(std::move(options));
}
#undef GEN_PASS_DEF_TOSAATTACHTARGET
#endif // GEN_PASS_DEF_TOSAATTACHTARGET

//===----------------------------------------------------------------------===//
// TosaConvertIntegerTypeToSignless
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSACONVERTINTEGERTYPETOSIGNLESS
std::unique_ptr<::mlir::Pass> createTosaConvertIntegerTypeToSignless();
#undef GEN_PASS_DECL_TOSACONVERTINTEGERTYPETOSIGNLESS
#endif // GEN_PASS_DECL_TOSACONVERTINTEGERTYPETOSIGNLESS
#ifdef GEN_PASS_DEF_TOSACONVERTINTEGERTYPETOSIGNLESS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaConvertIntegerTypeToSignless();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaConvertIntegerTypeToSignlessBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaConvertIntegerTypeToSignlessBase;

  TosaConvertIntegerTypeToSignlessBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaConvertIntegerTypeToSignlessBase(const TosaConvertIntegerTypeToSignlessBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaConvertIntegerTypeToSignlessBase& operator=(const TosaConvertIntegerTypeToSignlessBase &) = delete;
  TosaConvertIntegerTypeToSignlessBase(TosaConvertIntegerTypeToSignlessBase &&) = delete;
  TosaConvertIntegerTypeToSignlessBase& operator=(TosaConvertIntegerTypeToSignlessBase &&) = delete;
  ~TosaConvertIntegerTypeToSignlessBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-convert-integer-type-to-signless");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-convert-integer-type-to-signless"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Convert integer types to signless)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaConvertIntegerTypeToSignless");
  }
  ::llvm::StringRef getName() const override { return "TosaConvertIntegerTypeToSignless"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaConvertIntegerTypeToSignlessBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTosaConvertIntegerTypeToSignless() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaConvertIntegerTypeToSignless() {
  return impl::createTosaConvertIntegerTypeToSignless();
}
#undef GEN_PASS_DEF_TOSACONVERTINTEGERTYPETOSIGNLESS
#endif // GEN_PASS_DEF_TOSACONVERTINTEGERTYPETOSIGNLESS

//===----------------------------------------------------------------------===//
// TosaInferShapesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSAINFERSHAPESPASS
std::unique_ptr<::mlir::Pass> createTosaInferShapesPass();
#undef GEN_PASS_DECL_TOSAINFERSHAPESPASS
#endif // GEN_PASS_DECL_TOSAINFERSHAPESPASS
#ifdef GEN_PASS_DEF_TOSAINFERSHAPESPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaInferShapesPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaInferShapesPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaInferShapesPassBase;

  TosaInferShapesPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaInferShapesPassBase(const TosaInferShapesPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaInferShapesPassBase& operator=(const TosaInferShapesPassBase &) = delete;
  TosaInferShapesPassBase(TosaInferShapesPassBase &&) = delete;
  TosaInferShapesPassBase& operator=(TosaInferShapesPassBase &&) = delete;
  ~TosaInferShapesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-infer-shapes");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-infer-shapes"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Propagate shapes across TOSA operations)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaInferShapesPass");
  }
  ::llvm::StringRef getName() const override { return "TosaInferShapesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<func::FuncDialect>();
    registry.insert<tensor::TensorDialect>();
    registry.insert<tosa::TosaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaInferShapesPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTosaInferShapesPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaInferShapesPass() {
  return impl::createTosaInferShapesPass();
}
#undef GEN_PASS_DEF_TOSAINFERSHAPESPASS
#endif // GEN_PASS_DEF_TOSAINFERSHAPESPASS

//===----------------------------------------------------------------------===//
// TosaLayerwiseConstantFoldPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSALAYERWISECONSTANTFOLDPASS
struct TosaLayerwiseConstantFoldPassOptions {
  bool aggressiveReduceConstant = false;
};
std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass();
std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass(TosaLayerwiseConstantFoldPassOptions options);
#undef GEN_PASS_DECL_TOSALAYERWISECONSTANTFOLDPASS
#endif // GEN_PASS_DECL_TOSALAYERWISECONSTANTFOLDPASS
#ifdef GEN_PASS_DEF_TOSALAYERWISECONSTANTFOLDPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass(TosaLayerwiseConstantFoldPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaLayerwiseConstantFoldPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaLayerwiseConstantFoldPassBase;

  TosaLayerwiseConstantFoldPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaLayerwiseConstantFoldPassBase(const TosaLayerwiseConstantFoldPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaLayerwiseConstantFoldPassBase& operator=(const TosaLayerwiseConstantFoldPassBase &) = delete;
  TosaLayerwiseConstantFoldPassBase(TosaLayerwiseConstantFoldPassBase &&) = delete;
  TosaLayerwiseConstantFoldPassBase& operator=(TosaLayerwiseConstantFoldPassBase &&) = delete;
  ~TosaLayerwiseConstantFoldPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-layerwise-constant-fold");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-layerwise-constant-fold"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Fold layerwise operations on constant tensors)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaLayerwiseConstantFoldPass");
  }
  ::llvm::StringRef getName() const override { return "TosaLayerwiseConstantFoldPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaLayerwiseConstantFoldPassBase<DerivedT>)

  TosaLayerwiseConstantFoldPassBase(TosaLayerwiseConstantFoldPassOptions options) : TosaLayerwiseConstantFoldPassBase() {
    aggressiveReduceConstant = std::move(options.aggressiveReduceConstant);
  }
protected:
  ::mlir::Pass::Option<bool> aggressiveReduceConstant{*this, "aggressive-reduce-constant", ::llvm::cl::desc(R"PO(Always perform the reduce constant optimizationMay add more tosa.const but would reduce runtime calculations)PO"), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass(TosaLayerwiseConstantFoldPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass() {
  return impl::createTosaLayerwiseConstantFoldPass();
}

std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass(TosaLayerwiseConstantFoldPassOptions options) {
  return impl::createTosaLayerwiseConstantFoldPass(std::move(options));
}
#undef GEN_PASS_DEF_TOSALAYERWISECONSTANTFOLDPASS
#endif // GEN_PASS_DEF_TOSALAYERWISECONSTANTFOLDPASS

//===----------------------------------------------------------------------===//
// TosaMakeBroadcastablePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSAMAKEBROADCASTABLEPASS
std::unique_ptr<::mlir::Pass> createTosaMakeBroadcastablePass();
#undef GEN_PASS_DECL_TOSAMAKEBROADCASTABLEPASS
#endif // GEN_PASS_DECL_TOSAMAKEBROADCASTABLEPASS
#ifdef GEN_PASS_DEF_TOSAMAKEBROADCASTABLEPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaMakeBroadcastablePass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaMakeBroadcastablePassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaMakeBroadcastablePassBase;

  TosaMakeBroadcastablePassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaMakeBroadcastablePassBase(const TosaMakeBroadcastablePassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaMakeBroadcastablePassBase& operator=(const TosaMakeBroadcastablePassBase &) = delete;
  TosaMakeBroadcastablePassBase(TosaMakeBroadcastablePassBase &&) = delete;
  TosaMakeBroadcastablePassBase& operator=(TosaMakeBroadcastablePassBase &&) = delete;
  ~TosaMakeBroadcastablePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-make-broadcastable");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-make-broadcastable"; }

  ::llvm::StringRef getDescription() const override { return R"PD(TOSA rank Reshape to enable Broadcasting)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaMakeBroadcastablePass");
  }
  ::llvm::StringRef getName() const override { return "TosaMakeBroadcastablePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaMakeBroadcastablePassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTosaMakeBroadcastablePass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaMakeBroadcastablePass() {
  return impl::createTosaMakeBroadcastablePass();
}
#undef GEN_PASS_DEF_TOSAMAKEBROADCASTABLEPASS
#endif // GEN_PASS_DEF_TOSAMAKEBROADCASTABLEPASS

//===----------------------------------------------------------------------===//
// TosaOptionalDecompositionsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSAOPTIONALDECOMPOSITIONSPASS
std::unique_ptr<::mlir::Pass> createTosaOptionalDecompositionsPass();
#undef GEN_PASS_DECL_TOSAOPTIONALDECOMPOSITIONSPASS
#endif // GEN_PASS_DECL_TOSAOPTIONALDECOMPOSITIONSPASS
#ifdef GEN_PASS_DEF_TOSAOPTIONALDECOMPOSITIONSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaOptionalDecompositionsPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaOptionalDecompositionsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaOptionalDecompositionsPassBase;

  TosaOptionalDecompositionsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaOptionalDecompositionsPassBase(const TosaOptionalDecompositionsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaOptionalDecompositionsPassBase& operator=(const TosaOptionalDecompositionsPassBase &) = delete;
  TosaOptionalDecompositionsPassBase(TosaOptionalDecompositionsPassBase &&) = delete;
  TosaOptionalDecompositionsPassBase& operator=(TosaOptionalDecompositionsPassBase &&) = delete;
  ~TosaOptionalDecompositionsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-optional-decompositions");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-optional-decompositions"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Applies Tosa operations optional decompositions)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaOptionalDecompositionsPass");
  }
  ::llvm::StringRef getName() const override { return "TosaOptionalDecompositionsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaOptionalDecompositionsPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTosaOptionalDecompositionsPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaOptionalDecompositionsPass() {
  return impl::createTosaOptionalDecompositionsPass();
}
#undef GEN_PASS_DEF_TOSAOPTIONALDECOMPOSITIONSPASS
#endif // GEN_PASS_DEF_TOSAOPTIONALDECOMPOSITIONSPASS

//===----------------------------------------------------------------------===//
// TosaReduceTransposes
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSAREDUCETRANSPOSES
std::unique_ptr<::mlir::Pass> createTosaReduceTransposes();
#undef GEN_PASS_DECL_TOSAREDUCETRANSPOSES
#endif // GEN_PASS_DECL_TOSAREDUCETRANSPOSES
#ifdef GEN_PASS_DEF_TOSAREDUCETRANSPOSES

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaReduceTransposes();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaReduceTransposesBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaReduceTransposesBase;

  TosaReduceTransposesBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaReduceTransposesBase(const TosaReduceTransposesBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaReduceTransposesBase& operator=(const TosaReduceTransposesBase &) = delete;
  TosaReduceTransposesBase(TosaReduceTransposesBase &&) = delete;
  TosaReduceTransposesBase& operator=(TosaReduceTransposesBase &&) = delete;
  ~TosaReduceTransposesBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-reduce-transposes");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-reduce-transposes"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Reduce transposes through other operators)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaReduceTransposes");
  }
  ::llvm::StringRef getName() const override { return "TosaReduceTransposes"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaReduceTransposesBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTosaReduceTransposes() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaReduceTransposes() {
  return impl::createTosaReduceTransposes();
}
#undef GEN_PASS_DEF_TOSAREDUCETRANSPOSES
#endif // GEN_PASS_DEF_TOSAREDUCETRANSPOSES

//===----------------------------------------------------------------------===//
// TosaValidation
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSAVALIDATION
struct TosaValidationOptions {
  bool strictOpSpecAlignment = false;
  bool allowInvalidOpDatatypeCombinations = false;
};
std::unique_ptr<::mlir::Pass> createTosaValidation();
std::unique_ptr<::mlir::Pass> createTosaValidation(TosaValidationOptions options);
#undef GEN_PASS_DECL_TOSAVALIDATION
#endif // GEN_PASS_DECL_TOSAVALIDATION
#ifdef GEN_PASS_DEF_TOSAVALIDATION

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaValidation();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaValidation(TosaValidationOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaValidationBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TosaValidationBase;

  TosaValidationBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaValidationBase(const TosaValidationBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TosaValidationBase& operator=(const TosaValidationBase &) = delete;
  TosaValidationBase(TosaValidationBase &&) = delete;
  TosaValidationBase& operator=(TosaValidationBase &&) = delete;
  ~TosaValidationBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-validate");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-validate"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Validates TOSA dialect)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaValidation");
  }
  ::llvm::StringRef getName() const override { return "TosaValidation"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaValidationBase<DerivedT>)

  TosaValidationBase(TosaValidationOptions options) : TosaValidationBase() {
    strictOpSpecAlignment = std::move(options.strictOpSpecAlignment);
    allowInvalidOpDatatypeCombinations = std::move(options.allowInvalidOpDatatypeCombinations);
  }
protected:
  ::mlir::Pass::Option<bool> strictOpSpecAlignment{*this, "strict-op-spec-alignment", ::llvm::cl::desc(R"PO(Verify if the properties of certain operations align the spec requirement)PO"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> allowInvalidOpDatatypeCombinations{*this, "allow-invalid-op-datatype-combinations", ::llvm::cl::desc(R"PO(Disable checks for operations that are determined to be invalid due to their operand/result datatypes not aligning with the 'Supported Data Types' sections of the specifciation)PO"), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createTosaValidation() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createTosaValidation(TosaValidationOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaValidation() {
  return impl::createTosaValidation();
}

std::unique_ptr<::mlir::Pass> createTosaValidation(TosaValidationOptions options) {
  return impl::createTosaValidation(std::move(options));
}
#undef GEN_PASS_DEF_TOSAVALIDATION
#endif // GEN_PASS_DEF_TOSAVALIDATION
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// TosaAttachTarget Registration
//===----------------------------------------------------------------------===//

inline void registerTosaAttachTarget() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaAttachTarget();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaAttachTargetPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaAttachTarget();
  });
}

//===----------------------------------------------------------------------===//
// TosaConvertIntegerTypeToSignless Registration
//===----------------------------------------------------------------------===//

inline void registerTosaConvertIntegerTypeToSignless() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaConvertIntegerTypeToSignless();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaConvertIntegerTypeToSignlessPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaConvertIntegerTypeToSignless();
  });
}

//===----------------------------------------------------------------------===//
// TosaInferShapesPass Registration
//===----------------------------------------------------------------------===//

inline void registerTosaInferShapesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaInferShapesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaInferShapesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaInferShapesPass();
  });
}

//===----------------------------------------------------------------------===//
// TosaLayerwiseConstantFoldPass Registration
//===----------------------------------------------------------------------===//

inline void registerTosaLayerwiseConstantFoldPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaLayerwiseConstantFoldPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaLayerwiseConstantFoldPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaLayerwiseConstantFoldPass();
  });
}

//===----------------------------------------------------------------------===//
// TosaMakeBroadcastablePass Registration
//===----------------------------------------------------------------------===//

inline void registerTosaMakeBroadcastablePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaMakeBroadcastablePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaMakeBroadcastablePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaMakeBroadcastablePass();
  });
}

//===----------------------------------------------------------------------===//
// TosaOptionalDecompositionsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTosaOptionalDecompositionsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaOptionalDecompositionsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaOptionalDecompositionsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaOptionalDecompositionsPass();
  });
}

//===----------------------------------------------------------------------===//
// TosaReduceTransposes Registration
//===----------------------------------------------------------------------===//

inline void registerTosaReduceTransposes() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaReduceTransposes();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaReduceTransposesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaReduceTransposes();
  });
}

//===----------------------------------------------------------------------===//
// TosaValidation Registration
//===----------------------------------------------------------------------===//

inline void registerTosaValidation() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaValidation();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaValidationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaValidation();
  });
}

//===----------------------------------------------------------------------===//
// TosaOpt Registration
//===----------------------------------------------------------------------===//

inline void registerTosaOptPasses() {
  registerTosaAttachTarget();
  registerTosaConvertIntegerTypeToSignless();
  registerTosaInferShapesPass();
  registerTosaLayerwiseConstantFoldPass();
  registerTosaMakeBroadcastablePass();
  registerTosaOptionalDecompositionsPass();
  registerTosaReduceTransposes();
  registerTosaValidation();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class TosaAttachTargetBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TosaAttachTargetBase;

  TosaAttachTargetBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaAttachTargetBase(const TosaAttachTargetBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TosaAttachTargetBase& operator=(const TosaAttachTargetBase &) = delete;
  TosaAttachTargetBase(TosaAttachTargetBase &&) = delete;
  TosaAttachTargetBase& operator=(TosaAttachTargetBase &&) = delete;
  ~TosaAttachTargetBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-attach-target");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-attach-target"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Attach tosa.target_env information to the given module.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaAttachTarget");
  }
  ::llvm::StringRef getName() const override { return "TosaAttachTarget"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<func::FuncDialect>();
    registry.insert<tosa::TosaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaAttachTargetBase<DerivedT>)

protected:
  ::mlir::Pass::Option<mlir::tosa::Level> level{*this, "level", ::llvm::cl::desc(R"PO(The TOSA level that operators should conform to. A TOSA level defines operator argument ranges that an implementation shall support.)PO"), ::llvm::cl::init(mlir::tosa::Level::eightK), ::llvm::cl::values(
                clEnumValN(mlir::tosa::Level::eightK, "8k",
                  "Ranges are expected to be sufficient for applications with frame "
                  "sizes up to 8K."),
                clEnumValN(mlir::tosa::Level::none, "none",
                  "Allows the full range of arguments specified by the operations according "
                  "to the operation data types.")
                )};
  ::mlir::Pass::ListOption<std::string> profiles{*this, "profiles", ::llvm::cl::desc(R"PO(The TOSA profile(s) that operators should conform to. TOSA profiles enable efficient implementation on different classes of device. Each profile is an independent set of operations and data type combinations.)PO")};
  ::mlir::Pass::ListOption<std::string> extensions{*this, "extensions", ::llvm::cl::desc(R"PO(The TOSA extension(s) that operators should conform to. TOSA profile extensions define optional operation and data type combinations.)PO")};
};

template <typename DerivedT>
class TosaConvertIntegerTypeToSignlessBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaConvertIntegerTypeToSignlessBase;

  TosaConvertIntegerTypeToSignlessBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaConvertIntegerTypeToSignlessBase(const TosaConvertIntegerTypeToSignlessBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaConvertIntegerTypeToSignlessBase& operator=(const TosaConvertIntegerTypeToSignlessBase &) = delete;
  TosaConvertIntegerTypeToSignlessBase(TosaConvertIntegerTypeToSignlessBase &&) = delete;
  TosaConvertIntegerTypeToSignlessBase& operator=(TosaConvertIntegerTypeToSignlessBase &&) = delete;
  ~TosaConvertIntegerTypeToSignlessBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-convert-integer-type-to-signless");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-convert-integer-type-to-signless"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Convert integer types to signless)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaConvertIntegerTypeToSignless");
  }
  ::llvm::StringRef getName() const override { return "TosaConvertIntegerTypeToSignless"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaConvertIntegerTypeToSignlessBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TosaInferShapesPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaInferShapesPassBase;

  TosaInferShapesPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaInferShapesPassBase(const TosaInferShapesPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaInferShapesPassBase& operator=(const TosaInferShapesPassBase &) = delete;
  TosaInferShapesPassBase(TosaInferShapesPassBase &&) = delete;
  TosaInferShapesPassBase& operator=(TosaInferShapesPassBase &&) = delete;
  ~TosaInferShapesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-infer-shapes");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-infer-shapes"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Propagate shapes across TOSA operations)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaInferShapesPass");
  }
  ::llvm::StringRef getName() const override { return "TosaInferShapesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<func::FuncDialect>();
    registry.insert<tensor::TensorDialect>();
    registry.insert<tosa::TosaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaInferShapesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TosaLayerwiseConstantFoldPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaLayerwiseConstantFoldPassBase;

  TosaLayerwiseConstantFoldPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaLayerwiseConstantFoldPassBase(const TosaLayerwiseConstantFoldPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaLayerwiseConstantFoldPassBase& operator=(const TosaLayerwiseConstantFoldPassBase &) = delete;
  TosaLayerwiseConstantFoldPassBase(TosaLayerwiseConstantFoldPassBase &&) = delete;
  TosaLayerwiseConstantFoldPassBase& operator=(TosaLayerwiseConstantFoldPassBase &&) = delete;
  ~TosaLayerwiseConstantFoldPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-layerwise-constant-fold");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-layerwise-constant-fold"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Fold layerwise operations on constant tensors)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaLayerwiseConstantFoldPass");
  }
  ::llvm::StringRef getName() const override { return "TosaLayerwiseConstantFoldPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaLayerwiseConstantFoldPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> aggressiveReduceConstant{*this, "aggressive-reduce-constant", ::llvm::cl::desc(R"PO(Always perform the reduce constant optimizationMay add more tosa.const but would reduce runtime calculations)PO"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class TosaMakeBroadcastablePassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaMakeBroadcastablePassBase;

  TosaMakeBroadcastablePassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaMakeBroadcastablePassBase(const TosaMakeBroadcastablePassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaMakeBroadcastablePassBase& operator=(const TosaMakeBroadcastablePassBase &) = delete;
  TosaMakeBroadcastablePassBase(TosaMakeBroadcastablePassBase &&) = delete;
  TosaMakeBroadcastablePassBase& operator=(TosaMakeBroadcastablePassBase &&) = delete;
  ~TosaMakeBroadcastablePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-make-broadcastable");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-make-broadcastable"; }

  ::llvm::StringRef getDescription() const override { return R"PD(TOSA rank Reshape to enable Broadcasting)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaMakeBroadcastablePass");
  }
  ::llvm::StringRef getName() const override { return "TosaMakeBroadcastablePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaMakeBroadcastablePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TosaOptionalDecompositionsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaOptionalDecompositionsPassBase;

  TosaOptionalDecompositionsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaOptionalDecompositionsPassBase(const TosaOptionalDecompositionsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaOptionalDecompositionsPassBase& operator=(const TosaOptionalDecompositionsPassBase &) = delete;
  TosaOptionalDecompositionsPassBase(TosaOptionalDecompositionsPassBase &&) = delete;
  TosaOptionalDecompositionsPassBase& operator=(TosaOptionalDecompositionsPassBase &&) = delete;
  ~TosaOptionalDecompositionsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-optional-decompositions");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-optional-decompositions"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Applies Tosa operations optional decompositions)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaOptionalDecompositionsPass");
  }
  ::llvm::StringRef getName() const override { return "TosaOptionalDecompositionsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaOptionalDecompositionsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TosaReduceTransposesBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaReduceTransposesBase;

  TosaReduceTransposesBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaReduceTransposesBase(const TosaReduceTransposesBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaReduceTransposesBase& operator=(const TosaReduceTransposesBase &) = delete;
  TosaReduceTransposesBase(TosaReduceTransposesBase &&) = delete;
  TosaReduceTransposesBase& operator=(TosaReduceTransposesBase &&) = delete;
  ~TosaReduceTransposesBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-reduce-transposes");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-reduce-transposes"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Reduce transposes through other operators)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaReduceTransposes");
  }
  ::llvm::StringRef getName() const override { return "TosaReduceTransposes"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaReduceTransposesBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TosaValidationBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TosaValidationBase;

  TosaValidationBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaValidationBase(const TosaValidationBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TosaValidationBase& operator=(const TosaValidationBase &) = delete;
  TosaValidationBase(TosaValidationBase &&) = delete;
  TosaValidationBase& operator=(TosaValidationBase &&) = delete;
  ~TosaValidationBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-validate");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-validate"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Validates TOSA dialect)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaValidation");
  }
  ::llvm::StringRef getName() const override { return "TosaValidation"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaValidationBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> strictOpSpecAlignment{*this, "strict-op-spec-alignment", ::llvm::cl::desc(R"PO(Verify if the properties of certain operations align the spec requirement)PO"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> allowInvalidOpDatatypeCombinations{*this, "allow-invalid-op-datatype-combinations", ::llvm::cl::desc(R"PO(Disable checks for operations that are determined to be invalid due to their operand/result datatypes not aligning with the 'Supported Data Types' sections of the specifciation)PO"), ::llvm::cl::init(false)};
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
