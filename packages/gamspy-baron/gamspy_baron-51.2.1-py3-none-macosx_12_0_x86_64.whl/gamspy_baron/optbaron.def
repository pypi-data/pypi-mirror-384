*
* optbaron.def
*

AbsConFeasTol double 0 1e-6 1e-12 maxdouble 1 1 Absolute constraint feasibility tolerance
AbsIntFeasTol double 0 1e-5 1e-12 maxdouble 1 1 Absolute integer feasibility tolerance
AllowExternal enumint 0 1 1 7 Indicator for use of External NLP solver with automatic NLP solver selection
 0 1 do not use the GAMS external NLP solver for local search
 1 1 consider the GAMS external NLP solver for local search
AllowIpopt enumint 0 1 1 7 Indicator for use of IPOPT with automatic NLP solver selection
 0 1 do not use IPOPT for local search
 1 1 consider IPOPT for local search
AllowMinos enumint 0 1 1 7 Indicator for use of MINOS with automatic NLP solver selection
 0 1 do not use MINOS for local search
 1 1 consider MINOS for local search
AllowSnopt enumint 0 1 1 7 Indicator for use of SNOPT with automatic NLP solver selection
 0 1 do not use SNOPT for local search
 1 1 consider SNOPT for local search
AllowFilterSD enumint 0 1 1 7 Indicator for use of FILTERSD with automatic NLP solver selection
 0 1 do not use FILTERSD for local search
 1 1 consider FILTERSD for local search
AllowFilterSQP enumint 0 1 1 7 Indicator for use of FILTERSQP with automatic NLP solver selection
 0 1 do not use FILTERSQP for local search
 1 1 consider FILTERSQP for local search
AllowCplex boolean 0 1 1 7 Indicator for use of CPLEX with automatic LP/MIP/QP solver selection
AllowCbc boolean 0 1 1 7 Indicator for use of CLP/CBC with automatic LP/MIP/QP solver selection
AllowXpress boolean 0 1 1 7 Indicator for use of FICO XPRESS with automatic LP/MIP/QP solver selection
AllowHsl boolean 0 1 1 7 Indicator for use of HSL LA04 with automatic LP solver selection
AutoBounds integer 0 0 0 maxint 0 8 Option to automatically generate bounds when bounds are missing
BasFra double 0 0.7 0 maxdouble 1 8 Similarity measure between bases for basis update not to occur
BasKp boolean 0 1 1 8 Indicates whether basis information is to be save
BoxTol double 0 1e-8 0 maxdouble 1 1 Box elimination tolerance.
BrPtStra enumint 0 0 1 4 Branching point selection strategy
 0 1 BARONs dynamic strategy
 1 1 w-branching
 2 1 bisection-branching
 3 1 convex combination of 1 and 2
BrVarStra enumint 0 0 1 4 Branching variable selection strategy
 0 1 BARONs dynamic strategy
 1 1 largest violation
 2 1 longest edge
CompIIS enumint 0 0 1 8 Request the computation of an Irreducible Inconsistent Set (IIS)
 0 1 do not search for an IIS
 1 1 the search for an IIS is based on a fast heuristic
 2 1 an IIS is obtained using a deletion filtering algorithm
 3 1 an IIS is obtained using an addition filtering algorithm
 4 1 an IIS is obtained using an addition-deletion filtering algorithm
 5 1 an IIS is obtained using a depth-first search algorithm
ConvexRatio double 0 0.7 0 maxdouble 1 4 The branching point ratio
CutOff double 0 0 0 maxdouble 1 1 Eliminate solutions that are no better than this value
DeltaA double 0 maxdouble 1e-12 maxdouble 1 1 Absolute improvement for insufficient progress termination
DeltaR double 0 1 1e-12 maxdouble 1 1 Relative improvement for insufficient progress termination
DeltaT double 0 -100 mindouble maxdouble 1 1 Time interval for insufficient progress termination
DeltaTerm enumint 0 0 1 1 Indicates whether insufficient progress termination is on or off
 0 1 do not enforce this termination condition
 1 1 terminate if progress is insufficient
DoLocal boolean 0 1 1 5 Local search option for upper bounding
 0 no local search is done during upper bounding
 1 BARON's dynamic local search decision rule
EpsA double 0 1e-6 0 maxdouble 1 1 Absolute termination tolerance.
EpsR double 0 1e-6 0 maxdouble 1 1 Relative termination tolerance.
FirstFeas integer 0 0 0 maxint 1 1 Changes the search for first numsol solutions
 0 search for the <i>best</i> \ref BARONNumSol "NumSol" feasible solutions
 1 find \ref BARONNumSol "NumSol" solutions irrespective of solution quality
FirstLoc boolean 0 0 1 1 Terminate the search as soon as a local optimum is found
GDXOut string 0 "" 1 10 Prefix for GDX file names for multiple solutions if \ref BARONNumSol "NumSol" &gt; 1.
hAbsTol double 0 0.1 0 maxdouble 1 5 Absolute improvement in the objective to repeat heuristic
Hessian integer 0 0 0 maxint 0 10 Generate hessian information
hRelTol double 0 0.1 0 maxdouble 1 5 Relative improvement in the objective to repeat heuristic
IISInt enumint 0 0 1 8 Indicates whether general integers should be considered as potential members of the IIS
 0 1 do not consider general integers as part of an IIS, assume them to be correct
 1 1 consider general integers (but not binaries) as part of an IIS
IISOrder integer 0 -1 -1 maxint 1 8 Order in which constraints are considered in the search for an IIS
 -1 auto set to aim for a small IIS depending on the value of \ref BARONCompIIS "CompIIS"
 1 arrange constraints in problem order
 2 arrange constraints in ascending order of degree
 3 arrange constraints in descending order of degree
 >3 random order using <tt>IISorder</tt> as seed
InfBnd double 0 0 0 maxdouble 1 10 infinity value to be used on bounds
IntOpt1 integer 0 0 0 maxint 0 8 Integer option 1
IntOpt2 integer 0 0 0 maxint 0 8 Integer option 2
IntOpt3 integer 0 0 0 maxint 0 8 Integer option 3
IntOpt4 integer 0 0 0 maxint 0 8 Integer option 4
IntOpt5 integer 0 0 0 maxint 0 8 Integer option 5
ISolTol double 0 1e-4 0 maxdouble 1 1 Solution Distance
LBTTDo boolean 0 1 1 3 Linear-feasibility-based range reduction option (poor man's LPs)
 0 no range reduction based on feasibility.
 1 range reduction done based on feasibility.
linearidentify boolean 0 1 1 8 identification of common linear subexpressions in nonlinear functions
LocRes boolean 0 0 1 6 Option to control output from local search
 0 no local search output
 1 detailed results from local search will be printed to res.dat file
LPAlg enumint 0 0 1 7 Specifies the LP algorithm to be used (available only with CPLEX as the LP solver)
 0 1 automatic selection of LP algorithm
 1 1 primal simplex
 2 1 dual simplex
 3 1 barrier
LPSol enumint 0 -1 1 7 Specifies the LP/MIP/QP Solver to be used
 -1 1 Automatic LP/MIP/QP solver selection and switching strategy
 3 1 CPLEX
 7 1 XPRESS
 8 1 CLP/CBC
 15 1 HSL LA04
MaxHeur integer 0 5 0 maxint 1 5 Maximum number of passes allowed for heuristic
MaxIter integer 0 -1 -1 maxint 1 1 Maximum number of branch-and-reduce iterations allowed
maxnodepass integer 0 5 0 maxint 1 3 Maximum number of passes allowed through a node
MaxPreTime double 0 -1 -1 maxdouble 1 1 Maximum CPU time allowed in presolve
maxredpass integer 0 10 0 maxint 1 3 Maximum number of times range reduction is performed at a node before a new relaxation is constructed
MaxTime double 0 1e10 0 maxdouble 1 1 Maximum time allowed (sec)
MDo boolean 0 1 1 3 Marginals-based reduction option
 0 no range reduction based on marginals.
 1 range reduction done based on marginals.
mipsolopt boolean 0 0 0 10 Read MIP solvers options
ModBrPt boolean 0 1 1 4 Branch point modification option
NLPSol enumint 0 -1 1 7 Specifies the NLP solver to be used
 -1 1 Automatic NLP solver selection and switching strategy
 0 1 Local search based on function evaluations alone with no calls to local solvers
 2 1 MINOS
 4 1 SNOPT
 6 1 GAMS NLP solver (see \ref BARONExtNLPsolver "ExtNLPsolver")
 9 1 IPOPT
 10 1 FILTERSD
 14 1 FILTERSQP
NodeSel enumint 0 0 1 4 Specifies the node selection rule to be used for exploring the search tree
 0 1 BARONs mixed selection scheme
 1 1 best bound
 2 1 last in first out [LIFO]
 3 1 minimum infeasibility
NoStarting boolean 0 0 0 10 Discard starting point
Nouter1 integer 0 4 0 maxint 1 2 Number of outer approximators of convex univariant functions
NoutIter integer 0 4 0 maxint 1 2 Number of rounds of cutting plane generation at node relaxation
NoutPerVar integer 0 4 0 maxint 1 2 Number of outer approximations per variable for convex multivariate functions
NumBranch integer 0 -1 -1 maxint 1 4 Number of Variables to be branched on
 -1 consider the model variables as well as variables introduced by BARON's lower bounding procedure
 0 consider only the original model variables for branching
 n consider only the first n variables for branching
NumLoc integer 0 -2 -2 maxint 1 5 Number of local searches done in preprocessing
NumSol integer 0 1 -1 maxint 1 1 Number of feasible solutions to be found
NumStore integer 0 0 -1 maxint 1 4 Number of variables whose bounds are to be stored at every node of the tree
 -1 store all variables
 0 store numbranch variables
 n store n variables
OBTTDo boolean 0 1 1 3 Optimality based tightening option
 0 no range reduction based on optimality.
 1 range reduction done based on optimality.
oldpow boolean 0 0 0 8 Old polyhedral convexification routines for powers
oldmono boolean 0 0 0 8 Old polyhedral convexification routines for powers
oldlog boolean 0 0 0 8 Old polyhedral convexification routines for logarithms
OutGrid integer 0 20 0 maxint 1 2 Number of grid points per variable for convex multivariate approximators of BARON's <tt>CONVEX_EQUATIONS</tt>.
PBin boolean 0 1 1 3 Probing on binary variables option
PDo integer 0 -2 -2 maxint 1 3 Number of probing problems allowed
 -2 automatically decided by BARON.
 -1 probing on all variables.
 0 no range reduction by probing.
 n probing on n variables.
pEnd integer 0 -1 -1 maxint 1 3 Level of branch-and-reduce tree where probing ends
pFreq integer 0 3 0 maxint 1 3 Level-frequency of probing applications
PhaseOne integer 0 0 0 maxint 0 10 Create Phase One feasibility problem
postabstol double 0 1e30 0 maxdouble 1 8 Absolute tolerance for postponing a node
postreltol double 0 1e30 0 maxdouble 1 8 Realtive tolerance for postponing a node
prelpdo integer 0 0 minint maxint 1 8 Solve preprocessing LPs at root
 -n preprocess the first n problem variables
 0 no preprocessing LPs should be solved
 1 preprocess all problem variables including those introduced by BARON's reformulator
 2 preprocess the first numstore problem variables
 3 preprocess all original problem variables
prfreq double 0 1000000 0 maxdouble 1 6 Log output frequency in number of nodes
prlevel boolean 0 1 1 6 Defines the level of log output printed.
 0 all log output is suppressed
 1 print log output
profra double 0 0.67 0 1 1 3 Fraction of probe to bound distance from relaxed solution when forced probing is done
prtimefreq double 0 30 0 maxdouble 1 6 Log output frequency in number of seconds
pStart integer 0 0 0 maxint 1 3 Level of branch-and-reduce tree where probing begins
pxdo integer 0 0 0 maxint 1 3 Number of probing variables fully optimized (not fixed at bound)
RealOpt1 double 0 0 0 maxdouble 0 8 Real option 1
RealOpt2 double 0 0 0 maxdouble 0 8 Real option 2
RealOpt3 double 0 0 0 maxdouble 0 8 Real option 3
RealOpt4 double 0 0 0 maxdouble 0 8 Real option 4
RealOpt5 double 0 0 0 maxdouble 0 8 Real option 5
RealPower integer 0 0 0 maxint 0 10 Use original real power
redabstol double 0 0.1 0 maxdouble 1 3 Absolute improvement in the objective to reconstruct the relaxation of the current node
redreltol double 0 0.1 0 maxdouble 1 3 Relative improvement in the objective to reconstruct the relaxation of the current node
Reform integer 0 100 0 maxint 0 10 Reformulation level
RelConFeasTol double 0 0 0 0.1 1 1 Relative constraint feasibility tolerance
RelIntFeasTol double 0 0 0 0.1 1 1 Relative integer feasibility tolerance
Results boolean 0 1 0 6 Indicator if a results file is to be created
 0 do not create file
 1 create file named according to the \ref BARONResName "ResName" option
seed integer 0 19631963 1 maxint 1 8 Initial seed for random number generator
Threads integer 0 1 1 maxint 1 2 Number of cores used for solution of MIP subproblems
TDo boolean 0 1 1 3 Nonlinear-feasibility-based range reduction option (poor man's NLPs)
 0 no bounds tightening is performed.
 1 bounds tightening is performed.
twoways boolean 0 1 1 3 Determines whether probing on both bounds is done or not
WantDual enumint 0 1 1 8 whether to try to provide dual solution values
 0 1 BARON may or may not return a dual solution.
 1 1 BARON will return a dual solution using an inexpensive technique to solve a KKT system corresponding to the best primal solution identified
DualBudget double 0 0 0 maxdouble 1 8 Maximum time allowed (sec) for calculating a dual solution in case BARON times out and WantDual equals 1
.Lo double 0 0 mindouble maxdouble 0 10 Variable Lower Bound
.Up double 0 0 0 maxdouble 0 10 Variable Upper Bound
.Prior double 0 0 0 maxdouble 0 10 Variable Branching Priority
.EquClass enumint 0 0 1 10 Equation Classification
 0 1 Regular constraint.
 1 1 Relaxation-only constraint
 2 1 Convex constraint
 3 1 Convex constraint that is relaxation-only.
GamsCntr string 0 "" 0 9 GAMS control file name
HessCntr string 0 "" 0 9 Hessian mini control file
HessInst string 0 "" 0 9 Hessian instruction file
TimName string 0 "225a/tim.dat" 0 6 Name of <tt>times</tt> to be written.
ResName string 0 "225a/res.dat" 0 6 Name of <tt>results</tt> file to be written.
SumName string 0 "225a/sum.dat" 0 6 Indicator if a <tt>summary</tt> file is to be created.
OptName string 0 "" 0 9 temp option file name
ProName string 0 "problem" 0 6 Problem name. This option should be no longer than 10 characters.
BarName string 0 "225a/mybaron.dat" 1 10 Name of BARON problem file to be written
Include immediate ReadFile 0 10 Start reading from a new file
ObjName string 0 "" 0 10 Obj variable name
ExtNLPsolver string 0 "conopt4" 1 7 External GAMS NLP solver and option file (e.g. conopt3.1)
ExtMINLPsolver string 0 "sbb" 0 10 External GAMS MINLP solver and option file (e.g. sbb.1)
Secret strlist 0 0 10 Pass secret option to BARON
ClockType enumstr 0 "wall" 1 10 Type of clock to use when reporting solving time back to GAMS
 "wall" 1 report time according to "clock on the wall" (as used by most GAMS solver links)
 "cpu" 1 report time used by CPU (summed up over all cores)
 "baron" 1 report same time as used by BARON ("cpu" if one thread, "wall" if multiple threads)
optca synonym EpsA
optcr synonym EpsR
integer1 synonym IntOpt1
integer2 synonym IntOpt2
integer3 synonym IntOpt3
integer4 synonym IntOpt4
integer5 synonym IntOpt5
nodlim synonym MaxIter
reslim synonym MaxTime
real1 synonym RealOpt1
real2 synonym RealOpt2
real3 synonym RealOpt3
real4 synonym RealOpt4
real5 synonym RealOpt5
myeolchar EOLCOMM #
*
* deprecated section
*
baron11 deprecated
 linearidentify New parser in BARON 11.3 makes option superfluous
baron126 deprecated
 BasFra Automatic setting of many options based on problem characteristics and learning algorithms
 BasKp Automatic setting of many options based on problem characteristics and learning algorithms
 ConvexRatio Automatic setting of many options based on problem characteristics and learning algorithms
 hAbsTol Automatic setting of many options based on problem characteristics and learning algorithms
 hRelTol Automatic setting of many options based on problem characteristics and learning algorithms
 MaxHeur Automatic setting of many options based on problem characteristics and learning algorithms
 maxnodepass Automatic setting of many options based on problem characteristics and learning algorithms
 MaxPreTime Automatic setting of many options based on problem characteristics and learning algorithms
 maxredpass Automatic setting of many options based on problem characteristics and learning algorithms
 ModBrPt Automatic setting of many options based on problem characteristics and learning algorithms
 NumBranch Automatic setting of many options based on problem characteristics and learning algorithms
 NumStore Automatic setting of many options based on problem characteristics and learning algorithms
 PBin Automatic setting of many options based on problem characteristics and learning algorithms
 pEnd Automatic setting of many options based on problem characteristics and learning algorithms
 pFreq Automatic setting of many options based on problem characteristics and learning algorithms
 postabstol Automatic setting of many options based on problem characteristics and learning algorithms
 postreltol Automatic setting of many options based on problem characteristics and learning algorithms
 prelpdo Automatic setting of many options based on problem characteristics and learning algorithms
 profra Automatic setting of many options based on problem characteristics and learning algorithms
 pStart Automatic setting of many options based on problem characteristics and learning algorithms
 pxdo Automatic setting of many options based on problem characteristics and learning algorithms
 redabstol Automatic setting of many options based on problem characteristics and learning algorithms
 redreltol Automatic setting of many options based on problem characteristics and learning algorithms
 twoways Automatic setting of many options based on problem characteristics and learning algorithms
*
* Groups
* <group-ident> group <group-number <help-context> <help-text>
*
Termination group 1 1 Termination options
Relaxation group 2 1 Relaxation options
Range group 3 1 Range reduction options
Branching group 4 1 Tree management options
Heuristic group 5 1 Local search options
Output group 6 1 Output Options
Subsolver group 7 1 Subsolver Options
Other group 8 1 Other Options
GamsOnly group 9 0 Gams system interface only
NonBaron group 10 1 Interface and Conversion
*** End of file
