*
* optgurobi.def
*

Presolve enumint 0 -1 1 5 Presolve level
 -1 1 Auto
 0 1 Off
 1 1 Conservative
 2 1 Aggressive
Tuning string 1 "" 1 16 Parameter Tuning
bariterlimit integer 0 maxint 0 maxint 1 1 Barrier iteration limit
bestbdstop double 0 maxdouble mindouble maxdouble 1 1 Best objective bound to stop
bestobjstop double 0 mindouble mindouble maxdouble 1 1 Best objective value to stop
cutoff double 0 maxdouble mindouble maxdouble 1 1 Objective cutoff
iterationlimit double 0 maxdouble 0 maxdouble 1 1 Simplex iteration limit
memlimit double 0 maxdouble 0 maxdouble 1 1 Memory limit
nodelimit double 0 maxdouble 0 maxdouble 1 1 MIP node limit
softmemlimit double 0 maxdouble 0 maxdouble 1 1 Soft memory limit
solutionlimit integer 0 maxint 1 maxint 1 1 MIP feasible solution limit
timelimit double 0 maxdouble 0 maxdouble 1 1 Time limit
worklimit double 0 maxdouble 0 maxdouble 1 1 Work limit
barconvtol double 0 1e-08 0 1 1 2 Barrier convergence tolerance
barqcpconvtol double 0 1e-06 0 1 1 2 Barrier QCP convergence tolerance
feasibilitytol double 0 1e-06 1e-09 0.01 1 2 Primal feasibility tolerance
intfeastol double 0 1e-05 1e-09 0.1 1 2 Integer feasibility tolerance
markowitztol double 0 0.0078125 0.0001 0.999 1 2 Threshold pivoting tolerance
mipgap double 0 0.0001 0 maxdouble 1 2 Relative MIP optimality gap
mipgapabs double 0 1e-10 0 maxdouble 1 2 Absolute MIP optimality gap
optimalitytol double 0 1e-06 1e-09 0.01 1 2 Dual feasibility tolerance
psdtol double 0 1e-06 0 maxdouble 1 2 Positive semi-definite tolerance
displayinterval integer 0 5 1 maxint 1 3 Frequency at which log lines are printed
outputflag boolean 0 1 0 3 Solver output control
record boolean 0 0 0 4 Enable API call recording
resultfile string 0 "" 0 4 Result file written upon completion of optimization
solfiles string 0 "" 1 4 Location to store intermediate solution files
aggfill integer 0 -1 -1 maxint 1 5 Allowed fill during presolve aggregation
aggregate integer 0 1 0 2 1 5 Presolve aggregation control
dualreductions boolean 0 1 1 5 Disables dual reductions in presolve
precrush boolean 0 0 1 5 Allows presolve to translate constraints on the original model toequivalent constraints on the presolved model
predeprow integer 0 -1 -1 1 1 5 Presolve dependent row reduction
predual integer 0 -1 -1 2 1 5 Presolve dualization
premiqcpform enumint 0 -1 1 5 Format of presolved MIQCP model
 -1 1 Auto
 0 1 Always leaves the model in MIQCP form
 1 1 Always transforms the model into MISOCP form
 2 1 Always transforms the model into disaggregated MISOCP form
prepasses integer 0 -1 -1 maxint 1 5 Presolve pass limit
preqlinearize enumint 0 -1 1 5 Presolve Q matrix linearization
 -1 1 Auto
 0 1 Linearization off
 1 1 Force Linearization and get strong LP relaxation
 2 1 Force Linearization and get compact relaxation
presos1bigm double 0 -1 -1 1e+10 1 5 Controls largest coefficient in SOS1 reformulation
presos1encoding integer 0 -1 -1 3 1 5 Controls SOS1 reformulation
presos2bigm double 0 -1 -1 1e+10 1 5 Controls largest coefficient in SOS2 reformulation
presos2encoding integer 0 -1 -1 3 1 5 Controls SOS2 reformulation
presparsify integer 0 -1 -1 2 1 5 Presolve sparsify reduction
 -1 Auto
 0 Disable the presolve sparsify reduction
 1 Enable the presolve sparsify reduction for MIPs
 2 Enable the presolve sparsify reduction for all model types
lpwarmstart integer 0 1 0 2 1 6 Warm start usage in simplex
method enumint 0 -1 1 6 Define method, e.g., Simplex, to solve continuous models
 -1 1 Automatic
 0 1 Primal simplex
 1 1 Dual simplex
 2 1 Barrier
 3 1 Concurrent
 4 1 Deterministic concurrent
 5 1 Both primal and dual simplex
networkalg integer 0 -1 -1 1 1 6 Network simplex algorithm
normadjust integer 0 -1 -1 3 1 6 Simplex pricing norm
perturbvalue double 0 0.0002 0 maxdouble 1 6 Simplex perturbation magnitude
quad integer 0 -1 -1 1 1 6 Quad precision computation in simplex
sifting enumint 0 -1 1 6 Sifting within dual simplex
 -1 1 Auto
 0 1 Off
 1 1 Moderate
 2 1 Agressive
siftmethod enumint 0 -1 1 6 LP method used to solve sifting sub-problems
 -1 1 Auto
 0 1 Primal Simplex
 1 1 Dual Simplex
 2 1 Barrier
simplexpricing enumint 0 -1 1 6 Simplex variable pricing strategy
 -1 1 Auto
 0 1 Partial Pricing
 1 1 Steepest Edge
 2 1 Devex
 3 1 Quick-Start Steepest Edge
barcorrectors integer 0 -1 -1 maxint 1 7 Central correction limit
barhomogeneous enumint 0 -1 1 7 Barrier homogeneous algorithm
 -1 1 Auto
 0 1 Homogeneous Barrier off
 1 1 Force Homogeneous Barrier on
barorder enumint 0 -1 1 7 Barrier ordering algorithm
 -1 1 Auto
 0 1 Approximate Minimum Degree ordering
 1 1 Nested Dissection ordering
crossover integer 0 -1 -1 5 1 7 Barrier crossover strategy
crossoverbasis enumint 0 -1 1 7 Crossover initial basis construction strategy
 -1 1 Auto
 0 1 Chooses an initial basis quickly
 1 1 Can take much longer, but often produces a more numerically stable start basis
qcpdual boolean 0 0 1 7 Compute dual variables for QCP models
 0 Do not compute dual for QCP problem
 1 Compute dual for QCP problem
objscale double 0 0 -1 maxdouble 1 8 Objective scaling
scaleflag integer 0 -1 -1 3 1 8 Model scaling
branchdir enumint 0 0 1 9 Branch direction preference
 -1 1 Always explore the down branch first
 0 1 Automatic
 1 1 Always explore the up branch first
concurrentjobs integer 0 0 0 maxint 1 9 Enables distributed concurrent solver
concurrentmethod enumint 0 -1 1 9 Chooses continuous solvers to run concurrently
 -1 1 Auto
 0 1 barrier, dual, primal simplex
 1 1 barrier and dual simplex
 2 1 barrier and primal simplex
 3 1 dual and primal simplex
concurrentmip integer 0 1 1 64 1 9 Enables concurrent MIP solver
degenmoves integer 0 -1 -1 maxint 1 9 Degenerate simplex moves
disconnected enumint 0 -1 1 9 Disconnected component strategy
 -1 1 Auto
 0 1 Ignores structure entirely
 1 1 Conservative
 2 1 Aggressive
distributedmipjobs integer 0 0 0 maxint 1 9 Enables the distributed MIP solver
heuristics double 0 0.05 0 1 1 9 Turn MIP heuristics up or down
improvestartgap double 0 0 0 maxdouble 1 9 Trigger solution improvement
improvestartnodes double 0 maxdouble 0 maxdouble 1 9 Trigger solution improvement
improvestarttime double 0 maxdouble 0 maxdouble 1 9 Trigger solution improvement
integralityfocus boolean 0 0 1 9 Set the integrality focus
 0 Disable the integrality focus
 1 Enable the integrality focus
minrelnodes integer 0 -1 -1 maxint 1 9 Minimum relaxation heuristic control
mipfocus enumint 0 0 1 9 Set the focus of the MIP solver
 0 1 Balance between finding good feasible solutions and proving optimality
 1 1 Focus towards finding feasible solutions
 2 1 Focus towards proving optimality
 3 1 Focus on moving the best objective bound
miqcpmethod enumint 0 -1 1 9 Method used to solve MIQCP models
 -1 1 Auto
 0 1 Continuous QCP relaxations at each node
 1 1 Linearized, outer-approximation approach
nlpheur boolean 0 1 1 9 Controls the NLP heuristic for non-convex quadratic models
nodefiledir string 0 "." 1 9 Directory for MIP node files
nodefilestart double 0 maxdouble 0 maxdouble 1 9 Memory threshold for writing MIP tree nodes to disk
nodemethod enumint 0 -1 1 9 Method used to solve MIP node relaxations
 -1 1 Automatic
 0 1 Primal simplex
 1 1 Dual simplex
 2 1 Barrier
nonconvex integer 0 -1 -1 2 1 9 Control how to deal with non-convex quadratic programs
norelheurtime double 0 0 0 maxdouble 1 9 Limits the amount of time (in seconds) spent in the NoRel heuristic
norelheurwork double 0 0 0 maxdouble 1 9 Limits the amount of work performed by the NoRel heuristic
obbt integer 0 -1 -1 3 1 9 Controls aggressiveness of optimality-based bound tightening
partitionplace integer 0 15 0 31 1 9 Controls when the partition heuristic runs
pumppasses integer 0 -1 -1 maxint 1 9 Feasibility pump heuristic control
rins integer 0 -1 -1 maxint 1 9 RINS heuristic
startnodelimit integer 0 -1 -3 maxint 1 9 Node limit for MIP start sub-MIP
submipnodes integer 0 500 0 maxint 1 9 Nodes explored by sub-MIP heuristics
symmetry enumint 0 -1 1 9 Symmetry detection
 -1 1 Auto
 0 1 Off
 1 1 Conservative
 2 1 Aggressive
varbranch enumint 0 -1 1 9 Branch variable selection strategy
 -1 1 Auto
 0 1 Pseudo Reduced Cost Branching
 1 1 Pseudo Shadow Price Branching
 2 1 Maximum Infeasibility Branching
 3 1 Strong Branching
zeroobjnodes integer 0 -1 -1 maxint 1 9 Zero objective heuristic control
bqpcuts enumint 0 -1 1 10 BQP cut generation
 -1 1 Auto
 0 1 Off
 1 1 Conservative
 2 1 Aggressive
cuts enumint 0 -1 1 10 Global cut generation control
 -1 1 Auto
 0 1 Off
 1 1 Conservative
 2 1 Aggressive
 3 1 Very aggressive
cliquecuts enumint 0 -1 1 10 Clique cut generation
 -1 1 Auto
 0 1 Off
 1 1 Conservative
 2 1 Aggressive
covercuts enumint 0 -1 1 10 Cover cut generation
 -1 1 Auto
 0 1 Off
 1 1 Conservative
 2 1 Aggressive
cutaggpasses integer 0 -1 -1 maxint 1 10 Constraint aggregation passes performed during cut generation
cutpasses integer 0 -1 -1 maxint 1 10 Root cutting plane pass limit
dualimpliedcuts integer 0 -1 -1 2 1 10 Dual implied bound cut generation
flowcovercuts enumint 0 -1 1 10 Flow cover cut generation
 -1 1 Auto
 0 1 Off
 1 1 Conservative
 2 1 Aggressive
flowpathcuts enumint 0 -1 1 10 Flow path cut generation
 -1 1 Auto
 0 1 Off
 1 1 Conservative
 2 1 Aggressive
gomorypasses integer 0 -1 -1 maxint 1 10 Root Gomory cut pass limit
gubcovercuts enumint 0 -1 1 10 GUB cover cut generation
 -1 1 Auto
 0 1 Off
 1 1 Conservative
 2 1 Aggressive
impliedcuts enumint 0 -1 1 10 Implied bound cut generation
 -1 1 Auto
 0 1 Off
 1 1 Conservative
 2 1 Aggressive
infproofcuts integer 0 -1 -1 2 1 10 Infeasibility proof cut generation
liftprojectcuts integer 0 -1 -1 2 1 10 Lift-and-project cut generation
mipsepcuts enumint 0 -1 1 10 MIP separation cut generation
 -1 1 Auto
 0 1 Off
 1 1 Conservative
 2 1 Aggressive
mircuts enumint 0 -1 1 10 MIR cut generation
 -1 1 Auto
 0 1 Off
 1 1 Conservative
 2 1 Aggressive
mixingcuts integer 0 -1 -1 2 1 10 Mixing cut generation
modkcuts integer 0 -1 -1 2 1 10 Mod-k cut generation
networkcuts enumint 0 -1 1 10 Network cut generation
 -1 1 Auto
 0 1 Off
 1 1 Conservative
 2 1 Aggressive
projimpliedcuts enumint 0 -1 1 10 Projected implied bound cut generation
 -1 1 Auto
 0 1 Off
 1 1 Moderate
 2 1 Aggressive
psdcuts enumint 0 -1 1 10 PSD cut generation
 -1 1 Auto
 0 1 Off
 1 1 Moderate
 2 1 Aggressive
relaxliftcuts enumint 0 -1 1 10 Relax-and-lift cut generation
 -1 1 Auto
 0 1 Off
 1 1 Conservative
 2 1 Aggressive
rltcuts enumint 0 -1 1 10 RLT cut generation
 -1 1 Auto
 0 1 Off
 1 1 Conservative
 2 1 Aggressive
strongcgcuts integer 0 -1 -1 2 1 10 Strong-CG cut generation
submipcuts integer 0 -1 -1 2 1 10 Sub-MIP cut generation
zerohalfcuts enumint 0 -1 1 10 Zero-half cut generation
 -1 1 Auto
 0 1 Off
 1 1 Conservative
 2 1 Aggressive
numericfocus integer 0 0 0 3 1 11 Set the numerical focus
tunecleanup double 0 0 0 1 1 12 Enables a tuning cleanup phase
tunecriterion integer 0 -1 -1 3 1 12 Specify tuning criterion
tunedynamicjobs integer 0 0 -1 maxint 1 12 Enables distributed tuning using a dynamic set of workers
tunejobs integer 0 0 0 maxint 1 12 Enables distributed tuning using a static set of workers
tunemetric integer 0 -1 -1 1 1 12 Metric to aggregate results into a single measure
tuneoutput enumint 0 2 1 12 Tuning output level
 0 1 No output
 1 1 Summary output only when a new best parameter set is found
 2 1 Summary output for each parameter set that is tried
 3 1 Summary output, plus detailed solver output, for each parameter set tried
tuneresults integer 0 -1 -2 maxint 1 12 Number of improved parameter sets returned
tunetargetmipgap double 0 0 0 maxdouble 1 12 A target gap to be reached
tunetargettime double 0 0.005 0 maxdouble 1 12 A target runtime in seconds to be reached
tunetimelimit double 0 maxdouble 0 maxdouble 1 12 Time limit for tuning
tunetrials integer 0 0 0 maxint 1 12 Perform multiple runs on each parameter set to limit the effect ofrandom noise
poolgap double 0 maxdouble 0 maxdouble 1 13 Relative gap for solutions in pool
poolgapabs double 0 maxdouble 0 maxdouble 1 13 Absolute gap for solutions in pool
poolsearchmode integer 0 0 0 2 1 13 Choose the approach used to find additional solutions
poolsolutions integer 0 10 1 maxint 1 13 Number of solutions to keep in pool
multiobjmethod integer 0 -1 -1 2 1 14 Warm-start method to solve for subsequent objectives
multiobjpre integer 0 -1 -1 2 1 14 Initial presolve on multi-objective models
threads integer 0 0 -128 1024 1 15 Number of parallel threads to use
workerpassword string 0 "" 1 15 Password for distributed worker cluster
feasrelaxbigm double 0 1e+06 0 maxdouble 1 16 Big-M value for feasibility relaxations
funcpieceerror double 0 0.001 1e-06 1e+06 1 16 Error allowed for PWL translation of function constraint
funcpiecelength double 0 0.01 1e-05 1e+06 1 16 Piece length for PWL translation of function constraint
funcpieceratio double 0 -1 -1 1 1 16 Controls whether to under- or over-estimate function values in PWLapproximation
funcpieces integer 0 0 -2 200000000 1 16 Sets strategy for PWL function approximation
 -2 Bounds the relative error of the approximation; the error bound is provided in the FuncPieceError parameter
 -1 Bounds the absolute error of the approximation; the error bound is provided in the FuncPieceError parameter
 0 Automatic PWL approximation
 1 Uses a fixed width for each piece; the actual width is provided in the FuncPieceLength parameter
 >=2 Sets the number of pieces; pieces are equal width
funcmaxval double 0 1e+06 0.01 maxdouble 1 16 Maximum value for x and y variables in function constraints
funcnonlinear boolean 0 1 1 16 Chooses the approximation approach used to handle function constraints
 0 Piecewise-linear approximations
 1 Nonlinear functions
iismethod integer 0 -1 -1 3 1 16 IIS method
seed integer 0 0 0 maxint 1 16 Modify the random number seed
solutiontarget enumint 0 -1 1 16 Specify the solution target for LP
 -1 1 Auto
 0 1 primal and dual optimal, and basic
 1 1 primal and dual optimal
appname string 1 "" 0 16 App Name for Gurobi license manager
.dofuncpieceerror double 0 1e-3 1e-6 1e6 1 16 Error allowed for PWL translation of function constraints
.dofuncpiecelength double 0 1e-2 1e-5 1e6 1 16 Piece length for PWL translation of function constraints
.dofuncpieceratio double 0 -1 -1 1 1 16 Control whether to under- or over-estimate function values in PWL approximation
.dofuncpieces integer 0 0 -2 maxint 1 16 Sets strategy for PWL function approximation
 -2 Bounds the relative error of the approximation; the error bound is provided in the FuncPieceError parameter
 -1 Bounds the absolute error of the approximation; the error bound is provided in the FuncPieceError parameter
 0 Automatic based on relative error approach
 1 Uses a fixed width for each piece; the actual width is provided in the FuncPieceLength parameter
 >=2 Sets the number of pieces; pieces are equal width
dummy string 0 "" 0 16 Pass a parameter string to gurobi directly
dumpbcsol string 1 "" 1 9 Dump incumbents to GDX files during branch-and-cut
feasopt boolean 1 0 1 16 Computes a minimum-cost relaxation to make an infeasible model feasible
 0 Turns Feasible Relaxation off
 1 Turns Feasible Relaxation on
feasoptmode enumint 1 0 1 16 Mode of FeasOpt
 0 1 Minimize sum of relaxations
 1 1 Minimize sum of relaxations and optimize
 2 1 Minimize number of relaxations
 3 1 Minimize number of relaxations and optimize
 4 1 Minimize sum of squares of relaxations
 5 1 Minimize sum of squares of relaxations and optimize
.feaspref double 1 1 0 1e+020 1 16 feasibility preference
fixoptfile string 1 "" 1 9 Option file for fixed problem optimization
freegamsmodel boolean 1 0 1 16 Preserves memory by dumping the GAMS model instance representation temporarily to disk
.genconstrtype integer 1 0 0 17 0 16 General constraint type
iis integer 1 0 0 2 1 16 Run the Irreducible Inconsistent Subsystem (IIS) finder if the problem is infeasible
 0 No conflict analysis
 1 Conflict analysis after solve if infeasible
 2 Conflict analysis without previous solve
isvname string 1 "" 0 16 ISV Name for Gurobi license manager
kappa boolean 1 0 1 16 Display approximate condition number estimates for the optimal simplex basis
 0 Do not compute and display approximate condition number
 1 Compute and display approximate condition number
kappaexact boolean 1 0 1 16 Display exact condition number estimates for the optimal simplex basis
 0 Do not compute and display exact condition number
 1 Compute and display exact condition number
.lazy integer 1 0 -1 3 1 9 Lazy constraints value
lazyconstraints boolean 1 0 1 9 Indicator to use lazy constraints
mipstart boolean 1 0 1 9 Use mip starting values
 0 Do not use the values
 1 Use the values
mipstopexpr strlist 1 1 9 Stop expression for branch and bound
miptrace string 1 "" 1 16 Filename of MIP trace file
miptracenode integer 1 100 0 maxint 1 16 Node interval when a trace record is written
miptracetime double 1 1 0 maxdouble 1 16 Time interval when a trace record is written
multimipstart strlist 1 1 9 Use multiple (partial) mipstarts provided via gdx files
multobj boolean 1 0 1 16 Controls the hierarchical optimization of multiple objectives
names boolean 1 1 1 16 Indicator for loading names
 0 Do not load GAMS names into Gurobi model
 1 Load GAMS names into Gurobi model
nobounds immediate nobounds 0 16 Ignores bounds on options
objnabstol strlist 1 1 16 Allowable absolute degradation for objective
objnreltol strlist 1 1 16 Allowable relative degradation for objective
.partition integer 1 0 -1 maxint 1 9 Variable partition value
printoptions boolean 1 0 1 16 List values of all options to GAMS listing file
 0 Do not list option values to GAMS listing file
 1 List option values to GAMS listing file
.prior double 1 1 1 maxdouble 1 9 Branching priorities
probread string 1 "" 0 16 Supply a problem via a Gurobi input file
qextractalg enumint 1 0 1 16 quadratic extraction algorithm in GAMS interface
 0 1 Automatic
 1 1 ThreePass: Uses a three-pass forward / backward / forward AD technique to compute function / gradient / Hessian values and a hybrid scheme for storage.
 2 1 DoubleForward: Uses forward-mode AD to compute and store function, gradient, and Hessian values at each node or stack level as required.  The gradients and Hessians are stored in linked lists.
 3 1 Concurrent: Uses ThreePass and DoubleForward in parallel. As soon as one finishes, the other one stops.
qextractdenseswitchfactor double 1 0.008 0 maxdouble 1 16 Sparse/dense factor for quadratic extraction algorithm in GAMS interface
qextractdenseswitchlog boolean 1 0 1 16 Enables additional information about sparse/dense factor choice in quadratic extraction algorithm in GAMS interface
readfile immediate readfile 0 16 Read secondary option file
readparams string 1 "" 1 16 Read Gurobi parameter file
rerun enumint 1 -1 1 16 Resolve without presolve in case of unbounded or infeasible
 -1 1 No
 0 1 Auto
 1 1 Yes
rngrestart string 1 "" 1 16 Write GAMS readable ranging information file
sensitivity boolean 1 0 1 16 Provide sensitivity information
 0 Do not provide sensitivity information
 1 Provide sensitivity information
solnpool string 1 "" 1 9 Controls export of alternate MIP solutions
solnpoolmerge string 1 "" 1 9 Controls export of alternate MIP solutions for merged GDX solution file
solnpoolnumsym integer 0 10 1 maxint 1 9 Maximum number of variable symbols when writing merged GDX solution file
solnpoolprefix string 0 "soln" 1 9 First dimension of variables for merged GDX solution file or file name prefix for GDX solution files
solvefixed boolean 1 1 1 9 Indicator for solving the fixed problem for a MIP to get a dual solution
 0 Do not solve the fixed problem
 1 Solve the fixed problem
.trynonlin boolean 1 1 1 16 Try nonlinear function general constraint interface for nonlinear constraint
usebasis enumint 1 0 1 16 Use basis from GAMS
 0 1 No basis
 1 1 Supply basis if basis is full otherwise provide primal dual solution
 2 1 Supply basis iff basis is full
 3 1 Supply primal dual solution
varhint boolean 1 0 1 16 Guide heuristics and branching through variable hints
workerpool strlist 2 1 15 Distributed worker cluster
writeparams string 1 "" 1 16 Write Gurobi parameter file
writeprob string 1 "" 1 16 Save the problem instance
*
* synonym section
*
lpmethod synonym method
rootmethod synonym method
concurrentmipjobs synonym concurrentjobs
dumpsolution synonym solnpool
*
* indicator section
*
indic  indicator
*
* deprecated section
*
gurobi3 deprecated
 lpmethod Use option method to specify algorithm used for LP and QP problems
 rootmethod Use option method to specify algorithm used for root node
synon deprecated
 concurrentmipjobs
 dumpsolution
*
* Groups
* <group-ident> group <group-number <help-context> <help-text>
*
Termination group 1 1 Termination options
Tolerances group 2 1 Tolerances options
Logging group 3 1 Logging options
Output group 4 1 Output options
Presolve group 5 1 Presolve options
Simplex group 6 1 Simplex options
Barrier group 7 1 Barrier options
Scaling group 8 1 Scaling options
MIP group 9 1 MIP options
MIPCuts group 10 1 MIP Cuts options
Numerics group 11 1 Numerics options
Tuning group 12 1 Tuning options
MultipleSolutions group 13 1 Multiple Solutions options
MultipleObjectives group 14 1 Multiple Objectives options
ParallelandDistributedComputing group 15 1 Parallel and Distributed Computing options
Other group 16 1 Other options
*** End of file
