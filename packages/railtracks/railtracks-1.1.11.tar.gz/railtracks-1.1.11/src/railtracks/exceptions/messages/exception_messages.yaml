# ------------------------------- Exception Messages ------------------------------
CLASSMETHOD_REQUIRED_MSG: "The '{method_name}' method must be a @classmethod."
CLASSMETHOD_REQUIRED_NOTES:
  - "Add @classmethod decorator to '{method_name}'."
  - "Signature should be: \n@classmethod\ndef {method_name}(cls): ..."

CONNECTED_NODES_EMPTY_MSG: "tool_nodes must not return an empty set."
CONNECTED_NODES_EMPTY_NOTES:
  - "Please provide a set nodes that can be used as tools by the ToolCallLLM node."

CONNECTED_NODES_TYPE_MSG: "tool_nodes must return a set of Nodes."
CONNECTED_NODES_TYPE_NOTES:
  - "Ensure all the nodes provided as tool_nodes are of type Node."
  - "You can use the from_function function to convert a function to a Node."
  - "You can use the @rt.to_node decorator to convert a function to a Node. eg.-\n@rt.to_node\ndef my_function(): ..."

DICT_PARAMETER_NOT_ALLOWED_MSG: "Parameter '{param_name}' contains a dictionary type at {path}, which is not allowed."
DICT_PARAMETER_NOT_ALLOWED_NOTES:
  - "Parameter '{param_name}' uses a dict or Dict type directly or nested at {path}."
  - "Dictionaries are not supported as function parameters for node creation."
  - "Consider using a Pydantic model or a more specific type instead of dict."
  - "Check your type annotations for nested structures like List[Dict], Tuple[Dict], etc."

DUPLICATE_PARAMETER_NAMES_MSG: "Duplicate parameter names are not allowed."
DUPLICATE_PARAMETER_NAMES_NOTES:
  - "Parameter names in tool_params must be unique."

INVALID_SYSTEM_MESSAGE_MSG: "system_message must be of type string or SystemMessage, not any other type."

MAX_TOOL_CALLS_NEGATIVE_MSG: "max_tool_calls must be a non-negative integer."
MAX_TOOL_CALLS_NEGATIVE_NOTES:
  - "The default value for any tool_call_llm node is 30."
  - "To give the llm access to unlimited tool calls, set max_tool_calls to None."
  - "If you want to allow only a limited number of tool calls, set max_tool_calls to that number."

MESSAGE_HISTORY_EMPTY_MSG: "Message history must contain at least one message."
MESSAGE_HISTORY_EMPTY_NOTES:
  - "Please provide an initial message."

MESSAGE_HISTORY_TYPE_MSG: "Message history must be a list of Message objects."
MESSAGE_HISTORY_TYPE_NOTES:
  - "System messages must be of type rt.llm.SystemMessage (not string)."
  - "User messages must be of type rt.llm.UserMessage (not string)."

MISSING_PRETTY_NAME_MSG: "You must provide a name when using this node as a tool, as this is used to identify the tool."

MISSING_TOOL_DETAILS_MSG: "Tool parameters are provided, but tool details are missing."
MISSING_TOOL_DETAILS_NOTES:
  - "If you want to use this node as a tool, you must provide tool details."

MODEL_REQUIRED_MSG: "You must provide a model to this node."
MODEL_REQUIRED_NOTES:
  - "You can provide the model during the time of node creation using easy_usage_wrappers. Eg:\n_ = rt.library.terminal_llm(..., llm=rt.llm.OpenAILLM('gpt-4o'))"
  - "You can insert the model during the time of node invocation using the 'llm' parameter. Eg:\n_ = rt.call(node, llm=rt.llm.OpenAILLM('gpt-4o'))"

OUTPUT_MODEL_EMPTY_MSG: "Output model has no fields defined."
OUTPUT_MODEL_EMPTY_NOTES:
  - "Check to see if the BaseModel has any fields defined."
  - "Output model cannot be empty."
  - "The model fields must be defined in the output_model. Eg.-\n class MyModel(BaseModel): \n    field1: str = Field(description='field1 description')"

OUTPUT_MODEL_REQUIRED_MSG: "Output model is not provided."
OUTPUT_MODEL_REQUIRED_NOTES:
  - "Check to see if the output_model is a pydantic model."
  - "Output model cannot be empty."
  - "The model fields must be defined in the output_model. Eg.-\n class MyModel(BaseModel): \n    field1: str = Field(description='field1 description')"

OUTPUT_MODEL_TYPE_MSG: "Output model must be a pydantic model, not {actual_type}."
OUTPUT_MODEL_TYPE_NOTES:
  - "Check to see if the output_model is a pydantic model."
  - "The model fields must be defined in the output_model. Eg.-\n class MyModel(BaseModel): \n    field1: str = Field(description='field1 description')"

PARAMETER_SET_CONTAINS_INVALID_TYPE_MSG: "Parameters set must be a set of Parameter objects or None."
PARAMETER_SET_CONTAINS_INVALID_TYPE_NOTES: "If the tool expects no parameters, use None or pass in an empty set instead."

TOOL_PARAMETERS_FROM_SCHEMA_FAILED_MSG: "Cannot convert the provided JSON-output_schema into Parameter objects. Reason: '{reason}'"
TOOL_PARAMETERS_TYPE_MSG: "Tool parameters must be a set of Parameter objects, a dict, or None."
TOOL_PARAMETERS_TYPE_NOTES:
  - "If the tool expects no parameters, use None."
  - "If you are having issues with passing in a JSON-output_schema, try to provide a set of Parameter objects instead."
  - "You can make a Tool object from a custom function. \nEg.-\ndef my_function():\n    ...\nsample_tool = rc.llm.Tool.from_function(my_function)"

# ----------------------------------- Warnings ------------------------------------

MAX_TOOL_CALLS_UNLIMITED_WARN: "You have set max_tool_calls to None. The llm will be able to make unlimited tool calls."

NO_SYSTEM_MESSAGE_WARN: "No SystemMessage was provided. This is not recommended. Please provide the first message as a SystemMessage."

ONLY_SYSTEM_MESSAGE_WARN: "Only SystemMessage was provided. This is not recommended. Please provide at least one UserMessage."

INVALID_SESSION_FILE_NAME_WARN: >
  The session name '{name}' could not be included in the saved json filename,
  falling back to using the unique identifier only {identifier}. To avoid this in the future,
  please ensure the session name contains only alphanumeric characters, dashes, and underscores.