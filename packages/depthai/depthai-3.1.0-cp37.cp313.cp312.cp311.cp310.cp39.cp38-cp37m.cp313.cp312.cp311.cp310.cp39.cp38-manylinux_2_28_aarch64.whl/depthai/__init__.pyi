from depthai import node as node
from depthai import nn_archive as nn_archive
from depthai import modelzoo as modelzoo
from depthai import filters as filters

# Ensures that the stubs are picked up - thanks, numpy project
import typing
json = dict
from pathlib import Path
from typing import Set, Type, TypeVar
T = TypeVar('T')
from typing import Any, Callable, ClassVar, Iterable, Iterator, Optional, Union

from typing import overload
import datetime
import numpy
import os
LINE_LIST: PointsAnnotationType
LINE_LOOP: PointsAnnotationType
LINE_STRIP: PointsAnnotationType
POINTS: PointsAnnotationType
UNKNOWN: PointsAnnotationType
X_LINK_ALREADY_OPEN: XLinkError_t
X_LINK_ANY_PLATFORM: XLinkPlatform
X_LINK_ANY_PROTOCOL: XLinkProtocol
X_LINK_ANY_STATE: XLinkDeviceState
X_LINK_BOOTED: XLinkDeviceState
X_LINK_BOOTED_NON_EXCLUSIVE: XLinkDeviceState
X_LINK_BOOTLOADER: XLinkDeviceState
X_LINK_COMMUNICATION_FAIL: XLinkError_t
X_LINK_COMMUNICATION_NOT_OPEN: XLinkError_t
X_LINK_COMMUNICATION_UNKNOWN_ERROR: XLinkError_t
X_LINK_DEVICE_ALREADY_IN_USE: XLinkError_t
X_LINK_DEVICE_NOT_FOUND: XLinkError_t
X_LINK_ERROR: XLinkError_t
X_LINK_FLASH_BOOTED: XLinkDeviceState
X_LINK_GATE: XLinkDeviceState
X_LINK_GATE_BOOTED: XLinkDeviceState
X_LINK_GATE_SETUP: XLinkDeviceState
X_LINK_INIT_PCIE_ERROR: XLinkError_t
X_LINK_INIT_TCP_IP_ERROR: XLinkError_t
X_LINK_INIT_USB_ERROR: XLinkError_t
X_LINK_INSUFFICIENT_PERMISSIONS: XLinkError_t
X_LINK_IPC: XLinkProtocol
X_LINK_MYRIAD_2: XLinkPlatform
X_LINK_MYRIAD_X: XLinkPlatform
X_LINK_NMB_OF_PROTOCOLS: XLinkProtocol
X_LINK_NOT_IMPLEMENTED: XLinkError_t
X_LINK_OUT_OF_MEMORY: XLinkError_t
X_LINK_PCIE: XLinkProtocol
X_LINK_RVC3: XLinkPlatform
X_LINK_RVC4: XLinkPlatform
X_LINK_SUCCESS: XLinkError_t
X_LINK_TCP_IP: XLinkProtocol
X_LINK_TIMEOUT: XLinkError_t
X_LINK_UNBOOTED: XLinkDeviceState
X_LINK_USB_CDC: XLinkProtocol
X_LINK_USB_VSC: XLinkProtocol
createSubnode: function

class ADatatype:
    def __init__(self) -> None: ...

class AprilTag:
    bottomLeft: Point2f
    bottomRight: Point2f
    decisionMargin: float
    hamming: int
    id: int
    topLeft: Point2f
    topRight: Point2f
    def __init__(self) -> None: ...

class AprilTagConfig(Buffer):
    class Family:
        __members__: ClassVar[dict] = ...  # read-only
        TAG_16H5: ClassVar[AprilTagConfig.Family] = ...
        TAG_25H9: ClassVar[AprilTagConfig.Family] = ...
        TAG_36H10: ClassVar[AprilTagConfig.Family] = ...
        TAG_36H11: ClassVar[AprilTagConfig.Family] = ...
        TAG_CIR21H7: ClassVar[AprilTagConfig.Family] = ...
        TAG_STAND41H12: ClassVar[AprilTagConfig.Family] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class QuadThresholds:
        criticalDegree: float
        deglitch: bool
        maxLineFitMse: float
        maxNmaxima: int
        minClusterPixels: int
        minWhiteBlackDiff: int
        def __init__(self) -> None: ...
    decodeSharpening: float
    family: AprilTagConfig.Family
    maxHammingDistance: int
    quadDecimate: int
    quadSigma: float
    quadThresholds: AprilTagConfig.QuadThresholds
    refineEdges: bool
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def setFamily(self, family: AprilTagConfig.Family) -> AprilTagConfig: ...

class AprilTagProperties:
    initialConfig: AprilTagConfig
    inputConfigSync: bool
    numThreads: int
    def __init__(self, *args, **kwargs) -> None: ...

class AprilTags(Buffer):
    aprilTags: list[AprilTag]
    def __init__(self) -> None: ...
    def getSequenceNum(self) -> int: ...
    def getTimestamp(self) -> datetime.timedelta: ...
    def getTimestampDevice(self) -> datetime.timedelta: ...

class Asset:
    alignment: int
    data: numpy.ndarray[numpy.uint8]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    @property
    def key(self) -> str: ...

class AssetManager:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def addExisting(self, assets: list[Asset]) -> None: ...
    @overload
    def get(self, key: str) -> Asset: ...
    @overload
    def get(self, key: str) -> Asset: ...
    @overload
    def getAll(self) -> list[Asset]: ...
    @overload
    def getAll(self) -> list[Asset]: ...
    def getRootPath(self) -> str: ...
    def remove(self, key: str) -> None: ...
    @overload
    def set(self, asset: Asset) -> Asset: ...
    @overload
    def set(self, key: str, asset: Asset) -> Asset: ...
    @overload
    def set(self, key: str, path: os.PathLike, alignment: int = ...) -> Asset: ...
    @overload
    def set(self, key: str, data, std, alignment: int = ...) -> Asset: ...
    def size(self) -> int: ...

class BenchmarkReport(Buffer):
    def __init__(self) -> None: ...
    @property
    def averageLatency(self) -> float: ...
    @property
    def fps(self) -> float: ...
    @property
    def latencies(self) -> list[float]: ...
    @property
    def numMessagesReceived(self) -> float: ...
    @property
    def timeTotal(self) -> float: ...

class BoardConfig:
    class GPIO:
        class Direction:
            __members__: ClassVar[dict] = ...  # read-only
            INPUT: ClassVar[BoardConfig.GPIO.Direction] = ...
            OUTPUT: ClassVar[BoardConfig.GPIO.Direction] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
    
        class Drive:
            __members__: ClassVar[dict] = ...  # read-only
            MA_12: ClassVar[BoardConfig.GPIO.Drive] = ...
            MA_2: ClassVar[BoardConfig.GPIO.Drive] = ...
            MA_4: ClassVar[BoardConfig.GPIO.Drive] = ...
            MA_8: ClassVar[BoardConfig.GPIO.Drive] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
    
        class Level:
            __members__: ClassVar[dict] = ...  # read-only
            HIGH: ClassVar[BoardConfig.GPIO.Level] = ...
            LOW: ClassVar[BoardConfig.GPIO.Level] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
    
        class Mode:
            __members__: ClassVar[dict] = ...  # read-only
            ALT_MODE_0: ClassVar[BoardConfig.GPIO.Mode] = ...
            ALT_MODE_1: ClassVar[BoardConfig.GPIO.Mode] = ...
            ALT_MODE_2: ClassVar[BoardConfig.GPIO.Mode] = ...
            ALT_MODE_3: ClassVar[BoardConfig.GPIO.Mode] = ...
            ALT_MODE_4: ClassVar[BoardConfig.GPIO.Mode] = ...
            ALT_MODE_5: ClassVar[BoardConfig.GPIO.Mode] = ...
            ALT_MODE_6: ClassVar[BoardConfig.GPIO.Mode] = ...
            DIRECT: ClassVar[BoardConfig.GPIO.Mode] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
    
        class Pull:
            __members__: ClassVar[dict] = ...  # read-only
            BUS_KEEPER: ClassVar[BoardConfig.GPIO.Pull] = ...
            NO_PULL: ClassVar[BoardConfig.GPIO.Pull] = ...
            PULL_DOWN: ClassVar[BoardConfig.GPIO.Pull] = ...
            PULL_UP: ClassVar[BoardConfig.GPIO.Pull] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
        ALT_MODE_0: ClassVar[BoardConfig.GPIO.Mode] = ...
        ALT_MODE_1: ClassVar[BoardConfig.GPIO.Mode] = ...
        ALT_MODE_2: ClassVar[BoardConfig.GPIO.Mode] = ...
        ALT_MODE_3: ClassVar[BoardConfig.GPIO.Mode] = ...
        ALT_MODE_4: ClassVar[BoardConfig.GPIO.Mode] = ...
        ALT_MODE_5: ClassVar[BoardConfig.GPIO.Mode] = ...
        ALT_MODE_6: ClassVar[BoardConfig.GPIO.Mode] = ...
        BUS_KEEPER: ClassVar[BoardConfig.GPIO.Pull] = ...
        DIRECT: ClassVar[BoardConfig.GPIO.Mode] = ...
        HIGH: ClassVar[BoardConfig.GPIO.Level] = ...
        INPUT: ClassVar[BoardConfig.GPIO.Direction] = ...
        LOW: ClassVar[BoardConfig.GPIO.Level] = ...
        MA_12: ClassVar[BoardConfig.GPIO.Drive] = ...
        MA_2: ClassVar[BoardConfig.GPIO.Drive] = ...
        MA_4: ClassVar[BoardConfig.GPIO.Drive] = ...
        MA_8: ClassVar[BoardConfig.GPIO.Drive] = ...
        NO_PULL: ClassVar[BoardConfig.GPIO.Pull] = ...
        OUTPUT: ClassVar[BoardConfig.GPIO.Direction] = ...
        PULL_DOWN: ClassVar[BoardConfig.GPIO.Pull] = ...
        PULL_UP: ClassVar[BoardConfig.GPIO.Pull] = ...
        direction: BoardConfig.GPIO.Direction
        drive: BoardConfig.GPIO.Drive
        level: BoardConfig.GPIO.Level
        mode: BoardConfig.GPIO.Mode
        pull: BoardConfig.GPIO.Pull
        schmitt: bool
        slewFast: bool
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, arg0: BoardConfig.GPIO.Direction) -> None: ...
        @overload
        def __init__(self, arg0: BoardConfig.GPIO.Direction, arg1: BoardConfig.GPIO.Level) -> None: ...
        @overload
        def __init__(self, arg0: BoardConfig.GPIO.Direction, arg1: BoardConfig.GPIO.Level, arg2: BoardConfig.GPIO.Pull) -> None: ...
        @overload
        def __init__(self, arg0: BoardConfig.GPIO.Direction, arg1: BoardConfig.GPIO.Mode) -> None: ...
        @overload
        def __init__(self, arg0: BoardConfig.GPIO.Direction, arg1: BoardConfig.GPIO.Mode, arg2: BoardConfig.GPIO.Pull) -> None: ...

    class GPIOMap:
        def __init__(self) -> None: ...
        def items(self) -> BoardConfig.ItemsView: ...
        def keys(self) -> BoardConfig.KeysView: ...
        def values(self) -> BoardConfig.ValuesView: ...
        def __bool__(self) -> bool: ...
        @overload
        def __contains__(self, arg0: int) -> bool: ...
        @overload
        def __contains__(self, arg0: object) -> bool: ...
        def __delitem__(self, arg0: int) -> None: ...
        def __getitem__(self, arg0: int) -> BoardConfig.GPIO: ...
        def __iter__(self) -> Iterator[int]: ...
        def __len__(self) -> int: ...
        def __setitem__(self, arg0: int, arg1: BoardConfig.GPIO) -> None: ...

    class ItemsView:
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> Iterator: ...
        def __len__(self) -> int: ...

    class KeysView:
        def __init__(self, *args, **kwargs) -> None: ...
        def __contains__(self, arg0: object) -> bool: ...
        def __iter__(self) -> Iterator: ...
        def __len__(self) -> int: ...

    class Network:
        mtu: int
        xlinkTcpNoDelay: bool
        def __init__(self) -> None: ...

    class UART:
        tmp: int
        def __init__(self) -> None: ...

    class UARTMap:
        def __init__(self) -> None: ...
        def items(self) -> BoardConfig.ItemsView: ...
        def keys(self) -> BoardConfig.KeysView: ...
        def values(self) -> BoardConfig.ValuesView: ...
        def __bool__(self) -> bool: ...
        @overload
        def __contains__(self, arg0: int) -> bool: ...
        @overload
        def __contains__(self, arg0: object) -> bool: ...
        def __delitem__(self, arg0: int) -> None: ...
        def __getitem__(self, arg0: int) -> BoardConfig.UART: ...
        def __iter__(self) -> Iterator[int]: ...
        def __len__(self) -> int: ...
        def __setitem__(self, arg0: int, arg1: BoardConfig.UART) -> None: ...

    class USB:
        flashBootedPid: int
        flashBootedVid: int
        manufacturer: str
        maxSpeed: UsbSpeed
        pid: int
        productName: str
        vid: int
        def __init__(self) -> None: ...

    class UVC:
        cameraName: str
        enable: bool
        frameType: ImgFrame.Type
        height: int
        width: int
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, arg0: int, arg1: int) -> None: ...

    class ValuesView:
        def __init__(self, *args, **kwargs) -> None: ...
        def __iter__(self) -> Iterator: ...
        def __len__(self) -> int: ...
    emmc: Optional[bool]
    gpio: BoardConfig.GPIOMap
    logDevicePrints: Optional[bool]
    logPath: Optional[str]
    logSizeMax: Optional[int]
    logVerbosity: Optional[LogLevel]
    mipi4LaneRgb: Optional[bool]
    network: BoardConfig.Network
    pcieInternalClock: Optional[bool]
    sysctl: list[str]
    uart: BoardConfig.UARTMap
    usb: BoardConfig.USB
    usb3PhyInternalClock: Optional[bool]
    uvc: Optional[BoardConfig.UVC]
    watchdogInitialDelayMs: Optional[int]
    watchdogTimeoutMs: Optional[int]
    def __init__(self) -> None: ...

class Buffer(ADatatype):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    def getData(self) -> numpy.ndarray[numpy.uint8]: ...
    def getSequenceNum(self) -> int: ...
    def getTimestamp(self) -> datetime.timedelta: ...
    def getTimestampDevice(self) -> datetime.timedelta: ...
    def getVisualizationMessage(self) -> Union[ImgAnnotations,ImgFrame,None]: ...
    @overload
    def setData(self, arg0, std) -> None: ...
    @overload
    def setData(self, arg0: numpy.ndarray[numpy.uint8]) -> None: ...
    @overload
    def setData(self, arg0: Buffer) -> None: ...
    def setSequenceNum(self, arg0: int) -> None: ...
    def setTimestamp(self, arg0: datetime.timedelta) -> None: ...
    def setTimestampDevice(self, arg0: datetime.timedelta) -> None: ...

class CalibrationHandler:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: os.PathLike) -> None: ...
    @overload
    def __init__(self, arg0: os.PathLike, arg1: os.PathLike) -> None: ...
    @overload
    def __init__(self, arg0: EepromData) -> None: ...
    def eepromToJson(self) -> json: ...
    def eepromToJsonFile(self, destPath: os.PathLike) -> bool: ...
    @classmethod
    def fromJson(cls, arg0: json) -> CalibrationHandler: ...
    def getBaselineDistance(self, cam1: CameraBoardSocket = ..., cam2: CameraBoardSocket = ..., useSpecTranslation: bool = ...) -> float: ...
    def getCameraExtrinsics(self, srcCamera: CameraBoardSocket, dstCamera: CameraBoardSocket, useSpecTranslation: bool = ...) -> list[list[float]]: ...
    @overload
    def getCameraIntrinsics(self, cameraId: CameraBoardSocket, resizeWidth: int = ..., resizeHeight: int = ..., topLeftPixelId: Point2f = ..., bottomRightPixelId: Point2f = ..., keepAspectRatio: bool = ...) -> list[list[float]]: ...
    @overload
    def getCameraIntrinsics(self, cameraId: CameraBoardSocket, destShape: Size2f, topLeftPixelId: Point2f = ..., bottomRightPixelId: Point2f = ..., keepAspectRatio: bool = ...) -> list[list[float]]: ...
    @overload
    def getCameraIntrinsics(self, cameraId: CameraBoardSocket, destShape: tuple[int,int], topLeftPixelId: Point2f = ..., bottomRightPixelId: Point2f = ..., keepAspectRatio: bool = ...) -> list[list[float]]: ...
    def getCameraRotationMatrix(self, srcCamera: CameraBoardSocket, dstCamera: CameraBoardSocket) -> list[list[float]]: ...
    def getCameraToImuExtrinsics(self, cameraId: CameraBoardSocket, useSpecTranslation: bool = ...) -> list[list[float]]: ...
    def getCameraTranslationVector(self, srcCamera: CameraBoardSocket, dstCamera: CameraBoardSocket, useSpecTranslation: bool = ...) -> list[float]: ...
    def getDefaultIntrinsics(self, cameraId: CameraBoardSocket) -> tuple[list[list[float]],int,int]: ...
    def getDistortionCoefficients(self, cameraId: CameraBoardSocket) -> list[float]: ...
    def getDistortionModel(self, cameraId: CameraBoardSocket) -> CameraModel: ...
    def getEepromData(self) -> EepromData: ...
    def getFov(self, cameraId: CameraBoardSocket, useSpec: bool = ...) -> float: ...
    def getImuToCameraExtrinsics(self, cameraId: CameraBoardSocket, useSpecTranslation: bool = ...) -> list[list[float]]: ...
    def getLensPosition(self, cameraId: CameraBoardSocket) -> int: ...
    def getStereoLeftCameraId(self) -> CameraBoardSocket: ...
    def getStereoLeftRectificationRotation(self) -> list[list[float]]: ...
    def getStereoRightCameraId(self) -> CameraBoardSocket: ...
    def getStereoRightRectificationRotation(self) -> list[list[float]]: ...
    @overload
    def setBoardInfo(self, boardName: str, boardRev: str) -> None: ...
    @overload
    def setBoardInfo(self, productName: str, boardName: str, boardRev: str, boardConf: str, hardwareConf: str, batchName: str, batchTime: int, boardOptions: int, boardCustom: str = ...) -> None: ...
    @overload
    def setBoardInfo(self, deviceName: str, productName: str, boardName: str, boardRev: str, boardConf: str, hardwareConf: str, batchName: str, batchTime: int, boardOptions: int, boardCustom: str = ...) -> None: ...
    def setCameraExtrinsics(self, srcCameraId: CameraBoardSocket, destCameraId: CameraBoardSocket, rotationMatrix: list[list[float]], translation: list[float], specTranslation: list[float] = ...) -> None: ...
    @overload
    def setCameraIntrinsics(self, cameraId: CameraBoardSocket, intrinsics: list[list[float]], frameSize: Size2f) -> None: ...
    @overload
    def setCameraIntrinsics(self, cameraId: CameraBoardSocket, intrinsics: list[list[float]], width: int, height: int) -> None: ...
    @overload
    def setCameraIntrinsics(self, cameraId: CameraBoardSocket, intrinsics: list[list[float]], frameSize: tuple[int,int]) -> None: ...
    def setCameraType(self, cameraId: CameraBoardSocket, cameraModel: CameraModel) -> None: ...
    def setDeviceName(self, deviceName: str) -> None: ...
    def setDistortionCoefficients(self, cameraId: CameraBoardSocket, distortionCoefficients: list[float]) -> None: ...
    def setFov(self, cameraId: CameraBoardSocket, hfov: float) -> None: ...
    def setImuExtrinsics(self, destCameraId: CameraBoardSocket, rotationMatrix: list[list[float]], translation: list[float], specTranslation: list[float] = ...) -> None: ...
    def setLensPosition(self, cameraId: CameraBoardSocket, lensPosition: int) -> None: ...
    def setProductName(self, productName: str) -> None: ...
    def setStereoLeft(self, cameraId: CameraBoardSocket, rectifiedRotation: list[list[float]]) -> None: ...
    def setStereoRight(self, cameraId: CameraBoardSocket, rectifiedRotation: list[list[float]]) -> None: ...

class CalibrationQuality(Buffer):
    info: str
    qualityData: Optional[CalibrationQualityData]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, qualityData: CalibrationQualityData, info: str) -> None: ...
    @overload
    def __init__(self, info: str) -> None: ...

class CalibrationQualityData:
    depthErrorDifference: list[float]
    rotationChange: Any
    sampsonErrorCurrent: float
    sampsonErrorNew: float
    def __init__(self) -> None: ...

class CameraBoardSocket:
    CENTER: ClassVar[CameraBoardSocket] = ...  # read-only
    LEFT: ClassVar[CameraBoardSocket] = ...  # read-only
    RGB: ClassVar[CameraBoardSocket] = ...  # read-only
    RIGHT: ClassVar[CameraBoardSocket] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    AUTO: ClassVar[CameraBoardSocket] = ...
    CAM_A: ClassVar[CameraBoardSocket] = ...
    CAM_B: ClassVar[CameraBoardSocket] = ...
    CAM_C: ClassVar[CameraBoardSocket] = ...
    CAM_D: ClassVar[CameraBoardSocket] = ...
    CAM_E: ClassVar[CameraBoardSocket] = ...
    CAM_F: ClassVar[CameraBoardSocket] = ...
    CAM_G: ClassVar[CameraBoardSocket] = ...
    CAM_H: ClassVar[CameraBoardSocket] = ...
    VERTICAL: ClassVar[CameraBoardSocket] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CameraControl(Buffer):
    class AntiBandingMode:
        __members__: ClassVar[dict] = ...  # read-only
        AUTO: ClassVar[CameraControl.AntiBandingMode] = ...
        MAINS_50_HZ: ClassVar[CameraControl.AntiBandingMode] = ...
        MAINS_60_HZ: ClassVar[CameraControl.AntiBandingMode] = ...
        OFF: ClassVar[CameraControl.AntiBandingMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class AutoFocusMode:
        __members__: ClassVar[dict] = ...  # read-only
        AUTO: ClassVar[CameraControl.AutoFocusMode] = ...
        CONTINUOUS_PICTURE: ClassVar[CameraControl.AutoFocusMode] = ...
        CONTINUOUS_VIDEO: ClassVar[CameraControl.AutoFocusMode] = ...
        EDOF: ClassVar[CameraControl.AutoFocusMode] = ...
        MACRO: ClassVar[CameraControl.AutoFocusMode] = ...
        OFF: ClassVar[CameraControl.AutoFocusMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class AutoWhiteBalanceMode:
        __members__: ClassVar[dict] = ...  # read-only
        AUTO: ClassVar[CameraControl.AutoWhiteBalanceMode] = ...
        CLOUDY_DAYLIGHT: ClassVar[CameraControl.AutoWhiteBalanceMode] = ...
        DAYLIGHT: ClassVar[CameraControl.AutoWhiteBalanceMode] = ...
        FLUORESCENT: ClassVar[CameraControl.AutoWhiteBalanceMode] = ...
        INCANDESCENT: ClassVar[CameraControl.AutoWhiteBalanceMode] = ...
        OFF: ClassVar[CameraControl.AutoWhiteBalanceMode] = ...
        SHADE: ClassVar[CameraControl.AutoWhiteBalanceMode] = ...
        TWILIGHT: ClassVar[CameraControl.AutoWhiteBalanceMode] = ...
        WARM_FLUORESCENT: ClassVar[CameraControl.AutoWhiteBalanceMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class CaptureIntent:
        __members__: ClassVar[dict] = ...  # read-only
        CUSTOM: ClassVar[CameraControl.CaptureIntent] = ...
        PREVIEW: ClassVar[CameraControl.CaptureIntent] = ...
        STILL_CAPTURE: ClassVar[CameraControl.CaptureIntent] = ...
        VIDEO_RECORD: ClassVar[CameraControl.CaptureIntent] = ...
        VIDEO_SNAPSHOT: ClassVar[CameraControl.CaptureIntent] = ...
        ZERO_SHUTTER_LAG: ClassVar[CameraControl.CaptureIntent] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Command:
        __members__: ClassVar[dict] = ...  # read-only
        AE_AUTO: ClassVar[CameraControl.Command] = ...
        AE_LOCK: ClassVar[CameraControl.Command] = ...
        AE_MANUAL: ClassVar[CameraControl.Command] = ...
        AE_REGION: ClassVar[CameraControl.Command] = ...
        AE_TARGET_FPS_RANGE: ClassVar[CameraControl.Command] = ...
        AF_MODE: ClassVar[CameraControl.Command] = ...
        AF_REGION: ClassVar[CameraControl.Command] = ...
        AF_TRIGGER: ClassVar[CameraControl.Command] = ...
        ANTIBANDING_MODE: ClassVar[CameraControl.Command] = ...
        AWB_LOCK: ClassVar[CameraControl.Command] = ...
        AWB_MODE: ClassVar[CameraControl.Command] = ...
        BRIGHTNESS: ClassVar[CameraControl.Command] = ...
        CAPTURE_INTENT: ClassVar[CameraControl.Command] = ...
        CHROMA_DENOISE: ClassVar[CameraControl.Command] = ...
        CONTRAST: ClassVar[CameraControl.Command] = ...
        CONTROL_MODE: ClassVar[CameraControl.Command] = ...
        CUSTOM_CAPTURE: ClassVar[CameraControl.Command] = ...
        CUSTOM_CAPT_MODE: ClassVar[CameraControl.Command] = ...
        CUSTOM_EXP_BRACKETS: ClassVar[CameraControl.Command] = ...
        CUSTOM_USECASE: ClassVar[CameraControl.Command] = ...
        EFFECT_MODE: ClassVar[CameraControl.Command] = ...
        EXPOSURE_COMPENSATION: ClassVar[CameraControl.Command] = ...
        FRAME_DURATION: ClassVar[CameraControl.Command] = ...
        LUMA_DENOISE: ClassVar[CameraControl.Command] = ...
        MOVE_LENS: ClassVar[CameraControl.Command] = ...
        NOISE_REDUCTION_STRENGTH: ClassVar[CameraControl.Command] = ...
        RESOLUTION: ClassVar[CameraControl.Command] = ...
        SATURATION: ClassVar[CameraControl.Command] = ...
        SCENE_MODE: ClassVar[CameraControl.Command] = ...
        SENSITIVITY: ClassVar[CameraControl.Command] = ...
        SHARPNESS: ClassVar[CameraControl.Command] = ...
        START_STREAM: ClassVar[CameraControl.Command] = ...
        STILL_CAPTURE: ClassVar[CameraControl.Command] = ...
        STOP_STREAM: ClassVar[CameraControl.Command] = ...
        STREAM_FORMAT: ClassVar[CameraControl.Command] = ...
        WB_COLOR_TEMP: ClassVar[CameraControl.Command] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class ControlMode:
        __members__: ClassVar[dict] = ...  # read-only
        AUTO: ClassVar[CameraControl.ControlMode] = ...
        OFF: ClassVar[CameraControl.ControlMode] = ...
        USE_SCENE_MODE: ClassVar[CameraControl.ControlMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class EffectMode:
        __members__: ClassVar[dict] = ...  # read-only
        AQUA: ClassVar[CameraControl.EffectMode] = ...
        BLACKBOARD: ClassVar[CameraControl.EffectMode] = ...
        MONO: ClassVar[CameraControl.EffectMode] = ...
        NEGATIVE: ClassVar[CameraControl.EffectMode] = ...
        OFF: ClassVar[CameraControl.EffectMode] = ...
        POSTERIZE: ClassVar[CameraControl.EffectMode] = ...
        SEPIA: ClassVar[CameraControl.EffectMode] = ...
        SOLARIZE: ClassVar[CameraControl.EffectMode] = ...
        WHITEBOARD: ClassVar[CameraControl.EffectMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class FrameSyncMode:
        __members__: ClassVar[dict] = ...  # read-only
        INPUT: ClassVar[CameraControl.FrameSyncMode] = ...
        OFF: ClassVar[CameraControl.FrameSyncMode] = ...
        OUTPUT: ClassVar[CameraControl.FrameSyncMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class SceneMode:
        __members__: ClassVar[dict] = ...  # read-only
        ACTION: ClassVar[CameraControl.SceneMode] = ...
        BARCODE: ClassVar[CameraControl.SceneMode] = ...
        BEACH: ClassVar[CameraControl.SceneMode] = ...
        CANDLELIGHT: ClassVar[CameraControl.SceneMode] = ...
        FACE_PRIORITY: ClassVar[CameraControl.SceneMode] = ...
        FIREWORKS: ClassVar[CameraControl.SceneMode] = ...
        LANDSCAPE: ClassVar[CameraControl.SceneMode] = ...
        NIGHT: ClassVar[CameraControl.SceneMode] = ...
        NIGHT_PORTRAIT: ClassVar[CameraControl.SceneMode] = ...
        PARTY: ClassVar[CameraControl.SceneMode] = ...
        PORTRAIT: ClassVar[CameraControl.SceneMode] = ...
        SNOW: ClassVar[CameraControl.SceneMode] = ...
        SPORTS: ClassVar[CameraControl.SceneMode] = ...
        STEADYPHOTO: ClassVar[CameraControl.SceneMode] = ...
        SUNSET: ClassVar[CameraControl.SceneMode] = ...
        THEATRE: ClassVar[CameraControl.SceneMode] = ...
        UNSUPPORTED: ClassVar[CameraControl.SceneMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    aeLockMode: bool
    aeMaxExposureTimeUs: int
    afRegion: Any
    antiBandingMode: CameraControl.AntiBandingMode
    autoFocusMode: CameraControl.AutoFocusMode
    awbLockMode: bool
    awbMode: CameraControl.AutoWhiteBalanceMode
    brightness: int
    captureIntent: CameraControl.CaptureIntent
    chromaDenoise: int
    cmdMask: int
    contrast: int
    controlMode: CameraControl.ControlMode
    effectMode: CameraControl.EffectMode
    expCompensation: int
    expManual: Any
    lensPosition: int
    lumaDenoise: int
    saturation: int
    sceneMode: CameraControl.SceneMode
    sharpness: int
    wbColorTemp: int
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def clearCommand(self, arg0: CameraControl.Command) -> None: ...
    def clearMiscControls(self) -> None: ...
    def getCaptureStill(self) -> bool: ...
    def getCommand(self, arg0: CameraControl.Command) -> bool: ...
    def getExposureTime(self) -> datetime.timedelta: ...
    def getHdr(self) -> bool: ...
    def getLensPosition(self) -> int: ...
    def getLensPositionRaw(self) -> float: ...
    def getMiscControls(self) -> list[tuple[str,str]]: ...
    def getSensitivity(self) -> int: ...
    def setAntiBandingMode(self, mode: CameraControl.AntiBandingMode) -> CameraControl: ...
    def setAutoExposureCompensation(self, compensation: int) -> CameraControl: ...
    def setAutoExposureEnable(self) -> CameraControl: ...
    @overload
    def setAutoExposureLimit(self, maxExposureTimeUs: int) -> CameraControl: ...
    @overload
    def setAutoExposureLimit(self, maxExposureTime: datetime.timedelta) -> CameraControl: ...
    def setAutoExposureLock(self, lock: bool) -> CameraControl: ...
    def setAutoExposureRegion(self, startX: int, startY: int, width: int, height: int) -> CameraControl: ...
    def setAutoFocusLensRange(self, infinityPosition: int, macroPosition: int) -> CameraControl: ...
    def setAutoFocusMode(self, mode: CameraControl.AutoFocusMode) -> CameraControl: ...
    def setAutoFocusRegion(self, startX: int, startY: int, width: int, height: int) -> CameraControl: ...
    def setAutoFocusTrigger(self) -> CameraControl: ...
    def setAutoWhiteBalanceLock(self, lock: bool) -> CameraControl: ...
    def setAutoWhiteBalanceMode(self, mode: CameraControl.AutoWhiteBalanceMode) -> CameraControl: ...
    def setBrightness(self, value: int) -> CameraControl: ...
    def setCaptureIntent(self, mode: CameraControl.CaptureIntent) -> CameraControl: ...
    def setCaptureStill(self, capture: bool) -> CameraControl: ...
    def setChromaDenoise(self, value: int) -> CameraControl: ...
    def setCommand(self, arg0: CameraControl.Command, arg1: bool) -> None: ...
    def setContrast(self, value: int) -> CameraControl: ...
    def setControlMode(self, mode: CameraControl.ControlMode) -> CameraControl: ...
    def setEffectMode(self, mode: CameraControl.EffectMode) -> CameraControl: ...
    def setExternalTrigger(self, numFramesBurst: int, numFramesDiscard: int) -> CameraControl: ...
    def setFrameSyncMode(self, mode: CameraControl.FrameSyncMode) -> CameraControl: ...
    def setHdr(self, enable: bool) -> CameraControl: ...
    def setLumaDenoise(self, value: int) -> CameraControl: ...
    @overload
    def setManualExposure(self, exposureTimeUs: int, sensitivityIso: int) -> CameraControl: ...
    @overload
    def setManualExposure(self, exposureTime: datetime.timedelta, sensitivityIso: int) -> CameraControl: ...
    def setManualFocus(self, lensPosition: int) -> CameraControl: ...
    def setManualFocusRaw(self, lensPositionRaw: float) -> CameraControl: ...
    def setManualWhiteBalance(self, colorTemperatureK: int) -> CameraControl: ...
    @overload
    def setMisc(self, control: str, value: str) -> CameraControl: ...
    @overload
    def setMisc(self, control: str, value: int) -> CameraControl: ...
    @overload
    def setMisc(self, control: str, value: float) -> CameraControl: ...
    def setSaturation(self, value: int) -> CameraControl: ...
    def setSceneMode(self, mode: CameraControl.SceneMode) -> CameraControl: ...
    def setSharpness(self, value: int) -> CameraControl: ...
    def setStartStreaming(self) -> CameraControl: ...
    def setStopStreaming(self) -> CameraControl: ...
    def setStrobeDisable(self) -> CameraControl: ...
    def setStrobeExternal(self, gpioNumber: int, activeLevel: int) -> CameraControl: ...
    def setStrobeSensor(self, activeLevel: int) -> CameraControl: ...

class CameraExposureOffset:
    __members__: ClassVar[dict] = ...  # read-only
    END: ClassVar[CameraExposureOffset] = ...
    MIDDLE: ClassVar[CameraExposureOffset] = ...
    START: ClassVar[CameraExposureOffset] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CameraFeatures:
    calibrationResolution: Optional[CameraSensorConfig]
    configs: list[CameraSensorConfig]
    hasAutofocus: bool
    hasAutofocusIC: bool
    height: int
    name: str
    orientation: CameraImageOrientation
    sensorName: str
    socket: CameraBoardSocket
    supportedTypes: list[CameraSensorType]
    width: int
    def __init__(self) -> None: ...

class CameraImageOrientation:
    __members__: ClassVar[dict] = ...  # read-only
    AUTO: ClassVar[CameraImageOrientation] = ...
    HORIZONTAL_MIRROR: ClassVar[CameraImageOrientation] = ...
    NORMAL: ClassVar[CameraImageOrientation] = ...
    ROTATE_180_DEG: ClassVar[CameraImageOrientation] = ...
    VERTICAL_FLIP: ClassVar[CameraImageOrientation] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CameraInfo:
    cameraType: CameraModel
    distortionCoeff: list[float]
    extrinsics: Extrinsics
    height: int
    intrinsicMatrix: list[list[float]]
    specHfovDeg: float
    width: int
    def __init__(self) -> None: ...

class CameraModel:
    __members__: ClassVar[dict] = ...  # read-only
    Equirectangular: ClassVar[CameraModel] = ...
    Fisheye: ClassVar[CameraModel] = ...
    Perspective: ClassVar[CameraModel] = ...
    RadialDivision: ClassVar[CameraModel] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CameraSensorConfig:
    fov: Rect
    height: int
    maxFps: float
    minFps: float
    type: CameraSensorType
    width: int
    def __init__(self) -> None: ...

class CameraSensorType:
    __members__: ClassVar[dict] = ...  # read-only
    COLOR: ClassVar[CameraSensorType] = ...
    MONO: ClassVar[CameraSensorType] = ...
    THERMAL: ClassVar[CameraSensorType] = ...
    TOF: ClassVar[CameraSensorType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Capability:
    def __init__(self, *args, **kwargs) -> None: ...

class CapabilityRangeFloat:
    def __init__(self, *args, **kwargs) -> None: ...
    def discrete(self, arg0: list[float]) -> None: ...
    def fixed(self, arg0: float) -> None: ...
    @overload
    def minMax(self, arg0: tuple[float,float]) -> None: ...
    @overload
    def minMax(self, arg0: tuple[float,float]) -> None: ...
    @overload
    def minMax(self, arg0: float, arg1: float) -> None: ...

class CapabilityRangeFloatPair:
    def __init__(self, *args, **kwargs) -> None: ...
    def discrete(self, arg0: list[tuple[float,float]]) -> None: ...
    def fixed(self, arg0: tuple[float,float]) -> None: ...
    @overload
    def minMax(self, arg0: tuple[tuple[float,float],tuple[float,float]]) -> None: ...
    @overload
    def minMax(self, arg0: tuple[tuple[float,float],tuple[float,float]]) -> None: ...
    @overload
    def minMax(self, arg0: tuple[float,float], arg1: tuple[float,float]) -> None: ...

class CapabilityRangeUint:
    def __init__(self, *args, **kwargs) -> None: ...
    def discrete(self, arg0: list[int]) -> None: ...
    def fixed(self, arg0: int) -> None: ...
    @overload
    def minMax(self, arg0: tuple[int,int]) -> None: ...
    @overload
    def minMax(self, arg0: tuple[int,int]) -> None: ...
    @overload
    def minMax(self, arg0: int, arg1: int) -> None: ...

class CapabilityRangeUintPair:
    def __init__(self, *args, **kwargs) -> None: ...
    def discrete(self, arg0: list[tuple[int,int]]) -> None: ...
    def fixed(self, arg0: tuple[int,int]) -> None: ...
    @overload
    def minMax(self, arg0: tuple[tuple[int,int],tuple[int,int]]) -> None: ...
    @overload
    def minMax(self, arg0: tuple[tuple[int,int],tuple[int,int]]) -> None: ...
    @overload
    def minMax(self, arg0: tuple[int,int], arg1: tuple[int,int]) -> None: ...

class ChipTemperature:
    average: float
    css: float
    dss: float
    mss: float
    upa: float
    def __init__(self) -> None: ...

class ChipTemperatureS3:
    average: float
    css: float
    mss: float
    nce: float
    soc: float
    def __init__(self) -> None: ...

class CircleAnnotation:
    diameter: float
    fillColor: Color
    outlineColor: Color
    position: Point2f
    thickness: float
    def __init__(self) -> None: ...

class Clock:
    def __init__(self, *args, **kwargs) -> None: ...
    def now(self) -> datetime.timedelta: ...

class Color:
    a: float
    b: float
    g: float
    r: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, r: float, g: float, b: float, a: float = ...) -> None: ...

class ColorCameraProperties:
    class ColorOrder:
        __members__: ClassVar[dict] = ...  # read-only
        BGR: ClassVar[ColorCameraProperties.ColorOrder] = ...
        RGB: ClassVar[ColorCameraProperties.ColorOrder] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class SensorResolution:
        __members__: ClassVar[dict] = ...  # read-only
        THE_1080_P: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_1200_P: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_1280X962: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_12_MP: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_1352X1012: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_13_MP: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_1440X1080: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_2000X1500: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_2024X1520: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_2028X1520: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_2104X1560: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_240X180: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_4000X3000: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_48_MP: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_4_K: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_5312X6000: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_5_MP: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_720_P: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_800_P: ClassVar[ColorCameraProperties.SensorResolution] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class WarpMeshSource:
        __members__: ClassVar[dict] = ...  # read-only
        AUTO: ClassVar[ColorCameraProperties.WarpMeshSource] = ...
        CALIBRATION: ClassVar[ColorCameraProperties.WarpMeshSource] = ...
        NONE: ClassVar[ColorCameraProperties.WarpMeshSource] = ...
        URI: ClassVar[ColorCameraProperties.WarpMeshSource] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    boardSocket: CameraBoardSocket
    calibAlpha: float
    eventFilter: list[FrameEvent]
    fps: float
    imageOrientation: CameraImageOrientation
    initialControl: CameraControl
    isp3aFps: int
    ispScale: Any
    numFramesPoolIsp: int
    numFramesPoolPreview: int
    numFramesPoolRaw: int
    numFramesPoolStill: int
    numFramesPoolVideo: int
    previewHeight: int
    previewKeepAspectRatio: bool
    previewWidth: int
    resolution: ColorCameraProperties.SensorResolution
    sensorCropX: float
    sensorCropY: float
    stillHeight: int
    stillWidth: int
    videoHeight: int
    videoWidth: int
    warpMeshHeight: int
    warpMeshSource: ColorCameraProperties.WarpMeshSource
    warpMeshStepHeight: int
    warpMeshStepWidth: int
    warpMeshUri: str
    warpMeshWidth: int
    def __init__(self, *args, **kwargs) -> None: ...

class Colormap:
    __members__: ClassVar[dict] = ...  # read-only
    JET: ClassVar[Colormap] = ...
    NONE: ClassVar[Colormap] = ...
    STEREO_JET: ClassVar[Colormap] = ...
    STEREO_TURBO: ClassVar[Colormap] = ...
    TURBO: ClassVar[Colormap] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CoverageData(Buffer):
    coverageAcquired: float
    coveragePerCellA: list[list[float]]
    coveragePerCellB: list[list[float]]
    dataAcquired: float
    meanCoverage: float
    def __init__(self) -> None: ...

class CpuUsage:
    average: float
    msTime: int
    def __init__(self) -> None: ...

class CrashDump:
    class CrashReport:
        class ErrorSourceInfo:
            class AssertContext:
                fileName: str
                functionName: str
                line: int
                def __init__(self) -> None: ...
        
            class TrapContext:
                trapAddress: int
                trapName: str
                trapNumber: int
                def __init__(self) -> None: ...
            assertContext: CrashDump.CrashReport.ErrorSourceInfo.AssertContext
            errorId: int
            trapContext: CrashDump.CrashReport.ErrorSourceInfo.TrapContext
            def __init__(self) -> None: ...
    
        class ThreadCallstack:
            class CallstackContext:
                callSite: int
                calledTarget: int
                context: str
                framePointer: int
                def __init__(self) -> None: ...
            callStack: list[CrashDump.CrashReport.ThreadCallstack.CallstackContext]
            instructionPointer: int
            stackBottom: int
            stackPointer: int
            stackTop: int
            threadId: int
            threadName: str
            threadStatus: str
            def __init__(self) -> None: ...
        crashedThreadId: int
        errorSource: str
        processor: ProcessorType
        threadCallstack: list[CrashDump.CrashReport.ThreadCallstack]
        def __init__(self) -> None: ...
    crashReports: list[CrashDump.CrashReport]
    depthaiCommitHash: str
    deviceId: str
    def __init__(self) -> None: ...
    def serializeToJson(self) -> json: ...

class DatatypeEnum:
    __members__: ClassVar[dict] = ...  # read-only
    ADatatype: ClassVar[DatatypeEnum] = ...
    AprilTagConfig: ClassVar[DatatypeEnum] = ...
    AprilTags: ClassVar[DatatypeEnum] = ...
    BenchmarkReport: ClassVar[DatatypeEnum] = ...
    Buffer: ClassVar[DatatypeEnum] = ...
    CameraControl: ClassVar[DatatypeEnum] = ...
    EdgeDetectorConfig: ClassVar[DatatypeEnum] = ...
    EncodedFrame: ClassVar[DatatypeEnum] = ...
    FeatureTrackerConfig: ClassVar[DatatypeEnum] = ...
    IMUData: ClassVar[DatatypeEnum] = ...
    ImageAlignConfig: ClassVar[DatatypeEnum] = ...
    ImageManipConfig: ClassVar[DatatypeEnum] = ...
    ImgAnnotations: ClassVar[DatatypeEnum] = ...
    ImgDetections: ClassVar[DatatypeEnum] = ...
    ImgFrame: ClassVar[DatatypeEnum] = ...
    MessageGroup: ClassVar[DatatypeEnum] = ...
    NNData: ClassVar[DatatypeEnum] = ...
    PointCloudConfig: ClassVar[DatatypeEnum] = ...
    PointCloudData: ClassVar[DatatypeEnum] = ...
    RGBDData: ClassVar[DatatypeEnum] = ...
    SpatialImgDetections: ClassVar[DatatypeEnum] = ...
    SpatialLocationCalculatorConfig: ClassVar[DatatypeEnum] = ...
    SpatialLocationCalculatorData: ClassVar[DatatypeEnum] = ...
    StereoDepthConfig: ClassVar[DatatypeEnum] = ...
    SystemInformation: ClassVar[DatatypeEnum] = ...
    SystemInformationS3: ClassVar[DatatypeEnum] = ...
    ThermalConfig: ClassVar[DatatypeEnum] = ...
    ToFConfig: ClassVar[DatatypeEnum] = ...
    TrackedFeatures: ClassVar[DatatypeEnum] = ...
    Tracklets: ClassVar[DatatypeEnum] = ...
    TransformData: ClassVar[DatatypeEnum] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class DetectionNetworkType:
    __members__: ClassVar[dict] = ...  # read-only
    MOBILENET: ClassVar[DetectionNetworkType] = ...
    YOLO: ClassVar[DetectionNetworkType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class DetectionParserOptions:
    anchorMasks: dict[str,list[int]]
    anchors: list[float]
    classes: int
    confidenceThreshold: float
    coordinates: int
    iouThreshold: float
    nnFamily: DetectionNetworkType
    def __init__(self, *args, **kwargs) -> None: ...

class DetectionParserProperties:
    parser: DetectionParserOptions
    def __init__(self, *args, **kwargs) -> None: ...

class Device(DeviceBase):
    class Config:
        board: BoardConfig
        logLevel: Optional[LogLevel]
        nonExclusiveMode: bool
        outputLogLevel: Optional[LogLevel]
        version: OpenVINO.Version
        def __init__(self) -> None: ...

    class ReconnectionStatus:
        __members__: ClassVar[dict] = ...  # read-only
        RECONNECTED: ClassVar[Device.ReconnectionStatus] = ...
        RECONNECTING: ClassVar[Device.ReconnectionStatus] = ...
        RECONNECT_FAILED: ClassVar[Device.ReconnectionStatus] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, maxUsbSpeed: UsbSpeed) -> None: ...
    @overload
    def __init__(self, deviceInfo: DeviceInfo, maxUsbSpeed: UsbSpeed) -> None: ...
    @overload
    def __init__(self, deviceDesc: DeviceInfo, pathToCmd: os.PathLike) -> None: ...
    @overload
    def __init__(self, config: Device.Config) -> None: ...
    @overload
    def __init__(self, config: Device.Config, deviceInfo: DeviceInfo) -> None: ...
    @overload
    def __init__(self, deviceInfo: DeviceInfo) -> None: ...
    @overload
    def __init__(self, deviceInfo: DeviceInfo, maxUsbSpeed: UsbSpeed) -> None: ...
    @overload
    def __init__(self, nameOrDeviceId: str) -> None: ...
    @overload
    def __init__(self, nameOrDeviceId: str, maxUsbSpeed: UsbSpeed) -> None: ...
    def getPlatform(self) -> Platform: ...
    def getPlatformAsString(self) -> str: ...

class DeviceBase:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, maxUsbSpeed: UsbSpeed) -> None: ...
    @overload
    def __init__(self, deviceInfo: DeviceInfo, maxUsbSpeed: UsbSpeed) -> None: ...
    @overload
    def __init__(self, deviceDesc: DeviceInfo, pathToCmd: os.PathLike) -> None: ...
    @overload
    def __init__(self, config: Device.Config) -> None: ...
    @overload
    def __init__(self, config: Device.Config, deviceInfo: DeviceInfo) -> None: ...
    @overload
    def __init__(self, deviceInfo: DeviceInfo) -> None: ...
    @overload
    def __init__(self, deviceInfo: DeviceInfo, maxUsbSpeed: UsbSpeed) -> None: ...
    @overload
    def __init__(self, nameOrDeviceId: str) -> None: ...
    @overload
    def __init__(self, nameOrDeviceId: str, maxUsbSpeed: UsbSpeed) -> None: ...
    def addLogCallback(self, callback: Callable[[LogMessage],None]) -> int: ...
    def close(self) -> None: ...
    def crashDevice(self) -> None: ...
    def factoryResetCalibration(self) -> None: ...
    def flashCalibration(self, arg0: CalibrationHandler) -> None: ...
    def flashEepromClear(self) -> None: ...
    def flashFactoryCalibration(self, arg0: CalibrationHandler) -> None: ...
    def flashFactoryEepromClear(self) -> None: ...
    @classmethod
    def getAllAvailableDevices(cls) -> list[DeviceInfo]: ...
    @classmethod
    def getAllConnectedDevices(cls) -> list[DeviceInfo]: ...
    @overload
    @classmethod
    def getAnyAvailableDevice(cls, timeout: datetime.timedelta) -> tuple[bool,DeviceInfo]: ...
    @overload
    @classmethod
    def getAnyAvailableDevice(cls) -> tuple[bool,DeviceInfo]: ...
    def getAvailableStereoPairs(self) -> list[StereoPair]: ...
    def getBootloaderVersion(self) -> Optional[Version]: ...
    def getCalibration(self) -> CalibrationHandler: ...
    def getCameraSensorNames(self) -> dict[CameraBoardSocket,str]: ...
    def getChipTemperature(self) -> ChipTemperature: ...
    def getCmxMemoryUsage(self) -> MemoryInfo: ...
    def getConnectedCameraFeatures(self) -> list[CameraFeatures]: ...
    def getConnectedCameras(self) -> list[CameraBoardSocket]: ...
    def getConnectedIMU(self) -> str: ...
    def getConnectionInterfaces(self) -> list[connectionInterface]: ...
    def getCrashDump(self, clearCrashDump: bool = ...) -> CrashDump: ...
    def getDdrMemoryUsage(self) -> MemoryInfo: ...
    @classmethod
    def getDeviceById(cls, deviceId: str) -> tuple[bool,DeviceInfo]: ...
    def getDeviceId(self) -> str: ...
    def getDeviceInfo(self) -> DeviceInfo: ...
    def getDeviceName(self) -> object: ...
    @classmethod
    def getEmbeddedDeviceBinary(cls, *args, **kwargs) -> Any: ...
    def getEmbeddedIMUFirmwareVersion(self) -> Version: ...
    @classmethod
    def getFirstAvailableDevice(cls, skipInvalidDevices: bool = ...) -> tuple[bool,DeviceInfo]: ...
    @classmethod
    def getGlobalProfilingData(cls) -> ProfilingData: ...
    def getIMUFirmwareUpdateStatus(self) -> tuple[bool,float]: ...
    def getIMUFirmwareVersion(self) -> Version: ...
    def getIrDrivers(self) -> list[tuple[str,int,int]]: ...
    def getLeonCssCpuUsage(self) -> CpuUsage: ...
    def getLeonCssHeapUsage(self) -> MemoryInfo: ...
    def getLeonMssCpuUsage(self) -> CpuUsage: ...
    def getLeonMssHeapUsage(self) -> MemoryInfo: ...
    def getLogLevel(self) -> LogLevel: ...
    def getLogOutputLevel(self) -> LogLevel: ...
    def getMxId(self) -> str: ...
    def getProductName(self) -> object: ...
    def getProfilingData(self) -> ProfilingData: ...
    def getStereoPairs(self) -> list[StereoPair]: ...
    def getSystemInformationLoggingRate(self) -> float: ...
    def getUsbSpeed(self) -> UsbSpeed: ...
    def getXLinkChunkSize(self) -> int: ...
    def hasCrashDump(self) -> bool: ...
    def isClosed(self) -> bool: ...
    def isEepromAvailable(self) -> bool: ...
    def isPipelineRunning(self) -> bool: ...
    def readCalibration(self) -> CalibrationHandler: ...
    def readCalibration2(self) -> CalibrationHandler: ...
    def readCalibrationOrDefault(self) -> CalibrationHandler: ...
    def readCalibrationRaw(self, *args, **kwargs) -> Any: ...
    def readFactoryCalibration(self) -> CalibrationHandler: ...
    def readFactoryCalibrationOrDefault(self) -> CalibrationHandler: ...
    def readFactoryCalibrationRaw(self, *args, **kwargs) -> Any: ...
    def removeLogCallback(self, callbackId: int) -> bool: ...
    def setCalibration(self, arg0: CalibrationHandler) -> None: ...
    def setIrFloodLightIntensity(self, intensity: float, mask: int = ...) -> bool: ...
    def setIrLaserDotProjectorIntensity(self, intensity: float, mask: int = ...) -> bool: ...
    def setLogLevel(self, level: LogLevel) -> None: ...
    def setLogOutputLevel(self, level: LogLevel) -> None: ...
    def setMaxReconnectionAttempts(self, maxAttempts: int, callback: Callable[[Device.ReconnectionStatus],None] = ...) -> None: ...
    def setSystemInformationLoggingRate(self, rateHz: float) -> None: ...
    @overload
    def setTimesync(self, arg0: datetime.timedelta, arg1: int, arg2: bool) -> None: ...
    @overload
    def setTimesync(self, enable: bool) -> None: ...
    def setXLinkChunkSize(self, sizeBytes: int) -> None: ...
    def startIMUFirmwareUpdate(self, forceUpdate: bool = ...) -> bool: ...
    def tryFlashCalibration(self, calibrationDataHandler: CalibrationHandler) -> bool: ...
    def __enter__(self) -> DeviceBase: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...

class DeviceBootloader:
    class ApplicationInfo:
        applicationName: str
        firmwareVersion: str
        hasApplication: bool
        def __init__(self) -> None: ...

    class Config:
        appMem: DeviceBootloader.Memory
        network: DeviceBootloader.NetworkConfig
        usb: DeviceBootloader.UsbConfig
        def __init__(self) -> None: ...
        def fromJson(self) -> DeviceBootloader.Config: ...
        def getDnsAltIPv4(self) -> str: ...
        def getDnsIPv4(self) -> str: ...
        def getIPv4(self) -> str: ...
        def getIPv4Gateway(self) -> str: ...
        def getIPv4Mask(self) -> str: ...
        def getMacAddress(self) -> str: ...
        def getNetworkTimeout(self) -> datetime.timedelta: ...
        def getUsbMaxSpeed(self) -> UsbSpeed: ...
        def getUsbTimeout(self) -> datetime.timedelta: ...
        def isStaticIPV4(self) -> bool: ...
        def setDnsIPv4(self, arg0: str, arg1: str) -> None: ...
        def setDynamicIPv4(self, arg0: str, arg1: str, arg2: str) -> None: ...
        def setMacAddress(self, arg0: str) -> None: ...
        def setNetworkTimeout(self, arg0: datetime.timedelta) -> None: ...
        def setStaticIPv4(self, arg0: str, arg1: str, arg2: str) -> None: ...
        def setUsbMaxSpeed(self, arg0: UsbSpeed) -> None: ...
        def setUsbTimeout(self, arg0: datetime.timedelta) -> None: ...
        def toJson(self) -> json: ...

    class Memory:
        __members__: ClassVar[dict] = ...  # read-only
        AUTO: ClassVar[DeviceBootloader.Memory] = ...
        EMMC: ClassVar[DeviceBootloader.Memory] = ...
        FLASH: ClassVar[DeviceBootloader.Memory] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class MemoryInfo:
        available: bool
        info: str
        size: int
        def __init__(self) -> None: ...

    class NetworkConfig:
        ipv4: int
        ipv4Dns: int
        ipv4DnsAlt: int
        ipv4Gateway: int
        ipv4Mask: int
        ipv6: Any
        ipv6Dns: Any
        ipv6DnsAlt: Any
        ipv6Gateway: Any
        ipv6Prefix: int
        mac: Any
        staticIpv4: bool
        staticIpv6: bool
        timeoutMs: int
        def __init__(self) -> None: ...

    class Section:
        __members__: ClassVar[dict] = ...  # read-only
        APPLICATION: ClassVar[DeviceBootloader.Section] = ...
        AUTO: ClassVar[DeviceBootloader.Section] = ...
        BOOTLOADER: ClassVar[DeviceBootloader.Section] = ...
        BOOTLOADER_CONFIG: ClassVar[DeviceBootloader.Section] = ...
        HEADER: ClassVar[DeviceBootloader.Section] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Type:
        __members__: ClassVar[dict] = ...  # read-only
        AUTO: ClassVar[DeviceBootloader.Type] = ...
        NETWORK: ClassVar[DeviceBootloader.Type] = ...
        USB: ClassVar[DeviceBootloader.Type] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class UsbConfig:
        maxUsbSpeed: int
        pid: int
        timeoutMs: int
        vid: int
        def __init__(self) -> None: ...
    @overload
    def __init__(self, devInfo: DeviceInfo, allowFlashingBootloader: bool = ...) -> None: ...
    @overload
    def __init__(self, devInfo: DeviceInfo, pathToCmd: os.PathLike, allowFlashingBootloader: bool = ...) -> None: ...
    @overload
    def __init__(self, nameOrDeviceId: str, allowFlashingBootloader: bool = ...) -> None: ...
    def bootMemory(self, fw, std) -> None: ...
    def bootUsbRomBootloader(self) -> None: ...
    def close(self) -> None: ...
    @classmethod
    def createDepthaiApplicationPackage(cls, *args, **kwargs) -> Any: ...
    @overload
    def flash(self, progressCallback: Callable[[float],None], pipeline: Pipeline, compress: bool = ..., applicationName: str = ..., memory: DeviceBootloader.Memory = ..., checkChecksum: bool = ...) -> tuple[bool,str]: ...
    @overload
    def flash(self, pipeline: Pipeline, compress: bool = ..., applicationName: str = ..., memory: DeviceBootloader.Memory = ..., checkChecksum: bool = ...) -> tuple[bool,str]: ...
    def flashBootHeader(self, memory: DeviceBootloader.Memory, frequency: int = ..., location: int = ..., dummyCycles: int = ..., offset: int = ...) -> tuple[bool,str]: ...
    @overload
    def flashBootloader(self, progressCallback: Callable[[float],None], path: os.PathLike = ...) -> tuple[bool,str]: ...
    @overload
    def flashBootloader(self, memory: DeviceBootloader.Memory, type: DeviceBootloader.Type, progressCallback: Callable[[float],None], path: os.PathLike = ...) -> tuple[bool,str]: ...
    def flashClear(self, memory: DeviceBootloader.Memory = ...) -> tuple[bool,str]: ...
    def flashConfig(self, config: DeviceBootloader.Config, memory: DeviceBootloader.Memory = ..., type: DeviceBootloader.Type = ...) -> tuple[bool,str]: ...
    def flashConfigClear(self, memory: DeviceBootloader.Memory = ..., type: DeviceBootloader.Type = ...) -> tuple[bool,str]: ...
    def flashConfigData(self, configData: json, memory: DeviceBootloader.Memory = ..., type: DeviceBootloader.Type = ...) -> tuple[bool,str]: ...
    def flashConfigFile(self, configData: os.PathLike, memory: DeviceBootloader.Memory = ..., type: DeviceBootloader.Type = ...) -> tuple[bool,str]: ...
    @overload
    def flashCustom(self, memory: DeviceBootloader.Memory, offset: int, data, std, progressCallback: Callable[[float],None] = ...) -> tuple[bool,str]: ...
    @overload
    def flashCustom(self, memory: DeviceBootloader.Memory, offset: int, filename: str, progressCallback: Callable[[float],None] = ...) -> tuple[bool,str]: ...
    @overload
    def flashDepthaiApplicationPackage(self, progressCallback: Callable[[float],None], package, std, memory: DeviceBootloader.Memory = ...) -> tuple[bool,str]: ...
    @overload
    def flashDepthaiApplicationPackage(self, package, std, memory: DeviceBootloader.Memory = ...) -> tuple[bool,str]: ...
    def flashFastBootHeader(self, memory: DeviceBootloader.Memory, frequency: int = ..., location: int = ..., dummyCycles: int = ..., offset: int = ...) -> tuple[bool,str]: ...
    def flashGpioModeBootHeader(self, memory: DeviceBootloader.Memory, mode: int) -> tuple[bool,str]: ...
    def flashUsbRecoveryBootHeader(self, memory: DeviceBootloader.Memory) -> tuple[bool,str]: ...
    def flashUserBootloader(self, progressCallback: Callable[[float],None], path: os.PathLike = ...) -> tuple[bool,str]: ...
    @classmethod
    def getAllAvailableDevices(cls) -> list[DeviceInfo]: ...
    @classmethod
    def getEmbeddedBootloaderBinary(cls, *args, **kwargs) -> Any: ...
    @classmethod
    def getEmbeddedBootloaderVersion(cls) -> Version: ...
    @classmethod
    def getFirstAvailableDevice(cls) -> tuple[bool,DeviceInfo]: ...
    def getMemoryInfo(self, arg0: DeviceBootloader.Memory) -> DeviceBootloader.MemoryInfo: ...
    def getType(self) -> DeviceBootloader.Type: ...
    def getVersion(self) -> Version: ...
    def isAllowedFlashingBootloader(self) -> bool: ...
    def isEmbeddedVersion(self) -> bool: ...
    def isUserBootloader(self) -> bool: ...
    def isUserBootloaderSupported(self) -> bool: ...
    def readApplicationInfo(self, memory: DeviceBootloader.Memory) -> DeviceBootloader.ApplicationInfo: ...
    def readConfig(self, memory: DeviceBootloader.Memory = ..., type: DeviceBootloader.Type = ...) -> DeviceBootloader.Config: ...
    def readConfigData(self, memory: DeviceBootloader.Memory = ..., type: DeviceBootloader.Type = ...) -> json: ...
    def readCustom(self, memory: DeviceBootloader.Memory, offset: int, size: int, filename: str, progressCallback: Callable[[float],None] = ...) -> tuple[bool,str]: ...
    @overload
    @classmethod
    def saveDepthaiApplicationPackage(cls, path: os.PathLike, pipeline: Pipeline, pathToCmd: os.PathLike = ..., compress: bool = ..., applicationName: str = ..., checkChecksum: bool = ...) -> None: ...
    @overload
    @classmethod
    def saveDepthaiApplicationPackage(cls, path: os.PathLike, pipeline: Pipeline, compress: bool, applicationName: str = ..., checkChecksum: bool = ...) -> None: ...
    def __enter__(self) -> DeviceBootloader: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...

class DeviceDesc:
    mxid: str
    name: str
    platform: XLinkPlatform
    protocol: XLinkProtocol
    state: XLinkDeviceState
    status: XLinkError_t
    def __init__(self) -> None: ...

class DeviceInfo:
    deviceId: str
    name: str
    platform: XLinkPlatform
    protocol: XLinkProtocol
    state: XLinkDeviceState
    status: XLinkError_t
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, name: str, deviceId: str, state: XLinkDeviceState, protocol: XLinkProtocol, platform: XLinkPlatform, status: XLinkError_t) -> None: ...
    @overload
    def __init__(self, deviceIdOrName: str) -> None: ...
    @overload
    def __init__(self, arg0: DeviceDesc) -> None: ...
    def getDeviceId(self) -> str: ...
    def getXLinkDeviceDesc(self) -> DeviceDesc: ...

class DeviceNode(ThreadedNode):
    def __init__(self, *args, **kwargs) -> None: ...

class DeviceNodeGroup(DeviceNode):
    def __init__(self, *args, **kwargs) -> None: ...

class DynamicCalibrationControl(Buffer):
    class Commands:
        class ApplyCalibration:
            calibration: Any
            @overload
            def __init__(self) -> None: ...
            @overload
            def __init__(self, calibration) -> None: ...
    
        class Calibrate:
            force: bool
            def __init__(self, force: bool = ...) -> None: ...
    
        class CalibrationQuality:
            force: bool
            def __init__(self, force: bool = ...) -> None: ...
    
        class LoadImage:
            def __init__(self) -> None: ...
    
        class ResetData:
            def __init__(self) -> None: ...
    
        class SetPerformanceMode:
            performanceMode: DynamicCalibrationControl.PerformanceMode
            def __init__(self, performanceMode: DynamicCalibrationControl.PerformanceMode) -> None: ...
    
        class StartCalibration:
            calibrationPeriod: float
            loadImagePeriod: float
            def __init__(self, loadImagePeriod: float = ..., calibrationPeriod: float = ...) -> None: ...
    
        class StopCalibration:
            def __init__(self) -> None: ...
        def __init__(self, *args, **kwargs) -> None: ...

    class PerformanceMode:
        __members__: ClassVar[dict] = ...  # read-only
        DEFAULT: ClassVar[DynamicCalibrationControl.PerformanceMode] = ...
        OPTIMIZE_PERFORMANCE: ClassVar[DynamicCalibrationControl.PerformanceMode] = ...
        OPTIMIZE_SPEED: ClassVar[DynamicCalibrationControl.PerformanceMode] = ...
        SKIP_CHECKS: ClassVar[DynamicCalibrationControl.PerformanceMode] = ...
        STATIC_SCENERY: ClassVar[DynamicCalibrationControl.PerformanceMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    DEFAULT: ClassVar[DynamicCalibrationControl.PerformanceMode] = ...
    OPTIMIZE_PERFORMANCE: ClassVar[DynamicCalibrationControl.PerformanceMode] = ...
    OPTIMIZE_SPEED: ClassVar[DynamicCalibrationControl.PerformanceMode] = ...
    SKIP_CHECKS: ClassVar[DynamicCalibrationControl.PerformanceMode] = ...
    STATIC_SCENERY: ClassVar[DynamicCalibrationControl.PerformanceMode] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: DynamicCalibrationControl.Commands.Calibrate) -> None: ...
    @overload
    def __init__(self, arg0: DynamicCalibrationControl.Commands.CalibrationQuality) -> None: ...
    @overload
    def __init__(self, arg0: DynamicCalibrationControl.Commands.StartCalibration) -> None: ...
    @overload
    def __init__(self, arg0: DynamicCalibrationControl.Commands.StopCalibration) -> None: ...
    @overload
    def __init__(self, arg0: DynamicCalibrationControl.Commands.LoadImage) -> None: ...
    @overload
    def __init__(self, arg0: DynamicCalibrationControl.Commands.ApplyCalibration) -> None: ...
    @overload
    def __init__(self, arg0: DynamicCalibrationControl.Commands.ResetData) -> None: ...
    @overload
    def __init__(self, arg0: DynamicCalibrationControl.Commands.SetPerformanceMode) -> None: ...
    @classmethod
    def applyCalibration(cls, calibration) -> DynamicCalibrationControl: ...
    @classmethod
    def calibrate(cls, force: bool = ...) -> DynamicCalibrationControl: ...
    @classmethod
    def calibrationQuality(cls, force: bool = ...) -> DynamicCalibrationControl: ...
    @classmethod
    def loadImage(cls) -> DynamicCalibrationControl: ...
    @classmethod
    def resetData(cls) -> DynamicCalibrationControl: ...
    @classmethod
    def setPerformanceMode(cls, mode: DynamicCalibrationControl.PerformanceMode = ...) -> DynamicCalibrationControl: ...
    @classmethod
    def startCalibration(cls, loadImagePeriod: float = ..., calibrationPeriod: float = ...) -> DynamicCalibrationControl: ...
    @classmethod
    def stopCalibration(cls) -> DynamicCalibrationControl: ...

class DynamicCalibrationProperties:
    def __init__(self, *args, **kwargs) -> None: ...

class DynamicCalibrationResult(Buffer):
    calibrationData: Optional[DynamicCalibrationResultData]
    info: str
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, data: DynamicCalibrationResultData, info: str) -> None: ...
    @overload
    def __init__(self, info: str) -> None: ...

class DynamicCalibrationResultData:
    calibrationDifference: CalibrationQualityData
    currentCalibration: Any
    newCalibration: Any
    def __init__(self) -> None: ...

class EdgeDetectorConfig(Buffer):
    def __init__(self) -> None: ...
    def getConfigData(self) -> EdgeDetectorConfigData: ...
    def setSobelFilterKernels(self, horizontalKernel: list[list[int]], verticalKernel: list[list[int]]) -> None: ...

class EdgeDetectorConfigData:
    sobelFilterHorizontalKernel: list[list[int]]
    sobelFilterVerticalKernel: list[list[int]]
    def __init__(self) -> None: ...

class EdgeDetectorProperties:
    initialConfig: EdgeDetectorConfig
    numFramesPool: int
    outputFrameSize: int
    def __init__(self, *args, **kwargs) -> None: ...

class EepromData:
    batchName: str
    batchTime: int
    boardConf: str
    boardCustom: str
    boardName: str
    boardOptions: int
    boardRev: str
    cameraData: dict[CameraBoardSocket,CameraInfo]
    deviceName: str
    hardwareConf: str
    housingExtrinsics: Extrinsics
    imuExtrinsics: Extrinsics
    miscellaneousData: Any
    productName: str
    stereoEnableDistortionCorrection: bool
    stereoRectificationData: StereoRectification
    stereoUseSpecTranslation: bool
    version: int
    verticalCameraSocket: CameraBoardSocket
    def __init__(self) -> None: ...

class EepromError(RuntimeError): ...

class EncodedFrame(Buffer):
    class FrameType:
        __members__: ClassVar[dict] = ...  # read-only
        B: ClassVar[EncodedFrame.FrameType] = ...
        I: ClassVar[EncodedFrame.FrameType] = ...
        P: ClassVar[EncodedFrame.FrameType] = ...
        Unknown: ClassVar[EncodedFrame.FrameType] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Profile:
        __members__: ClassVar[dict] = ...  # read-only
        AVC: ClassVar[EncodedFrame.Profile] = ...
        HEVC: ClassVar[EncodedFrame.Profile] = ...
        JPEG: ClassVar[EncodedFrame.Profile] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    def __init__(self) -> None: ...
    def getBitrate(self) -> int: ...
    def getColorTemperature(self) -> int: ...
    def getExposureTime(self) -> datetime.timedelta: ...
    def getFrameType(self) -> EncodedFrame.FrameType: ...
    def getHeight(self) -> int: ...
    def getInstanceNum(self) -> int: ...
    def getLensPosition(self) -> int: ...
    def getLensPositionRaw(self) -> float: ...
    def getLossless(self) -> bool: ...
    def getProfile(self) -> EncodedFrame.Profile: ...
    def getQuality(self) -> int: ...
    def getSensitivity(self) -> int: ...
    def getSequenceNum(self) -> int: ...
    def getTimestamp(self) -> datetime.timedelta: ...
    def getTimestampDevice(self) -> datetime.timedelta: ...
    def getTransformation(self) -> ImgTransformation: ...
    def getWidth(self) -> int: ...
    def setBitrate(self, arg0: int) -> EncodedFrame: ...
    def setFrameType(self, arg0: EncodedFrame.FrameType) -> EncodedFrame: ...
    def setHeight(self, height: int) -> EncodedFrame: ...
    def setLossless(self, arg0: bool) -> EncodedFrame: ...
    def setProfile(self, arg0: EncodedFrame.Profile) -> EncodedFrame: ...
    def setQuality(self, arg0: int) -> EncodedFrame: ...
    @overload
    def setSize(self, width: int, height: int) -> EncodedFrame: ...
    @overload
    def setSize(self, sizer: tuple[int,int]) -> EncodedFrame: ...
    def setTransformation(self, arg0: ImgTransformation) -> None: ...
    def setWidth(self, width: int) -> EncodedFrame: ...

class EventData:
    @overload
    def __init__(self, data: str, fileName: str, mimeType: str) -> None: ...
    @overload
    def __init__(self, fileUrl: str) -> None: ...
    @overload
    def __init__(self, imgFrame: ImgFrame, fileName: str) -> None: ...
    @overload
    def __init__(self, encodedFrame: EncodedFrame, fileName: str) -> None: ...
    @overload
    def __init__(self, nnData: NNData, fileName: str) -> None: ...

class EventsManager:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, url: str, uploadCachedOnStart: bool = ..., publishInterval: float = ...) -> None: ...
    def checkConnection(self) -> bool: ...
    def sendEvent(self, name: str, imgFrame: ImgFrame = ..., data: list[EventData] = ..., tags: list[str] = ..., extraData: dict[str,str] = ..., deviceSerialNo: str = ...) -> bool: ...
    def sendSnap(self, name: str, imgFrame: ImgFrame = ..., data: list[EventData] = ..., tags: list[str] = ..., extraData: dict[str,str] = ..., deviceSerialNo: str = ...) -> bool: ...
    def setCacheDir(self, cacheDir: str) -> None: ...
    def setCacheIfCannotSend(self, cacheIfCannotUpload: bool) -> None: ...
    def setDeviceSerialNumber(self, deviceSerialNumber: str) -> None: ...
    def setLogResponse(self, logResponse: bool) -> None: ...
    def setQueueSize(self, queueSize: int) -> None: ...
    def setSourceAppId(self, sourceAppId: str) -> None: ...
    def setSourceAppIdentifier(self, sourceAppIdentifier: str) -> None: ...
    def setToken(self, token: str) -> None: ...
    def setUrl(self, url: str) -> None: ...
    def setVerifySsl(self, verifySsl: bool) -> None: ...
    def uploadCachedData(self) -> None: ...

class Extrinsics:
    rotationMatrix: list[list[float]]
    specTranslation: Point3f
    toCameraSocket: CameraBoardSocket
    translation: Point3f
    def __init__(self) -> None: ...

class FeatureTrackerConfig(Buffer):
    class CornerDetector:
        class Thresholds:
            decreaseFactor: float
            increaseFactor: float
            initialValue: float
            max: float
            min: float
            def __init__(self) -> None: ...
    
        class Type:
            __members__: ClassVar[dict] = ...  # read-only
            HARRIS: ClassVar[FeatureTrackerConfig.CornerDetector.Type] = ...
            SHI_THOMASI: ClassVar[FeatureTrackerConfig.CornerDetector.Type] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
        cellGridDimension: int
        enableSobel: bool
        enableSorting: bool
        numMaxFeatures: int
        numTargetFeatures: int
        thresholds: FeatureTrackerConfig.CornerDetector.Thresholds
        type: FeatureTrackerConfig.CornerDetector.Type
        def __init__(self) -> None: ...

    class FeatureMaintainer:
        enable: bool
        lostFeatureErrorThreshold: float
        minimumDistanceBetweenFeatures: float
        trackedFeatureThreshold: float
        def __init__(self) -> None: ...

    class MotionEstimator:
        class OpticalFlow:
            epsilon: float
            maxIterations: int
            pyramidLevels: int
            searchWindowHeight: int
            searchWindowWidth: int
            def __init__(self) -> None: ...
    
        class Type:
            __members__: ClassVar[dict] = ...  # read-only
            HW_MOTION_ESTIMATION: ClassVar[FeatureTrackerConfig.MotionEstimator.Type] = ...
            LUCAS_KANADE_OPTICAL_FLOW: ClassVar[FeatureTrackerConfig.MotionEstimator.Type] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
        enable: bool
        opticalFlow: FeatureTrackerConfig.MotionEstimator.OpticalFlow
        type: FeatureTrackerConfig.MotionEstimator.Type
        def __init__(self) -> None: ...
    def __init__(self) -> None: ...
    @overload
    def setCornerDetector(self, cornerDetector: FeatureTrackerConfig.CornerDetector.Type) -> FeatureTrackerConfig: ...
    @overload
    def setCornerDetector(self, config: FeatureTrackerConfig.CornerDetector) -> FeatureTrackerConfig: ...
    @overload
    def setFeatureMaintainer(self, enable: bool) -> FeatureTrackerConfig: ...
    @overload
    def setFeatureMaintainer(self, config: FeatureTrackerConfig.FeatureMaintainer) -> FeatureTrackerConfig: ...
    def setHwMotionEstimation(self) -> FeatureTrackerConfig: ...
    @overload
    def setMotionEstimator(self, enable: bool) -> FeatureTrackerConfig: ...
    @overload
    def setMotionEstimator(self, config: FeatureTrackerConfig.MotionEstimator) -> FeatureTrackerConfig: ...
    def setNumTargetFeatures(self, numTargetFeatures: int) -> FeatureTrackerConfig: ...
    @overload
    def setOpticalFlow(self) -> FeatureTrackerConfig: ...
    @overload
    def setOpticalFlow(self, config: FeatureTrackerConfig.MotionEstimator.OpticalFlow) -> FeatureTrackerConfig: ...

class FeatureTrackerProperties:
    initialConfig: FeatureTrackerConfig
    numMemorySlices: int
    numShaves: int
    def __init__(self, *args, **kwargs) -> None: ...

class FrameEvent:
    __members__: ClassVar[dict] = ...  # read-only
    NONE: ClassVar[FrameEvent] = ...
    READOUT_END: ClassVar[FrameEvent] = ...
    READOUT_START: ClassVar[FrameEvent] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GlobalProperties:
    cameraTuningBlobSize: Optional[int]
    cameraTuningBlobUri: str
    leonOsFrequencyHz: float
    leonRtFrequencyHz: float
    pipelineName: Optional[str]
    pipelineVersion: Optional[str]
    sippBufferSize: int
    sippDmaBufferSize: int
    xlinkChunkSize: int
    def __init__(self, *args, **kwargs) -> None: ...

class IMUData(Buffer):
    packets: list[IMUPacket]
    def __init__(self) -> None: ...

class IMUPacket:
    acceleroMeter: IMUReportAccelerometer
    gyroscope: IMUReportGyroscope
    magneticField: IMUReportMagneticField
    rotationVector: IMUReportRotationVectorWAcc
    def __init__(self) -> None: ...

class IMUProperties:
    batchReportThreshold: int
    enableFirmwareUpdate: Optional[bool]
    imuSensors: list[IMUSensorConfig]
    maxBatchReports: int
    def __init__(self, *args, **kwargs) -> None: ...

class IMUReport:
    class Accuracy:
        __members__: ClassVar[dict] = ...  # read-only
        HIGH: ClassVar[IMUReport.Accuracy] = ...
        LOW: ClassVar[IMUReport.Accuracy] = ...
        MEDIUM: ClassVar[IMUReport.Accuracy] = ...
        UNRELIABLE: ClassVar[IMUReport.Accuracy] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    accuracy: IMUReport.Accuracy
    sequence: int
    timestamp: Timestamp
    tsDevice: Timestamp
    def __init__(self) -> None: ...
    def getSequenceNum(self) -> int: ...
    def getTimestamp(self) -> datetime.timedelta: ...
    def getTimestampDevice(self) -> datetime.timedelta: ...

class IMUReportAccelerometer(IMUReport):
    x: float
    y: float
    z: float
    def __init__(self) -> None: ...

class IMUReportGyroscope(IMUReport):
    x: float
    y: float
    z: float
    def __init__(self) -> None: ...

class IMUReportMagneticField(IMUReport):
    x: float
    y: float
    z: float
    def __init__(self) -> None: ...

class IMUReportRotationVectorWAcc(IMUReport):
    i: float
    j: float
    k: float
    real: float
    rotationVectorAccuracy: float
    def __init__(self) -> None: ...

class IMUSensor:
    __members__: ClassVar[dict] = ...  # read-only
    ACCELEROMETER: ClassVar[IMUSensor] = ...
    ACCELEROMETER_RAW: ClassVar[IMUSensor] = ...
    ARVR_STABILIZED_GAME_ROTATION_VECTOR: ClassVar[IMUSensor] = ...
    ARVR_STABILIZED_ROTATION_VECTOR: ClassVar[IMUSensor] = ...
    GAME_ROTATION_VECTOR: ClassVar[IMUSensor] = ...
    GEOMAGNETIC_ROTATION_VECTOR: ClassVar[IMUSensor] = ...
    GRAVITY: ClassVar[IMUSensor] = ...
    GYROSCOPE_CALIBRATED: ClassVar[IMUSensor] = ...
    GYROSCOPE_RAW: ClassVar[IMUSensor] = ...
    GYROSCOPE_UNCALIBRATED: ClassVar[IMUSensor] = ...
    LINEAR_ACCELERATION: ClassVar[IMUSensor] = ...
    MAGNETOMETER_CALIBRATED: ClassVar[IMUSensor] = ...
    MAGNETOMETER_RAW: ClassVar[IMUSensor] = ...
    MAGNETOMETER_UNCALIBRATED: ClassVar[IMUSensor] = ...
    ROTATION_VECTOR: ClassVar[IMUSensor] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class IMUSensorConfig:
    changeSensitivity: int
    reportRate: int
    sensitivityEnabled: bool
    sensitivityRelative: bool
    sensorId: IMUSensor
    def __init__(self) -> None: ...

class ImageAlignConfig(Buffer):
    staticDepthPlane: int
    def __init__(self) -> None: ...

class ImageAlignProperties:
    alignHeight: int
    alignWidth: int
    initialConfig: ImageAlignConfig
    interpolation: Interpolation
    numFramesPool: int
    numShaves: int
    outKeepAspectRatio: bool
    warpHwIds: list[int]
    def __init__(self, *args, **kwargs) -> None: ...

class ImageFiltersConfig(Buffer):
    filterIndices: list[int]
    filterParams: Any
    def __init__(self) -> None: ...
    def insertFilter(self, params) -> ImageFiltersConfig: ...
    def setProfilePreset(self, arg0) -> None: ...
    def updateFilterAtIndex(self, index: int, params) -> ImageFiltersConfig: ...

class ImageFiltersPresetMode:
    __members__: ClassVar[dict] = ...  # read-only
    TOF_HIGH_RANGE: ClassVar[ImageFiltersPresetMode] = ...
    TOF_LOW_RANGE: ClassVar[ImageFiltersPresetMode] = ...
    TOF_MID_RANGE: ClassVar[ImageFiltersPresetMode] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ImageFiltersProperties:
    def __init__(self, *args, **kwargs) -> None: ...

class ImageManipConfig(Buffer):
    class ResizeMode:
        __members__: ClassVar[dict] = ...  # read-only
        CENTER_CROP: ClassVar[ImageManipConfig.ResizeMode] = ...
        LETTERBOX: ClassVar[ImageManipConfig.ResizeMode] = ...
        NONE: ClassVar[ImageManipConfig.ResizeMode] = ...
        STRETCH: ClassVar[ImageManipConfig.ResizeMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    def __init__(self) -> None: ...
    @overload
    def addCrop(self, x: int, y: int, w: int, h: int) -> ImageManipConfig: ...
    @overload
    def addCrop(self, rect: Rect, normalizedCoords: bool) -> ImageManipConfig: ...
    def addCropRotatedRect(self, rect: RotatedRect, normalizedCoords: bool) -> ImageManipConfig: ...
    def addFlipHorizontal(self) -> ImageManipConfig: ...
    def addFlipVertical(self) -> ImageManipConfig: ...
    @overload
    def addRotateDeg(self, angle: float) -> ImageManipConfig: ...
    @overload
    def addRotateDeg(self, angle: float, center: Point2f) -> ImageManipConfig: ...
    @overload
    def addScale(self, scale: float) -> ImageManipConfig: ...
    @overload
    def addScale(self, scaleX: float, scaleY: float) -> ImageManipConfig: ...
    def addTransformAffine(self, mat) -> ImageManipConfig: ...
    def addTransformFourPoints(self, src, dst, normalizedCoords: bool) -> ImageManipConfig: ...
    def addTransformPerspective(self, mat) -> ImageManipConfig: ...
    def clearOps(self) -> ImageManipConfig: ...
    def getUndistort(self) -> bool: ...
    @overload
    def setBackgroundColor(self, r: int, g: int, b: int) -> ImageManipConfig: ...
    @overload
    def setBackgroundColor(self, val: int) -> ImageManipConfig: ...
    @overload
    def setColormap(self, colormap: Colormap) -> ImageManipConfig: ...
    @overload
    def setColormap(self, colormap: Colormap) -> ImageManipConfig: ...
    def setFrameType(self, type: ImgFrame.Type) -> ImageManipConfig: ...
    def setOutputCenter(self, c: bool) -> ImageManipConfig: ...
    def setOutputSize(self, w: int, h: int, mode: ImageManipConfig.ResizeMode = ...) -> ImageManipConfig: ...
    def setReusePreviousImage(self, reuse: bool) -> ImageManipConfig: ...
    def setSkipCurrentImage(self, skip: bool) -> ImageManipConfig: ...
    def setUndistort(self, undistort: bool) -> ImageManipConfig: ...

class ImgAnnotation:
    circles: VectorCircleAnnotation
    points: VectorPointsAnnotation
    texts: VectorTextAnnotation
    def __init__(self) -> None: ...

class ImgAnnotations(Buffer):
    annotations: VectorImgAnnotation
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: VectorImgAnnotation) -> None: ...
    def getSequenceNum(self) -> int: ...
    def getTimestamp(self) -> datetime.timedelta: ...
    def getTimestampDevice(self) -> datetime.timedelta: ...

class ImgDetection:
    confidence: float
    label: int
    labelName: str
    xmax: float
    xmin: float
    ymax: float
    ymin: float
    def __init__(self) -> None: ...

class ImgDetections(Buffer):
    detections: list[ImgDetection]
    def __init__(self) -> None: ...
    def getSequenceNum(self) -> int: ...
    def getTimestamp(self) -> datetime.timedelta: ...
    def getTimestampDevice(self) -> datetime.timedelta: ...
    def getTransformation(self) -> Optional[ImgTransformation]: ...
    def setTransformation(self, arg0: Optional[ImgTransformation]) -> None: ...

class ImgFrame(Buffer):
    class Specs:
        bytesPP: int
        height: int
        p1Offset: int
        p2Offset: int
        p3Offset: int
        stride: int
        type: ImgFrame.Type
        width: int
        def __init__(self) -> None: ...

    class Type:
        __members__: ClassVar[dict] = ...  # read-only
        BGR888i: ClassVar[ImgFrame.Type] = ...
        BGR888p: ClassVar[ImgFrame.Type] = ...
        BGRF16F16F16i: ClassVar[ImgFrame.Type] = ...
        BGRF16F16F16p: ClassVar[ImgFrame.Type] = ...
        BITSTREAM: ClassVar[ImgFrame.Type] = ...
        GRAY8: ClassVar[ImgFrame.Type] = ...
        GRAYF16: ClassVar[ImgFrame.Type] = ...
        HDR: ClassVar[ImgFrame.Type] = ...
        LUT16: ClassVar[ImgFrame.Type] = ...
        LUT2: ClassVar[ImgFrame.Type] = ...
        LUT4: ClassVar[ImgFrame.Type] = ...
        NONE: ClassVar[ImgFrame.Type] = ...
        NV12: ClassVar[ImgFrame.Type] = ...
        NV21: ClassVar[ImgFrame.Type] = ...
        PACK10: ClassVar[ImgFrame.Type] = ...
        PACK12: ClassVar[ImgFrame.Type] = ...
        RAW10: ClassVar[ImgFrame.Type] = ...
        RAW12: ClassVar[ImgFrame.Type] = ...
        RAW14: ClassVar[ImgFrame.Type] = ...
        RAW16: ClassVar[ImgFrame.Type] = ...
        RAW32: ClassVar[ImgFrame.Type] = ...
        RAW8: ClassVar[ImgFrame.Type] = ...
        RGB161616: ClassVar[ImgFrame.Type] = ...
        RGB888i: ClassVar[ImgFrame.Type] = ...
        RGB888p: ClassVar[ImgFrame.Type] = ...
        RGBA8888: ClassVar[ImgFrame.Type] = ...
        RGBF16F16F16i: ClassVar[ImgFrame.Type] = ...
        RGBF16F16F16p: ClassVar[ImgFrame.Type] = ...
        YUV400p: ClassVar[ImgFrame.Type] = ...
        YUV420p: ClassVar[ImgFrame.Type] = ...
        YUV422i: ClassVar[ImgFrame.Type] = ...
        YUV422p: ClassVar[ImgFrame.Type] = ...
        YUV444i: ClassVar[ImgFrame.Type] = ...
        YUV444p: ClassVar[ImgFrame.Type] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    def getBytesPerPixel(self) -> float: ...
    def getCategory(self) -> int: ...
    def getColorTemperature(self) -> int: ...
    def getCvFrame(self) -> numpy.ndarray: ...
    def getExposureTime(self) -> datetime.timedelta: ...
    def getFrame(self) -> numpy.ndarray: ...
    def getHeight(self) -> int: ...
    def getInstanceNum(self) -> int: ...
    def getLensPosition(self) -> int: ...
    def getLensPositionRaw(self) -> float: ...
    def getPlaneHeight(self) -> int: ...
    def getPlaneStride(self, arg0: int) -> int: ...
    def getSensitivity(self) -> int: ...
    def getSequenceNum(self) -> int: ...
    def getSourceDFov(self) -> float: ...
    def getSourceHFov(self) -> float: ...
    def getSourceHeight(self) -> int: ...
    def getSourceVFov(self) -> float: ...
    def getSourceWidth(self) -> int: ...
    def getStride(self) -> int: ...
    @overload
    def getTimestamp(self) -> datetime.timedelta: ...
    @overload
    def getTimestamp(self, offset: CameraExposureOffset) -> datetime.timedelta: ...
    @overload
    def getTimestampDevice(self) -> datetime.timedelta: ...
    @overload
    def getTimestampDevice(self, offset: CameraExposureOffset) -> datetime.timedelta: ...
    def getTransformation(self) -> ImgTransformation: ...
    def getType(self) -> ImgFrame.Type: ...
    def getWidth(self) -> int: ...
    def setCategory(self, category: int) -> ImgFrame: ...
    def setCvFrame(self, arg0: numpy.ndarray, arg1: ImgFrame.Type) -> ImgFrame: ...
    def setFrame(self, arg0: numpy.ndarray) -> ImgFrame: ...
    def setHeight(self, height: int) -> ImgFrame: ...
    def setInstanceNum(self, instance: int) -> ImgFrame: ...
    @overload
    def setSize(self, width: int, height: int) -> ImgFrame: ...
    @overload
    def setSize(self, sizer: tuple[int,int]) -> ImgFrame: ...
    def setStride(self, stride: int) -> ImgFrame: ...
    def setTransformation(self, arg0: ImgTransformation) -> None: ...
    def setType(self, type: ImgFrame.Type) -> ImgFrame: ...
    def setWidth(self, width: int) -> ImgFrame: ...
    def validateTransformations(self) -> bool: ...

class ImgFrameCapability(Capability):
    enableUndistortion: Optional[bool]
    fps: CapabilityRangeFloat
    resizeMode: ImgResizeMode
    size: CapabilityRangeUintPair
    type: Optional[ImgFrame.Type]
    def __init__(self) -> None: ...

class ImgResizeMode:
    __members__: ClassVar[dict] = ...  # read-only
    CROP: ClassVar[ImgResizeMode] = ...
    LETTERBOX: ClassVar[ImgResizeMode] = ...
    STRETCH: ClassVar[ImgResizeMode] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ImgTransformation:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, width: int, height: int) -> None: ...
    @overload
    def __init__(self, srcWidth: int, srcHeight: int, width: int, height: int) -> None: ...
    @overload
    def __init__(self, width: int, height: int, sourceIntrinsicMatrix) -> None: ...
    @overload
    def __init__(self, width: int, height: int, sourceIntrinsicMatrix, distortionModel: CameraModel, distortionCoefficients: list[float]) -> None: ...
    def addCrop(self, x: int, y: int, width: int, height: int) -> ImgTransformation: ...
    def addFlipHorizontal(self) -> ImgTransformation: ...
    def addFlipVertical(self) -> ImgTransformation: ...
    def addPadding(self, x: int, y: int, width: int, height: int) -> ImgTransformation: ...
    def addRotation(self, angle: float, rotationPoint: Point2f) -> ImgTransformation: ...
    def addScale(self, scaleX: float, scaleY: float) -> ImgTransformation: ...
    def addTransformation(self, matrix) -> ImgTransformation: ...
    def getDFov(self, source: bool = ...) -> float: ...
    def getDistortionCoefficients(self) -> list[float]: ...
    def getDistortionModel(self) -> CameraModel: ...
    def getDstMaskPt(self, x: int, y: int) -> bool: ...
    def getHFov(self, source: bool = ...) -> float: ...
    def getIntrinsicMatrix(self, *args, **kwargs) -> Any: ...
    def getIntrinsicMatrixInv(self, *args, **kwargs) -> Any: ...
    def getMatrix(self, *args, **kwargs) -> Any: ...
    def getMatrixInv(self, *args, **kwargs) -> Any: ...
    def getSize(self) -> tuple[int,int]: ...
    def getSourceIntrinsicMatrix(self, *args, **kwargs) -> Any: ...
    def getSourceIntrinsicMatrixInv(self, *args, **kwargs) -> Any: ...
    def getSourceSize(self) -> tuple[int,int]: ...
    def getSrcCrops(self) -> list[RotatedRect]: ...
    def getSrcMaskPt(self, x: int, y: int) -> bool: ...
    def getVFov(self, source: bool = ...) -> float: ...
    def invTransformPoint(self, point: Point2f) -> Point2f: ...
    def invTransformRect(self, rect: RotatedRect) -> RotatedRect: ...
    def isValid(self) -> bool: ...
    def remapPointFrom(self, to: ImgTransformation, point: Point2f) -> Point2f: ...
    def remapPointTo(self, to: ImgTransformation, point: Point2f) -> Point2f: ...
    def remapRectFrom(self, to: ImgTransformation, rect: RotatedRect) -> RotatedRect: ...
    def remapRectTo(self, to: ImgTransformation, rect: RotatedRect) -> RotatedRect: ...
    def setDistortionCoefficients(self, coefficients: list[float]) -> ImgTransformation: ...
    def setDistortionModel(self, model: CameraModel) -> ImgTransformation: ...
    def setIntrinsicMatrix(self, intrinsicMatrix) -> ImgTransformation: ...
    def transformPoint(self, point: Point2f) -> Point2f: ...
    def transformRect(self, rect: RotatedRect) -> RotatedRect: ...

class InputQueue:
    def __init__(self, *args, **kwargs) -> None: ...
    def send(self, msg: ADatatype) -> None: ...

class Interpolation:
    __members__: ClassVar[dict] = ...  # read-only
    BICUBIC: ClassVar[Interpolation] = ...
    BILINEAR: ClassVar[Interpolation] = ...
    BYPASS: ClassVar[Interpolation] = ...
    DEFAULT: ClassVar[Interpolation] = ...
    DEFAULT_DISPARITY_DEPTH: ClassVar[Interpolation] = ...
    NEAREST_NEIGHBOR: ClassVar[Interpolation] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class LogLevel:
    __members__: ClassVar[dict] = ...  # read-only
    CRITICAL: ClassVar[LogLevel] = ...
    DEBUG: ClassVar[LogLevel] = ...
    ERR: ClassVar[LogLevel] = ...
    INFO: ClassVar[LogLevel] = ...
    OFF: ClassVar[LogLevel] = ...
    TRACE: ClassVar[LogLevel] = ...
    WARN: ClassVar[LogLevel] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class LogMessage:
    colorRangeEnd: int
    colorRangeStart: int
    level: LogLevel
    nodeIdName: str
    payload: str
    time: Timestamp
    def __init__(self, *args, **kwargs) -> None: ...

class MedianFilter:
    __members__: ClassVar[dict] = ...  # read-only
    KERNEL_3x3: ClassVar[filters.params.MedianFilter] = ...
    KERNEL_5x5: ClassVar[filters.params.MedianFilter] = ...
    KERNEL_7x7: ClassVar[filters.params.MedianFilter] = ...
    MEDIAN_OFF: ClassVar[filters.params.MedianFilter] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class MemoryInfo:
    remaining: int
    total: int
    used: int
    def __init__(self) -> None: ...

class MessageDemuxProperties:
    def __init__(self, *args, **kwargs) -> None: ...

class MessageGroup(Buffer):
    def __init__(self) -> None: ...
    def getIntervalNs(self) -> int: ...
    def getMessageNames(self) -> list[str]: ...
    def getNumMessages(self) -> int: ...
    def getSequenceNum(self) -> int: ...
    def getTimestamp(self) -> datetime.timedelta: ...
    def getTimestampDevice(self) -> datetime.timedelta: ...
    def isSynced(self, arg0: int) -> bool: ...
    def __getitem__(self, arg0: str) -> ADatatype: ...
    def __iter__(self) -> Iterator[tuple[str,ADatatype]]: ...
    def __setitem__(self, arg0: str, arg1: ADatatype) -> None: ...

class MessageQueue:
    class QueueException(Exception): ...
    @overload
    def __init__(self, name: str) -> None: ...
    @overload
    def __init__(self, name: str = ..., maxSize: int = ..., blocking: bool = ...) -> None: ...
    def addCallback(self, callback: Callable) -> int: ...
    def close(self) -> None: ...
    def front(self) -> ADatatype: ...
    @overload
    def get(self) -> ADatatype: ...
    @overload
    def get(self, timeout: datetime.timedelta) -> ADatatype: ...
    def getAll(self) -> list[ADatatype]: ...
    def getBlocking(self) -> bool: ...
    def getMaxSize(self) -> int: ...
    @overload
    def getName(self) -> str: ...
    @overload
    def getName(self) -> str: ...
    def getSize(self) -> int: ...
    def has(self) -> bool: ...
    def isClosed(self) -> bool: ...
    def isFull(self) -> int: ...
    def removeCallback(self, callbackId: int) -> bool: ...
    @overload
    def send(self, msg: ADatatype) -> None: ...
    @overload
    def send(self, msg: ADatatype, timeout: datetime.timedelta) -> bool: ...
    def setBlocking(self, blocking: bool) -> None: ...
    def setMaxSize(self, maxSize: int) -> None: ...
    def setName(self, name: str) -> None: ...
    def tryGet(self) -> ADatatype: ...
    def tryGetAll(self) -> list[ADatatype]: ...
    def trySend(self, msg: ADatatype) -> bool: ...

class ModelType:
    __members__: ClassVar[dict] = ...  # read-only
    BLOB: ClassVar[ModelType] = ...
    DLC: ClassVar[ModelType] = ...
    NNARCHIVE: ClassVar[ModelType] = ...
    OTHER: ClassVar[ModelType] = ...
    SUPERBLOB: ClassVar[ModelType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class MonoCameraProperties:
    class SensorResolution:
        __members__: ClassVar[dict] = ...  # read-only
        THE_1200_P: ClassVar[MonoCameraProperties.SensorResolution] = ...
        THE_4000X3000: ClassVar[MonoCameraProperties.SensorResolution] = ...
        THE_400_P: ClassVar[MonoCameraProperties.SensorResolution] = ...
        THE_4224X3136: ClassVar[MonoCameraProperties.SensorResolution] = ...
        THE_480_P: ClassVar[MonoCameraProperties.SensorResolution] = ...
        THE_720_P: ClassVar[MonoCameraProperties.SensorResolution] = ...
        THE_800_P: ClassVar[MonoCameraProperties.SensorResolution] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    boardSocket: CameraBoardSocket
    eventFilter: list[FrameEvent]
    fps: float
    initialControl: CameraControl
    isp3aFps: int
    numFramesPool: int
    numFramesPoolRaw: int
    resolution: MonoCameraProperties.SensorResolution
    def __init__(self, *args, **kwargs) -> None: ...

class NNArchive:
    @overload
    def __init__(self, archivePath: os.PathLike, compression: NNArchiveEntry.Compression = ..., extractFolder: str = ...) -> None: ...
    @overload
    def __init__(self, archivePath: os.PathLike, options: NNArchiveOptions = ...) -> None: ...
    def getBlob(self) -> Optional[OpenVINO.Blob]: ...
    def getConfig(self) -> Union[nn_archive.v1.Config]: ...
    def getConfigV1(self) -> nn_archive.v1.Config: ...
    def getInputHeight(self, index: int = ...) -> Optional[int]: ...
    def getInputSize(self, index: int = ...) -> Optional[tuple[int,int]]: ...
    def getInputWidth(self, index: int = ...) -> Optional[int]: ...
    def getModelPath(self) -> Optional[os.PathLike]: ...
    def getModelType(self) -> ModelType: ...
    def getSuperBlob(self) -> Optional[OpenVINO.SuperBlob]: ...
    def getSupportedPlatforms(self) -> list[Platform]: ...

class NNArchiveConfigVersion:
    __members__: ClassVar[dict] = ...  # read-only
    V1: ClassVar[NNArchiveConfigVersion] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class NNArchiveEntry:
    class Compression:
        __members__: ClassVar[dict] = ...  # read-only
        AUTO: ClassVar[NNArchiveEntry.Compression] = ...
        RAW_FS: ClassVar[NNArchiveEntry.Compression] = ...
        TAR: ClassVar[NNArchiveEntry.Compression] = ...
        TAR_GZ: ClassVar[NNArchiveEntry.Compression] = ...
        TAR_XZ: ClassVar[NNArchiveEntry.Compression] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Seek:
        __members__: ClassVar[dict] = ...  # read-only
        CUR: ClassVar[NNArchiveEntry.Seek] = ...
        END: ClassVar[NNArchiveEntry.Seek] = ...
        SET: ClassVar[NNArchiveEntry.Seek] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    def __init__(self, *args, **kwargs) -> None: ...

class NNArchiveOptions:
    compression: NNArchiveEntry.Compression
    extractFolder: os.PathLike
    def __init__(self) -> None: ...

class NNArchiveVersionedConfig:
    @overload
    def __init__(self, path: os.PathLike, compression: NNArchiveEntry.Compression = ...) -> None: ...
    @overload
    def __init__(self, data, std, compression: NNArchiveEntry.Compression = ...) -> None: ...
    @overload
    def __init__(self, arg0: Callable[[],int], arg1, arg2: Callable[[int,NNArchiveEntry.Seek],int], arg3: Callable[[int],int], arg4: Callable[[],int], arg5: NNArchiveEntry.Compression) -> None: ...
    def getConfig(self) -> Union[nn_archive.v1.Config]: ...
    def getConfigV1(self) -> nn_archive.v1.Config: ...
    def getVersion(self) -> NNArchiveConfigVersion: ...

class NNData(Buffer):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    @overload
    def addTensor(self, name: str, tensor: list[int], storageOrder: TensorInfo.StorageOrder) -> NNData: ...
    @overload
    def addTensor(self, name: str, tensor: list[float], storageOrder: TensorInfo.StorageOrder) -> NNData: ...
    @overload
    def addTensor(self, name: str, tensor: list[float], storageOrder: TensorInfo.StorageOrder) -> NNData: ...
    @overload
    def addTensor(self, name: str, tensor: numpy.ndarray[numpy.int32], storageOrder: TensorInfo.StorageOrder) -> NNData: ...
    @overload
    def addTensor(self, name: str, tensor: numpy.ndarray[numpy.float32], storageOrder: TensorInfo.StorageOrder) -> NNData: ...
    @overload
    def addTensor(self, name: str, tensor: numpy.ndarray[numpy.float64], storageOrder: TensorInfo.StorageOrder) -> NNData: ...
    @overload
    def addTensor(self, name: str, tensor: object, dataType: TensorInfo.DataType) -> None: ...
    @overload
    def addTensor(self, name: str, tensor: object) -> None: ...
    def getAllLayerNames(self) -> list[str]: ...
    def getAllLayers(self) -> list[TensorInfo]: ...
    @overload
    def getFirstTensor(self, dequantize: bool = ...) -> object: ...
    @overload
    def getFirstTensor(self, storageOrder: TensorInfo.StorageOrder, dequantize: bool = ...) -> object: ...
    def getLayerDatatype(self, name: str, datatype: TensorInfo.DataType) -> bool: ...
    def getSequenceNum(self) -> int: ...
    @overload
    def getTensor(self, name: str, dequantize: bool = ...) -> object: ...
    @overload
    def getTensor(self, name: str, storageOrder: TensorInfo.StorageOrder, dequantize: bool = ...) -> object: ...
    def getTensorDatatype(self, name: str) -> TensorInfo.DataType: ...
    def getTensorInfo(self, name: str) -> Optional[TensorInfo]: ...
    def getTimestamp(self) -> datetime.timedelta: ...
    def getTimestampDevice(self) -> datetime.timedelta: ...
    def getTransformation(self) -> Optional[ImgTransformation]: ...
    def hasLayer(self, name: str) -> bool: ...
    def setTransformation(self, arg0: Optional[ImgTransformation]) -> None: ...

class NNModelDescription:
    compressionLevel: str
    model: str
    modelPrecisionType: str
    optimizationLevel: str
    platform: str
    snpeVersion: str
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, model: str, platform: str = ..., optimizationLevel: str = ..., compressionLevel: str = ..., snpeVersion: str = ..., modelPrecisionType: str = ...) -> None: ...
    @overload
    def __init__(self, model: str) -> None: ...
    def check(self) -> bool: ...
    @classmethod
    def fromYamlFile(cls, yamlPath: os.PathLike, modelsPath: os.PathLike = ...) -> NNModelDescription: ...
    def saveToYamlFile(self, yamlPath: os.PathLike) -> None: ...
    def toString(self) -> str: ...

class NeuralNetworkProperties:
    blobSize: Optional[int]
    blobUri: str
    numFrames: int
    numNCEPerThread: int
    numThreads: int
    def __init__(self, *args, **kwargs) -> None: ...

class Node:
    class Connection:
        inputGroup: str
        inputId: int
        inputName: str
        outputGroup: str
        outputId: int
        outputName: str
        def __init__(self, *args, **kwargs) -> None: ...

    class DatatypeHierarchy:
        datatype: DatatypeEnum
        descendants: bool
        def __init__(self, arg0: DatatypeEnum, arg1: bool) -> None: ...

    class Id:
        def __init__(self, *args, **kwargs) -> None: ...

    class Input(MessageQueue):
        class Type:
            __members__: ClassVar[dict] = ...  # read-only
            MReceiver: ClassVar[Node.Input.Type] = ...
            SReceiver: ClassVar[Node.Input.Type] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
        possibleDatatypes: list[Node.DatatypeHierarchy]
        def __init__(self, parent: Node, name: str = ..., group: str = ..., blocking: bool = ..., queueSize: int = ..., types: list[Node.DatatypeHierarchy] = ..., waitForMessage: bool = ...) -> None: ...
        def createInputQueue(self, maxSize: int = ..., blocking: bool = ...) -> InputQueue: ...
        @overload
        def getParent(self) -> Node: ...
        @overload
        def getParent(self) -> Node: ...
        def getPossibleDatatypes(self) -> list[Node.DatatypeHierarchy]: ...
        def getReusePreviousMessage(self) -> bool: ...
        def getWaitForMessage(self) -> bool: ...
        @overload
        def setPossibleDatatypes(self, types: list[Node.DatatypeHierarchy]) -> None: ...
        @overload
        def setPossibleDatatypes(self, types: list[tuple[DatatypeEnum,bool]]) -> None: ...
        def setReusePreviousMessage(self, reusePreviousMessage: bool) -> None: ...
        def setWaitForMessage(self, waitForMessage: bool) -> None: ...

    class InputMap:
        def __init__(self, *args, **kwargs) -> None: ...
        def items(self) -> Iterator[tuple[tuple[str,str],Node.Input]]: ...
        def __bool__(self) -> bool: ...
        @overload
        def __contains__(self, arg0: str) -> bool: ...
        @overload
        def __contains__(self, arg0: tuple[str,str]) -> bool: ...
        @overload
        def __delitem__(self, arg0: str) -> None: ...
        @overload
        def __delitem__(self, arg0: tuple[str,str]) -> None: ...
        @overload
        def __getitem__(self, arg0: str) -> Node.Input: ...
        @overload
        def __getitem__(self, arg0: tuple[str,str]) -> Node.Input: ...
        def __iter__(self) -> Iterator[tuple[str,str]]: ...
        def __len__(self) -> int: ...
        def __setitem__(self, arg0: tuple[str,str], arg1: Node.Input) -> None: ...

    class Output:
        class Type:
            __members__: ClassVar[dict] = ...  # read-only
            MSender: ClassVar[Node.Output.Type] = ...
            SSender: ClassVar[Node.Output.Type] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
        def __init__(self, parent: Node, name: str = ..., group: str = ..., possibleDatatypes: list[Node.DatatypeHierarchy] = ...) -> None: ...
        def canConnect(self, input: Node.Input) -> bool: ...
        def createOutputQueue(self, maxSize: int = ..., blocking: bool = ...) -> MessageQueue: ...
        def getName(self) -> str: ...
        @overload
        def getParent(self) -> Node: ...
        @overload
        def getParent(self) -> Node: ...
        def getPossibleDatatypes(self) -> list[Node.DatatypeHierarchy]: ...
        def isSamePipeline(self, input: Node.Input) -> bool: ...
        def link(self, input: Node.Input) -> None: ...
        def send(self, msg: ADatatype) -> None: ...
        @overload
        def setPossibleDatatypes(self, types: list[Node.DatatypeHierarchy]) -> None: ...
        @overload
        def setPossibleDatatypes(self, types: list[tuple[DatatypeEnum,bool]]) -> None: ...
        def trySend(self, msg: ADatatype) -> bool: ...
        def unlink(self, input: Node.Input) -> None: ...

    class OutputMap:
        def __init__(self, *args, **kwargs) -> None: ...
        def items(self) -> Iterator[tuple[tuple[str,str],Node.Output]]: ...
        def __bool__(self) -> bool: ...
        @overload
        def __contains__(self, arg0: str) -> bool: ...
        @overload
        def __contains__(self, arg0: tuple[str,str]) -> bool: ...
        @overload
        def __delitem__(self, arg0: str) -> None: ...
        @overload
        def __delitem__(self, arg0: tuple[str,str]) -> None: ...
        @overload
        def __getitem__(self, arg0: str) -> Node.Output: ...
        @overload
        def __getitem__(self, arg0: tuple[str,str]) -> Node.Output: ...
        def __iter__(self) -> Iterator[tuple[str,str]]: ...
        def __len__(self) -> int: ...
        def __setitem__(self, arg0: tuple[str,str], arg1: Node.Output) -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def add(self, node: Node) -> None: ...
    @overload
    def getAssetManager(self) -> AssetManager: ...
    @overload
    def getAssetManager(self) -> AssetManager: ...
    def getInputMapRefs(self) -> list[Node.InputMap]: ...
    @overload
    def getInputRefs(self) -> list[Node.Input]: ...
    @overload
    def getInputRefs(self) -> list[Node.Input]: ...
    def getInputs(self) -> list[Node.Input]: ...
    def getName(self) -> str: ...
    def getOutputMapRefs(self) -> list[Node.OutputMap]: ...
    @overload
    def getOutputRefs(self) -> list[Node.Output]: ...
    @overload
    def getOutputRefs(self) -> list[Node.Output]: ...
    def getOutputs(self) -> list[Node.Output]: ...
    @overload
    def getParentPipeline(self) -> Pipeline: ...
    @overload
    def getParentPipeline(self) -> Pipeline: ...
    def stopPipeline(self) -> None: ...
    @property
    def id(self) -> int: ...

class NodeGroup(Node):
    def __init__(self, *args, **kwargs) -> None: ...

class ObjectTrackerProperties:
    detectionLabelsToTrack: list[int]
    maxObjectsToTrack: int
    trackerIdAssignmentPolicy: TrackerIdAssignmentPolicy
    trackerThreshold: float
    trackerType: TrackerType
    def __init__(self, *args, **kwargs) -> None: ...

class OpenVINO:
    class Blob:
        data: Any
        device: OpenVINO.Device
        networkInputs: dict[str,TensorInfo]
        networkOutputs: dict[str,TensorInfo]
        numShaves: int
        numSlices: int
        stageCount: int
        version: OpenVINO.Version
        @overload
        def __init__(self, arg0, std) -> None: ...
        @overload
        def __init__(self, arg0: os.PathLike) -> None: ...

    class Device:
        __members__: ClassVar[dict] = ...  # read-only
        VPU: ClassVar[OpenVINO.Device] = ...
        VPUX: ClassVar[OpenVINO.Device] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class SuperBlob:
        NUMBER_OF_PATCHES: ClassVar[int] = ...  # read-only
        @overload
        def __init__(self, superblobBytes, std) -> None: ...
        @overload
        def __init__(self, pathToSuperBlobFile: str) -> None: ...
        def getBlobWithNumShaves(self, numShaves: int) -> OpenVINO.Blob: ...

    class Version:
        __members__: ClassVar[dict] = ...  # read-only
        VERSION_2020_3: ClassVar[OpenVINO.Version] = ...
        VERSION_2020_4: ClassVar[OpenVINO.Version] = ...
        VERSION_2021_1: ClassVar[OpenVINO.Version] = ...
        VERSION_2021_2: ClassVar[OpenVINO.Version] = ...
        VERSION_2021_3: ClassVar[OpenVINO.Version] = ...
        VERSION_2021_4: ClassVar[OpenVINO.Version] = ...
        VERSION_2022_1: ClassVar[OpenVINO.Version] = ...
        VERSION_UNIVERSAL: ClassVar[OpenVINO.Version] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    DEFAULT_VERSION: ClassVar[OpenVINO.Version] = ...
    VERSION_2020_3: ClassVar[OpenVINO.Version] = ...
    VERSION_2020_4: ClassVar[OpenVINO.Version] = ...
    VERSION_2021_1: ClassVar[OpenVINO.Version] = ...
    VERSION_2021_2: ClassVar[OpenVINO.Version] = ...
    VERSION_2021_3: ClassVar[OpenVINO.Version] = ...
    VERSION_2021_4: ClassVar[OpenVINO.Version] = ...
    VERSION_2022_1: ClassVar[OpenVINO.Version] = ...
    VERSION_UNIVERSAL: ClassVar[OpenVINO.Version] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def areVersionsBlobCompatible(cls, v1: OpenVINO.Version, v2: OpenVINO.Version) -> bool: ...
    @classmethod
    def getBlobLatestSupportedVersion(cls, *args, **kwargs) -> Any: ...
    @classmethod
    def getBlobSupportedVersions(cls, *args, **kwargs) -> Any: ...
    @classmethod
    def getVersionName(cls, version: OpenVINO.Version) -> str: ...
    @classmethod
    def getVersions(cls) -> list[OpenVINO.Version]: ...
    @classmethod
    def parseVersionName(cls, versionString: str) -> OpenVINO.Version: ...

class Pipeline:
    @overload
    def __init__(self, createImplicitDevice: bool = ...) -> None: ...
    @overload
    def __init__(self, defaultDevice: Device) -> None: ...
    def add(self, arg0: Node) -> Node: ...
    def build(self) -> None: ...
    def create(self, arg0: Type[T], *args, **kwargs) -> T: ...
    def enableHolisticRecord(self, recordConfig: RecordConfig) -> None: ...
    def enableHolisticReplay(self, recordingPath: str) -> None: ...
    def getAllNodes(self) -> list[Node]: ...
    @overload
    def getAssetManager(self) -> AssetManager: ...
    @overload
    def getAssetManager(self) -> AssetManager: ...
    def getBoardConfig(self) -> BoardConfig: ...
    def getCalibrationData(self) -> CalibrationHandler: ...
    @overload
    def getDefaultDevice(self) -> Device: ...
    @overload
    def getDefaultDevice(self) -> Device: ...
    def getDeviceConfig(self) -> Device.Config: ...
    def getGlobalProperties(self) -> GlobalProperties: ...
    def getNode(self, arg0: int) -> Node: ...
    def isBuilt(self) -> bool: ...
    def isRunning(self) -> bool: ...
    def processTasks(self, waitForTasks: bool = ..., timeoutSeconds: float = ...) -> None: ...
    def remove(self, node: Node) -> None: ...
    def run(self) -> None: ...
    def serializeToJson(self, arg0: bool) -> json: ...
    def setBoardConfig(self, arg0: BoardConfig) -> None: ...
    def setCalibrationData(self, calibrationDataHandler: CalibrationHandler) -> None: ...
    def setCameraTuningBlobPath(self, path: os.PathLike) -> None: ...
    def setSippBufferSize(self, sizeBytes: int) -> None: ...
    def setSippDmaBufferSize(self, sizeBytes: int) -> None: ...
    def setXLinkChunkSize(self, sizeBytes: int) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def wait(self) -> None: ...
    def __enter__(self) -> Pipeline: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...

class Platform:
    __members__: ClassVar[dict] = ...  # read-only
    RVC2: ClassVar[Platform] = ...
    RVC3: ClassVar[Platform] = ...
    RVC4: ClassVar[Platform] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Point2f:
    x: float
    y: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: float, y: float) -> None: ...
    @overload
    def __init__(self, x: float, y: float, normalized: bool) -> None: ...
    def isNormalized(self) -> bool: ...

class Point3d:
    x: float
    y: float
    z: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None: ...

class Point3f:
    x: float
    y: float
    z: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None: ...

class Point3fRGBA:
    a: int
    b: int
    g: int
    r: int
    x: float
    y: float
    z: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: int, arg4: int, arg5: int) -> None: ...

class PointCloudConfig(Buffer):
    def __init__(self) -> None: ...
    def getSparse(self) -> bool: ...
    def getTransformationMatrix(self, *args, **kwargs) -> Any: ...
    def setSparse(self, arg0: bool) -> PointCloudConfig: ...
    @overload
    def setTransformationMatrix(self, arg0) -> PointCloudConfig: ...
    @overload
    def setTransformationMatrix(self, arg0) -> PointCloudConfig: ...

class PointCloudData(Buffer):
    def __init__(self) -> None: ...
    def getHeight(self) -> int: ...
    def getInstanceNum(self) -> int: ...
    def getMaxX(self) -> float: ...
    def getMaxY(self) -> float: ...
    def getMaxZ(self) -> float: ...
    def getMinX(self) -> float: ...
    def getMinY(self) -> float: ...
    def getMinZ(self) -> float: ...
    def getPoints(self) -> numpy.ndarray[numpy.float32]: ...
    def getPointsRGB(self) -> tuple: ...
    def getSequenceNum(self) -> int: ...
    def getTimestamp(self) -> datetime.timedelta: ...
    def getTimestampDevice(self) -> datetime.timedelta: ...
    def getWidth(self) -> int: ...
    def isColor(self) -> bool: ...
    def isSparse(self) -> bool: ...
    def setHeight(self, arg0: int) -> PointCloudData: ...
    def setInstanceNum(self, arg0: int) -> PointCloudData: ...
    def setMaxX(self, arg0: float) -> PointCloudData: ...
    def setMaxY(self, arg0: float) -> PointCloudData: ...
    def setMaxZ(self, arg0: float) -> PointCloudData: ...
    def setMinX(self, arg0: float) -> PointCloudData: ...
    def setMinY(self, arg0: float) -> PointCloudData: ...
    def setMinZ(self, arg0: float) -> PointCloudData: ...
    def setPoints(self, arg0: numpy.ndarray[numpy.float32]) -> None: ...
    def setPointsRGB(self, arg0: numpy.ndarray[numpy.float32], arg1: numpy.ndarray[numpy.uint8]) -> None: ...
    @overload
    def setSize(self, width: int, height: int) -> PointCloudData: ...
    @overload
    def setSize(self, size: tuple[int,int]) -> PointCloudData: ...
    def setWidth(self, arg0: int) -> PointCloudData: ...

class PointCloudProperties:
    initialConfig: PointCloudConfig
    numFramesPool: int
    def __init__(self, *args, **kwargs) -> None: ...

class PointsAnnotation:
    fillColor: Color
    outlineColor: Color
    outlineColors: VectorColor
    points: VectorPoint2f
    thickness: float
    type: PointsAnnotationType
    def __init__(self) -> None: ...

class PointsAnnotationType:
    __members__: ClassVar[dict] = ...  # read-only
    LINE_LIST: ClassVar[PointsAnnotationType] = ...
    LINE_LOOP: ClassVar[PointsAnnotationType] = ...
    LINE_STRIP: ClassVar[PointsAnnotationType] = ...
    POINTS: ClassVar[PointsAnnotationType] = ...
    UNKNOWN: ClassVar[PointsAnnotationType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ProcessorType:
    __members__: ClassVar[dict] = ...  # read-only
    CPU: ClassVar[ProcessorType] = ...
    DSP: ClassVar[ProcessorType] = ...
    LEON_CSS: ClassVar[ProcessorType] = ...
    LEON_MSS: ClassVar[ProcessorType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ProfilingData:
    numBytesRead: int
    numBytesWritten: int
    def __init__(self, *args, **kwargs) -> None: ...

class Properties:
    def __init__(self, *args, **kwargs) -> None: ...

class Quaterniond:
    qw: float
    qx: float
    qy: float
    qz: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float) -> None: ...

class RGBDData(Buffer):
    def __init__(self) -> None: ...
    def getDepthFrame(self) -> ImgFrame: ...
    def getRGBFrame(self) -> ImgFrame: ...
    def setDepthFrame(self, frame: ImgFrame) -> None: ...
    def setRGBFrame(self, frame: ImgFrame) -> None: ...

class RecordConfig:
    class VideoEncoding:
        bitrate: int
        enabled: bool
        lossless: bool
        profile: VideoEncoderProperties.Profile
        quality: int
        def __init__(self) -> None: ...
    compressionLevel: Any
    outputDir: os.PathLike
    videoEncoding: RecordConfig.VideoEncoding
    def __init__(self) -> None: ...

class Rect:
    height: float
    width: float
    x: float
    y: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float) -> None: ...
    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: bool) -> None: ...
    @overload
    def __init__(self, arg0: Point2f, arg1: Point2f) -> None: ...
    @overload
    def __init__(self, arg0: Point2f, arg1: Point2f, arg2: bool) -> None: ...
    @overload
    def __init__(self, arg0: Point2f, arg1: Size2f) -> None: ...
    @overload
    def __init__(self, arg0: Point2f, arg1: Size2f, arg2: bool) -> None: ...
    def area(self) -> float: ...
    def bottomRight(self) -> Point2f: ...
    def contains(self, arg0: Point2f) -> bool: ...
    def denormalize(self, width: int, height: int) -> Rect: ...
    def empty(self) -> bool: ...
    def isNormalized(self) -> bool: ...
    def normalize(self, width: int, height: int) -> Rect: ...
    def size(self) -> Size2f: ...
    def topLeft(self) -> Point2f: ...

class RemoteConnection:
    def __init__(self, address: str = ..., webSocketPort: int = ..., serveFrontend: bool = ..., httpPort: int = ...) -> None: ...
    @overload
    def addTopic(self, topicName: str, output: Node.Output, group: str = ..., useVisualizationIfAvailable: bool = ...) -> None: ...
    @overload
    def addTopic(self, topicName: str, group: str = ..., maxSize: int = ..., blocking: bool = ..., useVisualizationIfAvailable: bool = ...) -> MessageQueue: ...
    def registerPipeline(self, pipeline: Pipeline) -> None: ...
    def registerService(self, serviceName: str, callback: Callable[[json],json]) -> None: ...
    def removeTopic(self, topicName: str) -> bool: ...
    def waitKey(self, delay: int) -> int: ...

class RotatedRect:
    angle: float
    center: Point2f
    size: Size2f
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: Point2f, arg1: Size2f, arg2: float) -> None: ...
    @overload
    def __init__(self, arg0: Rect, arg1: float) -> None: ...
    def denormalize(self, width: int, height: int, force: bool = ...) -> RotatedRect: ...
    def getOuterRect(self, *args, **kwargs) -> Any: ...
    def getPoints(self, *args, **kwargs) -> Any: ...
    def isNormalized(self) -> bool: ...
    def normalize(self, width: int, height: int) -> RotatedRect: ...

class SPIInProperties:
    busId: int
    maxDataSize: int
    numFrames: int
    streamName: str
    def __init__(self, *args, **kwargs) -> None: ...

class SPIOutProperties:
    busId: int
    streamName: str
    def __init__(self, *args, **kwargs) -> None: ...

class ScriptProperties:
    processor: ProcessorType
    scriptName: str
    scriptUri: str
    def __init__(self, *args, **kwargs) -> None: ...

class SerializationType:
    __members__: ClassVar[dict] = ...  # read-only
    JSON: ClassVar[SerializationType] = ...
    JSON_MSGPACK: ClassVar[SerializationType] = ...
    LIBNOP: ClassVar[SerializationType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Size2f:
    height: float
    width: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, width: float, height: float) -> None: ...
    @overload
    def __init__(self, width: float, height: float, normalized: bool) -> None: ...
    def isNormalized(self) -> bool: ...

class SlugComponents:
    modelRef: str
    modelSlug: str
    modelVariantSlug: str
    teamName: str
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, teamName: str = ..., modelSlug: str = ..., modelVariantSlug: str = ..., modelRef: str = ...) -> None: ...
    def merge(self) -> str: ...
    @classmethod
    def split(cls, slug: str) -> SlugComponents: ...

class SpatialDetectionNetworkProperties:
    depthThresholds: SpatialLocationCalculatorConfigThresholds
    detectedBBScaleFactor: float
    def __init__(self, *args, **kwargs) -> None: ...

class SpatialImgDetection(ImgDetection):
    boundingBoxMapping: SpatialLocationCalculatorConfigData
    spatialCoordinates: Point3f
    def __init__(self) -> None: ...

class SpatialImgDetections(Buffer):
    detections: list[SpatialImgDetection]
    def __init__(self) -> None: ...
    def getSequenceNum(self) -> int: ...
    def getTimestamp(self) -> datetime.timedelta: ...
    def getTimestampDevice(self) -> datetime.timedelta: ...
    def getTransformation(self) -> Optional[ImgTransformation]: ...
    def setTransformation(self, arg0: Optional[ImgTransformation]) -> None: ...

class SpatialLocationCalculatorAlgorithm:
    __members__: ClassVar[dict] = ...  # read-only
    AVERAGE: ClassVar[SpatialLocationCalculatorAlgorithm] = ...
    MAX: ClassVar[SpatialLocationCalculatorAlgorithm] = ...
    MEAN: ClassVar[SpatialLocationCalculatorAlgorithm] = ...
    MEDIAN: ClassVar[SpatialLocationCalculatorAlgorithm] = ...
    MIN: ClassVar[SpatialLocationCalculatorAlgorithm] = ...
    MODE: ClassVar[SpatialLocationCalculatorAlgorithm] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SpatialLocationCalculatorConfig(Buffer):
    def __init__(self) -> None: ...
    def addROI(self, ROI: SpatialLocationCalculatorConfigData) -> None: ...
    def getConfigData(self) -> list[SpatialLocationCalculatorConfigData]: ...
    def setROIs(self, ROIs: list[SpatialLocationCalculatorConfigData]) -> None: ...

class SpatialLocationCalculatorConfigData:
    calculationAlgorithm: SpatialLocationCalculatorAlgorithm
    depthThresholds: SpatialLocationCalculatorConfigThresholds
    roi: Rect
    def __init__(self) -> None: ...

class SpatialLocationCalculatorConfigThresholds:
    lowerThreshold: int
    upperThreshold: int
    def __init__(self) -> None: ...

class SpatialLocationCalculatorData(Buffer):
    spatialLocations: list[SpatialLocations]
    def __init__(self) -> None: ...
    def getSequenceNum(self) -> int: ...
    def getSpatialLocations(self) -> list[SpatialLocations]: ...
    def getTimestamp(self) -> datetime.timedelta: ...
    def getTimestampDevice(self) -> datetime.timedelta: ...

class SpatialLocationCalculatorProperties:
    roiConfig: SpatialLocationCalculatorConfig
    def __init__(self, *args, **kwargs) -> None: ...

class SpatialLocations:
    config: SpatialLocationCalculatorConfigData
    depthAverage: float
    depthAveragePixelCount: int
    depthMax: int
    depthMedian: float
    depthMin: int
    depthMode: float
    spatialCoordinates: Point3f
    def __init__(self) -> None: ...

class StereoDepthConfig(Buffer):
    class AlgorithmControl:
        class DepthAlign:
            __members__: ClassVar[dict] = ...  # read-only
            CENTER: ClassVar[StereoDepthConfig.AlgorithmControl.DepthAlign] = ...
            RECTIFIED_LEFT: ClassVar[StereoDepthConfig.AlgorithmControl.DepthAlign] = ...
            RECTIFIED_RIGHT: ClassVar[StereoDepthConfig.AlgorithmControl.DepthAlign] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
    
        class DepthUnit:
            __members__: ClassVar[dict] = ...  # read-only
            CENTIMETER: ClassVar[StereoDepthConfig.AlgorithmControl.DepthUnit] = ...
            CUSTOM: ClassVar[StereoDepthConfig.AlgorithmControl.DepthUnit] = ...
            FOOT: ClassVar[StereoDepthConfig.AlgorithmControl.DepthUnit] = ...
            INCH: ClassVar[StereoDepthConfig.AlgorithmControl.DepthUnit] = ...
            METER: ClassVar[StereoDepthConfig.AlgorithmControl.DepthUnit] = ...
            MILLIMETER: ClassVar[StereoDepthConfig.AlgorithmControl.DepthUnit] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
        centerAlignmentShiftFactor: Optional[float]
        customDepthUnitMultiplier: float
        depthAlign: StereoDepthConfig.AlgorithmControl.DepthAlign
        depthUnit: StereoDepthConfig.AlgorithmControl.DepthUnit
        disparityShift: int
        enableExtended: bool
        enableLeftRightCheck: bool
        enableSubpixel: bool
        enableSwLeftRightCheck: bool
        leftRightCheckThreshold: int
        numInvalidateEdgePixels: int
        subpixelFractionalBits: int
        def __init__(self) -> None: ...

    class CensusTransform:
        class KernelSize:
            __members__: ClassVar[dict] = ...  # read-only
            AUTO: ClassVar[StereoDepthConfig.CensusTransform.KernelSize] = ...
            KERNEL_5x5: ClassVar[StereoDepthConfig.CensusTransform.KernelSize] = ...
            KERNEL_7x7: ClassVar[StereoDepthConfig.CensusTransform.KernelSize] = ...
            KERNEL_7x9: ClassVar[StereoDepthConfig.CensusTransform.KernelSize] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
        enableMeanMode: bool
        kernelMask: int
        kernelSize: StereoDepthConfig.CensusTransform.KernelSize
        noiseThresholdOffset: int
        noiseThresholdScale: int
        threshold: int
        def __init__(self) -> None: ...

    class ConfidenceMetrics:
        flatnessConfidenceThreshold: int
        flatnessConfidenceWeight: int
        flatnessOverride: bool
        motionVectorConfidenceThreshold: int
        motionVectorConfidenceWeight: int
        occlusionConfidenceWeight: int
        def __init__(self) -> None: ...

    class CostAggregation:
        class P1Config:
            defaultValue: int
            edgeThreshold: int
            edgeValue: int
            enableAdaptive: bool
            smoothThreshold: int
            smoothValue: int
            def __init__(self) -> None: ...
    
        class P2Config:
            defaultValue: int
            edgeValue: int
            enableAdaptive: bool
            smoothValue: int
            def __init__(self) -> None: ...
        divisionFactor: int
        horizontalPenaltyCostP1: int
        horizontalPenaltyCostP2: int
        p1Config: StereoDepthConfig.CostAggregation.P1Config
        p2Config: StereoDepthConfig.CostAggregation.P2Config
        verticalPenaltyCostP1: int
        verticalPenaltyCostP2: int
        def __init__(self) -> None: ...

    class CostMatching:
        class DisparityWidth:
            __members__: ClassVar[dict] = ...  # read-only
            DISPARITY_64: ClassVar[StereoDepthConfig.CostMatching.DisparityWidth] = ...
            DISPARITY_96: ClassVar[StereoDepthConfig.CostMatching.DisparityWidth] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
    
        class LinearEquationParameters:
            alpha: int
            beta: int
            threshold: int
            def __init__(self) -> None: ...
        confidenceThreshold: int
        disparityWidth: StereoDepthConfig.CostMatching.DisparityWidth
        enableCompanding: bool
        enableSwConfidenceThresholding: bool
        invalidDisparityValue: int
        linearEquationParameters: StereoDepthConfig.CostMatching.LinearEquationParameters
        def __init__(self) -> None: ...

    class MedianFilter:
        __members__: ClassVar[dict] = ...  # read-only
        KERNEL_3x3: ClassVar[filters.params.MedianFilter] = ...
        KERNEL_5x5: ClassVar[filters.params.MedianFilter] = ...
        KERNEL_7x7: ClassVar[filters.params.MedianFilter] = ...
        MEDIAN_OFF: ClassVar[filters.params.MedianFilter] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class PostProcessing:
        class AdaptiveMedianFilter:
            confidenceThreshold: int
            enable: bool
            def __init__(self) -> None: ...
    
        class BrightnessFilter:
            maxBrightness: int
            minBrightness: int
            def __init__(self) -> None: ...
    
        class DecimationFilter:
            class DecimationMode:
                __members__: ClassVar[dict] = ...  # read-only
                NON_ZERO_MEAN: ClassVar[StereoDepthConfig.PostProcessing.DecimationFilter.DecimationMode] = ...
                NON_ZERO_MEDIAN: ClassVar[StereoDepthConfig.PostProcessing.DecimationFilter.DecimationMode] = ...
                PIXEL_SKIPPING: ClassVar[StereoDepthConfig.PostProcessing.DecimationFilter.DecimationMode] = ...
                __entries: ClassVar[dict] = ...
                def __init__(self, value: int) -> None: ...
                def __eq__(self, other: object) -> bool: ...
                def __getstate__(self) -> int: ...
                def __hash__(self) -> int: ...
                def __index__(self) -> int: ...
                def __int__(self) -> int: ...
                def __ne__(self, other: object) -> bool: ...
                def __setstate__(self, state: int) -> None: ...
                @property
                def name(self) -> str: ...
                @property
                def value(self) -> int: ...
            decimationFactor: int
            decimationMode: StereoDepthConfig.PostProcessing.DecimationFilter.DecimationMode
            def __init__(self) -> None: ...
    
        class Filter:
            __members__: ClassVar[dict] = ...  # read-only
            DECIMATION: ClassVar[StereoDepthConfig.PostProcessing.Filter] = ...
            MEDIAN: ClassVar[StereoDepthConfig.PostProcessing.Filter] = ...
            NONE: ClassVar[StereoDepthConfig.PostProcessing.Filter] = ...
            SPATIAL: ClassVar[StereoDepthConfig.PostProcessing.Filter] = ...
            SPECKLE: ClassVar[StereoDepthConfig.PostProcessing.Filter] = ...
            TEMPORAL: ClassVar[StereoDepthConfig.PostProcessing.Filter] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
    
        class HoleFilling:
            enable: bool
            fillConfidenceThreshold: int
            highConfidenceThreshold: int
            invalidateDisparities: bool
            minValidDisparity: int
            def __init__(self) -> None: ...
    
        class SpatialFilter:
            alpha: float
            delta: int
            enable: bool
            holeFillingRadius: int
            numIterations: int
            def __init__(self) -> None: ...
    
        class SpeckleFilter:
            differenceThreshold: int
            enable: bool
            speckleRange: int
            def __init__(self) -> None: ...
    
        class TemporalFilter:
            class PersistencyMode:
                __members__: ClassVar[dict] = ...  # read-only
                PERSISTENCY_INDEFINITELY: ClassVar[filters.params.TemporalFilter.PersistencyMode] = ...
                PERSISTENCY_OFF: ClassVar[filters.params.TemporalFilter.PersistencyMode] = ...
                VALID_1_IN_LAST_2: ClassVar[filters.params.TemporalFilter.PersistencyMode] = ...
                VALID_1_IN_LAST_5: ClassVar[filters.params.TemporalFilter.PersistencyMode] = ...
                VALID_1_IN_LAST_8: ClassVar[filters.params.TemporalFilter.PersistencyMode] = ...
                VALID_2_IN_LAST_3: ClassVar[filters.params.TemporalFilter.PersistencyMode] = ...
                VALID_2_IN_LAST_4: ClassVar[filters.params.TemporalFilter.PersistencyMode] = ...
                VALID_2_OUT_OF_8: ClassVar[filters.params.TemporalFilter.PersistencyMode] = ...
                VALID_8_OUT_OF_8: ClassVar[filters.params.TemporalFilter.PersistencyMode] = ...
                __entries: ClassVar[dict] = ...
                def __init__(self, value: int) -> None: ...
                def __eq__(self, other: object) -> bool: ...
                def __getstate__(self) -> int: ...
                def __hash__(self) -> int: ...
                def __index__(self) -> int: ...
                def __int__(self) -> int: ...
                def __ne__(self, other: object) -> bool: ...
                def __setstate__(self, state: int) -> None: ...
                @property
                def name(self) -> str: ...
                @property
                def value(self) -> int: ...
            alpha: float
            delta: int
            enable: bool
            persistencyMode: Any
            def __init__(self) -> None: ...
    
        class ThresholdFilter:
            maxRange: int
            minRange: int
            def __init__(self) -> None: ...
        adaptiveMedianFilter: StereoDepthConfig.PostProcessing.AdaptiveMedianFilter
        bilateralSigmaValue: int
        brightnessFilter: StereoDepthConfig.PostProcessing.BrightnessFilter
        decimationFilter: StereoDepthConfig.PostProcessing.DecimationFilter
        filteringOrder: Any
        holeFilling: StereoDepthConfig.PostProcessing.HoleFilling
        median: filters.params.MedianFilter
        spatialFilter: filters.params.SpatialFilter
        speckleFilter: filters.params.SpeckleFilter
        temporalFilter: filters.params.TemporalFilter
        thresholdFilter: StereoDepthConfig.PostProcessing.ThresholdFilter
        def __init__(self) -> None: ...
    algorithmControl: StereoDepthConfig.AlgorithmControl
    censusTransform: StereoDepthConfig.CensusTransform
    confidenceMetrics: StereoDepthConfig.ConfidenceMetrics
    costAggregation: StereoDepthConfig.CostAggregation
    costMatching: StereoDepthConfig.CostMatching
    postProcessing: StereoDepthConfig.PostProcessing
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def getBilateralFilterSigma(self) -> int: ...
    def getConfidenceThreshold(self) -> int: ...
    def getDepthUnit(self) -> StereoDepthConfig.AlgorithmControl.DepthUnit: ...
    def getExtendedDisparity(self) -> bool: ...
    def getFiltersComputeBackend(self) -> ProcessorType: ...
    def getLeftRightCheck(self) -> bool: ...
    def getLeftRightCheckThreshold(self) -> int: ...
    def getMaxDisparity(self) -> float: ...
    def getMedianFilter(self) -> filters.params.MedianFilter: ...
    def getSubpixel(self) -> bool: ...
    def getSubpixelFractionalBits(self) -> int: ...
    def setBilateralFilterSigma(self, sigma: int) -> StereoDepthConfig: ...
    def setConfidenceThreshold(self, confThr: int) -> StereoDepthConfig: ...
    def setDepthAlign(self, align: StereoDepthConfig.AlgorithmControl.DepthAlign) -> StereoDepthConfig: ...
    def setDepthUnit(self, arg0: StereoDepthConfig.AlgorithmControl.DepthUnit) -> StereoDepthConfig: ...
    def setDisparityShift(self, arg0: int) -> StereoDepthConfig: ...
    def setExtendedDisparity(self, enable: bool) -> StereoDepthConfig: ...
    def setFiltersComputeBackend(self, filtersBackend: ProcessorType) -> StereoDepthConfig: ...
    def setLeftRightCheck(self, enable: bool) -> StereoDepthConfig: ...
    def setLeftRightCheckThreshold(self, sigma: int) -> StereoDepthConfig: ...
    def setMedianFilter(self, median: filters.params.MedianFilter) -> StereoDepthConfig: ...
    def setNumInvalidateEdgePixels(self, arg0: int) -> StereoDepthConfig: ...
    def setSubpixel(self, enable: bool) -> StereoDepthConfig: ...
    def setSubpixelFractionalBits(self, subpixelFractionalBits: int) -> StereoDepthConfig: ...

class StereoDepthProperties:
    class RectificationMesh:
        meshLeftUri: str
        meshRightUri: str
        meshSize: Optional[int]
        stepHeight: int
        stepWidth: int
        def __init__(self, *args, **kwargs) -> None: ...
    alphaScaling: Optional[float]
    baseline: Optional[float]
    depthAlignCamera: CameraBoardSocket
    depthAlignmentUseSpecTranslation: Optional[bool]
    disparityToDepthUseSpecTranslation: Optional[bool]
    enableRectification: bool
    enableRuntimeStereoModeSwitch: bool
    focalLength: Optional[float]
    focalLengthFromCalibration: bool
    height: Optional[int]
    initialConfig: StereoDepthConfig
    mesh: StereoDepthProperties.RectificationMesh
    numFramesPool: int
    numPostProcessingMemorySlices: int
    numPostProcessingShaves: int
    outHeight: Optional[int]
    outKeepAspectRatio: bool
    outWidth: Optional[int]
    rectificationUseSpecTranslation: Optional[bool]
    rectifyEdgeFillColor: int
    useHomographyRectification: Optional[bool]
    width: Optional[int]
    def __init__(self, *args, **kwargs) -> None: ...

class StereoPair:
    baseline: float
    isVertical: bool
    left: CameraBoardSocket
    right: CameraBoardSocket
    def __init__(self) -> None: ...

class StereoRectification:
    leftCameraSocket: CameraBoardSocket
    rectifiedRotationLeft: list[list[float]]
    rectifiedRotationRight: list[list[float]]
    rightCameraSocket: CameraBoardSocket
    def __init__(self) -> None: ...

class SyncProperties:
    syncAttempts: int
    syncThresholdNs: int
    def __init__(self, *args, **kwargs) -> None: ...

class SystemInformation(Buffer):
    chipTemperature: ChipTemperature
    cmxMemoryUsage: MemoryInfo
    ddrMemoryUsage: MemoryInfo
    leonCssCpuUsage: CpuUsage
    leonCssMemoryUsage: MemoryInfo
    leonMssCpuUsage: CpuUsage
    leonMssMemoryUsage: MemoryInfo
    def __init__(self) -> None: ...

class SystemInformationS3(Buffer):
    chipTemperature: ChipTemperatureS3
    cpuAvgUsage: CpuUsage
    cpuUsages: list[CpuUsage]
    ddrMemoryUsage: MemoryInfo
    def __init__(self) -> None: ...

class SystemLoggerProperties:
    rateHz: float
    def __init__(self, *args, **kwargs) -> None: ...

class TensorInfo:
    class DataType:
        __members__: ClassVar[dict] = ...  # read-only
        FP16: ClassVar[TensorInfo.DataType] = ...
        FP32: ClassVar[TensorInfo.DataType] = ...
        FP64: ClassVar[TensorInfo.DataType] = ...
        I8: ClassVar[TensorInfo.DataType] = ...
        INT: ClassVar[TensorInfo.DataType] = ...
        U8F: ClassVar[TensorInfo.DataType] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class StorageOrder:
        __members__: ClassVar[dict] = ...  # read-only
        C: ClassVar[TensorInfo.StorageOrder] = ...
        CHW: ClassVar[TensorInfo.StorageOrder] = ...
        CN: ClassVar[TensorInfo.StorageOrder] = ...
        CWH: ClassVar[TensorInfo.StorageOrder] = ...
        H: ClassVar[TensorInfo.StorageOrder] = ...
        HCW: ClassVar[TensorInfo.StorageOrder] = ...
        HWC: ClassVar[TensorInfo.StorageOrder] = ...
        NC: ClassVar[TensorInfo.StorageOrder] = ...
        NCHW: ClassVar[TensorInfo.StorageOrder] = ...
        NHCW: ClassVar[TensorInfo.StorageOrder] = ...
        NHWC: ClassVar[TensorInfo.StorageOrder] = ...
        W: ClassVar[TensorInfo.StorageOrder] = ...
        WCH: ClassVar[TensorInfo.StorageOrder] = ...
        WHC: ClassVar[TensorInfo.StorageOrder] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    dataType: TensorInfo.DataType
    dims: list[int]
    name: str
    numDimensions: int
    offset: int
    order: TensorInfo.StorageOrder
    qpScale: float
    qpZp: float
    quantization: bool
    strides: list[int]
    def __init__(self) -> None: ...
    def getTensorSize(self) -> int: ...

class TextAnnotation:
    backgroundColor: Color
    fontSize: float
    position: Point2f
    text: str
    textColor: Color
    def __init__(self) -> None: ...

class ThermalAmbientParams:
    atmosphericTemperature: Optional[int]
    atmosphericTransmittance: Optional[int]
    distance: Optional[int]
    gainMode: Optional[ThermalGainMode]
    reflectionTemperature: Optional[int]
    targetEmissivity: Optional[int]
    def __init__(self) -> None: ...

class ThermalConfig(Buffer):
    ambientParams: ThermalAmbientParams
    ffcParams: ThermalFFCParams
    imageParams: ThermalImageParams
    def __init__(self) -> None: ...

class ThermalFFCParams:
    antiFallProtectionThresholdHighGainMode: Optional[int]
    antiFallProtectionThresholdLowGainMode: Optional[int]
    autoFFC: Optional[bool]
    autoFFCTempThreshold: Optional[int]
    closeManualShutter: Optional[bool]
    fallProtection: Optional[bool]
    maxFFCInterval: Optional[int]
    minFFCInterval: Optional[int]
    minShutterInterval: Optional[int]
    def __init__(self) -> None: ...

class ThermalGainMode:
    __members__: ClassVar[dict] = ...  # read-only
    HIGH: ClassVar[ThermalGainMode] = ...
    LOW: ClassVar[ThermalGainMode] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ThermalImageParams:
    brightnessLevel: Optional[int]
    contrastLevel: Optional[int]
    digitalDetailEnhanceLevel: Optional[int]
    orientation: Any
    spatialNoiseFilterLevel: Optional[int]
    timeNoiseFilterLevel: Optional[int]
    def __init__(self) -> None: ...

class ThermalProperties:
    boardSocket: CameraBoardSocket
    fps: float
    initialConfig: ThermalConfig
    numFramesPool: int
    def __init__(self, *args, **kwargs) -> None: ...

class ThreadedNode(Node):
    def __init__(self, *args, **kwargs) -> None: ...
    def critical(self, arg0: str) -> None: ...
    def debug(self, arg0: str) -> None: ...
    def error(self, arg0: str) -> None: ...
    def getLogLevel(self) -> LogLevel: ...
    def info(self, arg0: str) -> None: ...
    def isRunning(self) -> bool: ...
    def setLogLevel(self, arg0: LogLevel) -> None: ...
    def trace(self, arg0: str) -> None: ...
    def warn(self, arg0: str) -> None: ...

class Timestamp:
    nsec: int
    sec: int
    def __init__(self) -> None: ...
    def get(self) -> datetime.timedelta: ...

class ToFConfig(Buffer):
    enableBurstMode: bool
    enableDistortionCorrection: bool
    enableFPPNCorrection: Optional[bool]
    enableOpticalCorrection: Optional[bool]
    enablePhaseShuffleTemporalFilter: bool
    enablePhaseUnwrapping: Optional[bool]
    enableTemperatureCorrection: Optional[bool]
    enableWiggleCorrection: Optional[bool]
    median: filters.params.MedianFilter
    phaseUnwrapErrorThreshold: int
    phaseUnwrappingLevel: int
    def __init__(self) -> None: ...
    def setMedianFilter(self, arg0: filters.params.MedianFilter) -> ToFConfig: ...
    def setProfilePreset(self, arg0: ImageFiltersPresetMode) -> None: ...

class ToFDepthConfidenceFilterConfig(Buffer):
    confidenceThreshold: float
    def __init__(self) -> None: ...
    def setProfilePreset(self, arg0) -> None: ...

class ToFDepthConfidenceFilterProperties:
    def __init__(self, *args, **kwargs) -> None: ...

class ToFProperties:
    initialConfig: ToFConfig
    numFramesPool: int
    numShaves: Optional[int]
    warpHwIds: list[int]
    def __init__(self, *args, **kwargs) -> None: ...

class TrackedFeature:
    age: int
    descriptor: Any
    harrisScore: float
    id: int
    position: Point2f
    trackingError: float
    def __init__(self) -> None: ...

class TrackedFeatures(Buffer):
    trackedFeatures: list[TrackedFeature]
    def __init__(self) -> None: ...
    def getSequenceNum(self) -> int: ...
    def getTimestamp(self) -> datetime.timedelta: ...
    def getTimestampDevice(self) -> datetime.timedelta: ...

class TrackerIdAssignmentPolicy:
    __members__: ClassVar[dict] = ...  # read-only
    SMALLEST_ID: ClassVar[TrackerIdAssignmentPolicy] = ...
    UNIQUE_ID: ClassVar[TrackerIdAssignmentPolicy] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TrackerType:
    __members__: ClassVar[dict] = ...  # read-only
    SHORT_TERM_IMAGELESS: ClassVar[TrackerType] = ...
    SHORT_TERM_KCF: ClassVar[TrackerType] = ...
    ZERO_TERM_COLOR_HISTOGRAM: ClassVar[TrackerType] = ...
    ZERO_TERM_IMAGELESS: ClassVar[TrackerType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Tracklet:
    class TrackingStatus:
        __members__: ClassVar[dict] = ...  # read-only
        LOST: ClassVar[Tracklet.TrackingStatus] = ...
        NEW: ClassVar[Tracklet.TrackingStatus] = ...
        REMOVED: ClassVar[Tracklet.TrackingStatus] = ...
        TRACKED: ClassVar[Tracklet.TrackingStatus] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    age: int
    id: int
    label: int
    roi: Rect
    spatialCoordinates: Point3f
    srcImgDetection: ImgDetection
    status: Tracklet.TrackingStatus
    def __init__(self) -> None: ...

class Tracklets(Buffer):
    tracklets: list[Tracklet]
    def __init__(self) -> None: ...
    def getSequenceNum(self) -> int: ...
    def getTimestamp(self) -> datetime.timedelta: ...
    def getTimestampDevice(self) -> datetime.timedelta: ...
    def getTransformation(self) -> ImgTransformation: ...
    def setTransformation(self, arg0: ImgTransformation) -> None: ...

class TransformData(Buffer):
    def __init__(self) -> None: ...
    def getQuaternion(self) -> Quaterniond: ...
    def getRotationEuler(self) -> Point3d: ...
    def getTranslation(self) -> Point3d: ...

class UVCProperties:
    gpioInit: dict[int,int]
    gpioStreamOff: dict[int,int]
    gpioStreamOn: dict[int,int]
    def __init__(self, *args, **kwargs) -> None: ...

class UsbSpeed:
    __members__: ClassVar[dict] = ...  # read-only
    FULL: ClassVar[UsbSpeed] = ...
    HIGH: ClassVar[UsbSpeed] = ...
    LOW: ClassVar[UsbSpeed] = ...
    SUPER: ClassVar[UsbSpeed] = ...
    SUPER_PLUS: ClassVar[UsbSpeed] = ...
    UNKNOWN: ClassVar[UsbSpeed] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class VectorCircleAnnotation:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: VectorCircleAnnotation) -> None: ...
    @overload
    def __init__(self, arg0: Iterable) -> None: ...
    def append(self, x: CircleAnnotation) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: VectorCircleAnnotation) -> None: ...
    @overload
    def extend(self, L: Iterable) -> None: ...
    def insert(self, i: int, x: CircleAnnotation) -> None: ...
    @overload
    def pop(self) -> CircleAnnotation: ...
    @overload
    def pop(self, i: int) -> CircleAnnotation: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> VectorCircleAnnotation: ...
    @overload
    def __getitem__(self, arg0: int) -> CircleAnnotation: ...
    def __iter__(self) -> Iterator[CircleAnnotation]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: CircleAnnotation) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: VectorCircleAnnotation) -> None: ...

class VectorColor:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: VectorColor) -> None: ...
    @overload
    def __init__(self, arg0: Iterable) -> None: ...
    def append(self, x: Color) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: VectorColor) -> None: ...
    @overload
    def extend(self, L: Iterable) -> None: ...
    def insert(self, i: int, x: Color) -> None: ...
    @overload
    def pop(self) -> Color: ...
    @overload
    def pop(self, i: int) -> Color: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> VectorColor: ...
    @overload
    def __getitem__(self, arg0: int) -> Color: ...
    def __iter__(self) -> Iterator[Color]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Color) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: VectorColor) -> None: ...

class VectorImgAnnotation:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: VectorImgAnnotation) -> None: ...
    @overload
    def __init__(self, arg0: Iterable) -> None: ...
    def append(self, x: ImgAnnotation) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: VectorImgAnnotation) -> None: ...
    @overload
    def extend(self, L: Iterable) -> None: ...
    def insert(self, i: int, x: ImgAnnotation) -> None: ...
    @overload
    def pop(self) -> ImgAnnotation: ...
    @overload
    def pop(self, i: int) -> ImgAnnotation: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> VectorImgAnnotation: ...
    @overload
    def __getitem__(self, arg0: int) -> ImgAnnotation: ...
    def __iter__(self) -> Iterator[ImgAnnotation]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: ImgAnnotation) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: VectorImgAnnotation) -> None: ...

class VectorPoint2f:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: VectorPoint2f) -> None: ...
    @overload
    def __init__(self, arg0: Iterable) -> None: ...
    def append(self, x: Point2f) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: VectorPoint2f) -> None: ...
    @overload
    def extend(self, L: Iterable) -> None: ...
    def insert(self, i: int, x: Point2f) -> None: ...
    @overload
    def pop(self) -> Point2f: ...
    @overload
    def pop(self, i: int) -> Point2f: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> VectorPoint2f: ...
    @overload
    def __getitem__(self, arg0: int) -> Point2f: ...
    def __iter__(self) -> Iterator[Point2f]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Point2f) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: VectorPoint2f) -> None: ...

class VectorPointsAnnotation:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: VectorPointsAnnotation) -> None: ...
    @overload
    def __init__(self, arg0: Iterable) -> None: ...
    def append(self, x: PointsAnnotation) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: VectorPointsAnnotation) -> None: ...
    @overload
    def extend(self, L: Iterable) -> None: ...
    def insert(self, i: int, x: PointsAnnotation) -> None: ...
    @overload
    def pop(self) -> PointsAnnotation: ...
    @overload
    def pop(self, i: int) -> PointsAnnotation: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> VectorPointsAnnotation: ...
    @overload
    def __getitem__(self, arg0: int) -> PointsAnnotation: ...
    def __iter__(self) -> Iterator[PointsAnnotation]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: PointsAnnotation) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: VectorPointsAnnotation) -> None: ...

class VectorTextAnnotation:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: VectorTextAnnotation) -> None: ...
    @overload
    def __init__(self, arg0: Iterable) -> None: ...
    def append(self, x: TextAnnotation) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: VectorTextAnnotation) -> None: ...
    @overload
    def extend(self, L: Iterable) -> None: ...
    def insert(self, i: int, x: TextAnnotation) -> None: ...
    @overload
    def pop(self) -> TextAnnotation: ...
    @overload
    def pop(self, i: int) -> TextAnnotation: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> VectorTextAnnotation: ...
    @overload
    def __getitem__(self, arg0: int) -> TextAnnotation: ...
    def __iter__(self) -> Iterator[TextAnnotation]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: TextAnnotation) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: VectorTextAnnotation) -> None: ...

class Version:
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self, v: str) -> None: ...
    @overload
    def __init__(self, major: int, minor: int, patch: int) -> None: ...
    def getBuildInfo(self) -> str: ...
    def toStringSemver(self) -> str: ...
    def __eq__(self, arg0: Version) -> bool: ...
    def __gt__(self, arg0: Version) -> bool: ...
    def __lt__(self, arg0: Version) -> bool: ...

class VideoEncoderProperties:
    class Profile:
        __members__: ClassVar[dict] = ...  # read-only
        H264_BASELINE: ClassVar[VideoEncoderProperties.Profile] = ...
        H264_HIGH: ClassVar[VideoEncoderProperties.Profile] = ...
        H264_MAIN: ClassVar[VideoEncoderProperties.Profile] = ...
        H265_MAIN: ClassVar[VideoEncoderProperties.Profile] = ...
        MJPEG: ClassVar[VideoEncoderProperties.Profile] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class RateControlMode:
        __members__: ClassVar[dict] = ...  # read-only
        CBR: ClassVar[VideoEncoderProperties.RateControlMode] = ...
        VBR: ClassVar[VideoEncoderProperties.RateControlMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    bitrate: int
    keyframeFrequency: int
    maxBitrate: int
    numBFrames: int
    numFramesPool: int
    outputFrameSize: int
    profile: VideoEncoderProperties.Profile
    quality: int
    rateCtrlMode: VideoEncoderProperties.RateControlMode
    def __init__(self, *args, **kwargs) -> None: ...

class VioConfig:
    mapper_bow_num_bits: int
    mapper_detection_num_points: int
    mapper_frames_to_match_threshold: float
    mapper_lm_lambda_max: float
    mapper_lm_lambda_min: float
    mapper_max_hamming_distance: float
    mapper_min_matches: float
    mapper_min_track_length: float
    mapper_min_triangulation_dist: float
    mapper_no_factor_weights: bool
    mapper_num_frames_to_match: float
    mapper_obs_huber_thresh: float
    mapper_obs_std_dev: float
    mapper_ransac_threshold: float
    mapper_second_best_test_ratio: float
    mapper_use_factors: bool
    mapper_use_lm: bool
    optical_flow_detection_grid_size: int
    optical_flow_detection_max_threshold: int
    optical_flow_detection_min_threshold: int
    optical_flow_detection_nonoverlap: bool
    optical_flow_detection_num_points_cell: int
    optical_flow_epipolar_error: float
    optical_flow_image_safe_radius: float
    optical_flow_levels: int
    optical_flow_matching_default_depth: float
    optical_flow_matching_guess_type: Any
    optical_flow_max_iterations: int
    optical_flow_max_recovered_dist2: float
    optical_flow_pattern: int
    optical_flow_recall_all_cams: bool
    optical_flow_recall_enable: bool
    optical_flow_recall_max_patch_dist: float
    optical_flow_recall_max_patch_norms: list[float]
    optical_flow_recall_num_points_cell: bool
    optical_flow_recall_over_tracking: bool
    optical_flow_recall_update_patch_viewpoint: bool
    optical_flow_skip_frames: int
    optical_flow_type: str
    vio_debug: bool
    vio_enforce_realtime: bool
    vio_extended_logging: bool
    vio_fix_long_term_keyframes: bool
    vio_init_ba_weight: float
    vio_init_bg_weight: float
    vio_init_pose_weight: float
    vio_kf_marg_criteria: Any
    vio_kf_marg_feature_ratio: float
    vio_linearization_type: Any
    vio_lm_lambda_initial: float
    vio_lm_lambda_max: float
    vio_lm_lambda_min: float
    vio_marg_lost_landmarks: bool
    vio_max_iterations: int
    vio_max_kfs: int
    vio_max_states: int
    vio_min_frames_after_kf: int
    vio_min_triangulation_dist: float
    vio_new_kf_keypoints_thresh: float
    vio_obs_huber_thresh: float
    vio_obs_std_dev: float
    vio_scale_jacobian: bool
    vio_sqrt_marg: bool
    vio_use_lm: bool
    def __init__(self) -> None: ...

class WarpProperties:
    def __init__(self, *args, **kwargs) -> None: ...

class XLinkConnection:
    @overload
    def __init__(self, arg0: DeviceInfo, arg1, std) -> None: ...
    @overload
    def __init__(self, arg0: DeviceInfo, arg1: str) -> None: ...
    @overload
    def __init__(self, arg0: DeviceInfo) -> None: ...
    @classmethod
    def bootBootloader(cls, devInfo: DeviceInfo) -> DeviceInfo: ...
    @classmethod
    def getAllConnectedDevices(cls, state: XLinkDeviceState = ..., skipInvalidDevices: bool = ..., timeoutMs: int = ...) -> list[DeviceInfo]: ...
    @classmethod
    def getDeviceById(cls, deviceId: str, state: XLinkDeviceState = ..., skipInvalidDevice: bool = ...) -> tuple[bool,DeviceInfo]: ...
    @classmethod
    def getFirstDevice(cls, state: XLinkDeviceState = ..., skipInvalidDevice: bool = ...) -> tuple[bool,DeviceInfo]: ...
    @classmethod
    def getGlobalProfilingData(cls) -> ProfilingData: ...

class XLinkDeviceState:
    __members__: ClassVar[dict] = ...  # read-only
    X_LINK_ANY_STATE: ClassVar[XLinkDeviceState] = ...
    X_LINK_BOOTED: ClassVar[XLinkDeviceState] = ...
    X_LINK_BOOTED_NON_EXCLUSIVE: ClassVar[XLinkDeviceState] = ...
    X_LINK_BOOTLOADER: ClassVar[XLinkDeviceState] = ...
    X_LINK_FLASH_BOOTED: ClassVar[XLinkDeviceState] = ...
    X_LINK_GATE: ClassVar[XLinkDeviceState] = ...
    X_LINK_GATE_BOOTED: ClassVar[XLinkDeviceState] = ...
    X_LINK_GATE_SETUP: ClassVar[XLinkDeviceState] = ...
    X_LINK_UNBOOTED: ClassVar[XLinkDeviceState] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class XLinkError(RuntimeError): ...

class XLinkError_t:
    __members__: ClassVar[dict] = ...  # read-only
    X_LINK_ALREADY_OPEN: ClassVar[XLinkError_t] = ...
    X_LINK_COMMUNICATION_FAIL: ClassVar[XLinkError_t] = ...
    X_LINK_COMMUNICATION_NOT_OPEN: ClassVar[XLinkError_t] = ...
    X_LINK_COMMUNICATION_UNKNOWN_ERROR: ClassVar[XLinkError_t] = ...
    X_LINK_DEVICE_ALREADY_IN_USE: ClassVar[XLinkError_t] = ...
    X_LINK_DEVICE_NOT_FOUND: ClassVar[XLinkError_t] = ...
    X_LINK_ERROR: ClassVar[XLinkError_t] = ...
    X_LINK_INIT_PCIE_ERROR: ClassVar[XLinkError_t] = ...
    X_LINK_INIT_TCP_IP_ERROR: ClassVar[XLinkError_t] = ...
    X_LINK_INIT_USB_ERROR: ClassVar[XLinkError_t] = ...
    X_LINK_INSUFFICIENT_PERMISSIONS: ClassVar[XLinkError_t] = ...
    X_LINK_NOT_IMPLEMENTED: ClassVar[XLinkError_t] = ...
    X_LINK_OUT_OF_MEMORY: ClassVar[XLinkError_t] = ...
    X_LINK_SUCCESS: ClassVar[XLinkError_t] = ...
    X_LINK_TIMEOUT: ClassVar[XLinkError_t] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class XLinkPlatform:
    __members__: ClassVar[dict] = ...  # read-only
    X_LINK_ANY_PLATFORM: ClassVar[XLinkPlatform] = ...
    X_LINK_MYRIAD_2: ClassVar[XLinkPlatform] = ...
    X_LINK_MYRIAD_X: ClassVar[XLinkPlatform] = ...
    X_LINK_RVC3: ClassVar[XLinkPlatform] = ...
    X_LINK_RVC4: ClassVar[XLinkPlatform] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class XLinkProtocol:
    __members__: ClassVar[dict] = ...  # read-only
    X_LINK_ANY_PROTOCOL: ClassVar[XLinkProtocol] = ...
    X_LINK_IPC: ClassVar[XLinkProtocol] = ...
    X_LINK_NMB_OF_PROTOCOLS: ClassVar[XLinkProtocol] = ...
    X_LINK_PCIE: ClassVar[XLinkProtocol] = ...
    X_LINK_TCP_IP: ClassVar[XLinkProtocol] = ...
    X_LINK_USB_CDC: ClassVar[XLinkProtocol] = ...
    X_LINK_USB_VSC: ClassVar[XLinkProtocol] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class XLinkReadError(XLinkError): ...

class XLinkWriteError(XLinkError): ...

class connectionInterface:
    __members__: ClassVar[dict] = ...  # read-only
    ETHERNET: ClassVar[connectionInterface] = ...
    USB: ClassVar[connectionInterface] = ...
    WIFI: ClassVar[connectionInterface] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

def downloadModelsFromZoo(path: os.PathLike, cacheDirectory: os.PathLike = ..., apiKey: str = ..., progressFormat: str = ...) -> bool: ...
def getModelFromZoo(modelDescription: NNModelDescription, useCached: bool = ..., cacheDirectory: os.PathLike = ..., apiKey: str = ..., progressFormat: str = ...) -> os.PathLike: ...
def isDatatypeSubclassOf(arg0: DatatypeEnum, arg1: DatatypeEnum) -> bool: ...
def platform2string(arg0: Platform) -> str: ...
def readModelType(modelPath: os.PathLike) -> ModelType: ...
def string2platform(arg0: str) -> Platform: ...
