from collections.abc import Callable, Sequence
import enum
import os
from typing import overload

from . import amdgpu as amdgpu, host as host


class BaseProgramParameters:
    pass

class CompletionEvent:
    def __init__(self) -> None: ...

    def __await__(self) -> object: ...

class Device:
    @property
    def name(self) -> str: ...

    @property
    def node_affinity(self) -> int: ...

    def __eq__(self, arg: Device, /) -> bool: ...

    def __repr__(self) -> str: ...

class DeviceAffinity:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: Device, /) -> None: ...

    def __eq__(self, arg: DeviceAffinity, /) -> bool: ...

    def add(self, arg: Device, /) -> bool: ...

    def __add__(self, arg: Device, /) -> bool: ...

    def __repr__(self) -> str: ...

class Fiber:
    def __repr__(self) -> str: ...

    @property
    def raw_devices(self) -> list[Device]: ...

    @overload
    def raw_device(self, arg: int, /) -> Device: ...

    @overload
    def raw_device(self, arg: str, /) -> Device: ...

    @property
    def devices(self) -> _ScopeDevicesSet: ...

    @property
    def devices_dict(self) -> dict: ...

    @property
    def device_names(self) -> list[str]: ...

    def device(self, *args) -> ScopedDevice: ...

class Future:
    def result(self) -> object: ...

    def __await__(self) -> object: ...

class Message:
    def __init__(self) -> None: ...

class MessageFuture(Future):
    def result(self) -> object: ...

NONE: ProgramIsolation = ProgramIsolation.NONE

class Node:
    @property
    def node_num(self) -> int: ...

    def __repr__(self) -> str: ...

PER_CALL: ProgramIsolation = ProgramIsolation.PER_CALL

PER_FIBER: ProgramIsolation = ProgramIsolation.PER_FIBER

class Process:
    def __init__(self, *, fiber: Fiber) -> None: ...

    @property
    def pid(self) -> int: ...

    @property
    def fiber(self) -> Fiber: ...

    @property
    def system(self) -> System: ...

    def launch(self) -> object: ...

    def __await__(self) -> object: ...

    def __repr__(self) -> str: ...

class Program:
    def __init__(self, modules: Sequence[ProgramModule], *, devices: Sequence[Device], trace_execution: bool = False, isolation: ProgramIsolation = ProgramIsolation.PER_FIBER) -> None: ...

    @property
    def exports(self) -> list[str]: ...

    @property
    def isolation(self) -> ProgramIsolation: ...

    def lookup_function(self, arg: str, /) -> ProgramFunction: ...

    def __getitem__(self, arg: str, /) -> ProgramFunction: ...

class ProgramFunction:
    @property
    def name(self) -> str: ...

    @property
    def calling_convention(self) -> str: ...

    def invocation(self, fiber: Fiber, isolation: ProgramIsolation | None = None) -> "shortfin::local::ProgramInvocation::Ptr":
        """
        Creates an invocation object targeting the function.

        This is a low-level interface for performing an invocation, and it should be
        used when precise, non-default control is needed.
        """

    @property
    def isolation(self) -> ProgramIsolation: ...

    def __call__(self, *args, fiber: Fiber, isolation: ProgramIsolation | None = None) -> ProgramInvocationFuture: ...

    def __repr__(self) -> str: ...

class ProgramInvocation:
    @property
    def assume_no_alias(self) -> bool:
        """Assumes that no results alias inputs or other buffers"""

    @assume_no_alias.setter
    def assume_no_alias(self, arg: bool, /) -> None: ...

    global_assume_no_alias: bool | None = ...
    """Globally changes the assume_no_alias flag for all invocations"""

    def invoke(self) -> ProgramInvocationFuture: ...

    def add_arg(self, arg: object, /) -> None: ...

    def __iter__(self) -> object: ...

    def __len__(self) -> int:
        """The number of results in this invocation"""

    def __getitem__(self, arg: int, /) -> object:
        """Gets the i'th result"""

    def __repr__(self) -> str: ...

class ProgramInvocationFuture(Future):
    def result(self) -> object: ...

class ProgramIsolation(enum.Enum):
    NONE = 0

    PER_FIBER = 1

    PER_CALL = 2

class ProgramModule:
    @property
    def exports(self) -> list[str]: ...

    def __repr__(self) -> str: ...

    @staticmethod
    def load(system: System, path: str | os.PathLike, mmap: bool = False) -> ProgramModule: ...

    @staticmethod
    def parameter_provider(system: System, *params) -> ProgramModule: ...

class Queue:
    def __repr__(self) -> str: ...

    def close(self) -> None: ...

    def writer(self) -> object: ...

    def reader(self) -> object: ...

    @property
    def closed(self) -> bool: ...

    def write_nodelay(self, arg: Message, /) -> None: ...

class QueueReader:
    def __call__(self) -> MessageFuture: ...

class QueueWriter:
    def __call__(self, arg: Message, /) -> CompletionEvent: ...

    def close(self) -> None: ...

class ScopedDevice:
    @property
    def fiber(self) -> Fiber: ...

    @property
    def affinity(self) -> DeviceAffinity: ...

    @property
    def raw_device(self) -> Device: ...

    def __eq__(self, arg: ScopedDevice, /) -> bool: ...

    def __await__(self) -> object: ...

    def __repr__(self) -> str: ...

class StaticProgramParameters(BaseProgramParameters):
    def __init__(self, system: System, parameter_scope: str, max_concurrent_operations: int = 16) -> None: ...

    def load(self, file_path: str | os.PathLike, format: str = '', readable: bool = True, writable: bool = False, mmap: bool = False) -> None: ...

class System:
    def __init__(self, *args, **kwargs) -> None:
        """
        Constructs a System based on system type and kwargs.

        System types depend on how the library was compiled and correspond to
        SystemBuilder classes. This API is a shorthand for creating a SystemBuilder
        and calling create_system() on it.
        """

    def __enter__(self) -> object: ...

    def __exit__(self, exc_type: object | None, exc_value: object | None, exc_tb: object | None) -> None: ...

    def shutdown(self) -> None: ...

    @property
    def device_names(self) -> list: ...

    @property
    def devices(self) -> list[Device]: ...

    def device(self, arg: str, /) -> Device: ...

    def create_queue(self, name: str | None = None) -> Queue: ...

    def named_queue(self, name: str) -> Queue: ...

    def create_fiber(self, worker: Worker | None = None, *, devices: object | None = None) -> Fiber: ...

    def create_worker(self, name: str) -> Worker: ...

    @property
    def init_worker(self) -> Worker: ...

    def run(self, coro: object) -> object: ...

    def load_module(self, path: str | os.PathLike, mmap: bool = False) -> ProgramModule: ...

class SystemBuilder:
    def __init__(*args, **kwargs) -> None: ...

    default_system_type: str | None = ...
    """(arg: object, /) -> str | None"""

    def create_system(self) -> object: ...

class VoidFuture(Future):
    def __init__(self) -> None: ...

    def set_success(self) -> None: ...

class Worker:
    @property
    def loop(self) -> object: ...

    def call_threadsafe(self, arg: Callable[[], None], /) -> None: ...

    def call(self, arg: object, /) -> None: ...

    def delay_call(self, arg0: int, arg1: object, /) -> None: ...

    def __repr__(self) -> str: ...
