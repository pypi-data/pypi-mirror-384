"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""


from io import BytesIO
import struct

class lcmt_drake_signal(object):
    """
    This LCM message contains a basic vector of doubles that can represent any
    signal passed around in Drake. Note that the channel name on which this
    message is sent will represent the name of the overall signal.
    """

    __slots__ = ["dim", "val", "coord", "timestamp"]

    __typenames__ = ["int32_t", "double", "string", "int64_t"]

    __dimensions__ = [None, ["dim"], ["dim"], None]

    def __init__(self):
        self.dim = 0
        """
        The number of elements in the signal.
        LCM Type: int32_t
        """

        self.val = []
        """
        The value of each element in the signal.
        LCM Type: double[dim]
        """

        self.coord = []
        """
        The name of each element in the signal.
        LCM Type: string[dim]
        """

        self.timestamp = 0
        """
        The timestamp in milliseconds.
        LCM Type: int64_t
        """


    def encode(self):
        buf = BytesIO()
        buf.write(lcmt_drake_signal._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">i", self.dim))
        buf.write(struct.pack('>%dd' % self.dim, *self.val[:self.dim]))
        for i0 in range(self.dim):
            __coord_encoded = self.coord[i0].encode('utf-8')
            buf.write(struct.pack('>I', len(__coord_encoded)+1))
            buf.write(__coord_encoded)
            buf.write(b"\0")
        buf.write(struct.pack(">q", self.timestamp))

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != lcmt_drake_signal._get_packed_fingerprint():
            raise ValueError("Decode error")
        return lcmt_drake_signal._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = lcmt_drake_signal()
        self.dim = struct.unpack(">i", buf.read(4))[0]
        self.val = struct.unpack('>%dd' % self.dim, buf.read(self.dim * 8))
        self.coord = []
        for i0 in range(self.dim):
            __coord_len = struct.unpack('>I', buf.read(4))[0]
            self.coord.append(buf.read(__coord_len)[:-1].decode('utf-8', 'replace'))
        self.timestamp = struct.unpack(">q", buf.read(8))[0]
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if lcmt_drake_signal in parents: return 0
        tmphash = (0x236e73ecd6fc3932) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff) + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if lcmt_drake_signal._packed_fingerprint is None:
            lcmt_drake_signal._packed_fingerprint = struct.pack(">Q", lcmt_drake_signal._get_hash_recursive([]))
        return lcmt_drake_signal._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", lcmt_drake_signal._get_packed_fingerprint())[0]

