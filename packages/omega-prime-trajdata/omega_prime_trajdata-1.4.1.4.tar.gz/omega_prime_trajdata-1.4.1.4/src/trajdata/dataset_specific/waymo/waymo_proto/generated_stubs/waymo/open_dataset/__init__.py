# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: waymo_open_dataset/protos/box.proto, waymo_open_dataset/protos/map.proto, waymo_open_dataset/protos/scenario.proto, waymo_open_dataset/protos/vector.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "BoundarySegment",
    "Box2D",
    "Box3D",
    "Crosswalk",
    "Driveway",
    "DynamicMapState",
    "DynamicState",
    "LaneCenter",
    "LaneCenterLaneType",
    "LaneNeighbor",
    "Map",
    "MapFeature",
    "MapPoint",
    "ObjectState",
    "RequiredPrediction",
    "RequiredPredictionDifficultyLevel",
    "RoadEdge",
    "RoadEdgeRoadEdgeType",
    "RoadLine",
    "RoadLineRoadLineType",
    "Scenario",
    "SpeedBump",
    "StopSign",
    "Track",
    "TrackObjectType",
    "TrafficSignalLaneState",
    "TrafficSignalLaneStateState",
    "Vector2D",
    "Vector3D",
)

from dataclasses import dataclass

import betterproto2

from google.protobuf.descriptor import Descriptor, EnumDescriptor

from ...google_proto_descriptor_pool import default_google_proto_descriptor_pool
from ...message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class LaneCenterLaneType(betterproto2.Enum):
    """
    Type of this lane.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return WAYMO_OPEN_DATASET_PROTOS_MAP_PROTO_DESCRIPTOR.enum_types_by_name[
            "LaneCenter.LaneType"
        ]

    TYPE_UNDEFINED = 0

    TYPE_FREEWAY = 1

    TYPE_SURFACE_STREET = 2

    TYPE_BIKE_LANE = 3


class RequiredPredictionDifficultyLevel(betterproto2.Enum):
    """
    A difficulty level for predicting a given track.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return WAYMO_OPEN_DATASET_PROTOS_SCENARIO_PROTO_DESCRIPTOR.enum_types_by_name[
            "RequiredPrediction.DifficultyLevel"
        ]

    NONE = 0

    LEVEL_1 = 1

    LEVEL_2 = 2


class RoadEdgeRoadEdgeType(betterproto2.Enum):
    """
    Type of this road edge.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return WAYMO_OPEN_DATASET_PROTOS_MAP_PROTO_DESCRIPTOR.enum_types_by_name[
            "RoadEdge.RoadEdgeType"
        ]

    TYPE_UNKNOWN = 0

    TYPE_ROAD_EDGE_BOUNDARY = 1
    """
    Physical road boundary that doesn't have traffic on the other side (e.g.,
    a curb or the k-rail on the right side of a freeway).
    """

    TYPE_ROAD_EDGE_MEDIAN = 2
    """
    Physical road boundary that separates the car from other traffic
    (e.g. a k-rail or an island).
    """


class RoadLineRoadLineType(betterproto2.Enum):
    """
    Type of this road line.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return WAYMO_OPEN_DATASET_PROTOS_MAP_PROTO_DESCRIPTOR.enum_types_by_name[
            "RoadLine.RoadLineType"
        ]

    TYPE_UNKNOWN = 0

    TYPE_BROKEN_SINGLE_WHITE = 1

    TYPE_SOLID_SINGLE_WHITE = 2

    TYPE_SOLID_DOUBLE_WHITE = 3

    TYPE_BROKEN_SINGLE_YELLOW = 4

    TYPE_BROKEN_DOUBLE_YELLOW = 5

    TYPE_SOLID_SINGLE_YELLOW = 6

    TYPE_SOLID_DOUBLE_YELLOW = 7

    TYPE_PASSING_DOUBLE_YELLOW = 8


class TrackObjectType(betterproto2.Enum):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return WAYMO_OPEN_DATASET_PROTOS_SCENARIO_PROTO_DESCRIPTOR.enum_types_by_name[
            "Track.ObjectType"
        ]

    TYPE_UNSET = 0
    """
    This is an invalid state that indicates an error.
    """

    TYPE_VEHICLE = 1

    TYPE_PEDESTRIAN = 2

    TYPE_CYCLIST = 3

    TYPE_OTHER = 4


class TrafficSignalLaneStateState(betterproto2.Enum):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return WAYMO_OPEN_DATASET_PROTOS_MAP_PROTO_DESCRIPTOR.enum_types_by_name[
            "TrafficSignalLaneState.State"
        ]

    LANE_STATE_UNKNOWN = 0

    LANE_STATE_ARROW_STOP = 1
    """
    States for traffic signals with arrows.
    """

    LANE_STATE_ARROW_CAUTION = 2

    LANE_STATE_ARROW_GO = 3

    LANE_STATE_STOP = 4
    """
    Standard round traffic signals.
    """

    LANE_STATE_CAUTION = 5

    LANE_STATE_GO = 6

    LANE_STATE_FLASHING_STOP = 7
    """
    Flashing light signals.
    """

    LANE_STATE_FLASHING_CAUTION = 8


@dataclass(eq=False, repr=False)
class BoundarySegment(betterproto2.Message):
    """
    A segment of a lane with a given adjacent boundary.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return WAYMO_OPEN_DATASET_PROTOS_MAP_PROTO_DESCRIPTOR.message_types_by_name[
            "BoundarySegment"
        ]

    lane_start_index: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)
    """
    The index into the lane's polyline where this lane boundary starts.
    """

    lane_end_index: "int" = betterproto2.field(2, betterproto2.TYPE_INT32)
    """
    The index into the lane's polyline where this lane boundary ends.
    """

    boundary_feature_id: "int" = betterproto2.field(3, betterproto2.TYPE_INT64)
    """
    The adjacent boundary feature ID of the MapFeature for the boundary. This
    can either be a RoadLine feature or a RoadEdge feature.
    """

    boundary_type: "RoadLineRoadLineType" = betterproto2.field(
        4, betterproto2.TYPE_ENUM, default_factory=lambda: RoadLineRoadLineType(0)
    )
    """
    The adjacent boundary type. If the boundary is a road edge instead of a
    road line, this will be set to TYPE_UNKNOWN.
    """


default_message_pool.register_message(
    "waymo.open_dataset", "BoundarySegment", BoundarySegment
)


@dataclass(eq=False, repr=False)
class Box2D(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return WAYMO_OPEN_DATASET_PROTOS_BOX_PROTO_DESCRIPTOR.message_types_by_name[
            "Box2d"
        ]

    center: "Vector2D | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Box coordinates in image frame.
    """

    size: "Vector2D | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Dimensions of the box. length: dim x. width: dim y.
    """

    heading: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    The heading of the bounding box (in radians).  The heading is the angle
    required to rotate +x to the surface normal of the box front face. It is
    normalized to [-pi, pi).
    """


default_message_pool.register_message("waymo.open_dataset", "Box2d", Box2D)


@dataclass(eq=False, repr=False)
class Box3D(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return WAYMO_OPEN_DATASET_PROTOS_BOX_PROTO_DESCRIPTOR.message_types_by_name[
            "Box3d"
        ]

    center: "Vector3D | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Box coordinates in image frame.
    """

    size: "Vector3D | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Dimensions of the box. length: dim x. width: dim y.
    """

    heading: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    The heading of the bounding box (in radians).  The heading is the angle
    required to rotate +x to the surface normal of the box front face. It is
    normalized to [-pi, pi).
    """


default_message_pool.register_message("waymo.open_dataset", "Box3d", Box3D)


@dataclass(eq=False, repr=False)
class Crosswalk(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return WAYMO_OPEN_DATASET_PROTOS_MAP_PROTO_DESCRIPTOR.message_types_by_name[
            "Crosswalk"
        ]

    polygon: "list[MapPoint]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The polygon defining the outline of the crosswalk. The polygon is assumed
    to be closed (i.e. a segment exists between the last point and the first
    point).
    """


default_message_pool.register_message("waymo.open_dataset", "Crosswalk", Crosswalk)


@dataclass(eq=False, repr=False)
class Driveway(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return WAYMO_OPEN_DATASET_PROTOS_MAP_PROTO_DESCRIPTOR.message_types_by_name[
            "Driveway"
        ]

    polygon: "list[MapPoint]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The polygon defining the outline of the driveway region. The polygon is
    assumed to be closed (i.e. a segment exists between the last point and the
    first point).
    """


default_message_pool.register_message("waymo.open_dataset", "Driveway", Driveway)


@dataclass(eq=False, repr=False)
class DynamicMapState(betterproto2.Message):
    """
    The dynamic map information at a single time step.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return (
            WAYMO_OPEN_DATASET_PROTOS_SCENARIO_PROTO_DESCRIPTOR.message_types_by_name[
                "DynamicMapState"
            ]
        )

    lane_states: "list[TrafficSignalLaneState]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The traffic signal states for all observed signals at this time step.
    """


default_message_pool.register_message(
    "waymo.open_dataset", "DynamicMapState", DynamicMapState
)


@dataclass(eq=False, repr=False)
class DynamicState(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return WAYMO_OPEN_DATASET_PROTOS_MAP_PROTO_DESCRIPTOR.message_types_by_name[
            "DynamicState"
        ]

    timestamp_seconds: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    The timestamp associated with the dynamic feature data.
    """

    lane_states: "list[TrafficSignalLaneState]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The set of traffic signal states for the associated time step.
    """


default_message_pool.register_message(
    "waymo.open_dataset", "DynamicState", DynamicState
)


@dataclass(eq=False, repr=False)
class LaneCenter(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return WAYMO_OPEN_DATASET_PROTOS_MAP_PROTO_DESCRIPTOR.message_types_by_name[
            "LaneCenter"
        ]

    speed_limit_mph: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    The speed limit for this lane.
    """

    type: "LaneCenterLaneType" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: LaneCenterLaneType(0)
    )

    interpolating: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)
    """
    True if the lane interpolates between two other lanes.
    """

    polyline: "list[MapPoint]" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The polyline data for the lane. A polyline is a list of points with
    segments defined between consecutive points.
    """

    entry_lanes: "list[int]" = betterproto2.field(
        9, betterproto2.TYPE_INT64, repeated=True
    )
    """
    A list of IDs for lanes that this lane may be entered from.
    """

    exit_lanes: "list[int]" = betterproto2.field(
        10, betterproto2.TYPE_INT64, repeated=True
    )
    """
    A list of IDs for lanes that this lane may exit to.
    """

    left_boundaries: "list[BoundarySegment]" = betterproto2.field(
        13, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The boundaries to the left of this lane. There may be different boundary
    types along this lane. Each BoundarySegment defines a section of the lane
    with a given boundary feature to the left. Note that some lanes do not have
    any boundaries (i.e. lane centers in intersections).
    """

    right_boundaries: "list[BoundarySegment]" = betterproto2.field(
        14, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The boundaries to the right of this lane. See left_boundaries for details.
    """

    left_neighbors: "list[LaneNeighbor]" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of neighbors to the left of this lane. Neighbor lanes
    include only adjacent lanes going the same direction.
    """

    right_neighbors: "list[LaneNeighbor]" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of neighbors to the right of this lane. Neighbor lanes
    include only adjacent lanes going the same direction.
    """


default_message_pool.register_message("waymo.open_dataset", "LaneCenter", LaneCenter)


@dataclass(eq=False, repr=False)
class LaneNeighbor(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return WAYMO_OPEN_DATASET_PROTOS_MAP_PROTO_DESCRIPTOR.message_types_by_name[
            "LaneNeighbor"
        ]

    feature_id: "int" = betterproto2.field(1, betterproto2.TYPE_INT64)
    """
    The feature ID of the neighbor lane.
    """

    self_start_index: "int" = betterproto2.field(2, betterproto2.TYPE_INT32)
    """
    The self adjacency segment.
    The other lane may only be a neighbor for only part of this lane. These
    indices define the points within this lane's polyline for which feature_id
    is a neighbor. If the lanes are neighbors at disjoint places (e.g., a
    median between them appears and then goes away) multiple neighbors will be
    listed. A lane change can only happen from this segment of this lane into
    the segment of the neighbor lane defined by neighbor_start_index and
    neighbor_end_index.
    """

    self_end_index: "int" = betterproto2.field(3, betterproto2.TYPE_INT32)

    neighbor_start_index: "int" = betterproto2.field(4, betterproto2.TYPE_INT32)
    """
    The neighbor adjacency segment.
    These indices define the valid portion of the neighbor lane's polyline
    where that lane is a neighbor to this lane. A lane change can only happen
    into this segment of the neighbor lane from the segment of this lane
    defined by self_start_index and self_end_index.
    """

    neighbor_end_index: "int" = betterproto2.field(5, betterproto2.TYPE_INT32)

    boundaries: "list[BoundarySegment]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of segments within the self adjacency segment that have different
    boundaries between this lane and the neighbor lane. Each entry in this
    field contains the boundary type between this lane and the neighbor lane
    along with the indices into this lane's polyline where the boundary type
    begins and ends.
    """


default_message_pool.register_message(
    "waymo.open_dataset", "LaneNeighbor", LaneNeighbor
)


@dataclass(eq=False, repr=False)
class Map(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return WAYMO_OPEN_DATASET_PROTOS_MAP_PROTO_DESCRIPTOR.message_types_by_name[
            "Map"
        ]

    map_features: "list[MapFeature]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The full set of map features.
    """

    dynamic_states: "list[DynamicState]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A set of dynamic states per time step. These are ordered in consecutive
    time steps.
    """


default_message_pool.register_message("waymo.open_dataset", "Map", Map)


@dataclass(eq=False, repr=False)
class MapFeature(betterproto2.Message):
    """


    Oneofs:
        - feature_data: Type specific data.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return WAYMO_OPEN_DATASET_PROTOS_MAP_PROTO_DESCRIPTOR.message_types_by_name[
            "MapFeature"
        ]

    id: "int" = betterproto2.field(1, betterproto2.TYPE_INT64)
    """
    A unique ID to identify this feature.
    """

    lane: "LaneCenter | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="feature_data"
    )

    road_line: "RoadLine | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="feature_data"
    )

    road_edge: "RoadEdge | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="feature_data"
    )

    stop_sign: "StopSign | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True, group="feature_data"
    )

    crosswalk: "Crosswalk | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="feature_data"
    )

    speed_bump: "SpeedBump | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True, group="feature_data"
    )

    driveway: "Driveway | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True, group="feature_data"
    )


default_message_pool.register_message("waymo.open_dataset", "MapFeature", MapFeature)


@dataclass(eq=False, repr=False)
class MapPoint(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return WAYMO_OPEN_DATASET_PROTOS_MAP_PROTO_DESCRIPTOR.message_types_by_name[
            "MapPoint"
        ]

    x: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Position in meters. The origin is an arbitrary location.
    """

    y: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)

    z: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)


default_message_pool.register_message("waymo.open_dataset", "MapPoint", MapPoint)


@dataclass(eq=False, repr=False)
class ObjectState(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return (
            WAYMO_OPEN_DATASET_PROTOS_SCENARIO_PROTO_DESCRIPTOR.message_types_by_name[
                "ObjectState"
            ]
        )

    center_x: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Coordinates of the center of the object bounding box.
    """

    center_y: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)

    center_z: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)

    length: "float" = betterproto2.field(5, betterproto2.TYPE_FLOAT)
    """
    The dimensions of the bounding box in meters.
    """

    width: "float" = betterproto2.field(6, betterproto2.TYPE_FLOAT)

    height: "float" = betterproto2.field(7, betterproto2.TYPE_FLOAT)

    heading: "float" = betterproto2.field(8, betterproto2.TYPE_FLOAT)
    """
    The yaw angle in radians of the forward direction of the bounding box (the
    vector from the center of the box to the middle of the front box segment)
    counter clockwise from the X-axis (right hand system about the Z axis).
    This angle is normalized to [-pi, pi).
    """

    velocity_x: "float" = betterproto2.field(9, betterproto2.TYPE_FLOAT)
    """
    The velocity vector in m/s. This vector direction may be slightly different
    from the heading of the bounding box.
    """

    velocity_y: "float" = betterproto2.field(10, betterproto2.TYPE_FLOAT)

    valid: "bool" = betterproto2.field(11, betterproto2.TYPE_BOOL)
    """
    False if the state data is invalid or missing.
    """


default_message_pool.register_message("waymo.open_dataset", "ObjectState", ObjectState)


@dataclass(eq=False, repr=False)
class RequiredPrediction(betterproto2.Message):
    """
    An object that must be predicted for the scenario.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return (
            WAYMO_OPEN_DATASET_PROTOS_SCENARIO_PROTO_DESCRIPTOR.message_types_by_name[
                "RequiredPrediction"
            ]
        )

    track_index: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)
    """
    An index into the Scenario `tracks` field for the object to be predicted.
    """

    difficulty: "RequiredPredictionDifficultyLevel" = betterproto2.field(
        2,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: RequiredPredictionDifficultyLevel(0),
    )
    """
    The difficulty level for this object.
    """


default_message_pool.register_message(
    "waymo.open_dataset", "RequiredPrediction", RequiredPrediction
)


@dataclass(eq=False, repr=False)
class RoadEdge(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return WAYMO_OPEN_DATASET_PROTOS_MAP_PROTO_DESCRIPTOR.message_types_by_name[
            "RoadEdge"
        ]

    type: "RoadEdgeRoadEdgeType" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: RoadEdgeRoadEdgeType(0)
    )
    """
    The type of road edge.
    """

    polyline: "list[MapPoint]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The polyline defining the road edge. A polyline is a list of points with
    segments defined between consecutive points.
    """


default_message_pool.register_message("waymo.open_dataset", "RoadEdge", RoadEdge)


@dataclass(eq=False, repr=False)
class RoadLine(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return WAYMO_OPEN_DATASET_PROTOS_MAP_PROTO_DESCRIPTOR.message_types_by_name[
            "RoadLine"
        ]

    type: "RoadLineRoadLineType" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: RoadLineRoadLineType(0)
    )
    """
    The type of the lane boundary.
    """

    polyline: "list[MapPoint]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The polyline defining the road edge. A polyline is a list of points with
    segments defined between consecutive points.
    """


default_message_pool.register_message("waymo.open_dataset", "RoadLine", RoadLine)


@dataclass(eq=False, repr=False)
class Scenario(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return (
            WAYMO_OPEN_DATASET_PROTOS_SCENARIO_PROTO_DESCRIPTOR.message_types_by_name[
                "Scenario"
            ]
        )

    scenario_id: "str" = betterproto2.field(5, betterproto2.TYPE_STRING)
    """
    The unique ID for this scenario.
    """

    timestamps_seconds: "list[float]" = betterproto2.field(
        1, betterproto2.TYPE_DOUBLE, repeated=True
    )
    """
    Timestamps corresponding to the track states for each step in the scenario.
    The length of this field is equal to tracks[i].states_size() for all tracks
    i and equal to the length of the dynamic_map_states_field.
    """

    current_time_index: "int" = betterproto2.field(10, betterproto2.TYPE_INT32)
    """
    The index into timestamps_seconds for the current time. All time steps
    after this index are future data to be predicted. All steps before this
    index are history data.
    """

    tracks: "list[Track]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Tracks for all objects in the scenario. All object tracks in all scenarios
    in the dataset have the same number of object states. In this way, the
    tracks field forms a 2 dimensional grid with objects on one axis and time
    on the other. Each state can be associated with a timestamp in the
    'timestamps_seconds' field by its index. E.g., tracks[i].states[j] indexes
    the i^th agent's state at time timestamps_seconds[j].
    """

    dynamic_map_states: "list[DynamicMapState]" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The dynamic map states in the scenario (e.g. traffic signal states).
    This field has the same length as timestamps_seconds. Each entry in this
    field can be associated with a timestamp in the 'timestamps_seconds' field
    by its index. E.g., dynamic_map_states[i] indexes the dynamic map state at
    time timestamps_seconds[i].
    """

    map_features: "list[MapFeature]" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The set of static map features for the scenario.
    """

    sdc_track_index: "int" = betterproto2.field(6, betterproto2.TYPE_INT32)
    """
    The index into the tracks field of the autonomous vehicle object.
    """

    objects_of_interest: "list[int]" = betterproto2.field(
        4, betterproto2.TYPE_INT32, repeated=True
    )
    """
    A list of objects IDs in the scene detected to have interactive behavior.
    The objects in this list form an interactive group. These IDs correspond
    to IDs in the tracks field above.
    """

    tracks_to_predict: "list[RequiredPrediction]" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of tracks to generate predictions for. For the challenges, exactly
    these objects must be predicted in each scenario for test and validation
    submissions. This field is populated in the training set only as a
    suggestion of objects to train on.
    """


default_message_pool.register_message("waymo.open_dataset", "Scenario", Scenario)


@dataclass(eq=False, repr=False)
class SpeedBump(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return WAYMO_OPEN_DATASET_PROTOS_MAP_PROTO_DESCRIPTOR.message_types_by_name[
            "SpeedBump"
        ]

    polygon: "list[MapPoint]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The polygon defining the outline of the speed bump. The polygon is assumed
    to be closed (i.e. a segment exists between the last point and the first
    point).
    """


default_message_pool.register_message("waymo.open_dataset", "SpeedBump", SpeedBump)


@dataclass(eq=False, repr=False)
class StopSign(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return WAYMO_OPEN_DATASET_PROTOS_MAP_PROTO_DESCRIPTOR.message_types_by_name[
            "StopSign"
        ]

    lane: "list[int]" = betterproto2.field(1, betterproto2.TYPE_INT64, repeated=True)
    """
    The IDs of lane features controlled by this stop sign.
    """

    position: "MapPoint | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The position of the stop sign.
    """


default_message_pool.register_message("waymo.open_dataset", "StopSign", StopSign)


@dataclass(eq=False, repr=False)
class Track(betterproto2.Message):
    """
    The object states for a single object through the scenario.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return (
            WAYMO_OPEN_DATASET_PROTOS_SCENARIO_PROTO_DESCRIPTOR.message_types_by_name[
                "Track"
            ]
        )

    id: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)
    """
    The unique ID of the object being tracked. The IDs start from zero and are
    non-negative.
    """

    object_type: "TrackObjectType" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: TrackObjectType(0)
    )
    """
    The type of object being tracked.
    """

    states: "list[ObjectState]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The object states through the track. States include the 3D bounding boxes
    and velocities.
    """


default_message_pool.register_message("waymo.open_dataset", "Track", Track)


@dataclass(eq=False, repr=False)
class TrafficSignalLaneState(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return WAYMO_OPEN_DATASET_PROTOS_MAP_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficSignalLaneState"
        ]

    lane: "int" = betterproto2.field(1, betterproto2.TYPE_INT64)
    """
    The ID for the MapFeature corresponding to the lane controlled by this
    traffic signal state.
    """

    state: "TrafficSignalLaneStateState" = betterproto2.field(
        2,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: TrafficSignalLaneStateState(0),
    )
    """
    The state of the traffic signal.
    """

    stop_point: "MapPoint | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The stopping point along the lane controlled by the traffic signal.
    This is the point where dynamic objects must stop when the signal is in a
    stop state.
    """


default_message_pool.register_message(
    "waymo.open_dataset", "TrafficSignalLaneState", TrafficSignalLaneState
)


@dataclass(eq=False, repr=False)
class Vector2D(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return WAYMO_OPEN_DATASET_PROTOS_VECTOR_PROTO_DESCRIPTOR.message_types_by_name[
            "Vector2d"
        ]

    x: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)

    y: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)


default_message_pool.register_message("waymo.open_dataset", "Vector2d", Vector2D)


@dataclass(eq=False, repr=False)
class Vector3D(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return WAYMO_OPEN_DATASET_PROTOS_VECTOR_PROTO_DESCRIPTOR.message_types_by_name[
            "Vector3d"
        ]

    x: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)

    y: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)

    z: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)


default_message_pool.register_message("waymo.open_dataset", "Vector3d", Vector3D)


WAYMO_OPEN_DATASET_PROTOS_MAP_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n#waymo_open_dataset/protos/map.proto\x12\x12waymo.open_dataset"\x91\x01\n\x03Map\x12A\n\x0cmap_features\x18\x01 \x03(\x0b2\x1e.waymo.open_dataset.MapFeatureR\x0bmapFeatures\x12G\n\x0edynamic_states\x18\x02 \x03(\x0b2 .waymo.open_dataset.DynamicStateR\rdynamicStates"\x88\x01\n\x0cDynamicState\x12+\n\x11timestamp_seconds\x18\x01 \x01(\x01R\x10timestampSeconds\x12K\n\x0blane_states\x18\x02 \x03(\x0b2*.waymo.open_dataset.TrafficSignalLaneStateR\nlaneStates"\xa2\x03\n\x16TrafficSignalLaneState\x12\x12\n\x04lane\x18\x01 \x01(\x03R\x04lane\x12F\n\x05state\x18\x02 \x01(\x0e20.waymo.open_dataset.TrafficSignalLaneState.StateR\x05state\x12;\n\nstop_point\x18\x03 \x01(\x0b2\x1c.waymo.open_dataset.MapPointR\tstopPoint"\xee\x01\n\x05State\x12\x14\n\x12LANE_STATE_UNKNOWN\x12\x19\n\x15LANE_STATE_ARROW_STOP\x10\x01\x12\x1c\n\x18LANE_STATE_ARROW_CAUTION\x10\x02\x12\x17\n\x13LANE_STATE_ARROW_GO\x10\x03\x12\x13\n\x0fLANE_STATE_STOP\x10\x04\x12\x16\n\x12LANE_STATE_CAUTION\x10\x05\x12\x11\n\rLANE_STATE_GO\x10\x06\x12\x1c\n\x18LANE_STATE_FLASHING_STOP\x10\x07\x12\x1f\n\x1bLANE_STATE_FLASHING_CAUTION\x10\x08"\xd4\x03\n\nMapFeature\x12\x0e\n\x02id\x18\x01 \x01(\x03R\x02id\x124\n\x04lane\x18\x03 \x01(\x0b2\x1e.waymo.open_dataset.LaneCenterH\x00R\x04lane\x12;\n\troad_line\x18\x04 \x01(\x0b2\x1c.waymo.open_dataset.RoadLineH\x00R\x08roadLine\x12;\n\troad_edge\x18\x05 \x01(\x0b2\x1c.waymo.open_dataset.RoadEdgeH\x00R\x08roadEdge\x12;\n\tstop_sign\x18\x07 \x01(\x0b2\x1c.waymo.open_dataset.StopSignH\x00R\x08stopSign\x12=\n\tcrosswalk\x18\x08 \x01(\x0b2\x1d.waymo.open_dataset.CrosswalkH\x00R\tcrosswalk\x12>\n\nspeed_bump\x18\t \x01(\x0b2\x1d.waymo.open_dataset.SpeedBumpH\x00R\tspeedBump\x12:\n\x08driveway\x18\n \x01(\x0b2\x1c.waymo.open_dataset.DrivewayH\x00R\x08drivewayB\x0e\n\x0cfeature_data"4\n\x08MapPoint\x12\x0c\n\x01x\x18\x01 \x01(\x01R\x01x\x12\x0c\n\x01y\x18\x02 \x01(\x01R\x01y\x12\x0c\n\x01z\x18\x03 \x01(\x01R\x01z"\xe1\x01\n\x0fBoundarySegment\x12(\n\x10lane_start_index\x18\x01 \x01(\x05R\x0elaneStartIndex\x12$\n\x0elane_end_index\x18\x02 \x01(\x05R\x0claneEndIndex\x12.\n\x13boundary_feature_id\x18\x03 \x01(\x03R\x11boundaryFeatureId\x12N\n\rboundary_type\x18\x04 \x01(\x0e2).waymo.open_dataset.RoadLine.RoadLineTypeR\x0cboundaryType"\xa2\x02\n\x0cLaneNeighbor\x12\x1d\n\nfeature_id\x18\x01 \x01(\x03R\tfeatureId\x12(\n\x10self_start_index\x18\x02 \x01(\x05R\x0eselfStartIndex\x12$\n\x0eself_end_index\x18\x03 \x01(\x05R\x0cselfEndIndex\x120\n\x14neighbor_start_index\x18\x04 \x01(\x05R\x12neighborStartIndex\x12,\n\x12neighbor_end_index\x18\x05 \x01(\x05R\x10neighborEndIndex\x12C\n\nboundaries\x18\x06 \x03(\x0b2#.waymo.open_dataset.BoundarySegmentR\nboundaries"\xa8\x05\n\nLaneCenter\x12&\n\x0fspeed_limit_mph\x18\x01 \x01(\x01R\rspeedLimitMph\x12;\n\x04type\x18\x02 \x01(\x0e2\'.waymo.open_dataset.LaneCenter.LaneTypeR\x04type\x12$\n\rinterpolating\x18\x03 \x01(\x08R\rinterpolating\x128\n\x08polyline\x18\x08 \x03(\x0b2\x1c.waymo.open_dataset.MapPointR\x08polyline\x12#\n\x0bentry_lanes\x18\t \x03(\x03R\nentryLanesB\x02\x10\x01\x12!\n\nexit_lanes\x18\n \x03(\x03R\texitLanesB\x02\x10\x01\x12L\n\x0fleft_boundaries\x18\r \x03(\x0b2#.waymo.open_dataset.BoundarySegmentR\x0eleftBoundaries\x12N\n\x10right_boundaries\x18\x0e \x03(\x0b2#.waymo.open_dataset.BoundarySegmentR\x0frightBoundaries\x12G\n\x0eleft_neighbors\x18\x0b \x03(\x0b2 .waymo.open_dataset.LaneNeighborR\rleftNeighbors\x12I\n\x0fright_neighbors\x18\x0c \x03(\x0b2 .waymo.open_dataset.LaneNeighborR\x0erightNeighbors"[\n\x08LaneType\x12\x10\n\x0eTYPE_UNDEFINED\x12\x10\n\x0cTYPE_FREEWAY\x10\x01\x12\x17\n\x13TYPE_SURFACE_STREET\x10\x02\x12\x12\n\x0eTYPE_BIKE_LANE\x10\x03"\xdb\x01\n\x08RoadEdge\x12=\n\x04type\x18\x01 \x01(\x0e2).waymo.open_dataset.RoadEdge.RoadEdgeTypeR\x04type\x128\n\x08polyline\x18\x02 \x03(\x0b2\x1c.waymo.open_dataset.MapPointR\x08polyline"V\n\x0cRoadEdgeType\x12\x0e\n\x0cTYPE_UNKNOWN\x12\x1b\n\x17TYPE_ROAD_EDGE_BOUNDARY\x10\x01\x12\x19\n\x15TYPE_ROAD_EDGE_MEDIAN\x10\x02"\x96\x03\n\x08RoadLine\x12=\n\x04type\x18\x01 \x01(\x0e2).waymo.open_dataset.RoadLine.RoadLineTypeR\x04type\x128\n\x08polyline\x18\x02 \x03(\x0b2\x1c.waymo.open_dataset.MapPointR\x08polyline"\x90\x02\n\x0cRoadLineType\x12\x0e\n\x0cTYPE_UNKNOWN\x12\x1c\n\x18TYPE_BROKEN_SINGLE_WHITE\x10\x01\x12\x1b\n\x17TYPE_SOLID_SINGLE_WHITE\x10\x02\x12\x1b\n\x17TYPE_SOLID_DOUBLE_WHITE\x10\x03\x12\x1d\n\x19TYPE_BROKEN_SINGLE_YELLOW\x10\x04\x12\x1d\n\x19TYPE_BROKEN_DOUBLE_YELLOW\x10\x05\x12\x1c\n\x18TYPE_SOLID_SINGLE_YELLOW\x10\x06\x12\x1c\n\x18TYPE_SOLID_DOUBLE_YELLOW\x10\x07\x12\x1e\n\x1aTYPE_PASSING_DOUBLE_YELLOW\x10\x08"X\n\x08StopSign\x12\x12\n\x04lane\x18\x01 \x03(\x03R\x04lane\x128\n\x08position\x18\x02 \x01(\x0b2\x1c.waymo.open_dataset.MapPointR\x08position"C\n\tCrosswalk\x126\n\x07polygon\x18\x01 \x03(\x0b2\x1c.waymo.open_dataset.MapPointR\x07polygon"C\n\tSpeedBump\x126\n\x07polygon\x18\x01 \x03(\x0b2\x1c.waymo.open_dataset.MapPointR\x07polygon"B\n\x08Driveway\x126\n\x07polygon\x18\x01 \x03(\x0b2\x1c.waymo.open_dataset.MapPointR\x07polygon'
)
WAYMO_OPEN_DATASET_PROTOS_SCENARIO_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n(waymo_open_dataset/protos/scenario.proto\x12\x12waymo.open_dataset\x1a#waymo_open_dataset/protos/map.proto"\x92\x02\n\x0bObjectState\x12\x19\n\x08center_x\x18\x02 \x01(\x01R\x07centerX\x12\x19\n\x08center_y\x18\x03 \x01(\x01R\x07centerY\x12\x19\n\x08center_z\x18\x04 \x01(\x01R\x07centerZ\x12\x16\n\x06length\x18\x05 \x01(\x02R\x06length\x12\x14\n\x05width\x18\x06 \x01(\x02R\x05width\x12\x16\n\x06height\x18\x07 \x01(\x02R\x06height\x12\x18\n\x07heading\x18\x08 \x01(\x02R\x07heading\x12\x1d\n\nvelocity_x\x18\t \x01(\x02R\tvelocityX\x12\x1d\n\nvelocity_y\x18\n \x01(\x02R\tvelocityY\x12\x14\n\x05valid\x18\x0b \x01(\x08R\x05valid"\xfc\x01\n\x05Track\x12\x0e\n\x02id\x18\x01 \x01(\x05R\x02id\x12E\n\x0bobject_type\x18\x02 \x01(\x0e2$.waymo.open_dataset.Track.ObjectTypeR\nobjectType\x127\n\x06states\x18\x03 \x03(\x0b2\x1f.waymo.open_dataset.ObjectStateR\x06states"c\n\nObjectType\x12\x0c\n\nTYPE_UNSET\x12\x10\n\x0cTYPE_VEHICLE\x10\x01\x12\x13\n\x0fTYPE_PEDESTRIAN\x10\x02\x12\x10\n\x0cTYPE_CYCLIST\x10\x03\x12\x0e\n\nTYPE_OTHER\x10\x04"^\n\x0fDynamicMapState\x12K\n\x0blane_states\x18\x01 \x03(\x0b2*.waymo.open_dataset.TrafficSignalLaneStateR\nlaneStates"\xc2\x01\n\x12RequiredPrediction\x12\x1f\n\x0btrack_index\x18\x01 \x01(\x05R\ntrackIndex\x12V\n\ndifficulty\x18\x02 \x01(\x0e26.waymo.open_dataset.RequiredPrediction.DifficultyLevelR\ndifficulty"3\n\x0fDifficultyLevel\x12\x06\n\x04NONE\x12\x0b\n\x07LEVEL_1\x10\x01\x12\x0b\n\x07LEVEL_2\x10\x02"\x83\x04\n\x08Scenario\x12\x1f\n\x0bscenario_id\x18\x05 \x01(\tR\nscenarioId\x12-\n\x12timestamps_seconds\x18\x01 \x03(\x01R\x11timestampsSeconds\x12,\n\x12current_time_index\x18\n \x01(\x05R\x10currentTimeIndex\x121\n\x06tracks\x18\x02 \x03(\x0b2\x19.waymo.open_dataset.TrackR\x06tracks\x12Q\n\x12dynamic_map_states\x18\x07 \x03(\x0b2#.waymo.open_dataset.DynamicMapStateR\x10dynamicMapStates\x12A\n\x0cmap_features\x18\x08 \x03(\x0b2\x1e.waymo.open_dataset.MapFeatureR\x0bmapFeatures\x12&\n\x0fsdc_track_index\x18\x06 \x01(\x05R\rsdcTrackIndex\x12.\n\x13objects_of_interest\x18\x04 \x03(\x05R\x11objectsOfInterest\x12R\n\x11tracks_to_predict\x18\x0b \x03(\x0b2&.waymo.open_dataset.RequiredPredictionR\x0ftracksToPredictJ\x04\x08\t\x10\n'
)
WAYMO_OPEN_DATASET_PROTOS_VECTOR_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n&waymo_open_dataset/protos/vector.proto\x12\x12waymo.open_dataset"&\n\x08Vector2d\x12\x0c\n\x01x\x18\x01 \x01(\x01R\x01x\x12\x0c\n\x01y\x18\x02 \x01(\x01R\x01y"4\n\x08Vector3d\x12\x0c\n\x01x\x18\x01 \x01(\x01R\x01x\x12\x0c\n\x01y\x18\x02 \x01(\x01R\x01y\x12\x0c\n\x01z\x18\x03 \x01(\x01R\x01z'
)
WAYMO_OPEN_DATASET_PROTOS_BOX_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n#waymo_open_dataset/protos/box.proto\x12\x12waymo.open_dataset\x1a&waymo_open_dataset/protos/vector.proto"\x89\x01\n\x05Box2d\x124\n\x06center\x18\x01 \x01(\x0b2\x1c.waymo.open_dataset.Vector2dR\x06center\x120\n\x04size\x18\x02 \x01(\x0b2\x1c.waymo.open_dataset.Vector2dR\x04size\x12\x18\n\x07heading\x18\x03 \x01(\x01R\x07heading"\x89\x01\n\x05Box3d\x124\n\x06center\x18\x01 \x01(\x0b2\x1c.waymo.open_dataset.Vector3dR\x06center\x120\n\x04size\x18\x02 \x01(\x0b2\x1c.waymo.open_dataset.Vector3dR\x04size\x12\x18\n\x07heading\x18\x03 \x01(\x01R\x07heading'
)
