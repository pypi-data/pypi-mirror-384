# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: vectorized_map.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "MapElement",
    "PedCrosswalk",
    "PedWalkway",
    "Point",
    "Polyline",
    "RoadArea",
    "RoadLane",
    "VectorizedMap",
)

from dataclasses import dataclass

import betterproto2

from google.protobuf.descriptor import Descriptor

from ..google_proto_descriptor_pool import default_google_proto_descriptor_pool
from ..message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False)
class MapElement(betterproto2.Message):
    """


    Oneofs:
        - element_data: Type specific data.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return VECTORIZED_MAP_PROTO_DESCRIPTOR.message_types_by_name["MapElement"]

    id: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)
    """
    A unique ID to identify this element.
    """

    road_lane: "RoadLane | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="element_data"
    )

    road_area: "RoadArea | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="element_data"
    )

    ped_crosswalk: "PedCrosswalk | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="element_data"
    )

    ped_walkway: "PedWalkway | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="element_data"
    )


default_message_pool.register_message("trajdata", "MapElement", MapElement)


@dataclass(eq=False, repr=False)
class PedCrosswalk(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return VECTORIZED_MAP_PROTO_DESCRIPTOR.message_types_by_name["PedCrosswalk"]

    polygon: "Polyline | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The polygon defining the outline of the crosswalk. The polygon is assumed
    to be closed (i.e. a segment exists between the last point and the first
    point).
    """


default_message_pool.register_message("trajdata", "PedCrosswalk", PedCrosswalk)


@dataclass(eq=False, repr=False)
class PedWalkway(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return VECTORIZED_MAP_PROTO_DESCRIPTOR.message_types_by_name["PedWalkway"]

    polygon: "Polyline | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The polygon defining the outline of the pedestrian walkway (e.g., sidewalk).
    The polygon is assumed to be closed (i.e. a segment exists between the last
    point and the first point).
    """


default_message_pool.register_message("trajdata", "PedWalkway", PedWalkway)


@dataclass(eq=False, repr=False)
class Point(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return VECTORIZED_MAP_PROTO_DESCRIPTOR.message_types_by_name["Point"]

    x: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)

    y: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)

    z: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)


default_message_pool.register_message("trajdata", "Point", Point)


@dataclass(eq=False, repr=False)
class Polyline(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return VECTORIZED_MAP_PROTO_DESCRIPTOR.message_types_by_name["Polyline"]

    dx_mm: "list[int]" = betterproto2.field(1, betterproto2.TYPE_SINT32, repeated=True)
    """
    Position deltas in millimeters. The origin is an arbitrary location.
    From https://github.com/woven-planet/l5kit/blob/master/l5kit/l5kit/data/proto/road_network.proto#L446
    The delta for the first point is just its coordinates tuple, i.e. it is a "delta" from
    the origin. For subsequent points, this field stores the difference between the point's
    coordinates and the previous point's coordinates. This is for representation efficiency.
    """

    dy_mm: "list[int]" = betterproto2.field(2, betterproto2.TYPE_SINT32, repeated=True)

    dz_mm: "list[int]" = betterproto2.field(3, betterproto2.TYPE_SINT32, repeated=True)

    h_rad: "list[float]" = betterproto2.field(
        4, betterproto2.TYPE_DOUBLE, repeated=True
    )


default_message_pool.register_message("trajdata", "Polyline", Polyline)


@dataclass(eq=False, repr=False)
class RoadArea(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return VECTORIZED_MAP_PROTO_DESCRIPTOR.message_types_by_name["RoadArea"]

    exterior_polygon: "Polyline | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The polygon defining the outline of general driveable area. This acts as a 
    catch-all when there's a road segment without lane information.
    For example, intersections in nuScenes are not "lanes".
    """

    interior_holes: "list[Polyline]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The area within these polygons is NOT included.
    """


default_message_pool.register_message("trajdata", "RoadArea", RoadArea)


@dataclass(eq=False, repr=False)
class RoadLane(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return VECTORIZED_MAP_PROTO_DESCRIPTOR.message_types_by_name["RoadLane"]

    center: "Polyline | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The polyline data for the lane. A polyline is a list of points with
    segments defined between consecutive points.
    """

    left_boundary: "Polyline | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The polyline data for the (optional) left boundary of this lane.
    """

    right_boundary: "Polyline | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The polyline data for the (optional) right boundary of this lane.
    """

    entry_lanes: "list[bytes]" = betterproto2.field(
        4, betterproto2.TYPE_BYTES, repeated=True
    )
    """
    A list of IDs for lanes that this lane may be entered from.
    """

    exit_lanes: "list[bytes]" = betterproto2.field(
        5, betterproto2.TYPE_BYTES, repeated=True
    )
    """
    A list of IDs for lanes that this lane may exit to.
    """

    adjacent_lanes_left: "list[bytes]" = betterproto2.field(
        6, betterproto2.TYPE_BYTES, repeated=True
    )
    """
    A list of neighbors to the left of this lane. Neighbor lanes
    include only adjacent lanes going the same direction.
    """

    adjacent_lanes_right: "list[bytes]" = betterproto2.field(
        7, betterproto2.TYPE_BYTES, repeated=True
    )
    """
    A list of neighbors to the right of this lane. Neighbor lanes
    include only adjacent lanes going the same direction.
    """


default_message_pool.register_message("trajdata", "RoadLane", RoadLane)


@dataclass(eq=False, repr=False)
class VectorizedMap(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return VECTORIZED_MAP_PROTO_DESCRIPTOR.message_types_by_name["VectorizedMap"]

    name: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    The name of this map in the format environment_name:map_name
    """

    elements: "list[MapElement]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The full set of map elements.
    """

    max_pt: "Point | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The coordinates of the cuboid (in m)
    containing all elements in this map.
    """

    min_pt: "Point | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )

    shifted_origin: "Point | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The original world coordinates (in m) of the bottom-left of the map
    (account for a change in the origin for storage efficiency).
    """


default_message_pool.register_message("trajdata", "VectorizedMap", VectorizedMap)


VECTORIZED_MAP_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x14vectorized_map.proto\x12\x08trajdata"\xdd\x01\n\rVectorizedMap\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\x120\n\x08elements\x18\x02 \x03(\x0b2\x14.trajdata.MapElementR\x08elements\x12&\n\x06max_pt\x18\x03 \x01(\x0b2\x0f.trajdata.PointR\x05maxPt\x12&\n\x06min_pt\x18\x04 \x01(\x0b2\x0f.trajdata.PointR\x05minPt\x126\n\x0eshifted_origin\x18\x05 \x01(\x0b2\x0f.trajdata.PointR\rshiftedOrigin"\x8a\x02\n\nMapElement\x12\x0e\n\x02id\x18\x01 \x01(\x0cR\x02id\x121\n\troad_lane\x18\x02 \x01(\x0b2\x12.trajdata.RoadLaneH\x00R\x08roadLane\x121\n\troad_area\x18\x03 \x01(\x0b2\x12.trajdata.RoadAreaH\x00R\x08roadArea\x12=\n\rped_crosswalk\x18\x04 \x01(\x0b2\x16.trajdata.PedCrosswalkH\x00R\x0cpedCrosswalk\x127\n\x0bped_walkway\x18\x05 \x01(\x0b2\x14.trajdata.PedWalkwayH\x00R\npedWalkwayB\x0e\n\x0celement_data"1\n\x05Point\x12\x0c\n\x01x\x18\x01 \x01(\x01R\x01x\x12\x0c\n\x01y\x18\x02 \x01(\x01R\x01y\x12\x0c\n\x01z\x18\x03 \x01(\x01R\x01z"^\n\x08Polyline\x12\x13\n\x05dx_mm\x18\x01 \x03(\x11R\x04dxMm\x12\x13\n\x05dy_mm\x18\x02 \x03(\x11R\x04dyMm\x12\x13\n\x05dz_mm\x18\x03 \x03(\x11R\x04dzMm\x12\x13\n\x05h_rad\x18\x04 \x03(\x01R\x04hRad"\xfb\x02\n\x08RoadLane\x12*\n\x06center\x18\x01 \x01(\x0b2\x12.trajdata.PolylineR\x06center\x12<\n\rleft_boundary\x18\x02 \x01(\x0b2\x12.trajdata.PolylineH\x00R\x0cleftBoundary\x88\x01\x01\x12>\n\x0eright_boundary\x18\x03 \x01(\x0b2\x12.trajdata.PolylineH\x01R\rrightBoundary\x88\x01\x01\x12\x1f\n\x0bentry_lanes\x18\x04 \x03(\x0cR\nentryLanes\x12\x1d\n\nexit_lanes\x18\x05 \x03(\x0cR\texitLanes\x12.\n\x13adjacent_lanes_left\x18\x06 \x03(\x0cR\x11adjacentLanesLeft\x120\n\x14adjacent_lanes_right\x18\x07 \x03(\x0cR\x12adjacentLanesRightB\x10\n\x0e_left_boundaryB\x11\n\x0f_right_boundary"\x84\x01\n\x08RoadArea\x12=\n\x10exterior_polygon\x18\x01 \x01(\x0b2\x12.trajdata.PolylineR\x0fexteriorPolygon\x129\n\x0einterior_holes\x18\x02 \x03(\x0b2\x12.trajdata.PolylineR\rinteriorHoles"<\n\x0cPedCrosswalk\x12,\n\x07polygon\x18\x01 \x01(\x0b2\x12.trajdata.PolylineR\x07polygon":\n\nPedWalkway\x12,\n\x07polygon\x18\x01 \x01(\x0b2\x12.trajdata.PolylineR\x07polygonb\x06proto3'
)
