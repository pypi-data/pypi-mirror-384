Index: isubrip/__main__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import atexit\r\nimport os\r\nimport shutil\r\nimport sys\r\n\r\nfrom pathlib import Path\r\nfrom typing import Optional, Type\r\nfrom xml.etree import ElementTree\r\n\r\nimport m3u8\r\nimport requests\r\n\r\nfrom isubrip.constants import DATA_FOLDER_PATH, DEFAULT_CONFIG_PATH, PACKAGE_NAME, PYPI_RSS_URL, TEMP_FOLDER_PATH, USER_CONFIG_FILE\r\nfrom isubrip.enums import DataSource\r\nfrom isubrip.exceptions import ConfigError\r\nfrom isubrip.namedtuples import MovieData\r\nfrom isubrip.playlist_downloader import PlaylistDownloader\r\nfrom isubrip.scrapers.scrapers_importer import *\r\nfrom isubrip.subtitles import Subtitles\r\nfrom isubrip.utils import format_title, parse_config\r\n\r\n\r\ndef main():\r\n    # Load default and user (if it exists) config files\r\n    config_files = [DEFAULT_CONFIG_PATH]\r\n\r\n    ### DEPRECATED ###\r\n    deprecated_config_file = None\r\n\r\n    # Windows\r\n    if sys.platform == \"win32\":\r\n        deprecated_config_file = Path(os.environ['APPDATA']) / \"iSubRip\" / \"config.toml\"\r\n\r\n    # Linux\r\n    elif sys.platform == \"linux\":\r\n        deprecated_config_file = Path.home() / \".config\" / \"iSubRip\" / \"config.toml\"\r\n\r\n    if deprecated_config_file and deprecated_config_file.is_file():\r\n        config_files.append(deprecated_config_file)\r\n        print(\"Warning: A config file was found in a deprecated location that will be unsupported in future versions.\\n\"\r\n              f\"Please move the config file to \\\"{USER_CONFIG_FILE}\\\" to avoid future issues.\\n\")\r\n    ### END DEPRECATED ###\r\n\r\n    # If data folder doesn't exist, create it\r\n    if not DATA_FOLDER_PATH.is_dir():\r\n        DATA_FOLDER_PATH.mkdir(parents=True, exist_ok=True)\r\n\r\n    else:\r\n        # If a user config file exists, add it\r\n        if USER_CONFIG_FILE.is_file():\r\n            config_files.append(USER_CONFIG_FILE)\r\n\r\n    # Check if at least one argument was passed, exit if not\r\n    if len(sys.argv) < 2:\r\n        print_usage()\r\n        exit(1)\r\n\r\n    # Exit if default config file is missing for some reason\r\n    if not DEFAULT_CONFIG_PATH.is_file():\r\n        print(\"Error: Default config file could not be found.\")\r\n        exit(1)\r\n\r\n    try:\r\n        config = parse_config(*config_files)\r\n\r\n    except (ConfigError, FileNotFoundError) as e:\r\n        print(f\"Error: {e}\")\r\n        exit(1)\r\n\r\n    # Set `Subtitles` settings from config\r\n    Subtitles.remove_duplicates = config.subtitles[\"remove-duplicates\"]\r\n    Subtitles.fix_rtl = config.subtitles[\"fix-rtl\"]\r\n    Subtitles.rtl_languages = config.subtitles[\"rtl-languages\"]\r\n\r\n    download_path: Path\r\n    download_to_temp: bool\r\n\r\n    # Set download path to temp folder \"zip\" setting is used\r\n    if config.downloads[\"zip\"]:\r\n        download_path = TEMP_FOLDER_PATH\r\n        download_to_temp = True\r\n        TEMP_FOLDER_PATH.mkdir(exist_ok=True)\r\n        atexit.register(shutil.rmtree, TEMP_FOLDER_PATH)\r\n\r\n    else:\r\n        download_path = Path(config.downloads[\"folder\"])\r\n        download_to_temp = False\r\n\r\n    if config.general[\"check-for-updates\"]:\r\n        check_for_updates()\r\n\r\n    for idx, url in enumerate(sys.argv[1:]):\r\n        if idx > 0:\r\n            print(\"\\n--------------------------------------------------\\n\")  # Print between different movies\r\n\r\n        print(f\"Scraping {url}...\")\r\n        scrape_obj = find_matching_scraper(url)\r\n\r\n        if not scrape_obj:\r\n            print(f\"Error: No valid scraper found for URL \\\"{url}\\\"\")\r\n            continue\r\n\r\n        scraper = create_scraper_obj(scrape_obj, config)\r\n\r\n        try:\r\n            movie_data: MovieData = scraper.get_movie_data(url, {\"User-Agent\": config.scraping[\"user-agent\"]})\r\n\r\n            # AppleTV link used, but no iTunes playlist found on page\r\n            if movie_data.data_source == DataSource.APPLETV and not movie_data.playlists:\r\n                print(\"An iTunes offer could not be found. Skipping...\")\r\n                continue\r\n\r\n        except Exception as e:\r\n            print(f\"Error: {e}\")\r\n            continue\r\n\r\n        print(f\"Found movie: {movie_data.name}\")\r\n\r\n        if not movie_data.playlists:\r\n            print(f\"Error: No valid playlist could be found.\")\r\n            continue\r\n\r\n        multiple_playlists = len(movie_data.playlists) > 1\r\n        downloaded_subtitles_langs = set()\r\n        downloaded_subtitles_paths = []\r\n        subtitles_count = 0\r\n\r\n        # Create temp folder if needed\r\n        if download_to_temp:\r\n            movie_download_path = download_path / f\"{format_title(movie_data.name)}.iT.WEB\"\r\n            movie_download_path.mkdir(exist_ok=True)\r\n\r\n        else:\r\n            movie_download_path = download_path\r\n\r\n        with PlaylistDownloader(config.downloads[\"user-agent\"]) as playlist_downloader:\r\n            for idy, playlist in enumerate(movie_data.playlists):\r\n                # Print empty line between different playlists\r\n                if idy > 0:\r\n                    print()\r\n\r\n                if multiple_playlists:\r\n                    print(f\"id{playlist.itunes_id}:\")\r\n\r\n                m3u8_playlist: m3u8.M3U8 = m3u8.load(playlist.url)\r\n                separate_playlist_folder: bool = multiple_playlists and not config.downloads[\"merge-playlists\"]\r\n                playlist_subtitles_count = 0\r\n\r\n                # Create folder for playlist if needed\r\n                if separate_playlist_folder:\r\n                    playlist_download_path = movie_download_path / f\"id{playlist.itunes_id}\"\r\n                    playlist_download_path.mkdir(exist_ok=True)\r\n\r\n                else:\r\n                    playlist_download_path = movie_download_path\r\n\r\n                for subtitles in Scraper.find_subtitles(m3u8_playlist, config.downloads[\"languages\"]):\r\n                    if not config.downloads[\"merge-playlists\"] or \\\r\n                            (config.downloads[\"merge-playlists\"] and subtitles.language_code not in downloaded_subtitles_langs):\r\n                        playlist_subtitles_count += 1\r\n                        print(f\"Downloading \\\"{subtitles.language_name}\\\" ({subtitles.language_code}) subtitles...\")\r\n                        downloaded_subtitles = playlist_downloader.download_subtitles(movie_data, subtitles, playlist_download_path, config.downloads[\"format\"])\r\n\r\n                        # Assure subtitles downloaded successfully\r\n                        if downloaded_subtitles.is_file():\r\n                            downloaded_subtitles_paths.append(downloaded_subtitles)\r\n\r\n                if separate_playlist_folder:\r\n                    print(f\"{playlist_subtitles_count} subtitles were downloaded.\")\r\n\r\n                    # Remove playlist folder if it's empty\r\n                    if playlist_subtitles_count == 0:\r\n                        playlist_download_path.rmdir()\r\n\r\n                subtitles_count += playlist_subtitles_count\r\n\r\n        # If files were downloaded to a temp folder (\"zip\" option was used)\r\n        if download_to_temp:\r\n            if len(downloaded_subtitles_paths) == 1:\r\n                shutil.copy(downloaded_subtitles_paths[0], config.downloads[\"folder\"])\r\n\r\n            elif len(downloaded_subtitles_paths) > 1:\r\n                # Create zip archive\r\n                print(f\"\\nCreating zip archive...\")\r\n                archive_inital_path = download_path / movie_download_path.stem\r\n                archive_dest_path = shutil.make_archive(base_name=str(archive_inital_path), format=\"zip\", root_dir=movie_download_path)\r\n                shutil.copy(archive_dest_path, config.downloads[\"folder\"])\r\n\r\n            # Remove temp dir\r\n            shutil.rmtree(movie_download_path)\r\n            atexit.unregister(shutil.rmtree)\r\n\r\n        # Add playlists count only if it's more than 1\r\n        playlists_messgae = f\"from {len(movie_data.playlists)} playlists \" if len(movie_data.playlists) > 0 else \"\"\r\n\r\n        print(f\"\\n{len(downloaded_subtitles_paths)}/{subtitles_count} matching subtitles \",\r\n              f\"for \\\"{movie_data.name}\\\" were downloaded {playlists_messgae}\",\r\n              f\"to {Path(config.downloads['folder']).absolute()}\\\".\", sep=\"\")\r\n\r\n\r\ndef check_for_updates() -> None:\r\n    \"\"\"Check and print if a newer version of the package is available.\"\"\"\r\n    # If anything breaks, just skip update check\r\n    try:\r\n        current_version = sys.modules[PACKAGE_NAME].__version__\r\n\r\n        response = requests.get(PYPI_RSS_URL).text\r\n        xml_data = ElementTree.fromstring(response)\r\n        latest_version = xml_data.find(\"channel/item/title\").text\r\n\r\n        # If the latest PyPI release is different from current one, print a message\r\n        if latest_version != current_version:\r\n            print(f\"Note: You are currently using version {current_version} of {PACKAGE_NAME}, however version {latest_version} is available.\",\r\n                  f\"\\nConsider upgrading by running \\\"python3 -m pip install --upgrade {PACKAGE_NAME}\\\"\\n\")\r\n\r\n    except Exception:\r\n        return\r\n\r\n\r\ndef print_usage() -> None:\r\n    \"\"\"Print usage information.\"\"\"\r\n    print(f\"Usage: {PACKAGE_NAME} <iTunes movie URL> [iTunes movie URL...]\")\r\n\r\n\r\ndef find_matching_scraper(url: str) -> Optional[Type[Scraper]]:\r\n    for scraper in scraper_objs:\r\n        if scraper.check_url_match(url):\r\n            return scraper\r\n\r\n    return None\r\n\r\ndef create_scraper_obj()\r\n\r\nif __name__ == \"__main__\":\r\n    a = find_matching_scraper(\"https://itunes.apple.com/us/movie/avengers-endgame/id1454463627\")\r\n    b = find_matching_scraper(\"https://tv.apple.com/us/movie/umc.cmc.5cxq4yswbsp3apykshwrcb890\")\r\n    c = find_matching_scraper(\"test\")\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/__main__.py b/isubrip/__main__.py
--- a/isubrip/__main__.py	(revision fa7ed2ca9f358f23a30fc67d607169f3be89e240)
+++ b/isubrip/__main__.py	(date 1665179571203)
@@ -10,14 +10,14 @@
 import m3u8
 import requests
 
+from isubrip.config import ConfigError, parse_config
 from isubrip.constants import DATA_FOLDER_PATH, DEFAULT_CONFIG_PATH, PACKAGE_NAME, PYPI_RSS_URL, TEMP_FOLDER_PATH, USER_CONFIG_FILE
 from isubrip.enums import DataSource
-from isubrip.exceptions import ConfigError
 from isubrip.namedtuples import MovieData
 from isubrip.playlist_downloader import PlaylistDownloader
 from isubrip.scrapers.scrapers_importer import *
 from isubrip.subtitles import Subtitles
-from isubrip.utils import format_title, parse_config
+from isubrip.utils import format_title
 
 
 def main():
@@ -229,7 +229,6 @@
 
     return None
 
-def create_scraper_obj()
 
 if __name__ == "__main__":
     a = find_matching_scraper("https://itunes.apple.com/us/movie/avengers-endgame/id1454463627")
Index: isubrip/config.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os.path\r\nfrom typing import Any\r\n\r\nimport tomli\r\nfrom mergedeep import merge\r\n\r\nfrom isubrip.enums import SubtitlesFormat\r\nfrom isubrip.exceptions import ConfigValueMissing, InvalidConfigValue\r\nfrom isubrip.namedtuples import ConfigSetting\r\n\r\n\r\nclass Config:\r\n    \"\"\"A class for managing iSubRip config files.\"\"\"\r\n\r\n    def __init__(self) -> None:\r\n        \"\"\"Create a new ConfigManager instance.\"\"\"\r\n        self.config_dict: dict = {}\r\n        self.config_loaded: bool = False\r\n\r\n        # List of valid subtitle formats as strings\r\n        self._valid_subtitle_formats: set = set(item.name.upper() for item in SubtitlesFormat)\r\n\r\n    def __getattr__(self, key: str) -> Any:\r\n        \"\"\"Allow access to config settings using attributes.\r\n\r\n        Args:\r\n            key (str): Config key to get.\r\n\r\n        Returns:\r\n            Any: The corresponding value for the key in the config.\r\n        \"\"\"\r\n        if key in self.config_dict:\r\n            return self.config_dict[key]\r\n\r\n    def loads(self, config_data: str) -> None:\r\n        \"\"\"Parse a tomli iSubRip config from a string.\r\n\r\n        Args:\r\n            config_data (str): Config file data as a string.\r\n\r\n        Raises:\r\n            FileNotFoundError: Config file could not be found in the specified path.\r\n            TOMLDecodeError: Config file is not a valid TOML file.\r\n            ConfigValueMissing: A required config value is missing.\r\n            InvalidConfigValue: An invalid value was used in the config file.\r\n\r\n        Returns:\r\n            dict: A dictionary containing all settings.\r\n        \"\"\"\r\n\r\n        # Load settings from default config file\r\n        loaded_data: dict = tomli.loads(config_data)\r\n\r\n        if not self.config_loaded:\r\n            temp_config: dict = loaded_data\r\n            self.config_loaded = True\r\n\r\n        else:\r\n            temp_config: dict = dict(merge(self.config_dict, loaded_data))\r\n\r\n        # Convert download format from string to SubtitlesFormat enum\r\n        if isinstance(temp_config[\"downloads\"][\"format\"], str) and temp_config[\"downloads\"][\"format\"].upper() in self._valid_subtitle_formats:\r\n            temp_config[\"downloads\"][\"format\"] = SubtitlesFormat[temp_config[\"downloads\"][\"format\"].upper()]\r\n\r\n        elif not isinstance(temp_config[\"downloads\"][\"format\"], SubtitlesFormat):\r\n            raise InvalidConfigValue(f\"Invalid config value for downloads.format: {temp_config['downloads']['format']}\")\r\n\r\n        self._standardize_config_(temp_config)\r\n        self.check_config(temp_config)\r\n        self.config_dict = temp_config\r\n\r\n    @staticmethod\r\n    def _standardize_config_(config_dict: dict) -> None:\r\n        \"\"\"Standardize a config dictionary and fix issues.\r\n\r\n        Args:\r\n            config_dict (dict): Config dictionary to standardize.\r\n        \"\"\"\r\n        # If languages list is empty, change it to None\r\n        if not config_dict[\"downloads\"][\"languages\"]:\r\n            config_dict[\"downloads\"][\"languages\"] = None\r\n\r\n        # Remove a trialing slash / backslash from path\r\n        if isinstance(config_dict[\"downloads\"][\"format\"], str):\r\n            config_dict[\"downloads\"][\"folder\"] = config_dict[\"downloads\"][\"folder\"].rstrip(r\"\\/\")\r\n\r\n    @staticmethod\r\n    def check_config(config_dict: dict) -> None:\r\n        \"\"\"Check the config for invalid values.\r\n        Raises an error if an invalid value is found.\r\n    \r\n        Args:\r\n            config_dict (dict): Config dictionary to check.\r\n\r\n        Raises:\r\n            ConfigValueMissing: A required config value is missing.\r\n            InvalidConfigValue: An invalid value was used in the config file.\r\n        \"\"\"\r\n        \r\n        # List of config values and their corresponding types\r\n        setting_list = [\r\n            ConfigSetting(\"general\", \"check-for-updates\", bool),\r\n            ConfigSetting(\"downloads\", \"folder\", str),\r\n            ConfigSetting(\"downloads\", \"format\", SubtitlesFormat),\r\n            ConfigSetting(\"downloads\", \"languages\", (list, type(None))),\r\n            ConfigSetting(\"downloads\", \"merge-playlists\", bool),\r\n            ConfigSetting(\"downloads\", \"user-agent\", str),\r\n            ConfigSetting(\"downloads\", \"zip\", bool),\r\n            ConfigSetting(\"scraping\", \"user-agent\", str),\r\n            ConfigSetting(\"subtitles\", \"fix-rtl\", bool),\r\n            ConfigSetting(\"subtitles\", \"rtl-languages\", list),\r\n            ConfigSetting(\"subtitles\", \"remove-duplicates\", bool),\r\n        ]\r\n\r\n        # Assure each config value exists and is of the correct type\r\n        for setting in setting_list:\r\n            if setting.category not in config_dict:\r\n                raise ConfigValueMissing(f\"Config category \\'{setting.category}\\' with required settings is missing.\")\r\n\r\n            if setting.key in config_dict[setting.category]:\r\n                setting_value = config_dict[setting.category][setting.key]\r\n\r\n                if not isinstance(setting_value, setting.types):\r\n                    raise InvalidConfigValue(f\"Invalid config value type for {setting.category}.{setting.key}: \\'{setting_value}\\'\"\r\n                                             f\"\\nExpected {setting.types}, received: {type(setting_value)}.\")\r\n\r\n            else:\r\n                raise ConfigValueMissing(f\"Missing required config value: \\'{setting.category}.{setting.key}\\'\")\r\n\r\n        # Assure path is valid\r\n        if not os.path.isdir(config_dict[\"downloads\"][\"folder\"]):\r\n            raise InvalidConfigValue(f\"Invalid config value for downloads.folder:\"\r\n                                     f\"\\nPath \\'{config_dict['downloads']['folder']}\\' is invalid or does not exist.\")\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/config.py b/isubrip/config.py
--- a/isubrip/config.py	(revision fa7ed2ca9f358f23a30fc67d607169f3be89e240)
+++ b/isubrip/config.py	(date 1665179425440)
@@ -1,18 +1,93 @@
 import os.path
-from typing import Any
+from enum import Enum
+from os import PathLike
+from typing import Any, List, Union, Tuple, Dict
 
 import tomli
 from mergedeep import merge
 
 from isubrip.enums import SubtitlesFormat
-from isubrip.exceptions import ConfigValueMissing, InvalidConfigValue
-from isubrip.namedtuples import ConfigSetting
+from isubrip.utils import type_to_str
+
+
+class SpecialTask(Enum):
+    CheckIfFile = 1
+    CheckIfFolder = 2
+
+
+class ConfigSetting:
+    """A class representing a config setting."""
+
+    def __init__(self, required: bool, key: str, types: Union[type, Tuple[type]], category: str,
+                 subcategories: Union[str, Tuple[str]] = None,
+                 special_tasks: Union[SpecialTask, Tuple[SpecialTask], None] = None):
+        """
+        Initialize a ConfigSetting object.
+
+        Args:
+            required (bool): Whether the setting is required or not.
+            key (str): The key for the setting.
+            types (type | tuple[type]): The valid type(s) for the setting.
+            category (str): The top category the setting sits under in the config.
+            subcategories (str | Tuple[str], optional): Optional single / nested subcategories under the top category.
+            special_tasks (SpecialTask | tuple[SpecialTask], optional): Special task(s) to perform on the setting.
+        """
+        if not isinstance(types, tuple):
+            types = (types,)
+
+        if subcategories and not isinstance(subcategories, tuple):
+            subcategories = (subcategories,)
+
+        if not isinstance(special_tasks, tuple):
+            special_tasks = (special_tasks,)
+
+        self.required = required
+        self.category = category
+        self.subcategories = subcategories
+        self.key = key
+        self.types: Tuple[type] = types
+        self.special_tasks: Tuple[SpecialTask] = special_tasks
+
+        setting_path = f"{self.category}"
+        if self.subcategories:
+            for subcategory in self.subcategories:
+                setting_path += f".{subcategory}"
+        setting_path += f".{self.key}"
+        self.path = setting_path
+
+    def __check_value(self, value) -> (bool, Union[str, None]):  # TODO: Raise exception and return None?
+        """
+        Checks if a value is valid for the current setting.
+
+        Args:
+            value: The value to check.
+
+        Returns:
+            tuple[bool, str | None]: A tuple of (True, None) if the value is valid,
+                or (False, str) with an error message if the value is invalid.
+        """
+        for special_task in self.special_tasks:
+            if special_task == SpecialTask.CheckIfFile:
+                if not os.path.isfile(value):
+                    return False, f"\nPath \'{value}\' is invalid, or does not exist."
+
+            elif special_task == SpecialTask.CheckIfFolder:
+                if not os.path.isdir(value):
+                    return False, f"\nPath to file \'{value}\' is invalid, or does not exist."
+
+        if type(value) not in self.types:
+            type_names: str = ', '.join([type_to_str(t) for t in self.types])
+
+            return False, f"Invalid value type for \'{self.path}\': \'{value}\'." \
+                          f" Expected {type_names}, received: {type_to_str(value)}."
+
+        return True, None
 
 
 class Config:
     """A class for managing iSubRip config files."""
 
-    def __init__(self) -> None:
+    def __init__(self) -> None:  # TODO: Accept argument of List[ConfigSetting]. And implement __add__ method
         """Create a new ConfigManager instance."""
         self.config_dict: dict = {}
         self.config_loaded: bool = False
@@ -21,7 +96,8 @@
         self._valid_subtitle_formats: set = set(item.name.upper() for item in SubtitlesFormat)
 
     def __getattr__(self, key: str) -> Any:
-        """Allow access to config settings using attributes.
+        """
+        Allow access to config settings using attributes.
 
         Args:
             key (str): Config key to get.
@@ -33,7 +109,8 @@
             return self.config_dict[key]
 
     def loads(self, config_data: str) -> None:
-        """Parse a tomli iSubRip config from a string.
+        """
+        Parse a toml config from a string.
 
         Args:
             config_data (str): Config file data as a string.
@@ -59,25 +136,27 @@
             temp_config: dict = dict(merge(self.config_dict, loaded_data))
 
         # Convert download format from string to SubtitlesFormat enum
-        if isinstance(temp_config["downloads"]["format"], str) and temp_config["downloads"]["format"].upper() in self._valid_subtitle_formats:
+        if isinstance(temp_config["downloads"]["format"], str) and \
+                temp_config["downloads"]["format"].upper() in self._valid_subtitle_formats:  # TODO: Move outside this module
             temp_config["downloads"]["format"] = SubtitlesFormat[temp_config["downloads"]["format"].upper()]
 
-        elif not isinstance(temp_config["downloads"]["format"], SubtitlesFormat):
+        elif not isinstance(temp_config["downloads"]["format"], SubtitlesFormat):  # TODO: Move outside this module
             raise InvalidConfigValue(f"Invalid config value for downloads.format: {temp_config['downloads']['format']}")
 
+        self.validate_config(temp_config)
         self._standardize_config_(temp_config)
-        self.check_config(temp_config)
         self.config_dict = temp_config
 
     @staticmethod
     def _standardize_config_(config_dict: dict) -> None:
-        """Standardize a config dictionary and fix issues.
+        """
+        Standardize a config dictionary and fix issues.
 
         Args:
             config_dict (dict): Config dictionary to standardize.
         """
         # If languages list is empty, change it to None
-        if not config_dict["downloads"]["languages"]:
+        if not config_dict.get("downloads") and config_dict["downloads"].get("languages") == []:
             config_dict["downloads"]["languages"] = None
 
         # Remove a trialing slash / backslash from path
@@ -85,12 +164,12 @@
             config_dict["downloads"]["folder"] = config_dict["downloads"]["folder"].rstrip(r"\/")
 
     @staticmethod
-    def check_config(config_dict: dict) -> None:
-        """Check the config for invalid values.
-        Raises an error if an invalid value is found.
-    
+    def validate_config(config_dict: dict) -> None:
+        """
+        Check a config for missing or invalid values.
+
         Args:
-            config_dict (dict): Config dictionary to check.
+            config_dict (dict): A dictionary with config data to check.
 
         Raises:
             ConfigValueMissing: A required config value is missing.
@@ -99,35 +178,87 @@
         
         # List of config values and their corresponding types
         setting_list = [
-            ConfigSetting("general", "check-for-updates", bool),
-            ConfigSetting("downloads", "folder", str),
-            ConfigSetting("downloads", "format", SubtitlesFormat),
-            ConfigSetting("downloads", "languages", (list, type(None))),
-            ConfigSetting("downloads", "merge-playlists", bool),
-            ConfigSetting("downloads", "user-agent", str),
-            ConfigSetting("downloads", "zip", bool),
-            ConfigSetting("scraping", "user-agent", str),
-            ConfigSetting("subtitles", "fix-rtl", bool),
-            ConfigSetting("subtitles", "rtl-languages", list),
-            ConfigSetting("subtitles", "remove-duplicates", bool),
+            ConfigSetting(required=True, category="general", key="check-for-updates", types=bool),
+            ConfigSetting(required=True, category="downloads", key="folder", types=str, special_tasks=SpecialTask.CheckIfFolder),
+            ConfigSetting(required=True, category="downloads", key="format", types=SubtitlesFormat),
+            ConfigSetting(required=False, category="downloads", key="languages", types=List[str]),
+            ConfigSetting(required=True, category="downloads", key="merge-playlists", types=bool),
+            ConfigSetting(required=True, category="downloads", key="user-agent", types=str),
+            ConfigSetting(required=True, category="downloads", key="zip", types=bool),
+            ConfigSetting(required=True, category="scraping", key="user-agent", types=str),
+            ConfigSetting(required=True, category="subtitles", key="fix-rtl", types=bool),
+            ConfigSetting(required=True, category="subtitles", key="rtl-languages", types=list),
+            ConfigSetting(required=True, category="subtitles", key="remove-duplicates", types=bool),
         ]
 
         # Assure each config value exists and is of the correct type
         for setting in setting_list:
-            if setting.category not in config_dict:
-                raise ConfigValueMissing(f"Config category \'{setting.category}\' with required settings is missing.")
+            if setting.required:
+                if setting.category not in config_dict:
+                    raise RequiredConfigValueMissing(f"Config category \'{setting.category}\' with required settings is missing.")
+
+                elif setting.subcategories:
+                    config_iter = config_dict[setting.category]
+                    current_path = setting.category
 
-            if setting.key in config_dict[setting.category]:
-                setting_value = config_dict[setting.category][setting.key]
+                    for subcategory in setting.subcategories:
+                        current_path += f".{subcategory}"
+                        if subcategory not in config_iter:
+                            raise RequiredConfigValueMissing(f"Config path \'{current_path}\' with required settings is missing.")  # TODO: Better or more dynamic error message in cases like required settings for specific scrapers
 
-                if not isinstance(setting_value, setting.types):
-                    raise InvalidConfigValue(f"Invalid config value type for {setting.category}.{setting.key}: \'{setting_value}\'"
-                                             f"\nExpected {setting.types}, received: {type(setting_value)}.")
+                        config_iter = config_iter[subcategory]
 
-            else:
-                raise ConfigValueMissing(f"Missing required config value: \'{setting.category}.{setting.key}\'")
+                if setting.key not in config_dict[setting.category]:
+                    raise RequiredConfigValueMissing(f"Missing required config value: \'{setting.category}.{setting.key}\'")
 
-        # Assure path is valid
-        if not os.path.isdir(config_dict["downloads"]["folder"]):
-            raise InvalidConfigValue(f"Invalid config value for downloads.folder:"
-                                     f"\nPath \'{config_dict['downloads']['folder']}\' is invalid or does not exist.")
+            # Find value
+            value = config_dict[setting.category]
+            if setting.subcategories:
+                for subcategory in setting.subcategories:
+                    value = value[subcategory]
+            value = value[setting.key]
+
+            result = setting.__check_value(value)
+
+            if not result[0]:
+                raise InvalidConfigValue(result[1])
+
+
+def parse_config(file_path: Union[str, PathLike], *file_paths: Union[str, PathLike]) -> Config:  # TODO: Check if can be removed and replaced with Config.loads()
+    """
+    Parse config files by order and return a Config object.
+
+    Args:
+        file_path (str): A config file to parse.
+        *file_paths (str, optional): Additional config files to parse (will override previous settings).
+
+    Returns:
+        Config: A parsed Config object.
+    """
+    config = Config()
+    file_paths: tuple = (file_path,) + file_paths
+
+    for file_path in file_paths:
+        with open(file_path, 'r') as data:
+            config.loads(data.read())
+
+    return config
+
+
+class ConfigError(Exception):
+    """Raised when there's an issue with a configuration"""
+    pass
+
+
+class RequiredConfigValueMissing(ConfigError):
+    """Raised when a required value is missing."""
+    pass
+
+
+class InvalidConfigValue(ConfigError):
+    """Raised when an invalid value is used."""
+    pass
+
+
+if __name__ == "__main__":
+    print(type_to_str(Tuple[str, Union[str, List[str]]]))
Index: isubrip/constants.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from pathlib import Path\r\nfrom tempfile import gettempdir\r\n\r\n# General\r\nPACKAGE_NAME = \"isubrip\"\r\nPYPI_RSS_URL = \"https://pypi.org/rss/project/isubrip/releases.xml\"  # Used for checking updates\r\n\r\n# Paths\r\nDEFAULT_CONFIG_PATH = Path(__file__).parent / \"resources\" / \"default_config.toml\"\r\nAPPLETV_STOREFRONTS_PATH = Path(__file__).parent / \"resources\" / \"atv_storefronts.json\"\r\nDATA_FOLDER_PATH = Path.home() / f\".{PACKAGE_NAME}\"\r\nUSER_CONFIG_FILE_NAME = \"config.toml\"\r\nUSER_CONFIG_FILE = DATA_FOLDER_PATH / USER_CONFIG_FILE_NAME\r\nTEMP_FOLDER_PATH = Path(gettempdir()) / PACKAGE_NAME\r\n\r\n\r\n# RegEx\r\nWEBVTT_PERCENTAGE_REGEX = r\"\\d{1,3}(?:.\\d+)?%\"  # TODO: Escape '.'? If yes, on another branch\r\nWEBVTT_CAPTION_TIMINGS_REGEX = \\\r\n    r\"(?:[0-5]\\d:)?[0-5]\\d:[0-5]\\d[\\.,]\\d{3}[ \\t]+-->[ \\t]+(?:[0-5]\\d:)?[0-5]\\d:[0-5]\\d[\\.,]\\d{3}\"\r\n\r\nWEBVTT_CAPTION_SETTING_ALIGNMENT_REGEX = r\"align:(?:start|center|middle|end|left|right)\"\r\nWEBVTT_CAPTION_SETTING_LINE_REGEX = rf\"line:(?:{WEBVTT_PERCENTAGE_REGEX}|-?\\d+%)(?:,(?:start|center|middle|end))?\"\r\nWEBVTT_CAPTION_SETTING_POSITION_REGEX = rf\"position:{WEBVTT_PERCENTAGE_REGEX}(?:,(?:start|center|middle|end))?\"\r\nWEBVTT_CAPTION_SETTING_REGION_REGEX = r\"region:(?:(?!(?:-->)|\\t)\\S)+\"\r\nWEBVTT_CAPTION_SETTING_SIZE_REGEX = rf\"size:{WEBVTT_PERCENTAGE_REGEX}\"\r\nWEBVTT_CAPTION_SETTING_VERTICAL_REGEX = r\"vertical:(?:lr|rl)\"\r\n\r\nWEBVTT_CAPTION_SETTINGS_REGEX = f\"(?:(?:{WEBVTT_CAPTION_SETTING_ALIGNMENT_REGEX})|\" \\\r\n                                f\"(?:{WEBVTT_CAPTION_SETTING_LINE_REGEX})|\" \\\r\n                                f\"(?:{WEBVTT_CAPTION_SETTING_POSITION_REGEX})|\" \\\r\n                                f\"(?:{WEBVTT_CAPTION_SETTING_REGION_REGEX})|\" \\\r\n                                f\"(?:{WEBVTT_CAPTION_SETTING_SIZE_REGEX})|\" \\\r\n                                f\"(?:{WEBVTT_CAPTION_SETTING_VERTICAL_REGEX})|\" \\\r\n                                f\"(?:[ \\t]+))*\"\r\n\r\nWEBVTT_CAPTION_BLOCK_REGEX = rf\"^({WEBVTT_CAPTION_TIMINGS_REGEX})[ \\t]*({WEBVTT_CAPTION_SETTINGS_REGEX})?\"\r\n\r\n# Can't use isubrip.webvtt.Comment.header instead of literal \"NOTE\" string because of circualr import\r\nWEBVTT_COMMENT_HEADER_REGEX = rf\"^NOTE(?:$|[ \\t])(.+)?\"\r\n\r\n# Unicode\r\nRTL_CONTROL_CHARS = ('\\u200e', '\\u200f', '\\u202a', '\\u202b', '\\u202c', '\\u202d', '\\u202e')\r\nRTL_CHAR = '\\u202b'\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/constants.py b/isubrip/constants.py
--- a/isubrip/constants.py	(revision fa7ed2ca9f358f23a30fc67d607169f3be89e240)
+++ b/isubrip/constants.py	(date 1665179425447)
@@ -9,7 +9,7 @@
 DEFAULT_CONFIG_PATH = Path(__file__).parent / "resources" / "default_config.toml"
 APPLETV_STOREFRONTS_PATH = Path(__file__).parent / "resources" / "atv_storefronts.json"
 DATA_FOLDER_PATH = Path.home() / f".{PACKAGE_NAME}"
-USER_CONFIG_FILE_NAME = "config.toml"
+USER_CONFIG_FILE_NAME = "confidg.toml"
 USER_CONFIG_FILE = DATA_FOLDER_PATH / USER_CONFIG_FILE_NAME
 TEMP_FOLDER_PATH = Path(gettempdir()) / PACKAGE_NAME
 
Index: isubrip/enums.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from enum import Enum\r\n\r\n\r\nclass DataSource(Enum):\r\n    \"\"\"Subtitles source.\"\"\"\r\n    ITUNES = 1\r\n    APPLETV = 2\r\n\r\n\r\nclass SubtitlesType(Enum):\r\n    \"\"\"Subtitles type (Normal / CC / Forced).\"\"\"\r\n    NORMAL = 1\r\n    CC = 2\r\n    FORCED = 3\r\n\r\n\r\nclass SubtitlesFormat(Enum):\r\n    \"\"\"Subtitles format (srt / vtt).\"\"\"\r\n    SRT = 1\r\n    VTT = 2\r\n\r\n\r\nclass ArchiveFormat(Enum):\r\n    \"\"\"Archive Format (zip / tar / tar.gz).\"\"\"\r\n    ZIP = 1\r\n    TAR = 2\r\n    TAR_GZ = 3\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/enums.py b/isubrip/enums.py
--- a/isubrip/enums.py	(revision fa7ed2ca9f358f23a30fc67d607169f3be89e240)
+++ b/isubrip/enums.py	(date 1665179425512)
@@ -18,10 +18,3 @@
     """Subtitles format (srt / vtt)."""
     SRT = 1
     VTT = 2
-
-
-class ArchiveFormat(Enum):
-    """Archive Format (zip / tar / tar.gz)."""
-    ZIP = 1
-    TAR = 2
-    TAR_GZ = 3
Index: isubrip/exceptions.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># --------------- Scraping --------------- #\r\n\r\nclass ScrapeError(Exception):\r\n    \"\"\"An issue while scraping the page.\"\"\"\r\n    pass\r\n\r\n\r\nclass InvalidURL(ScrapeError):\r\n    \"\"\"An invalid URL has been used.\"\"\"\r\n    pass\r\n\r\n\r\nclass PageLoadError(ScrapeError):\r\n    \"\"\"The Page did not load properly.\"\"\"\r\n    pass\r\n\r\n\r\n# --------------- Config --------------- #\r\n\r\nclass ConfigError(Exception):\r\n    \"\"\"An issue with a config file.\"\"\"\r\n    pass\r\n\r\n\r\nclass ConfigValueMissing(ConfigError):\r\n    \"\"\"A required config value is missing.\"\"\"\r\n    pass\r\n\r\n\r\nclass InvalidConfigValue(ConfigError):\r\n    \"\"\"An invalid value has been used.\"\"\"\r\n    pass\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/exceptions.py b/isubrip/exceptions.py
--- a/isubrip/exceptions.py	(revision fa7ed2ca9f358f23a30fc67d607169f3be89e240)
+++ b/isubrip/exceptions.py	(date 1665179425518)
@@ -13,20 +13,3 @@
 class PageLoadError(ScrapeError):
     """The Page did not load properly."""
     pass
-
-
-# --------------- Config --------------- #
-
-class ConfigError(Exception):
-    """An issue with a config file."""
-    pass
-
-
-class ConfigValueMissing(ConfigError):
-    """A required config value is missing."""
-    pass
-
-
-class InvalidConfigValue(ConfigError):
-    """An invalid value has been used."""
-    pass
Index: isubrip/utils.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import re\r\n\r\nfrom os import PathLike\r\nfrom typing import Union\r\n\r\nfrom isubrip.config import Config\r\n\r\n\r\ndef format_title(title: str) -> str:\r\n    \"\"\"Format movie title to a standardized title that can be used as a file name.\r\n\r\n    Args:\r\n        title (str): An iTunes movie title.\r\n\r\n    Returns:\r\n        str: The title, in a file-name-friendly format.\r\n    \"\"\"\r\n    # Replacements will be done in the same order of this list\r\n    replacement_pairs = [\r\n        (': ', '.'),\r\n        (' - ', '-'),\r\n        (', ', '.'),\r\n        ('. ', '.'),\r\n        (' ', '.'),\r\n        ('|', '.'),\r\n        ('<', ''),\r\n        ('>', ''),\r\n        ('(', ''),\r\n        (')', ''),\r\n        ('\"', ''),\r\n        ('?', ''),\r\n        ('*', ''),\r\n    ]\r\n\r\n    for pair in replacement_pairs:\r\n        title = title.replace(pair[0], pair[1])\r\n\r\n    title = re.sub(r\"\\.+\", \".\", title)  # Replace multiple dots with a single dot\r\n\r\n    return title\r\n\r\n\r\ndef parse_config(file_path: Union[str, PathLike], *file_paths: Union[str, PathLike]) -> Config:\r\n    \"\"\"\r\n    Parse config files by order and return a Config object.\r\n\r\n    Args:\r\n        file_path (str): A config file to parse.\r\n        *file_paths (str, optional): Additional config files to parse (will override previous settings).\r\n\r\n    Returns:\r\n        Config: A parsed Config object.\r\n    \"\"\"\r\n    config = Config()\r\n    file_paths: tuple = (file_path,) + file_paths\r\n\r\n    for file_path in file_paths:\r\n        with open(file_path, 'r') as data:\r\n            config.loads(data.read())\r\n\r\n    return config\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/utils.py b/isubrip/utils.py
--- a/isubrip/utils.py	(revision fa7ed2ca9f358f23a30fc67d607169f3be89e240)
+++ b/isubrip/utils.py	(date 1665179484379)
@@ -1,10 +1,6 @@
 import re
-
-from os import PathLike
 from typing import Union
 
-from isubrip.config import Config
-
 
 def format_title(title: str) -> str:
     """Format movie title to a standardized title that can be used as a file name.
@@ -40,22 +36,35 @@
     return title
 
 
-def parse_config(file_path: Union[str, PathLike], *file_paths: Union[str, PathLike]) -> Config:
+def type_to_str(type_obj) -> str:
     """
-    Parse config files by order and return a Config object.
+    Convert a type object to a string.
 
     Args:
-        file_path (str): A config file to parse.
-        *file_paths (str, optional): Additional config files to parse (will override previous settings).
+        type_obj (type): Type object to convert.
 
     Returns:
-        Config: A parsed Config object.
+        str: String representation of the type object.
     """
-    config = Config()
-    file_paths: tuple = (file_path,) + file_paths
+    args = None
+
+    if hasattr(type_obj, "__args__"):
+        if type_obj.__args__:
+            args = [type_to_str(t) for t in type_obj.__args__]
 
-    for file_path in file_paths:
-        with open(file_path, 'r') as data:
-            config.loads(data.read())
+    if hasattr(type_obj, "__origin__"):
+        if args:
+            if type_obj.__origin__ is Union:
+                return ' | '.join(args)
 
-    return config
+            return f"{type_to_str(type_obj.__origin__)}[{', '.join(args)}]"
+
+        return type_to_str(type_obj.__origin__)
+
+    if hasattr(type_obj, "__name__"):
+        return type_obj.__name__
+
+    if isinstance(type(type_obj), type(None)):
+        return "None"
+
+    return type_to_str(type(type_obj))
Index: config.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This is an example config for iSubRip using the default settings.\r\n#\r\n# The script looks for a config in the following locations, according to the OS:\r\n# Windows: %AppData%/iSubRip/config.toml  \r\n# Linux: $XDG_CONFIG_HOME/iSubRip/config.toml  \r\n# MacOS: ~/Library/Application Support/isubrip/config.toml  \r\n#\r\n# All settings are optional. Any settings not specified in the config will result in using the default value (which are in the default_config.toml file).\r\n\r\n[general]\r\n# Check for updates before running, and show a note if a new version exists.\r\n# Value can be either \"true\" or \"false\".\r\ncheck-for-updates = true\r\n\r\n\r\n[downloads]\r\n# Folder to downloads files to.\r\n# The default \".\" value means it will download to the same folder the script ran from.\r\n# Use double backslashes in path to avoid escaping characters. Example: \"C:\\\\Users\\\\<username>\\\\Downloads\\\\\"\r\nfolder = \".\"\r\n\r\n# Subtitles format to use when downloading subtitles.\r\n# Value can be either \"vtt\" for WebVTT format, or \"srt\" for srt format.\r\nformat = \"vtt\"\r\n\r\n# A list of iTunes language codes to download.\r\n# An empty array (like the one currently being used) will result in downloading all of the available subtitles.\r\n# Example: [\"en-US\", \"fr-FR\", \"he\"]\r\nlanguages = []\r\n\r\n# Treat subtitles from different iTunes IDs as if they were scraped from the same one.\r\n# Subtitles for languages that were found already will not be redownloaded if found on a different iTunes ID,\r\n# and subtitles will be saved in the same folder and not separate folders for each ID.\r\n#\r\n# NOTE: This is off by default as different IDs might have different runtimes even if they're for the same movies.\r\n#       Having them on separate folders helps identifying what runtime each subtitles file is for.\r\n#\r\n# Value can be either \"true\" or \"false\".\r\nmerge-playlists = false\r\n\r\n# User-Agent to use while downloading subtitles.\r\n# Don't change this unless you know what you're doing.\r\nuser-agent = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36\"\r\n\r\n# Save files into a zip archive if there is more than one matching subtitles.\r\n# Value can be either \"true\" or \"false\".\r\nzip = false\r\n\r\n\r\n[scraping]\r\n# User-Agent to use while scraping iTunes.\r\n# Don't change this unless you know what you're doing.\r\nitunes-user-agent = \"iTunes-AppleTV/15.2\"\r\n\r\n# User-Agent to use while scraping AppleTV.\r\n# Don't change this unless you know what you're doing.\r\nappletv-user-agent = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36\"\r\n\r\n\r\n[subtitles]\r\n# Fix RTL for languages set on `fix-rtl-languages`.\r\n# Value can be either \"true\" or \"false\".\r\n#\r\n# NOTE: This is off by default as some subtitles use other methods to fix RTL (like writing punctuations backwards).\r\n#       Using this option on these type of subtitles can break the already-fixed RTL issues.\r\nfix-rtl = false\r\n\r\n# List of iTunes language codes to fix RTL on.\r\nrtl-languages = [\"ar\", \"he\"]\r\n\r\n# Remove duplicate paragraphs (same text and timestamps).\r\nremove-duplicates = true\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/config.toml b/config.toml
--- a/config.toml	(revision fa7ed2ca9f358f23a30fc67d607169f3be89e240)
+++ b/config.toml	(date 1665179484385)
@@ -1,11 +1,12 @@
 # This is an example config for iSubRip using the default settings.
 #
-# The script looks for a config in the following locations, according to the OS:
-# Windows: %AppData%/iSubRip/config.toml  
-# Linux: $XDG_CONFIG_HOME/iSubRip/config.toml  
-# MacOS: ~/Library/Application Support/isubrip/config.toml  
+# A config file will be looked for in one of the following paths according to OS:
+#  - Windows: %USERPROFILE%\.isubrip\config.json
+#  - Linux / macOS: $HOME/.isubrip/config.toml
 #
-# All settings are optional. Any settings not specified in the config will result in using the default value (which are in the default_config.toml file).
+# All settings are optional.
+# Any settings not specified in the config will result in using the default value (which are in the default_config.toml file).
+# ------------------------------------------------------------
 
 [general]
 # Check for updates before running, and show a note if a new version exists.
Index: isubrip/resources/default_config.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This is the default config.\r\n# This file should NOT be altered. For changing settings, use a user-config file.\r\n# Any settings set on the user config will override these.\r\n\r\n[general]\r\ncheck-for-updates = true\r\n\r\n[downloads]\r\nfolder = \".\"\r\nformat = \"vtt\"\r\nlanguages = []\r\nmerge-playlists = false\r\nuser-agent = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36\"\r\nzip = true\r\n\r\n[scraping]\r\nuser-agent = \"iTunes-AppleTV/15.2\"\r\n\r\n[subtitles]\r\nfix-rtl = false\r\nrtl-languages = [\"ar\", \"he\"]\r\nremove-duplicates = true\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/resources/default_config.toml b/isubrip/resources/default_config.toml
--- a/isubrip/resources/default_config.toml	(revision fa7ed2ca9f358f23a30fc67d607169f3be89e240)
+++ b/isubrip/resources/default_config.toml	(date 1665179425424)
@@ -8,7 +8,7 @@
 [downloads]
 folder = "."
 format = "vtt"
-languages = []
+languages = "test"
 merge-playlists = false
 user-agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36"
 zip = true
