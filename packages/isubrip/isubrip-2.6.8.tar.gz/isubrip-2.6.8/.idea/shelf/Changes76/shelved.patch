Index: isubrip/utils.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nfrom abc import ABCMeta\r\nimport datetime as dt\r\nfrom functools import lru_cache\r\nimport json\r\nfrom pathlib import Path\r\nimport re\r\nimport secrets\r\nimport shutil\r\nimport sys\r\nfrom typing import TYPE_CHECKING, Any, Type, Union, get_args, get_origin\r\n\r\nfrom isubrip.constants import TEMP_FOLDER_PATH, TITLE_REPLACEMENT_STRINGS, WINDOWS_RESERVED_FILE_NAMES\r\nfrom isubrip.data_structures import (\r\n    Episode,\r\n    MediaBase,\r\n    Movie,\r\n    Season,\r\n    Series,\r\n    SubtitlesData,\r\n    SubtitlesFormatType,\r\n    SubtitlesType,\r\n)\r\nfrom isubrip.logger import logger\r\n\r\nif TYPE_CHECKING:\r\n    from os import PathLike\r\n    from types import TracebackType\r\n\r\n    import requests\r\n\r\n\r\nHOST_REGEX = re.compile(\r\n    r\"(?i)^(?:https?://)?(?P<host>[^/:?]+)\",\r\n)\r\nDURATION_TAG_REGEX = re.compile(\r\n    r\"(?i)^(?:(?P<hours>\\d{1,2})H)?\\s?(?:(?P<minutes>\\d{1,2})M)?\\s?(?:(?P<seconds>\\d{1,2})S)?$\"\r\n)\r\nISO8601_DURATION_REGEX = re.compile(\r\n    r\"(?i)^PT(?:(?P<hours>\\d{1,2})H)?(?:(?P<minutes>\\d{1,2})M)?(?:(?P<seconds>\\d{1,2})(?:\\.(?P<milliseconds>\\d{1,3}))?S)?\"  # noqa: E501\r\n)\r\n\r\n\r\nclass SingletonMeta(ABCMeta):\r\n    \"\"\"\r\n    A metaclass that implements the Singleton pattern.\r\n    When a class using this metaclass is initialized, it will return the same instance every time.\r\n    \"\"\"\r\n    _instances: dict[object, object] = {}\r\n\r\n    def __call__(cls, *args: Any, **kwargs: Any) -> object:\r\n        if cls._instances.get(cls) is None:\r\n            cls._instances[cls] = super().__call__(*args, **kwargs)\r\n\r\n        return cls._instances[cls]\r\n\r\n\r\nclass TempDirGenerator:\r\n    \"\"\"A class for generating temporary directories, and disposing them once the object is destroyed.\"\"\"\r\n    _generated_temp_directories: list[Path] = []\r\n\r\n    def __exit__(self, exc_type: Type[BaseException] | None,\r\n                 exc_val: BaseException | None, exc_tb: TracebackType | None) -> None:\r\n        self.cleanup()\r\n\r\n    @classmethod\r\n    def generate(cls, directory_name: str | None = None) -> Path:\r\n        \"\"\"\r\n        Generate a temporary directory within 'TEMP_FOLDER_PATH'.\r\n\r\n        Args:\r\n            directory_name (str | None, optional): Name of the directory to generate.\r\n                If not specified, a random string will be generated. Defaults to None.\r\n\r\n        Returns:\r\n            Path: Path to the generated directory.\r\n        \"\"\"\r\n        directory_name = directory_name or secrets.token_hex(5)\r\n        full_path = TEMP_FOLDER_PATH / directory_name\r\n\r\n        if full_path.is_dir():\r\n            if full_path in cls._generated_temp_directories:  # Generated by this class\r\n                logger.debug(f\"Using previously generated temporary directory: '{full_path}'.\")\r\n                return full_path\r\n\r\n            logger.debug(f\"Temporary directory '{full_path}' already exists. \"\r\n                         f\"Emptying the directory from all contents...\")\r\n            shutil.rmtree(full_path)\r\n            full_path.mkdir(parents=True)\r\n\r\n        else:\r\n            full_path.mkdir(parents=True)\r\n            logger.debug(f\"Temporary directory has been generated: '{full_path}'\")\r\n\r\n        cls._generated_temp_directories.append(full_path)\r\n        return full_path\r\n\r\n    @classmethod\r\n    def cleanup(cls) -> None:\r\n        \"\"\"Remove all temporary directories generated by this object.\"\"\"\r\n        for temp_directory in cls._generated_temp_directories:\r\n            logger.debug(f\"Removing temporary directory: '{temp_directory}'\")\r\n\r\n            try:\r\n                shutil.rmtree(temp_directory)\r\n\r\n            except Exception as e:\r\n                logger.debug(f\"Failed to remove temporary directory '{temp_directory}': {e}\")\r\n\r\n        cls._generated_temp_directories = []\r\n\r\n\r\ndef check_type(value: Any, type_) -> bool:  # type: ignore[no-untyped-def]\r\n    \"\"\"\r\n    Check if a value is of a certain type.\r\n    Works with parameterized generics.\r\n\r\n    Args:\r\n        value (Any): Value to check.\r\n        type_: Type to check against.\r\n\r\n    Returns:\r\n        bool: True if the value is of the specified type, False otherwise.\r\n    \"\"\"\r\n    origin = get_origin(type_)\r\n    args = get_args(type_)\r\n\r\n    if origin is Union:\r\n        return any(check_type(value, union_sub_type) for union_sub_type in args)\r\n\r\n    if origin is tuple:\r\n        if args[-1] is Ellipsis:\r\n            # Example: (int, str, ...)\r\n            args_len = len(args)\r\n\r\n            return check_type(value[:args_len - 1], tuple(args[:-1])) and \\\r\n                all(check_type(item, args[-2]) for item in value[args_len - 1:])\r\n\r\n        return isinstance(value, tuple) and \\\r\n            len(value) == len(args) and \\\r\n            all(check_type(item, item_type) for item, item_type in zip(value, args))\r\n\r\n    if origin is list:\r\n        return isinstance(value, list) and \\\r\n            all(check_type(item, args[0]) for item in value)\r\n\r\n    if origin is dict:\r\n        return isinstance(value, dict) and \\\r\n            all(check_type(k, args[0]) and check_type(v, args[1]) for k, v in value.items())\r\n\r\n    return isinstance(value, type_)\r\n\r\n\r\ndef convert_epoch_to_datetime(epoch_timestamp: int) -> dt.datetime:\r\n    \"\"\"\r\n    Convert an epoch timestamp to a datetime object.\r\n\r\n    Args:\r\n        epoch_timestamp (int): Epoch timestamp.\r\n\r\n    Returns:\r\n        datetime: A datetime object representing the timestamp.\r\n    \"\"\"\r\n    if epoch_timestamp >= 0:\r\n        return dt.datetime.fromtimestamp(epoch_timestamp)\r\n\r\n    return dt.datetime(1970, 1, 1) + dt.timedelta(seconds=epoch_timestamp)\r\n\r\n\r\ndef download_subtitles_to_file(media_data: Movie | Episode, subtitles_data: SubtitlesData, output_path: str | PathLike,\r\n                               source_abbreviation: str | None = None, overwrite: bool = False) -> Path:\r\n    \"\"\"\r\n    Download subtitles to a file.\r\n\r\n    Args:\r\n        media_data (Movie | Episode): An object containing media data.\r\n        subtitles_data (SubtitlesData): A SubtitlesData object containing subtitles data.\r\n        output_path (str | PathLike): Path to the output folder.\r\n        source_abbreviation (str | None, optional): Abbreviation of the source the subtitles are downloaded from.\r\n            Defaults to None.\r\n        overwrite (bool, optional): Whether to overwrite files if they already exist. Defaults to True.\r\n\r\n    Returns:\r\n        Path: Path to the downloaded subtitles file.\r\n\r\n    Raises:\r\n        ValueError: If the path in `output_path` does not exist.\r\n    \"\"\"\r\n    output_path = Path(output_path)\r\n\r\n    if not output_path.is_dir():\r\n        raise ValueError(f\"Invalid path: {output_path}\")\r\n\r\n    if isinstance(media_data, Movie):\r\n        file_name = format_release_name(title=media_data.name,\r\n                                        release_date=media_data.release_date,\r\n                                        media_source=source_abbreviation,\r\n                                        language_code=subtitles_data.language_code,\r\n                                        subtitles_type=subtitles_data.special_type,\r\n                                        file_format=subtitles_data.subtitles_format)\r\n    else:  # isinstance(media_data, Episode):\r\n        file_name = format_release_name(title=media_data.series_name,\r\n                                        release_date=media_data.release_date,\r\n                                        season_number=media_data.season_number,\r\n                                        episode_number=media_data.episode_number,\r\n                                        episode_name=media_data.episode_name,\r\n                                        media_source=source_abbreviation,\r\n                                        language_code=subtitles_data.language_code,\r\n                                        subtitles_type=subtitles_data.special_type,\r\n                                        file_format=subtitles_data.subtitles_format)\r\n\r\n    file_path = output_path / file_name\r\n\r\n    if file_path.exists() and not overwrite:\r\n        file_path = generate_non_conflicting_path(file_path=file_path)\r\n\r\n    with file_path.open('wb') as f:\r\n        f.write(subtitles_data.content)\r\n\r\n    return file_path\r\n\r\n\r\ndef extract_host_from_url(url: str) -> str:\r\n    \"\"\"\r\n    Extract the host from a URL.\r\n\r\n    Args:\r\n        url (str): A URL.\r\n\r\n    Returns:\r\n        str: The host of the URL.\r\n    \"\"\"\r\n    return re.match(HOST_REGEX, url).group('host')\r\n\r\n\r\ndef format_media_description(media_data: MediaBase, shortened: bool = False) -> str:\r\n    \"\"\"\r\n    Generate a short description string of a media object.\r\n\r\n    Args:\r\n        media_data (MediaBase): An object containing media data.\r\n        shortened (bool, optional): Whether to generate a shortened description. Defaults to False.\r\n\r\n    Returns:\r\n        str: A short description string of the media object.\r\n    \"\"\"\r\n    if isinstance(media_data, Movie):\r\n        release_year = (\r\n            media_data.release_date.year\r\n            if isinstance(media_data.release_date, dt.datetime)\r\n            else media_data.release_date\r\n        )\r\n        description_str = f\"{media_data.name} [{release_year}]\"\r\n\r\n        if media_data.id:\r\n            description_str += f\" (ID: {media_data.id})\"\r\n\r\n        return description_str\r\n\r\n    if isinstance(media_data, Series):\r\n        description_str = f\"{media_data.series_name}\"\r\n\r\n        if media_data.series_release_date:\r\n            if isinstance(media_data.series_release_date, dt.datetime):\r\n                description_str += f\" [{media_data.series_release_date.year}]\"\r\n\r\n            else:\r\n                description_str += f\" [{media_data.series_release_date}]\"\r\n\r\n        if media_data.id:\r\n            description_str += f\" (ID: {media_data.id})\"\r\n\r\n        return description_str\r\n\r\n    if isinstance(media_data, Season):\r\n        if shortened:\r\n            description_str = f\"Season {media_data.season_number:02d}\"\r\n\r\n        else:\r\n            description_str = f\"{media_data.series_name} - Season {media_data.season_number:02d}\"\r\n\r\n        if media_data.season_name:\r\n            description_str += f\" - {media_data.season_name}\"\r\n\r\n        if media_data.id:\r\n            description_str += f\" (ID: {media_data.id})\"\r\n\r\n        return description_str\r\n\r\n    if isinstance(media_data, Episode):\r\n        if shortened:\r\n            description_str = f\"S{media_data.season_number:02d}E{media_data.episode_number:02d}\"\r\n\r\n        else:\r\n            description_str = (f\"{media_data.series_name} - \"\r\n                               f\"S{media_data.season_number:02d}E{media_data.episode_number:02d}\")\r\n\r\n        if media_data.episode_name:\r\n            description_str += f\" - {media_data.episode_name}\"\r\n\r\n        if media_data.id:\r\n            description_str += f\" (ID: {media_data.id})\"\r\n\r\n        return description_str\r\n\r\n    raise ValueError(f\"Unsupported media type: '{type(media_data)}'\")\r\n\r\n\r\n@lru_cache\r\ndef format_release_name(title: str,\r\n                        release_date: dt.datetime | int | None = None,\r\n                        season_number: int | None = None,\r\n                        episode_number: int | None = None,\r\n                        episode_name: str | None = None,\r\n                        media_source: str | None = None,\r\n                        source_type: str | None = \"WEB\",\r\n                        additional_info: str | list[str] | None = None,\r\n                        language_code: str | None = None,\r\n                        subtitles_type: SubtitlesType | None = None,\r\n                        file_format: str | SubtitlesFormatType | None = None) -> str:\r\n    \"\"\"\r\n    Format a release name.\r\n\r\n    Args:\r\n        title (str): Media title.\r\n        release_date (int | None, optional): Release date (datetime), or year (int) of the media. Defaults to None.\r\n        season_number (int | None, optional): Season number. Defaults to None.\r\n        episode_number (int | None, optional): Episode number. Defaults to None.\r\n        episode_name (str | None, optional): Episode name. Defaults to None.\r\n        media_source (str | None, optional): Media source name (full or abbreviation). Defaults to None.\r\n        source_type(str | None, optional): General source type (WEB, BluRay, etc.). Defaults to None.\r\n        additional_info (list[str] | str | None, optional): Additional info to add to the file name. Defaults to None.\r\n        language_code (str | None, optional): Language code. Defaults to None.\r\n        subtitles_type (SubtitlesType | None, optional): Subtitles type. Defaults to None.\r\n        file_format (SubtitlesFormat | str | None, optional): File format to use.  Defaults to None.\r\n\r\n    Returns:\r\n        str: Generated file name.\r\n    \"\"\"\r\n    file_name = standardize_title(title).rstrip('.')\r\n\r\n    if release_date is not None:\r\n        if isinstance(release_date, dt.datetime):\r\n            release_year = release_date.year\r\n\r\n        else:\r\n            release_year = release_date\r\n\r\n        file_name += f\".{release_year}\"\r\n\r\n    if season_number is not None and episode_number is not None:\r\n        file_name += f\".S{season_number:02}E{episode_number:02}\"\r\n\r\n    if episode_name is not None:\r\n        file_name += f\".{standardize_title(episode_name).rstrip('.')}\"\r\n\r\n    if media_source is not None:\r\n        file_name += f\".{media_source}\"\r\n\r\n    if source_type is not None:\r\n        file_name += f\".{source_type}\"\r\n\r\n    if additional_info is not None:\r\n        if isinstance(additional_info, (list, tuple)):\r\n            additional_info = '.'.join(additional_info)\r\n\r\n        file_name += f\".{additional_info}\"\r\n\r\n    if language_code is not None:\r\n        file_name += f\".{language_code}\"\r\n\r\n    if subtitles_type is not None:\r\n        file_name += f\".{subtitles_type.value.lower()}\"\r\n\r\n    if file_format is not None:\r\n        if isinstance(file_format, SubtitlesFormatType):\r\n            file_format = file_format.value.file_extension\r\n\r\n        file_name += f\".{file_format}\"\r\n\r\n    return file_name\r\n\r\n\r\ndef format_subtitles_language_description(subtitles_data: SubtitlesData) -> str:\r\n    if subtitles_data.language_name:\r\n        language_str = f\"{subtitles_data.language_name} ({subtitles_data.language_code})\"\r\n\r\n    else:\r\n        language_str = subtitles_data.language_code\r\n\r\n    if subtitles_type := subtitles_data.special_type:\r\n        language_str += f\" [{subtitles_type.value}]\"\r\n\r\n    return language_str\r\n\r\n\r\ndef generate_non_conflicting_path(file_path: Path, has_extension: bool = True) -> Path:\r\n    \"\"\"\r\n    Generate a non-conflicting path for a file.\r\n    If the file already exists, a number will be added to the end of the file name.\r\n\r\n    Args:\r\n        file_path (Path): Path to a file.\r\n        has_extension (bool, optional): Whether the name of the file includes file extension. Defaults to True.\r\n\r\n    Returns:\r\n        Path: A non-conflicting file path.\r\n    \"\"\"\r\n    if isinstance(file_path, str):\r\n        file_path = Path(file_path)\r\n\r\n    if not file_path.exists():\r\n        return file_path\r\n\r\n    i = 1\r\n    while True:\r\n        if has_extension:\r\n            new_file_path = file_path.parent / f\"{file_path.stem}-{i}{file_path.suffix}\"\r\n\r\n        else:\r\n            new_file_path = file_path.parent / f\"{file_path}-{i}\"\r\n\r\n        if not new_file_path.exists():\r\n            return new_file_path\r\n\r\n        i += 1\r\n\r\n\r\ndef merge_dict_values(*dictionaries: dict) -> dict:\r\n    \"\"\"\r\n    A function for merging the values of multiple dictionaries using the same keys.\r\n    If a key already exists, the value will be added to a list of values mapped to that key.\r\n\r\n    Note:\r\n        This function support only merging of lists, without any nesting.\r\n\r\n    Args:\r\n        *dictionaries (dict): Dictionaries to merge.\r\n\r\n    Returns:\r\n        dict: A merged dictionary.\r\n    \"\"\"\r\n    _dictionaries = [d for d in dictionaries if d]\r\n\r\n    if len(_dictionaries) == 0:\r\n        return {}\r\n\r\n    if len(_dictionaries) == 1:\r\n        return _dictionaries[0]\r\n\r\n    result: dict = {}\r\n\r\n    for _dict in _dictionaries:\r\n        for key, value in _dict.items():\r\n            if key in result:\r\n                if isinstance(result[key], list):\r\n                    if isinstance(value, list):\r\n                        result[key].extend(value)\r\n                    else:\r\n                        result[key].append(value)\r\n                else:\r\n                    if isinstance(value, list):\r\n                        result[key] = [result[key], *value]\r\n                    else:\r\n                        result[key] = [result[key], value]\r\n            else:\r\n                result[key] = value\r\n\r\n    return result\r\n\r\n\r\ndef raise_for_status(response: requests.Response) -> None:\r\n    \"\"\"\r\n    Raise an exception if the response status code is invalid.\r\n    Uses 'response.raise_for_status()' internally, with additional logging.\r\n\r\n    Args:\r\n        response (requests.Response): A response object.\r\n    \"\"\"\r\n    truncation_threshold = 1500\r\n\r\n    if response.ok:\r\n        return\r\n\r\n    if len(response.text) > truncation_threshold:\r\n        # Truncate the response as in some cases there could be an unexpected long HTML response\r\n        response_text = response.text[:truncation_threshold].rstrip() + \" <TRUNCATED...>\"\r\n\r\n    else:\r\n        response_text = response.text\r\n\r\n    logger.debug(f\"Response status code: {response.status_code}\")\r\n\r\n    if response.headers.get('Content-Type'):\r\n        logger.debug(f\"Response type: {response.headers['Content-Type']}\")\r\n\r\n    logger.debug(f\"Response text: {response_text}\")\r\n\r\n    response.raise_for_status()\r\n\r\n\r\ndef parse_duration(duration_string: str) -> dt.timedelta:\r\n    \"\"\"\r\n    Parse a duration ISO 8601 string (e.g. PT1H30M15S), or a duration tag (e.g. '1h 30m', '30m') to a timedelta object.\r\n\r\n    Args:\r\n        duration_string (str): Duration tag to parse.\r\n\r\n    Returns:\r\n        dt.timedelta: A timedelta object representing the duration.\r\n    \"\"\"\r\n    if regex_match := re.match(ISO8601_DURATION_REGEX, duration_string):\r\n        data = regex_match.groupdict()\r\n\r\n    elif regex_match := re.match(DURATION_TAG_REGEX, duration_string):\r\n        data = regex_match.groupdict()\r\n\r\n    else:\r\n        raise ValueError(f\"Invalid / unsupported duration string: '{duration_string}'\")\r\n\r\n    hours = int(data[\"hours\"]) if data.get(\"hours\") else 0\r\n    minutes = int(data[\"minutes\"]) if data.get(\"minutes\") else 0\r\n    seconds = int(data[\"seconds\"]) if data.get(\"seconds\") else 0\r\n    milliseconds = int(data[\"milliseconds\"]) if data.get(\"milliseconds\") else 0\r\n\r\n    return dt.timedelta(hours=hours, minutes=minutes, seconds=seconds, milliseconds=milliseconds)\r\n\r\n\r\ndef parse_season_and_episode_tag(tag: str) -> tuple[int, int]:\r\n    \"\"\"\r\n    Parse a season and episode tag (e.g. 'S01E01') to a tuple containing the season number and episode number.\r\n\r\n    Args:\r\n        tag (str): Season and episode tag. (e.g. 'S01E02')\r\n\r\n    Returns:\r\n        tuple[int, int]: A tuple containing the season number (first item) and episode number (second item).\r\n    \"\"\"\r\n    regex_pattern = re.compile(r\"(?i)^S(?P<season>\\d{1,2})[\\s.]?E(?P<episode>\\d{1,3})$\")\r\n\r\n    if regex_match := re.match(regex_pattern, tag):\r\n        return int(regex_match.group('season')), int(regex_match.group('episode'))\r\n\r\n    raise ValueError(f\"Invalid season and episode tag: '{tag}'\")\r\n\r\n\r\ndef parse_url_params(url_params: str) -> dict:\r\n    \"\"\"\r\n    Parse GET parameters from a URL to a dictionary.\r\n\r\n    Args:\r\n        url_params (str): URL parameters. (e.g. 'param1=value1&param2=value2')\r\n\r\n    Returns:\r\n        dict: A dictionary containing the URL parameters.\r\n    \"\"\"\r\n    url_params = url_params.split('?')[-1].rstrip('&')\r\n    params_list = url_params.split('&')\r\n\r\n    if len(params_list) == 0 or \\\r\n            (len(params_list) == 1 and '=' not in params_list[0]):\r\n        return {}\r\n\r\n    return {key: value for key, value in (param.split('=') for param in params_list)}\r\n\r\n\r\ndef single_to_list(obj: Any) -> list:\r\n    \"\"\"\r\n    Convert a single non-iterable object to a list.\r\n    If None is passed, an empty list will be returned.\r\n\r\n    Args:\r\n        obj: Object to convert.\r\n\r\n    Returns:\r\n        list: A list containing the object.\r\n            If the object is already an iterable, it will be converted to a list.\r\n    \"\"\"\r\n    if isinstance(obj, list):\r\n        return obj\r\n\r\n    if obj is None:\r\n        return []\r\n\r\n    # tuple (not a namedtuple) or a set\r\n    if (isinstance(obj, tuple) and not hasattr(obj, '_fields')) or isinstance(obj, set):\r\n        return list(obj)\r\n\r\n    return [obj]\r\n\r\n\r\ndef split_subtitles_timestamp(timestamp: str) -> tuple[dt.time, dt.time]:\r\n    \"\"\"\r\n    Split a subtitles timestamp into start and end.\r\n\r\n    Args:\r\n        timestamp (str): A subtitles timestamp. For example: \"00:00:00.000 --> 00:00:00.000\"\r\n\r\n    Returns:\r\n        tuple(time, time): A tuple containing start and end times as a datetime object.\r\n    \"\"\"\r\n    # Support ',' character in timestamp's milliseconds (used in SubRip format).\r\n    timestamp = timestamp.replace(',', '.')\r\n\r\n    start_time, end_time = timestamp.split(\" --> \")\r\n    return dt.time.fromisoformat(start_time), dt.time.fromisoformat(end_time)\r\n\r\n\r\n@lru_cache\r\ndef standardize_title(title: str) -> str:\r\n    \"\"\"\r\n    Format movie title to a standardized title that can be used as a file name.\r\n\r\n    Args:\r\n        title (str): A movie title.\r\n\r\n    Returns:\r\n        str: The movie title, in a file-name-friendly format.\r\n    \"\"\"\r\n    title = title.strip()\r\n\r\n    for string, replacement_string in TITLE_REPLACEMENT_STRINGS.items():\r\n        title = title.replace(string, replacement_string)\r\n\r\n    title = re.sub(r\"\\.+\", \".\", title)  # Replace multiple dots with a single dot\r\n\r\n    # If running on Windows, rename Windows reserved names to allow file creation\r\n    if sys.platform == 'win32':\r\n        split_title = title.split('.')\r\n\r\n        if split_title[0].upper() in WINDOWS_RESERVED_FILE_NAMES:\r\n            if len(split_title) > 1:\r\n                return split_title[0] + split_title[1] + '.'.join(split_title[2:])\r\n\r\n            if len(split_title) == 1:\r\n                return \"_\" + title\r\n\r\n    return title\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/utils.py b/isubrip/utils.py
--- a/isubrip/utils.py	(revision a2cec0f68a8dfed9418f81750b863adeae49e756)
+++ b/isubrip/utils.py	(date 1709331170907)
@@ -7,11 +7,10 @@
 from pathlib import Path
 import re
 import secrets
-import shutil
 import sys
 from typing import TYPE_CHECKING, Any, Type, Union, get_args, get_origin
 
-from isubrip.constants import TEMP_FOLDER_PATH, TITLE_REPLACEMENT_STRINGS, WINDOWS_RESERVED_FILE_NAMES
+from isubrip.constants import TEMP_FOLDER_PATH
 from isubrip.data_structures import (
     Episode,
     MediaBase,
@@ -79,21 +78,14 @@
         directory_name = directory_name or secrets.token_hex(5)
         full_path = TEMP_FOLDER_PATH / directory_name
 
-        if full_path.is_dir():
-            if full_path in cls._generated_temp_directories:  # Generated by this class
-                logger.debug(f"Using previously generated temporary directory: '{full_path}'.")
-                return full_path
-
-            logger.debug(f"Temporary directory '{full_path}' already exists. "
-                         f"Emptying the directory from all contents...")
-            shutil.rmtree(full_path)
-            full_path.mkdir(parents=True)
-
-        else:
+        if not full_path.is_dir():
             full_path.mkdir(parents=True)
             logger.debug(f"Temporary directory has been generated: '{full_path}'")
-
-        cls._generated_temp_directories.append(full_path)
+            cls._generated_temp_directories.append(full_path)
+
+        else:
+            logger.debug(f"Using existing temporary directory: '{full_path}'.")
+
         return full_path
 
     @classmethod
@@ -103,7 +95,7 @@
             logger.debug(f"Removing temporary directory: '{temp_directory}'")
 
             try:
-                shutil.rmtree(temp_directory)
+                temp_directory.rmdir()
 
             except Exception as e:
                 logger.debug(f"Failed to remove temporary directory '{temp_directory}': {e}")
@@ -193,22 +185,22 @@
         raise ValueError(f"Invalid path: {output_path}")
 
     if isinstance(media_data, Movie):
-        file_name = format_release_name(title=media_data.name,
-                                        release_date=media_data.release_date,
-                                        media_source=source_abbreviation,
-                                        language_code=subtitles_data.language_code,
-                                        subtitles_type=subtitles_data.special_type,
-                                        file_format=subtitles_data.subtitles_format)
+        file_name = generate_release_name(title=media_data.name,
+                                          release_date=media_data.release_date,
+                                          media_source=source_abbreviation,
+                                          language_code=subtitles_data.language_code,
+                                          subtitles_type=subtitles_data.special_type,
+                                          file_format=subtitles_data.subtitles_format)
     else:  # isinstance(media_data, Episode):
-        file_name = format_release_name(title=media_data.series_name,
-                                        release_date=media_data.release_date,
-                                        season_number=media_data.season_number,
-                                        episode_number=media_data.episode_number,
-                                        episode_name=media_data.episode_name,
-                                        media_source=source_abbreviation,
-                                        language_code=subtitles_data.language_code,
-                                        subtitles_type=subtitles_data.special_type,
-                                        file_format=subtitles_data.subtitles_format)
+        file_name = generate_release_name(title=media_data.series_name,
+                                          release_date=media_data.release_date,
+                                          season_number=media_data.season_number,
+                                          episode_number=media_data.episode_number,
+                                          episode_name=media_data.episode_name,
+                                          media_source=source_abbreviation,
+                                          language_code=subtitles_data.language_code,
+                                          subtitles_type=subtitles_data.special_type,
+                                          file_format=subtitles_data.subtitles_format)
 
     file_path = output_path / file_name
 
@@ -221,20 +213,7 @@
     return file_path
 
 
-def extract_host_from_url(url: str) -> str:
-    """
-    Extract the host from a URL.
-
-    Args:
-        url (str): A URL.
-
-    Returns:
-        str: The host of the URL.
-    """
-    return re.match(HOST_REGEX, url).group('host')
-
-
-def format_media_description(media_data: MediaBase, shortened: bool = False) -> str:
+def generate_media_description(media_data: MediaBase, shortened: bool = False) -> str:
     """
     Generate a short description string of a media object.
 
@@ -307,20 +286,82 @@
     raise ValueError(f"Unsupported media type: '{type(media_data)}'")
 
 
-@lru_cache
-def format_release_name(title: str,
-                        release_date: dt.datetime | int | None = None,
-                        season_number: int | None = None,
-                        episode_number: int | None = None,
-                        episode_name: str | None = None,
-                        media_source: str | None = None,
-                        source_type: str | None = "WEB",
-                        additional_info: str | list[str] | None = None,
-                        language_code: str | None = None,
-                        subtitles_type: SubtitlesType | None = None,
-                        file_format: str | SubtitlesFormatType | None = None) -> str:
+def extract_host_from_url(url: str) -> str:
+    """
+    Extract the host from a URL.
+
+    Args:
+        url (str): A URL.
+
+    Returns:
+        str: The host of the URL.
+    """
+    return re.match(HOST_REGEX, url).group('host')
+
+
+def generate_non_conflicting_path(file_path: Path, has_extension: bool = True) -> Path:
+    """
+    Generate a non-conflicting path for a file.
+    If the file already exists, a number will be added to the end of the file name.
+
+    Args:
+        file_path (Path): Path to a file.
+        has_extension (bool, optional): Whether the name of the file includes file extension. Defaults to True.
+
+    Returns:
+        Path: A non-conflicting file path.
+    """
+    if isinstance(file_path, str):
+        file_path = Path(file_path)
+
+    if not file_path.exists():
+        return file_path
+
+    i = 1
+    while True:
+        if has_extension:
+            new_file_path = file_path.parent / f"{file_path.stem}-{i}{file_path.suffix}"
+
+        else:
+            new_file_path = file_path.parent / f"{file_path}-{i}"
+
+        if not new_file_path.exists():
+            return new_file_path
+
+        i += 1
+
+
+def generate_random_hex_string(length: int) -> str:
+    """
+    Generate a random hexadecimal string.
+
+    Args:
+        length (int): Length of the string to generate.
+
+    Returns:
+        str: A random hexadecimal string.
+    """
+    result = secrets.token_hex(length // 2)
+
+    if length % 2 == 1:
+        result += secrets.token_hex(1)[0]
+
+    return result
+
+
+def generate_release_name(title: str,
+                          release_date: dt.datetime | int | None = None,
+                          season_number: int | None = None,
+                          episode_number: int | None = None,
+                          episode_name: str | None = None,
+                          media_source: str | None = None,
+                          source_type: str | None = "WEB",
+                          additional_info: str | list[str] | None = None,
+                          language_code: str | None = None,
+                          subtitles_type: SubtitlesType | None = None,
+                          file_format: str | SubtitlesFormatType | None = None) -> str:
     """
-    Format a release name.
+    Generate a release name.
 
     Args:
         title (str): Media title.
@@ -382,49 +423,32 @@
     return file_name
 
 
-def format_subtitles_language_description(subtitles_data: SubtitlesData) -> str:
-    if subtitles_data.language_name:
-        language_str = f"{subtitles_data.language_name} ({subtitles_data.language_code})"
-
-    else:
-        language_str = subtitles_data.language_code
-
-    if subtitles_type := subtitles_data.special_type:
-        language_str += f" [{subtitles_type.value}]"
-
-    return language_str
-
-
-def generate_non_conflicting_path(file_path: Path, has_extension: bool = True) -> Path:
+def generate_url_params(data: dict[str, Any], remove_dict_spaces: bool = False) -> str:
     """
-    Generate a non-conflicting path for a file.
-    If the file already exists, a number will be added to the end of the file name.
+    Generate a URL query string from a dictionary.
 
     Args:
-        file_path (Path): Path to a file.
-        has_extension (bool, optional): Whether the name of the file includes file extension. Defaults to True.
+        data (dict[str, Any]): Dictionary to generate a URL query string from.
+        remove_dict_spaces (bool, optional): Whether to remove spaces from stringified dictionary values.
+            Defaults to False.
 
     Returns:
-        Path: A non-conflicting file path.
+        str: Generated URL query string.
     """
-    if isinstance(file_path, str):
-        file_path = Path(file_path)
+    stringified_data = {}
+    json_dumps_separators = (',', ':') if remove_dict_spaces else None
 
-    if not file_path.exists():
-        return file_path
+    for key, value in data.items():
+        if isinstance(value, (list, tuple, dict)):
+            stringified_data[key] = json.dumps(value, separators=json_dumps_separators)
 
-    i = 1
-    while True:
-        if has_extension:
-            new_file_path = file_path.parent / f"{file_path.stem}-{i}{file_path.suffix}"
+        elif isinstance(value, bool):
+            stringified_data[key] = str(value).lower()
 
         else:
-            new_file_path = file_path.parent / f"{file_path}-{i}"
+            stringified_data[key] = str(value)
 
-        if not new_file_path.exists():
-            return new_file_path
-
-        i += 1
+    return '&'.join([f"{key}={value}" for key, value in stringified_data.items() if value is not None])
 
 
 def merge_dict_values(*dictionaries: dict) -> dict:
@@ -441,17 +465,17 @@
     Returns:
         dict: A merged dictionary.
     """
-    _dictionaries = [d for d in dictionaries if d]
+    dictionaries = [d for d in dictionaries if d]
 
-    if len(_dictionaries) == 0:
+    if len(dictionaries) == 0:
         return {}
 
-    if len(_dictionaries) == 1:
-        return _dictionaries[0]
+    elif len(dictionaries) == 1:
+        return dictionaries[0]
 
     result: dict = {}
 
-    for _dict in _dictionaries:
+    for _dict in dictionaries:
         for key, value in _dict.items():
             if key in result:
                 if isinstance(result[key], list):
@@ -618,10 +642,34 @@
     Returns:
         str: The movie title, in a file-name-friendly format.
     """
+    windows_reserved_file_names = ("CON", "PRN", "AUX", "NUL", "COM1", "COM2", "COM3", "COM4",
+                                   "COM5", "COM6", "COM7", "COM8", "COM9", "LPT1", "LPT2",
+                                   "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9")
+
     title = title.strip()
 
-    for string, replacement_string in TITLE_REPLACEMENT_STRINGS.items():
-        title = title.replace(string, replacement_string)
+    # Replacements will be done in the same order of this list
+    replacement_pairs = [
+        (': ', '.'),
+        (':', '.'),
+        (' - ', '-'),
+        (', ', '.'),
+        ('. ', '.'),
+        (' ', '.'),
+        ('|', '.'),
+        ('/', '.'),
+        ('…', '.'),
+        ('<', ''),
+        ('>', ''),
+        ('(', ''),
+        (')', ''),
+        ('"', ''),
+        ('?', ''),
+        ('*', ''),
+    ]
+
+    for pair in replacement_pairs:
+        title = title.replace(pair[0], pair[1])
 
     title = re.sub(r"\.+", ".", title)  # Replace multiple dots with a single dot
 
@@ -629,7 +677,7 @@
     if sys.platform == 'win32':
         split_title = title.split('.')
 
-        if split_title[0].upper() in WINDOWS_RESERVED_FILE_NAMES:
+        if split_title[0].upper() in windows_reserved_file_names:
             if len(split_title) > 1:
                 return split_title[0] + split_title[1] + '.'.join(split_title[2:])
 
