Index: isubrip/scrapers/scraper.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nimport abc\r\nimport asyncio\r\nimport importlib\r\nimport inspect\r\nimport os\r\nimport re\r\nimport sys\r\nfrom abc import abstractmethod, ABC\r\nfrom enum import Enum\r\nfrom glob import glob\r\nfrom pathlib import Path\r\nfrom typing import Dict, Iterator, List, Optional, Tuple, Type, Union, NamedTuple, TypeVar\r\n\r\nimport aiohttp\r\nimport m3u8\r\nimport requests\r\nfrom m3u8 import M3U8, Media\r\n\r\nfrom isubrip.config import Config, ConfigSetting\r\nfrom isubrip.constants import PACKAGE_NAME\r\nfrom isubrip.utils import merge_dict_values\r\nfrom isubrip.data_structures import EpisodeData, MovieData, SeasonData, SeriesData, SubtitlesData, SubtitlesFormat, SubtitlesType\r\nfrom isubrip.subtitle_formats.subtitles import Subtitles\r\n\r\n\r\nScraper = TypeVar('Scraper', bound='ScraperBase')\r\n\r\n\r\nclass PlaylistData(NamedTuple):\r\n    \"\"\"A named tuple containing main_playlist data.\"\"\"\r\n    url: str\r\n    id: Optional[str] = None\r\n\r\n\r\nclass ScraperMeta(abc.ABCMeta):\r\n    \"\"\"\r\n    A metaclass for scrapers.\r\n    This metaclass ensures only one instance of each scraper is created (singleton).\r\n    \"\"\"\r\n    _instances: Dict[str, ScraperBase] = {}  # TODO REFACTOR: Set checkpoint here and assure this works (only one instance of each scraper is generated for multiple links)\r\n\r\n    def __call__(cls, *args, **kwargs) -> ScraperBase:\r\n        if cls._instances.get(cls.__name__) is None:\r\n            cls._instances[cls.__name__] = super().__call__(*args, **kwargs)\r\n\r\n        return cls._instances[cls.__name__]\r\n\r\n\r\nclass ScraperBase(ABC, metaclass=ScraperMeta):  # TODO REFACTOR: Move to ScaperMeta? Assure everything works beforehand and then test if that breaks stuff\r\n    \"\"\"A base class for scrapers.\"\"\"\r\n    _config_category: str = \"main_playlist-filters\"\r\n\r\n    default_user_agent = None\r\n\r\n    is_movie_scraper: bool = False\r\n    is_series_scraper: bool = False\r\n\r\n    # --- Class Attributes ---\r\n    # TODO REFACTOR: Somehow assert these are set in subclasses\r\n    subtitles_class: Type[Subtitles]\r\n    \"\"\"The scraper's subtitles class.\"\"\"\r\n\r\n    service_abbreviation: str\r\n    \"\"\"A short abbreviation of the service name.\"\"\"\r\n\r\n    service_name: str\r\n    \"\"\"The name of the service.\"\"\"\r\n\r\n    url_regex: Union[str, List[str]]\r\n    \"\"\"A RegEx pattern to find URLs matching the service.\"\"\"\r\n\r\n    def __init__(self, config_data: Optional[dict] = None):\r\n        self._session = requests.Session()\r\n        self._session.headers.update({\"User-Agent\": self.default_user_agent})\r\n        self.config: Optional[Config] = Config(config_data=config_data)\r\n        self.default_filters: dict = config_data if config_data else {}\r\n\r\n    @classmethod\r\n    def check_url_match(cls, url: str) -> bool:\r\n        \"\"\"\r\n        Checks if a URL matches scraper's url regex.\r\n\r\n        Args:\r\n            url: The URL to check.\r\n\r\n        Returns:\r\n            bool: True if URL matches, False otherwise.\r\n        \"\"\"\r\n        if not cls.url_regex:\r\n            return False\r\n\r\n        if isinstance(cls.url_regex, str):\r\n            return re.fullmatch(cls.url_regex, url) is not None\r\n\r\n        elif isinstance(cls.url_regex, (list, tuple)):\r\n            for regex in cls.url_regex:\r\n                if re.fullmatch(regex, url) is not None:\r\n                    return True\r\n\r\n            return False\r\n\r\n    def __enter__(self):\r\n        return self\r\n\r\n    def __exit__(self, exc_type, exc_val, exc_tb):\r\n        self.close()\r\n\r\n    def close(self):\r\n        self._session.close()\r\n\r\n    @abstractmethod\r\n    def get_data(self, url: str) -> Union[MovieData, SeriesData, SeasonData, EpisodeData]:\r\n        \"\"\"\r\n        Scrape media information about the media on a URL.\r\n\r\n        Args:\r\n            url: The URL to get information about.\r\n\r\n        Returns:\r\n            Union[MovieData, SeriesData, SubtitlesData, PlaylistData]: Information about the media.\r\n        \"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    def get_subtitles(self, main_playlist: M3U8, playlist_filters: Union[Dict[str, Union[str, List[str]]], None] = None,\r\n                      subrip_conversion: bool = False) -> Iterator[SubtitlesData]:\r\n        \"\"\"\r\n        Find and yield subtitles data from a main_playlist.\r\n        \"\"\"\r\n        pass\r\n\r\n\r\nclass MovieScraper(ScraperBase, ABC, metaclass=ScraperMeta):\r\n    \"\"\"\r\n    A base class for movie scrapers.\r\n    \"\"\"\r\n    is_movie_scraper: bool = True\r\n\r\n    @abstractmethod\r\n    def _get_movie_data(self, url: str) -> MovieData:\r\n        pass\r\n\r\n\r\nclass SeriesScraper(ScraperBase, ABC, metaclass=ScraperMeta):\r\n    \"\"\"\r\n    A base class for TV scrapers.\r\n    \"\"\"\r\n    is_series_scraper: bool = True\r\n\r\n    @abstractmethod\r\n    def _get_series_data(self, url: str) -> SeriesData:\r\n        pass\r\n\r\n\r\nclass M3U8Scraper(ScraperBase, ABC, metaclass=ScraperMeta):\r\n    \"\"\"A base class for M3U8 scrapers.\"\"\"\r\n    class M3U8Attribute(Enum):\r\n        \"\"\"\r\n        An enum representing all possible M3U8 attributes.\r\n        Names / Keys represent M3U8 attributes (should be converted to lowercase),\r\n        and values represent the name of the key for config usage.\r\n        \"\"\"\r\n        ASSOC_LANGUAGE = \"assoc-language\"\r\n        AUTOSELECT = \"autoselect\"\r\n        CHARACTERISTICS = \"characteristics\"\r\n        CHANNELS = \"channels\"\r\n        DEFAULT = \"default\"\r\n        FORCED = \"forced\"\r\n        GROUP_ID = \"group-id\"\r\n        INSTREAM_ID = \"instream-id\"\r\n        LANGUAGE = \"language\"\r\n        NAME = \"name\"\r\n        STABLE_RENDITION_ID = \"stable-rendition-id\"\r\n        TYPE = \"type\"\r\n\r\n    def __init__(self, config_data: Optional[dict] = None):\r\n        super().__init__(config_data)\r\n        # TODO REFACTOR: Move async stuff to a different class, and than inherient from it if async is needed? (in case non-m3u8 scrapers need it as well)\r\n        self.async_session = aiohttp.ClientSession()\r\n        self.async_session.headers.update({\"User-Agent\": self.default_user_agent})\r\n\r\n        # Add M3U8 filters settings\r\n        self.config.add_settings([\r\n            ConfigSetting(\r\n                category=ScraperBase._config_category,\r\n                key=m3u8_attribute.value,\r\n                type=Union[str, List[str]],\r\n                required=False,\r\n            ) for m3u8_attribute in self.M3U8Attribute],\r\n            check_config=False)\r\n\r\n    def close(self):\r\n        asyncio.get_event_loop().run_in_executor(None, self._async_close)\r\n        super().close()\r\n\r\n    async def _async_close(self):\r\n        await self.async_session.close()\r\n\r\n    def _download_segments_async(self, segments: m3u8.SegmentList[m3u8.Segment]) -> List[bytes]:\r\n        \"\"\"\r\n        Download M3U8 segments asynchronously.\r\n\r\n        Args:\r\n            segments (m3u8.SegmentList[m3u8.Segment]): List of segments to download.\r\n\r\n        Returns:\r\n            List[bytes]: List of downloaded segments.\r\n        \"\"\"\r\n        loop = asyncio.get_event_loop()\r\n        async_tasks = [loop.create_task(self._download_segment_async(segment.absolute_uri)) for segment in segments]\r\n        segments_bytes = loop.run_until_complete(asyncio.gather(*async_tasks))\r\n\r\n        return list(segments_bytes)\r\n\r\n    async def _download_segment_async(self, url: str) -> bytes:\r\n        \"\"\"\r\n        Download an M3U8 segment asynchronously.\r\n\r\n        Args:\r\n            url (str): URL of the segment to download.\r\n\r\n        Returns:\r\n            bytes: Downloaded segment.\r\n        \"\"\"\r\n        async with self.async_session.get(url) as response:\r\n            return await response.read()\r\n\r\n    @staticmethod\r\n    def detect_subtitles_type(subtitles_media: m3u8.Media) -> Optional[SubtitlesType]:\r\n        \"\"\"\r\n        Detect the type of subtitles from a m3u8 Media object.\r\n\r\n        Args:\r\n            subtitles_media (m3u8.Media): Subtitles Media object to detect the type of.\r\n\r\n        Returns:\r\n            Optional[SubtitlesType]: The type of the subtitles, None for regular subtitles.\r\n        \"\"\"\r\n        if subtitles_media.forced == \"YES\":\r\n            return SubtitlesType.FORCED\r\n\r\n        elif subtitles_media.characteristics is not None and \"public.accessibility\" in subtitles_media.characteristics:\r\n            return SubtitlesType.CC\r\n\r\n        return None\r\n\r\n    def get_media_playlists(self, main_playlist: m3u8.M3U8,\r\n                            playlist_filters: Union[Dict[str, Union[str, List[str], Tuple[str]]], None] = None,\r\n                            include_default_filters: bool = True) -> Iterator[Media]:\r\n        \"\"\"\r\n        Find and yield playlists of media within an M3U8 main_playlist using optional filters.\r\n\r\n        Args:\r\n            main_playlist (m3u8.M3U8): an M3U8 object of the main main_playlist.\r\n            playlist_filters (dict, optional): A dictionary of filters to use when searching for subtitles.\r\n                Will be added to filters set by the config (unless `include_default_filters` is set to false).\r\n                Defaults to None.\r\n            include_default_filters (bool, optional): Whether to include the default filters set by the config or not.\r\n                Defaults to True.\r\n\r\n        Yields:\r\n            SubtitlesData: A NamedTuple with a matching main_playlist, and it's metadata:\r\n            Language Code, Language Name, SubtitlesType, Playlist URL.\r\n        \"\"\"\r\n        default_playlist_filters: Optional[dict] = self.default_filters.get(\"playlist-filters\")\r\n\r\n        if include_default_filters and default_playlist_filters:\r\n            if not playlist_filters:\r\n                playlist_filters = default_playlist_filters\r\n\r\n            else:\r\n                playlist_filters = merge_dict_values(default_playlist_filters, playlist_filters)\r\n\r\n        for media in main_playlist.media:\r\n            if playlist_filters is None:\r\n                yield media\r\n\r\n            is_valid = True\r\n\r\n            for filter_name, filter_value in playlist_filters.items():\r\n                try:\r\n                    filter_name = M3U8Scraper.M3U8Attribute(filter_name)\r\n\r\n                except ValueError:\r\n                    continue\r\n                    # TODO: Add logger warning \"invalid main_playlist filter, skipping...\"\r\n\r\n                attribute_value = getattr(media, filter_name.name.lower(), None)\r\n\r\n                if attribute_value is None:\r\n                    is_valid = False\r\n                    break\r\n\r\n                if isinstance(filter_value, (list, tuple)) and \\\r\n                        attribute_value.casefold() not in (x.casefold() for x in filter_value):\r\n                    is_valid = False\r\n                    break\r\n\r\n                elif isinstance(filter_value, str) and filter_value.casefold() != attribute_value.casefold():\r\n                    is_valid = False\r\n                    break\r\n\r\n            if not is_valid:\r\n                continue\r\n\r\n            yield media\r\n\r\n    def get_subtitles(self, main_playlist: m3u8.M3U8,\r\n                      playlist_filters: Union[Dict[str, Union[str, List[str]]], None] = None,\r\n                      subrip_conversion: bool = False) -> Iterator[SubtitlesData]:\r\n        \"\"\"\r\n        Find and yield subtitles for a movie using optional filters.\r\n\r\n        Args:\r\n            main_playlist (m3u8.M3U8): an M3U8 object of the main playlist.\r\n            playlist_filters (dict, optional): A dictionary of filters to use when searching for subtitles.\r\n                Will be added to filters set by the config. Defaults to None.\r\n            subrip_conversion (bool, optional): Whether to convert and return the subtitles as an SRT file or not.\r\n\r\n        Yields:\r\n            SubtitlesData: A SubtitlesData NamedTuple with a matching playlist, and it's metadata.\r\n        \"\"\"\r\n        if playlist_filters is None:\r\n            playlist_filters = {}\r\n\r\n        playlist_filters[\"type\"] = \"SUBTITLES\"\r\n\r\n        for matched_media in self.get_media_playlists(main_playlist=main_playlist, playlist_filters=playlist_filters):\r\n            # TODO: Add logger info \"Found subtitles for language: {matched_media.name}\"\r\n            try:\r\n                matched_media_playlist = m3u8.load(matched_media.absolute_uri)\r\n\r\n            except (ValueError, IOError) as e:\r\n                pass  # TODO: Add logger warning\r\n                continue\r\n\r\n            subtitles = self.subtitles_class(language_code=matched_media.language, language_name=matched_media.name)\r\n\r\n            for segment in self._download_segments_async(matched_media_playlist.segments):\r\n                subtitles.append_subtitles(subtitles.loads(segment.decode(\"utf-8\")))\r\n\r\n            yield SubtitlesData(\r\n                language_code=matched_media.language,\r\n                language_name=matched_media.name,\r\n                format=SubtitlesFormat.SUBRIP if subrip_conversion else SubtitlesFormat.WEBVTT,\r\n                content=subtitles.to_srt().dump() if subrip_conversion else subtitles.dump(),\r\n                special_type=self.detect_subtitles_type(matched_media),\r\n            )\r\n\r\n\r\nclass ScraperException(Exception):\r\n    pass\r\n\r\n\r\nclass ScraperFactory:\r\n    def __init__(self):\r\n        self._scrapers: list[Type[Scraper]] = [scraper_class for scraper_class in self.get_scraper_classes()]\r\n        self._scrapers_cache: dict[Type[Scraper], Scraper] = {}\r\n\r\n    def get_initialized_scrapers(self) -> list[Scraper]:\r\n        \"\"\"\r\n        Get a list of all previously initialized scrapers.\r\n\r\n        Returns:\r\n            list[Scraper]: A list of initialized scrapers.\r\n        \"\"\"\r\n        return list(self._scrapers_cache.values())\r\n\r\n    @staticmethod\r\n    def get_scraper_classes() -> Iterator[Type[Scraper]]:\r\n        \"\"\"\r\n        Find and yield all scraper classes.\r\n\r\n        Yield:\r\n            Type[Scraper]: A scraper class.\r\n        \"\"\"\r\n        scraper_modules_paths = glob(os.path.dirname(__file__) + \"/*_scraper.py\")\r\n\r\n        for scraper_module_path in scraper_modules_paths:\r\n            sys.path.append(scraper_module_path)\r\n\r\n            module = importlib.import_module(f\"{PACKAGE_NAME}.scrapers.{Path(scraper_module_path).stem}\")\r\n\r\n            # find Scraper subclasses\r\n            for name, obj in inspect.getmembers(module,\r\n                                                predicate=lambda x: inspect.isclass(x) and issubclass(x, ScraperBase)):\r\n                if inspect.isabstract(obj):\r\n                    continue\r\n\r\n                yield obj\r\n\r\n    def get_matching_scraper(self, url: str, scrapers_config_data: dict = {}) -> Scraper:\r\n        \"\"\"\r\n        Find and return a scraper that matches the given URL.\r\n\r\n        Args:\r\n            url (str): The URL to check.\r\n            scrapers_config_data (dict, optional): A dictionary containing scrapers config data to use\r\n                when creating a new scraper.\r\n\r\n        Returns:\r\n            Optional[Scraper]: An instance of the scraper that matches the given URL, or None if no match was found.\r\n        \"\"\"\r\n        for scraper in self._scrapers:\r\n            if scraper.check_url_match(url):\r\n                if scraper not in self._scrapers_cache:\r\n                    self._scrapers_cache[scraper] = scraper(config_data=scrapers_config_data.get(scraper.service_name.lower()))\r\n\r\n                return self._scrapers_cache[scraper]\r\n\r\n        raise ScraperException(f\"No scraper found for URL: {url}\")\r\n\r\n\r\ndef get_matching_scraper(url: str, config_data: Optional[dict] = None) -> Optional[Scraper]:\r\n    \"\"\"\r\n\r\n    Args:\r\n        url (str): The URL to check.\r\n        config_data (dict, optional): A dictionary of config data to use when creating a new scraper.\r\n\r\n    Returns:\r\n        Optional[Scraper]: An instance of the scraper that matches the given URL, or None if no match was found.\r\n    \"\"\"\r\n    scraper_modules_paths = glob(os.path.dirname(__file__) + \"/*_scraper.py\")\r\n\r\n    for scraper_module_path in scraper_modules_paths:\r\n        sys.path.append(scraper_module_path)\r\n\r\n        module = importlib.import_module(f\"scrapers.{Path(scraper_module_path).stem}\")\r\n\r\n        # find Scraper subclasses\r\n        for name, obj in inspect.getmembers(module,\r\n                                            predicate=lambda x: inspect.isclass(x) and issubclass(x, ScraperBase)):\r\n            if obj.check_url_match(url):\r\n                return obj(config_data=config_data)\r\n\r\n            else:\r\n                pass  # TODO: Add logger debug message \"Scraper {obj} does not match URL {url}\"\r\n    return None\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/scrapers/scraper.py b/isubrip/scrapers/scraper.py
--- a/isubrip/scrapers/scraper.py	(revision 5bab94f51efa526aa65fdf94747bf6c33c0cc978)
+++ b/isubrip/scrapers/scraper.py	(date 1678483411176)
@@ -24,7 +24,6 @@
 from isubrip.data_structures import EpisodeData, MovieData, SeasonData, SeriesData, SubtitlesData, SubtitlesFormat, SubtitlesType
 from isubrip.subtitle_formats.subtitles import Subtitles
 
-
 Scraper = TypeVar('Scraper', bound='ScraperBase')
 
 
@@ -39,26 +38,19 @@
     A metaclass for scrapers.
     This metaclass ensures only one instance of each scraper is created (singleton).
     """
-    _instances: Dict[str, ScraperBase] = {}  # TODO REFACTOR: Set checkpoint here and assure this works (only one instance of each scraper is generated for multiple links)
-
-    def __call__(cls, *args, **kwargs) -> ScraperBase:
-        if cls._instances.get(cls.__name__) is None:
-            cls._instances[cls.__name__] = super().__call__(*args, **kwargs)
-
-        return cls._instances[cls.__name__]
-
-
-class ScraperBase(ABC, metaclass=ScraperMeta):  # TODO REFACTOR: Move to ScaperMeta? Assure everything works beforehand and then test if that breaks stuff
-    """A base class for scrapers."""
-    _config_category: str = "main_playlist-filters"
-
     default_user_agent = None
-
     is_movie_scraper: bool = False
     is_series_scraper: bool = False
 
-    # --- Class Attributes ---
-    # TODO REFACTOR: Somehow assert these are set in subclasses
+    _initialized_instances: Dict[str, ScraperBase] = {}
+    _config_category: str = "playlist-filters"
+
+    def __call__(cls, *args, **kwargs) -> ScraperBase:
+        if cls._initialized_instances.get(cls.__name__) is None:
+            cls._initialized_instances[cls.__name__] = super().__call__(*args, **kwargs)
+
+        return cls._initialized_instances[cls.__name__]
+
     subtitles_class: Type[Subtitles]
     """The scraper's subtitles class."""
 
@@ -132,7 +124,7 @@
         pass
 
 
-class MovieScraper(ScraperBase, ABC, metaclass=ScraperMeta):
+class MovieScraper(ABC, metaclass=ScraperMeta):
     """
     A base class for movie scrapers.
     """
@@ -143,7 +135,7 @@
         pass
 
 
-class SeriesScraper(ScraperBase, ABC, metaclass=ScraperMeta):
+class SeriesScraper(ABC, metaclass=ScraperMeta):
     """
     A base class for TV scrapers.
     """
@@ -154,7 +146,7 @@
         pass
 
 
-class M3U8Scraper(ScraperBase, ABC, metaclass=ScraperMeta):
+class M3U8Scraper(ABC, metaclass=ScraperMeta):
     """A base class for M3U8 scrapers."""
     class M3U8Attribute(Enum):
         """
@@ -184,7 +176,7 @@
         # Add M3U8 filters settings
         self.config.add_settings([
             ConfigSetting(
-                category=ScraperBase._config_category,
+                category="playlist-filters",
                 key=m3u8_attribute.value,
                 type=Union[str, List[str]],
                 required=False,
Index: isubrip/config.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os.path\r\nimport typing\r\nfrom copy import deepcopy\r\nfrom enum import Enum, EnumMeta\r\nfrom typing import Any, Dict, List, NamedTuple, Optional, Tuple, Type, Union\r\n\r\nimport tomli\r\nfrom mergedeep import merge\r\n\r\nfrom isubrip.exceptions import ConfigValueMissing, InvalidConfigValue\r\n\r\n\r\nclass SpecialConfigType(Enum):\r\n    \"\"\"An Enum representing special config type options.\"\"\"\r\n    EXISTING_FILE_PATH = 1\r\n    EXISTING_FOLDER_PATH = 2\r\n\r\n\r\nclass ConfigSetting(NamedTuple):\r\n    key: str\r\n    type: Union[Type, typing._GenericAlias]\r\n    category: Union[str, Tuple[str, ...], List[str], None] = None\r\n    required: bool = False\r\n    enum_type: Optional[EnumMeta] = None\r\n    special_types: Union[SpecialConfigType, Tuple[SpecialConfigType, ...], List[SpecialConfigType], None] = None\r\n\r\n    def __eq__(self, other: Any) -> bool:\r\n        if isinstance(other, ConfigSetting):\r\n            return self.key == other.key and self.category == other.category\r\n        return False\r\n\r\n\r\nclass DuplicateBehavior(Enum):\r\n    \"\"\"An Enum representing optional behaviors when a duplicate is found.\"\"\"\r\n    OVERWRITE = 1\r\n    IGNORE = 2\r\n    RAISE_ERROR = 3\r\n\r\n\r\nclass Config:\r\n    \"\"\"A class for managing iSubRip config files.\"\"\"\r\n    def __init__(self, config_settings: Optional[List[ConfigSetting]] = None, config_data: Optional[Dict] = None):\r\n        \"\"\"Create a new Config instance.\"\"\"\r\n        self._config_settings: list = []\r\n        self._config_data: dict = {}\r\n\r\n        if config_settings:\r\n            self.add_settings(config_settings, check_config=False)\r\n\r\n        if config_data:\r\n            self._config_data = deepcopy(config_data)\r\n\r\n    def __getattr__(self, key: str) -> Any:\r\n        \"\"\"\r\n        Allow access to config settings using attributes.\r\n\r\n        Args:\r\n            key (str): Config key to get.\r\n\r\n        Returns:\r\n            Any: The corresponding value for the key in the config.\r\n        \"\"\"\r\n        if self._config_data and key in self._config_data:\r\n            return self._config_data[key]\r\n\r\n        else:\r\n            raise AttributeError(f\"Attribute \\'{key}\\' does not exist.\")\r\n\r\n    def __getitem__(self, key: str) -> Any:\r\n        \"\"\"\r\n        Allow access to config settings using dict-like syntax.\r\n\r\n        Args:\r\n            key (str): Config key to get.\r\n\r\n        Returns:\r\n            Any: The corresponding value for the key in the config.\r\n        \"\"\"\r\n        return self._config_data[key]\r\n\r\n    @property\r\n    def data(self):\r\n        return self._config_data\r\n\r\n    def add_settings(self, config_settings: List[ConfigSetting],\r\n                     duplicate_behavior: DuplicateBehavior = DuplicateBehavior.OVERWRITE,\r\n                     check_config: bool = True) -> None:\r\n        \"\"\"\r\n        Add new config settings to the config.\r\n\r\n        Args:\r\n            config_settings (list[ConfigSetting]): A list of ConfigSettings objects to add to the config.\r\n            duplicate_behavior (DuplicateBehavior, optional): Behaviour to apply if a duplicate is found.\r\n                Defaults to DuplicateBehavior.OVERWRITE.\r\n            check_config (bool, optional): Whether to check the config after loading it. Defaults to True.\r\n        \"\"\"\r\n        config_settings_copy = deepcopy(config_settings)\r\n\r\n        for config_setting in config_settings_copy:\r\n            if config_setting in self._config_settings:\r\n                if duplicate_behavior == DuplicateBehavior.OVERWRITE:\r\n                    self._config_settings.remove(config_setting)\r\n                    self._config_settings.append(config_setting)\r\n\r\n                elif duplicate_behavior == DuplicateBehavior.RAISE_ERROR:\r\n                    raise ValueError(f\"Duplicate config setting: {config_setting}\")\r\n\r\n            else:\r\n                self._config_settings.append(config_setting)\r\n\r\n        if check_config:\r\n            self.check()\r\n\r\n    def loads(self, config_data: str, check_config: bool = True) -> None:\r\n        \"\"\"\r\n        Parse a tomli config from a string.\r\n\r\n        Args:\r\n            config_data (str): Config file data as a string.\r\n            check_config (bool, optional): Whether to check the config after loading it. Defaults to True.\r\n\r\n        Raises:\r\n            FileNotFoundError: Config file could not be found in the specified path.\r\n            TOMLDecodeError: Config file is not a valid TOML file.\r\n            ConfigValueMissing: A required config value is missing.\r\n            InvalidConfigValue: An invalid value was used in the config file.\r\n        \"\"\"\r\n        # Load settings from default config file\r\n        loaded_data: dict = tomli.loads(config_data)\r\n\r\n        if self._config_data:\r\n            temp_config: dict = dict(merge(self._config_data, loaded_data))\r\n\r\n        else:\r\n            temp_config: dict = loaded_data\r\n\r\n        self._config_data = temp_config\r\n\r\n        if check_config and self._config_settings:\r\n            self.check()\r\n\r\n    @staticmethod\r\n    def _map_config_settings(settings: List[ConfigSetting], data: dict) -> Dict[ConfigSetting, Any]:\r\n        \"\"\"\r\n        Map config settings to their values.\r\n        This function wil also unflatten data.\r\n\r\n        Args:\r\n            settings (list[ConfigSetting]): A list or tuple of ConfigSettings objects.\r\n            data (dict): A dictionary containing the config data.\r\n\r\n        Returns:\r\n            dict[ConfigSetting, Any]: A dictionary mapping config settings to their values.\r\n        \"\"\"\r\n        mapped_settings: Dict[ConfigSetting, Any] = {}\r\n\r\n        for setting in settings:\r\n            if setting.category:\r\n                if isinstance(setting.category, str):\r\n                    setting_categories = (setting.category,)\r\n\r\n                elif isinstance(setting.category, type(None)):\r\n                    setting_categories = ()\r\n\r\n                else:\r\n                    setting_categories = setting.category\r\n\r\n                config_dict_iter: dict = data\r\n\r\n                for setting_category in setting_categories:\r\n                    if setting_category not in config_dict_iter:\r\n                        mapped_settings[setting] = None\r\n                        break\r\n\r\n                    config_dict_iter = config_dict_iter[setting_category]\r\n\r\n            else:\r\n                config_dict_iter = data\r\n\r\n            if setting.key not in config_dict_iter:\r\n                mapped_settings[setting] = None\r\n\r\n            else:\r\n                value = config_dict_iter[setting.key]\r\n\r\n                if setting.enum_type is not None:\r\n                    try:\r\n                        value = setting.enum_type(value)\r\n\r\n                    except ValueError:\r\n                        setting_path = '.'.join(setting.category)\r\n                        enum_options = ', '.join(item.value for item in setting.enum_type)\r\n\r\n                        raise InvalidConfigValue(\r\n                            f\"Invalid config value for {setting_path}.{setting.key}: \\'{value}\\'.\\n\"\r\n                            f\"Expected one of: {enum_options}.\")\r\n\r\n                if type(value) in (list, tuple) and len(value) == 0:\r\n                    value = None\r\n\r\n                if isinstance(setting.special_types, SpecialConfigType):\r\n                    special_types = (setting.special_types,)\r\n\r\n                elif isinstance(setting.special_types, type(None)):\r\n                    special_types = ()\r\n\r\n                else:\r\n                    special_types = setting.special_types\r\n\r\n                if SpecialConfigType.EXISTING_FILE_PATH in special_types:\r\n                    value = value.rstrip(r\"\\/\")\r\n\r\n                mapped_settings[setting] = value\r\n\r\n        return mapped_settings\r\n\r\n    def check(self) -> None:\r\n        \"\"\"\r\n            Check whether the config is valid by comparing config's data to the config settings.\r\n            Raises an error if an invalid value is found.\r\n\r\n        Raises:\r\n            ConfigValueMissing: A required config value is missing.\r\n            InvalidConfigValue: An invalid value was used in the config file.\r\n        \"\"\"\r\n        if self._config_data is None or not self._config_settings:\r\n            return\r\n\r\n        mapped_config = Config._map_config_settings(self._config_settings, self._config_data)  # TODO: Keep in instance and update only when settings / data is updated?\r\n\r\n        for setting, value in mapped_config.items():\r\n            if isinstance(setting.category, (list, tuple)):\r\n                setting_path = '.'.join(setting.category) + f\".{setting.key}\"\r\n\r\n            elif isinstance(setting.category, str):\r\n                setting_path = setting.category + f\".{setting.key}\"\r\n\r\n            else:\r\n                setting_path = setting.key\r\n\r\n            if value is None:\r\n                if setting.required:\r\n                    raise ConfigValueMissing(f\"Missing required config value: '{setting_path}'\")\r\n\r\n                else:\r\n                    continue\r\n\r\n            if setting.enum_type is None and not check_type(value, setting.type):\r\n                raise InvalidConfigValue(\r\n                    f\"Invalid config value type for '{setting_path}': '{value}'.\\n\"\r\n                    f\"Expected {setting.type}, received: {type(value)}.\")\r\n\r\n            # Special type checks\r\n            if isinstance(setting.special_types, SpecialConfigType):\r\n                special_types = (setting.special_types,)\r\n\r\n            elif isinstance(setting.special_types, type(None)):\r\n                special_types = ()\r\n\r\n            else:\r\n                special_types = setting.special_types\r\n\r\n            if SpecialConfigType.EXISTING_FILE_PATH in special_types:\r\n                if not os.path.isfile(value):\r\n                    raise InvalidConfigValue(f\"Invalid config value type for '{setting_path}'.\\n\"\r\n                                             f\"\\nFile '{value}' not found.\")\r\n\r\n            elif SpecialConfigType.EXISTING_FOLDER_PATH in special_types:\r\n                if not os.path.isdir(value):\r\n                    raise InvalidConfigValue(f\"Invalid config value type for '{setting_path}'.\\n\"\r\n                                             f\"\\nFolder '{value}' not found.\")\r\n\r\n\r\ndef check_type(value, type_) -> bool:\r\n    \"\"\"\r\n    Check if a value is of a certain type.\r\n    Works with typing module types.\r\n\r\n    Args:\r\n        value: Value to check.\r\n        type_: Type to check against.\r\n\r\n    Returns:\r\n        bool: True if the value is of the specified type, False otherwise.\r\n    \"\"\"\r\n    if hasattr(type_, \"__origin__\"):\r\n        if type_.__origin__ is Union:\r\n            return any(check_type(value, union_sub_type) for union_sub_type in type_.__args__)\r\n\r\n        elif type_.__origin__ is tuple:\r\n            if type_.__args__[-1] is Ellipsis:\r\n                return check_type(value, Tuple[type_.__args__[:-1]])\r\n\r\n            return isinstance(value, tuple) and \\\r\n                all(check_type(value, tuple_type) for value, tuple_type in zip(value, type_.__args__))\r\n\r\n        elif type_.__origin__ is list:\r\n            return isinstance(value, list) and \\\r\n                all(check_type(item, type_.__args__[0]) for item in value)\r\n\r\n        elif type_.__origin__ is dict:\r\n            return isinstance(value, dict) and \\\r\n                all(check_type(k, type_.__args__[0]) and check_type(v, type_.__args__[1]) for k, v in value.items())\r\n\r\n    return isinstance(value, type_)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/config.py b/isubrip/config.py
--- a/isubrip/config.py	(revision 5bab94f51efa526aa65fdf94747bf6c33c0cc978)
+++ b/isubrip/config.py	(date 1678483271162)
@@ -10,6 +10,13 @@
 from isubrip.exceptions import ConfigValueMissing, InvalidConfigValue
 
 
+class DuplicateBehavior(Enum):
+    """An Enum representing optional behaviors when a duplicate is found."""
+    OVERWRITE = 1
+    IGNORE = 2
+    RAISE_ERROR = 3
+
+
 class SpecialConfigType(Enum):
     """An Enum representing special config type options."""
     EXISTING_FILE_PATH = 1
@@ -17,6 +24,12 @@
 
 
 class ConfigSetting(NamedTuple):
+    """
+    A NamedTuple representing a config setting.
+
+    Attributes:
+          # TODO REFACTOR
+    """
     key: str
     type: Union[Type, typing._GenericAlias]
     category: Union[str, Tuple[str, ...], List[str], None] = None
@@ -30,17 +43,17 @@
         return False
 
 
-class DuplicateBehavior(Enum):
-    """An Enum representing optional behaviors when a duplicate is found."""
-    OVERWRITE = 1
-    IGNORE = 2
-    RAISE_ERROR = 3
-
-
 class Config:
     """A class for managing iSubRip config files."""
     def __init__(self, config_settings: Optional[List[ConfigSetting]] = None, config_data: Optional[Dict] = None):
-        """Create a new Config instance."""
+        """
+        Create a new Config instance.
+
+        Args:
+            config_settings (list[ConfigSetting], optional): A list of ConfigSettings objects
+                that will be used for validations. Defaults to None.
+            config_data (dict, optional): A dict of config data to add to the config. Defaults to None.
+        """
         self._config_settings: list = []
         self._config_data: dict = {}
 
@@ -156,7 +169,7 @@
 
         for setting in settings:
             if setting.category:
-                if isinstance(setting.category, str):
+                if isinstance(setting.category, str):  # TODO: Create a function for this tuple conversion if single
                     setting_categories = (setting.category,)
 
                 elif isinstance(setting.category, type(None)):
