Index: isubrip/utils.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nfrom abc import ABCMeta\r\nimport datetime as dt\r\nfrom functools import lru_cache\r\nfrom pathlib import Path\r\nimport re\r\nimport secrets\r\nimport shutil\r\nimport sys\r\nfrom typing import TYPE_CHECKING, Any, Type, Union, get_args, get_origin\r\n\r\nfrom isubrip.constants import TEMP_FOLDER_PATH, TITLE_REPLACEMENT_STRINGS, WINDOWS_RESERVED_FILE_NAMES\r\nfrom isubrip.data_structures import (\r\n    Episode,\r\n    MediaBase,\r\n    Movie,\r\n    Season,\r\n    Series,\r\n    SubtitlesData,\r\n    SubtitlesFormatType,\r\n    SubtitlesType,\r\n)\r\nfrom isubrip.logger import logger\r\n\r\nif TYPE_CHECKING:\r\n    from os import PathLike\r\n    from types import TracebackType\r\n\r\n    import httpx\r\n\r\n\r\nclass SingletonMeta(ABCMeta):\r\n    \"\"\"\r\n    A metaclass that implements the Singleton pattern.\r\n    When a class using this metaclass is initialized, it will return the same instance every time.\r\n    \"\"\"\r\n    _instances: dict[object, object] = {}\r\n\r\n    def __call__(cls, *args: Any, **kwargs: Any) -> object:\r\n        if cls._instances.get(cls) is None:\r\n            cls._instances[cls] = super().__call__(*args, **kwargs)\r\n\r\n        return cls._instances[cls]\r\n\r\n\r\nclass TempDirGenerator:\r\n    \"\"\"A class for generating temporary directories, and disposing them once the object is destroyed.\"\"\"\r\n    _generated_temp_directories: list[Path] = []\r\n\r\n    def __exit__(self, exc_type: Type[BaseException] | None,\r\n                 exc_val: BaseException | None, exc_tb: TracebackType | None) -> None:\r\n        self.cleanup()\r\n\r\n    @classmethod\r\n    def generate(cls, directory_name: str | None = None) -> Path:\r\n        \"\"\"\r\n        Generate a temporary directory within 'TEMP_FOLDER_PATH'.\r\n\r\n        Args:\r\n            directory_name (str | None, optional): Name of the directory to generate.\r\n                If not specified, a random string will be generated. Defaults to None.\r\n\r\n        Returns:\r\n            Path: Path to the generated directory.\r\n        \"\"\"\r\n        directory_name = directory_name or secrets.token_hex(5)\r\n        full_path = TEMP_FOLDER_PATH / directory_name\r\n\r\n        if full_path.is_dir():\r\n            if full_path in cls._generated_temp_directories:  # Generated by this class\r\n                logger.debug(f\"Using previously generated temporary directory: '{full_path}'.\")\r\n                return full_path\r\n\r\n            logger.debug(f\"Temporary directory '{full_path}' already exists. \"\r\n                         f\"Emptying the directory from all contents...\")\r\n            shutil.rmtree(full_path)\r\n            full_path.mkdir(parents=True)\r\n\r\n        else:\r\n            full_path.mkdir(parents=True)\r\n            logger.debug(f\"Temporary directory has been generated: '{full_path}'\")\r\n\r\n        cls._generated_temp_directories.append(full_path)\r\n        return full_path\r\n\r\n    @classmethod\r\n    def cleanup(cls) -> None:\r\n        \"\"\"Remove all temporary directories generated by this object.\"\"\"\r\n        for temp_directory in cls._generated_temp_directories:\r\n            logger.debug(f\"Removing temporary directory: '{temp_directory}'\")\r\n\r\n            try:\r\n                shutil.rmtree(temp_directory)\r\n\r\n            except Exception as e:\r\n                logger.debug(f\"Failed to remove temporary directory '{temp_directory}': {e}\")\r\n\r\n        cls._generated_temp_directories = []\r\n\r\n\r\ndef check_type(value: Any, type_) -> bool:  # type: ignore[no-untyped-def]\r\n    \"\"\"\r\n    Check if a value is of a certain type.\r\n    Works with parameterized generics.\r\n\r\n    Args:\r\n        value (Any): Value to check.\r\n        type_: Type to check against.\r\n\r\n    Returns:\r\n        bool: True if the value is of the specified type, False otherwise.\r\n    \"\"\"\r\n    origin = get_origin(type_)\r\n    args = get_args(type_)\r\n\r\n    if origin is Union:\r\n        return any(check_type(value, union_sub_type) for union_sub_type in args)\r\n\r\n    if origin is tuple:\r\n        if args[-1] is Ellipsis:\r\n            # Example: (int, str, ...)\r\n            args_len = len(args)\r\n\r\n            return check_type(value[:args_len - 1], tuple(args[:-1])) and \\\r\n                all(check_type(item, args[-2]) for item in value[args_len - 1:])\r\n\r\n        return isinstance(value, tuple) and \\\r\n            len(value) == len(args) and \\\r\n            all(check_type(item, item_type) for item, item_type in zip(value, args))\r\n\r\n    if origin is list:\r\n        return isinstance(value, list) and \\\r\n            all(check_type(item, args[0]) for item in value)\r\n\r\n    if origin is dict:\r\n        return isinstance(value, dict) and \\\r\n            all(check_type(k, args[0]) and check_type(v, args[1]) for k, v in value.items())\r\n\r\n    return isinstance(value, type_)\r\n\r\n\r\ndef convert_epoch_to_datetime(epoch_timestamp: int) -> dt.datetime:\r\n    \"\"\"\r\n    Convert an epoch timestamp to a datetime object.\r\n\r\n    Args:\r\n        epoch_timestamp (int): Epoch timestamp.\r\n\r\n    Returns:\r\n        datetime: A datetime object representing the timestamp.\r\n    \"\"\"\r\n    if epoch_timestamp >= 0:\r\n        return dt.datetime.fromtimestamp(epoch_timestamp)\r\n\r\n    return dt.datetime(1970, 1, 1) + dt.timedelta(seconds=epoch_timestamp)\r\n\r\n\r\ndef download_subtitles_to_file(media_data: Movie | Episode, subtitles_data: SubtitlesData, output_path: str | PathLike,\r\n                               source_abbreviation: str | None = None, overwrite: bool = False) -> Path:\r\n    \"\"\"\r\n    Download subtitles to a file.\r\n\r\n    Args:\r\n        media_data (Movie | Episode): An object containing media data.\r\n        subtitles_data (SubtitlesData): A SubtitlesData object containing subtitles data.\r\n        output_path (str | PathLike): Path to the output folder.\r\n        source_abbreviation (str | None, optional): Abbreviation of the source the subtitles are downloaded from.\r\n            Defaults to None.\r\n        overwrite (bool, optional): Whether to overwrite files if they already exist. Defaults to True.\r\n\r\n    Returns:\r\n        Path: Path to the downloaded subtitles file.\r\n\r\n    Raises:\r\n        ValueError: If the path in `output_path` does not exist.\r\n    \"\"\"\r\n    output_path = Path(output_path)\r\n\r\n    if not output_path.is_dir():\r\n        raise ValueError(f\"Invalid path: {output_path}\")\r\n\r\n    if isinstance(media_data, Movie):\r\n        file_name = format_release_name(title=media_data.name,\r\n                                        release_date=media_data.release_date,\r\n                                        media_source=source_abbreviation,\r\n                                        language_code=subtitles_data.language_code,\r\n                                        subtitles_type=subtitles_data.special_type,\r\n                                        file_format=subtitles_data.subtitles_format)\r\n    else:  # isinstance(media_data, Episode):\r\n        file_name = format_release_name(title=media_data.series_name,\r\n                                        release_date=media_data.release_date,\r\n                                        season_number=media_data.season_number,\r\n                                        episode_number=media_data.episode_number,\r\n                                        episode_name=media_data.episode_name,\r\n                                        media_source=source_abbreviation,\r\n                                        language_code=subtitles_data.language_code,\r\n                                        subtitles_type=subtitles_data.special_type,\r\n                                        file_format=subtitles_data.subtitles_format)\r\n\r\n    file_path = output_path / file_name\r\n\r\n    if file_path.exists() and not overwrite:\r\n        file_path = generate_non_conflicting_path(file_path=file_path)\r\n\r\n    with file_path.open('wb') as f:\r\n        f.write(subtitles_data.content)\r\n\r\n    return file_path\r\n\r\n\r\ndef format_media_description(media_data: MediaBase, shortened: bool = False) -> str:\r\n    \"\"\"\r\n    Generate a short description string of a media object.\r\n\r\n    Args:\r\n        media_data (MediaBase): An object containing media data.\r\n        shortened (bool, optional): Whether to generate a shortened description. Defaults to False.\r\n\r\n    Returns:\r\n        str: A short description string of the media object.\r\n    \"\"\"\r\n    if isinstance(media_data, Movie):\r\n        release_year = (\r\n            media_data.release_date.year\r\n            if isinstance(media_data.release_date, dt.datetime)\r\n            else media_data.release_date\r\n        )\r\n        description_str = f\"{media_data.name} [{release_year}]\"\r\n\r\n        if media_data.id:\r\n            description_str += f\" (ID: {media_data.id})\"\r\n\r\n        return description_str\r\n\r\n    if isinstance(media_data, Series):\r\n        description_str = f\"{media_data.series_name}\"\r\n\r\n        if media_data.series_release_date:\r\n            if isinstance(media_data.series_release_date, dt.datetime):\r\n                description_str += f\" [{media_data.series_release_date.year}]\"\r\n\r\n            else:\r\n                description_str += f\" [{media_data.series_release_date}]\"\r\n\r\n        if media_data.id:\r\n            description_str += f\" (ID: {media_data.id})\"\r\n\r\n        return description_str\r\n\r\n    if isinstance(media_data, Season):\r\n        if shortened:\r\n            description_str = f\"Season {media_data.season_number:02d}\"\r\n\r\n        else:\r\n            description_str = f\"{media_data.series_name} - Season {media_data.season_number:02d}\"\r\n\r\n        if media_data.season_name:\r\n            description_str += f\" - {media_data.season_name}\"\r\n\r\n        if media_data.id:\r\n            description_str += f\" (ID: {media_data.id})\"\r\n\r\n        return description_str\r\n\r\n    if isinstance(media_data, Episode):\r\n        if shortened:\r\n            description_str = f\"S{media_data.season_number:02d}E{media_data.episode_number:02d}\"\r\n\r\n        else:\r\n            description_str = (f\"{media_data.series_name} - \"\r\n                               f\"S{media_data.season_number:02d}E{media_data.episode_number:02d}\")\r\n\r\n        if media_data.episode_name:\r\n            description_str += f\" - {media_data.episode_name}\"\r\n\r\n        if media_data.id:\r\n            description_str += f\" (ID: {media_data.id})\"\r\n\r\n        return description_str\r\n\r\n    raise ValueError(f\"Unsupported media type: '{type(media_data)}'\")\r\n\r\n\r\n@lru_cache\r\ndef format_release_name(title: str,\r\n                        release_date: dt.datetime | int | None = None,\r\n                        season_number: int | None = None,\r\n                        episode_number: int | None = None,\r\n                        episode_name: str | None = None,\r\n                        media_source: str | None = None,\r\n                        source_type: str | None = \"WEB\",\r\n                        additional_info: str | list[str] | None = None,\r\n                        language_code: str | None = None,\r\n                        subtitles_type: SubtitlesType | None = None,\r\n                        file_format: str | SubtitlesFormatType | None = None) -> str:\r\n    \"\"\"\r\n    Format a release name.\r\n\r\n    Args:\r\n        title (str): Media title.\r\n        release_date (int | None, optional): Release date (datetime), or year (int) of the media. Defaults to None.\r\n        season_number (int | None, optional): Season number. Defaults to None.\r\n        episode_number (int | None, optional): Episode number. Defaults to None.\r\n        episode_name (str | None, optional): Episode name. Defaults to None.\r\n        media_source (str | None, optional): Media source name (full or abbreviation). Defaults to None.\r\n        source_type(str | None, optional): General source type (WEB, BluRay, etc.). Defaults to None.\r\n        additional_info (list[str] | str | None, optional): Additional info to add to the file name. Defaults to None.\r\n        language_code (str | None, optional): Language code. Defaults to None.\r\n        subtitles_type (SubtitlesType | None, optional): Subtitles type. Defaults to None.\r\n        file_format (SubtitlesFormat | str | None, optional): File format to use.  Defaults to None.\r\n\r\n    Returns:\r\n        str: Generated file name.\r\n    \"\"\"\r\n    file_name = standardize_title(title).rstrip('.')\r\n\r\n    if release_date is not None:\r\n        if isinstance(release_date, dt.datetime):\r\n            release_year = release_date.year\r\n\r\n        else:\r\n            release_year = release_date\r\n\r\n        file_name += f\".{release_year}\"\r\n\r\n    if season_number is not None and episode_number is not None:\r\n        file_name += f\".S{season_number:02}E{episode_number:02}\"\r\n\r\n    if episode_name is not None:\r\n        file_name += f\".{standardize_title(episode_name).rstrip('.')}\"\r\n\r\n    if media_source is not None:\r\n        file_name += f\".{media_source}\"\r\n\r\n    if source_type is not None:\r\n        file_name += f\".{source_type}\"\r\n\r\n    if additional_info is not None:\r\n        if isinstance(additional_info, (list, tuple)):\r\n            additional_info = '.'.join(additional_info)\r\n\r\n        file_name += f\".{additional_info}\"\r\n\r\n    if language_code is not None:\r\n        file_name += f\".{language_code}\"\r\n\r\n    if subtitles_type is not None:\r\n        file_name += f\".{subtitles_type.value.lower()}\"\r\n\r\n    if file_format is not None:\r\n        if isinstance(file_format, SubtitlesFormatType):\r\n            file_format = file_format.value.file_extension\r\n\r\n        file_name += f\".{file_format}\"\r\n\r\n    return file_name\r\n\r\n\r\ndef format_subtitles_description(language_code: str, language_name: str | None = None,\r\n                                 special_type: SubtitlesType | None = None) -> str:\r\n    if language_name:\r\n        language_str = f\"{language_name} ({language_code})\"\r\n\r\n    else:\r\n        language_str = language_code\r\n\r\n    if special_type:\r\n        language_str += f\" [{special_type.value}]\"\r\n\r\n    return language_str\r\n\r\n\r\ndef generate_non_conflicting_path(file_path: Path, has_extension: bool = True) -> Path:\r\n    \"\"\"\r\n    Generate a non-conflicting path for a file.\r\n    If the file already exists, a number will be added to the end of the file name.\r\n\r\n    Args:\r\n        file_path (Path): Path to a file.\r\n        has_extension (bool, optional): Whether the name of the file includes file extension. Defaults to True.\r\n\r\n    Returns:\r\n        Path: A non-conflicting file path.\r\n    \"\"\"\r\n    if isinstance(file_path, str):\r\n        file_path = Path(file_path)\r\n\r\n    if not file_path.exists():\r\n        return file_path\r\n\r\n    i = 1\r\n    while True:\r\n        if has_extension:\r\n            new_file_path = file_path.parent / f\"{file_path.stem}-{i}{file_path.suffix}\"\r\n\r\n        else:\r\n            new_file_path = file_path.parent / f\"{file_path}-{i}\"\r\n\r\n        if not new_file_path.exists():\r\n            return new_file_path\r\n\r\n        i += 1\r\n\r\n\r\ndef merge_dict_values(*dictionaries: dict) -> dict:\r\n    \"\"\"\r\n    A function for merging the values of multiple dictionaries using the same keys.\r\n    If a key already exists, the value will be added to a list of values mapped to that key.\r\n\r\n    Examples:\r\n        merge_dict_values({'a': 1, 'b': 3}, {'a': 2, 'b': 4}) -> {'a': [1, 2], 'b': [3, 4]}\r\n        merge_dict_values({'a': 1, 'b': 2}, {'a': 1, 'b': [2, 3]}) -> {'a': 1, 'b': [2, 3]}\r\n\r\n    Note:\r\n        This function support only merging of lists or single items (no tuples or other iterables),\r\n        and without any nesting (lists within lists).\r\n\r\n    Args:\r\n        *dictionaries (dict): Dictionaries to merge.\r\n\r\n    Returns:\r\n        dict: A merged dictionary.\r\n    \"\"\"\r\n    _dictionaries: list[dict] = [d for d in dictionaries if d]\r\n\r\n    if len(_dictionaries) == 0:\r\n        return {}\r\n\r\n    if len(_dictionaries) == 1:\r\n        return _dictionaries[0]\r\n\r\n    result: dict = {}\r\n\r\n    for _dict in _dictionaries:\r\n        for key, value in _dict.items():\r\n            if key in result:\r\n                if isinstance(result[key], list):\r\n                    if isinstance(value, list):\r\n                        result[key].extend(value)\r\n                    else:\r\n                        result[key].append(value)\r\n                else:\r\n                    if isinstance(value, list):\r\n                        result[key] = [result[key], *value]\r\n                    else:\r\n                        result[key] = [result[key], value]\r\n            else:\r\n                result[key] = value\r\n\r\n    return result\r\n\r\n\r\ndef raise_for_status(response: httpx.Response) -> None:\r\n    \"\"\"\r\n    Raise an exception if the response status code is invalid.\r\n    Uses 'response.raise_for_status()' internally, with additional logging.\r\n\r\n    Args:\r\n        response (httpx.Response): A response object.\r\n    \"\"\"\r\n    truncation_threshold = 1500\r\n\r\n    if not response.is_error:\r\n        return\r\n\r\n    if len(response.text) > truncation_threshold:\r\n        # Truncate the response as in some cases there could be an unexpected long HTML response\r\n        response_text = response.text[:truncation_threshold].rstrip() + \" <TRUNCATED...>\"\r\n\r\n    else:\r\n        response_text = response.text\r\n\r\n    logger.debug(f\"Response status code: {response.status_code}\")\r\n\r\n    if response.headers.get('Content-Type'):\r\n        logger.debug(f\"Response type: {response.headers['Content-Type']}\")\r\n\r\n    logger.debug(f\"Response text: {response_text}\")\r\n\r\n    response.raise_for_status()\r\n\r\n\r\ndef parse_url_params(url_params: str) -> dict:\r\n    \"\"\"\r\n    Parse GET parameters from a URL to a dictionary.\r\n\r\n    Args:\r\n        url_params (str): URL parameters. (e.g. 'param1=value1&param2=value2')\r\n\r\n    Returns:\r\n        dict: A dictionary containing the URL parameters.\r\n    \"\"\"\r\n    url_params = url_params.split('?')[-1].rstrip('&')\r\n    params_list = url_params.split('&')\r\n\r\n    if len(params_list) == 0 or \\\r\n            (len(params_list) == 1 and '=' not in params_list[0]):\r\n        return {}\r\n\r\n    return {key: value for key, value in (param.split('=') for param in params_list)}\r\n\r\n\r\ndef single_to_list(obj: Any) -> list:\r\n    \"\"\"\r\n    Convert a single non-iterable object to a list.\r\n    If None is passed, an empty list will be returned.\r\n\r\n    Args:\r\n        obj: Object to convert.\r\n\r\n    Returns:\r\n        list: A list containing the object.\r\n            If the object is already an iterable, it will be converted to a list.\r\n    \"\"\"\r\n    if isinstance(obj, list):\r\n        return obj\r\n\r\n    if obj is None:\r\n        return []\r\n\r\n    # tuple (not a namedtuple) or a set\r\n    if (isinstance(obj, tuple) and not hasattr(obj, '_fields')) or isinstance(obj, set):\r\n        return list(obj)\r\n\r\n    return [obj]\r\n\r\n\r\ndef split_subtitles_timestamp(timestamp: str) -> tuple[dt.time, dt.time]:\r\n    \"\"\"\r\n    Split a subtitles timestamp into start and end.\r\n\r\n    Args:\r\n        timestamp (str): A subtitles timestamp. For example: \"00:00:00.000 --> 00:00:00.000\"\r\n\r\n    Returns:\r\n        tuple(time, time): A tuple containing start and end times as a datetime object.\r\n    \"\"\"\r\n    # Support ',' character in timestamp's milliseconds (used in SubRip format).\r\n    timestamp = timestamp.replace(',', '.')\r\n\r\n    start_time, end_time = timestamp.split(\" --> \")\r\n    return dt.time.fromisoformat(start_time), dt.time.fromisoformat(end_time)\r\n\r\n\r\n@lru_cache\r\ndef standardize_title(title: str) -> str:\r\n    \"\"\"\r\n    Format movie title to a standardized title that can be used as a file name.\r\n\r\n    Args:\r\n        title (str): A movie title.\r\n\r\n    Returns:\r\n        str: The movie title, in a file-name-friendly format.\r\n    \"\"\"\r\n    title = title.strip()\r\n\r\n    for string, replacement_string in TITLE_REPLACEMENT_STRINGS.items():\r\n        title = title.replace(string, replacement_string)\r\n\r\n    title = re.sub(r\"\\.+\", \".\", title)  # Replace multiple dots with a single dot\r\n\r\n    # If running on Windows, rename Windows reserved names to allow file creation\r\n    if sys.platform == 'win32':\r\n        split_title = title.split('.')\r\n\r\n        if split_title[0].upper() in WINDOWS_RESERVED_FILE_NAMES:\r\n            if len(split_title) > 1:\r\n                return split_title[0] + split_title[1] + '.'.join(split_title[2:])\r\n\r\n            if len(split_title) == 1:\r\n                return \"_\" + title\r\n\r\n    return title\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/utils.py b/isubrip/utils.py
--- a/isubrip/utils.py	(revision d3b0ef086b2efeb43e52af4565060033c2307487)
+++ b/isubrip/utils.py	(date 1724110280840)
@@ -8,7 +8,7 @@
 import secrets
 import shutil
 import sys
-from typing import TYPE_CHECKING, Any, Type, Union, get_args, get_origin
+from typing import TYPE_CHECKING, Any, Type
 
 from isubrip.constants import TEMP_FOLDER_PATH, TITLE_REPLACEMENT_STRINGS, WINDOWS_RESERVED_FILE_NAMES
 from isubrip.data_structures import (
@@ -99,47 +99,6 @@
         cls._generated_temp_directories = []
 
 
-def check_type(value: Any, type_) -> bool:  # type: ignore[no-untyped-def]
-    """
-    Check if a value is of a certain type.
-    Works with parameterized generics.
-
-    Args:
-        value (Any): Value to check.
-        type_: Type to check against.
-
-    Returns:
-        bool: True if the value is of the specified type, False otherwise.
-    """
-    origin = get_origin(type_)
-    args = get_args(type_)
-
-    if origin is Union:
-        return any(check_type(value, union_sub_type) for union_sub_type in args)
-
-    if origin is tuple:
-        if args[-1] is Ellipsis:
-            # Example: (int, str, ...)
-            args_len = len(args)
-
-            return check_type(value[:args_len - 1], tuple(args[:-1])) and \
-                all(check_type(item, args[-2]) for item in value[args_len - 1:])
-
-        return isinstance(value, tuple) and \
-            len(value) == len(args) and \
-            all(check_type(item, item_type) for item, item_type in zip(value, args))
-
-    if origin is list:
-        return isinstance(value, list) and \
-            all(check_type(item, args[0]) for item in value)
-
-    if origin is dict:
-        return isinstance(value, dict) and \
-            all(check_type(k, args[0]) and check_type(v, args[1]) for k, v in value.items())
-
-    return isinstance(value, type_)
-
-
 def convert_epoch_to_datetime(epoch_timestamp: int) -> dt.datetime:
     """
     Convert an epoch timestamp to a datetime object.
@@ -451,6 +410,19 @@
     return result
 
 
+def normalize_config_name(name: str) -> str:
+    """
+    Normalize a config category / field name (used for creating an alias).
+
+    Args:
+        name (str): The name to normalize.
+
+    Returns:
+        str: The normalized name.
+    """
+    return name.lower().replace('-', '_')
+
+
 def raise_for_status(response: httpx.Response) -> None:
     """
     Raise an exception if the response status code is invalid.
@@ -501,7 +473,7 @@
     return {key: value for key, value in (param.split('=') for param in params_list)}
 
 
-def single_to_list(obj: Any) -> list:
+def single_to_list(obj: Any) -> list:  # TODO: set to str only to fix mypy issues?
     """
     Convert a single non-iterable object to a list.
     If None is passed, an empty list will be returned.
Index: isubrip/__main__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nimport asyncio\r\nimport logging\r\nfrom pathlib import Path\r\nimport shutil\r\nimport sys\r\nfrom typing import List, Union\r\n\r\nimport httpx\r\n\r\nfrom isubrip.config import Config, ConfigError, ConfigSetting, SpecialConfigType\r\nfrom isubrip.constants import (\r\n    ARCHIVE_FORMAT,\r\n    DATA_FOLDER_PATH,\r\n    DEFAULT_CONFIG_PATH,\r\n    EVENT_LOOP,\r\n    LOG_FILE_NAME,\r\n    LOG_FILES_PATH,\r\n    PACKAGE_NAME,\r\n    PACKAGE_VERSION,\r\n    PREORDER_MESSAGE,\r\n    TEMP_FOLDER_PATH,\r\n    USER_CONFIG_FILE,\r\n)\r\nfrom isubrip.data_structures import (\r\n    Episode,\r\n    MediaData,\r\n    Movie,\r\n    ScrapedMediaResponse,\r\n    Season,\r\n    Series,\r\n    SubtitlesData,\r\n    SubtitlesDownloadResults,\r\n)\r\nfrom isubrip.logger import CustomLogFileFormatter, CustomStdoutFormatter, logger\r\nfrom isubrip.scrapers.scraper import PlaylistLoadError, Scraper, ScraperError, ScraperFactory, SubtitlesDownloadError\r\nfrom isubrip.subtitle_formats.webvtt import WebVTTCaptionBlock\r\nfrom isubrip.utils import (\r\n    TempDirGenerator,\r\n    download_subtitles_to_file,\r\n    format_media_description,\r\n    format_release_name,\r\n    format_subtitles_description,\r\n    generate_non_conflicting_path,\r\n    raise_for_status,\r\n    single_to_list,\r\n)\r\n\r\nLOG_ROTATION_SIZE: int | None = None\r\n\r\nBASE_CONFIG_SETTINGS = [\r\n    ConfigSetting(\r\n        key=\"check-for-updates\",\r\n        value_type=bool,\r\n        category=\"general\",\r\n        required=False,\r\n    ),\r\n    ConfigSetting(\r\n        key=\"log_rotation_size\",\r\n        value_type=str,\r\n        category=\"general\",\r\n        required=False,\r\n    ),\r\n    ConfigSetting(\r\n        key=\"add-release-year-to-series\",\r\n        value_type=bool,\r\n        category=\"downloads\",\r\n        required=False,\r\n    ),\r\n    ConfigSetting(\r\n        key=\"folder\",\r\n        value_type=str,\r\n        category=\"downloads\",\r\n        required=True,\r\n        special_type=SpecialConfigType.EXISTING_FOLDER_PATH,\r\n    ),\r\n    ConfigSetting(\r\n        key=\"languages\",\r\n        value_type=List[str],\r\n        category=\"downloads\",\r\n        required=False,\r\n    ),\r\n    ConfigSetting(\r\n        key=\"overwrite-existing\",\r\n        value_type=bool,\r\n        category=\"downloads\",\r\n        required=True,\r\n    ),\r\n    ConfigSetting(\r\n        key=\"zip\",\r\n        value_type=bool,\r\n        category=\"downloads\",\r\n        required=False,\r\n    ),\r\n    ConfigSetting(\r\n        key=\"fix-rtl\",\r\n        value_type=bool,\r\n        category=\"subtitles\",\r\n        required=True,\r\n    ),\r\n    ConfigSetting(\r\n        key=\"rtl-languages\",\r\n        value_type=List[str],\r\n        category=\"subtitles\",\r\n        required=False,\r\n    ),\r\n    ConfigSetting(\r\n        key=\"remove-duplicates\",\r\n        value_type=bool,\r\n        category=\"subtitles\",\r\n        required=True,\r\n    ),\r\n    ConfigSetting(\r\n        key=\"convert-to-srt\",\r\n        value_type=bool,\r\n        category=\"subtitles\",\r\n        required=False,\r\n    ),\r\n    ConfigSetting(\r\n        key=\"subrip-alignment-conversion\",\r\n        value_type=bool,\r\n        category=(\"subtitles\", \"webvtt\"),\r\n        required=False,\r\n    ),\r\n    ConfigSetting(\r\n        key=\"timeout\",\r\n        value_type=Union[int, float],\r\n        category=\"scrapers\",\r\n        required=False,\r\n    ),\r\n    ConfigSetting(\r\n        key=\"user-agent\",\r\n        value_type=str,\r\n        category=\"scrapers\",\r\n        required=False,\r\n    ),\r\n    ConfigSetting(\r\n        key=\"proxy\",\r\n        value_type=str,\r\n        category=\"scrapers\",\r\n        required=False,\r\n    ),\r\n    ConfigSetting(\r\n        key=\"verify-ssl\",\r\n        value_type=bool,\r\n        category=\"scrapers\",\r\n        required=False,\r\n    ),\r\n]\r\n\r\n\r\ndef main() -> None:\r\n    try:\r\n        # Assure at least one argument was passed\r\n        if len(sys.argv) < 2:\r\n            print_usage()\r\n            exit(0)\r\n\r\n        if not DATA_FOLDER_PATH.is_dir():\r\n            DATA_FOLDER_PATH.mkdir(parents=True)\r\n\r\n        setup_loggers(stdout_loglevel=logging.INFO,\r\n                      file_loglevel=logging.DEBUG)\r\n\r\n        cli_args = \" \".join(sys.argv[1:])\r\n        logger.debug(f\"CLI Command: {PACKAGE_NAME} {cli_args}\")\r\n        logger.debug(f\"Python version: {sys.version}\")\r\n        logger.debug(f\"Package version: {PACKAGE_VERSION}\")\r\n        logger.debug(f\"OS: {sys.platform}\")\r\n\r\n        config = generate_config()\r\n        update_settings(config)\r\n\r\n        if config.general.get(\"check-for-updates\", True):\r\n            check_for_updates(current_package_version=PACKAGE_VERSION)\r\n\r\n        urls = single_to_list(sys.argv[1:])\r\n        EVENT_LOOP.run_until_complete(download(urls=urls, config=config))\r\n\r\n    except Exception as ex:\r\n        logger.error(f\"Error: {ex}\")\r\n        logger.debug(\"Debug information:\", exc_info=True)\r\n        exit(1)\r\n\r\n    finally:\r\n        if log_rotation_size := LOG_ROTATION_SIZE:\r\n            handle_log_rotation(log_rotation_size=log_rotation_size)\r\n\r\n        # NOTE: This will only close scrapers that were initialized using the ScraperFactory.\r\n        async_cleanup_coroutines = []\r\n        for scraper in ScraperFactory.get_initialized_scrapers():\r\n            # Log scraper.requests_count\r\n            logger.debug(f\"Requests count for '{scraper.name}' scraper: {scraper.requests_count}\")\r\n            scraper.close()\r\n            async_cleanup_coroutines.append(scraper.async_close())\r\n\r\n        EVENT_LOOP.run_until_complete(asyncio.gather(*async_cleanup_coroutines))\r\n        TempDirGenerator.cleanup()\r\n\r\n\r\nasync def download(urls: list[str], config: Config) -> None:\r\n    \"\"\"\r\n    Download subtitles from a given URL.\r\n\r\n    Args:\r\n        urls (list[str]): A list of URLs to download subtitles from.\r\n        config (Config): A config to use for downloading subtitles.\r\n    \"\"\"\r\n    for url in urls:\r\n        try:\r\n            logger.info(f\"Scraping '{url}'...\")\r\n\r\n            scraper = ScraperFactory.get_scraper_instance(url=url,\r\n                                                          kwargs={\"config_data\": config.data.get(\"scrapers\")},\r\n                                                          extract_scraper_config=True)\r\n            scraper.config.check()  # Recheck config after scraper settings were loaded\r\n\r\n            try:\r\n                logger.debug(f\"Fetching '{url}'...\")\r\n                scraper_response: ScrapedMediaResponse = await scraper.get_data(url=url)\r\n\r\n            except ScraperError as e:\r\n                logger.error(f\"Error: {e}\")\r\n                logger.debug(\"Debug information:\", exc_info=True)\r\n                continue\r\n\r\n            media_data = scraper_response.media_data\r\n            playlist_scraper = ScraperFactory.get_scraper_instance(scraper_id=scraper_response.playlist_scraper,\r\n                                                                   kwargs={\"config_data\": config.data.get(\"scrapers\")},\r\n                                                                   extract_scraper_config=True)\r\n\r\n            if not media_data:\r\n                logger.error(f\"Error: No supported media was found for {url}.\")\r\n                continue\r\n\r\n            for media_item in media_data:\r\n                try:\r\n                    logger.info(f\"Found {media_item.media_type}: {format_media_description(media_data=media_item)}\")\r\n                    await download_media(scraper=playlist_scraper, media_item=media_item, config=config)\r\n\r\n                except Exception as e:\r\n                    if len(media_data) > 1:\r\n                        logger.warning(f\"Error scraping media item \"\r\n                                       f\"'{format_media_description(media_data=media_item)}': {e}\\n\"\r\n                                       f\"Skipping to next media item...\")\r\n                        logger.debug(\"Debug information:\", exc_info=True)\r\n                        continue\r\n\r\n                    raise\r\n\r\n        except Exception as e:\r\n            logger.error(f\"Error while scraping '{url}': {e}\")\r\n            logger.debug(\"Debug information:\", exc_info=True)\r\n            continue\r\n\r\n\r\nasync def download_media(scraper: Scraper, media_item: MediaData, config: Config) -> None:\r\n    \"\"\"\r\n    Download a media item.\r\n\r\n    Args:\r\n        scraper (Scraper): A Scraper object to use for downloading subtitles.\r\n        media_item (MediaData): A media data item to download subtitles for.\r\n        config (Config): A config to use for downloading subtitles.\r\n    \"\"\"\r\n    if isinstance(media_item, Series):\r\n        for season in media_item.seasons:\r\n            await download_media(scraper=scraper, media_item=season, config=config)\r\n\r\n    elif isinstance(media_item, Season):\r\n        for episode in media_item.episodes:\r\n            logger.info(f\"{format_media_description(media_data=episode, shortened=True)}:\")\r\n            await download_media_item(scraper=scraper, media_item=episode, config=config)\r\n\r\n    elif isinstance(media_item, (Movie, Episode)):\r\n        await download_media_item(scraper=scraper, media_item=media_item, config=config)\r\n\r\n\r\nasync def download_media_item(scraper: Scraper, media_item: Movie | Episode, config: Config) -> None:\r\n    ex: Exception | None = None\r\n\r\n    if media_item.playlist:\r\n        download_subtitles_kwargs = {\r\n            \"download_path\": Path(config.downloads[\"folder\"]),\r\n            \"language_filter\": config.downloads.get(\"languages\"),\r\n            \"convert_to_srt\": config.subtitles.get(\"convert-to-srt\", False),\r\n            \"overwrite_existing\": config.downloads.get(\"overwrite-existing\", False),\r\n            \"zip_files\": config.downloads.get(\"zip\", False),\r\n        }\r\n\r\n        try:\r\n            results = await download_subtitles(scraper=scraper,\r\n                                               media_data=media_item,\r\n                                               **download_subtitles_kwargs)\r\n\r\n            success_count = len(results.successful_subtitles)\r\n            failed_count = len(results.failed_subtitles)\r\n\r\n            if success_count or failed_count:\r\n                logger.info(f\"{success_count}/{success_count + failed_count} matching subtitles \"\r\n                            f\"were successfully downloaded.\")\r\n\r\n            else:\r\n                logger.info(\"No matching subtitles were found.\")\r\n\r\n            return  # noqa: TRY300\r\n\r\n        except PlaylistLoadError as e:\r\n            ex = e\r\n\r\n    # We get here if there is no playlist, or there is one, but it failed to load\r\n    if isinstance(media_item, Movie) and media_item.preorder_availability_date:\r\n        preorder_date_str = media_item.preorder_availability_date.strftime(\"%Y-%m-%d\")\r\n        logger.info(PREORDER_MESSAGE.format(movie_name=media_item.name, scraper_name=scraper.name,\r\n                                            preorder_date=preorder_date_str))\r\n\r\n    else:\r\n        if ex:\r\n            logger.error(f\"Error: {ex}\")\r\n\r\n        else:\r\n            logger.error(\"Error: No valid playlist was found.\")\r\n\r\n\r\ndef check_for_updates(current_package_version: str) -> None:\r\n    \"\"\"\r\n    Check and print if a newer version of the package is available, and log accordingly.\r\n\r\n    Args:\r\n        current_package_version (str): The current version of the package.\r\n    \"\"\"\r\n    api_url = f\"https://pypi.org/pypi/{PACKAGE_NAME}/json\"\r\n    logger.debug(\"Checking for package updates on PyPI...\")\r\n    try:\r\n        response = httpx.get(\r\n            url=api_url,\r\n            headers={\"Accept\": \"application/json\"},\r\n            timeout=5,\r\n        )\r\n        raise_for_status(response)\r\n        response_data = response.json()\r\n\r\n        pypi_latest_version = response_data[\"info\"][\"version\"]\r\n\r\n        if pypi_latest_version != current_package_version:\r\n            logger.warning(f\"You are currently using version '{current_package_version}' of '{PACKAGE_NAME}', \"\r\n                           f\"however version '{pypi_latest_version}' is available.\"\r\n                           f'\\nConsider upgrading by running \"pip install --upgrade {PACKAGE_NAME}\"\\n')\r\n\r\n        else:\r\n            logger.debug(f\"Latest version of '{PACKAGE_NAME}' ({current_package_version}) is currently installed.\")\r\n\r\n    except Exception as e:\r\n        logger.warning(f\"Update check failed: {e}\")\r\n        logger.debug(\"Debug information:\", exc_info=True)\r\n        return\r\n\r\n\r\nasync def download_subtitles(scraper: Scraper, media_data: Movie | Episode, download_path: Path,\r\n                             language_filter: list[str] | None = None, convert_to_srt: bool = False,\r\n                             overwrite_existing: bool = True, zip_files: bool = False) -> SubtitlesDownloadResults:\r\n    \"\"\"\r\n    Download subtitles for the given media data.\r\n\r\n    Args:\r\n        scraper (Scraper): A Scraper object to use for downloading subtitles.\r\n        media_data (Movie | Episode): A movie or episode data object.\r\n        download_path (Path): Path to a folder where the subtitles will be downloaded to.\r\n        language_filter (list[str] | None): List of specific languages to download subtitles for.\r\n            None for all languages (no filter). Defaults to None.\r\n        convert_to_srt (bool, optional): Whether to convert the subtitles to SRT format. Defaults to False.\r\n        overwrite_existing (bool, optional): Whether to overwrite existing subtitles. Defaults to True.\r\n        zip_files (bool, optional): Whether to unite the subtitles into a single zip file\r\n            (only if there are multiple subtitles).\r\n\r\n    Returns:\r\n        SubtitlesDownloadResults: A SubtitlesDownloadResults object containing the results of the download.\r\n    \"\"\"\r\n    temp_dir_name = generate_media_folder_name(media_data=media_data, source=scraper.abbreviation)\r\n    temp_download_path = TempDirGenerator.generate(directory_name=temp_dir_name)\r\n\r\n    successful_downloads: list[SubtitlesData] = []\r\n    failed_downloads: list[SubtitlesDownloadError] = []\r\n    temp_downloads: list[Path] = []\r\n\r\n    if not media_data.playlist:\r\n        raise PlaylistLoadError(\"No playlist was found for provided media data.\")\r\n\r\n    main_playlist = await scraper.load_playlist(url=media_data.playlist)\r\n\r\n    if not main_playlist:\r\n        raise PlaylistLoadError(\"Failed to load the main playlist.\")\r\n\r\n    matching_subtitles = scraper.find_matching_subtitles(main_playlist=main_playlist,  # type: ignore[var-annotated]\r\n                                                         language_filter=language_filter)\r\n\r\n    logger.debug(f\"{len(matching_subtitles)} matching subtitles were found.\")\r\n\r\n    for matching_subtitles_item in matching_subtitles:\r\n        subtitles_data = await scraper.download_subtitles(media_data=matching_subtitles_item,\r\n                                                          subrip_conversion=convert_to_srt)\r\n        language_info = format_subtitles_description(language_code=subtitles_data.language_code,\r\n                                                     language_name=subtitles_data.language_name,\r\n                                                     special_type=subtitles_data.special_type)\r\n\r\n        if isinstance(subtitles_data, SubtitlesDownloadError):\r\n            logger.warning(f\"Failed to download '{language_info}' subtitles. Skipping...\")\r\n            logger.debug(\"Debug information:\", exc_info=subtitles_data.original_exc)\r\n            failed_downloads.append(subtitles_data)\r\n            continue\r\n\r\n        try:\r\n            temp_downloads.append(download_subtitles_to_file(\r\n                media_data=media_data,\r\n                subtitles_data=subtitles_data,\r\n                output_path=temp_download_path,\r\n                source_abbreviation=scraper.abbreviation,\r\n                overwrite=overwrite_existing,\r\n            ))\r\n\r\n            logger.info(f\"'{language_info}' subtitles were successfully downloaded.\")\r\n            successful_downloads.append(subtitles_data)\r\n\r\n        except Exception as e:\r\n            logger.error(f\"Error: Failed to save '{language_info}' subtitles: {e}\")\r\n            logger.debug(\"Debug information:\", exc_info=True)\r\n            failed_downloads.append(\r\n                SubtitlesDownloadError(\r\n                    language_code=subtitles_data.language_code,\r\n                    language_name=subtitles_data.language_name,\r\n                    special_type=subtitles_data.special_type,\r\n                    original_exc=e,\r\n                ),\r\n            )\r\n\r\n    if not zip_files or len(temp_downloads) == 1:\r\n        for file_path in temp_downloads:\r\n            if overwrite_existing:\r\n                new_path = download_path / file_path.name\r\n\r\n            else:\r\n                new_path = generate_non_conflicting_path(file_path=download_path / file_path.name)\r\n\r\n            # str conversion needed only for Python <= 3.8 - https://github.com/python/cpython/issues/76870\r\n            shutil.move(src=str(file_path), dst=new_path)\r\n\r\n    elif len(temp_downloads) > 0:\r\n        archive_path = Path(shutil.make_archive(\r\n            base_name=str(temp_download_path.parent / temp_download_path.name),\r\n            format=ARCHIVE_FORMAT,\r\n            root_dir=temp_download_path,\r\n        ))\r\n\r\n        file_name = generate_media_folder_name(media_data=media_data,\r\n                                               source=scraper.abbreviation) + f\".{ARCHIVE_FORMAT}\"\r\n\r\n        if overwrite_existing:\r\n            destination_path = download_path / file_name\r\n\r\n        else:\r\n            destination_path = generate_non_conflicting_path(file_path=download_path / file_name)\r\n\r\n        shutil.move(src=str(archive_path), dst=destination_path)\r\n\r\n    return SubtitlesDownloadResults(\r\n        media_data=media_data,\r\n        successful_subtitles=successful_downloads,\r\n        failed_subtitles=failed_downloads,\r\n        is_zip=zip_files,\r\n    )\r\n\r\n\r\ndef handle_log_rotation(log_rotation_size: int) -> None:\r\n    \"\"\"\r\n    Handle log rotation and remove old log files if needed.\r\n\r\n    Args:\r\n        log_rotation_size (int): Maximum amount of log files to keep.\r\n    \"\"\"\r\n    sorted_log_files = sorted(LOG_FILES_PATH.glob(\"*.log\"), key=lambda file: file.stat().st_mtime, reverse=True)\r\n\r\n    if len(sorted_log_files) > log_rotation_size:\r\n        for log_file in sorted_log_files[log_rotation_size:]:\r\n            log_file.unlink()\r\n\r\n\r\ndef generate_config() -> Config:\r\n    \"\"\"\r\n    Generate a config object using config files, and validate it.\r\n\r\n    Returns:\r\n        Config: A config object.\r\n\r\n    Raises:\r\n        ConfigException: If there is a general config error.\r\n        MissingConfigValue: If a required config value is missing.\r\n        InvalidConfigValue: If a config value is invalid.\r\n    \"\"\"\r\n    if not DEFAULT_CONFIG_PATH.is_file():\r\n        raise ConfigError(\"Default config file could not be found.\")\r\n\r\n    config = Config(config_settings=BASE_CONFIG_SETTINGS)\r\n\r\n    logger.debug(\"Loading default config data...\")\r\n\r\n    with DEFAULT_CONFIG_PATH.open('r') as data:\r\n        config.loads(config_data=data.read(), check_config=True)\r\n\r\n    logger.debug(\"Default config data loaded and validated successfully.\")\r\n\r\n    # If logs folder doesn't exist, create it (also handles data folder)\r\n    if not DATA_FOLDER_PATH.is_dir():\r\n        logger.debug(f\"'{DATA_FOLDER_PATH}' directory could not be found and will be created.\")\r\n        DATA_FOLDER_PATH.mkdir(parents=True, exist_ok=True)\r\n        LOG_FILES_PATH.mkdir()\r\n\r\n    else:\r\n        if not LOG_FILES_PATH.is_dir():\r\n            logger.debug(f\"'{LOG_FILES_PATH}' directory could not be found and will be created.\")\r\n            LOG_FILES_PATH.mkdir()\r\n\r\n        # If a user config file exists, add it to config_files\r\n        if USER_CONFIG_FILE.is_file():\r\n            logger.info(f\"User config file detected at '{USER_CONFIG_FILE}' and will be used.\")\r\n\r\n            with USER_CONFIG_FILE.open('r') as data:\r\n                config.loads(config_data=data.read(), check_config=True)\r\n\r\n            logger.debug(\"User config file loaded and validated successfully.\")\r\n\r\n    return config\r\n\r\n\r\ndef generate_media_folder_name(media_data: Movie | Episode, source: str | None = None) -> str:\r\n    \"\"\"\r\n    Generate a folder name for media data.\r\n\r\n    Args:\r\n        media_data (Movie | Episode): A movie or episode data object.\r\n        source (str | None, optional): Abbreviation of the source to use for file names. Defaults to None.\r\n\r\n    Returns:\r\n        str: A folder name for the media data.\r\n    \"\"\"\r\n    if isinstance(media_data, Movie):\r\n        return format_release_name(\r\n            title=media_data.name,\r\n            release_date=media_data.release_date,\r\n            media_source=source,\r\n        )\r\n\r\n    # elif isinstance(media_data, Episode):\r\n    return format_release_name(\r\n        title=media_data.series_name,\r\n        season_number=media_data.season_number,\r\n        episode_number=media_data.episode_number,\r\n        media_source=source,\r\n    )\r\n\r\n\r\ndef generate_temp_media_path(media_data: Movie | Episode, source: str | None = None) -> Path:\r\n    \"\"\"\r\n    Generate a temporary directory for downloading media data.\r\n\r\n    Args:\r\n        media_data (Movie | Episode): A movie or episode data object.\r\n        source (str | None, optional): Abbreviation of the source to use for file names. Defaults to None.\r\n\r\n    Returns:\r\n        Path: A path to the temporary folder.\r\n    \"\"\"\r\n    temp_folder_name = generate_media_folder_name(media_data=media_data, source=source)\r\n    path = generate_non_conflicting_path(file_path=TEMP_FOLDER_PATH / temp_folder_name, has_extension=False)\r\n\r\n    return TempDirGenerator.generate(directory_name=path.name)\r\n\r\n\r\ndef update_settings(config: Config) -> None:\r\n    \"\"\"\r\n    Update settings according to config.\r\n\r\n    Args:\r\n        config (Config): An instance of a config to set settings according to.\r\n    \"\"\"\r\n    Scraper.subtitles_fix_rtl = config.subtitles[\"fix-rtl\"]\r\n    Scraper.subtitles_remove_duplicates = config.subtitles[\"remove-duplicates\"]\r\n    Scraper.default_timeout = config.scrapers.get(\"timeout\", 10)\r\n    Scraper.default_user_agent = config.scrapers.get(\"user-agent\", httpx._client.USER_AGENT)  # noqa: SLF001\r\n    Scraper.default_proxy = config.scrapers.get(\"proxy\")\r\n    Scraper.default_verify_ssl = config.scrapers.get(\"verify-ssl\", True)\r\n\r\n    if not Scraper.default_verify_ssl:\r\n        import urllib3\r\n        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\r\n\r\n    WebVTTCaptionBlock.subrip_alignment_conversion = (\r\n        config.subtitles.get(\"webvtt\", {}).get(\"subrip-alignment-conversion\", False)\r\n    )\r\n\r\n    if log_rotation := config.general.get(\"log-rotation-size\"):\r\n        global LOG_ROTATION_SIZE\r\n        LOG_ROTATION_SIZE = log_rotation\r\n\r\n\r\ndef print_usage() -> None:\r\n    \"\"\"Print usage information.\"\"\"\r\n    logger.info(f\"Usage: {PACKAGE_NAME} <iTunes movie URL> [iTunes movie URL...]\")\r\n\r\n\r\ndef setup_loggers(stdout_loglevel: int, file_loglevel: int) -> None:\r\n    \"\"\"\r\n    Configure loggers.\r\n\r\n    Args:\r\n        stdout_loglevel (int): Log level for STDOUT logger.\r\n        file_loglevel (int): Log level for logfile logger.\r\n    \"\"\"\r\n    logger.setLevel(logging.DEBUG)\r\n\r\n    # Setup STDOUT logger\r\n    stdout_handler = logging.StreamHandler(sys.stdout)\r\n    stdout_handler.setLevel(stdout_loglevel)\r\n    stdout_handler.setFormatter(CustomStdoutFormatter())\r\n    logger.addHandler(stdout_handler)\r\n\r\n    # Setup logfile logger\r\n    if not LOG_FILES_PATH.is_dir():\r\n        logger.debug(\"Logs directory could not be found and will be created.\")\r\n        LOG_FILES_PATH.mkdir()\r\n\r\n    logfile_path = generate_non_conflicting_path(file_path=LOG_FILES_PATH / LOG_FILE_NAME)\r\n    logfile_handler = logging.FileHandler(filename=logfile_path, encoding=\"utf-8\")\r\n    logfile_handler.setLevel(file_loglevel)\r\n    logfile_handler.setFormatter(CustomLogFileFormatter())\r\n    logger.debug(f\"Log file location: '{logfile_path}'\")\r\n    logger.addHandler(logfile_handler)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/__main__.py b/isubrip/__main__.py
--- a/isubrip/__main__.py	(revision d3b0ef086b2efeb43e52af4565060033c2307487)
+++ b/isubrip/__main__.py	(date 1724109963036)
@@ -5,15 +5,13 @@
 from pathlib import Path
 import shutil
 import sys
-from typing import List, Union
 
 import httpx
 
-from isubrip.config import Config, ConfigError, ConfigSetting, SpecialConfigType
+from isubrip.config import NewConfig
 from isubrip.constants import (
     ARCHIVE_FORMAT,
     DATA_FOLDER_PATH,
-    DEFAULT_CONFIG_PATH,
     EVENT_LOOP,
     LOG_FILE_NAME,
     LOG_FILES_PATH,
@@ -21,7 +19,6 @@
     PACKAGE_VERSION,
     PREORDER_MESSAGE,
     TEMP_FOLDER_PATH,
-    USER_CONFIG_FILE,
 )
 from isubrip.data_structures import (
     Episode,
@@ -49,105 +46,6 @@
 
 LOG_ROTATION_SIZE: int | None = None
 
-BASE_CONFIG_SETTINGS = [
-    ConfigSetting(
-        key="check-for-updates",
-        value_type=bool,
-        category="general",
-        required=False,
-    ),
-    ConfigSetting(
-        key="log_rotation_size",
-        value_type=str,
-        category="general",
-        required=False,
-    ),
-    ConfigSetting(
-        key="add-release-year-to-series",
-        value_type=bool,
-        category="downloads",
-        required=False,
-    ),
-    ConfigSetting(
-        key="folder",
-        value_type=str,
-        category="downloads",
-        required=True,
-        special_type=SpecialConfigType.EXISTING_FOLDER_PATH,
-    ),
-    ConfigSetting(
-        key="languages",
-        value_type=List[str],
-        category="downloads",
-        required=False,
-    ),
-    ConfigSetting(
-        key="overwrite-existing",
-        value_type=bool,
-        category="downloads",
-        required=True,
-    ),
-    ConfigSetting(
-        key="zip",
-        value_type=bool,
-        category="downloads",
-        required=False,
-    ),
-    ConfigSetting(
-        key="fix-rtl",
-        value_type=bool,
-        category="subtitles",
-        required=True,
-    ),
-    ConfigSetting(
-        key="rtl-languages",
-        value_type=List[str],
-        category="subtitles",
-        required=False,
-    ),
-    ConfigSetting(
-        key="remove-duplicates",
-        value_type=bool,
-        category="subtitles",
-        required=True,
-    ),
-    ConfigSetting(
-        key="convert-to-srt",
-        value_type=bool,
-        category="subtitles",
-        required=False,
-    ),
-    ConfigSetting(
-        key="subrip-alignment-conversion",
-        value_type=bool,
-        category=("subtitles", "webvtt"),
-        required=False,
-    ),
-    ConfigSetting(
-        key="timeout",
-        value_type=Union[int, float],
-        category="scrapers",
-        required=False,
-    ),
-    ConfigSetting(
-        key="user-agent",
-        value_type=str,
-        category="scrapers",
-        required=False,
-    ),
-    ConfigSetting(
-        key="proxy",
-        value_type=str,
-        category="scrapers",
-        required=False,
-    ),
-    ConfigSetting(
-        key="verify-ssl",
-        value_type=bool,
-        category="scrapers",
-        required=False,
-    ),
-]
 
 
 def main() -> None:
@@ -160,7 +58,7 @@
         if not DATA_FOLDER_PATH.is_dir():
             DATA_FOLDER_PATH.mkdir(parents=True)
 
-        setup_loggers(stdout_loglevel=logging.INFO,
+        setup_loggers(stdout_loglevel=logging.DEBUG,
                       file_loglevel=logging.DEBUG)
 
         cli_args = " ".join(sys.argv[1:])
@@ -169,10 +67,11 @@
         logger.debug(f"Package version: {PACKAGE_VERSION}")
         logger.debug(f"OS: {sys.platform}")
 
-        config = generate_config()
-        update_settings(config)
+        # Add field to ScrapersCategory
+        config = NewConfig(scrapers=ScraperFactory.get_scraper_classes())
+        update_settings(config=config)
 
-        if config.general.get("check-for-updates", True):
+        if config.general.check_for_updates:
             check_for_updates(current_package_version=PACKAGE_VERSION)
 
         urls = single_to_list(sys.argv[1:])
@@ -190,7 +89,6 @@
         # NOTE: This will only close scrapers that were initialized using the ScraperFactory.
         async_cleanup_coroutines = []
         for scraper in ScraperFactory.get_initialized_scrapers():
-            # Log scraper.requests_count
             logger.debug(f"Requests count for '{scraper.name}' scraper: {scraper.requests_count}")
             scraper.close()
             async_cleanup_coroutines.append(scraper.async_close())
@@ -199,22 +97,21 @@
         TempDirGenerator.cleanup()
 
 
-async def download(urls: list[str], config: Config) -> None:
+async def download(urls: list[str], config: NewConfig) -> None:
     """
     Download subtitles from a given URL.
 
     Args:
         urls (list[str]): A list of URLs to download subtitles from.
-        config (Config): A config to use for downloading subtitles.
+        config (NewConfig): A config to use for downloading subtitles.
     """
     for url in urls:
         try:
             logger.info(f"Scraping '{url}'...")
 
             scraper = ScraperFactory.get_scraper_instance(url=url,
-                                                          kwargs={"config_data": config.data.get("scrapers")},
+                                                          kwargs={"config_data": config.scrapers},
                                                           extract_scraper_config=True)
-            scraper.config.check()  # Recheck config after scraper settings were loaded
 
             try:
                 logger.debug(f"Fetching '{url}'...")
@@ -255,14 +152,14 @@
             continue
 
 
-async def download_media(scraper: Scraper, media_item: MediaData, config: Config) -> None:
+async def download_media(scraper: Scraper, media_item: MediaData, config: NewConfig) -> None:
     """
     Download a media item.
 
     Args:
         scraper (Scraper): A Scraper object to use for downloading subtitles.
         media_item (MediaData): A media data item to download subtitles for.
-        config (Config): A config to use for downloading subtitles.
+        config (NewConfig): A config to use for downloading subtitles.
     """
     if isinstance(media_item, Series):
         for season in media_item.seasons:
@@ -277,16 +174,16 @@
         await download_media_item(scraper=scraper, media_item=media_item, config=config)
 
 
-async def download_media_item(scraper: Scraper, media_item: Movie | Episode, config: Config) -> None:
+async def download_media_item(scraper: Scraper, media_item: Movie | Episode, config: NewConfig) -> None:
     ex: Exception | None = None
 
     if media_item.playlist:
-        download_subtitles_kwargs = {
-            "download_path": Path(config.downloads["folder"]),
-            "language_filter": config.downloads.get("languages"),
-            "convert_to_srt": config.subtitles.get("convert-to-srt", False),
-            "overwrite_existing": config.downloads.get("overwrite-existing", False),
-            "zip_files": config.downloads.get("zip", False),
+        download_subtitles_kwargs = {  # TODO: Accept parameter instead of passing config
+            "download_path": config.downloads.folder,
+            "language_filter": config.downloads.languages,
+            "convert_to_srt": config.subtitles.convert_to_srt,
+            "overwrite_existing": config.downloads.overwrite_existing,
+            "zip_files": config.downloads.zip,
         }
 
         try:
@@ -485,53 +382,6 @@
             log_file.unlink()
 
 
-def generate_config() -> Config:
-    """
-    Generate a config object using config files, and validate it.
-
-    Returns:
-        Config: A config object.
-
-    Raises:
-        ConfigException: If there is a general config error.
-        MissingConfigValue: If a required config value is missing.
-        InvalidConfigValue: If a config value is invalid.
-    """
-    if not DEFAULT_CONFIG_PATH.is_file():
-        raise ConfigError("Default config file could not be found.")
-
-    config = Config(config_settings=BASE_CONFIG_SETTINGS)
-
-    logger.debug("Loading default config data...")
-
-    with DEFAULT_CONFIG_PATH.open('r') as data:
-        config.loads(config_data=data.read(), check_config=True)
-
-    logger.debug("Default config data loaded and validated successfully.")
-
-    # If logs folder doesn't exist, create it (also handles data folder)
-    if not DATA_FOLDER_PATH.is_dir():
-        logger.debug(f"'{DATA_FOLDER_PATH}' directory could not be found and will be created.")
-        DATA_FOLDER_PATH.mkdir(parents=True, exist_ok=True)
-        LOG_FILES_PATH.mkdir()
-
-    else:
-        if not LOG_FILES_PATH.is_dir():
-            logger.debug(f"'{LOG_FILES_PATH}' directory could not be found and will be created.")
-            LOG_FILES_PATH.mkdir()
-
-        # If a user config file exists, add it to config_files
-        if USER_CONFIG_FILE.is_file():
-            logger.info(f"User config file detected at '{USER_CONFIG_FILE}' and will be used.")
-
-            with USER_CONFIG_FILE.open('r') as data:
-                config.loads(config_data=data.read(), check_config=True)
-
-            logger.debug("User config file loaded and validated successfully.")
-
-    return config
-
-
 def generate_media_folder_name(media_data: Movie | Episode, source: str | None = None) -> str:
     """
     Generate a folder name for media data.
@@ -576,29 +426,30 @@
     return TempDirGenerator.generate(directory_name=path.name)
 
 
-def update_settings(config: Config) -> None:
+def update_settings(config: NewConfig) -> None:
     """
     Update settings according to config.
 
     Args:
-        config (Config): An instance of a config to set settings according to.
+        config (NewConfig): An instance of a config to set settings according to.
     """
-    Scraper.subtitles_fix_rtl = config.subtitles["fix-rtl"]
-    Scraper.subtitles_remove_duplicates = config.subtitles["remove-duplicates"]
-    Scraper.default_timeout = config.scrapers.get("timeout", 10)
-    Scraper.default_user_agent = config.scrapers.get("user-agent", httpx._client.USER_AGENT)  # noqa: SLF001
-    Scraper.default_proxy = config.scrapers.get("proxy")
-    Scraper.default_verify_ssl = config.scrapers.get("verify-ssl", True)
+    Scraper.subtitles_fix_rtl = config.subtitles.fix_rtl
+    Scraper.subtitles_remove_duplicates = config.subtitles.remove_duplicates
+    Scraper.default_timeout = config.scrapers.default.timeout
+    Scraper.default_user_agent = config.scrapers.default.user_agent
+    Scraper.default_proxy = config.scrapers.default.proxy
+    Scraper.default_verify_ssl = config.scrapers.default.verify_ssl
 
     if not Scraper.default_verify_ssl:
-        import urllib3
+        import urllib3  # TODO: Replace code, as urllib3 is not a dependency of isubrip
         urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
 
     WebVTTCaptionBlock.subrip_alignment_conversion = (
-        config.subtitles.get("webvtt", {}).get("subrip-alignment-conversion", False)
+        config.subtitles.webvtt.subrip_alignment_conversion
     )
 
-    if log_rotation := config.general.get("log-rotation-size"):
+    # TODO: Not use global variables
+    if log_rotation := config.general.log_rotation_size:
         global LOG_ROTATION_SIZE
         LOG_ROTATION_SIZE = log_rotation
 
Index: isubrip/config.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nfrom copy import deepcopy\r\nfrom enum import Enum\r\nfrom pathlib import Path\r\nimport typing\r\nfrom typing import Any, NamedTuple, Type\r\n\r\nfrom mergedeep import merge\r\nimport tomli\r\n\r\nfrom isubrip.utils import check_type, single_to_list\r\n\r\n\r\nclass DuplicateBehavior(Enum):\r\n    \"\"\"\r\n    An Enum representing optional behaviors for when a duplicate config key is found.\r\n\r\n    Attributes:\r\n        OVERWRITE: Overwrite the existing value with the new value.\r\n        IGNORE: Ignore the new value and keep the existing value.\r\n        RAISE_ERROR: Raise an error.\r\n    \"\"\"\r\n    OVERWRITE = 1\r\n    IGNORE = 2\r\n    RAISE_ERROR = 3\r\n\r\n\r\nclass SpecialConfigType(Enum):\r\n    \"\"\"\r\n    An Enum representing special config value properties to validate.\r\n\r\n    Attributes:\r\n        EXISTING_FILE_PATH: The value must be of a path to an existing file.\r\n        EXISTING_FOLDER_PATH: The value must be of a path to an existing folder.\r\n    \"\"\"\r\n    EXISTING_FILE_PATH = 1\r\n    EXISTING_FOLDER_PATH = 2\r\n\r\n\r\nclass ConfigSetting(NamedTuple):\r\n    \"\"\"\r\n    A NamedTuple representing a config setting.\r\n\r\n    Attributes:\r\n        key (str): Dictionary key used to access the setting.\r\n        value_type (type): Variable type of the value of the setting. Used for validation.\r\n        category (str | tuple[str, ...], optional): A category that the setting is under.\r\n            Categories are used to group related settings' keys together in a sub-dictionary.\r\n            A tuple can be used to nest categories (first item is the top-level category). Defaults to None.\r\n        required (bool, optional): Whether the setting is required. Defaults to False.\r\n        enum_type (type[Enum], optional): An Enum that the settings values will be converted to. Defaults to None.\r\n        special_type (SpecialConfigType | list[SpecialConfigType], optional): A special property of the setting's value\r\n            to validate, represented by a SpecialConfigType value. Defaults to None.\r\n    \"\"\"\r\n    key: str\r\n    # TODO: Use `types.UnionType` instead of `typing._UnionGenericAlias`, once minimum Python version >= 3.10.\r\n    # TODO: Update 'InvalidConfigType' exception as well.\r\n    value_type: type | typing._UnionGenericAlias  # type: ignore[name-defined]\r\n    category: str | tuple[str, ...] | None = None\r\n    required: bool = False\r\n    enum_type: Type[Enum] | None = None\r\n    special_type: SpecialConfigType | list[SpecialConfigType] | None = None\r\n\r\n    def __eq__(self, other: Any) -> bool:\r\n        if isinstance(other, ConfigSetting):\r\n            return self.key == other.key and self.category == other.category\r\n        return False\r\n\r\n\r\nclass Config:\r\n    \"\"\"A class for managing iSubRip config files.\"\"\"\r\n    def __init__(self, config_settings: list[ConfigSetting] | None = None, config_data: dict | None = None):\r\n        \"\"\"\r\n        Create a new Config instance.\r\n\r\n        Args:\r\n            config_settings (list[ConfigSetting], optional): A list of ConfigSettings objects\r\n                that will be used for validations. Defaults to None.\r\n            config_data (dict, optional): A dict of config data to add to the config. Defaults to None.\r\n        \"\"\"\r\n        self._config_settings: list = []\r\n        self._config_data: dict = {}\r\n\r\n        if config_settings:\r\n            self.add_settings(config_settings, check_config=False)\r\n\r\n        if config_data:\r\n            self._config_data = deepcopy(config_data)\r\n\r\n    def __contains__(self, item: Any) -> bool:\r\n        \"\"\"\r\n        Allow checking if a key exists in the config using the 'in' operator.\r\n\r\n        Args:\r\n            item (Any): The key to check for.\r\n\r\n        Returns:\r\n            bool: True if the key exists in the config, False otherwise.\r\n        \"\"\"\r\n        return item in self._config_data\r\n\r\n    def __getattr__(self, key: str) -> Any:\r\n        \"\"\"\r\n        Allow access to config settings using attributes.\r\n\r\n        Args:\r\n            key (str): Config key to get.\r\n\r\n        Returns:\r\n            Any: The corresponding value for the key in the config.\r\n        \"\"\"\r\n        if self._config_data and key in self._config_data:\r\n            return self._config_data[key]\r\n\r\n        raise AttributeError(f\"Attribute '{key}' does not exist.\")\r\n\r\n    def __getitem__(self, key: str) -> Any:\r\n        \"\"\"\r\n        Allow access to config settings using dict-like syntax.\r\n\r\n        Args:\r\n            key (str): Config key to get.\r\n\r\n        Returns:\r\n            Any: The corresponding value for the key in the config.\r\n        \"\"\"\r\n        return self._config_data[key]\r\n\r\n    def get(self, key: str, default: Any = None) -> Any:\r\n        \"\"\"\r\n        Get a config value.\r\n\r\n        Args:\r\n            key (str): Config key to get.\r\n            default (Any, optional): Default value to return if the key does not exist. Defaults to None.\r\n\r\n        Returns:\r\n            Any: The corresponding value for the key in the config or the default value if the key does not exist.\r\n        \"\"\"\r\n        return self._config_data.get(key, default)\r\n\r\n    @property\r\n    def data(self) -> dict:\r\n        return self._config_data\r\n\r\n    def add_settings(self, config_settings: ConfigSetting | list[ConfigSetting],\r\n                     duplicate_behavior: DuplicateBehavior = DuplicateBehavior.OVERWRITE,\r\n                     check_config: bool = True) -> None:\r\n        \"\"\"\r\n        Add new config settings to the config.\r\n\r\n        Args:\r\n            config_settings (ConfigSetting | list[ConfigSetting]): A ConfigSetting object or a list of ConfigSetting\r\n                objects to add to the config.\r\n            duplicate_behavior (DuplicateBehavior, optional): Behaviour to apply if a duplicate is found.\r\n                Defaults to DuplicateBehavior.OVERWRITE.\r\n            check_config (bool, optional): Whether to check the config after loading it. Defaults to True.\r\n        \"\"\"\r\n        config_settings_copy = deepcopy(single_to_list(config_settings))\r\n\r\n        for config_setting in config_settings_copy:\r\n            if config_setting in self._config_settings:\r\n                if duplicate_behavior == DuplicateBehavior.OVERWRITE:\r\n                    self._config_settings.remove(config_setting)\r\n                    self._config_settings.append(config_setting)\r\n\r\n                elif duplicate_behavior == DuplicateBehavior.RAISE_ERROR:\r\n                    raise ValueError(f\"Duplicate config setting: {config_setting}\")\r\n\r\n            else:\r\n                self._config_settings.append(config_setting)\r\n\r\n        if check_config:\r\n            self.check()\r\n\r\n    def loads(self, config_data: str, check_config: bool = True) -> None:\r\n        \"\"\"\r\n        Parse a tomli config from a string.\r\n\r\n        Args:\r\n            config_data (str): Config file data as a string.\r\n            check_config (bool, optional): Whether to check the config after loading it. Defaults to True.\r\n\r\n        Raises:\r\n            FileNotFoundError: Config file could not be found in the specified path.\r\n            TOMLDecodeError: Config file is not a valid TOML file.\r\n            ConfigValueMissing: A required config value is missing.\r\n            InvalidConfigValue: An invalid value was used in the config file.\r\n        \"\"\"\r\n        # Load settings from default config file\r\n        loaded_data: dict = tomli.loads(config_data)\r\n\r\n        if self._config_data:\r\n            temp_config = dict(merge(self._config_data, loaded_data))\r\n\r\n        else:\r\n            temp_config = loaded_data\r\n\r\n        self._config_data = temp_config\r\n\r\n        if check_config and self._config_settings:\r\n            self.check()\r\n\r\n    def _map_config_settings(self, settings: list[ConfigSetting], data: dict) -> dict[ConfigSetting, Any]:\r\n        \"\"\"\r\n        Map config settings to their values.\r\n        This function wil also unflatten data.\r\n\r\n        Args:\r\n            settings (list[ConfigSetting]): A list or tuple of ConfigSettings objects.\r\n            data (dict): A dictionary containing the config data.\r\n\r\n        Returns:\r\n            dict[ConfigSetting, Any]: A dictionary mapping config settings to their values.\r\n        \"\"\"\r\n        mapped_settings: dict = {}\r\n\r\n        for setting in settings:\r\n            if setting.category:\r\n                setting_categories = single_to_list(setting.category)\r\n                config_dict_iter: dict = data\r\n\r\n                for setting_category in setting_categories:\r\n                    if setting_category not in config_dict_iter:\r\n                        mapped_settings[setting] = None\r\n                        break\r\n\r\n                    config_dict_iter = config_dict_iter[setting_category]\r\n\r\n            else:\r\n                config_dict_iter = data\r\n\r\n            if setting.key not in config_dict_iter:\r\n                mapped_settings[setting] = None\r\n\r\n            else:\r\n                value = config_dict_iter[setting.key]\r\n                enum_type = setting.enum_type\r\n\r\n                if enum_type is not None:\r\n                    try:\r\n                        value = enum_type(value)\r\n\r\n                    except ValueError as e:\r\n                        setting_path = '.'.join(single_to_list(setting.category))\r\n                        raise InvalidEnumConfigValueError(setting_path=setting_path,\r\n                                                          value=value, enum_type=enum_type) from e\r\n\r\n                if type(value) in (list, tuple) and len(value) == 0:\r\n                    value = None\r\n\r\n                special_types = single_to_list(setting.special_type)\r\n\r\n                if SpecialConfigType.EXISTING_FILE_PATH in special_types:\r\n                    value = value.rstrip(r\"\\/\")\r\n\r\n                mapped_settings[setting] = value\r\n\r\n        return mapped_settings\r\n\r\n    def check(self) -> None:\r\n        \"\"\"\r\n        Check whether the config is valid by comparing config's data to the config settings.\r\n        Raises an error if an invalid value is found.\r\n\r\n        Raises:\r\n            MissingConfigValue: A required config value is missing.\r\n            InvalidConfigValue: An invalid value was used in the config file.\r\n        \"\"\"\r\n        if not (self._config_data and self._config_settings):\r\n            return\r\n\r\n        mapped_config = self._map_config_settings(self._config_settings, self._config_data)\r\n\r\n        for setting, value in mapped_config.items():\r\n            if isinstance(setting.category, (list, tuple)):\r\n                setting_path = '.'.join(setting.category) + f\".{setting.key}\"\r\n\r\n            elif isinstance(setting.category, str):\r\n                setting_path = setting.category + f\".{setting.key}\"\r\n\r\n            else:\r\n                setting_path = setting.key\r\n\r\n            if value is None:\r\n                if setting.required:\r\n                    raise MissingRequiredConfigSettingError(setting_path=setting_path)\r\n\r\n                continue\r\n\r\n            if setting.enum_type is None and not check_type(value, setting.value_type):\r\n                raise InvalidConfigTypeError(setting_path=setting_path, value=value, expected_type=setting.value_type)\r\n\r\n            special_types = single_to_list(setting.special_type)\r\n\r\n            if SpecialConfigType.EXISTING_FILE_PATH in special_types and not Path(value).is_file():\r\n                raise InvalidConfigFilePathError(setting_path=setting_path, value=value)\r\n\r\n            if SpecialConfigType.EXISTING_FOLDER_PATH in special_types and not Path(value).is_dir():\r\n                raise InvalidConfigFolderPathError(setting_path=setting_path, value=value)\r\n\r\n\r\nclass ConfigError(Exception):\r\n    pass\r\n\r\n\r\nclass MissingRequiredConfigSettingError(ConfigError):\r\n    \"\"\"A required config value is missing.\"\"\"\r\n    def __init__(self, setting_path: str):\r\n        super().__init__(f\"Missing required config value: '{setting_path}'.\")\r\n\r\n\r\nclass InvalidConfigValueError(ConfigError):\r\n    \"\"\"An invalid config setting has been set.\"\"\"\r\n    def __init__(self, setting_path: str, value: Any, additional_note: str | None = None):\r\n        message = f\"Invalid config value for '{setting_path}': '{value}'.\"\r\n\r\n        if additional_note:\r\n            message += f\"\\n{additional_note}\"\r\n\r\n        super().__init__(message)\r\n\r\n\r\nclass InvalidEnumConfigValueError(InvalidConfigValueError):\r\n    \"\"\"An invalid config value of an enum type setting has been set.\"\"\"\r\n    def __init__(self, setting_path: str, value: Any, enum_type: type[Enum]):\r\n        enum_options = ', '.join([f\"'{option.name}'\" for option in enum_type])\r\n\r\n        super().__init__(\r\n            setting_path=setting_path,\r\n            value=value,\r\n            additional_note=f\"Value can only be one of: {enum_options}.\",\r\n        )\r\n\r\n\r\nclass InvalidConfigTypeError(InvalidConfigValueError):\r\n    \"\"\"An invalid config value type has been set.\"\"\"\r\n    def __init__(self, setting_path: str,\r\n                 expected_type: type | typing._UnionGenericAlias,  # type: ignore[name-defined]\r\n                 value: Any):\r\n        expected_type_str = expected_type.__name__ if hasattr(expected_type, '__name__') else str(expected_type)\r\n        value_type_str = type(value).__name__ if hasattr(type(value), '__name__') else str(type(value))\r\n\r\n        super().__init__(\r\n            setting_path=setting_path,\r\n            value=value,\r\n            additional_note=f\"Expected type: '{expected_type_str}'. Received: '{value_type_str}'.\",\r\n        )\r\n\r\n\r\nclass InvalidConfigFilePathError(InvalidConfigValueError):\r\n    \"\"\"An invalid config value of a file path has been set.\"\"\"\r\n    def __init__(self, setting_path: str, value: str):\r\n        super().__init__(\r\n            setting_path=setting_path,\r\n            value=value,\r\n            additional_note=f\"File '{value}' not found.\",\r\n        )\r\n\r\n\r\nclass InvalidConfigFolderPathError(InvalidConfigValueError):\r\n    \"\"\"An invalid config value of a folder path has been set.\"\"\"\r\n    def __init__(self, setting_path: str, value: str):\r\n        super().__init__(\r\n            setting_path=setting_path,\r\n            value=value,\r\n            additional_note=f\"Folder '{value}' not found.\",\r\n        )\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/config.py b/isubrip/config.py
--- a/isubrip/config.py	(revision d3b0ef086b2efeb43e52af4565060033c2307487)
+++ b/isubrip/config.py	(date 1724110280822)
@@ -1,369 +1,102 @@
 from __future__ import annotations
 
-from copy import deepcopy
-from enum import Enum
+from abc import ABC
 from pathlib import Path
 import typing
-from typing import Any, NamedTuple, Type
-
-from mergedeep import merge
-import tomli
-
-from isubrip.utils import check_type, single_to_list
-
-
-class DuplicateBehavior(Enum):
-    """
-    An Enum representing optional behaviors for when a duplicate config key is found.
-
-    Attributes:
-        OVERWRITE: Overwrite the existing value with the new value.
-        IGNORE: Ignore the new value and keep the existing value.
-        RAISE_ERROR: Raise an error.
-    """
-    OVERWRITE = 1
-    IGNORE = 2
-    RAISE_ERROR = 3
-
-
-class SpecialConfigType(Enum):
-    """
-    An Enum representing special config value properties to validate.
-
-    Attributes:
-        EXISTING_FILE_PATH: The value must be of a path to an existing file.
-        EXISTING_FOLDER_PATH: The value must be of a path to an existing folder.
-    """
-    EXISTING_FILE_PATH = 1
-    EXISTING_FOLDER_PATH = 2
-
-
-class ConfigSetting(NamedTuple):
-    """
-    A NamedTuple representing a config setting.
-
-    Attributes:
-        key (str): Dictionary key used to access the setting.
-        value_type (type): Variable type of the value of the setting. Used for validation.
-        category (str | tuple[str, ...], optional): A category that the setting is under.
-            Categories are used to group related settings' keys together in a sub-dictionary.
-            A tuple can be used to nest categories (first item is the top-level category). Defaults to None.
-        required (bool, optional): Whether the setting is required. Defaults to False.
-        enum_type (type[Enum], optional): An Enum that the settings values will be converted to. Defaults to None.
-        special_type (SpecialConfigType | list[SpecialConfigType], optional): A special property of the setting's value
-            to validate, represented by a SpecialConfigType value. Defaults to None.
-    """
-    key: str
-    # TODO: Use `types.UnionType` instead of `typing._UnionGenericAlias`, once minimum Python version >= 3.10.
-    # TODO: Update 'InvalidConfigType' exception as well.
-    value_type: type | typing._UnionGenericAlias  # type: ignore[name-defined]
-    category: str | tuple[str, ...] | None = None
-    required: bool = False
-    enum_type: Type[Enum] | None = None
-    special_type: SpecialConfigType | list[SpecialConfigType] | None = None
-
-    def __eq__(self, other: Any) -> bool:
-        if isinstance(other, ConfigSetting):
-            return self.key == other.key and self.category == other.category
-        return False
-
-
-class Config:
-    """A class for managing iSubRip config files."""
-    def __init__(self, config_settings: list[ConfigSetting] | None = None, config_data: dict | None = None):
-        """
-        Create a new Config instance.
-
-        Args:
-            config_settings (list[ConfigSetting], optional): A list of ConfigSettings objects
-                that will be used for validations. Defaults to None.
-            config_data (dict, optional): A dict of config data to add to the config. Defaults to None.
-        """
-        self._config_settings: list = []
-        self._config_data: dict = {}
+from typing import List, Tuple, Type
 
-        if config_settings:
-            self.add_settings(config_settings, check_config=False)
+from pydantic import BaseModel, ConfigDict, create_model, Field, field_validator
+from pydantic_settings import BaseSettings, PydanticBaseSettingsSource, SettingsConfigDict, TomlConfigSettingsSource
 
-        if config_data:
-            self._config_data = deepcopy(config_data)
+from isubrip.constants import USER_CONFIG_FILE_PATH
+from isubrip.scrapers.scraper import ScraperFactory, ScraperConfigBase
+from isubrip.utils import normalize_config_name
 
-    def __contains__(self, item: Any) -> bool:
-        """
-        Allow checking if a key exists in the config using the 'in' operator.
 
-        Args:
-            item (Any): The key to check for.
+class ConfigCategory(BaseModel, ABC):
+    """A base class for settings categories."""
+    model_config = ConfigDict(
+        extra='allow',
+        alias_generator=normalize_config_name,
+    )
 
-        Returns:
-            bool: True if the key exists in the config, False otherwise.
-        """
-        return item in self._config_data
 
-    def __getattr__(self, key: str) -> Any:
-        """
-        Allow access to config settings using attributes.
+class GeneralCategory(ConfigCategory):
+    check_for_updates: bool = Field(default=True, alias="check-for-updates")
+    log_rotation_size: int = Field(default=15, alias="log-rotation-size")
 
-        Args:
-            key (str): Config key to get.
 
-        Returns:
-            Any: The corresponding value for the key in the config.
-        """
-        if self._config_data and key in self._config_data:
-            return self._config_data[key]
+class DownloadsCategory(ConfigCategory):
+    folder: Path = Field(default=Path.cwd().resolve())
+    languages: List[str] = Field(default=[])
+    overwrite_existing: bool = Field(default=False, alias="overwrite-existing")
+    zip: bool = Field(default=False)
 
-        raise AttributeError(f"Attribute '{key}' does not exist.")
-
-    def __getitem__(self, key: str) -> Any:
-        """
-        Allow access to config settings using dict-like syntax.
-
-        Args:
-            key (str): Config key to get.
-
-        Returns:
-            Any: The corresponding value for the key in the config.
-        """
-        return self._config_data[key]
-
-    def get(self, key: str, default: Any = None) -> Any:
-        """
-        Get a config value.
-
-        Args:
-            key (str): Config key to get.
-            default (Any, optional): Default value to return if the key does not exist. Defaults to None.
-
-        Returns:
-            Any: The corresponding value for the key in the config or the default value if the key does not exist.
-        """
-        return self._config_data.get(key, default)
-
-    @property
-    def data(self) -> dict:
-        return self._config_data
-
-    def add_settings(self, config_settings: ConfigSetting | list[ConfigSetting],
-                     duplicate_behavior: DuplicateBehavior = DuplicateBehavior.OVERWRITE,
-                     check_config: bool = True) -> None:
-        """
-        Add new config settings to the config.
-
-        Args:
-            config_settings (ConfigSetting | list[ConfigSetting]): A ConfigSetting object or a list of ConfigSetting
-                objects to add to the config.
-            duplicate_behavior (DuplicateBehavior, optional): Behaviour to apply if a duplicate is found.
-                Defaults to DuplicateBehavior.OVERWRITE.
-            check_config (bool, optional): Whether to check the config after loading it. Defaults to True.
-        """
-        config_settings_copy = deepcopy(single_to_list(config_settings))
-
-        for config_setting in config_settings_copy:
-            if config_setting in self._config_settings:
-                if duplicate_behavior == DuplicateBehavior.OVERWRITE:
-                    self._config_settings.remove(config_setting)
-                    self._config_settings.append(config_setting)
-
-                elif duplicate_behavior == DuplicateBehavior.RAISE_ERROR:
-                    raise ValueError(f"Duplicate config setting: {config_setting}")
-
-            else:
-                self._config_settings.append(config_setting)
-
-        if check_config:
-            self.check()
-
-    def loads(self, config_data: str, check_config: bool = True) -> None:
-        """
-        Parse a tomli config from a string.
-
-        Args:
-            config_data (str): Config file data as a string.
-            check_config (bool, optional): Whether to check the config after loading it. Defaults to True.
-
-        Raises:
-            FileNotFoundError: Config file could not be found in the specified path.
-            TOMLDecodeError: Config file is not a valid TOML file.
-            ConfigValueMissing: A required config value is missing.
-            InvalidConfigValue: An invalid value was used in the config file.
-        """
-        # Load settings from default config file
-        loaded_data: dict = tomli.loads(config_data)
-
-        if self._config_data:
-            temp_config = dict(merge(self._config_data, loaded_data))
-
-        else:
-            temp_config = loaded_data
-
-        self._config_data = temp_config
-
-        if check_config and self._config_settings:
-            self.check()
-
-    def _map_config_settings(self, settings: list[ConfigSetting], data: dict) -> dict[ConfigSetting, Any]:
-        """
-        Map config settings to their values.
-        This function wil also unflatten data.
-
-        Args:
-            settings (list[ConfigSetting]): A list or tuple of ConfigSettings objects.
-            data (dict): A dictionary containing the config data.
-
-        Returns:
-            dict[ConfigSetting, Any]: A dictionary mapping config settings to their values.
-        """
-        mapped_settings: dict = {}
-
-        for setting in settings:
-            if setting.category:
-                setting_categories = single_to_list(setting.category)
-                config_dict_iter: dict = data
-
-                for setting_category in setting_categories:
-                    if setting_category not in config_dict_iter:
-                        mapped_settings[setting] = None
-                        break
-
-                    config_dict_iter = config_dict_iter[setting_category]
-
-            else:
-                config_dict_iter = data
-
-            if setting.key not in config_dict_iter:
-                mapped_settings[setting] = None
+    @field_validator('folder')
+    @classmethod
+    def assure_path_exists(cls, value: Path):
+        if value.exists():
+            if not value.is_dir():
+                raise ValueError(f"Path '{value}' is not a directory.")
 
-            else:
-                value = config_dict_iter[setting.key]
-                enum_type = setting.enum_type
-
-                if enum_type is not None:
-                    try:
-                        value = enum_type(value)
-
-                    except ValueError as e:
-                        setting_path = '.'.join(single_to_list(setting.category))
-                        raise InvalidEnumConfigValueError(setting_path=setting_path,
-                                                          value=value, enum_type=enum_type) from e
-
-                if type(value) in (list, tuple) and len(value) == 0:
-                    value = None
-
-                special_types = single_to_list(setting.special_type)
-
-                if SpecialConfigType.EXISTING_FILE_PATH in special_types:
-                    value = value.rstrip(r"\/")
-
-                mapped_settings[setting] = value
-
-        return mapped_settings
-
-    def check(self) -> None:
-        """
-        Check whether the config is valid by comparing config's data to the config settings.
-        Raises an error if an invalid value is found.
-
-        Raises:
-            MissingConfigValue: A required config value is missing.
-            InvalidConfigValue: An invalid value was used in the config file.
-        """
-        if not (self._config_data and self._config_settings):
-            return
-
-        mapped_config = self._map_config_settings(self._config_settings, self._config_data)
+        else:
+            raise ValueError(f"Path '{value}' does not exist.")
 
-        for setting, value in mapped_config.items():
-            if isinstance(setting.category, (list, tuple)):
-                setting_path = '.'.join(setting.category) + f".{setting.key}"
 
-            elif isinstance(setting.category, str):
-                setting_path = setting.category + f".{setting.key}"
+class WebVTTSubcategory(ConfigCategory):
+    subrip_alignment_conversion: bool = Field(default=False, alias="subrip-alignment-conversion")
 
-            else:
-                setting_path = setting.key
 
-            if value is None:
-                if setting.required:
-                    raise MissingRequiredConfigSettingError(setting_path=setting_path)
+class SubtitlesCategory(ConfigCategory):
+    fix_rtl: bool = Field(default=False, alias="fix-rtl")
+    remove_duplicates: bool = Field(default=True, alias="remove-duplicates")
+    convert_to_srt: bool = Field(default=False, alias="convert-to-srt")
+    webvtt: WebVTTSubcategory = WebVTTSubcategory()
 
-                continue
 
-            if setting.enum_type is None and not check_type(value, setting.value_type):
-                raise InvalidConfigTypeError(setting_path=setting_path, value=value, expected_type=setting.value_type)
+class DefaultScraperSubcategory(ConfigCategory):
+    model_config = SettingsConfigDict(
+        extra='forbid',
+    )
 
-            special_types = single_to_list(setting.special_type)
-
-            if SpecialConfigType.EXISTING_FILE_PATH in special_types and not Path(value).is_file():
-                raise InvalidConfigFilePathError(setting_path=setting_path, value=value)
-
-            if SpecialConfigType.EXISTING_FOLDER_PATH in special_types and not Path(value).is_dir():
-                raise InvalidConfigFolderPathError(setting_path=setting_path, value=value)
-
-
-class ConfigError(Exception):
-    pass
-
-
-class MissingRequiredConfigSettingError(ConfigError):
-    """A required config value is missing."""
-    def __init__(self, setting_path: str):
-        super().__init__(f"Missing required config value: '{setting_path}'.")
-
-
-class InvalidConfigValueError(ConfigError):
-    """An invalid config setting has been set."""
-    def __init__(self, setting_path: str, value: Any, additional_note: str | None = None):
-        message = f"Invalid config value for '{setting_path}': '{value}'."
-
-        if additional_note:
-            message += f"\n{additional_note}"
-
-        super().__init__(message)
-
-
-class InvalidEnumConfigValueError(InvalidConfigValueError):
-    """An invalid config value of an enum type setting has been set."""
-    def __init__(self, setting_path: str, value: Any, enum_type: type[Enum]):
-        enum_options = ', '.join([f"'{option.name}'" for option in enum_type])
-
-        super().__init__(
-            setting_path=setting_path,
-            value=value,
-            additional_note=f"Value can only be one of: {enum_options}.",
-        )
-
+    timeout: float = Field(default=10)
+    user_agent: str = Field(
+        default="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36", # noqa: E501
+        alias="user-agent",
+    )
+    proxy: typing.Optional[str] = Field(default=None)
+    verify_ssl: bool = Field(default=True, alias="verify-ssl")
 
-class InvalidConfigTypeError(InvalidConfigValueError):
-    """An invalid config value type has been set."""
-    def __init__(self, setting_path: str,
-                 expected_type: type | typing._UnionGenericAlias,  # type: ignore[name-defined]
-                 value: Any):
-        expected_type_str = expected_type.__name__ if hasattr(expected_type, '__name__') else str(expected_type)
-        value_type_str = type(value).__name__ if hasattr(type(value), '__name__') else str(type(value))
 
-        super().__init__(
-            setting_path=setting_path,
-            value=value,
-            additional_note=f"Expected type: '{expected_type_str}'. Received: '{value_type_str}'.",
-        )
+# The scrapers model is created dynamically based on the available scrapers.
+ScrapersCategory = create_model(
+    'ScrapersCategory',
+    __base__=ConfigCategory,
+    default=(DefaultScraperSubcategory, DefaultScraperSubcategory()),
+    **{
+        scraper.id: (ScraperConfigBase, scraper.ScraperConfig())
+        for scraper in ScraperFactory.get_scraper_classes()
+    },
+)
 
-
-class InvalidConfigFilePathError(InvalidConfigValueError):
-    """An invalid config value of a file path has been set."""
-    def __init__(self, setting_path: str, value: str):
-        super().__init__(
-            setting_path=setting_path,
-            value=value,
-            additional_note=f"File '{value}' not found.",
-        )
+class NewConfig(BaseSettings):
+    model_config = SettingsConfigDict(
+        extra='forbid',
+        toml_file=USER_CONFIG_FILE_PATH,
+    )
 
+    general: GeneralCategory = GeneralCategory()
+    downloads: DownloadsCategory = DownloadsCategory()
+    subtitles: SubtitlesCategory = SubtitlesCategory()
+    scrapers: ScrapersCategory = ScrapersCategory()
 
-class InvalidConfigFolderPathError(InvalidConfigValueError):
-    """An invalid config value of a folder path has been set."""
-    def __init__(self, setting_path: str, value: str):
-        super().__init__(
-            setting_path=setting_path,
-            value=value,
-            additional_note=f"Folder '{value}' not found.",
-        )
+    @classmethod
+    def settings_customise_sources(
+        cls,
+        settings_cls: Type[BaseSettings],
+        init_settings: PydanticBaseSettingsSource,
+        env_settings: PydanticBaseSettingsSource,
+        dotenv_settings: PydanticBaseSettingsSource,
+        file_secret_settings: PydanticBaseSettingsSource,
+    ) -> Tuple[PydanticBaseSettingsSource, ...]:
+        return (TomlConfigSettingsSource(settings_cls),)
Index: isubrip/scrapers/scraper.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nfrom abc import ABC, abstractmethod\r\nimport asyncio\r\nfrom enum import Enum\r\nimport importlib\r\nimport inspect\r\nfrom pathlib import Path\r\nimport re\r\nimport sys\r\nfrom typing import TYPE_CHECKING, Any, ClassVar, List, Literal, Type, TypeVar, Union, overload\r\n\r\nimport httpx\r\nimport m3u8\r\n\r\nfrom isubrip.config import Config, ConfigSetting\r\nfrom isubrip.constants import PACKAGE_NAME, SCRAPER_MODULES_SUFFIX\r\nfrom isubrip.data_structures import (\r\n    MainPlaylist,\r\n    PlaylistMediaItem,\r\n    ScrapedMediaResponse,\r\n    SubtitlesData,\r\n    SubtitlesFormatType,\r\n    SubtitlesType,\r\n)\r\nfrom isubrip.logger import logger\r\nfrom isubrip.utils import SingletonMeta, merge_dict_values, single_to_list\r\n\r\nif TYPE_CHECKING:\r\n    from types import TracebackType\r\n\r\n    from isubrip.subtitle_formats.subtitles import Subtitles\r\n\r\nScraperT = TypeVar(\"ScraperT\", bound=\"Scraper\")\r\n\r\n\r\nclass Scraper(ABC, metaclass=SingletonMeta):\r\n    \"\"\"\r\n    A base class for scrapers.\r\n\r\n    Attributes:\r\n        _playlist_filters_config_category (ClassVar[str]): Config category to look for playlist filters.\r\n        default_user_agent (str): [Class Attribute]\r\n            Default user agent to use if no other user agent is specified when making requests.\r\n        default_proxy (str | None): [Class Attribute] Default proxy to use when making requests.\r\n        default_verify_ssl (bool): [Class Attribute] Whether to verify SSL certificates by default.\r\n        subtitles_fix_rtl (bool): [Class Attribute] Whether to fix RTL from downloaded subtitles.\r\n            A list of languages to fix RTL on. If None, a default list will be used.\r\n        subtitles_remove_duplicates (bool): [Class Attribute]\r\n            Whether to remove duplicate lines from downloaded subtitles.\r\n\r\n        id (str): [Class Attribute] ID of the scraper.\r\n        name (str): [Class Attribute] Name of the scraper.\r\n        abbreviation (str): [Class Attribute] Abbreviation of the scraper.\r\n        url_regex (re.Pattern | list[re.Pattern]): [Class Attribute] A RegEx pattern to find URLs matching the service.\r\n        subtitles_class (type[Subtitles]): [Class Attribute] Class of the subtitles format returned by the scraper.\r\n        is_movie_scraper (bool): [Class Attribute] Whether the scraper is for movies.\r\n        is_series_scraper (bool): [Class Attribute] Whether the scraper is for series.\r\n        uses_scrapers (list[str]): [Class Attribute] A list of IDs for other scraper classes that this scraper uses.\r\n            This assures that the config data for the other scrapers is passed as well.\r\n        _session (httpx.Client): A synchronous HTTP client session.\r\n        _async_session (httpx.AsyncClient): An asynchronous HTTP client session.\r\n        config (Config): A Config object containing scraper's configuration.\r\n    \"\"\"\r\n    _playlist_filters_config_category: ClassVar[str] = \"playlist-filters\"\r\n    default_timeout: ClassVar[int] = 10\r\n    default_user_agent: ClassVar[str] = httpx._client.USER_AGENT  # noqa: SLF001\r\n    default_proxy: ClassVar[str | None] = None\r\n    default_verify_ssl: ClassVar[bool] = True\r\n    subtitles_fix_rtl: ClassVar[bool] = False\r\n    subtitles_remove_duplicates: ClassVar[bool] = True\r\n\r\n    id: ClassVar[str]\r\n    name: ClassVar[str]\r\n    abbreviation: ClassVar[str]\r\n    url_regex: ClassVar[re.Pattern | list[re.Pattern]]\r\n    subtitles_class: ClassVar[type[Subtitles]]\r\n    is_movie_scraper: ClassVar[bool] = False\r\n    is_series_scraper: ClassVar[bool] = False\r\n    uses_scrapers: ClassVar[list[str]] = []\r\n\r\n    def __init__(self, timeout: int | float | None = None,\r\n                 user_agent: str | None = None, proxy: str | None = None,\r\n                 verify_ssl: bool | None = None, config_data: dict | None = None):\r\n        \"\"\"\r\n        Initialize a Scraper object.\r\n\r\n        Args:\r\n            timeout (int | float | None, optional): A timeout to use when making requests. Defaults to None.\r\n            user_agent (str | None, optional): A user agent to use when making requests. Defaults to None.\r\n            proxy (str | None, optional): A proxy to use when making requests. Defaults to None.\r\n            verify_ssl (bool | None, optional): Whether to verify SSL certificates. Defaults to None.\r\n            config_data (dict | None, optional): A dictionary containing scraper's configuration data. Defaults to None.\r\n        \"\"\"\r\n        self.config = Config(config_data=config_data.get(self.id) if config_data else None)\r\n\r\n        # Add a \"user-agent\" setting by default to all scrapers\r\n        self.config.add_settings([\r\n            ConfigSetting(\r\n                key=\"timeout\",\r\n                value_type=Union[int, float],\r\n                required=False,\r\n            ),\r\n            ConfigSetting(\r\n                key=\"user-agent\",\r\n                value_type=str,\r\n                required=False,\r\n            ),\r\n            ConfigSetting(\r\n                key=\"proxy\",\r\n                value_type=str,\r\n                required=False,\r\n            ),\r\n            ConfigSetting(\r\n                key=\"verify-ssl\",\r\n                value_type=bool,\r\n                required=False,\r\n            ),\r\n        ],\r\n            check_config=False)\r\n\r\n        self._user_agent: str\r\n        self._proxy: str | None\r\n        self._verify_ssl: bool\r\n\r\n        # Timeout Configuration\r\n        if timeout is not None:\r\n            self._timeout = timeout\r\n\r\n        elif \"timeout\" in self.config:\r\n            self._timeout = self.config[\"timeout\"]\r\n\r\n        else:\r\n            self._timeout = self.default_timeout\r\n\r\n        if self._timeout != self.default_timeout:\r\n            logger.debug(f\"Initializing '{self.name}' scraper with timeout: '{self._timeout}'.\")\r\n\r\n        # User-Agent Configuration\r\n        if user_agent is not None:\r\n            self._user_agent = user_agent\r\n\r\n        elif \"user-agent\" in self.config:\r\n            self._user_agent = self.config[\"user-agent\"]\r\n\r\n        else:\r\n            self._user_agent = self.default_user_agent\r\n\r\n        if self._user_agent != self.default_user_agent:\r\n            logger.debug(f\"Initializing '{self.name}' scraper with user-agent: '{self._user_agent}'.\")\r\n\r\n        # Proxy Configuration\r\n        if proxy is not None:\r\n            self._proxy = proxy or self.config.get(\"proxy\") or self.default_proxy\r\n\r\n        elif \"proxy\" in self.config:\r\n            self._proxy = self.config[\"proxy\"]\r\n\r\n        else:\r\n            self._proxy = self.default_proxy\r\n\r\n        if self._proxy != self.default_proxy:\r\n            logger.debug(f\"Initializing '{self.name}' scraper with proxy: '{self._proxy}'.\")\r\n\r\n        # SSL Verification Configuration\r\n        if verify_ssl is not None:\r\n            self._verify_ssl = verify_ssl\r\n\r\n        elif \"verify-ssl\" in self.config:\r\n            self._verify_ssl = self.config[\"verify-ssl\"]\r\n\r\n        else:\r\n            self._verify_ssl = self.default_verify_ssl\r\n\r\n        if self._verify_ssl != self.default_verify_ssl:\r\n            logger.debug(f\"Initializing '{self.name}' scraper with SSL verification set to: '{self._verify_ssl}'.\")\r\n\r\n        self._requests_counter = 0\r\n        clients_params: dict[str, Any] = {\r\n            \"headers\": {\"User-Agent\": self._user_agent},\r\n            \"verify\": self._verify_ssl,\r\n            \"proxy\": self._proxy,\r\n            \"timeout\": float(self._timeout),\r\n        }\r\n        self._session = httpx.Client(\r\n            **clients_params,\r\n            event_hooks={\r\n                \"request\": [self._increment_requests_counter],\r\n            },\r\n        )\r\n        self._async_session = httpx.AsyncClient(\r\n            **clients_params,\r\n            event_hooks={\r\n                \"request\": [self._async_increment_requests_counter],\r\n            },\r\n        )\r\n\r\n        # Update session settings according to configurations\r\n        self._session.headers.update({\"User-Agent\": self._user_agent})\r\n        self._async_session.headers.update({\"User-Agent\": self._user_agent})\r\n\r\n        if not self._verify_ssl:\r\n            import urllib3\r\n            urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\r\n\r\n    def _increment_requests_counter(self, request: httpx.Request) -> None:  # noqa: ARG002\r\n        self._requests_counter += 1\r\n\r\n    async def _async_increment_requests_counter(self, request: httpx.Request) -> None:  # noqa: ARG002\r\n        self._requests_counter += 1\r\n\r\n    @property\r\n    def requests_count(self) -> int:\r\n        return self._requests_counter\r\n\r\n    @classmethod\r\n    @overload\r\n    def match_url(cls, url: str, raise_error: Literal[True] = ...) -> re.Match:\r\n        ...\r\n\r\n    @classmethod\r\n    @overload\r\n    def match_url(cls, url: str, raise_error: Literal[False] = ...) -> re.Match | None:\r\n        ...\r\n\r\n    @classmethod\r\n    def match_url(cls, url: str, raise_error: bool = False) -> re.Match | None:\r\n        \"\"\"\r\n        Checks if a URL matches scraper's url regex.\r\n\r\n        Args:\r\n            url (str): A URL to check against the regex.\r\n            raise_error (bool, optional): Whether to raise an error instead of returning None if the URL doesn't match.\r\n\r\n        Returns:\r\n            re.Match | None: A Match object if the URL matches the regex, None otherwise (if raise_error is False).\r\n\r\n        Raises:\r\n            ValueError: If the URL doesn't match the regex and raise_error is True.\r\n        \"\"\"\r\n        if isinstance(cls.url_regex, re.Pattern) and (match_result := re.fullmatch(pattern=cls.url_regex, string=url)):\r\n            return match_result\r\n\r\n        if isinstance(cls.url_regex, list):\r\n            for url_regex_item in cls.url_regex:\r\n                if result := re.fullmatch(pattern=url_regex_item, string=url):\r\n                    return result\r\n\r\n        if raise_error:\r\n            raise ValueError(f\"URL '{url}' doesn't match the URL regex of {cls.name}.\")\r\n\r\n        return None\r\n\r\n    def __enter__(self) -> Scraper:\r\n        return self\r\n\r\n    def __exit__(self, exc_type: Type[BaseException] | None,\r\n                 exc_val: BaseException | None, exc_tb: TracebackType | None) -> None:\r\n        self.close()\r\n\r\n    async def async_close(self) -> None:\r\n        await self._async_session.aclose()\r\n\r\n    def close(self) -> None:\r\n        self._session.close()\r\n\r\n    @abstractmethod\r\n    async def get_data(self, url: str) -> ScrapedMediaResponse:\r\n        \"\"\"\r\n        Scrape media information about the media on a URL.\r\n\r\n        Args:\r\n            url (str): A URL to get media information about.\r\n\r\n        Returns:\r\n            ScrapedMediaResponse: A ScrapedMediaResponse object containing scraped media information.\r\n        \"\"\"\r\n\r\n    @abstractmethod\r\n    async def download_subtitles(self, media_data: PlaylistMediaItem, subrip_conversion: bool = False) -> SubtitlesData:\r\n        \"\"\"\r\n        Download subtitles from a media object.\r\n\r\n        Args:\r\n            media_data (PlaylistMediaItem): A media object to download subtitles from.\r\n            subrip_conversion (bool, optional): Whether to convert the subtitles to SubRip format. Defaults to False.\r\n\r\n        Returns:\r\n            SubtitlesData: A SubtitlesData object containing downloaded subtitles.\r\n        \"\"\"\r\n\r\n    @abstractmethod\r\n    def find_matching_media(self, main_playlist: MainPlaylist,\r\n                            filters: dict[str, str | list[str]] | None = None) -> list:\r\n        \"\"\"\r\n        Find media items that match the given filters in the main playlist (or all media items if no filters are given).\r\n\r\n        Args:\r\n            main_playlist (MainPlaylist): Main playlist to search for media items in.\r\n            filters (dict[str, str | list[str]] | None, optional): A dictionary of filters to match media items against.\r\n                Defaults to None.\r\n\r\n        Returns:\r\n            list: A list of media items that match the given filters.\r\n        \"\"\"\r\n\r\n    @abstractmethod\r\n    def find_matching_subtitles(self, main_playlist: MainPlaylist,\r\n                                language_filter: list[str] | None = None) -> list[PlaylistMediaItem]:\r\n        \"\"\"\r\n        Find subtitles that match the given language filter in the main playlist.\r\n\r\n        Args:\r\n            main_playlist (MainPlaylist): Main playlist to search for subtitles in.\r\n            language_filter (list[str] | None, optional): A list of language codes to filter subtitles by.\r\n                Defaults to None.\r\n\r\n        Returns:\r\n            list[PlaylistMediaItem]: A list of subtitles that match the given language filter.\r\n        \"\"\"\r\n\r\n    @abstractmethod\r\n    async def load_playlist(self, url: str | list[str], headers: dict | None = None) -> MainPlaylist | None:\r\n        \"\"\"\r\n        Load a playlist from a URL to a representing object.\r\n        Multiple URLs can be given, in which case the first one that loads successfully will be returned.\r\n\r\n        Args:\r\n            url (str | list[str]): URL of the M3U8 playlist to load. Can also be a list of URLs (for redundancy).\r\n            headers (dict | None, optional): A dictionary of headers to use when making the request.\r\n                Defaults to None (results in using session's configured headers).\r\n\r\n        Returns:\r\n            MainPlaylist | None: A playlist object (matching the type), or None if the playlist couldn't be loaded.\r\n        \"\"\"\r\n\r\n\r\nclass HLSScraper(Scraper, ABC):\r\n    \"\"\"A base class for HLS (m3u8) scrapers.\"\"\"\r\n    class M3U8Attribute(Enum):\r\n        \"\"\"\r\n        An enum representing all possible M3U8 attributes.\r\n        Names / Keys represent M3U8 Media object attributes (should be converted to lowercase),\r\n        and values represent the name of the key for config usage.\r\n        \"\"\"\r\n        ASSOC_LANGUAGE = \"assoc-language\"\r\n        AUTOSELECT = \"autoselect\"\r\n        CHARACTERISTICS = \"characteristics\"\r\n        CHANNELS = \"channels\"\r\n        DEFAULT = \"default\"\r\n        FORCED = \"forced\"\r\n        GROUP_ID = \"group-id\"\r\n        INSTREAM_ID = \"instream-id\"\r\n        LANGUAGE = \"language\"\r\n        NAME = \"name\"\r\n        STABLE_RENDITION_ID = \"stable-rendition-id\"\r\n        TYPE = \"type\"\r\n\r\n    _subtitles_filters: dict[str, str | list[str]] = {\r\n        M3U8Attribute.TYPE.value: \"SUBTITLES\",\r\n    }\r\n\r\n    def __init__(self,  user_agent: str | None = None, config_data: dict | None = None):\r\n        super().__init__(user_agent=user_agent, config_data=config_data)\r\n\r\n        # Add M3U8 filters settings\r\n        self.config.add_settings([\r\n            ConfigSetting(\r\n                category=self._playlist_filters_config_category,\r\n                key=m3u8_attribute.value,\r\n                value_type=Union[str, List[str]],\r\n                required=False,\r\n            ) for m3u8_attribute in self.M3U8Attribute],\r\n            check_config=False)\r\n\r\n    def parse_language_name(self, media_data: m3u8.Media) -> str | None:\r\n        \"\"\"\r\n        Parse the language name from an M3U8 Media object.\r\n        Can be overridden in subclasses for normalization.\r\n\r\n        Args:\r\n            media_data (m3u8.Media): Media object to parse the language name from.\r\n\r\n        Returns:\r\n            str | None: The language name if found, None otherwise.\r\n        \"\"\"\r\n        name: str | None = media_data.name\r\n        return name\r\n\r\n    async def load_playlist(self, url: str | list[str], headers: dict | None = None) -> m3u8.M3U8 | None:\r\n        _headers = headers or self._session.headers\r\n        result: m3u8.M3U8 | None = None\r\n\r\n        for url_item in single_to_list(url):\r\n            try:\r\n                response = await self._async_session.get(url=url_item, headers=_headers, timeout=5)\r\n\r\n            except Exception as e:\r\n                logger.debug(f\"Failed to load M3U8 playlist '{url_item}': {e}\")\r\n                continue\r\n\r\n            if not response.text:\r\n                raise PlaylistLoadError(\"Received empty response for playlist from server.\")\r\n\r\n            result = m3u8.loads(content=response.text, uri=url_item)\r\n            break\r\n\r\n        return result\r\n\r\n    @staticmethod\r\n    def detect_subtitles_type(subtitles_media: m3u8.Media) -> SubtitlesType | None:\r\n        \"\"\"\r\n        Detect the subtitles type (Closed Captions, Forced, etc.) from an M3U8 Media object.\r\n\r\n        Args:\r\n            subtitles_media (m3u8.Media): Subtitles Media object to detect the type of.\r\n\r\n        Returns:\r\n            SubtitlesType | None: The type of the subtitles, None for regular subtitles.\r\n        \"\"\"\r\n        if subtitles_media.forced == \"YES\":\r\n            return SubtitlesType.FORCED\r\n\r\n        if subtitles_media.characteristics is not None and \"public.accessibility\" in subtitles_media.characteristics:\r\n            return SubtitlesType.CC\r\n\r\n        return None\r\n\r\n    async def download_subtitles(self, media_data: m3u8.Media, subrip_conversion: bool = False) -> SubtitlesData:\r\n        playlist_m3u8 = await self.load_playlist(url=media_data.absolute_uri)\r\n\r\n        if playlist_m3u8 is None:\r\n            raise PlaylistLoadError(\"Could not load subtitles M3U8 playlist.\")\r\n\r\n        downloaded_segments = await self.download_segments(playlist=playlist_m3u8)\r\n        subtitles = self.subtitles_class(data=downloaded_segments[0], language_code=media_data.language)\r\n\r\n        if len(downloaded_segments) > 1:\r\n            for segment_data in downloaded_segments[1:]:\r\n                segment_subtitles_obj = self.subtitles_class(data=segment_data, language_code=media_data.language)\r\n                subtitles.append_subtitles(segment_subtitles_obj)\r\n\r\n        subtitles.polish(\r\n            fix_rtl=self.subtitles_fix_rtl,\r\n            remove_duplicates=self.subtitles_remove_duplicates,\r\n        )\r\n\r\n        if subrip_conversion:\r\n            subtitles_format = SubtitlesFormatType.SUBRIP\r\n            content = subtitles.to_srt().dump()\r\n\r\n        else:\r\n            subtitles_format = SubtitlesFormatType.WEBVTT\r\n            content = subtitles.dump()\r\n\r\n        return SubtitlesData(\r\n            language_code=media_data.language,\r\n            language_name=self.parse_language_name(media_data=media_data),\r\n            subtitles_format=subtitles_format,\r\n            content=content,\r\n            content_encoding=subtitles.encoding,\r\n            special_type=self.detect_subtitles_type(subtitles_media=media_data),\r\n        )\r\n\r\n    async def download_segments(self, playlist: m3u8.M3U8) -> list[bytes]:\r\n        responses = await asyncio.gather(\r\n            *[\r\n                self._async_session.get(url=segment.absolute_uri)\r\n                for segment in playlist.segments\r\n            ],\r\n        )\r\n\r\n        responses_data = []\r\n\r\n        for result in responses:\r\n            try:\r\n                result.raise_for_status()\r\n                responses_data.append(result.content)\r\n\r\n            except Exception as e:\r\n                raise DownloadError(\"One of the subtitles segments failed to download.\") from e\r\n\r\n        return responses_data\r\n\r\n    def find_matching_media(self, main_playlist: m3u8.M3U8,\r\n                            filters: dict[str, str | list[str]] | None = None) -> list[m3u8.Media]:\r\n        results: list[m3u8.Media] = []\r\n        config_filters: dict | None = self.config.get(self._playlist_filters_config_category)\r\n        playlist_filters: dict[str, Union[str, List[str]]] | None\r\n\r\n        if config_filters:\r\n            # Merge filtering dictionaries into a single dictionary\r\n            playlist_filters = merge_dict_values(\r\n                *[dict_item for dict_item in (filters, config_filters)\r\n                  if dict_item is not None],\r\n            )\r\n\r\n        else:\r\n            playlist_filters = filters\r\n\r\n        for media in main_playlist.media:\r\n            if not playlist_filters:\r\n                results.append(media)\r\n                continue\r\n\r\n            is_valid = True\r\n\r\n            for filter_name, filter_value in playlist_filters.items():\r\n                try:\r\n                    filter_name_enum = HLSScraper.M3U8Attribute(filter_name)\r\n                    attribute_value = getattr(media, filter_name_enum.name.lower(), None)\r\n\r\n                    if (attribute_value is None) or (\r\n                            isinstance(filter_value, list) and\r\n                            attribute_value.casefold() not in (x.casefold() for x in filter_value)\r\n                    ) or (\r\n                            isinstance(filter_value, str) and filter_value.casefold() != attribute_value.casefold()\r\n                    ):\r\n                        is_valid = False\r\n                        break\r\n\r\n                except Exception:\r\n                    is_valid = False\r\n\r\n            if is_valid:\r\n                results.append(media)\r\n\r\n        return results\r\n\r\n    def find_matching_subtitles(self, main_playlist: m3u8.M3U8,\r\n                                language_filter: list[str] | None = None) -> list[m3u8.Media]:\r\n        _filters = self._subtitles_filters\r\n\r\n        if language_filter:\r\n            _filters[self.M3U8Attribute.LANGUAGE.value] = language_filter\r\n\r\n        return self.find_matching_media(main_playlist=main_playlist, filters=_filters)\r\n\r\n\r\nclass ScraperFactory:\r\n    _scraper_classes_cache: list[type[Scraper]] | None = None\r\n    _scraper_instances_cache: dict[type[Scraper], Scraper] = {}\r\n    _currently_initializing: list[type[Scraper]] = []  # Used to prevent infinite recursion\r\n\r\n    @classmethod\r\n    def get_initialized_scrapers(cls) -> list[Scraper]:\r\n        \"\"\"\r\n        Get a list of all previously initialized scrapers.\r\n\r\n        Returns:\r\n            list[Scraper]: A list of initialized scrapers.\r\n        \"\"\"\r\n        return list(cls._scraper_instances_cache.values())\r\n\r\n    @classmethod\r\n    def get_scraper_classes(cls) -> list[type[Scraper]]:\r\n        \"\"\"\r\n        Find all scraper classes in the scrapers directory.\r\n\r\n        Returns:\r\n            list[Scraper]: A Scraper subclass.\r\n        \"\"\"\r\n        if cls._scraper_classes_cache is not None:\r\n            return cls._scraper_classes_cache\r\n\r\n        cls._scraper_classes_cache = []\r\n        scraper_modules_paths = Path(__file__).parent.glob(f\"*{SCRAPER_MODULES_SUFFIX}.py\")\r\n\r\n        for scraper_module_path in scraper_modules_paths:\r\n            sys.path.append(str(scraper_module_path))\r\n\r\n            module = importlib.import_module(f\"{PACKAGE_NAME}.scrapers.{scraper_module_path.stem}\")\r\n\r\n            # Find all 'Scraper' subclasses\r\n            for _, obj in inspect.getmembers(module,\r\n                                             predicate=lambda x: inspect.isclass(x) and issubclass(x, Scraper)):\r\n                # Skip object if it's an abstract or imported from another module\r\n                if not inspect.isabstract(obj) and obj.__module__ == module.__name__:\r\n                    cls._scraper_classes_cache.append(obj)\r\n\r\n        return cls._scraper_classes_cache\r\n\r\n    @classmethod\r\n    def _get_scraper_instance(cls, scraper_class: type[ScraperT], kwargs: dict | None = None,\r\n                              extract_scraper_config: bool = False) -> ScraperT:\r\n        \"\"\"\r\n        Initialize and return a scraper instance.\r\n\r\n        Args:\r\n            scraper_class (type[ScraperT]): A scraper class to initialize.\r\n            kwargs (dict | None, optional): A dictionary containing parameters to pass to the scraper's constructor.\r\n                Defaults to None.\r\n            extract_scraper_config (bool, optional): Whether the passed 'config_data' (within kwargs)\r\n                is a main config dictionary, and scraper's config should be extracted from it. Defaults to False.\r\n\r\n        Returns:\r\n            Scraper: An instance of the given scraper class.\r\n        \"\"\"\r\n        logger.debug(f\"Initializing '{scraper_class.name}' scraper...\")\r\n        kwargs = kwargs or {}\r\n\r\n        if scraper_class not in cls._scraper_instances_cache:\r\n            logger.debug(f\"'{scraper_class.name}' scraper not found in cache, creating a new instance...\")\r\n\r\n            if scraper_class in cls._currently_initializing:\r\n                raise ScraperError(f\"'{scraper_class.name}' scraper is already being initialized.\\n\"\r\n                                   f\"Make sure there are no circular dependencies between scrapers.\")\r\n\r\n            cls._currently_initializing.append(scraper_class)\r\n\r\n            if extract_scraper_config:\r\n                if kwargs.get(\"config_data\"):\r\n                    required_scrapers_ids = [scraper_class.id, *scraper_class.uses_scrapers]\r\n                    kwargs[\"config_data\"] = (\r\n                        {scraper_id: kwargs[\"config_data\"][scraper_id] for scraper_id in required_scrapers_ids\r\n                         if kwargs[\"config_data\"].get(scraper_id)}\r\n                    )\r\n\r\n                else:\r\n                    kwargs[\"config_data\"] = None\r\n\r\n            cls._scraper_instances_cache[scraper_class] = scraper_class(**kwargs)\r\n            cls._currently_initializing.remove(scraper_class)\r\n\r\n        else:\r\n            logger.debug(f\"Cached '{scraper_class.name}' scraper instance found and will be used.\")\r\n\r\n        return cls._scraper_instances_cache[scraper_class]  # type: ignore[return-value]\r\n\r\n    @classmethod\r\n    @overload\r\n    def get_scraper_instance(cls, scraper_class: type[ScraperT], scraper_id: str | None = ...,\r\n                             url: str | None = ..., kwargs: dict | None = ..., extract_scraper_config: bool = ...,\r\n                             raise_error: Literal[True] = ...) -> ScraperT:\r\n        ...\r\n\r\n    @classmethod\r\n    @overload\r\n    def get_scraper_instance(cls, scraper_class: type[ScraperT], scraper_id: str | None = ...,\r\n                             url: str | None = ..., kwargs: dict | None = ...,\r\n                             extract_scraper_config: bool = ...,\r\n                             raise_error: Literal[False] = ...) -> ScraperT | None:\r\n        ...\r\n\r\n    @classmethod\r\n    @overload\r\n    def get_scraper_instance(cls, scraper_class: None = ..., scraper_id: str | None = ...,\r\n                             url: str | None = ..., kwargs: dict | None = ..., extract_scraper_config: bool = ...,\r\n                             raise_error: Literal[True] = ...) -> Scraper:\r\n        ...\r\n\r\n    @classmethod\r\n    @overload\r\n    def get_scraper_instance(cls, scraper_class: None = ..., scraper_id: str | None = ...,\r\n                             url: str | None = ..., kwargs: dict | None = ..., extract_scraper_config: bool = ...,\r\n                             raise_error: Literal[False] = ...) -> Scraper | None:\r\n        ...\r\n\r\n    @classmethod\r\n    def get_scraper_instance(cls, scraper_class: type[Scraper] | None = None, scraper_id: str | None = None,\r\n                             url: str | None = None, kwargs: dict | None = None, extract_scraper_config: bool = False,\r\n                             raise_error: bool = True) -> Scraper | None:\r\n        \"\"\"\r\n        Find, initialize and return a scraper that matches the given URL or ID.\r\n\r\n        Args:\r\n            scraper_class (type[ScraperT] | None, optional): A scraper class to initialize. Defaults to None.\r\n            scraper_id (str | None, optional): ID of a scraper to initialize. Defaults to None.\r\n            url (str | None, optional): A URL to match a scraper for to initialize. Defaults to None.\r\n            kwargs (dict | None, optional): A dictionary containing parameters to pass to the scraper's constructor.\r\n                Defaults to None.\r\n            extract_scraper_config (bool, optional): Whether the passed 'config_data' (within kwargs)\r\n            raise_error (bool, optional): Whether to raise an error if no scraper was found. Defaults to False.\r\n\r\n        Returns:\r\n            ScraperT | Scraper | None: An instance of a scraper that matches the given URL or ID,\r\n                None otherwise (if raise_error is False).\r\n\r\n        Raises:\r\n            ValueError: If no scraper was found and raise_error is True.\r\n        \"\"\"\r\n        if scraper_class:\r\n            return cls._get_scraper_instance(scraper_class=scraper_class, kwargs=kwargs,\r\n                                             extract_scraper_config=extract_scraper_config)\r\n\r\n        if not (scraper_id or url):\r\n            raise ValueError(\"At least one of: 'scraper_class', 'scraper_id', or 'url' must be provided.\")\r\n\r\n        if scraper_id:\r\n            logger.debug(f\"Searching for a scraper object with ID '{scraper_id}'...\")\r\n            for scraper in cls.get_scraper_classes():\r\n                if scraper.id == scraper_id:\r\n                    return cls._get_scraper_instance(scraper_class=scraper, kwargs=kwargs,\r\n                                                     extract_scraper_config=extract_scraper_config)\r\n\r\n        elif url:\r\n            logger.debug(f\"Searching for a scraper object that matches URL '{url}'...\")\r\n            for scraper in cls.get_scraper_classes():\r\n                if scraper.match_url(url) is not None:\r\n                    return cls._get_scraper_instance(scraper_class=scraper, kwargs=kwargs,\r\n                                                     extract_scraper_config=extract_scraper_config)\r\n\r\n        error_message = \"No matching scraper was found.\"\r\n\r\n        if raise_error:\r\n            raise ValueError(error_message)\r\n\r\n        logger.debug(error_message)\r\n        return None\r\n\r\n\r\nclass ScraperError(Exception):\r\n    pass\r\n\r\n\r\nclass DownloadError(ScraperError):\r\n    pass\r\n\r\n\r\nclass PlaylistLoadError(ScraperError):\r\n    pass\r\n\r\n\r\nclass SubtitlesDownloadError(ScraperError):\r\n    def __init__(self, language_code: str, language_name: str | None = None, special_type: SubtitlesType | None = None,\r\n                 original_exc: Exception | None = None, *args: Any, **kwargs: dict[str, Any]):\r\n        \"\"\"\r\n        Initialize a SubtitlesDownloadError instance.\r\n\r\n        Args:\r\n            language_code (str): Language code of the subtitles that failed to download.\r\n            language_name (str | None, optional): Language name of the subtitles that failed to download.\r\n            special_type (SubtitlesType | None, optional): Type of the subtitles that failed to download.\r\n            original_exc (Exception | None, optional): The original exception that caused the error.\r\n        \"\"\"\r\n        super().__init__(*args, **kwargs)\r\n        self.language_code = language_code\r\n        self.language_name = language_name\r\n        self.special_type = special_type\r\n        self.original_exc = original_exc\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/scrapers/scraper.py b/isubrip/scrapers/scraper.py
--- a/isubrip/scrapers/scraper.py	(revision d3b0ef086b2efeb43e52af4565060033c2307487)
+++ b/isubrip/scrapers/scraper.py	(date 1724110349145)
@@ -12,8 +12,8 @@
 
 import httpx
 import m3u8
+from pydantic import BaseModel, Field
 
-from isubrip.config import Config, ConfigSetting
 from isubrip.constants import PACKAGE_NAME, SCRAPER_MODULES_SUFFIX
 from isubrip.data_structures import (
     MainPlaylist,
@@ -24,7 +24,7 @@
     SubtitlesType,
 )
 from isubrip.logger import logger
-from isubrip.utils import SingletonMeta, merge_dict_values, single_to_list
+from isubrip.utils import SingletonMeta, merge_dict_values, normalize_config_name, single_to_list
 
 if TYPE_CHECKING:
     from types import TracebackType
@@ -34,6 +34,32 @@
 ScraperT = TypeVar("ScraperT", bound="Scraper")
 
 
+class ScraperConfigBase(BaseModel, ABC):
+    """
+    A Pydantic BaseModel for a scraper's configuration.
+
+    Attributes:
+        timeout (int | float | None): Timeout to use when making requests.
+        user_agent (str | None): User agent to use when making requests.
+        proxy (str | None): Proxy to use when making requests.
+        verify_ssl (bool): Whether to verify SSL certificates.
+    """
+    model_config = ConfigDict(
+        extra='allow',
+        alias_generator=normalize_config_name,
+    )
+
+    timeout: int | float | None = Field(default=None)
+    user_agent: str | None = Field(default=None, alias="user-agent")
+    proxy: str | None = Field(default=None)
+    verify_ssl: bool | None = Field(default=None, alias="verify-ssl")
+
+
+class ScraperConfigSubcategory(BaseModel, ABC):
+    pass
+
+
+
 class Scraper(ABC, metaclass=SingletonMeta):
     """
     A base class for scrapers.
@@ -49,7 +75,7 @@
         subtitles_remove_duplicates (bool): [Class Attribute]
             Whether to remove duplicate lines from downloaded subtitles.
 
-        id (str): [Class Attribute] ID of the scraper.
+        id (str): [Class Attribute] ID of the scraper (must be unique).
         name (str): [Class Attribute] Name of the scraper.
         abbreviation (str): [Class Attribute] Abbreviation of the scraper.
         url_regex (re.Pattern | list[re.Pattern]): [Class Attribute] A RegEx pattern to find URLs matching the service.
@@ -60,7 +86,10 @@
             This assures that the config data for the other scrapers is passed as well.
         _session (httpx.Client): A synchronous HTTP client session.
         _async_session (httpx.AsyncClient): An asynchronous HTTP client session.
-        config (Config): A Config object containing scraper's configuration.
+
+    Notes:
+        Each scraper should implement its own `ScraperConfig` class that inherits from `ScraperConfigBase`,
+        and sets which configuration settings it uses and supports.
     """
     _playlist_filters_config_category: ClassVar[str] = "playlist-filters"
     default_timeout: ClassVar[int] = 10
@@ -79,9 +108,12 @@
     is_series_scraper: ClassVar[bool] = False
     uses_scrapers: ClassVar[list[str]] = []
 
-    def __init__(self, timeout: int | float | None = None,
-                 user_agent: str | None = None, proxy: str | None = None,
-                 verify_ssl: bool | None = None, config_data: dict | None = None):
+    class ScraperConfig(ScraperConfigBase):
+        """Set a default configuration for all scrapers using the default fields."""
+        pass
+
+    def __init__(self, timeout: int | float | None = None, user_agent: str | None = None,
+                 proxy: str | None = None, verify_ssl: bool | None = None):
         """
         Initialize a Scraper object.
 
@@ -90,35 +122,7 @@
             user_agent (str | None, optional): A user agent to use when making requests. Defaults to None.
             proxy (str | None, optional): A proxy to use when making requests. Defaults to None.
             verify_ssl (bool | None, optional): Whether to verify SSL certificates. Defaults to None.
-            config_data (dict | None, optional): A dictionary containing scraper's configuration data. Defaults to None.
         """
-        self.config = Config(config_data=config_data.get(self.id) if config_data else None)
-
-        # Add a "user-agent" setting by default to all scrapers
-        self.config.add_settings([
-            ConfigSetting(
-                key="timeout",
-                value_type=Union[int, float],
-                required=False,
-            ),
-            ConfigSetting(
-                key="user-agent",
-                value_type=str,
-                required=False,
-            ),
-            ConfigSetting(
-                key="proxy",
-                value_type=str,
-                required=False,
-            ),
-            ConfigSetting(
-                key="verify-ssl",
-                value_type=bool,
-                required=False,
-            ),
-        ],
-            check_config=False)
-
         self._user_agent: str
         self._proxy: str | None
         self._verify_ssl: bool
@@ -127,9 +131,6 @@
         if timeout is not None:
             self._timeout = timeout
 
-        elif "timeout" in self.config:
-            self._timeout = self.config["timeout"]
-
         else:
             self._timeout = self.default_timeout
 
@@ -139,42 +140,27 @@
         # User-Agent Configuration
         if user_agent is not None:
             self._user_agent = user_agent
-
-        elif "user-agent" in self.config:
-            self._user_agent = self.config["user-agent"]
+            logger.debug(f"Initializing '{self.name}' scraper with custom user-agent: '{self._user_agent}'.")
 
         else:
             self._user_agent = self.default_user_agent
 
-        if self._user_agent != self.default_user_agent:
-            logger.debug(f"Initializing '{self.name}' scraper with user-agent: '{self._user_agent}'.")
-
         # Proxy Configuration
         if proxy is not None:
-            self._proxy = proxy or self.config.get("proxy") or self.default_proxy
-
-        elif "proxy" in self.config:
-            self._proxy = self.config["proxy"]
+            self._proxy = proxy
+            logger.debug(f"Initializing '{self.name}' scraper with proxy: '{self._proxy}'.")
 
         else:
             self._proxy = self.default_proxy
 
-        if self._proxy != self.default_proxy:
-            logger.debug(f"Initializing '{self.name}' scraper with proxy: '{self._proxy}'.")
-
         # SSL Verification Configuration
         if verify_ssl is not None:
             self._verify_ssl = verify_ssl
-
-        elif "verify-ssl" in self.config:
-            self._verify_ssl = self.config["verify-ssl"]
+            logger.debug(f"Initializing '{self.name}' scraper with SSL verification set to: '{self._verify_ssl}'.")
 
         else:
             self._verify_ssl = self.default_verify_ssl
 
-        if self._verify_ssl != self.default_verify_ssl:
-            logger.debug(f"Initializing '{self.name}' scraper with SSL verification set to: '{self._verify_ssl}'.")
-
         self._requests_counter = 0
         clients_params: dict[str, Any] = {
             "headers": {"User-Agent": self._user_agent},
@@ -360,6 +346,15 @@
         M3U8Attribute.TYPE.value: "SUBTITLES",
     }
 
+    PlaylistFiltersSubcategory = create_model(
+        "PlaylistFiltersSubcategory",
+        # TODO
+    )
+
+    class ScraperConfig(ScraperConfigBase):
+
+
+
     def __init__(self,  user_agent: str | None = None, config_data: dict | None = None):
         super().__init__(user_agent=user_agent, config_data=config_data)
 
@@ -590,8 +585,6 @@
             scraper_class (type[ScraperT]): A scraper class to initialize.
             kwargs (dict | None, optional): A dictionary containing parameters to pass to the scraper's constructor.
                 Defaults to None.
-            extract_scraper_config (bool, optional): Whether the passed 'config_data' (within kwargs)
-                is a main config dictionary, and scraper's config should be extracted from it. Defaults to False.
 
         Returns:
             Scraper: An instance of the given scraper class.
@@ -608,17 +601,6 @@
 
             cls._currently_initializing.append(scraper_class)
 
-            if extract_scraper_config:
-                if kwargs.get("config_data"):
-                    required_scrapers_ids = [scraper_class.id, *scraper_class.uses_scrapers]
-                    kwargs["config_data"] = (
-                        {scraper_id: kwargs["config_data"][scraper_id] for scraper_id in required_scrapers_ids
-                         if kwargs["config_data"].get(scraper_id)}
-                    )
-
-                else:
-                    kwargs["config_data"] = None
-
             cls._scraper_instances_cache[scraper_class] = scraper_class(**kwargs)
             cls._currently_initializing.remove(scraper_class)
 
Index: pyproject.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[tool.poetry]\r\nname = \"isubrip\"\r\nversion = \"2.5.6\"\r\ndescription = \"A Python package for scraping and downloading subtitles from AppleTV / iTunes movie pages.\"\r\nlicense = \"MIT\"\r\nauthors = [\"Michael Yochpaz\"]\r\nreadme = \"README.md\"\r\nhomepage = \"https://github.com/MichaelYochpaz/iSubRip\"\r\nrepository = \"https://github.com/MichaelYochpaz/iSubRip\"\r\nkeywords = [\r\n    \"iTunes\",\r\n    \"AppleTV\",\r\n    \"movies\",\r\n    \"subtitles\",\r\n    \"scrape\",\r\n    \"scraper\",\r\n    \"download\",\r\n    \"m3u8\"\r\n]\r\nclassifiers = [\r\n    \"Development Status :: 5 - Production/Stable\",\r\n    \"Intended Audience :: End Users/Desktop\",\r\n    \"Intended Audience :: Developers\",\r\n    \"Operating System :: Microsoft :: Windows\",\r\n    \"Operating System :: MacOS\",\r\n    \"Operating System :: POSIX :: Linux\",\r\n    \"Topic :: Utilities\",\r\n    \"License :: OSI Approved :: MIT License\",\r\n    \"Programming Language :: Python :: 3.8\",\r\n    \"Programming Language :: Python :: 3.9\",\r\n    \"Programming Language :: Python :: 3.10\",\r\n    \"Programming Language :: Python :: 3.11\",\r\n    \"Programming Language :: Python :: 3.12\",\r\n]\r\npackages = [\r\n    { include = \"isubrip\" },\r\n]\r\ninclude = [\r\n    \"isubrip/resources\", \"README.md\", \"LICENSE\"\r\n]\r\n\r\n[tool.mypy]\r\ndisallow_untyped_defs = true\r\nexplicit_package_bases = true\r\nignore_missing_imports = true\r\npython_version = \"3.8\"\r\nwarn_return_any = true\r\n\r\n[tool.poetry.scripts]\r\nisubrip = \"isubrip.__main__:main\"\r\n\r\n[tool.poetry.urls]\r\n\"Bug Reports\" = \"https://github.com/MichaelYochpaz/iSubRip/issues\"\r\n\r\n[tool.poetry.dependencies]\r\npython = \"^3.8\"\r\nhttpx = {extras = [\"http2\"], version = \"^0.27.0\"}\r\nm3u8 = \"^4.1.0\"\r\nmergedeep = \"^1.3.4\"\r\npydantic = \"^2.7.0\"\r\ntomli = \"^2.0.1\"\r\n\r\n\r\n[tool.poetry.group.dev.dependencies]\r\nmypy = \"^1.10.0\"\r\nruff = \"^0.4.2\"\r\n\r\n[build-system]\r\nrequires = [\"poetry-core\"]\r\nbuild-backend = \"poetry.core.masonry.api\"\r\n\r\n[tool.poetry_bumpversion.file.\"isubrip/constants.py\"]\r\nsearch = 'PACKAGE_VERSION = \"{current_version}\"'\r\nreplace = 'PACKAGE_VERSION = \"{new_version}\"'\r\n\r\n\r\n[tool.ruff]\r\nline-length = 120\r\ntarget-version = \"py38\"\r\n\r\n[tool.ruff.lint]\r\nselect = [\r\n    \"ARG\",\r\n    \"ASYNC\",\r\n    \"B\",\r\n    \"C4\",\r\n    \"COM\",\r\n    \"E\",\r\n    \"F\",\r\n    \"FA\",\r\n    \"I\",\r\n    \"INP\",\r\n    \"ISC\",\r\n    \"N\",\r\n    \"PIE\",\r\n    \"PGH\",\r\n    \"PT\",\r\n    \"PTH\",\r\n    \"Q\",\r\n    \"RSE\",\r\n    \"RET\",\r\n    \"RUF\",\r\n    \"S\",\r\n    \"SIM\",\r\n    \"SLF\",\r\n    \"T20\",\r\n    \"TCH\",\r\n    \"TID\",\r\n    \"TRY\",\r\n    \"UP\",\r\n]\r\nignore = [\r\n    \"C416\",\r\n    \"Q000\",\r\n    \"RUF010\",\r\n    \"RUF012\",\r\n    \"SIM108\",\r\n    \"TD002\",\r\n    \"TD003\",\r\n    \"TRY003\",\r\n]\r\nunfixable = [\"ARG\"]\r\n\r\n[tool.ruff.lint.flake8-tidy-imports]\r\nban-relative-imports = \"all\"\r\n\r\n[tool.ruff.lint.flake8-quotes]\r\ndocstring-quotes = \"double\"\r\n\r\n[tool.ruff.lint.isort]\r\nforce-sort-within-sections = true\r\n\r\n[tool.ruff.lint.pyupgrade]\r\nkeep-runtime-typing = true
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pyproject.toml b/pyproject.toml
--- a/pyproject.toml	(revision d3b0ef086b2efeb43e52af4565060033c2307487)
+++ b/pyproject.toml	(date 1724109963112)
@@ -56,7 +56,6 @@
 python = "^3.8"
 httpx = {extras = ["http2"], version = "^0.27.0"}
 m3u8 = "^4.1.0"
-mergedeep = "^1.3.4"
 pydantic = "^2.7.0"
 tomli = "^2.0.1"
 
Index: isubrip/constants.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nimport asyncio\r\nimport datetime as dt\r\nimport logging\r\nfrom pathlib import Path\r\nfrom tempfile import gettempdir\r\n\r\n# General\r\nPACKAGE_NAME = \"isubrip\"\r\nPACKAGE_VERSION = \"2.5.6\"\r\n\r\n# Async\r\nEVENT_LOOP = asyncio.get_event_loop()\r\n\r\n# Logging\r\nPREORDER_MESSAGE = (\"'{movie_name}' is currently unavailable on {scraper_name}, \"\r\n                    \"and will be available on {preorder_date}.\")\r\n\r\nANSI_COLORS = {\r\n    logging.DEBUG: \"\\x1b[37;20m\",  # Light Grey\r\n    logging.INFO: \"\\x1b[38;20m\",  # Grey\r\n    logging.WARNING: \"\\x1b[33;20m\",  # Yellow\r\n    logging.ERROR: \"\\x1b[31;20m\",  # Red\r\n    logging.CRITICAL: \"\\x1b[31;1m\",  # Bold Red\r\n    }\r\nRESET_COLOR = \"\\x1b[0m\"\r\n\r\nLOGGING_DATE_FORMAT = \"%Y-%m-%d %H:%M:%S\"\r\nLOGGING_FILE_METADATA = \"[%(asctime)s | %(levelname)s | %(threadName)s | %(filename)s::%(funcName)s::%(lineno)d] \"\r\n\r\n# Downloads\r\nARCHIVE_FORMAT = \"zip\"\r\n\r\n# Paths\r\nDEFAULT_CONFIG_PATH = Path(__file__).parent / \"resources\" / \"default_config.toml\"\r\nDATA_FOLDER_PATH = Path.home() / f\".{PACKAGE_NAME}\"\r\nSCRAPER_MODULES_SUFFIX = \"_scraper\"\r\nTEMP_FOLDER_PATH = Path(gettempdir()) / PACKAGE_NAME\r\n\r\n# Config Paths\r\nUSER_CONFIG_FILE_NAME = \"config.toml\"\r\nUSER_CONFIG_FILE = DATA_FOLDER_PATH / USER_CONFIG_FILE_NAME\r\n\r\n# Logging Paths\r\nLOG_FILES_PATH = DATA_FOLDER_PATH / \"logs\"\r\nLOG_FILE_NAME = f\"{PACKAGE_NAME}_{dt.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.log\"\r\n\r\n# Other\r\nTITLE_REPLACEMENT_STRINGS = {  # Replacements will be done by the order of the keys.\r\n    \": \": \".\", \":\": \".\", \" - \": \"-\", \", \": \".\", \". \": \".\", \" \": \".\", \"|\": \".\", \"/\": \".\", \"\": \".\",\r\n    \"<\": \"\", \">\": \"\", \"(\": \"\", \")\": \"\", '\"': \"\", \"?\": \"\", \"*\": \"\",\r\n}\r\nWINDOWS_RESERVED_FILE_NAMES = (\"CON\", \"PRN\", \"AUX\", \"NUL\", \"COM1\", \"COM2\", \"COM3\", \"COM4\", \"COM5\", \"COM6\", \"COM7\",\r\n                               \"COM8\", \"COM9\", \"LPT1\", \"LPT2\", \"LPT3\", \"LPT4\", \"LPT5\", \"LPT6\", \"LPT7\", \"LPT8\", \"LPT9\")\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/constants.py b/isubrip/constants.py
--- a/isubrip/constants.py	(revision d3b0ef086b2efeb43e52af4565060033c2307487)
+++ b/isubrip/constants.py	(date 1724109963085)
@@ -40,7 +40,7 @@
 
 # Config Paths
 USER_CONFIG_FILE_NAME = "config.toml"
-USER_CONFIG_FILE = DATA_FOLDER_PATH / USER_CONFIG_FILE_NAME
+USER_CONFIG_FILE_PATH = DATA_FOLDER_PATH / USER_CONFIG_FILE_NAME
 
 # Logging Paths
 LOG_FILES_PATH = DATA_FOLDER_PATH / "logs"
Index: isubrip/resources/default_config.toml
===================================================================
diff --git a/isubrip/resources/default_config.toml b/isubrip/resources/default_config.toml
deleted file mode 100644
--- a/isubrip/resources/default_config.toml	(revision d3b0ef086b2efeb43e52af4565060033c2307487)
+++ /dev/null	(revision d3b0ef086b2efeb43e52af4565060033c2307487)
@@ -1,23 +0,0 @@
-# This is the default config file, containing all the default settings.
-# Settings set on the user config will override these.
-
-[general]
-check-for-updates = true
-log-rotation-size = 15
-
-[downloads]
-folder = "."
-merge-playlists = false
-overwrite-existing = false
-zip = true
-
-[subtitles]
-fix-rtl = false
-remove-duplicates = true
-convert-to-srt = false
-
-[subtitles.webvtt]
-subrip-alignment-conversion = false
-
-[scrapers]
-user-agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36"
Index: poetry.lock
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This file is automatically @generated by Poetry 1.7.1 and should not be changed by hand.\r\n\r\n[[package]]\r\nname = \"annotated-types\"\r\nversion = \"0.7.0\"\r\ndescription = \"Reusable constraint types to use with typing.Annotated\"\r\noptional = false\r\npython-versions = \">=3.8\"\r\nfiles = [\r\n    {file = \"annotated_types-0.7.0-py3-none-any.whl\", hash = \"sha256:1f02e8b43a8fbbc3f3e0d4f0f4bfc8131bcb4eebe8849b8e5c773f3a1c582a53\"},\r\n    {file = \"annotated_types-0.7.0.tar.gz\", hash = \"sha256:aff07c09a53a08bc8cfccb9c85b05f1aa9a2a6f23728d790723543408344ce89\"},\r\n]\r\n\r\n[package.dependencies]\r\ntyping-extensions = {version = \">=4.0.0\", markers = \"python_version < \\\"3.9\\\"\"}\r\n\r\n[[package]]\r\nname = \"anyio\"\r\nversion = \"4.4.0\"\r\ndescription = \"High level compatibility layer for multiple asynchronous event loop implementations\"\r\noptional = false\r\npython-versions = \">=3.8\"\r\nfiles = [\r\n    {file = \"anyio-4.4.0-py3-none-any.whl\", hash = \"sha256:c1b2d8f46a8a812513012e1107cb0e68c17159a7a594208005a57dc776e1bdc7\"},\r\n    {file = \"anyio-4.4.0.tar.gz\", hash = \"sha256:5aadc6a1bbb7cdb0bede386cac5e2940f5e2ff3aa20277e991cf028e0585ce94\"},\r\n]\r\n\r\n[package.dependencies]\r\nexceptiongroup = {version = \">=1.0.2\", markers = \"python_version < \\\"3.11\\\"\"}\r\nidna = \">=2.8\"\r\nsniffio = \">=1.1\"\r\ntyping-extensions = {version = \">=4.1\", markers = \"python_version < \\\"3.11\\\"\"}\r\n\r\n[package.extras]\r\ndoc = [\"Sphinx (>=7)\", \"packaging\", \"sphinx-autodoc-typehints (>=1.2.0)\", \"sphinx-rtd-theme\"]\r\ntest = [\"anyio[trio]\", \"coverage[toml] (>=7)\", \"exceptiongroup (>=1.2.0)\", \"hypothesis (>=4.0)\", \"psutil (>=5.9)\", \"pytest (>=7.0)\", \"pytest-mock (>=3.6.1)\", \"trustme\", \"uvloop (>=0.17)\"]\r\ntrio = [\"trio (>=0.23)\"]\r\n\r\n[[package]]\r\nname = \"backports-datetime-fromisoformat\"\r\nversion = \"2.0.1\"\r\ndescription = \"Backport of Python 3.11's datetime.fromisoformat\"\r\noptional = false\r\npython-versions = \">3\"\r\nfiles = [\r\n    {file = \"backports-datetime-fromisoformat-2.0.1.tar.gz\", hash = \"sha256:1b6afca7f47019c22df43062cde73c1af65fbdebc66520f352c690d52fd27127\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp310-cp310-macosx_10_9_universal2.whl\", hash = \"sha256:b739ccd3f36244f618f1fbc21d89894d9dc9d1d75a68762fcf917d433df38ae3\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp310-cp310-macosx_10_9_x86_64.whl\", hash = \"sha256:afd072ca32f2ca4e838e0f7b61a56168d98837ee9a182c567a49a834e07c2b98\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp310-cp310-macosx_11_0_arm64.whl\", hash = \"sha256:1a136d85f8b1db4747aa9e56a8caa0ba77c5c25b761b18e2169ea7b1b516f012\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp310-cp310-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:5d3a0579958ade7db62c8238163e05d46a4de61c99cebb40031ed7409a44d5f6\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp310-cp310-musllinux_1_1_i686.whl\", hash = \"sha256:199df62af8feff5da0f4953fdc4a6994bcd7dbfe1db95901d8b93d05feda2ab5\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp310-cp310-musllinux_1_1_x86_64.whl\", hash = \"sha256:afe32e60a471831058ede14fc226d9f14120e6dc67d66fbbd36e1724826ad70b\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp310-cp310-win_amd64.whl\", hash = \"sha256:a1ba7e226a9694b20b713867f71b5ed2f662603c39875f14f968608d331fc96a\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp37-cp37m-macosx_10_9_x86_64.whl\", hash = \"sha256:403f155deecbe94d43d0679a74abb5c9ac441422a9ececcfde030fb133865659\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp37-cp37m-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:b4d2ee049997d3aa2e714489cb3c34864fb0f25786e7a4ff04ac9d82af58b453\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp37-cp37m-musllinux_1_1_i686.whl\", hash = \"sha256:20aa422769af9f72ca41d83238d4a3a008d6cd74bcff0a08befb11b0018d6aa5\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp37-cp37m-musllinux_1_1_x86_64.whl\", hash = \"sha256:8ea8d85c3c9afa4ad51b6644d26516d43493f44c2131c12a2ba959433f4417f6\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp37-cp37m-win_amd64.whl\", hash = \"sha256:812b8c34e88a7d9615c604f1a0473a4e6d664aba94086bffb0c55627f9e3fb68\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp38-cp38-macosx_10_9_universal2.whl\", hash = \"sha256:df5365930320b7a9d404cd6f7bc13988e28355e812aa42e21aa5c93443dcdd2e\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp38-cp38-macosx_10_9_x86_64.whl\", hash = \"sha256:fe3e3968c8dce4a44da2da81a6031e992a4ee62d130c2536696d215a4db2ce3c\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp38-cp38-macosx_11_0_arm64.whl\", hash = \"sha256:36a4abb678ab0d6a1965d70e21e424bcf7a52086a7afb1c5f13243a3d44fa2dd\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp38-cp38-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:96b7e806ade09a91d8ce195c197fc799d8fbe6b8ea9cde21f8a01f1090e51e33\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp38-cp38-musllinux_1_1_i686.whl\", hash = \"sha256:002a77bd4f549ff5e80f1ef4a9b69982746dd6190786b90abe3d9c69c9883ce4\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp38-cp38-musllinux_1_1_x86_64.whl\", hash = \"sha256:7b4ad0013a96b656ebf85079921ffb211623a1e28ff4981b3927690a2ed6df54\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp38-cp38-win_amd64.whl\", hash = \"sha256:065421723e735ce8f68dbb4486f07562ce8556ed543ceaa012189b9aa209f303\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp39-cp39-macosx_10_9_universal2.whl\", hash = \"sha256:a4bf1bec08bc84095ee379202466c948fe12cff1442f58ee1a91fac4c5164c97\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp39-cp39-macosx_10_9_x86_64.whl\", hash = \"sha256:1836aff09b8317e179cc7288856b61a450515d4b411f0ab723dc9692dfa5362e\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp39-cp39-macosx_11_0_arm64.whl\", hash = \"sha256:815f85a581b142bcf34632c3ce26f7e21003f101ce88b5649631330e334bbe35\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp39-cp39-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:6a6986cfd3bc40b41465a6c54c18a30ca8110333d0b71f6062af136db11c8ff0\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp39-cp39-musllinux_1_1_i686.whl\", hash = \"sha256:82741e732d71f78b44a8c3b95f33b3630e7bfbdb02e3fede3938cdf15d5b6a83\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp39-cp39-musllinux_1_1_x86_64.whl\", hash = \"sha256:4eac27abb51ee84e08d1dd1e908c16cae2078c217ff5b54092e6cb92107b4c6c\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-cp39-cp39-win_amd64.whl\", hash = \"sha256:3b730d72061523be9600bcd281ef353f7f73b1df095adbbdc364aac8f430c44c\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-pp310-pypy310_pp73-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:f6e8f28f4a68539192473f427ed86794931502d186e2fffa1926250550c1335a\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-pp37-pypy37_pp73-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:0cef151f1df77e413dc179607edb5bee11949ca5890e81c0bb742d96fec753fe\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-pp38-pypy38_pp73-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:c28c95d6df2a44fa3540e18e484596c03e8ff7112e2f93b664f482fe3a88720b\"},\r\n    {file = \"backports_datetime_fromisoformat-2.0.1-pp39-pypy39_pp73-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:91042b53de903e3725209ad6d69b6994ae4819614c0decd62d05dfea23f35e2b\"},\r\n]\r\n\r\n[[package]]\r\nname = \"certifi\"\r\nversion = \"2024.6.2\"\r\ndescription = \"Python package for providing Mozilla's CA Bundle.\"\r\noptional = false\r\npython-versions = \">=3.6\"\r\nfiles = [\r\n    {file = \"certifi-2024.6.2-py3-none-any.whl\", hash = \"sha256:ddc6c8ce995e6987e7faf5e3f1b02b302836a0e5d98ece18392cb1a36c72ad56\"},\r\n    {file = \"certifi-2024.6.2.tar.gz\", hash = \"sha256:3cd43f1c6fa7dedc5899d69d3ad0398fd018ad1a17fba83ddaf78aa46c747516\"},\r\n]\r\n\r\n[[package]]\r\nname = \"exceptiongroup\"\r\nversion = \"1.2.1\"\r\ndescription = \"Backport of PEP 654 (exception groups)\"\r\noptional = false\r\npython-versions = \">=3.7\"\r\nfiles = [\r\n    {file = \"exceptiongroup-1.2.1-py3-none-any.whl\", hash = \"sha256:5258b9ed329c5bbdd31a309f53cbfb0b155341807f6ff7606a1e801a891b29ad\"},\r\n    {file = \"exceptiongroup-1.2.1.tar.gz\", hash = \"sha256:a4785e48b045528f5bfe627b6ad554ff32def154f42372786903b7abcfe1aa16\"},\r\n]\r\n\r\n[package.extras]\r\ntest = [\"pytest (>=6)\"]\r\n\r\n[[package]]\r\nname = \"h11\"\r\nversion = \"0.14.0\"\r\ndescription = \"A pure-Python, bring-your-own-I/O implementation of HTTP/1.1\"\r\noptional = false\r\npython-versions = \">=3.7\"\r\nfiles = [\r\n    {file = \"h11-0.14.0-py3-none-any.whl\", hash = \"sha256:e3fe4ac4b851c468cc8363d500db52c2ead036020723024a109d37346efaa761\"},\r\n    {file = \"h11-0.14.0.tar.gz\", hash = \"sha256:8f19fbbe99e72420ff35c00b27a34cb9937e902a8b810e2c88300c6f0a3b699d\"},\r\n]\r\n\r\n[[package]]\r\nname = \"h2\"\r\nversion = \"4.1.0\"\r\ndescription = \"HTTP/2 State-Machine based protocol implementation\"\r\noptional = false\r\npython-versions = \">=3.6.1\"\r\nfiles = [\r\n    {file = \"h2-4.1.0-py3-none-any.whl\", hash = \"sha256:03a46bcf682256c95b5fd9e9a99c1323584c3eec6440d379b9903d709476bc6d\"},\r\n    {file = \"h2-4.1.0.tar.gz\", hash = \"sha256:a83aca08fbe7aacb79fec788c9c0bac936343560ed9ec18b82a13a12c28d2abb\"},\r\n]\r\n\r\n[package.dependencies]\r\nhpack = \">=4.0,<5\"\r\nhyperframe = \">=6.0,<7\"\r\n\r\n[[package]]\r\nname = \"hpack\"\r\nversion = \"4.0.0\"\r\ndescription = \"Pure-Python HPACK header compression\"\r\noptional = false\r\npython-versions = \">=3.6.1\"\r\nfiles = [\r\n    {file = \"hpack-4.0.0-py3-none-any.whl\", hash = \"sha256:84a076fad3dc9a9f8063ccb8041ef100867b1878b25ef0ee63847a5d53818a6c\"},\r\n    {file = \"hpack-4.0.0.tar.gz\", hash = \"sha256:fc41de0c63e687ebffde81187a948221294896f6bdc0ae2312708df339430095\"},\r\n]\r\n\r\n[[package]]\r\nname = \"httpcore\"\r\nversion = \"1.0.5\"\r\ndescription = \"A minimal low-level HTTP client.\"\r\noptional = false\r\npython-versions = \">=3.8\"\r\nfiles = [\r\n    {file = \"httpcore-1.0.5-py3-none-any.whl\", hash = \"sha256:421f18bac248b25d310f3cacd198d55b8e6125c107797b609ff9b7a6ba7991b5\"},\r\n    {file = \"httpcore-1.0.5.tar.gz\", hash = \"sha256:34a38e2f9291467ee3b44e89dd52615370e152954ba21721378a87b2960f7a61\"},\r\n]\r\n\r\n[package.dependencies]\r\ncertifi = \"*\"\r\nh11 = \">=0.13,<0.15\"\r\n\r\n[package.extras]\r\nasyncio = [\"anyio (>=4.0,<5.0)\"]\r\nhttp2 = [\"h2 (>=3,<5)\"]\r\nsocks = [\"socksio (==1.*)\"]\r\ntrio = [\"trio (>=0.22.0,<0.26.0)\"]\r\n\r\n[[package]]\r\nname = \"httpx\"\r\nversion = \"0.27.0\"\r\ndescription = \"The next generation HTTP client.\"\r\noptional = false\r\npython-versions = \">=3.8\"\r\nfiles = [\r\n    {file = \"httpx-0.27.0-py3-none-any.whl\", hash = \"sha256:71d5465162c13681bff01ad59b2cc68dd838ea1f10e51574bac27103f00c91a5\"},\r\n    {file = \"httpx-0.27.0.tar.gz\", hash = \"sha256:a0cb88a46f32dc874e04ee956e4c2764aba2aa228f650b06788ba6bda2962ab5\"},\r\n]\r\n\r\n[package.dependencies]\r\nanyio = \"*\"\r\ncertifi = \"*\"\r\nh2 = {version = \">=3,<5\", optional = true, markers = \"extra == \\\"http2\\\"\"}\r\nhttpcore = \"==1.*\"\r\nidna = \"*\"\r\nsniffio = \"*\"\r\n\r\n[package.extras]\r\nbrotli = [\"brotli\", \"brotlicffi\"]\r\ncli = [\"click (==8.*)\", \"pygments (==2.*)\", \"rich (>=10,<14)\"]\r\nhttp2 = [\"h2 (>=3,<5)\"]\r\nsocks = [\"socksio (==1.*)\"]\r\n\r\n[[package]]\r\nname = \"hyperframe\"\r\nversion = \"6.0.1\"\r\ndescription = \"HTTP/2 framing layer for Python\"\r\noptional = false\r\npython-versions = \">=3.6.1\"\r\nfiles = [\r\n    {file = \"hyperframe-6.0.1-py3-none-any.whl\", hash = \"sha256:0ec6bafd80d8ad2195c4f03aacba3a8265e57bc4cff261e802bf39970ed02a15\"},\r\n    {file = \"hyperframe-6.0.1.tar.gz\", hash = \"sha256:ae510046231dc8e9ecb1a6586f63d2347bf4c8905914aa84ba585ae85f28a914\"},\r\n]\r\n\r\n[[package]]\r\nname = \"idna\"\r\nversion = \"3.7\"\r\ndescription = \"Internationalized Domain Names in Applications (IDNA)\"\r\noptional = false\r\npython-versions = \">=3.5\"\r\nfiles = [\r\n    {file = \"idna-3.7-py3-none-any.whl\", hash = \"sha256:82fee1fc78add43492d3a1898bfa6d8a904cc97d8427f683ed8e798d07761aa0\"},\r\n    {file = \"idna-3.7.tar.gz\", hash = \"sha256:028ff3aadf0609c1fd278d8ea3089299412a7a8b9bd005dd08b9f8285bcb5cfc\"},\r\n]\r\n\r\n[[package]]\r\nname = \"m3u8\"\r\nversion = \"4.1.0\"\r\ndescription = \"Python m3u8 parser\"\r\noptional = false\r\npython-versions = \">=3.7\"\r\nfiles = [\r\n    {file = \"m3u8-4.1.0-py3-none-any.whl\", hash = \"sha256:981daed09f57b7590721b6437278e49f2c36c1bceaa8fbe48f585e1745571d17\"},\r\n    {file = \"m3u8-4.1.0.tar.gz\", hash = \"sha256:3b9d7e5bafbaae89f2464cb16f397887d8decf6b1b48d8de58711414dc1c7b45\"},\r\n]\r\n\r\n[package.dependencies]\r\nbackports-datetime-fromisoformat = {version = \"*\", markers = \"python_version < \\\"3.11\\\"\"}\r\n\r\n[[package]]\r\nname = \"mergedeep\"\r\nversion = \"1.3.4\"\r\ndescription = \"A deep merge function for \uD83D\uDC0D.\"\r\noptional = false\r\npython-versions = \">=3.6\"\r\nfiles = [\r\n    {file = \"mergedeep-1.3.4-py3-none-any.whl\", hash = \"sha256:70775750742b25c0d8f36c55aed03d24c3384d17c951b3175d898bd778ef0307\"},\r\n    {file = \"mergedeep-1.3.4.tar.gz\", hash = \"sha256:0096d52e9dad9939c3d975a774666af186eda617e6ca84df4c94dec30004f2a8\"},\r\n]\r\n\r\n[[package]]\r\nname = \"mypy\"\r\nversion = \"1.10.1\"\r\ndescription = \"Optional static typing for Python\"\r\noptional = false\r\npython-versions = \">=3.8\"\r\nfiles = [\r\n    {file = \"mypy-1.10.1-cp310-cp310-macosx_10_9_x86_64.whl\", hash = \"sha256:e36f229acfe250dc660790840916eb49726c928e8ce10fbdf90715090fe4ae02\"},\r\n    {file = \"mypy-1.10.1-cp310-cp310-macosx_11_0_arm64.whl\", hash = \"sha256:51a46974340baaa4145363b9e051812a2446cf583dfaeba124af966fa44593f7\"},\r\n    {file = \"mypy-1.10.1-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:901c89c2d67bba57aaaca91ccdb659aa3a312de67f23b9dfb059727cce2e2e0a\"},\r\n    {file = \"mypy-1.10.1-cp310-cp310-musllinux_1_1_x86_64.whl\", hash = \"sha256:0cd62192a4a32b77ceb31272d9e74d23cd88c8060c34d1d3622db3267679a5d9\"},\r\n    {file = \"mypy-1.10.1-cp310-cp310-win_amd64.whl\", hash = \"sha256:a2cbc68cb9e943ac0814c13e2452d2046c2f2b23ff0278e26599224cf164e78d\"},\r\n    {file = \"mypy-1.10.1-cp311-cp311-macosx_10_9_x86_64.whl\", hash = \"sha256:bd6f629b67bb43dc0d9211ee98b96d8dabc97b1ad38b9b25f5e4c4d7569a0c6a\"},\r\n    {file = \"mypy-1.10.1-cp311-cp311-macosx_11_0_arm64.whl\", hash = \"sha256:a1bbb3a6f5ff319d2b9d40b4080d46cd639abe3516d5a62c070cf0114a457d84\"},\r\n    {file = \"mypy-1.10.1-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:b8edd4e9bbbc9d7b79502eb9592cab808585516ae1bcc1446eb9122656c6066f\"},\r\n    {file = \"mypy-1.10.1-cp311-cp311-musllinux_1_1_x86_64.whl\", hash = \"sha256:6166a88b15f1759f94a46fa474c7b1b05d134b1b61fca627dd7335454cc9aa6b\"},\r\n    {file = \"mypy-1.10.1-cp311-cp311-win_amd64.whl\", hash = \"sha256:5bb9cd11c01c8606a9d0b83ffa91d0b236a0e91bc4126d9ba9ce62906ada868e\"},\r\n    {file = \"mypy-1.10.1-cp312-cp312-macosx_10_9_x86_64.whl\", hash = \"sha256:d8681909f7b44d0b7b86e653ca152d6dff0eb5eb41694e163c6092124f8246d7\"},\r\n    {file = \"mypy-1.10.1-cp312-cp312-macosx_11_0_arm64.whl\", hash = \"sha256:378c03f53f10bbdd55ca94e46ec3ba255279706a6aacaecac52ad248f98205d3\"},\r\n    {file = \"mypy-1.10.1-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:6bacf8f3a3d7d849f40ca6caea5c055122efe70e81480c8328ad29c55c69e93e\"},\r\n    {file = \"mypy-1.10.1-cp312-cp312-musllinux_1_1_x86_64.whl\", hash = \"sha256:701b5f71413f1e9855566a34d6e9d12624e9e0a8818a5704d74d6b0402e66c04\"},\r\n    {file = \"mypy-1.10.1-cp312-cp312-win_amd64.whl\", hash = \"sha256:3c4c2992f6ea46ff7fce0072642cfb62af7a2484efe69017ed8b095f7b39ef31\"},\r\n    {file = \"mypy-1.10.1-cp38-cp38-macosx_10_9_x86_64.whl\", hash = \"sha256:604282c886497645ffb87b8f35a57ec773a4a2721161e709a4422c1636ddde5c\"},\r\n    {file = \"mypy-1.10.1-cp38-cp38-macosx_11_0_arm64.whl\", hash = \"sha256:37fd87cab83f09842653f08de066ee68f1182b9b5282e4634cdb4b407266bade\"},\r\n    {file = \"mypy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:8addf6313777dbb92e9564c5d32ec122bf2c6c39d683ea64de6a1fd98b90fe37\"},\r\n    {file = \"mypy-1.10.1-cp38-cp38-musllinux_1_1_x86_64.whl\", hash = \"sha256:5cc3ca0a244eb9a5249c7c583ad9a7e881aa5d7b73c35652296ddcdb33b2b9c7\"},\r\n    {file = \"mypy-1.10.1-cp38-cp38-win_amd64.whl\", hash = \"sha256:1b3a2ffce52cc4dbaeee4df762f20a2905aa171ef157b82192f2e2f368eec05d\"},\r\n    {file = \"mypy-1.10.1-cp39-cp39-macosx_10_9_x86_64.whl\", hash = \"sha256:fe85ed6836165d52ae8b88f99527d3d1b2362e0cb90b005409b8bed90e9059b3\"},\r\n    {file = \"mypy-1.10.1-cp39-cp39-macosx_11_0_arm64.whl\", hash = \"sha256:c2ae450d60d7d020d67ab440c6e3fae375809988119817214440033f26ddf7bf\"},\r\n    {file = \"mypy-1.10.1-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:6be84c06e6abd72f960ba9a71561c14137a583093ffcf9bbfaf5e613d63fa531\"},\r\n    {file = \"mypy-1.10.1-cp39-cp39-musllinux_1_1_x86_64.whl\", hash = \"sha256:2189ff1e39db399f08205e22a797383613ce1cb0cb3b13d8bcf0170e45b96cc3\"},\r\n    {file = \"mypy-1.10.1-cp39-cp39-win_amd64.whl\", hash = \"sha256:97a131ee36ac37ce9581f4220311247ab6cba896b4395b9c87af0675a13a755f\"},\r\n    {file = \"mypy-1.10.1-py3-none-any.whl\", hash = \"sha256:71d8ac0b906354ebda8ef1673e5fde785936ac1f29ff6987c7483cfbd5a4235a\"},\r\n    {file = \"mypy-1.10.1.tar.gz\", hash = \"sha256:1f8f492d7db9e3593ef42d4f115f04e556130f2819ad33ab84551403e97dd4c0\"},\r\n]\r\n\r\n[package.dependencies]\r\nmypy-extensions = \">=1.0.0\"\r\ntomli = {version = \">=1.1.0\", markers = \"python_version < \\\"3.11\\\"\"}\r\ntyping-extensions = \">=4.1.0\"\r\n\r\n[package.extras]\r\ndmypy = [\"psutil (>=4.0)\"]\r\ninstall-types = [\"pip\"]\r\nmypyc = [\"setuptools (>=50)\"]\r\nreports = [\"lxml\"]\r\n\r\n[[package]]\r\nname = \"mypy-extensions\"\r\nversion = \"1.0.0\"\r\ndescription = \"Type system extensions for programs checked with the mypy type checker.\"\r\noptional = false\r\npython-versions = \">=3.5\"\r\nfiles = [\r\n    {file = \"mypy_extensions-1.0.0-py3-none-any.whl\", hash = \"sha256:4392f6c0eb8a5668a69e23d168ffa70f0be9ccfd32b5cc2d26a34ae5b844552d\"},\r\n    {file = \"mypy_extensions-1.0.0.tar.gz\", hash = \"sha256:75dbf8955dc00442a438fc4d0666508a9a97b6bd41aa2f0ffe9d2f2725af0782\"},\r\n]\r\n\r\n[[package]]\r\nname = \"pydantic\"\r\nversion = \"2.8.0\"\r\ndescription = \"Data validation using Python type hints\"\r\noptional = false\r\npython-versions = \">=3.8\"\r\nfiles = [\r\n    {file = \"pydantic-2.8.0-py3-none-any.whl\", hash = \"sha256:ead4f3a1e92386a734ca1411cb25d94147cf8778ed5be6b56749047676d6364e\"},\r\n    {file = \"pydantic-2.8.0.tar.gz\", hash = \"sha256:d970ffb9d030b710795878940bd0489842c638e7252fc4a19c3ae2f7da4d6141\"},\r\n]\r\n\r\n[package.dependencies]\r\nannotated-types = \">=0.4.0\"\r\npydantic-core = \"2.20.0\"\r\ntyping-extensions = [\r\n    {version = \">=4.12.2\", markers = \"python_version >= \\\"3.13\\\"\"},\r\n    {version = \">=4.6.1\", markers = \"python_version < \\\"3.13\\\"\"},\r\n]\r\n\r\n[package.extras]\r\nemail = [\"email-validator (>=2.0.0)\"]\r\n\r\n[[package]]\r\nname = \"pydantic-core\"\r\nversion = \"2.20.0\"\r\ndescription = \"Core functionality for Pydantic validation and serialization\"\r\noptional = false\r\npython-versions = \">=3.8\"\r\nfiles = [\r\n    {file = \"pydantic_core-2.20.0-cp310-cp310-macosx_10_12_x86_64.whl\", hash = \"sha256:e9dcd7fb34f7bfb239b5fa420033642fff0ad676b765559c3737b91f664d4fa9\"},\r\n    {file = \"pydantic_core-2.20.0-cp310-cp310-macosx_11_0_arm64.whl\", hash = \"sha256:649a764d9b0da29816889424697b2a3746963ad36d3e0968784ceed6e40c6355\"},\r\n    {file = \"pydantic_core-2.20.0-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:7701df088d0b05f3460f7ba15aec81ac8b0fb5690367dfd072a6c38cf5b7fdb5\"},\r\n    {file = \"pydantic_core-2.20.0-cp310-cp310-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:ab760f17c3e792225cdaef31ca23c0aea45c14ce80d8eff62503f86a5ab76bff\"},\r\n    {file = \"pydantic_core-2.20.0-cp310-cp310-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:cb1ad5b4d73cde784cf64580166568074f5ccd2548d765e690546cff3d80937d\"},\r\n    {file = \"pydantic_core-2.20.0-cp310-cp310-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:b81ec2efc04fc1dbf400647d4357d64fb25543bae38d2d19787d69360aad21c9\"},\r\n    {file = \"pydantic_core-2.20.0-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:c4a9732a5cad764ba37f3aa873dccb41b584f69c347a57323eda0930deec8e10\"},\r\n    {file = \"pydantic_core-2.20.0-cp310-cp310-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:6dc85b9e10cc21d9c1055f15684f76fa4facadddcb6cd63abab702eb93c98943\"},\r\n    {file = \"pydantic_core-2.20.0-cp310-cp310-musllinux_1_1_aarch64.whl\", hash = \"sha256:21d9f7e24f63fdc7118e6cc49defaab8c1d27570782f7e5256169d77498cf7c7\"},\r\n    {file = \"pydantic_core-2.20.0-cp310-cp310-musllinux_1_1_x86_64.whl\", hash = \"sha256:8b315685832ab9287e6124b5d74fc12dda31e6421d7f6b08525791452844bc2d\"},\r\n    {file = \"pydantic_core-2.20.0-cp310-none-win32.whl\", hash = \"sha256:c3dc8ec8b87c7ad534c75b8855168a08a7036fdb9deeeed5705ba9410721c84d\"},\r\n    {file = \"pydantic_core-2.20.0-cp310-none-win_amd64.whl\", hash = \"sha256:85770b4b37bb36ef93a6122601795231225641003e0318d23c6233c59b424279\"},\r\n    {file = \"pydantic_core-2.20.0-cp311-cp311-macosx_10_12_x86_64.whl\", hash = \"sha256:58e251bb5a5998f7226dc90b0b753eeffa720bd66664eba51927c2a7a2d5f32c\"},\r\n    {file = \"pydantic_core-2.20.0-cp311-cp311-macosx_11_0_arm64.whl\", hash = \"sha256:78d584caac52c24240ef9ecd75de64c760bbd0e20dbf6973631815e3ef16ef8b\"},\r\n    {file = \"pydantic_core-2.20.0-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:5084ec9721f82bef5ff7c4d1ee65e1626783abb585f8c0993833490b63fe1792\"},\r\n    {file = \"pydantic_core-2.20.0-cp311-cp311-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:6d0f52684868db7c218437d260e14d37948b094493f2646f22d3dda7229bbe3f\"},\r\n    {file = \"pydantic_core-2.20.0-cp311-cp311-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:1def125d59a87fe451212a72ab9ed34c118ff771e5473fef4f2f95d8ede26d75\"},\r\n    {file = \"pydantic_core-2.20.0-cp311-cp311-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:b34480fd6778ab356abf1e9086a4ced95002a1e195e8d2fd182b0def9d944d11\"},\r\n    {file = \"pydantic_core-2.20.0-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:d42669d319db366cb567c3b444f43caa7ffb779bf9530692c6f244fc635a41eb\"},\r\n    {file = \"pydantic_core-2.20.0-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:53b06aea7a48919a254b32107647be9128c066aaa6ee6d5d08222325f25ef175\"},\r\n    {file = \"pydantic_core-2.20.0-cp311-cp311-musllinux_1_1_aarch64.whl\", hash = \"sha256:1f038156b696a1c39d763b2080aeefa87ddb4162c10aa9fabfefffc3dd8180fa\"},\r\n    {file = \"pydantic_core-2.20.0-cp311-cp311-musllinux_1_1_x86_64.whl\", hash = \"sha256:3f0f3a4a23717280a5ee3ac4fb1f81d6fde604c9ec5100f7f6f987716bb8c137\"},\r\n    {file = \"pydantic_core-2.20.0-cp311-none-win32.whl\", hash = \"sha256:316fe7c3fec017affd916a0c83d6f1ec697cbbbdf1124769fa73328e7907cc2e\"},\r\n    {file = \"pydantic_core-2.20.0-cp311-none-win_amd64.whl\", hash = \"sha256:2d06a7fa437f93782e3f32d739c3ec189f82fca74336c08255f9e20cea1ed378\"},\r\n    {file = \"pydantic_core-2.20.0-cp312-cp312-macosx_10_12_x86_64.whl\", hash = \"sha256:d6f8c49657f3eb7720ed4c9b26624063da14937fc94d1812f1e04a2204db3e17\"},\r\n    {file = \"pydantic_core-2.20.0-cp312-cp312-macosx_11_0_arm64.whl\", hash = \"sha256:ad1bd2f377f56fec11d5cfd0977c30061cd19f4fa199bf138b200ec0d5e27eeb\"},\r\n    {file = \"pydantic_core-2.20.0-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:ed741183719a5271f97d93bbcc45ed64619fa38068aaa6e90027d1d17e30dc8d\"},\r\n    {file = \"pydantic_core-2.20.0-cp312-cp312-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:d82e5ed3a05f2dcb89c6ead2fd0dbff7ac09bc02c1b4028ece2d3a3854d049ce\"},\r\n    {file = \"pydantic_core-2.20.0-cp312-cp312-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:b2ba34a099576234671f2e4274e5bc6813b22e28778c216d680eabd0db3f7dad\"},\r\n    {file = \"pydantic_core-2.20.0-cp312-cp312-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:879ae6bb08a063b3e1b7ac8c860096d8fd6b48dd9b2690b7f2738b8c835e744b\"},\r\n    {file = \"pydantic_core-2.20.0-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:0b0eefc7633a04c0694340aad91fbfd1986fe1a1e0c63a22793ba40a18fcbdc8\"},\r\n    {file = \"pydantic_core-2.20.0-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:73deadd6fd8a23e2f40b412b3ac617a112143c8989a4fe265050fd91ba5c0608\"},\r\n    {file = \"pydantic_core-2.20.0-cp312-cp312-musllinux_1_1_aarch64.whl\", hash = \"sha256:35681445dc85446fb105943d81ae7569aa7e89de80d1ca4ac3229e05c311bdb1\"},\r\n    {file = \"pydantic_core-2.20.0-cp312-cp312-musllinux_1_1_x86_64.whl\", hash = \"sha256:0f6dd3612a3b9f91f2e63924ea18a4476656c6d01843ca20a4c09e00422195af\"},\r\n    {file = \"pydantic_core-2.20.0-cp312-none-win32.whl\", hash = \"sha256:7e37b6bb6e90c2b8412b06373c6978d9d81e7199a40e24a6ef480e8acdeaf918\"},\r\n    {file = \"pydantic_core-2.20.0-cp312-none-win_amd64.whl\", hash = \"sha256:7d4df13d1c55e84351fab51383520b84f490740a9f1fec905362aa64590b7a5d\"},\r\n    {file = \"pydantic_core-2.20.0-cp313-cp313-macosx_10_12_x86_64.whl\", hash = \"sha256:d43e7ab3b65e4dc35a7612cfff7b0fd62dce5bc11a7cd198310b57f39847fd6c\"},\r\n    {file = \"pydantic_core-2.20.0-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:7b6a24d7b5893392f2b8e3b7a0031ae3b14c6c1942a4615f0d8794fdeeefb08b\"},\r\n    {file = \"pydantic_core-2.20.0-cp313-cp313-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:b2f13c3e955a087c3ec86f97661d9f72a76e221281b2262956af381224cfc243\"},\r\n    {file = \"pydantic_core-2.20.0-cp313-cp313-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:72432fd6e868c8d0a6849869e004b8bcae233a3c56383954c228316694920b38\"},\r\n    {file = \"pydantic_core-2.20.0-cp313-cp313-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:d70a8ff2d4953afb4cbe6211f17268ad29c0b47e73d3372f40e7775904bc28fc\"},\r\n    {file = \"pydantic_core-2.20.0-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:8e49524917b8d3c2f42cd0d2df61178e08e50f5f029f9af1f402b3ee64574392\"},\r\n    {file = \"pydantic_core-2.20.0-cp313-cp313-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:a4f0f71653b1c1bad0350bc0b4cc057ab87b438ff18fa6392533811ebd01439c\"},\r\n    {file = \"pydantic_core-2.20.0-cp313-cp313-musllinux_1_1_aarch64.whl\", hash = \"sha256:16197e6f4fdecb9892ed2436e507e44f0a1aa2cff3b9306d1c879ea2f9200997\"},\r\n    {file = \"pydantic_core-2.20.0-cp313-cp313-musllinux_1_1_x86_64.whl\", hash = \"sha256:763602504bf640b3ded3bba3f8ed8a1cc2fc6a87b8d55c1c5689f428c49c947e\"},\r\n    {file = \"pydantic_core-2.20.0-cp313-none-win32.whl\", hash = \"sha256:a3f243f318bd9523277fa123b3163f4c005a3e8619d4b867064de02f287a564d\"},\r\n    {file = \"pydantic_core-2.20.0-cp313-none-win_amd64.whl\", hash = \"sha256:03aceaf6a5adaad3bec2233edc5a7905026553916615888e53154807e404545c\"},\r\n    {file = \"pydantic_core-2.20.0-cp38-cp38-macosx_10_12_x86_64.whl\", hash = \"sha256:d6f2d8b8da1f03f577243b07bbdd3412eee3d37d1f2fd71d1513cbc76a8c1239\"},\r\n    {file = \"pydantic_core-2.20.0-cp38-cp38-macosx_11_0_arm64.whl\", hash = \"sha256:a272785a226869416c6b3c1b7e450506152d3844207331f02f27173562c917e0\"},\r\n    {file = \"pydantic_core-2.20.0-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:efbb412d55a4ffe73963fed95c09ccb83647ec63b711c4b3752be10a56f0090b\"},\r\n    {file = \"pydantic_core-2.20.0-cp38-cp38-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:1e4f46189d8740561b43655263a41aac75ff0388febcb2c9ec4f1b60a0ec12f3\"},\r\n    {file = \"pydantic_core-2.20.0-cp38-cp38-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:87d3df115f4a3c8c5e4d5acf067d399c6466d7e604fc9ee9acbe6f0c88a0c3cf\"},\r\n    {file = \"pydantic_core-2.20.0-cp38-cp38-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:a340d2bdebe819d08f605e9705ed551c3feb97e4fd71822d7147c1e4bdbb9508\"},\r\n    {file = \"pydantic_core-2.20.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:616b9c2f882393d422ba11b40e72382fe975e806ad693095e9a3b67c59ea6150\"},\r\n    {file = \"pydantic_core-2.20.0-cp38-cp38-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:25c46bb2ff6084859bbcfdf4f1a63004b98e88b6d04053e8bf324e115398e9e7\"},\r\n    {file = \"pydantic_core-2.20.0-cp38-cp38-musllinux_1_1_aarch64.whl\", hash = \"sha256:23425eccef8f2c342f78d3a238c824623836c6c874d93c726673dbf7e56c78c0\"},\r\n    {file = \"pydantic_core-2.20.0-cp38-cp38-musllinux_1_1_x86_64.whl\", hash = \"sha256:52527e8f223ba29608d999d65b204676398009725007c9336651c2ec2d93cffc\"},\r\n    {file = \"pydantic_core-2.20.0-cp38-none-win32.whl\", hash = \"sha256:1c3c5b7f70dd19a6845292b0775295ea81c61540f68671ae06bfe4421b3222c2\"},\r\n    {file = \"pydantic_core-2.20.0-cp38-none-win_amd64.whl\", hash = \"sha256:8093473d7b9e908af1cef30025609afc8f5fd2a16ff07f97440fd911421e4432\"},\r\n    {file = \"pydantic_core-2.20.0-cp39-cp39-macosx_10_12_x86_64.whl\", hash = \"sha256:ee7785938e407418795e4399b2bf5b5f3cf6cf728077a7f26973220d58d885cf\"},\r\n    {file = \"pydantic_core-2.20.0-cp39-cp39-macosx_11_0_arm64.whl\", hash = \"sha256:0e75794883d635071cf6b4ed2a5d7a1e50672ab7a051454c76446ef1ebcdcc91\"},\r\n    {file = \"pydantic_core-2.20.0-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:344e352c96e53b4f56b53d24728217c69399b8129c16789f70236083c6ceb2ac\"},\r\n    {file = \"pydantic_core-2.20.0-cp39-cp39-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:978d4123ad1e605daf1ba5e01d4f235bcf7b6e340ef07e7122e8e9cfe3eb61ab\"},\r\n    {file = \"pydantic_core-2.20.0-cp39-cp39-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:3c05eaf6c863781eb834ab41f5963604ab92855822a2062897958089d1335dad\"},\r\n    {file = \"pydantic_core-2.20.0-cp39-cp39-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:bc7e43b4a528ffca8c9151b6a2ca34482c2fdc05e6aa24a84b7f475c896fc51d\"},\r\n    {file = \"pydantic_core-2.20.0-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:658287a29351166510ebbe0a75c373600cc4367a3d9337b964dada8d38bcc0f4\"},\r\n    {file = \"pydantic_core-2.20.0-cp39-cp39-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:1dacf660d6de692fe351e8c806e7efccf09ee5184865893afbe8e59be4920b4a\"},\r\n    {file = \"pydantic_core-2.20.0-cp39-cp39-musllinux_1_1_aarch64.whl\", hash = \"sha256:3e147fc6e27b9a487320d78515c5f29798b539179f7777018cedf51b7749e4f4\"},\r\n    {file = \"pydantic_core-2.20.0-cp39-cp39-musllinux_1_1_x86_64.whl\", hash = \"sha256:c867230d715a3dd1d962c8d9bef0d3168994ed663e21bf748b6e3a529a129aab\"},\r\n    {file = \"pydantic_core-2.20.0-cp39-none-win32.whl\", hash = \"sha256:22b813baf0dbf612752d8143a2dbf8e33ccb850656b7850e009bad2e101fc377\"},\r\n    {file = \"pydantic_core-2.20.0-cp39-none-win_amd64.whl\", hash = \"sha256:3a7235b46c1bbe201f09b6f0f5e6c36b16bad3d0532a10493742f91fbdc8035f\"},\r\n    {file = \"pydantic_core-2.20.0-pp310-pypy310_pp73-macosx_10_12_x86_64.whl\", hash = \"sha256:cafde15a6f7feaec2f570646e2ffc5b73412295d29134a29067e70740ec6ee20\"},\r\n    {file = \"pydantic_core-2.20.0-pp310-pypy310_pp73-macosx_11_0_arm64.whl\", hash = \"sha256:2aec8eeea0b08fd6bc2213d8e86811a07491849fd3d79955b62d83e32fa2ad5f\"},\r\n    {file = \"pydantic_core-2.20.0-pp310-pypy310_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:840200827984f1c4e114008abc2f5ede362d6e11ed0b5931681884dd41852ff1\"},\r\n    {file = \"pydantic_core-2.20.0-pp310-pypy310_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:f8ea1d8b7df522e5ced34993c423c3bf3735c53df8b2a15688a2f03a7d678800\"},\r\n    {file = \"pydantic_core-2.20.0-pp310-pypy310_pp73-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:d5b8376a867047bf08910573deb95d3c8dfb976eb014ee24f3b5a61ccc5bee1b\"},\r\n    {file = \"pydantic_core-2.20.0-pp310-pypy310_pp73-musllinux_1_1_aarch64.whl\", hash = \"sha256:d08264b4460326cefacc179fc1411304d5af388a79910832835e6f641512358b\"},\r\n    {file = \"pydantic_core-2.20.0-pp310-pypy310_pp73-musllinux_1_1_x86_64.whl\", hash = \"sha256:7a3639011c2e8a9628466f616ed7fb413f30032b891898e10895a0a8b5857d6c\"},\r\n    {file = \"pydantic_core-2.20.0-pp310-pypy310_pp73-win_amd64.whl\", hash = \"sha256:05e83ce2f7eba29e627dd8066aa6c4c0269b2d4f889c0eba157233a353053cea\"},\r\n    {file = \"pydantic_core-2.20.0-pp39-pypy39_pp73-macosx_10_12_x86_64.whl\", hash = \"sha256:603a843fea76a595c8f661cd4da4d2281dff1e38c4a836a928eac1a2f8fe88e4\"},\r\n    {file = \"pydantic_core-2.20.0-pp39-pypy39_pp73-macosx_11_0_arm64.whl\", hash = \"sha256:ac76f30d5d3454f4c28826d891fe74d25121a346c69523c9810ebba43f3b1cec\"},\r\n    {file = \"pydantic_core-2.20.0-pp39-pypy39_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:22e3b1d4b1b3f6082849f9b28427ef147a5b46a6132a3dbaf9ca1baa40c88609\"},\r\n    {file = \"pydantic_core-2.20.0-pp39-pypy39_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:2761f71faed820e25ec62eacba670d1b5c2709bb131a19fcdbfbb09884593e5a\"},\r\n    {file = \"pydantic_core-2.20.0-pp39-pypy39_pp73-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:a0586cddbf4380e24569b8a05f234e7305717cc8323f50114dfb2051fcbce2a3\"},\r\n    {file = \"pydantic_core-2.20.0-pp39-pypy39_pp73-musllinux_1_1_aarch64.whl\", hash = \"sha256:b8c46a8cf53e849eea7090f331ae2202cd0f1ceb090b00f5902c423bd1e11805\"},\r\n    {file = \"pydantic_core-2.20.0-pp39-pypy39_pp73-musllinux_1_1_x86_64.whl\", hash = \"sha256:b4a085bd04af7245e140d1b95619fe8abb445a3d7fdf219b3f80c940853268ef\"},\r\n    {file = \"pydantic_core-2.20.0-pp39-pypy39_pp73-win_amd64.whl\", hash = \"sha256:116b326ac82c8b315e7348390f6d30bcfe6e688a7d3f1de50ff7bcc2042a23c2\"},\r\n    {file = \"pydantic_core-2.20.0.tar.gz\", hash = \"sha256:366be8e64e0cb63d87cf79b4e1765c0703dd6313c729b22e7b9e378db6b96877\"},\r\n]\r\n\r\n[package.dependencies]\r\ntyping-extensions = \">=4.6.0,<4.7.0 || >4.7.0\"\r\n\r\n[[package]]\r\nname = \"ruff\"\r\nversion = \"0.4.10\"\r\ndescription = \"An extremely fast Python linter and code formatter, written in Rust.\"\r\noptional = false\r\npython-versions = \">=3.7\"\r\nfiles = [\r\n    {file = \"ruff-0.4.10-py3-none-macosx_10_12_x86_64.whl\", hash = \"sha256:5c2c4d0859305ac5a16310eec40e4e9a9dec5dcdfbe92697acd99624e8638dac\"},\r\n    {file = \"ruff-0.4.10-py3-none-macosx_11_0_arm64.whl\", hash = \"sha256:a79489607d1495685cdd911a323a35871abfb7a95d4f98fc6f85e799227ac46e\"},\r\n    {file = \"ruff-0.4.10-py3-none-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:b1dd1681dfa90a41b8376a61af05cc4dc5ff32c8f14f5fe20dba9ff5deb80cd6\"},\r\n    {file = \"ruff-0.4.10-py3-none-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:c75c53bb79d71310dc79fb69eb4902fba804a81f374bc86a9b117a8d077a1784\"},\r\n    {file = \"ruff-0.4.10-py3-none-manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:18238c80ee3d9100d3535d8eb15a59c4a0753b45cc55f8bf38f38d6a597b9739\"},\r\n    {file = \"ruff-0.4.10-py3-none-manylinux_2_17_ppc64.manylinux2014_ppc64.whl\", hash = \"sha256:d8f71885bce242da344989cae08e263de29752f094233f932d4f5cfb4ef36a81\"},\r\n    {file = \"ruff-0.4.10-py3-none-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:330421543bd3222cdfec481e8ff3460e8702ed1e58b494cf9d9e4bf90db52b9d\"},\r\n    {file = \"ruff-0.4.10-py3-none-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:9e9b6fb3a37b772628415b00c4fc892f97954275394ed611056a4b8a2631365e\"},\r\n    {file = \"ruff-0.4.10-py3-none-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:0f54c481b39a762d48f64d97351048e842861c6662d63ec599f67d515cb417f6\"},\r\n    {file = \"ruff-0.4.10-py3-none-musllinux_1_2_aarch64.whl\", hash = \"sha256:67fe086b433b965c22de0b4259ddfe6fa541c95bf418499bedb9ad5fb8d1c631\"},\r\n    {file = \"ruff-0.4.10-py3-none-musllinux_1_2_armv7l.whl\", hash = \"sha256:acfaaab59543382085f9eb51f8e87bac26bf96b164839955f244d07125a982ef\"},\r\n    {file = \"ruff-0.4.10-py3-none-musllinux_1_2_i686.whl\", hash = \"sha256:3cea07079962b2941244191569cf3a05541477286f5cafea638cd3aa94b56815\"},\r\n    {file = \"ruff-0.4.10-py3-none-musllinux_1_2_x86_64.whl\", hash = \"sha256:338a64ef0748f8c3a80d7f05785930f7965d71ca260904a9321d13be24b79695\"},\r\n    {file = \"ruff-0.4.10-py3-none-win32.whl\", hash = \"sha256:ffe3cd2f89cb54561c62e5fa20e8f182c0a444934bf430515a4b422f1ab7b7ca\"},\r\n    {file = \"ruff-0.4.10-py3-none-win_amd64.whl\", hash = \"sha256:67f67cef43c55ffc8cc59e8e0b97e9e60b4837c8f21e8ab5ffd5d66e196e25f7\"},\r\n    {file = \"ruff-0.4.10-py3-none-win_arm64.whl\", hash = \"sha256:dd1fcee327c20addac7916ca4e2653fbbf2e8388d8a6477ce5b4e986b68ae6c0\"},\r\n    {file = \"ruff-0.4.10.tar.gz\", hash = \"sha256:3aa4f2bc388a30d346c56524f7cacca85945ba124945fe489952aadb6b5cd804\"},\r\n]\r\n\r\n[[package]]\r\nname = \"sniffio\"\r\nversion = \"1.3.1\"\r\ndescription = \"Sniff out which async library your code is running under\"\r\noptional = false\r\npython-versions = \">=3.7\"\r\nfiles = [\r\n    {file = \"sniffio-1.3.1-py3-none-any.whl\", hash = \"sha256:2f6da418d1f1e0fddd844478f41680e794e6051915791a034ff65e5f100525a2\"},\r\n    {file = \"sniffio-1.3.1.tar.gz\", hash = \"sha256:f4324edc670a0f49750a81b895f35c3adb843cca46f0530f79fc1babb23789dc\"},\r\n]\r\n\r\n[[package]]\r\nname = \"tomli\"\r\nversion = \"2.0.1\"\r\ndescription = \"A lil' TOML parser\"\r\noptional = false\r\npython-versions = \">=3.7\"\r\nfiles = [\r\n    {file = \"tomli-2.0.1-py3-none-any.whl\", hash = \"sha256:939de3e7a6161af0c887ef91b7d41a53e7c5a1ca976325f429cb46ea9bc30ecc\"},\r\n    {file = \"tomli-2.0.1.tar.gz\", hash = \"sha256:de526c12914f0c550d15924c62d72abc48d6fe7364aa87328337a31007fe8a4f\"},\r\n]\r\n\r\n[[package]]\r\nname = \"typing-extensions\"\r\nversion = \"4.12.2\"\r\ndescription = \"Backported and Experimental Type Hints for Python 3.8+\"\r\noptional = false\r\npython-versions = \">=3.8\"\r\nfiles = [\r\n    {file = \"typing_extensions-4.12.2-py3-none-any.whl\", hash = \"sha256:04e5ca0351e0f3f85c6853954072df659d0d13fac324d0072316b67d7794700d\"},\r\n    {file = \"typing_extensions-4.12.2.tar.gz\", hash = \"sha256:1a7ead55c7e559dd4dee8856e3a88b41225abfe1ce8df57b7c13915fe121ffb8\"},\r\n]\r\n\r\n[metadata]\r\nlock-version = \"2.0\"\r\npython-versions = \"^3.8\"\r\ncontent-hash = \"109a156d3fe479346764588306552bc51ad6173d4afd0277a41678d6bf2b1989\"\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/poetry.lock b/poetry.lock
--- a/poetry.lock	(revision d3b0ef086b2efeb43e52af4565060033c2307487)
+++ b/poetry.lock	(date 1724109963106)
@@ -220,17 +220,6 @@
 [package.dependencies]
 backports-datetime-fromisoformat = {version = "*", markers = "python_version < \"3.11\""}
 
-[[package]]
-name = "mergedeep"
-version = "1.3.4"
-description = "A deep merge function for ."
-optional = false
-python-versions = ">=3.6"
-files = [
-    {file = "mergedeep-1.3.4-py3-none-any.whl", hash = "sha256:70775750742b25c0d8f36c55aed03d24c3384d17c951b3175d898bd778ef0307"},
-    {file = "mergedeep-1.3.4.tar.gz", hash = "sha256:0096d52e9dad9939c3d975a774666af186eda617e6ca84df4c94dec30004f2a8"},
-]
-
 [[package]]
 name = "mypy"
 version = "1.10.1"
@@ -473,4 +462,4 @@
 [metadata]
 lock-version = "2.0"
 python-versions = "^3.8"
-content-hash = "109a156d3fe479346764588306552bc51ad6173d4afd0277a41678d6bf2b1989"
+content-hash = "96486bf1b76d2c03c148ffde74d5afbd14f0643ece28a13ec969d18c35b7bd34"
