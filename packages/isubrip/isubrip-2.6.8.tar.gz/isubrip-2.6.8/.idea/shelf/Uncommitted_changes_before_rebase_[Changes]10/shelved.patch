Index: isubrip/scrapers/disneyplus_hotstar_scraper.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nimport datetime as dt\r\nfrom typing import Iterator\r\n\r\nfrom isubrip.config import Config, ConfigSetting\r\nfrom isubrip.data_structures import Episode, Movie, ScrapedMediaResponse, Season, Series, SubtitlesData\r\nfrom isubrip.scrapers.scraper import MovieScraper, ScraperException, SeriesScraper\r\nfrom isubrip.subtitle_formats.webvtt import WebVTTSubtitles\r\nfrom isubrip.utils import generate_url_params, parse_duration, parse_season_and_episode_tag, parse_url_params\r\n\r\n\r\nclass DisneyPlusHotstarScraper(MovieScraper, SeriesScraper):\r\n    \"\"\"An Apple TV scraper.\"\"\"\r\n    id = \"dsnphs\"\r\n    name = \"Disney+ (Hotstar)\"\r\n    abbreviation = \"DSNP\"\r\n    url_regex = r\"(?P<base_url>https?://(?:www\\.)?apps\\.disneyplus\\.com/(?P<slug>(?:(?P<country_code>[a-z]{2})/)?(?:(?P<media_type>movies|shows)/)?(?:(?P<media_name>[\\w\\-%]+)/)?(?P<media_id>(?:\\d{4,10}))))(?:\\?(?P<url_params>(?:).*))?\"  # noqa: E501\r\n    # TODO: Update regex - slug can have episode data. Ex: il/shows/mshpkht-sympsvn/1260023404/some-enchanted-evening/1260023628\r\n    subtitles_class = WebVTTSubtitles\r\n    is_movie_scraper = True\r\n    is_series_scraper = True\r\n\r\n    _api_url = \"https://www.apps.disneyplus.com/api/internal/bff\"\r\n    _player_params = {\r\n        \"client_capabilities\":\r\n            {\r\n                \"audio_channel\": [\"stereo\"],\r\n                \"container\": [\"fmp4\", \"ts\"],\r\n                \"dvr\": [\"short\"],\r\n                \"dynamic_range\": [\"sdr\"],\r\n                \"encryption\": [\"widevine\", \"plain\"],\r\n                \"ladder\": [\"tv\", \"phone\"],\r\n                \"package\": [\"dash\", \"hls\"],\r\n                \"resolution\": [\"sd\", \"hd\", \"fhd\"],\r\n                \"video_codec\": [\"h264\"],\r\n            },\r\n        \"drm_parameters\":\r\n            {\r\n                \"hdcp_version\": [\"HDCP_V2_2\"],\r\n                \"widevine_security_level\": [\"SW_SECURE_DECODE\"],\r\n                \"playready_security_level\": [],\r\n            }\r\n    }\r\n\r\n    def __init__(self, config_data: dict | None = None):\r\n        super().__init__(config_data)\r\n\r\n        if self.config is None:\r\n            self.config = Config()\r\n\r\n        # Add \"token\" setting to config\r\n        self.config.add_settings(\r\n            ConfigSetting(\r\n                key=\"token\",\r\n                type=str,\r\n                required=True,\r\n            ),\r\n            check_config=True)\r\n\r\n        self._session.headers.update({\r\n            \"Accept\": \"application/json\",\r\n            \"X-Hs-Usertoken\": self.config[\"token\"],\r\n            \"X-Hs-Platform\": \"web\",\r\n            \"X-Hs-Client\": \"platform:web;app_version:23.05.29.0;browser:Chrome;schema_version:0.0.854\"\r\n        })\r\n\r\n        # self._session.proxies.update({  # TODO: Remove\r\n        #     \"http\": \"127.0.0.1:8085\",\r\n        #     \"https\": \"127.0.0.1:8085\",\r\n        # })\r\n        #\r\n        # self._session.verify = False  # TODO: Remove\r\n\r\n    def _get_api_data(self, endpoint: str) -> dict:\r\n        \"\"\"\r\n        Retrieve data from the Disney+ Hotstar's API.\r\n\r\n        Args:\r\n            endpoint (str): API endpoint.\r\n\r\n        Returns:\r\n            dict: Data returned by the API for the given endpoint.\r\n        \"\"\"\r\n        response = self._session.get(f\"{self._api_url}/{endpoint}\")\r\n        response.raise_for_status()\r\n        return response.json()\r\n\r\n    def _get_episode_playlists(self, episode_slug: str) -> list[str]:\r\n        player_params = generate_url_params(data=self._player_params, remove_dict_spaces=True)\r\n        api_data = self._get_api_data(endpoint=f\"v2/slugs/{episode_slug}?{player_params}\")\r\n\r\n        player_config = api_data[\"success\"][\"page\"][\"spaces\"][\"player\"][\"widget_wrappers\"][0][\"widget\"][\"data\"] \\\r\n            [\"player_config\"]\r\n\r\n        return [\r\n            player_config[\"media_asset_v2\"][\"primary\"][\"content_url\"],\r\n            player_config[\"media_asset_v2\"][\"fallback\"][\"content_url\"]\r\n        ]\r\n\r\n    def _get_season_data(self, show_id: str, season_id: str) -> dict[int, dict]:\r\n        endpoint = f\"v2/pages/841/spaces/803/widgets/1196/widgets/168?content_id={show_id}&season_id={season_id}\"\r\n        paginated_data = []\r\n\r\n        # Get all paginated episodes data for the season\r\n        while endpoint:  # TODO: Increase page size\r\n            api_data = self._get_api_data(endpoint)\r\n            episodes_paginated_data = api_data[\"success\"][\"widget_wrapper\"][\"widget\"][\"data\"]\r\n            paginated_data.extend(episodes_paginated_data[\"items\"])\r\n            endpoint = episodes_paginated_data.get(\"next_tray_url\")\r\n\r\n        api_episodes_data = [episode_data[\"playable_content\"][\"data\"] for episode_data in paginated_data]\r\n        result_data: dict[int, dict] = {}\r\n\r\n        for episode_data in api_episodes_data:\r\n            page_slug = episode_data[\"actions\"][\"on_click\"][1][\"page_navigation\"][\"page_slug\"].split(\"?\")[0]\r\n            episode_data[\"playlists\"] = self._get_episode_playlists(episode_slug=page_slug.lstrip(\"/\"))\r\n            _, episode_number = parse_season_and_episode_tag(episode_data[\"tags\"][0][\"value\"])\r\n            # Remove unnecessary data\r\n            if 'actions' in episode_data:\r\n                episode_data.pop('actions')\r\n\r\n            if 'download_options' in episode_data:\r\n                episode_data.pop('download_options')\r\n\r\n            result_data[episode_number] = episode_data\r\n\r\n        return result_data\r\n\r\n    def get_series_data(self, show_slug: str) -> ScrapedMediaResponse[Series]:\r\n        api_data = self._get_api_data(endpoint=\"v2/slugs/\" + show_slug)\r\n        media_data = api_data[\"success\"][\"page\"][\"spaces\"][\"hero\"][\"widget_wrappers\"][0][\"widget\"][\"data\"]\r\n        seasons_data = api_data[\"success\"][\"page\"][\"spaces\"][\"tray\"][\"widget_wrappers\"][0][\"widget\"][\"data\"] \\\r\n            [\"category_picker\"][\"data\"][\"tabs\"]\r\n\r\n        show_name = media_data[\"content_info\"][\"title\"]\r\n        show_seasons: list[Season] = []\r\n        result_seasons_data: dict[int, dict[int, dict]] = {}\r\n\r\n        for season_data in [season_data[\"tab\"][\"data\"] for season_data in seasons_data]:\r\n            url_params = parse_url_params(season_data[\"tray_widget_url\"])  # TODO: Use the URL instead of parsing it and recreating it\r\n            season_episodes_data = self._get_season_data(show_id=url_params[\"content_id\"],\r\n                                                         season_id=url_params[\"season_id\"])\r\n            season_number = int(season_data[\"title\"].split(\" \")[1])\r\n            result_seasons_data[season_number] = season_episodes_data\r\n\r\n            season_episodes: list[Episode] = []\r\n\r\n            for episode_number, episode_data in season_episodes_data.items():\r\n                season_episodes.append(\r\n                    Episode(\r\n                        id=episode_data[\"cw_info\"][\"content_id\"],\r\n                        alt_id=None,\r\n                        title=show_name,\r\n                        release_date=None,\r\n                        playlist=episode_data[\"playlists\"].copy(),\r\n                        scraper=self,\r\n                        original_scraper=self,\r\n                        original_data=episode_data,\r\n                        episode_number=episode_number,\r\n                        episode_name=episode_data[\"title\"],\r\n                        season_number=season_number,\r\n                        episode_release_date=dt.datetime.strptime(episode_data[\"tags\"][1][\"value\"], \"%d %b %Y\"),\r\n                        duration=parse_duration(episode_data[\"tags\"][2][\"value\"]),\r\n                    )\r\n                )\r\n\r\n            show_seasons.append(\r\n                Season(\r\n                    id=None,\r\n                    alt_id=None,\r\n                    title=show_name,\r\n                    release_date=None,\r\n                    # TODO\r\n                ))\r\n\r\n        return Series(\r\n            title=media_data[\"title\"],\r\n        )\r\n\r\n    def get_movie_data(self, movie_id: str) -> ScrapedMediaResponse[Movie]:\r\n        pass\r\n\r\n    def get_data(self, url: str) -> ScrapedMediaResponse[Movie] | ScrapedMediaResponse[Series]:\r\n        regex_match = self.match_url(url, raise_error=True)\r\n        url_data = regex_match.groupdict()\r\n\r\n        if not all(url_data.get(key) for key in (\"country_code\", \"media_type\", \"media_name\", \"media_id\")):\r\n            raise ScraperException(f\"Complete slug URL required for scraping from '{self.name}'.\")\r\n\r\n        if url_data[\"media_type\"] == \"movies\":\r\n            return self.get_movie_data(url_data[\"media_id\"])\r\n\r\n        elif url_data[\"media_type\"] == \"shows\":\r\n            return self.get_series_data(url_data[\"slug\"])\r\n\r\n    def get_subtitles(self, main_playlist, language_filter: list[str] | None = None,\r\n                      subrip_conversion: bool = False) -> Iterator[SubtitlesData]:\r\n        pass\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/scrapers/disneyplus_hotstar_scraper.py b/isubrip/scrapers/disneyplus_hotstar_scraper.py
--- a/isubrip/scrapers/disneyplus_hotstar_scraper.py	(revision 7bf88b7bc1725879b9155f21c8b496c668bc2137)
+++ b/isubrip/scrapers/disneyplus_hotstar_scraper.py	(date 1691087312281)
@@ -194,6 +194,9 @@
         elif url_data["media_type"] == "shows":
             return self.get_series_data(url_data["slug"])
 
+        else:
+            raise ScraperException(f"Unknown media type '{url_data['media_type']}'.")
+
     def get_subtitles(self, main_playlist, language_filter: list[str] | None = None,
                       subrip_conversion: bool = False) -> Iterator[SubtitlesData]:
         pass
