Index: isubrip/scrapers/itunes_scraper.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nimport re\r\nfrom typing import TYPE_CHECKING, Iterator\r\n\r\nimport m3u8\r\nfrom requests.exceptions import HTTPError\r\n\r\nfrom isubrip.data_structures import SubtitlesData, SubtitlesFormatType\r\nfrom isubrip.logger import logger\r\nfrom isubrip.scrapers.scraper import HLSScraper, PlaylistLoadError, ScraperError, ScraperFactory, SubtitlesDownloadError\r\nfrom isubrip.subtitle_formats.webvtt import WebVTTSubtitles\r\nfrom isubrip.utils import merge_dict_values, raise_for_status\r\n\r\nif TYPE_CHECKING:\r\n    from isubrip.data_structures import Movie, ScrapedMediaResponse\r\n\r\n\r\nclass ItunesScraper(HLSScraper):\r\n    \"\"\"An iTunes movie data scraper.\"\"\"\r\n    id = \"itunes\"\r\n    name = \"iTunes\"\r\n    abbreviation = \"iT\"\r\n    url_regex = re.compile(r\"(?i)(?P<base_url>https?://itunes\\.apple\\.com/(?:(?P<country_code>[a-z]{2})/)?(?P<media_type>movie|tv-show|tv-season|show)/(?:(?P<media_name>[\\w\\-%]+)/)?(?P<media_id>id\\d{9,10}))(?:\\?(?P<url_params>.*))?\")\r\n    subtitles_class = WebVTTSubtitles\r\n    is_movie_scraper = True\r\n    uses_scrapers = [\"appletv\"]\r\n\r\n    _subtitles_filters = {\r\n        HLSScraper.M3U8Attribute.GROUP_ID.value: [\"subtitles_ak\", \"subtitles_vod-ak-amt.tv.apple.com\"],\r\n        **HLSScraper._subtitles_filters,  # noqa: SLF001\r\n    }\r\n\r\n    def __init__(self,  user_agent: str | None = None, config_data: dict | None = None):\r\n        super().__init__(user_agent=user_agent, config_data=config_data)\r\n        self._appletv_scraper = ScraperFactory.get_scraper_instance(\r\n            scraper_id=\"appletv\",\r\n            kwargs={\"config_data\": config_data},\r\n            extract_scraper_config=True,\r\n            raise_error=True,\r\n        )\r\n\r\n    def get_data(self, url: str) -> ScrapedMediaResponse[Movie]:\r\n        \"\"\"\r\n        Scrape iTunes to find info about a movie, and it's M3U8 main_playlist.\r\n\r\n        Args:\r\n            url (str): An iTunes store movie URL.\r\n\r\n        Raises:\r\n            InvalidURL: `itunes_url` is not a valid iTunes store movie URL.\r\n            PageLoadError: HTML page did not load properly.\r\n            HTTPError: HTTP request failed.\r\n\r\n        Returns:\r\n            Movie: A Movie (NamedTuple) object with movie's name, and an M3U8 object of the main_playlist\r\n            if the main_playlist is found. None otherwise.\r\n        \"\"\"\r\n        regex_match = self.match_url(url, raise_error=True)\r\n        url = regex_match.group(1)\r\n        logger.debug(f\"Scraping iTunes URL: {url}.\")\r\n        response = self._session.get(url=url, allow_redirects=False)\r\n\r\n        try:\r\n            raise_for_status(response=response)\r\n\r\n        except HTTPError as e:\r\n            if response.status_code == 404:\r\n                raise ScraperError(\r\n                    \"Media not found. This could indicate that the provided URL is invalid.\",\r\n                ) from e\r\n\r\n            raise\r\n\r\n        redirect_location = response.headers.get(\"Location\")\r\n\r\n        if response.status_code != 301 or not redirect_location:\r\n            logger.debug(f\"iTunes URL: {url} did not redirect to an Apple TV URL.\\n\"\r\n                         f\"Response status code: {response.status_code}.\\n\"\r\n                         f\"Response headers:\\n{response.headers}.\\n\"\r\n                         f\"Response data:\\n{response.text}.\")\r\n            raise ScraperError(\"Apple TV redirect URL not found.\")\r\n\r\n        if not self._appletv_scraper.match_url(redirect_location):\r\n            logger.debug(f\"iTunes URL: {url} redirected to an invalid Apple TV URL: '{redirect_location}'.\")\r\n            raise ScraperError(\"Redirect URL is not a valid Apple TV URL.\")\r\n\r\n        return self._appletv_scraper.get_data(redirect_location)\r\n\r\n    def get_subtitles(self, main_playlist: str | list[str], language_filter: list[str] | str | None = None,\r\n                      subrip_conversion: bool = False) -> Iterator[SubtitlesData | SubtitlesDownloadError]:\r\n        language_filters = {self.M3U8Attribute.LANGUAGE.value: language_filter} if language_filter else None\r\n        main_playlist_m3u8 = self.load_m3u8(url=main_playlist)\r\n\r\n        if main_playlist_m3u8 is None:\r\n            raise PlaylistLoadError(\"Could not load M3U8 playlist.\")\r\n\r\n        playlist_filters = (merge_dict_values(self._subtitles_filters, language_filters)\r\n                            if language_filters\r\n                            else self._subtitles_filters)\r\n\r\n        matched_media_items = self.get_media_playlists(main_playlist=main_playlist_m3u8,\r\n                                                       playlist_filters=playlist_filters)\r\n\r\n        for matched_media in matched_media_items:\r\n            language_name = matched_media.name.replace(' (forced)', '').strip()\r\n            language_code = matched_media.language\r\n            special_type = self.detect_subtitles_type(subtitles_media=matched_media)\r\n\r\n            try:\r\n                m3u8_data = self._session.get(url=matched_media.absolute_uri)\r\n                matched_media_playlist = m3u8.loads(content=m3u8_data.text, uri=matched_media.absolute_uri)\r\n\r\n                subtitles_segments = self._download_segments(matched_media_playlist.segments)\r\n                subtitles = self.subtitles_class(data=subtitles_segments[0], language_code=language_code)\r\n\r\n                for segment in subtitles_segments[1:]:\r\n                    segment_subtitles_obj = self.subtitles_class(data=segment, language_code=language_code)\r\n                    segment_subtitles_obj.remove_head_blocks()\r\n                    subtitles.append_subtitles(segment_subtitles_obj)\r\n\r\n                subtitles.polish(\r\n                    fix_rtl=self.subtitles_fix_rtl,\r\n                    remove_duplicates=self.subtitles_remove_duplicates,\r\n                )\r\n\r\n                language_name = matched_media.name.replace(' (forced)', '').strip()\r\n\r\n                if subrip_conversion:\r\n                    subtitles_format = SubtitlesFormatType.SUBRIP\r\n                    content = subtitles.to_srt().dump()\r\n\r\n                else:\r\n                    subtitles_format = SubtitlesFormatType.WEBVTT\r\n                    content = subtitles.dump()\r\n\r\n                yield SubtitlesData(\r\n                    language_code=language_code,\r\n                    language_name=language_name,\r\n                    subtitles_format=subtitles_format,\r\n                    content=content,\r\n                    content_encoding=subtitles.encoding,\r\n                    special_type=special_type,\r\n                )\r\n\r\n            except Exception as e:\r\n                yield SubtitlesDownloadError(\r\n                    language_code=language_code,\r\n                    language_name=language_name,\r\n                    special_type=special_type,\r\n                    original_exc=e,\r\n                )\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/scrapers/itunes_scraper.py b/isubrip/scrapers/itunes_scraper.py
--- a/isubrip/scrapers/itunes_scraper.py	(revision 634b66812c92916f1a782a4b23f18322f9814f4a)
+++ b/isubrip/scrapers/itunes_scraper.py	(date 1716910790611)
@@ -116,7 +116,6 @@
 
                 for segment in subtitles_segments[1:]:
                     segment_subtitles_obj = self.subtitles_class(data=segment, language_code=language_code)
-                    segment_subtitles_obj.remove_head_blocks()
                     subtitles.append_subtitles(segment_subtitles_obj)
 
                 subtitles.polish(
Index: isubrip/subtitle_formats/webvtt.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nfrom abc import ABCMeta\r\nimport re\r\nfrom typing import TYPE_CHECKING, Any, ClassVar\r\n\r\nfrom isubrip.data_structures import SubtitlesFormatType\r\nfrom isubrip.subtitle_formats.subrip import SubRipCaptionBlock\r\nfrom isubrip.subtitle_formats.subtitles import RTL_CHAR, Subtitles, SubtitlesBlock, SubtitlesCaptionBlock\r\nfrom isubrip.utils import split_subtitles_timestamp\r\n\r\nif TYPE_CHECKING:\r\n    from datetime import time\r\n\r\n# WebVTT Documentation:\r\n# https://www.w3.org/TR/webvtt1/#cues\r\n# https://developer.mozilla.org/en-US/docs/Web/API/WebVTT_API#webvtt_cues\r\n\r\n\r\nclass WebVTTBlock(SubtitlesBlock, metaclass=ABCMeta):\r\n    \"\"\"\r\n    Abstract base class for WEBVTT cue blocks.\r\n    \"\"\"\r\n    is_caption_block: bool = False\r\n\r\n\r\nclass WebVTTCaptionBlock(SubtitlesCaptionBlock, WebVTTBlock):\r\n    \"\"\"An object representing a WebVTT caption block.\"\"\"\r\n    subrip_alignment_conversion: ClassVar[bool] = False\r\n\r\n    is_caption_block: bool = True\r\n\r\n    def __init__(self, start_time: time, end_time: time, payload: str, settings: str = \"\", identifier: str = \"\"):\r\n        \"\"\"\r\n        Initialize a new object representing a WebVTT caption block.\r\n\r\n        Args:\r\n            start_time (time): Cue start time.\r\n            end_time (time): Cue end time.\r\n            settings (str): Cue settings.\r\n            payload (str): Cue payload.\r\n        \"\"\"\r\n        super().__init__(start_time=start_time, end_time=end_time, payload=payload)\r\n        self.identifier = identifier\r\n        self.settings = settings\r\n\r\n    def to_srt(self) -> SubRipCaptionBlock:\r\n        # Add a {\\an8} tag at the start of the payload if it has 'line:0.00%' in the settings\r\n        if \"line:0.00%\" in self.settings and self.subrip_alignment_conversion:\r\n            # If the payload starts with an RTL control char, add the tag after it\r\n            if self.payload.startswith(RTL_CHAR):\r\n                payload = RTL_CHAR + WEBVTT_ALIGN_TOP_TAG + self.payload[len(RTL_CHAR):]\r\n\r\n            else:\r\n                payload = WEBVTT_ALIGN_TOP_TAG + self.payload\r\n\r\n        else:\r\n            payload = self.payload\r\n\r\n        return SubRipCaptionBlock(start_time=self.start_time, end_time=self.end_time, payload=payload)\r\n\r\n    def __eq__(self, other: Any) -> bool:\r\n        return isinstance(other, type(self)) and \\\r\n            self.start_time == other.start_time and self.end_time == other.end_time and self.payload == other.payload\r\n\r\n    def __str__(self) -> str:\r\n        result_str = \"\"\r\n        time_format = \"%H:%M:%S.%f\"\r\n\r\n        # Add identifier (if it exists)\r\n        if self.identifier:\r\n            result_str += f\"{self.identifier}\\n\"\r\n\r\n        result_str += f\"{self.start_time.strftime(time_format)[:-3]} --> {self.end_time.strftime(time_format)[:-3]}\"\r\n\r\n        if self.settings:\r\n            result_str += f\" {self.settings}\"\r\n\r\n        result_str += f\"\\n{self.payload}\"\r\n\r\n        return result_str\r\n\r\n\r\nclass WebVTTCommentBlock(WebVTTBlock):\r\n    \"\"\"An object representing a WebVTT comment block.\"\"\"\r\n    header = \"NOTE\"\r\n\r\n    def __init__(self, payload: str, inline: bool = False) -> None:\r\n        \"\"\"\r\n        Initialize a new object representing a WebVTT comment block.\r\n\r\n        Args:\r\n            payload (str): Comment payload.\r\n        \"\"\"\r\n        super().__init__()\r\n        self.payload = payload\r\n        self.inline = inline\r\n\r\n    def __eq__(self, other: Any) -> bool:\r\n        return isinstance(other, type(self)) and self.inline == other.inline and self.payload == other.payload\r\n\r\n    def __str__(self) -> str:\r\n        if self.inline:\r\n            return f\"{self.header} {self.payload}\"\r\n\r\n        if self.payload:\r\n            return f\"{self.header}\\n{self.payload}\"\r\n\r\n        return self.header\r\n\r\n\r\nclass WebVTTStyleBlock(WebVTTBlock):\r\n    \"\"\"An object representing a WebVTT style block.\"\"\"\r\n    header = \"STYLE\"\r\n\r\n    def __init__(self, payload: str) -> None:\r\n        \"\"\"\r\n        Initialize a new object representing a WebVTT style block.\r\n\r\n        Args:\r\n            payload (str): Style payload.\r\n        \"\"\"\r\n        super().__init__()\r\n        self.payload = payload\r\n\r\n    def __eq__(self, other: Any) -> bool:\r\n        return isinstance(other, type(self)) and self.payload == other.payload\r\n\r\n    def __str__(self) -> str:\r\n        return f\"{self.header}\\n{self.payload}\"\r\n\r\n\r\nclass WebVTTRegionBlock(WebVTTBlock):\r\n    \"\"\"An object representing a WebVTT region block.\"\"\"\r\n    header = \"REGION\"\r\n\r\n    def __init__(self, payload: str) -> None:\r\n        \"\"\"\r\n        Initialize a new object representing a WebVTT region block.\r\n\r\n        Args:\r\n            payload (str): Region payload.\r\n        \"\"\"\r\n        super().__init__()\r\n        self.payload = payload\r\n\r\n    def __eq__(self, other: Any) -> bool:\r\n        return isinstance(other, type(self)) and self.payload == other.payload\r\n\r\n    def __str__(self) -> str:\r\n        return f\"{self.header} {self.payload}\"\r\n\r\n\r\nclass WebVTTSubtitles(Subtitles[WebVTTBlock]):\r\n    \"\"\"An object representing a WebVTT subtitles file.\"\"\"\r\n    format = SubtitlesFormatType.WEBVTT\r\n\r\n    def _dumps(self) -> str:\r\n        \"\"\"\r\n        Dump subtitles to a string representing the subtitles in a WebVTT format.\r\n\r\n        Returns:\r\n            str: The subtitles in a string using a WebVTT format.\r\n        \"\"\"\r\n        subtitles_str = \"WEBVTT\\n\\n\"\r\n\r\n        for block in self.blocks:\r\n            subtitles_str += str(block) + \"\\n\\n\"\r\n\r\n        return subtitles_str.rstrip('\\n')\r\n\r\n    def _loads(self, data: str) -> None:\r\n        \"\"\"\r\n        Load and parse WebVTT subtitles data from a string.\r\n\r\n        Args:\r\n            data (bytes): Subtitles data to load.\r\n        \"\"\"\r\n        prev_line: str = \"\"\r\n        lines_iterator = iter(data.splitlines())\r\n\r\n        for line in lines_iterator:\r\n            # If the line is a timestamp\r\n            if caption_block_regex := re.match(WEBVTT_CAPTION_BLOCK_REGEX, line):\r\n                # If previous line wasn't empty, add it as an identifier\r\n                if prev_line:\r\n                    caption_identifier = prev_line\r\n\r\n                else:\r\n                    caption_identifier = \"\"\r\n\r\n                caption_timestamps = split_subtitles_timestamp(caption_block_regex.group(1))\r\n                caption_settings = caption_block_regex.group(2)\r\n                caption_payload = \"\"\r\n\r\n                for additional_line in lines_iterator:\r\n                    if not additional_line:\r\n                        line = additional_line\r\n                        break\r\n\r\n                    caption_payload += additional_line + \"\\n\"\r\n\r\n                caption_payload = caption_payload.rstrip(\"\\n\")\r\n                self.blocks.append(WebVTTCaptionBlock(\r\n                    identifier=caption_identifier,\r\n                    start_time=caption_timestamps[0],\r\n                    end_time=caption_timestamps[1],\r\n                    settings=caption_settings,\r\n                    payload=caption_payload))\r\n\r\n            elif comment_block_regex := re.match(WEBVTT_COMMENT_HEADER_REGEX, line):\r\n                comment_payload = \"\"\r\n                inline = False\r\n\r\n                if comment_block_regex.group(1) is not None:\r\n                    comment_payload += comment_block_regex.group(1) + \"\\n\"\r\n                    inline = True\r\n\r\n                for additional_line in lines_iterator:\r\n                    if not additional_line:\r\n                        line = additional_line\r\n                        break\r\n\r\n                    comment_payload += additional_line + \"\\n\"\r\n\r\n                self.blocks.append(WebVTTCommentBlock(comment_payload.rstrip(\"\\n\"), inline=inline))\r\n\r\n            elif line.rstrip(' \\t') == WebVTTRegionBlock.header:\r\n                region_payload = \"\"\r\n\r\n                for additional_line in lines_iterator:\r\n                    if not additional_line:\r\n                        line = additional_line\r\n                        break\r\n\r\n                    region_payload += additional_line + \"\\n\"\r\n\r\n                self.blocks.append(WebVTTRegionBlock(region_payload.rstrip(\"\\n\")))\r\n\r\n            elif line.rstrip(' \\t') == WebVTTStyleBlock.header:\r\n                style_payload = \"\"\r\n\r\n                for additional_line in lines_iterator:\r\n                    if not additional_line:\r\n                        line = additional_line\r\n                        break\r\n\r\n                    style_payload += additional_line + \"\\n\"\r\n\r\n                self.blocks.append(WebVTTStyleBlock(style_payload.rstrip(\"\\n\")))\r\n\r\n            prev_line = line\r\n\r\n    def remove_head_blocks(self) -> None:\r\n        \"\"\"\r\n        Remove all head blocks (Style / Region) from the subtitles.\r\n\r\n        NOTE:\r\n            Comment blocks are removed as well if they are before the first caption block (since they're probably\r\n            related to the head blocks).\r\n        \"\"\"\r\n        for block in self.blocks:\r\n            if isinstance(block, WebVTTCaptionBlock):\r\n                break\r\n\r\n            if isinstance(block, (WebVTTCommentBlock, WebVTTStyleBlock, WebVTTRegionBlock)):\r\n                self.blocks.remove(block)\r\n\r\n\r\n# --- Constants ---\r\nWEBVTT_PERCENTAGE_REGEX = r\"\\d{1,3}(?:\\.\\d+)?%\"\r\nWEBVTT_CAPTION_TIMINGS_REGEX = \\\r\n    r\"(?:[0-5]\\d:)?[0-5]\\d:[0-5]\\d[\\.,]\\d{3}[ \\t]+-->[ \\t]+(?:[0-5]\\d:)?[0-5]\\d:[0-5]\\d[\\.,]\\d{3}\"\r\n\r\nWEBVTT_CAPTION_SETTING_ALIGNMENT_REGEX = r\"align:(?:start|center|middle|end|left|right)\"\r\nWEBVTT_CAPTION_SETTING_LINE_REGEX = rf\"line:(?:{WEBVTT_PERCENTAGE_REGEX}|-?\\d+%)(?:,(?:start|center|middle|end))?\"\r\nWEBVTT_CAPTION_SETTING_POSITION_REGEX = rf\"position:{WEBVTT_PERCENTAGE_REGEX}(?:,(?:start|center|middle|end))?\"\r\nWEBVTT_CAPTION_SETTING_REGION_REGEX = r\"region:(?:(?!(?:-->)|\\t)\\S)+\"\r\nWEBVTT_CAPTION_SETTING_SIZE_REGEX = rf\"size:{WEBVTT_PERCENTAGE_REGEX}\"\r\nWEBVTT_CAPTION_SETTING_VERTICAL_REGEX = r\"vertical:(?:lr|rl)\"\r\n\r\nWEBVTT_CAPTION_SETTINGS_REGEX = (\"(?:\"\r\n                                 f\"(?:{WEBVTT_CAPTION_SETTING_ALIGNMENT_REGEX})|\"\r\n                                 f\"(?:{WEBVTT_CAPTION_SETTING_LINE_REGEX})|\"\r\n                                 f\"(?:{WEBVTT_CAPTION_SETTING_POSITION_REGEX})|\"\r\n                                 f\"(?:{WEBVTT_CAPTION_SETTING_REGION_REGEX})|\"\r\n                                 f\"(?:{WEBVTT_CAPTION_SETTING_SIZE_REGEX})|\"\r\n                                 f\"(?:{WEBVTT_CAPTION_SETTING_VERTICAL_REGEX})|\"\r\n                                 f\"(?:[ \\t]+)\"\r\n                                 \")*\")\r\n\r\nWEBVTT_CAPTION_BLOCK_REGEX = re.compile(rf\"^({WEBVTT_CAPTION_TIMINGS_REGEX})[ \\t]*({WEBVTT_CAPTION_SETTINGS_REGEX})?\")\r\nWEBVTT_COMMENT_HEADER_REGEX = re.compile(rf\"^{WebVTTCommentBlock.header}(?:$|[ \\t])(.+)?\")\r\n\r\nWEBVTT_ALIGN_TOP_TAG = \"{\\\\an8}\"\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/subtitle_formats/webvtt.py b/isubrip/subtitle_formats/webvtt.py
--- a/isubrip/subtitle_formats/webvtt.py	(revision 634b66812c92916f1a782a4b23f18322f9814f4a)
+++ b/isubrip/subtitle_formats/webvtt.py	(date 1716909013016)
@@ -1,6 +1,7 @@
 from __future__ import annotations
 
 from abc import ABCMeta
+from copy import deepcopy
 import re
 from typing import TYPE_CHECKING, Any, ClassVar
 
@@ -44,6 +45,12 @@
         self.identifier = identifier
         self.settings = settings
 
+    def __copy__(self) -> WebVTTCaptionBlock:
+        copy = self.__class__(start_time=self.start_time, end_time=self.end_time, payload=self.payload,
+                              settings=self.settings, identifier=self.identifier)
+        copy.modified = self.modified
+        return copy
+
     def to_srt(self) -> SubRipCaptionBlock:
         # Add a {\an8} tag at the start of the payload if it has 'line:0.00%' in the settings
         if "line:0.00%" in self.settings and self.subrip_alignment_conversion:
@@ -96,6 +103,11 @@
         self.payload = payload
         self.inline = inline
 
+    def __copy__(self) -> WebVTTCommentBlock:
+        copy = self.__class__(payload=self.payload, inline=self.inline)
+        copy.modified = self.modified
+        return copy
+
     def __eq__(self, other: Any) -> bool:
         return isinstance(other, type(self)) and self.inline == other.inline and self.payload == other.payload
 
@@ -123,6 +135,11 @@
         super().__init__()
         self.payload = payload
 
+    def __copy__(self) -> WebVTTStyleBlock:
+        copy = self.__class__(payload=self.payload)
+        copy.modified = self.modified
+        return copy
+
     def __eq__(self, other: Any) -> bool:
         return isinstance(other, type(self)) and self.payload == other.payload
 
@@ -144,6 +161,11 @@
         super().__init__()
         self.payload = payload
 
+    def __copy__(self) -> WebVTTRegionBlock:
+        copy = self.__class__(payload=self.payload)
+        copy.modified = self.modified
+        return copy
+
     def __eq__(self, other: Any) -> bool:
         return isinstance(other, type(self)) and self.payload == other.payload
 
@@ -251,6 +273,18 @@
 
             prev_line = line
 
+    def append_subtitles(self: WebVTTSubtitles,
+                         subtitles: WebVTTSubtitles) -> WebVTTSubtitles:
+        if subtitles.blocks:
+            subtitles_copy = deepcopy(subtitles)
+            subtitles_copy.remove_head_blocks()
+            self.add_blocks(subtitles_copy.blocks)
+
+            if subtitles_copy.modified:
+                self._modified = True
+
+        return self
+
     def remove_head_blocks(self) -> None:
         """
         Remove all head blocks (Style / Region) from the subtitles.
Index: isubrip/subtitle_formats/subrip.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nfrom typing import Any\r\n\r\nfrom isubrip.data_structures import SubtitlesFormatType\r\nfrom isubrip.subtitle_formats.subtitles import Subtitles, SubtitlesCaptionBlock\r\n\r\n\r\nclass SubRipCaptionBlock(SubtitlesCaptionBlock):\r\n    \"\"\"A subtitles caption block based on the SUBRIP format.\"\"\"\r\n    def __str__(self) -> str:\r\n        result_str = \"\"\r\n        time_format = \"%H:%M:%S,%f\"\r\n\r\n        result_str += f\"{self.start_time.strftime(time_format)[:-3]} --> {self.end_time.strftime(time_format)[:-3]}\\n\"\r\n        result_str += f\"{self.payload}\"\r\n\r\n        return result_str\r\n\r\n    def __eq__(self, other: Any) -> bool:\r\n        return isinstance(other, type(self)) and \\\r\n               self.start_time == other.start_time and self.end_time == other.end_time and self.payload == other.payload\r\n\r\n    def to_srt(self) -> SubRipCaptionBlock:\r\n        return self\r\n\r\n\r\nclass SubRipSubtitles(Subtitles[SubRipCaptionBlock]):\r\n    \"\"\"An object representing a SubRip subtitles file.\"\"\"\r\n    format = SubtitlesFormatType.SUBRIP\r\n\r\n    def _dumps(self) -> str:\r\n        subtitles_str = \"\"\r\n\r\n        for i, block in enumerate(iterable=self.blocks, start=1):\r\n            subtitles_str += f\"{i}\\n{str(block)}\\n\\n\"\r\n\r\n        return subtitles_str.rstrip('\\n')\r\n\r\n    def _loads(self, data: str) -> None:\r\n        raise NotImplementedError(\"SubRip subtitles loading is not supported.\")\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/subtitle_formats/subrip.py b/isubrip/subtitle_formats/subrip.py
--- a/isubrip/subtitle_formats/subrip.py	(revision 99fc7a7f8aace4d7305fb2f0777747ee443821b0)
+++ b/isubrip/subtitle_formats/subrip.py	(date 1716908078326)
@@ -8,6 +8,10 @@
 
 class SubRipCaptionBlock(SubtitlesCaptionBlock):
     """A subtitles caption block based on the SUBRIP format."""
+    def __eq__(self, other: Any) -> bool:
+        return isinstance(other, type(self)) and \
+               self.start_time == other.start_time and self.end_time == other.end_time and self.payload == other.payload
+
     def __str__(self) -> str:
         result_str = ""
         time_format = "%H:%M:%S,%f"
@@ -17,10 +21,6 @@
 
         return result_str
 
-    def __eq__(self, other: Any) -> bool:
-        return isinstance(other, type(self)) and \
-               self.start_time == other.start_time and self.end_time == other.end_time and self.payload == other.payload
-
     def to_srt(self) -> SubRipCaptionBlock:
         return self
 
Index: isubrip/subtitle_formats/subtitles.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nfrom abc import ABC, abstractmethod\r\nfrom datetime import time\r\nfrom typing import TYPE_CHECKING, Any, ClassVar, Generic, TypeVar\r\n\r\nfrom isubrip.logger import logger\r\n\r\nif TYPE_CHECKING:\r\n    from isubrip.data_structures import SubtitlesFormatType\r\n    from isubrip.subtitle_formats.subrip import SubRipCaptionBlock, SubRipSubtitles\r\n\r\nRTL_CONTROL_CHARS = ('\\u200e', '\\u200f', '\\u202a', '\\u202b', '\\u202c', '\\u202d', '\\u202e')\r\nRTL_CHAR = '\\u202b'\r\nRTL_LANGUAGES = [\"ar\", \"he\", \"he-il\"]\r\n\r\nSubtitlesT = TypeVar('SubtitlesT', bound='Subtitles')\r\nSubtitlesBlockT = TypeVar('SubtitlesBlockT', bound='SubtitlesBlock')\r\n\r\n\r\nclass SubtitlesBlock(ABC):\r\n    \"\"\"\r\n    Abstract base class for subtitles blocks.\r\n\r\n    Attributes:\r\n        modified (bool): Whether the block has been modified.\r\n    \"\"\"\r\n\r\n    def __init__(self) -> None:\r\n        self.modified: bool = False\r\n\r\n    @abstractmethod\r\n    def __str__(self) -> str:\r\n        pass\r\n\r\n    @abstractmethod\r\n    def __eq__(self, other: Any) -> bool:\r\n        pass\r\n\r\n\r\nclass SubtitlesCaptionBlock(SubtitlesBlock, ABC):\r\n    \"\"\"\r\n    A base class for subtitles caption blocks.\r\n\r\n    Attributes:\r\n        start_time (time): Start timestamp of the caption block.\r\n        end_time (time): End timestamp of the caption block.\r\n        payload (str): Caption block's payload.\r\n    \"\"\"\r\n\r\n    def __init__(self, start_time: time, end_time: time, payload: str):\r\n        \"\"\"\r\n        Initialize a new SubtitlesCaptionBlock object.\r\n\r\n        Args:\r\n            start_time: Start timestamp of the caption block.\r\n            end_time: End timestamp of the caption block.\r\n            payload: Caption block's payload.\r\n        \"\"\"\r\n        super().__init__()\r\n        self.start_time = start_time\r\n        self.end_time = end_time\r\n        self.payload = payload\r\n\r\n    def fix_rtl(self) -> None:\r\n        \"\"\"Fix payload's text direction to RTL.\"\"\"\r\n        previous_payload = self.payload\r\n\r\n        # Remove previous RTL-related formatting\r\n        for char in RTL_CONTROL_CHARS:\r\n            self.payload = self.payload.replace(char, '')\r\n\r\n        # Add RLM char at the start of every line\r\n        self.payload = RTL_CHAR + self.payload.replace(\"\\n\", f\"\\n{RTL_CHAR}\")\r\n\r\n        if self.payload != previous_payload:\r\n            self.modified = True\r\n\r\n    @abstractmethod\r\n    def to_srt(self) -> SubRipCaptionBlock:\r\n        \"\"\"\r\n        Convert WebVTT caption block to SRT caption block.\r\n\r\n        Returns:\r\n            SubRipCaptionBlock: The caption block in SRT format.\r\n        \"\"\"\r\n        ...\r\n\r\n\r\nclass Subtitles(Generic[SubtitlesBlockT], ABC):\r\n    \"\"\"\r\n    An object representing subtitles, made out of blocks.\r\n\r\n    Attributes:\r\n        _modified (bool): Whether the subtitles have been modified.\r\n        format (SubtitlesFormatType): [Class Attribute] Format of the subtitles (contains name and file extension).\r\n        language_code (str): Language code of the subtitles.\r\n        blocks (list[SubtitlesBlock]): A list of subtitles blocks that make up the subtitles.\r\n        encoding (str): Encoding of the subtitles.\r\n        raw_data (bytes | None): Raw data of the subtitles.\r\n    \"\"\"\r\n    format: ClassVar[SubtitlesFormatType]\r\n\r\n    def __init__(self, data: bytes | None, language_code: str, encoding: str = \"utf-8\"):\r\n        \"\"\"\r\n        Initialize a new Subtitles object.\r\n\r\n        Args:\r\n            data (bytes | None): Raw data of the subtitles.\r\n            language_code (str): Language code of the subtitles.\r\n            encoding (str, optional): Encoding of the subtitles. Defaults to \"utf-8\".\r\n        \"\"\"\r\n        self._modified = False\r\n        self.raw_data = None\r\n\r\n        self.blocks: list[SubtitlesBlockT] = []\r\n\r\n        self.language_code = language_code\r\n        self.encoding = encoding\r\n\r\n        if data:\r\n            self.raw_data = data\r\n            self._load(data=data)\r\n\r\n    def __add__(self: SubtitlesT, obj: SubtitlesBlockT | SubtitlesT) -> SubtitlesT:\r\n        \"\"\"\r\n        Add a new subtitles block, or append blocks from another subtitles object.\r\n\r\n        Args:\r\n            obj (SubtitlesBlock | Subtitles): A subtitles block or another subtitles object.\r\n\r\n        Returns:\r\n            Subtitles: The current subtitles object.\r\n        \"\"\"\r\n        if isinstance(obj, SubtitlesBlock):\r\n            self.add_blocks(obj)\r\n\r\n        elif isinstance(obj, self.__class__):\r\n            self.append_subtitles(obj)\r\n\r\n        else:\r\n            logger.warning(f\"Cannot add object of type '{type(obj)}' to '{type(self)}' object. Skipping...\")\r\n\r\n        return self\r\n\r\n    def __eq__(self, other: Any) -> bool:\r\n        return isinstance(other, type(self)) and self.blocks == other.blocks\r\n\r\n    def __str__(self) -> str:\r\n        return self.dumps()\r\n\r\n    def _dump(self) -> bytes:\r\n        \"\"\"\r\n        Dump subtitles object to bytes representing the subtitles.\r\n\r\n        Returns:\r\n            bytes: The subtitles in a bytes object.\r\n        \"\"\"\r\n        return self._dumps().encode(encoding=self.encoding)\r\n\r\n    @abstractmethod\r\n    def _dumps(self) -> str:\r\n        \"\"\"\r\n        Dump subtitles object to a string representing the subtitles.\r\n\r\n        Returns:\r\n            str: The subtitles in a string format.\r\n        \"\"\"\r\n        ...\r\n\r\n    def _load(self, data: bytes) -> None:\r\n        \"\"\"\r\n        Load and parse subtitles data from bytes.\r\n\r\n        Args:\r\n            data (bytes): Subtitles data to load.\r\n        \"\"\"\r\n        parsed_data = data.decode(encoding=self.encoding)\r\n        self._loads(data=parsed_data)\r\n\r\n    @abstractmethod\r\n    def _loads(self, data: str) -> None:\r\n        \"\"\"\r\n        Load and parse subtitles data from a string.\r\n\r\n        Args:\r\n            data (bytes): Subtitles data to load.\r\n        \"\"\"\r\n        ...\r\n\r\n    def dump(self) -> bytes:\r\n        \"\"\"\r\n        Dump subtitles to a bytes object representing the subtitles.\r\n        Returns the original raw subtitles data if they have not been modified, and raw data is available.\r\n\r\n        Returns:\r\n            bytes: The subtitles in a bytes object.\r\n        \"\"\"\r\n        if self.raw_data is not None and not self.modified():\r\n            logger.debug(\"Returning original raw data as subtitles have not been modified.\")\r\n            return self.raw_data\r\n\r\n        return self._dump()\r\n\r\n    def dumps(self) -> str:\r\n        \"\"\"\r\n        Dump subtitles to a string representing the subtitles.\r\n        Returns the original raw subtitles data if they have not been modified, and raw data is available.\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        if self.raw_data is not None and not self.modified():\r\n            logger.debug(\"Returning original raw data (decoded) as subtitles have not been modified.\")\r\n            return self.raw_data.decode(encoding=self.encoding)\r\n\r\n        return self._dumps()\r\n\r\n    def add_blocks(self: SubtitlesT,\r\n                   blocks: SubtitlesBlockT | list[SubtitlesBlockT],\r\n                   set_modified: bool = True) -> SubtitlesT:\r\n        \"\"\"\r\n        Add a new subtitles block to current subtitles.\r\n\r\n        Args:\r\n            blocks (SubtitlesBlock | list[SubtitlesBlock]):\r\n                A block object or a list of block objects to append.\r\n            set_modified (bool, optional): Whether to set the subtitles as modified. Defaults to True.\r\n\r\n        Returns:\r\n            Subtitles: The current subtitles object.\r\n        \"\"\"\r\n        if isinstance(blocks, list):\r\n            if not blocks:\r\n                return self\r\n\r\n            self.blocks.extend(blocks)\r\n\r\n        else:\r\n            self.blocks.append(blocks)\r\n\r\n        if set_modified:\r\n            self._modified = True\r\n\r\n        return self\r\n\r\n    def append_subtitles(self: SubtitlesT,\r\n                         subtitles: SubtitlesT) -> SubtitlesT:\r\n        \"\"\"\r\n        Append subtitles to an existing subtitles object.\r\n\r\n        Args:\r\n            subtitles (Subtitles): Subtitles object to append to current subtitles.\r\n\r\n        Returns:\r\n            Subtitles: The current subtitles object.\r\n        \"\"\"\r\n        if not subtitles.blocks:\r\n            return self\r\n\r\n        for block in subtitles.blocks:\r\n            self.add_blocks(block)\r\n\r\n        return self\r\n\r\n    def polish(self: SubtitlesT,\r\n               fix_rtl: bool = False,\r\n               remove_duplicates: bool = True,\r\n               ) -> SubtitlesT:\r\n        \"\"\"\r\n        Apply various fixes to subtitles.\r\n\r\n        Args:\r\n            fix_rtl (bool, optional): Whether to fix text direction of RTL languages. Defaults to False.\r\n            remove_duplicates (bool, optional): Whether to remove duplicate captions. Defaults to True.\r\n\r\n        Returns:\r\n            Subtitles: The current subtitles object.\r\n        \"\"\"\r\n        fix_rtl = (fix_rtl and self.language_code in RTL_LANGUAGES)\r\n\r\n        if not any((\r\n                fix_rtl,\r\n                remove_duplicates,\r\n        )):\r\n            return self\r\n\r\n        previous_block: SubtitlesBlockT | None = None\r\n\r\n        for block in self.blocks:\r\n            if fix_rtl:\r\n                block.fix_rtl()\r\n\r\n            if remove_duplicates and previous_block is not None and block == previous_block:\r\n                self.blocks.remove(previous_block)\r\n                self._modified = True\r\n\r\n            previous_block = block\r\n\r\n        return self\r\n\r\n    def modified(self) -> bool:\r\n        \"\"\"\r\n        Check if the subtitles have been modified (by checking if any of its blocks have been modified).\r\n\r\n        Returns:\r\n            bool: True if the subtitles have been modified, False otherwise.\r\n        \"\"\"\r\n        return self._modified or any(block.modified for block in self.blocks)\r\n\r\n    def to_srt(self) -> SubRipSubtitles:\r\n        \"\"\"\r\n        Convert subtitles to SRT format.\r\n\r\n        Returns:\r\n            SubRipSubtitles: The subtitles in SRT format.\r\n        \"\"\"\r\n        from isubrip.subtitle_formats.subrip import SubRipSubtitles\r\n\r\n        subrip_subtitles = SubRipSubtitles(\r\n            data=None,\r\n            language_code=self.language_code,\r\n            encoding=self.encoding,\r\n        )\r\n        subrip_blocks = [block.to_srt() for block in self.blocks if isinstance(block, SubtitlesCaptionBlock)]\r\n        subrip_subtitles.add_blocks(subrip_blocks)\r\n\r\n        return subrip_subtitles\r\n\r\n\r\ndef split_timestamp(timestamp: str) -> tuple[time, time]:\r\n    \"\"\"\r\n    Split a subtitles timestamp into start and end.\r\n\r\n    Args:\r\n        timestamp (str): A subtitles timestamp. For example: \"00:00:00.000 --> 00:00:00.000\"\r\n\r\n    Returns:\r\n        tuple(time, time): A tuple containing start and end times as a datetime object.\r\n    \"\"\"\r\n    # Support ',' character in timestamp's milliseconds (used in SubRip format).\r\n    timestamp = timestamp.replace(',', '.')\r\n\r\n    start_time, end_time = timestamp.split(\" --> \")\r\n    return time.fromisoformat(start_time), time.fromisoformat(end_time)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/subtitle_formats/subtitles.py b/isubrip/subtitle_formats/subtitles.py
--- a/isubrip/subtitle_formats/subtitles.py	(revision 634b66812c92916f1a782a4b23f18322f9814f4a)
+++ b/isubrip/subtitle_formats/subtitles.py	(date 1716909013011)
@@ -1,6 +1,7 @@
 from __future__ import annotations
 
 from abc import ABC, abstractmethod
+from copy import deepcopy
 from datetime import time
 from typing import TYPE_CHECKING, Any, ClassVar, Generic, TypeVar
 
@@ -30,11 +31,18 @@
         self.modified: bool = False
 
     @abstractmethod
-    def __str__(self) -> str:
+    def __copy__(self):
+        """Create a copy of the block."""
         pass
 
     @abstractmethod
     def __eq__(self, other: Any) -> bool:
+        """Check if two objects are equal."""
+        pass
+
+    @abstractmethod
+    def __str__(self) -> str:
+        """Return a string representation of the block."""
         pass
 
 
@@ -62,6 +70,11 @@
         self.end_time = end_time
         self.payload = payload
 
+    def __copy__(self):
+        copy = self.__class__(self.start_time, self.end_time, self.payload)
+        copy.modified = self.modified
+        return copy
+
     def fix_rtl(self) -> None:
         """Fix payload's text direction to RTL."""
         previous_payload = self.payload
@@ -143,6 +156,14 @@
 
         return self
 
+    def __copy__(self: SubtitlesT) -> SubtitlesT:
+        """Create a copy of the subtitles object."""
+        copy = self.__class__(data=None, language_code=self.language_code, encoding=self.encoding)
+        copy.raw_data = self.raw_data
+        copy.blocks = [block.__copy__() for block in self.blocks]
+        copy._modified = self._modified
+        return copy
+
     def __eq__(self, other: Any) -> bool:
         return isinstance(other, type(self)) and self.blocks == other.blocks
 
@@ -255,11 +276,11 @@
         Returns:
             Subtitles: The current subtitles object.
         """
-        if not subtitles.blocks:
-            return self
+        if subtitles.blocks:
+            self.add_blocks(deepcopy(subtitles.blocks))
 
-        for block in subtitles.blocks:
-            self.add_blocks(block)
+            if subtitles.modified:
+                self._modified = True
 
         return self
 
