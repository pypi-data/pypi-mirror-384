Index: isubrip/scrapers/itunes_scraper.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nimport re\r\nfrom typing import TYPE_CHECKING, Iterator\r\n\r\nimport m3u8\r\nfrom requests.exceptions import HTTPError\r\n\r\nfrom isubrip.data_structures import SubtitlesData, SubtitlesFormatType\r\nfrom isubrip.logger import logger\r\nfrom isubrip.scrapers.scraper import HLSScraper, PlaylistLoadError, ScraperError, ScraperFactory\r\nfrom isubrip.subtitle_formats.webvtt import WebVTTSubtitles\r\nfrom isubrip.utils import merge_dict_values, raise_for_status\r\n\r\nif TYPE_CHECKING:\r\n    from isubrip.data_structures import Movie, ScrapedMediaResponse\r\n\r\n\r\nclass ItunesScraper(HLSScraper):\r\n    \"\"\"An iTunes movie data scraper.\"\"\"\r\n    id = \"itunes\"\r\n    name = \"iTunes\"\r\n    abbreviation = \"iT\"\r\n    url_regex = re.compile(r\"(?i)(?P<base_url>https?://itunes\\.apple\\.com/(?:(?P<country_code>[a-z]{2})/)?(?P<media_type>movie|tv-show|tv-season|show)/(?:(?P<media_name>[\\w\\-%]+)/)?(?P<media_id>id\\d{9,10}))(?:\\?(?P<url_params>.*))?\")  # noqa: E501\r\n    subtitles_class = WebVTTSubtitles\r\n    is_movie_scraper = True\r\n    uses_scrapers = [\"appletv\"]\r\n\r\n    _subtitles_filters = {\r\n        HLSScraper.M3U8Attribute.GROUP_ID.value: [\"subtitles_ak\", \"subtitles_vod-ak-amt.tv.apple.com\"],\r\n        **HLSScraper._subtitles_filters,\r\n    }\r\n\r\n    def __init__(self,  user_agent: str | None = None, config_data: dict | None = None):\r\n        super().__init__(user_agent=user_agent, config_data=config_data)\r\n        self._appletv_scraper = ScraperFactory.get_scraper_instance(\r\n            scraper_id=\"appletv\",\r\n            kwargs={\"config_data\": config_data},\r\n            extract_scraper_config=True,\r\n            raise_error=True\r\n        )\r\n\r\n    def get_data(self, url: str) -> ScrapedMediaResponse[Movie]:\r\n        \"\"\"\r\n        Scrape iTunes to find info about a movie, and it's M3U8 main_playlist.\r\n\r\n        Args:\r\n            url (str): An iTunes store movie URL.\r\n\r\n        Raises:\r\n            InvalidURL: `itunes_url` is not a valid iTunes store movie URL.\r\n            PageLoadError: HTML page did not load properly.\r\n            HTTPError: HTTP request failed.\r\n\r\n        Returns:\r\n            Movie: A Movie (NamedTuple) object with movie's name, and an M3U8 object of the main_playlist\r\n            if the main_playlist is found. None otherwise.\r\n        \"\"\"\r\n        regex_match = self.match_url(url, raise_error=True)\r\n        url = regex_match.group(1)\r\n        logger.debug(f\"Scraping iTunes URL: {url}.\")\r\n        response = self._session.get(url=url, allow_redirects=False)\r\n\r\n        try:\r\n            raise_for_status(response=response)\r\n\r\n        except HTTPError as e:\r\n            if response.status_code == 404:\r\n                raise ScraperError(\r\n                    \"Media not found. This could indicate that the provided URL is invalid.\",\r\n                ) from e\r\n\r\n            raise\r\n\r\n        redirect_location = response.headers.get(\"Location\")\r\n\r\n        if response.status_code != 301 or not redirect_location:\r\n            logger.debug(f\"iTunes URL: {url} did not redirect to an Apple TV URL.\\n\"\r\n                         f\"Response status code: {response.status_code}.\\n\"\r\n                         f\"Response headers:\\n{response.headers}.\\n\"\r\n                         f\"Response data:\\n{response.text}.\")\r\n            raise ScraperError(\"Apple TV redirect URL not found.\")\r\n\r\n        if not self._appletv_scraper.match_url(redirect_location):\r\n            logger.debug(f\"iTunes URL: {url} redirected to an invalid Apple TV URL: '{redirect_location}'.\")\r\n            raise ScraperError(\"Redirect URL is not a valid Apple TV URL.\")\r\n\r\n        return self._appletv_scraper.get_data(redirect_location)\r\n\r\n    def get_subtitles(self, main_playlist: str | list[str], language_filter: list[str] | str | None = None,\r\n                      subrip_conversion: bool = False) -> Iterator[SubtitlesData]:\r\n        language_filters = {self.M3U8Attribute.LANGUAGE.value: language_filter} if language_filter else None\r\n        main_playlist_m3u8 = self.load_m3u8(url=main_playlist)\r\n\r\n        if main_playlist_m3u8 is None:\r\n            raise PlaylistLoadError(\"Could not load M3U8 playlist.\")\r\n\r\n        playlist_filters = (merge_dict_values(self._subtitles_filters, language_filters)\r\n                            if language_filters\r\n                            else self._subtitles_filters)\r\n\r\n        matched_media_items = self.get_media_playlists(main_playlist=main_playlist_m3u8,\r\n                                                       playlist_filters=playlist_filters)\r\n\r\n        for matched_media in matched_media_items:\r\n            language_name = matched_media.name.replace(' (forced)', '').strip()\r\n            language_code = matched_media.language\r\n            language_info_str = f\"{language_name} ({language_code})\"\r\n\r\n            try:\r\n                m3u8_data = self._session.get(url=matched_media.absolute_uri)\r\n                matched_media_playlist = m3u8.loads(content=m3u8_data.text, uri=matched_media.absolute_uri)\r\n\r\n                subtitles_segments = self._download_segments(matched_media_playlist.segments)\r\n                subtitles = self.subtitles_class.load(data=subtitles_segments[0], language_code=language_code)\r\n\r\n                for segment in subtitles_segments[1:]:\r\n                    subtitles.append_subtitles(subtitles.load(data=segment, language_code=language_code))\r\n\r\n                subtitles.polish(\r\n                    fix_rtl=self.subtitles_fix_rtl,\r\n                    rtl_languages=self.subtitles_fix_rtl_languages,\r\n                    remove_duplicates=self.subtitles_remove_duplicates,\r\n                )\r\n\r\n                language_name = matched_media.name.replace(' (forced)', '').strip()\r\n\r\n                yield SubtitlesData(\r\n                    language_code=language_code,\r\n                    language_name=language_name,\r\n                    subtitles_format=SubtitlesFormatType.SUBRIP if subrip_conversion else SubtitlesFormatType.WEBVTT,\r\n                    content=subtitles.to_srt().dump() if subrip_conversion else subtitles.dump(),\r\n                    content_encoding=subtitles.encoding,\r\n                    special_type=self.detect_subtitles_type(matched_media),\r\n                )\r\n\r\n            except Exception as e:\r\n                logger.warning(f\"Failed to download {language_info_str} subtitles. \"\r\n                               f\"Skipping...\")\r\n                logger.debug(e, exc_info=True)\r\n                continue\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/scrapers/itunes_scraper.py b/isubrip/scrapers/itunes_scraper.py
--- a/isubrip/scrapers/itunes_scraper.py	(revision 925cd34c4ec83ed4b57105a0e99855eb8a91a798)
+++ b/isubrip/scrapers/itunes_scraper.py	(date 1709331645519)
@@ -37,7 +37,7 @@
             scraper_id="appletv",
             kwargs={"config_data": config_data},
             extract_scraper_config=True,
-            raise_error=True
+            raise_error=True,
         )
 
     def get_data(self, url: str) -> ScrapedMediaResponse[Movie]:
