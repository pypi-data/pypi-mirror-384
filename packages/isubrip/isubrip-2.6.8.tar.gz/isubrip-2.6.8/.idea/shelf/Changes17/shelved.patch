Index: isubrip/scrapers/scraper.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nimport asyncio\r\nimport importlib\r\nimport inspect\r\nimport os\r\nimport re\r\nimport sys\r\nfrom abc import abstractmethod, ABC, ABCMeta\r\nfrom enum import Enum\r\nfrom glob import glob\r\nfrom pathlib import Path\r\nfrom typing import Iterator, Optional, Union, TypeVar\r\n\r\nimport aiohttp\r\nimport m3u8\r\nimport requests\r\nfrom m3u8 import M3U8, Media, Segment, SegmentList\r\n\r\nfrom isubrip.config import Config, ConfigSetting\r\nfrom isubrip.constants import PACKAGE_NAME\r\nfrom isubrip.utils import merge_dict_values\r\nfrom isubrip.data_structures import EpisodeData, MovieData, SeasonData, SeriesData, SubtitlesData, SubtitlesFormat, SubtitlesType\r\nfrom isubrip.subtitle_formats.subtitles import Subtitles\r\n\r\nScraper = TypeVar('Scraper', bound='ScraperBase')\r\n\r\n\r\nclass Singleton(ABCMeta):\r\n    \"\"\"\r\n    A metaclass that implements the Singleton pattern.\r\n    When a class using this metaclass is initialized, it will return the same instance every time.\r\n    \"\"\"\r\n    _instances: dict[str, ScraperBase] = {}\r\n\r\n    def __call__(cls, *args, **kwargs) -> object:\r\n        if cls._instances.get(cls.__name__) is None:\r\n            cls._instances[cls.__name__] = super().__call__(*args, **kwargs)\r\n\r\n        return cls._instances[cls.__name__]\r\n\r\n\r\nclass ScraperBase(ABC, metaclass=Singleton):\r\n    \"\"\"A base class for scrapers.\"\"\"\r\n    default_user_agent = None\r\n\r\n    is_movie_scraper: bool = False\r\n    is_series_scraper: bool = False\r\n\r\n    # --- Class Attributes ---\r\n    # TODO REFACTOR: Somehow assert these are set in subclasses\r\n    subtitles_class: type[Subtitles]\r\n    \"\"\"The scraper's subtitles class.\"\"\"\r\n\r\n    service_abbreviation: str\r\n    \"\"\"A short abbreviation of the service name.\"\"\"\r\n\r\n    service_name: str\r\n    \"\"\"The name of the service.\"\"\"\r\n\r\n    url_regex: Union[str, list[str]]\r\n    \"\"\"A RegEx pattern to find URLs matching the service.\"\"\"\r\n\r\n    def __init__(self, config_data: Optional[dict] = None):\r\n        self._session = requests.Session()\r\n        self._session.headers.update({\"User-Agent\": self.default_user_agent})\r\n        self.config: Optional[Config] = Config(config_data=config_data)\r\n        self.default_filters: dict = config_data if config_data else {}\r\n\r\n        self.config.add_settings([\r\n            ConfigSetting(\r\n                key=\"user-agent\",\r\n                type=str,\r\n                required=False,\r\n            )],\r\n            check_config=False)\r\n\r\n        self._session.headers.update({\"User-Agent\": self.config[\"user-agent\"]})\r\n\r\n    @classmethod\r\n    def check_url_match(cls, url: str) -> bool:\r\n        \"\"\"\r\n        Checks if a URL matches scraper's url regex.\r\n\r\n        Args:\r\n            url: The URL to check.\r\n\r\n        Returns:\r\n            bool: True if URL matches, False otherwise.\r\n        \"\"\"\r\n        if not cls.url_regex:\r\n            return False\r\n\r\n        if isinstance(cls.url_regex, str):\r\n            return re.fullmatch(cls.url_regex, url) is not None\r\n\r\n        elif isinstance(cls.url_regex, (list, tuple)):\r\n            for regex in cls.url_regex:\r\n                if re.fullmatch(regex, url) is not None:\r\n                    return True\r\n\r\n            return False\r\n\r\n    def __enter__(self):\r\n        return self\r\n\r\n    def __exit__(self, exc_type, exc_val, exc_tb):\r\n        self.close()\r\n\r\n    def close(self):\r\n        self._session.close()\r\n\r\n    @abstractmethod\r\n    def get_data(self, url: str) -> Union[MovieData, SeriesData, SeasonData, EpisodeData]:\r\n        \"\"\"\r\n        Scrape media information about the media on a URL.\r\n\r\n        Args:\r\n            url: The URL to get information about.\r\n\r\n        Returns:\r\n            MovieData| SeriesData | SubtitlesData | PlaylistData: Information about the media.\r\n        \"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    def get_subtitles(self, main_playlist: M3U8, playlist_filters: Union[dict[str, Union[str, list[str]]], None] = None,\r\n                      subrip_conversion: bool = False) -> Iterator[SubtitlesData]:\r\n        \"\"\"\r\n        Find and yield subtitles data from a main_playlist.\r\n\r\n        Args:\r\n            main_playlist (M3U8): The main playlist of the media to search for subtitles in.\r\n            playlist_filters (dict[str, str | list[str]], optional):\r\n                A dictionary of filters to use when searching for subtitles playlists. Defaults to None.\r\n            subrip_conversion (bool, optional): Whether to convert the subtitles to SubRip format. Defaults to False.\r\n\r\n        Yields:\r\n            SubtitlesData: A SubtitlesData object for each subtitle found\r\n                in the main playlist (matching the filters, if given).\r\n        \"\"\"\r\n        pass\r\n\r\n\r\nclass MovieScraper(ScraperBase, ABC):\r\n    \"\"\"\r\n    A base class for movie scrapers.\r\n    \"\"\"\r\n    is_movie_scraper: bool = True\r\n\r\n    @abstractmethod\r\n    def _get_movie_data(self, url: str) -> MovieData:\r\n        pass\r\n\r\n\r\nclass SeriesScraper(ScraperBase, ABC):\r\n    \"\"\"\r\n    A base class for TV scrapers.\r\n    \"\"\"\r\n    is_series_scraper: bool = True\r\n\r\n    @abstractmethod\r\n    def _get_series_data(self, url: str) -> SeriesData:\r\n        pass\r\n\r\n\r\nclass AsyncScraper(ScraperBase, ABC):\r\n    \"\"\"A base class for scrapers that use async requests.\"\"\"\r\n    def __init__(self, config_data: Optional[dict] = None):\r\n        super().__init__(config_data)\r\n        self.async_session = aiohttp.ClientSession()\r\n        self.async_session.headers.update({\"User-Agent\": self.default_user_agent})\r\n\r\n    def close(self):\r\n        asyncio.get_event_loop().run_until_complete(self._async_close())\r\n        super().close()\r\n\r\n    async def _async_close(self):\r\n        await self.async_session.close()\r\n\r\n\r\nclass M3U8Scraper(AsyncScraper, ABC):\r\n    \"\"\"A base class for M3U8 scrapers.\"\"\"\r\n    playlist_filters_config_category = \"playlist-filters\"\r\n\r\n    class M3U8Attribute(Enum):\r\n        \"\"\"\r\n        An enum representing all possible M3U8 attributes.\r\n        Names / Keys represent M3U8 attributes (should be converted to lowercase),\r\n        and values represent the name of the key for config usage.\r\n        \"\"\"\r\n        ASSOC_LANGUAGE = \"assoc-language\"\r\n        AUTOSELECT = \"autoselect\"\r\n        CHARACTERISTICS = \"characteristics\"\r\n        CHANNELS = \"channels\"\r\n        DEFAULT = \"default\"\r\n        FORCED = \"forced\"\r\n        GROUP_ID = \"group-id\"\r\n        INSTREAM_ID = \"instream-id\"\r\n        LANGUAGE = \"language\"\r\n        NAME = \"name\"\r\n        STABLE_RENDITION_ID = \"stable-rendition-id\"\r\n        TYPE = \"type\"\r\n\r\n    def __init__(self, config_data: Optional[dict] = None):\r\n        super().__init__(config_data)\r\n\r\n        # Add M3U8 filters settings\r\n        self.config.add_settings([\r\n            ConfigSetting(\r\n                category=self.playlist_filters_config_category,\r\n                key=m3u8_attribute.value,\r\n                type=Union[str, list[str]],\r\n                required=False,\r\n            ) for m3u8_attribute in self.M3U8Attribute],\r\n            check_config=False)\r\n\r\n    def _download_segments_async(self, segments: SegmentList[Segment]) -> list[bytes]:\r\n        \"\"\"\r\n        Download M3U8 segments asynchronously.\r\n\r\n        Args:\r\n            segments (m3u8.SegmentList[m3u8.Segment]): List of segments to download.\r\n\r\n        Returns:\r\n            list[bytes]: List of downloaded segments.\r\n        \"\"\"\r\n        loop = asyncio.get_event_loop()\r\n        async_tasks = [loop.create_task(self._download_segment_async(segment.absolute_uri)) for segment in segments]\r\n        segments_bytes = loop.run_until_complete(asyncio.gather(*async_tasks))\r\n\r\n        return list(segments_bytes)\r\n\r\n    async def _download_segment_async(self, url: str) -> bytes:\r\n        \"\"\"\r\n        Download an M3U8 segment asynchronously.\r\n\r\n        Args:\r\n            url (str): URL of the segment to download.\r\n\r\n        Returns:\r\n            bytes: Downloaded segment.\r\n        \"\"\"\r\n        async with self.async_session.get(url) as response:\r\n            return await response.read()\r\n\r\n    @staticmethod\r\n    def detect_subtitles_type(subtitles_media: Media) -> Optional[SubtitlesType]:\r\n        \"\"\"\r\n        Detect the subtitles type (Closed Captions, Forced, etc.) from an M3U8 Media object.\r\n\r\n        Args:\r\n            subtitles_media (m3u8.Media): Subtitles Media object to detect the type of.\r\n\r\n        Returns:\r\n            SubtitlesType | None: The type of the subtitles, None for regular subtitles.\r\n        \"\"\"\r\n        if subtitles_media.forced == \"YES\":\r\n            return SubtitlesType.FORCED\r\n\r\n        elif subtitles_media.characteristics is not None and \"public.accessibility\" in subtitles_media.characteristics:\r\n            return SubtitlesType.CC\r\n\r\n        return None\r\n\r\n    def get_media_playlists(self, main_playlist: M3U8,\r\n                            playlist_filters: Union[dict[str, Union[str, list[str], tuple[str]]], None] = None,\r\n                            include_default_filters: bool = True) -> Iterator[Media]:\r\n        \"\"\"\r\n        Find and yield playlists of media within an M3U8 main_playlist using optional filters.\r\n\r\n        Args:\r\n            main_playlist (m3u8.M3U8): an M3U8 object of the main main_playlist.\r\n            playlist_filters (dict, optional): A dictionary of filters to use when searching for subtitles.\r\n                Will be added to filters set by the config (unless `include_default_filters` is set to false).\r\n                Defaults to None.\r\n            include_default_filters (bool, optional): Whether to include the default filters set by the config or not.\r\n                Defaults to True.\r\n\r\n        Yields:\r\n            SubtitlesData: A NamedTuple with a matching main_playlist, and it's metadata:\r\n                Language Code, Language Name, SubtitlesType, Playlist URL.\r\n        \"\"\"\r\n        default_playlist_filters: Optional[dict] = \\\r\n            self.default_filters.get(M3U8Scraper.playlist_filters_config_category)\r\n\r\n        if include_default_filters and default_playlist_filters:\r\n            if not playlist_filters:\r\n                playlist_filters = default_playlist_filters\r\n\r\n            else:\r\n                playlist_filters = merge_dict_values(default_playlist_filters, playlist_filters)\r\n\r\n        for media in main_playlist.media:\r\n            if playlist_filters is None:\r\n                yield media\r\n\r\n            is_valid = True\r\n\r\n            for filter_name, filter_value in playlist_filters.items():\r\n                try:\r\n                    filter_name = M3U8Scraper.M3U8Attribute(filter_name)\r\n\r\n                except ValueError:\r\n                    continue\r\n                    # TODO: Add logger warning \"invalid main_playlist filter, skipping...\"\r\n\r\n                attribute_value = getattr(media, filter_name.name.lower(), None)\r\n\r\n                if attribute_value is None:\r\n                    is_valid = False\r\n                    break\r\n\r\n                if isinstance(filter_value, (list, tuple)) and \\\r\n                        attribute_value.casefold() not in (x.casefold() for x in filter_value):\r\n                    is_valid = False\r\n                    break\r\n\r\n                elif isinstance(filter_value, str) and filter_value.casefold() != attribute_value.casefold():\r\n                    is_valid = False\r\n                    break\r\n\r\n            if not is_valid:\r\n                continue\r\n\r\n            yield media\r\n\r\n    def get_subtitles(self, main_playlist: M3U8,\r\n                      playlist_filters: Union[dict[str, Union[str, list[str]]], None] = None,\r\n                      subrip_conversion: bool = False) -> Iterator[SubtitlesData]:\r\n        \"\"\"\r\n        Find and yield subtitles for a movie using optional filters.\r\n\r\n        Args:\r\n            main_playlist (m3u8.M3U8): an M3U8 object of the main playlist.\r\n            playlist_filters (dict, optional): A dictionary of filters to use when searching for subtitles.\r\n                Will be added to filters set by the config. Defaults to None.\r\n            subrip_conversion (bool, optional): Whether to convert and return the subtitles as an SRT file or not.\r\n\r\n        Yields:\r\n            SubtitlesData: A SubtitlesData NamedTuple with a matching playlist, and it's metadata.\r\n        \"\"\"\r\n        if playlist_filters is None:\r\n            playlist_filters = {}\r\n\r\n        playlist_filters[\"type\"] = \"SUBTITLES\"\r\n\r\n        for matched_media in self.get_media_playlists(main_playlist=main_playlist, playlist_filters=playlist_filters):\r\n            # TODO: Add logger info \"Found subtitles for language: {matched_media.name}\"\r\n            try:\r\n                matched_media_playlist = m3u8.load(matched_media.absolute_uri)\r\n\r\n            except (ValueError, IOError) as e:\r\n                pass  # TODO: Add logger warning\r\n                continue\r\n\r\n            subtitles = self.subtitles_class(language_code=matched_media.language, language_name=matched_media.name)\r\n\r\n            for segment in self._download_segments_async(matched_media_playlist.segments):\r\n                subtitles.append_subtitles(subtitles.loads(segment.decode(\"utf-8\")))\r\n\r\n            yield SubtitlesData(\r\n                language_code=matched_media.language,\r\n                language_name=matched_media.name,\r\n                format=SubtitlesFormat.SUBRIP if subrip_conversion else SubtitlesFormat.WEBVTT,\r\n                content=subtitles.to_srt().dump() if subrip_conversion else subtitles.dump(),\r\n                special_type=self.detect_subtitles_type(matched_media),\r\n            )\r\n\r\n\r\nclass ScraperException(Exception):\r\n    pass\r\n\r\n\r\nclass ScraperFactory:\r\n    def __init__(self):\r\n        self._scrapers: list[type[Scraper]] = [scraper_class for scraper_class in self.get_scraper_classes()]\r\n        self._scrapers_cache: dict[type[Scraper], Scraper] = {}\r\n\r\n    def get_initialized_scrapers(self) -> list[Scraper]:\r\n        \"\"\"\r\n        Get a list of all previously initialized scrapers.\r\n\r\n        Returns:\r\n            list[Scraper]: A list of initialized scrapers.\r\n        \"\"\"\r\n        return list(self._scrapers_cache.values())\r\n\r\n    @staticmethod\r\n    def get_scraper_classes() -> Iterator[type[Scraper]]:\r\n        \"\"\"\r\n        Find and yield all scraper classes.\r\n\r\n        Yield:\r\n            type[Scraper]: A scraper class.\r\n        \"\"\"\r\n        scraper_modules_paths = glob(os.path.dirname(__file__) + \"/*_scraper.py\")\r\n\r\n        for scraper_module_path in scraper_modules_paths:\r\n            sys.path.append(scraper_module_path)\r\n\r\n            module = importlib.import_module(f\"{PACKAGE_NAME}.scrapers.{Path(scraper_module_path).stem}\")\r\n\r\n            # find Scraper subclasses\r\n            for name, obj in inspect.getmembers(module,\r\n                                                predicate=lambda x: inspect.isclass(x) and issubclass(x, ScraperBase)):\r\n                if inspect.isabstract(obj):\r\n                    continue\r\n\r\n                yield obj\r\n\r\n    def get_matching_scraper(self, url: str, scrapers_config_data: dict = {}) -> Scraper:\r\n        \"\"\"\r\n        Find and return a scraper that matches the given URL.\r\n\r\n        Args:\r\n            url (str): The URL to check.\r\n            scrapers_config_data (dict, optional): A dictionary containing scrapers config data to use\r\n                when creating a new scraper.\r\n\r\n        Returns:\r\n            Scraper | None: An instance of the scraper that matches the given URL, or None if no match was found.\r\n        \"\"\"\r\n        for scraper in self._scrapers:\r\n            if scraper.check_url_match(url):\r\n                if scraper not in self._scrapers_cache:\r\n                    self._scrapers_cache[scraper] = \\\r\n                        scraper(config_data=scrapers_config_data.get(scraper.service_name.lower()))\r\n\r\n                return self._scrapers_cache[scraper]\r\n\r\n        raise ScraperException(f\"No scraper found for URL: {url}\")\r\n\r\n\r\ndef get_matching_scraper(url: str, config_data: Optional[dict] = None) -> Optional[Scraper]:\r\n    \"\"\"\r\n\r\n    Args:\r\n        url (str): The URL to check.\r\n        config_data (dict, optional): A dictionary of config data to use when creating a new scraper.\r\n\r\n    Returns:\r\n        Scraper | None: An instance of the scraper that matches the given URL, or None if no match was found.\r\n    \"\"\"\r\n    scraper_modules_paths = glob(os.path.dirname(__file__) + \"/*_scraper.py\")\r\n\r\n    for scraper_module_path in scraper_modules_paths:\r\n        sys.path.append(scraper_module_path)\r\n\r\n        module = importlib.import_module(f\"scrapers.{Path(scraper_module_path).stem}\")\r\n\r\n        # find Scraper subclasses\r\n        for name, obj in inspect.getmembers(module,\r\n                                            predicate=lambda x: inspect.isclass(x) and issubclass(x, ScraperBase)):\r\n            if obj.check_url_match(url):\r\n                return obj(config_data=config_data)\r\n\r\n            else:\r\n                pass  # TODO: Add logger debug message \"Scraper {obj} does not match URL {url}\"\r\n    return None\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/scrapers/scraper.py b/isubrip/scrapers/scraper.py
--- a/isubrip/scrapers/scraper.py	(revision 6370cc5541a45d9733e7978d6841f580334c6167)
+++ b/isubrip/scrapers/scraper.py	(date 1679090766637)
@@ -49,14 +49,20 @@
 
     # --- Class Attributes ---
     # TODO REFACTOR: Somehow assert these are set in subclasses
-    subtitles_class: type[Subtitles]
-    """The scraper's subtitles class."""
+    @classmethod
+    @abstractmethod
+    def subtitles_class(cls) -> type[Subtitles]:
+        """The class of the subtitles format returned by the scraper."""
+        pass
 
     service_abbreviation: str
     """A short abbreviation of the service name."""
 
-    service_name: str
-    """The name of the service."""
+    @classmethod
+    @abstractmethod
+    def service_name(cls) -> str:
+        """Name of the service the scraper is for."""
+        pass
 
     url_regex: Union[str, list[str]]
     """A RegEx pattern to find URLs matching the service."""
Index: isubrip/scrapers/itunes_scraper.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import json\r\nfrom datetime import datetime\r\n\r\nfrom bs4 import BeautifulSoup, Tag, NavigableString\r\nfrom requests import HTTPError\r\n\r\nfrom isubrip.data_structures import PlaylistData\r\nfrom isubrip.scrapers.scraper import *\r\nfrom isubrip.subtitle_formats.webvtt import WebVTTSubtitles\r\n\r\n\r\nclass iTunesScraper(M3U8Scraper, MovieScraper):\r\n    \"\"\"An iTunes movie data scraper.\"\"\"\r\n    url_regex = r\"^(https?://itunes\\.apple\\.com/[a-z]{2}/movie/(?:[\\w\\-%]+/)?(id\\d{9,10}))(?:$|\\?.*)\"\r\n    service_name = \"iTunes\"\r\n    service_abbreviation = \"iT\"\r\n    subtitles_class = WebVTTSubtitles\r\n\r\n    def get_data(self, url: str):\r\n        return self._get_movie_data(url)\r\n\r\n    def _get_movie_data(self, url: str) -> MovieData:\r\n        \"\"\"\r\n        Scrape iTunes to find info about a movie, and it's M3U8 main_playlist.\r\n\r\n        Args:\r\n            url (str): An iTunes store movie URL.\r\n\r\n        Raises:\r\n            InvalidURL: `itunes_url` is not a valid iTunes store movie URL.\r\n            PageLoadError: HTML page did not load properly.\r\n            HTTPError: HTTP request failed.\r\n\r\n        Returns:\r\n            MovieData: A MovieData (NamedTuple) object with movie's name, and an M3U8 object of the main_playlist\r\n            if the main_playlist is found. None otherwise.\r\n        \"\"\"\r\n        regex_match = re.fullmatch(self.url_regex, url)\r\n\r\n        url = regex_match.group(1)\r\n        response = self._session.get(url)\r\n        response.raise_for_status()\r\n\r\n        # Response is JSON formatted\r\n        if \"application/json\" in response.headers['content-type']:\r\n            try:\r\n                json_data = json.loads(response.content)\r\n\r\n            except json.JSONDecodeError:\r\n                raise ScraperException(\"Recieved an invalid JSON response.\")\r\n\r\n            return self._find_playlist_data_json(json_data)\r\n\r\n        # Response is HTML formatted\r\n        elif \"text/html\" in response.headers['content-type'] and response.status_code != 404:\r\n            html_data = BeautifulSoup(response.content, \"lxml\")\r\n            return self._find_playlist_data_html(html_data)\r\n\r\n    def _find_playlist_data_json(self, json_data: dict) -> MovieData:\r\n        \"\"\"\r\n        Scrape an iTunes JSON response to get movie info.\r\n\r\n        Args:\r\n            json_data (dict): A dictionary with iTunes data loaded from a JSON response.\r\n\r\n        Returns:\r\n            MovieData: A MovieData (NamedTuple) object with movie's name, and an M3U8 object of the main_playlist\r\n            if the main_playlist is found. None otherwise.\r\n        \"\"\"\r\n        itunes_id = json_data[\"pageData\"][\"id\"]\r\n        movie_data = json_data[\"storePlatformData\"][\"product-dv\"][\"results\"][itunes_id]\r\n\r\n        movie_title = movie_data[\"nameRaw\"]\r\n        movie_release_year = datetime.strptime(movie_data[\"releaseDate\"], '%Y-%m-%d').year\r\n\r\n        # Loop safely to find a matching main_playlist\r\n        for offer in movie_data[\"offers\"]:\r\n            if isinstance(offer.get(\"type\"), str) and offer[\"type\"] in [\"buy\", \"rent\"]:\r\n                if isinstance(offer.get(\"assets\"), list) and len(offer[\"assets\"]) > 0:\r\n                    for asset in offer[\"assets\"]:\r\n                        playlist_url: str = asset[\"hlsUrl\"]\r\n\r\n                        # Assure main_playlist is valid\r\n                        try:\r\n                            m3u8.load(playlist_url)\r\n\r\n                        # If m3u8 main_playlist is invalid, skip it\r\n                        except (ValueError, HTTPError):\r\n                            continue\r\n\r\n                        return MovieData(\r\n                            name=movie_title,\r\n                            release_year=movie_release_year,\r\n                            playlist=[PlaylistData(id=itunes_id, url=playlist_url)],\r\n                        )\r\n\r\n        return MovieData(\r\n            name=movie_title,\r\n            release_year=movie_release_year,\r\n            playlist=[],\r\n        )\r\n\r\n    def _find_playlist_data_html(self, html_data: BeautifulSoup) -> MovieData:\r\n        \"\"\"\r\n        Scrape an iTunes HTML page to get movie info.\r\n\r\n        Note:\r\n            This function uses web-scraping and because of that,\r\n            it's a lot less reliable than `_find_playlist_data_itunes_json_`.\r\n\r\n        Args:\r\n            html_data (BeautifulSoup): A BeautifulSoup object of the page.\r\n\r\n        Raises:\r\n            PageLoadError: HTML page did not load properly.\r\n\r\n        Returns:\r\n            MovieData: A MovieData (NamedTuple) object with movie's name, and an M3U8 object of the main_playlist\r\n            if the main_playlist is found. None otherwise.\r\n        \"\"\"\r\n        itunes_id_tag: Union[Tag, NavigableString, None] = html_data.find(\"meta\", attrs={\"name\": \"apple:content_id\"})\r\n        if not isinstance(itunes_id_tag, Tag):\r\n            raise ScraperException(\"HTML page did not load properly.\")\r\n\r\n        itunes_id: str = itunes_id_tag.attrs[\"content\"]\r\n\r\n        # Scrape a dictionary on the webpage that has playlists data\r\n        shoebox_data_tag: Union[Tag, NavigableString, None] = html_data.find(\"script\", attrs={\"id\": \"shoebox-ember-data-store\", \"type\": \"fastboot/shoebox\"})\r\n\r\n        # fastboot/shoebox data could not be found\r\n        if not isinstance(shoebox_data_tag, Tag):\r\n            raise ScraperException(\"fastboot/shoebox data could not be found.\")\r\n\r\n        # Convert to dictionary structure\r\n        shoebox_data: dict = json.loads(str(shoebox_data_tag.contents[0]).strip())\r\n\r\n        # Loop safely to find a matching main_playlist\r\n        if isinstance(shoebox_data[itunes_id].get(\"included\"), list):\r\n            movie_data: dict = shoebox_data[itunes_id]\r\n            movie_title: str = movie_data[\"data\"][\"attributes\"][\"name\"]\r\n            movie_release_year = datetime.strptime(movie_data[\"data\"][\"attributes\"][\"releaseDate\"], '%Y-%m-%d').year\r\n\r\n            for item in movie_data[\"included\"]:\r\n                if isinstance(item.get(\"type\"), str) and item[\"type\"] == \"offer\":\r\n                    if isinstance(item.get(\"attributes\"), dict) and \\\r\n                        isinstance(item[\"attributes\"].get(\"assets\"), list) and \\\r\n                            len(item[\"attributes\"][\"assets\"]) > 0:\r\n\r\n                        for asset in item[\"attributes\"][\"assets\"]:\r\n                            if isinstance(asset, dict) and isinstance(asset.get(\"hlsUrl\"), str):\r\n                                playlist_url: str = item[\"attributes\"][\"assets\"][0][\"hlsUrl\"]\r\n\r\n                                # Try loading the main_playlist to assure it's working\r\n                                try:\r\n                                    m3u8.load(playlist_url)\r\n\r\n                                # If m3u8 main_playlist is invalid, skip it\r\n                                except (ValueError, HTTPError):\r\n                                    continue\r\n\r\n                                return MovieData(\r\n                                    name=movie_title,\r\n                                    release_year=movie_release_year,\r\n                                    playlist=[PlaylistData(id=itunes_id, url=playlist_url)],\r\n                                )\r\n        else:\r\n            raise ScraperException(\"Invalid shoebox data.\")\r\n\r\n        return MovieData(\r\n            name=movie_title,\r\n            release_year=movie_release_year,\r\n            playlist=[],\r\n        )\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/scrapers/itunes_scraper.py b/isubrip/scrapers/itunes_scraper.py
--- a/isubrip/scrapers/itunes_scraper.py	(revision 6370cc5541a45d9733e7978d6841f580334c6167)
+++ b/isubrip/scrapers/itunes_scraper.py	(date 1679090493526)
@@ -12,7 +12,7 @@
 class iTunesScraper(M3U8Scraper, MovieScraper):
     """An iTunes movie data scraper."""
     url_regex = r"^(https?://itunes\.apple\.com/[a-z]{2}/movie/(?:[\w\-%]+/)?(id\d{9,10}))(?:$|\?.*)"
-    service_name = "iTunes"
+    # service_name = "iTunes"
     service_abbreviation = "iT"
     subtitles_class = WebVTTSubtitles
 
@@ -47,7 +47,7 @@
                 json_data = json.loads(response.content)
 
             except json.JSONDecodeError:
-                raise ScraperException("Recieved an invalid JSON response.")
+                raise ScraperException("Received an invalid JSON response.")
 
             return self._find_playlist_data_json(json_data)
 
