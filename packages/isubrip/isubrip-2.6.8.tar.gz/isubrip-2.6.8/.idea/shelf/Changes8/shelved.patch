Index: isubrip/scrapers/scraper.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nimport abc\r\nimport asyncio\r\nimport importlib\r\nimport inspect\r\nimport os\r\nimport re\r\nimport sys\r\nfrom abc import abstractmethod\r\nfrom enum import Enum\r\nfrom glob import glob\r\nfrom pathlib import Path\r\nfrom typing import Dict, Iterator, List, Optional, Tuple, Type, Union, NamedTuple, TypeVar\r\n\r\nimport aiohttp\r\nimport m3u8\r\nimport requests\r\nfrom m3u8 import M3U8, Media\r\n\r\nfrom isubrip.config import Config, ConfigSetting\r\nfrom isubrip.utils import merge_dict_values\r\nfrom isubrip.subtitles.subtitles import Subtitles, SubtitlesFormat, SubtitlesType\r\n\r\nScraper = TypeVar('Scraper', bound='ScraperBase')\r\n\r\n\r\nclass SubtitlesData(NamedTuple):  # TODO: Complete and return in scraper.get_subtitles, to use in main()\r\n    \"\"\"A named tuple containing subtitles metadata.\"\"\"\r\n    language_code: str\r\n    language_name: str\r\n    format: SubtitlesFormat\r\n    content: bytes\r\n    special_type: Optional[SubtitlesType] = None\r\n\r\n\r\nclass PlaylistData(NamedTuple):\r\n    \"\"\"A named tuple containing main_playlist data.\"\"\"\r\n    url: str\r\n    id: Optional[str] = None\r\n\r\n\r\nclass MovieData(NamedTuple):\r\n    \"\"\"A named tuple containing a movie name, id, and M3U8 main_playlist.\"\"\"\r\n    scraper: Type[ScraperBase]\r\n    name: str\r\n    release_year: int\r\n    playlist: Union[PlaylistData, List[PlaylistData]]\r\n\r\n\r\nclass EpisodeData(NamedTuple):\r\n    scraper: ScraperBase\r\n    episode_number: int\r\n    season_data: SeasonData\r\n    series_data: SeriesData\r\n    episode_name: Optional[str] = None\r\n    playlist: Optional[str] = None\r\n\r\n\r\nclass SeasonData(NamedTuple):\r\n    \"\"\"A named tuple containing a season number and M3U8 main_playlist.\"\"\"\r\n    season_number: int\r\n    episodes: List[EpisodeData]\r\n    series_data: SeriesData\r\n    season_name: Optional[str] = None\r\n\r\n\r\nclass SeriesData(NamedTuple):\r\n    \"\"\"A named tuple containing a series name, id, and M3U8 main_playlist.\"\"\"\r\n    name: str\r\n    release_year: int\r\n    seasons: List[SeasonData]\r\n\r\n\r\nclass ScraperBase(metaclass=abc.ABCMeta):\r\n    \"\"\"A base class for scrapers.\"\"\"\r\n    _config_category: str = \"main_playlist-filters\"\r\n\r\n    default_user_agent = None\r\n\r\n    is_movie_scraper: bool = False\r\n    is_series_scraper: bool = False\r\n\r\n    # --- Class Attributes ---\r\n    # TODO: Somehow assert these are set in subclasses\r\n    subtitles_class: Type[Subtitles]\r\n    \"\"\"The scraper's subtitles class.\"\"\"\r\n\r\n    service_abbreviation: str\r\n    \"\"\"A short abbreviation of the service name.\"\"\"\r\n\r\n    service_name: str\r\n    \"\"\"The name of the service.\"\"\"\r\n\r\n    url_regex: Union[str, List[str]]\r\n    \"\"\"A RegEx pattern to find URLs matching the service.\"\"\"\r\n\r\n    def __init__(self, config_data: Optional[dict] = None):\r\n        self._session = requests.Session()\r\n        self._session.headers.update({\"User-Agent\": self.default_user_agent})\r\n        self.config: Optional[Config] = Config(config_data=config_data)\r\n        self.default_filters: dict = {}\r\n\r\n    @classmethod\r\n    def check_url_match(cls, url: str) -> bool:\r\n        \"\"\"\r\n        Checks if a URL matches scraper's url regex.\r\n\r\n        Args:\r\n            url: The URL to check.\r\n\r\n        Returns:\r\n            bool: True if URL matches, False otherwise.\r\n        \"\"\"\r\n        if not cls.url_regex:\r\n            return False\r\n\r\n        if isinstance(cls.url_regex, str):\r\n            return re.fullmatch(cls.url_regex, url) is not None\r\n\r\n        elif isinstance(cls.url_regex, (list, tuple)):\r\n            for regex in cls.url_regex:\r\n                if re.fullmatch(regex, url) is not None:\r\n                    return True\r\n\r\n            return False\r\n\r\n    @abstractmethod\r\n    def get_data(self, url: str) -> Union[MovieData, SeriesData, SeasonData, EpisodeData]:\r\n        \"\"\"\r\n        Scrape media information about the media on a URL.\r\n\r\n        Args:\r\n            url: The URL to get information about.\r\n\r\n        Returns:\r\n            Union[MovieData, SeriesData, SubtitlesData, PlaylistData]: Information about the media.\r\n        \"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    def get_subtitles(self, main_playlist: M3U8, playlist_filters: Union[Dict[str, Union[str, List[str]]], None] = None,\r\n                      subrip_conversion: bool = False) -> Iterator[SubtitlesData]:  # TODO: Add signature to ScraperBase\r\n        \"\"\"\r\n        Find and yield subtitles data from a main_playlist.\r\n        \"\"\"\r\n        pass\r\n\r\n\r\nclass MovieScraper(ScraperBase):\r\n    \"\"\"\r\n    A base class for movie scrapers.\r\n    \"\"\"\r\n    is_movie_scraper: bool = True\r\n\r\n    @abstractmethod\r\n    def _get_movie_data(self, url: str) -> MovieData:\r\n        pass\r\n\r\n\r\nclass SeriesScraper(ScraperBase):\r\n    \"\"\"\r\n    A base class for TV scrapers.\r\n    \"\"\"\r\n    is_series_scraper: bool = True\r\n\r\n    @abstractmethod\r\n    def _get_series_data(self, url: str) -> SeriesData:\r\n        pass\r\n\r\n\r\nclass M3U8Scraper(ScraperBase, metaclass=abc.ABCMeta):\r\n    \"\"\"\r\n\r\n    \"\"\"\r\n    class M3U8Attribute(Enum):\r\n        \"\"\"\r\n        An enum representing all possible M3U8 attributes.\r\n        Names represent M3U8 attributes (should be converted to lowercase),\r\n        and values represent the name of the key for config usage.\r\n        \"\"\"\r\n        ASSOC_LANGUAGE = \"assoc-language\"\r\n        AUTOSELECT = \"autoselect\"\r\n        CHARACTERISTICS = \"characteristics\"\r\n        CHANNELS = \"channels\"\r\n        DEFAULT = \"default\"\r\n        FORCED = \"forced\"\r\n        GROUP_ID = \"group-id\"\r\n        INSTREAM_ID = \"instream-id\"\r\n        LANGUAGE = \"language\"\r\n        NAME = \"name\"\r\n        STABLE_RENDITION_ID = \"stable-rendition-id\"\r\n        TYPE = \"type\"\r\n\r\n    def __init__(self, config_data: Optional[dict] = None):\r\n        super().__init__(config_data)\r\n\r\n        # Add M3U8 filters settings\r\n        self.config.add_settings([\r\n            ConfigSetting(\r\n                category=ScraperBase._config_category,\r\n                key=m3u8_attribute.value,\r\n                type=Union[str, List[str]],\r\n                required=False,\r\n            ) for m3u8_attribute in self.M3U8Attribute])\r\n\r\n    async def _download_m3u8_segment(self, session: aiohttp.ClientSession, segment_url: str) -> str:\r\n        \"\"\"\r\n        Download an M3U8 segment asynchronously.\r\n\r\n        Args:\r\n            segment_url (str): Segment URL to download.\r\n\r\n        Returns:\r\n            str: Downloaded segment data as a string.\r\n        \"\"\"\r\n        async with session.get(segment_url) as response:\r\n            return await response.text()\r\n\r\n    @staticmethod\r\n    def detect_subtitles_type(subtitles_media: m3u8.Media) -> Optional[SubtitlesType]:\r\n        \"\"\"\r\n        Detect the type of subtitles from a m3u8 Media object.\r\n\r\n        Args:\r\n            subtitles_media (m3u8.Media): Subtitles Media object to detect the type of.\r\n\r\n        Returns:\r\n            Optional[SubtitlesType]: The type of the subtitles, None for regular subtitles.\r\n        \"\"\"\r\n        if subtitles_media.forced == \"YES\":\r\n            return SubtitlesType.FORCED\r\n\r\n        elif subtitles_media.characteristics is not None and \"public.accessibility\" in subtitles_media.characteristics:\r\n            return SubtitlesType.CC\r\n\r\n        return None\r\n\r\n    def get_media_playlists(self, main_playlist: m3u8.M3U8,\r\n                            playlist_filters: Union[Dict[str, Union[str, List[str], Tuple[str]]], None] = None,\r\n                            include_default_filters: bool = True) -> Iterator[Media]:\r\n        \"\"\"\r\n        Find and yield playlists of media within an M3U8 main_playlist using optional filters.\r\n\r\n        Args:\r\n            main_playlist (m3u8.M3U8): an M3U8 object of the main main_playlist.\r\n            playlist_filters (dict, optional): A dictionary of filters to use when searching for subtitles.\r\n                Will be added to filters set by the config (unless `include_default_filters` is set to false).\r\n                Defaults to None.\r\n            include_default_filters (bool, optional): Whether to include the default filters set by the config or not.\r\n                Defaults to True.\r\n\r\n        Yields:\r\n            SubtitlesData: A NamedTuple with a matching main_playlist, and it's metadata:\r\n            Language Code, Language Name, SubtitlesType, Playlist URL.\r\n        \"\"\"\r\n        if include_default_filters and self.default_filters:\r\n            if not playlist_filters:\r\n                playlist_filters = self.default_filters\r\n\r\n            else:\r\n                playlist_filters = merge_dict_values(self.default_filters, playlist_filters)\r\n\r\n        for media in main_playlist.media:\r\n            if playlist_filters is None:\r\n                yield media\r\n\r\n            is_valid = True\r\n\r\n            for filter_name, filter_value in playlist_filters.items():\r\n                try:\r\n                    filter_name = M3U8Scraper.M3U8Attribute(filter_name)\r\n\r\n                except ValueError:\r\n                    continue\r\n                    # TODO: Add logger warning \"invalid main_playlist filter, skipping...\"\r\n\r\n                attribute_value = getattr(media, filter_name.name.lower(), None)\r\n\r\n                if attribute_value is None:\r\n                    is_valid = False\r\n                    break\r\n\r\n                if isinstance(filter_value, (list, tuple)) and \\\r\n                        attribute_value.casefold() not in (x.casefold() for x in filter_value):\r\n                    is_valid = False\r\n                    break\r\n\r\n                elif isinstance(filter_value, str) and filter_value.casefold() != attribute_value.casefold():\r\n                    is_valid = False\r\n                    break\r\n\r\n            if not is_valid:\r\n                continue\r\n\r\n            yield media\r\n\r\n    def get_subtitles(self, main_playlist: m3u8.M3U8,\r\n                      playlist_filters: Union[Dict[str, Union[str, List[str]]], None] = None,\r\n                      subrip_conversion: bool = False) -> Iterator[SubtitlesData]:  # TODO: Use instead of playlist_downloader\r\n        \"\"\"\r\n        Find and yield subtitles for a movie using optional filters.\r\n\r\n        Args:\r\n            main_playlist (m3u8.M3U8): an M3U8 object of the main playlist.\r\n            playlist_filters (dict, optional): A dictionary of filters to use when searching for subtitles.\r\n                Will be added to filters set by the config. Defaults to None.\r\n            subrip_conversion (bool, optional): Whether to convert and return the subtitles as an SRT file or not.\r\n\r\n        Yields:\r\n            SubtitlesData: A SubtitlesData NamedTuple with a matching playlist, and it's metadata.\r\n        \"\"\"\r\n        if playlist_filters is None:\r\n            playlist_filters = {}\r\n\r\n        playlist_filters[\"type\"] = \"SUBTITLES\"\r\n\r\n        for matched_media in self.get_media_playlists(main_playlist=main_playlist, playlist_filters=playlist_filters):\r\n            try:\r\n                matched_media_playlist = m3u8.load(matched_media.absolute_uri)\r\n\r\n            except (ValueError, IOError) as e:\r\n                pass  # TODO: Add logger warning\r\n                continue\r\n\r\n            subtitles: Subtitles = self.subtitles_class(language_code=matched_media.language)\r\n\r\n            async_session = aiohttp.ClientSession(headers=self._session.headers)\r\n            async_loop = asyncio.get_event_loop()\r\n            async_tasks = [async_loop.create_task(self._download_m3u8_segment(session=async_session,\r\n                                                                              segment_url=segment.absolute_uri))\r\n                           for segment in matched_media_playlist.segments]\r\n            segments = async_loop.run_until_complete(asyncio.gather(*async_tasks))\r\n\r\n            for segment in segments:\r\n                subtitles.append_subtitles(subtitles.loads(segment))\r\n\r\n            yield SubtitlesData(\r\n                language_code=matched_media.language,\r\n                language_name=matched_media.name,\r\n                format=SubtitlesFormat.SUBRIP if subrip_conversion else SubtitlesFormat.WEBVTT,\r\n                content=subtitles.to_srt().dump() if subrip_conversion else subtitles.dump(),\r\n                special_type=self.detect_subtitles_type(matched_media),\r\n            )\r\n\r\n\r\nclass ScraperException(Exception):\r\n    pass\r\n\r\n\r\ndef find_matching_scraper(url: str) -> Optional[Type[ScraperBase]]:\r\n    \"\"\"\r\n    Import all scrapers, and find one where `check_url_match` returns True.\r\n\r\n    Args:\r\n        url (str): The URL to check.\r\n\r\n    Returns:\r\n        Optional[Type[ScraperBase]]: The scraper that matches the URL, or None if no matching scraper was found.\r\n    \"\"\"\r\n    scraper_modules_paths = glob(os.path.dirname(__file__) + \"/*_scraper.py\")\r\n\r\n    for scraper_module_path in scraper_modules_paths:\r\n        sys.path.append(scraper_module_path)\r\n\r\n        module = importlib.import_module(f\"scrapers.{Path(scraper_module_path).stem}\")\r\n\r\n        # find Scraper subclasses\r\n        for name, obj in inspect.getmembers(module,\r\n                                            predicate=lambda x: inspect.isclass(x) and issubclass(x, ScraperBase)):\r\n            if obj.check_url_match(url):\r\n                return obj\r\n\r\n                pass  # TODO: Add logger debug message \"Scraper {obj} does not match URL {url}\"\r\n    return None\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/scrapers/scraper.py b/isubrip/scrapers/scraper.py
--- a/isubrip/scrapers/scraper.py	(revision e77f1c538840edc1fd2bc4632a0b6dc4db14ca38)
+++ b/isubrip/scrapers/scraper.py	(date 1674464478507)
@@ -25,53 +25,6 @@
 Scraper = TypeVar('Scraper', bound='ScraperBase')
 
 
-class SubtitlesData(NamedTuple):  # TODO: Complete and return in scraper.get_subtitles, to use in main()
-    """A named tuple containing subtitles metadata."""
-    language_code: str
-    language_name: str
-    format: SubtitlesFormat
-    content: bytes
-    special_type: Optional[SubtitlesType] = None
-
-
-class PlaylistData(NamedTuple):
-    """A named tuple containing main_playlist data."""
-    url: str
-    id: Optional[str] = None
-
-
-class MovieData(NamedTuple):
-    """A named tuple containing a movie name, id, and M3U8 main_playlist."""
-    scraper: Type[ScraperBase]
-    name: str
-    release_year: int
-    playlist: Union[PlaylistData, List[PlaylistData]]
-
-
-class EpisodeData(NamedTuple):
-    scraper: ScraperBase
-    episode_number: int
-    season_data: SeasonData
-    series_data: SeriesData
-    episode_name: Optional[str] = None
-    playlist: Optional[str] = None
-
-
-class SeasonData(NamedTuple):
-    """A named tuple containing a season number and M3U8 main_playlist."""
-    season_number: int
-    episodes: List[EpisodeData]
-    series_data: SeriesData
-    season_name: Optional[str] = None
-
-
-class SeriesData(NamedTuple):
-    """A named tuple containing a series name, id, and M3U8 main_playlist."""
-    name: str
-    release_year: int
-    seasons: List[SeasonData]
-
-
 class ScraperBase(metaclass=abc.ABCMeta):
     """A base class for scrapers."""
     _config_category: str = "main_playlist-filters"
Index: isubrip/subtitles/subtitles.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nfrom enum import Enum\r\nfrom datetime import time\r\nfrom typing import Union, Optional, Type, List, Tuple, TypeVar\r\n\r\nRTL_CONTROL_CHARS = ('\\u200e', '\\u200f', '\\u202a', '\\u202b', '\\u202c', '\\u202d', '\\u202e')\r\nRTL_CHAR = '\\u202b'\r\n\r\nSubtitles = TypeVar('Subtitles', bound='SubtitlesBase')\r\nSubtitlesBlock = TypeVar('SubtitlesBlock', bound='SubtitlesBlockBase')\r\n\r\n\r\nclass SubtitlesFormat(Enum):  # TODO: Remove and use `format_file_extension` attribute instead?\r\n    \"\"\"Subtitles format. Value is the file extension.\"\"\"\r\n    SUBRIP = \"srt\"\r\n    WEBVTT = \"vtt\"\r\n\r\n\r\nclass SubtitlesType(Enum):\r\n    \"\"\"Subtitles special type.\"\"\"\r\n    CC = 1\r\n    FORCED = 2\r\n\r\n\r\nclass SubtitlesBlockBase(metaclass=ABCMeta):\r\n    \"\"\"Abstract base class for subtitles blocks.\"\"\"\r\n    @abstractmethod\r\n    def __str__(self):\r\n        pass\r\n\r\n    @abstractmethod\r\n    def __eq__(self, other):\r\n        pass\r\n\r\n    # TODO: Uncomment once implemented on SubRipSubtitles\r\n    # @staticmethod\r\n    # @abstractmethod\r\n    # def loads(subtitles_data: str) -> Subtitles:\r\n    #     pass\r\n\r\n\r\nclass SubtitlesCaptionBlockBase(SubtitlesBlockBase, metaclass=ABCMeta):\r\n    \"\"\"A base class for subtitles caption blocks.\"\"\"\r\n    def _fix_rtl(self) -> None:\r\n        \"\"\"Fix text direction to RTL.\"\"\"\r\n        # Remove previous RTL-related formatting\r\n        for char in RTL_CONTROL_CHARS:\r\n            self.payload = self.payload.replace(char, '')\r\n\r\n        # Add RLM char at the start of every line\r\n        self.payload = RTL_CHAR + self.payload.replace(\"\\n\", f\"\\n{RTL_CHAR}\")\r\n\r\n\r\nclass SubtitlesBase(metaclass=ABCMeta):\r\n    \"\"\"An object representing subtitles, made out of blocks.\"\"\"\r\n    @property  # TODO: These attributes have the same issue as the ones for scrapers, where they apply only instances of the class, but not the class itself.\r\n    @abstractmethod\r\n    def _blocks_type(self) -> Type[SubtitlesBlockBase]:\r\n        \"\"\"The format of the subtitles.\"\"\"\r\n        pass\r\n\r\n    @property\r\n    @abstractmethod\r\n    def format(self) -> SubtitlesFormat:\r\n        \"\"\"The format of the subtitles.\"\"\"\r\n        pass\r\n\r\n    @property\r\n    @abstractmethod\r\n    def format_file_extension(self) -> str:\r\n        \"\"\"The file extension for the format used for the subtitles.\"\"\"\r\n        pass\r\n\r\n    @property\r\n    @abstractmethod\r\n    def format_name(self) -> str:\r\n        \"\"\"The name of the format used for the subtitles.\"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    def dump(self) -> bytes:\r\n        \"\"\"Dump subtitles object to bytes representing the subtitles file.\"\"\"\r\n        pass\r\n\r\n    @abstractmethod\r\n    def dumps(self) -> str:\r\n        \"\"\"Dump subtitles object to a string representing the subtitles.\"\"\"\r\n        pass\r\n\r\n    def __init__(self, blocks: Optional[List[SubtitlesBlockBase]] = None, language_code: Optional[str] = None):\r\n        \"\"\"Initialize a new Subtitles object.\"\"\"\r\n        self.language_code: str = language_code\r\n        # TODO: Add language_name\r\n\r\n        if blocks is not None:\r\n            self.blocks: List[SubtitlesBlockBase] = blocks\r\n\r\n        else:\r\n            self.blocks: list[SubtitlesBlockBase] = []\r\n\r\n    def __add__(self, obj: Union[SubtitlesBlockBase, SubtitlesBase]) -> SubtitlesBase:\r\n        \"\"\"\r\n        Add a new subtitles block, or append blocks from another subtitles object.\r\n\r\n        Args:\r\n            obj (SubtitlesBlockBase | SubtitlesBase): A subtitles block or another subtitles object.\r\n\r\n        Returns:\r\n            Subtitles: The current subtitles object.\r\n        \"\"\"\r\n        if isinstance(obj, SubtitlesBlockBase):\r\n            self.add_block(obj)\r\n\r\n        elif isinstance(obj, self.__class__):\r\n            self.append_subtitles(obj)\r\n\r\n        return self\r\n\r\n    def __str__(self) -> str:\r\n        return self.dumps()\r\n\r\n    def _remove_duplicates(self) -> None:\r\n        \"\"\"Remove duplicate captions.\"\"\"\r\n        pass  # TODO\r\n\r\n    def add_block(self, block: Union[SubtitlesBlockBase, List[SubtitlesBlockBase], Tuple[SubtitlesBlockBase]]) -> None:\r\n        \"\"\"\r\n        Add a new subtitles block to current subtitles.\r\n\r\n        Args:\r\n            block (SubtitlesBlockBase | list | tuple): A block object or a list/tuple of block objects to append.\r\n        \"\"\"\r\n        if isinstance(block, (list, tuple)):\r\n            if all(isinstance(item, self._blocks_type) for item in block):\r\n                self.blocks.extend(block)\r\n\r\n            else:\r\n                raise ValueError(f\"All items in the list / tuple must be of type \\\"{self._blocks_type}\\\".\")\r\n\r\n        elif isinstance(block, self._blocks_type):\r\n            self.blocks.append(block)\r\n\r\n        else:\r\n            raise TypeError(\r\n                f\"Can't append a block of type \\\"{type(block)}\\\" to a \\\"{self.__class__}\\\" subtitles object \"\r\n                f\"as it accepts only blocks of type \\\"{self._blocks_type}\\\".\")\r\n\r\n    def append_subtitles(self, subtitles: SubtitlesBase) -> None:\r\n        \"\"\"\r\n        Append an existing subtitles object.\r\n\r\n        Args:\r\n            subtitles (Subtitles): Subtitles object to append to current subtitles.\r\n        \"\"\"\r\n        for block in subtitles.blocks:\r\n            self.add_block(block)\r\n\r\n    def polish(self, fix_rtl: Optional[bool] = False,\r\n               remove_duplicates: Optional[bool] = False) -> None:\r\n        \"\"\"Polish the block.\"\"\"\r\n        if fix_rtl:\r\n            for block in self.blocks:\r\n                if isinstance(block, SubtitlesCaptionBlockBase):\r\n                    block._fix_rtl()\r\n\r\n        if remove_duplicates:\r\n            self._remove_duplicates()\r\n\r\n\r\ndef split_timestamp(timestamp: str) -> tuple[time, time]:\r\n    \"\"\"\r\n    Split a subtitles timestamp into start and end.\r\n\r\n    Args:\r\n        timestamp (str): A subtitles timestamp. For example: \"00:00:00.000 --> 00:00:00.000\"\r\n\r\n    Returns:\r\n        tuple(time, time): A tuple containing start and end times as a datetime object.\r\n    \"\"\"\r\n    # Support ',' character in timestamp's milliseconds (used in SubRip format).\r\n    timestamp = timestamp.replace(',', '.')\r\n\r\n    start_time, end_time = timestamp.split(\" --> \")\r\n    return time.fromisoformat(start_time), time.fromisoformat(end_time)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/subtitles/subtitles.py b/isubrip/subtitles/subtitles.py
--- a/isubrip/subtitles/subtitles.py	(revision e77f1c538840edc1fd2bc4632a0b6dc4db14ca38)
+++ b/isubrip/subtitles/subtitles.py	(date 1674464478522)
@@ -1,7 +1,6 @@
 from __future__ import annotations
 
 from abc import ABCMeta, abstractmethod
-from enum import Enum
 from datetime import time
 from typing import Union, Optional, Type, List, Tuple, TypeVar
 
@@ -12,18 +11,6 @@
 SubtitlesBlock = TypeVar('SubtitlesBlock', bound='SubtitlesBlockBase')
 
 
-class SubtitlesFormat(Enum):  # TODO: Remove and use `format_file_extension` attribute instead?
-    """Subtitles format. Value is the file extension."""
-    SUBRIP = "srt"
-    WEBVTT = "vtt"
-
-
-class SubtitlesType(Enum):
-    """Subtitles special type."""
-    CC = 1
-    FORCED = 2
-
-
 class SubtitlesBlockBase(metaclass=ABCMeta):
     """Abstract base class for subtitles blocks."""
     @abstractmethod
