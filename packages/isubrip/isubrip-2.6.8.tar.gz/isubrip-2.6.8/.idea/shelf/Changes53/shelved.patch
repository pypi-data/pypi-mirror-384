Index: isubrip/utils.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nfrom abc import ABCMeta\r\nimport datetime as dt\r\nfrom pathlib import Path\r\nimport re\r\nimport sys\r\nfrom typing import TYPE_CHECKING, Any, Union, get_args, get_origin\r\n\r\nfrom isubrip.data_structures import Episode, Movie, SubtitlesData, SubtitlesFormatType, SubtitlesType\r\nfrom isubrip.logger import logger\r\n\r\nif TYPE_CHECKING:\r\n    from os import PathLike\r\n\r\n    import requests\r\n\r\n\r\nclass SingletonMeta(ABCMeta):\r\n    \"\"\"\r\n    A metaclass that implements the Singleton pattern.\r\n    When a class using this metaclass is initialized, it will return the same instance every time.\r\n    \"\"\"\r\n    _instances: dict[object, object] = {}\r\n\r\n    def __call__(cls, *args, **kwargs) -> object:\r\n        if cls._instances.get(cls) is None:\r\n            cls._instances[cls] = super().__call__(*args, **kwargs)\r\n\r\n        return cls._instances[cls]\r\n\r\n\r\ndef check_type(value: Any, type_) -> bool:\r\n    \"\"\"\r\n    Check if a value is of a certain type.\r\n    Works with parameterized generics.\r\n\r\n    Args:\r\n        value: Value to check.\r\n        type_: Type to check against.\r\n\r\n    Returns:\r\n        bool: True if the value is of the specified type, False otherwise.\r\n    \"\"\"\r\n    origin = get_origin(type_)\r\n    args = get_args(type_)\r\n\r\n    if origin is Union:\r\n        return any(check_type(value, union_sub_type) for union_sub_type in args)\r\n\r\n    if origin is tuple:\r\n        if args[-1] is Ellipsis:\r\n            # Example: (int, str, ...)\r\n            args_len = len(args)\r\n\r\n            return check_type(value[:args_len - 1], tuple(args[:-1])) and \\\r\n                all(check_type(item, args[-2]) for item in value[args_len - 1:])\r\n\r\n        return isinstance(value, tuple) and \\\r\n            len(value) == len(args) and \\\r\n            all(check_type(item, item_type) for item, item_type in zip(value, args))\r\n\r\n    if origin is list:\r\n        return isinstance(value, list) and \\\r\n            all(check_type(item, args[0]) for item in value)\r\n\r\n    if origin is dict:\r\n        return isinstance(value, dict) and \\\r\n            all(check_type(k, args[0]) and check_type(v, args[1]) for k, v in value.items())\r\n\r\n    return isinstance(value, type_)\r\n\r\n\r\ndef convert_epoch_to_datetime(epoch_timestamp: int) -> dt.datetime:\r\n    \"\"\"\r\n    Convert an epoch timestamp to a datetime object.\r\n\r\n    Args:\r\n        epoch_timestamp (int): Epoch timestamp.\r\n\r\n    Returns:\r\n        datetime: A datetime object representing the timestamp.\r\n    \"\"\"\r\n    if epoch_timestamp >= 0:\r\n        return dt.datetime.fromtimestamp(epoch_timestamp)\r\n\r\n    return dt.datetime(1970, 1, 1) + dt.timedelta(seconds=epoch_timestamp)\r\n\r\n\r\ndef download_subtitles_to_file(media_data: Movie | Episode, subtitles_data: SubtitlesData, output_path: str | PathLike,\r\n                               source_abbreviation: str | None = None, overwrite: bool = False) -> Path:\r\n    \"\"\"\r\n    Download subtitles to a file.\r\n\r\n    Args:\r\n        media_data (Movie | Episode): An object containing media data.\r\n        subtitles_data (SubtitlesData): A SubtitlesData object containing subtitles data.\r\n        output_path (str | PathLike): Path to the output folder.\r\n        source_abbreviation (str | None, optional): Abbreviation of the source the subtitles are downloaded from.\r\n            Defaults to None.\r\n        overwrite (bool, optional): Whether to overwrite files if they already exist. Defaults to True.\r\n\r\n    Returns:\r\n        Path: Path to the downloaded subtitles file.\r\n\r\n    Raises:\r\n        ValueError: If the path in `output_path` does not exist.\r\n    \"\"\"\r\n    output_path = Path(output_path)\r\n\r\n    if not output_path.is_dir():\r\n        raise ValueError(f\"Invalid path: {output_path}\")\r\n\r\n    if isinstance(media_data, Movie):\r\n        file_name = generate_release_name(title=media_data.name,\r\n                                          release_date=media_data.release_date,\r\n                                          media_source=source_abbreviation,\r\n                                          language_code=subtitles_data.language_code,\r\n                                          subtitles_type=subtitles_data.special_type,\r\n                                          file_format=subtitles_data.subtitles_format)\r\n    else:  # isinstance(media_data, Episode):\r\n        file_name = generate_release_name(title=media_data.name,\r\n                                          release_date=media_data.release_date,\r\n                                          season_number=media_data.season_number,\r\n                                          episode_number=media_data.episode_number,\r\n                                          episode_name=media_data.episode_name,\r\n                                          media_source=source_abbreviation,\r\n                                          language_code=subtitles_data.language_code,\r\n                                          subtitles_type=subtitles_data.special_type,\r\n                                          file_format=subtitles_data.subtitles_format)\r\n\r\n    file_path = output_path / file_name\r\n\r\n    if file_path.exists() and not overwrite:\r\n        file_path = generate_non_conflicting_path(file_path)\r\n\r\n    with file_path.open('wb') as f:\r\n        f.write(subtitles_data.content)\r\n\r\n    return file_path\r\n\r\n\r\ndef generate_non_conflicting_path(file_path: str | Path, has_extension: bool = True) -> Path:\r\n    \"\"\"\r\n    Generate a non-conflicting path for a file.\r\n    If the file already exists, a number will be added to the end of the file name.\r\n\r\n    Args:\r\n        file_path (str | Path): Path to a file.\r\n        has_extension (bool, optional): Whether the name of the file includes file extension. Defaults to True.\r\n\r\n    Returns:\r\n        Path: A non-conflicting file path.\r\n    \"\"\"\r\n    if isinstance(file_path, str):\r\n        file_path = Path(file_path)\r\n\r\n    if not file_path.exists():\r\n        return file_path\r\n\r\n    i = 1\r\n    while True:\r\n        if has_extension:\r\n            new_file_path = file_path.parent / f\"{file_path.stem}-{i}{file_path.suffix}\"\r\n\r\n        else:\r\n            new_file_path = file_path.parent / f\"{file_path}-{i}\"\r\n\r\n        if not new_file_path.exists():\r\n            return new_file_path\r\n\r\n        i += 1\r\n\r\n\r\ndef generate_release_name(title: str,\r\n                          release_date: dt.datetime | int | None = None,\r\n                          season_number: int | None = None,\r\n                          episode_number: int | None = None,\r\n                          episode_name: str | None = None,\r\n                          media_source: str | None = None,\r\n                          source_type: str | None = \"WEB\",\r\n                          additional_info: str | list[str] | None = None,\r\n                          language_code: str | None = None,\r\n                          subtitles_type: SubtitlesType | None = None,\r\n                          file_format: str | SubtitlesFormatType | None = None) -> str:\r\n    \"\"\"\r\n    Generate a release name.\r\n\r\n    Args:\r\n        title (str): Media title.\r\n        release_date (int | None, optional): Release date (datetime), or year (int) of the media. Defaults to None.\r\n        season_number (int | None, optional): Season number. Defaults to None.\r\n        episode_number (int | None, optional): Episode number. Defaults to None.\r\n        episode_name (str | None, optional): Episode name. Defaults to None.\r\n        media_source (str | None, optional): Media source name (full or abbreviation). Defaults to None.\r\n        source_type(str | None, optional): General source type (WEB, BluRay, etc.). Defaults to None.\r\n        additional_info (list[str] | str | None, optional): Additional info to add to the file name. Defaults to None.\r\n        language_code (str | None, optional): Language code. Defaults to None.\r\n        subtitles_type (SubtitlesType | None, optional): Subtitles type. Defaults to None.\r\n        file_format (SubtitlesFormat | str | None, optional): File format to use.  Defaults to None.\r\n\r\n    Returns:\r\n        str: Generated file name.\r\n    \"\"\"\r\n    file_name = standardize_title(title)\r\n\r\n    if release_date is not None:\r\n        if isinstance(release_date, dt.datetime):\r\n            release_year = release_date.year\r\n\r\n        else:\r\n            release_year = release_date\r\n\r\n        file_name += f\".{release_year}\"\r\n\r\n    if season_number is not None:\r\n        file_name += f\".S{season_number:02}\"\r\n\r\n    if episode_number is not None:\r\n        file_name += f\".E{episode_number:02}\"\r\n\r\n    if episode_name is not None:\r\n        file_name += f\".{standardize_title(episode_name)}\"\r\n\r\n    if media_source is not None:\r\n        file_name += f\".{media_source}\"\r\n\r\n    if source_type is not None:\r\n        file_name += f\".{source_type}\"\r\n\r\n    if additional_info is not None:\r\n        if isinstance(additional_info, (list, tuple)):\r\n            additional_info = '.'.join(additional_info)\r\n\r\n        file_name += f\".{additional_info}\"\r\n\r\n    if language_code is not None:\r\n        file_name += f\".{language_code}\"\r\n\r\n    if subtitles_type is not None:\r\n        file_name += f\".{subtitles_type.value.lower()}\"\r\n\r\n    if file_format is not None:\r\n        if isinstance(file_format, SubtitlesFormatType):\r\n            file_format = file_format.value.file_extension\r\n\r\n        file_name += f\".{file_format}\"\r\n\r\n    return file_name\r\n\r\n\r\ndef merge_dict_values(*dictionaries: dict) -> dict:\r\n    \"\"\"\r\n    A function for merging the values of multiple dictionaries using the same keys.\r\n    If a key already exists, the value will be added to a list of values mapped to that key.\r\n\r\n    Args:\r\n        *dictionaries (dict): Dictionaries to merge.\r\n\r\n    Returns:\r\n        dict: A merged dictionary.\r\n    \"\"\"\r\n    result: dict = {}\r\n\r\n    for dict_ in dictionaries:\r\n        for key, value in dict_.items():\r\n            if key in result:\r\n                if isinstance(result[key], list) and value not in result[key]:\r\n                    result[key].append(value)\r\n\r\n                elif isinstance(result[key], tuple) and value not in result[key]:\r\n                    result[key] = result[key] + (value,)\r\n\r\n                elif value != result[key]:\r\n                    result[key] = [result[key], value]\r\n            else:\r\n                result[key] = value\r\n\r\n    return result\r\n\r\n\r\ndef raise_for_status(response: requests.Response) -> None:\r\n    \"\"\"\r\n    Raise an exception if the response status code is invalid.\r\n    Uses 'response.raise_for_status()' internally, with additional logging.\r\n\r\n    Args:\r\n        response (requests.Response): A response object.\r\n    \"\"\"\r\n    if response.ok:\r\n        return\r\n\r\n    logger.error(f\"Response status code: {response.status_code}\")\r\n    logger.error(f\"Response text: {response.text}\")\r\n\r\n    response.raise_for_status()\r\n\r\n\r\ndef parse_url_params(url_params: str) -> dict:\r\n    \"\"\"\r\n    Parse GET parameters from a URL to a dictionary.\r\n\r\n    Args:\r\n        url_params (str): URL parameters. (e.g. 'param1=value1&param2=value2')\r\n\r\n    Returns:\r\n        dict: A dictionary containing the URL parameters.\r\n    \"\"\"\r\n    url_params = url_params.split('?')[-1].rstrip('&')\r\n    params_list = url_params.split('&')\r\n\r\n    if len(params_list) == 0 or \\\r\n            (len(params_list) == 1 and '=' not in params_list[0]):\r\n        return {}\r\n\r\n    return {key: value for key, value in (param.split('=') for param in params_list)}\r\n\r\n\r\ndef single_to_list(obj) -> list:\r\n    \"\"\"\r\n    Convert a single non-iterable object to a list.\r\n    If None is passed, an empty list will be returned.\r\n\r\n    Args:\r\n        obj: Object to convert.\r\n\r\n    Returns:\r\n        list: A list containing the object.\r\n            If the object is already an iterable, it will be converted to a list.\r\n    \"\"\"\r\n    if isinstance(obj, list):\r\n        return obj\r\n\r\n    if obj is None:\r\n        return []\r\n\r\n    # tuple (not a namedtuple) or a set\r\n    if (isinstance(obj, tuple) and not hasattr(obj, '_fields')) or isinstance(obj, set):\r\n        return list(obj)\r\n\r\n    return [obj]\r\n\r\n\r\ndef split_subtitles_timestamp(timestamp: str) -> tuple[dt.time, dt.time]:\r\n    \"\"\"\r\n    Split a subtitles timestamp into start and end.\r\n\r\n    Args:\r\n        timestamp (str): A subtitles timestamp. For example: \"00:00:00.000 --> 00:00:00.000\"\r\n\r\n    Returns:\r\n        tuple(time, time): A tuple containing start and end times as a datetime object.\r\n    \"\"\"\r\n    # Support ',' character in timestamp's milliseconds (used in SubRip format).\r\n    timestamp = timestamp.replace(',', '.')\r\n\r\n    start_time, end_time = timestamp.split(\" --> \")\r\n    return dt.time.fromisoformat(start_time), dt.time.fromisoformat(end_time)\r\n\r\n\r\ndef standardize_title(title: str) -> str:\r\n    \"\"\"\r\n    Format movie title to a standardized title that can be used as a file name.\r\n\r\n    Args:\r\n        title (str): A movie title.\r\n\r\n    Returns:\r\n        str: The movie title, in a file-name-friendly format.\r\n    \"\"\"\r\n    windows_reserved_file_names = (\"CON\", \"PRN\", \"AUX\", \"NUL\", \"COM1\", \"COM2\", \"COM3\", \"COM4\",\r\n                                   \"COM5\", \"COM6\", \"COM7\", \"COM8\", \"COM9\", \"LPT1\", \"LPT2\",\r\n                                   \"LPT3\", \"LPT4\", \"LPT5\", \"LPT6\", \"LPT7\", \"LPT8\", \"LPT9\")\r\n\r\n    title = title.strip()\r\n\r\n    # Replacements will be done in the same order of this list\r\n    replacement_pairs = [\r\n        (': ', '.'),\r\n        (':', '.'),\r\n        (' - ', '-'),\r\n        (', ', '.'),\r\n        ('. ', '.'),\r\n        (' ', '.'),\r\n        ('|', '.'),\r\n        ('/', '.'),\r\n        ('<', ''),\r\n        ('>', ''),\r\n        ('(', ''),\r\n        (')', ''),\r\n        ('\"', ''),\r\n        ('?', ''),\r\n        ('*', ''),\r\n    ]\r\n\r\n    for pair in replacement_pairs:\r\n        title = title.replace(pair[0], pair[1])\r\n\r\n    title = re.sub(r\"\\.+\", \".\", title)  # Replace multiple dots with a single dot\r\n\r\n    # If running on Windows, rename Windows reserved names to allow file creation\r\n    if sys.platform == 'win32':\r\n        split_title = title.split('.')\r\n\r\n        if split_title[0].upper() in windows_reserved_file_names:\r\n            if len(split_title) > 1:\r\n                return split_title[0] + split_title[1] + '.'.join(split_title[2:])\r\n\r\n            if len(split_title) == 1:\r\n                return \"_\" + title\r\n\r\n    return title\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/utils.py b/isubrip/utils.py
--- a/isubrip/utils.py	(revision 1a3bdb18864b8eb25cb7264b64c09b6d18a63d03)
+++ b/isubrip/utils.py	(date 1701116973418)
@@ -2,7 +2,9 @@
 
 from abc import ABCMeta
 import datetime as dt
+import json
 from pathlib import Path
+import random
 import re
 import sys
 from typing import TYPE_CHECKING, Any, Union, get_args, get_origin
@@ -16,6 +18,9 @@
     import requests
 
 
+HOST_REGEX = re.compile(r"^(?:https?://)?(?:www\.)?(?P<host>[^/:?]+)", flags=re.IGNORECASE)
+
+
 class SingletonMeta(ABCMeta):
     """
     A metaclass that implements the Singleton pattern.
@@ -140,6 +145,19 @@
     return file_path
 
 
+def extract_host_from_url(url: str) -> str:
+    """
+    Extract the host from a URL.
+
+    Args:
+        url (str): A URL.
+
+    Returns:
+        str: The host of the URL.
+    """
+    return re.match(HOST_REGEX, url).group('host')
+
+
 def generate_non_conflicting_path(file_path: str | Path, has_extension: bool = True) -> Path:
     """
     Generate a non-conflicting path for a file.
@@ -172,6 +190,19 @@
         i += 1
 
 
+def generate_random_hex_string(length: int) -> str:
+    """
+    Generate a random hexadecimal string.
+
+    Args:
+        length (int): Length of the string to generate.
+
+    Returns:
+        str: A random hexadecimal string.
+    """
+    return ''.join(random.choice("0123456789abcdef") for _ in range(length))
+
+
 def generate_release_name(title: str,
                           release_date: dt.datetime | int | None = None,
                           season_number: int | None = None,
@@ -249,6 +280,34 @@
     return file_name
 
 
+def generate_url_params(data: dict[str, Any], remove_dict_spaces: bool = False) -> str:
+    """
+    Generate a URL query string from a dictionary.
+
+    Args:
+        data (dict[str, Any]): Dictionary to generate a URL query string from.
+        remove_dict_spaces (bool, optional): Whether to remove spaces from stringified dictionary values.
+            Defaults to False.
+
+    Returns:
+        str: Generated URL query string.
+    """
+    stringified_data = {}
+    json_dumps_separators = (',', ':') if remove_dict_spaces else None
+
+    for key, value in data.items():
+        if isinstance(value, (list, tuple, dict)):
+            stringified_data[key] = json.dumps(value, separators=json_dumps_separators)
+
+        elif isinstance(value, bool):
+            stringified_data[key] = str(value).lower()
+
+        else:
+            stringified_data[key] = str(value)
+
+    return '&'.join([f"{key}={value}" for key, value in stringified_data.items() if value is not None])
+
+
 def merge_dict_values(*dictionaries: dict) -> dict:
     """
     A function for merging the values of multiple dictionaries using the same keys.
@@ -296,6 +355,59 @@
     response.raise_for_status()
 
 
+def parse_duration(duration_string: str) -> dt.timedelta:
+    """
+    Parse a duration ISO 8601 string (e.g. PT1H30M15S), or a duration tag (e.g. '1h 30m', '30m') to a timedelta object.
+
+    Args:
+        duration_string (str): Duration tag to parse.
+
+    Returns:
+        dt.timedelta: A timedelta object representing the duration.
+    """
+    iso8601_duration_regex = re.compile(
+        r"(?i)^PT(?:(?P<hours>\d{1,2})H)?(?:(?P<minutes>\d{1,2})M)?(?:(?P<seconds>\d{1,2})(?:\.(?P<milliseconds>\d{1,3}))?S)?",  # noqa: E501
+    )
+
+    duration_tag_regex = re.compile(
+        r"(?i)^(?:(?P<hours>\d{1,2})H)?\s?(?:(?P<minutes>\d{1,2})M)?\s?(?:(?P<seconds>\d{1,2})S)?$",
+    )
+
+    if regex_match := re.match(iso8601_duration_regex, duration_string):
+        data = regex_match.groupdict()
+
+    elif regex_match := re.match(duration_tag_regex, duration_string):
+        data = regex_match.groupdict()
+
+    else:
+        raise ValueError(f"Invalid / unsupported duration string: '{duration_string}'")
+
+    hours = int(data["hours"]) if data.get("hours") else 0
+    minutes = int(data["minutes"]) if data.get("minutes") else 0
+    seconds = int(data["seconds"]) if data.get("seconds") else 0
+    milliseconds = int(data["milliseconds"]) if data.get("milliseconds") else 0
+
+    return dt.timedelta(hours=hours, minutes=minutes, seconds=seconds, milliseconds=milliseconds)
+
+
+def parse_season_and_episode_tag(tag: str) -> tuple[int, int]:
+    """
+    Parse a season and episode tag (e.g. 'S01E01') to a tuple containing the season number and episode number.
+
+    Args:
+        tag (str): Season and episode tag. (e.g. 'S01E02')
+
+    Returns:
+        tuple[int, int]: A tuple containing the season number (first item) and episode number (second item).
+    """
+    regex_pattern = re.compile(r"(?i)^S(?P<season>\d{1,2})[\s.]?E(?P<episode>\d{1,3})$")
+
+    if regex_match := re.match(regex_pattern, tag):
+        return int(regex_match.group('season')), int(regex_match.group('episode'))
+
+    raise ValueError(f"Invalid season and episode tag: '{tag}'")
+
+
 def parse_url_params(url_params: str) -> dict:
     """
     Parse GET parameters from a URL to a dictionary.
Index: isubrip/scrapers/scraper.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nfrom abc import ABC, abstractmethod\r\nimport asyncio\r\nfrom enum import Enum\r\nimport importlib\r\nimport inspect\r\nfrom pathlib import Path\r\nimport re\r\nimport sys\r\nfrom typing import TYPE_CHECKING, ClassVar, Iterator, List, Literal, TypeVar, Union, overload\r\n\r\nimport aiohttp\r\nfrom lxml import etree as ET\r\nimport m3u8\r\nfrom m3u8 import M3U8, Media, Segment, SegmentList\r\nimport requests\r\nimport requests.utils\r\n\r\nfrom isubrip.config import Config, ConfigSetting\r\nfrom isubrip.constants import PACKAGE_NAME, SCRAPER_MODULES_SUFFIX\r\nfrom isubrip.data_structures import ScrapedMediaResponse, SubtitlesData, SubtitlesType\r\nfrom isubrip.logger import logger\r\nfrom isubrip.utils import SingletonMeta, merge_dict_values, single_to_list\r\n\r\nif TYPE_CHECKING:\r\n    from isubrip.subtitle_formats.subtitles import Subtitles\r\n\r\nScraperT = TypeVar(\"ScraperT\", bound=\"Scraper\")\r\n\r\n\r\nclass Scraper(ABC, metaclass=SingletonMeta):\r\n    \"\"\"\r\n    A base class for scrapers.\r\n\r\n    Attributes:\r\n        default_user_agent (str): [Class Attribute]\r\n            Default user agent to use if no other user agent is specified when making requests.\r\n        subtitles_fix_rtl (bool): [Class Attribute] Whether to fix RTL from downloaded subtitles.\r\n        subtitles_fix_rtl_languages (list[str] | None): [Class Attribute]\r\n            A list of languages to fix RTL on. If None, a default list will be used.\r\n        subtitles_remove_duplicates (bool): [Class Attribute]\r\n            Whether to remove duplicate lines from downloaded subtitles.\r\n\r\n        id (str): [Class Attribute] ID of the scraper.\r\n        name (str): [Class Attribute] Name of the scraper.\r\n        abbreviation (str): [Class Attribute] Abbreviation of the scraper.\r\n        url_regex (str): [Class Attribute] A RegEx pattern to find URLs matching the service.\r\n        subtitles_class (type[Subtitles]): [Class Attribute] Class of the subtitles format returned by the scraper.\r\n        is_movie_scraper (bool): [Class Attribute] Whether the scraper is for movies.\r\n        is_series_scraper (bool): [Class Attribute] Whether the scraper is for series.\r\n        uses_scrapers (list[str]): [Class Attribute] A list of IDs for other scraper classes that this scraper uses.\r\n            This assures that the config data for the other scrapers is passed as well.\r\n        _session (requests.Session): A requests session to use for making requests.\r\n        config (Config): A Config object containing the scraper's configuration.\r\n    \"\"\"\r\n    default_user_agent: ClassVar[str] = requests.utils.default_user_agent()\r\n    subtitles_fix_rtl: ClassVar[bool] = False\r\n    subtitles_fix_rtl_languages: ClassVar[list | None] = [\"ar\", \"he\"]\r\n    subtitles_remove_duplicates: ClassVar[bool] = True\r\n\r\n    id: ClassVar[str]\r\n    name: ClassVar[str]\r\n    abbreviation: ClassVar[str]\r\n    url_regex: ClassVar[str | list[str]]\r\n    subtitles_class: ClassVar[type[Subtitles]]\r\n    is_movie_scraper: ClassVar[bool] = False\r\n    is_series_scraper: ClassVar[bool] = False\r\n    uses_scrapers: ClassVar[list[str]] = []\r\n\r\n    def __init__(self, config_data: dict | None = None):\r\n        \"\"\"\r\n        Initialize a Scraper object.\r\n\r\n        Args:\r\n            config_data (dict | None, optional): A dictionary containing scraper's configuration data. Defaults to None.\r\n        \"\"\"\r\n        self._session = requests.Session()\r\n        self._config_data = config_data\r\n        self.config = Config(config_data=config_data.get(self.id) if config_data else None)\r\n\r\n        self.config.add_settings([\r\n            ConfigSetting(\r\n                key=\"user-agent\",\r\n                type=str,\r\n                required=False,\r\n            )],\r\n            check_config=False)\r\n\r\n        self._session.headers.update({\"User-Agent\": self.config.get(\"user-agent\") or self.default_user_agent})\r\n\r\n    @classmethod\r\n    @overload\r\n    def match_url(cls, url: str, raise_error: Literal[True] = ...) -> re.Match:\r\n        ...\r\n\r\n    @classmethod\r\n    @overload\r\n    def match_url(cls, url: str, raise_error: Literal[False] = ...) -> re.Match | None:\r\n        ...\r\n\r\n    @classmethod\r\n    def match_url(cls, url: str, raise_error: bool = False) -> re.Match | None:\r\n        \"\"\"\r\n        Checks if a URL matches scraper's url regex.\r\n\r\n        Args:\r\n            url (str): A URL to check against the regex.\r\n            raise_error (bool, optional): Whether to raise an error instead of returning None if the URL doesn't match.\r\n\r\n        Returns:\r\n            re.Match | None: A Match object if the URL matches the regex, None otherwise (if raise_error is False).\r\n\r\n        Raises:\r\n            ValueError: If the URL doesn't match the regex and raise_error is True.\r\n        \"\"\"\r\n        if isinstance(cls.url_regex, str):\r\n            return re.fullmatch(pattern=cls.url_regex, string=url, flags=re.IGNORECASE)\r\n\r\n        # isinstance(cls.url_regex, list):\r\n        for url_regex_item in cls.url_regex:\r\n            if result := re.fullmatch(pattern=url_regex_item, string=url, flags=re.IGNORECASE):\r\n                return result\r\n\r\n        if raise_error:\r\n            raise ValueError(f\"URL '{url}' doesn't match the URL regex of {cls.name}.\")\r\n\r\n        return None\r\n\r\n    def __enter__(self):\r\n        return self\r\n\r\n    def __exit__(self, exc_type, exc_val, exc_tb):\r\n        self.close()\r\n\r\n    def close(self):\r\n        self._session.close()\r\n\r\n    @abstractmethod\r\n    def get_data(self, url: str) -> ScrapedMediaResponse:\r\n        \"\"\"\r\n        Scrape media information about the media on a URL.\r\n\r\n        Args:\r\n            url (str): A URL to get media information about.\r\n\r\n        Returns:\r\n            ScrapedMediaResponse: A ScrapedMediaResponse object containing scraped media information.\r\n        \"\"\"\r\n\r\n    @abstractmethod\r\n    def get_subtitles(self, main_playlist: str | list[str], language_filter: list[str] | None = None,\r\n                      subrip_conversion: bool = False) -> Iterator[SubtitlesData]:\r\n        \"\"\"\r\n        Find and yield subtitles data from a main_playlist.\r\n\r\n        Args:\r\n            main_playlist(str | list[str]): A URL or a list of URLs (for redundancy) of the main playlist.\r\n            language_filter (list[str] | str | None, optional):\r\n                A language or a list of languages to filter for. Defaults to None.\r\n            subrip_conversion (bool, optional): Whether to convert the subtitles to SubRip format. Defaults to False.\r\n\r\n        Yields:\r\n            SubtitlesData: A SubtitlesData object for each subtitle found\r\n                in the main playlist (matching the filters, if given).\r\n        \"\"\"\r\n\r\n\r\nclass AsyncScraper(Scraper, ABC):\r\n    \"\"\"A base class for scrapers that utilize async requests.\"\"\"\r\n    def __init__(self, config_data: dict | None = None):\r\n        super().__init__(config_data)\r\n        self.async_session = aiohttp.ClientSession()\r\n        self.async_session.headers.update(self._session.headers)\r\n\r\n    def close(self):\r\n        asyncio.get_event_loop().run_until_complete(self._async_close())\r\n        super().close()\r\n\r\n    async def _async_close(self):\r\n        await self.async_session.close()\r\n\r\n\r\nclass HLSScraper(AsyncScraper, ABC):\r\n    \"\"\"A base class for HLS (m3u8) scrapers.\"\"\"\r\n    playlist_filters_config_category = \"playlist-filters\"\r\n\r\n    class M3U8Attribute(Enum):\r\n        \"\"\"\r\n        An enum representing all possible M3U8 attributes.\r\n        Names / Keys represent M3U8 Media object attributes (should be converted to lowercase),\r\n        and values represent the name of the key for config usage.\r\n        \"\"\"\r\n        ASSOC_LANGUAGE = \"assoc-language\"\r\n        AUTOSELECT = \"autoselect\"\r\n        CHARACTERISTICS = \"characteristics\"\r\n        CHANNELS = \"channels\"\r\n        DEFAULT = \"default\"\r\n        FORCED = \"forced\"\r\n        GROUP_ID = \"group-id\"\r\n        INSTREAM_ID = \"instream-id\"\r\n        LANGUAGE = \"language\"\r\n        NAME = \"name\"\r\n        STABLE_RENDITION_ID = \"stable-rendition-id\"\r\n        TYPE = \"type\"\r\n\r\n    def __init__(self, config_data: dict | None = None):\r\n        super().__init__(config_data)\r\n\r\n        if self.config is None:\r\n            self.config = Config()\r\n\r\n        # Add M3U8 filters settings\r\n        self.config.add_settings([\r\n            ConfigSetting(\r\n                category=self.playlist_filters_config_category,\r\n                key=m3u8_attribute.value,\r\n                type=Union[str, List[str]],\r\n                required=False,\r\n            ) for m3u8_attribute in self.M3U8Attribute],\r\n            check_config=False)\r\n\r\n    def _download_segments_async(self, segments: SegmentList[Segment]) -> list[bytes]:\r\n        \"\"\"\r\n        Download M3U8 segments asynchronously.\r\n\r\n        Args:\r\n            segments (m3u8.SegmentList[m3u8.Segment]): List of segments to download.\r\n\r\n        Returns:\r\n            list[bytes]: List of downloaded segments.\r\n        \"\"\"\r\n        loop = asyncio.get_event_loop()\r\n        async_tasks = [loop.create_task(self._download_segment_async(segment.absolute_uri)) for segment in segments]\r\n        segments_bytes = loop.run_until_complete(asyncio.gather(*async_tasks))\r\n\r\n        return list(segments_bytes)\r\n\r\n    async def _download_segment_async(self, url: str) -> bytes:\r\n        \"\"\"\r\n        Download an M3U8 segment asynchronously.\r\n\r\n        Args:\r\n            url (str): URL of the segment to download.\r\n\r\n        Returns:\r\n            bytes: Downloaded segment.\r\n        \"\"\"\r\n        async with self.async_session.get(url) as response:\r\n            return await response.read()\r\n\r\n    def load_m3u8(self, url: str | list[str]) -> M3U8 | None:\r\n        \"\"\"\r\n        Load an M3U8 playlist from a URL to an M3U8 object.\r\n        Multiple URLs can be given, in which case the first one that loads successfully will be returned.\r\n        The method uses caching to avoid loading the same playlist multiple times.\r\n\r\n        Args:\r\n            url (str | list[str]): URL of the M3U8 playlist to load. Can also be a list of URLs (for redundancy).\r\n\r\n        Returns:\r\n            m3u8.M3U8: An M3U8 object representing the playlist.\r\n        \"\"\"\r\n        for _url in single_to_list(url):\r\n            try:\r\n                return m3u8.load(uri=_url, timeout=5)\r\n\r\n            except Exception as e:\r\n                logger.debug(f\"Failed to load M3U8 playlist '{_url}': {e}\")\r\n                continue\r\n\r\n        return None\r\n\r\n    @staticmethod\r\n    def detect_subtitles_type(subtitles_media: Media) -> SubtitlesType | None:\r\n        \"\"\"\r\n        Detect the subtitles type (Closed Captions, Forced, etc.) from an M3U8 Media object.\r\n\r\n        Args:\r\n            subtitles_media (m3u8.Media): Subtitles Media object to detect the type of.\r\n\r\n        Returns:\r\n            SubtitlesType | None: The type of the subtitles, None for regular subtitles.\r\n        \"\"\"\r\n        if subtitles_media.forced == \"YES\":\r\n            return SubtitlesType.FORCED\r\n\r\n        if subtitles_media.characteristics is not None and \"public.accessibility\" in subtitles_media.characteristics:\r\n            return SubtitlesType.CC\r\n\r\n        return None\r\n\r\n    def get_media_playlists(self, main_playlist: M3U8,\r\n                            playlist_filters: dict[str, str | list[str]] | None = None,\r\n                            include_default_filters: bool = True) -> list[Media]:\r\n        \"\"\"\r\n        Find and yield playlists of media within an M3U8 main_playlist using optional filters.\r\n\r\n        Args:\r\n            main_playlist (m3u8.M3U8): An M3U8 object of the main main_playlist.\r\n            playlist_filters (dict[str, str | list[str], optional):\r\n                A dictionary of filters to use when searching for subtitles.\r\n                Will be added to filters set by the config (unless `include_default_filters` is set to false).\r\n                Defaults to None.\r\n            include_default_filters (bool, optional): Whether to include the default filters set by the config or not.\r\n                Defaults to True.\r\n\r\n        Returns:\r\n            list[Media]: A list of  matching Media objects.\r\n        \"\"\"\r\n        results = []\r\n        default_filters: dict | None = self.config.get(HLSScraper.playlist_filters_config_category)\r\n\r\n        if include_default_filters and default_filters:\r\n            if not playlist_filters:\r\n                playlist_filters = default_filters\r\n\r\n            else:\r\n                playlist_filters = merge_dict_values(default_filters, playlist_filters)\r\n\r\n        for media in main_playlist.media:\r\n            if not playlist_filters:\r\n                results.append(media)\r\n                continue\r\n\r\n            is_valid = True\r\n\r\n            for filter_name, filter_value in playlist_filters.items():\r\n                try:\r\n                    filter_name_enum = HLSScraper.M3U8Attribute(filter_name)\r\n                    attribute_value = getattr(media, filter_name_enum.name.lower(), None)\r\n\r\n                    if (attribute_value is None) or (\r\n                            isinstance(filter_value, list) and\r\n                            attribute_value.casefold() not in (x.casefold() for x in filter_value)\r\n                    ) or (\r\n                            isinstance(filter_value, str) and filter_value.casefold() != attribute_value.casefold()\r\n                    ):\r\n                        is_valid = False\r\n                        break\r\n\r\n                except Exception:\r\n                    is_valid = False\r\n\r\n            if is_valid:\r\n                results.append(media)\r\n\r\n        return results\r\n\r\n\r\nclass ScraperFactory(metaclass=SingletonMeta):\r\n    def __init__(self):\r\n        self._scraper_classes_cache: list[type[Scraper]] | None = None\r\n        self._scraper_instances_cache: dict[type[Scraper], Scraper] = {}\r\n        self._currently_initializing: list[type[Scraper]] = []  # Used to prevent infinite recursion\r\n\r\n    def get_initialized_scrapers(self) -> list[Scraper]:\r\n        \"\"\"\r\n        Get a list of all previously initialized scrapers.\r\n\r\n        Returns:\r\n            list[Scraper]: A list of initialized scrapers.\r\n        \"\"\"\r\n        return list(self._scraper_instances_cache.values())\r\n\r\n    def get_scraper_classes(self) -> list[type[Scraper]]:\r\n        \"\"\"\r\n        Find all scraper classes in the scrapers directory.\r\n\r\n        Returns:\r\n            list[Scraper]: A Scraper subclass.\r\n        \"\"\"\r\n        if self._scraper_classes_cache is not None:\r\n            return self._scraper_classes_cache\r\n\r\n        self._scraper_classes_cache = []\r\n        scraper_modules_paths = Path(__file__).parent.glob(f\"*{SCRAPER_MODULES_SUFFIX}.py\")\r\n\r\n        for scraper_module_path in scraper_modules_paths:\r\n            sys.path.append(str(scraper_module_path))\r\n\r\n            module = importlib.import_module(f\"{PACKAGE_NAME}.scrapers.{scraper_module_path.stem}\")\r\n\r\n            # Find all 'Scraper' subclasses\r\n            for _, obj in inspect.getmembers(module,\r\n                                             predicate=lambda x: inspect.isclass(x) and issubclass(x, Scraper)):\r\n                # Skip object if it's an abstract or imported from another module\r\n                if not inspect.isabstract(obj) and obj.__module__ == module.__name__:\r\n                    self._scraper_classes_cache.append(obj)\r\n\r\n        return self._scraper_classes_cache\r\n\r\n    def _get_scraper_instance(self, scraper_class: type[ScraperT],\r\n                              scrapers_config_data: dict | None = None) -> ScraperT:\r\n        \"\"\"\r\n        Initialize and return a scraper instance.\r\n\r\n        Args:\r\n            scraper_class (type[ScraperT]): A scraper class to initialize.\r\n            scrapers_config_data (dict, optional): A dictionary containing scrapers config data to use\r\n                when creating a new scraper. Defaults to None.\r\n\r\n        Returns:\r\n            Scraper: An instance of the given scraper class.\r\n        \"\"\"\r\n        logger.debug(f\"Initializing '{scraper_class.name}' scraper...\")\r\n\r\n        if scraper_class not in self._scraper_instances_cache:\r\n            logger.debug(f\"'{scraper_class.name}' scraper not found in cache, creating a new instance...\")\r\n\r\n            if scraper_class in self._currently_initializing:\r\n                raise ScraperError(f\"'{scraper_class.name}' scraper is already being initialized.\\n\"\r\n                                       f\"Make sure there are no circular dependencies between scrapers.\")\r\n\r\n            self._currently_initializing.append(scraper_class)\r\n\r\n            # Set config data for the scraper and its dependencies, if any\r\n            if not scrapers_config_data:\r\n                config_data = None\r\n\r\n            else:\r\n                required_scrapers_ids = [scraper_class.id, *scraper_class.uses_scrapers]\r\n                config_data = \\\r\n                    {scraper_id: scrapers_config_data[scraper_id] for scraper_id in required_scrapers_ids\r\n                     if scrapers_config_data.get(scraper_id)}\r\n\r\n            self._scraper_instances_cache[scraper_class] = scraper_class(config_data=config_data)\r\n            self._currently_initializing.remove(scraper_class)\r\n\r\n        else:\r\n            logger.debug(f\"Cached '{scraper_class.name}' scraper instance found and will be used.\")\r\n\r\n        return self._scraper_instances_cache[scraper_class]  # type: ignore[return-value]\r\n\r\n    @overload\r\n    def get_scraper_instance(self, scraper_class: type[ScraperT], scraper_id: str | None = ...,\r\n                             url: str | None = ..., config_data: dict | None = ...,\r\n                             raise_error: Literal[True] = ...) -> ScraperT:\r\n        ...\r\n\r\n    @overload\r\n    def get_scraper_instance(self, scraper_class: type[ScraperT], scraper_id: str | None = ...,\r\n                             url: str | None = ..., config_data: dict | None = ...,\r\n                             raise_error: Literal[False] = ...) -> ScraperT | None:\r\n        ...\r\n\r\n    @overload\r\n    def get_scraper_instance(self, scraper_class: None = ..., scraper_id: str | None = ...,\r\n                             url: str | None = ..., config_data: dict | None = ...,\r\n                             raise_error: Literal[True] = ...) -> Scraper:\r\n        ...\r\n\r\n    @overload\r\n    def get_scraper_instance(self, scraper_class: None = ..., scraper_id: str | None = ...,\r\n                             url: str | None = ..., config_data: dict | None = ...,\r\n                             raise_error: Literal[False] = ...) -> Scraper | None:\r\n        ...\r\n\r\n    def get_scraper_instance(self, scraper_class: type[Scraper] | None = None, scraper_id: str | None = None,\r\n                             url: str | None = None, config_data: dict | None = None,\r\n                             raise_error: bool = True) -> Scraper | None:\r\n        \"\"\"\r\n        Find, initialize and return a scraper that matches the given URL or ID.\r\n\r\n        Args:\r\n            scraper_class (type[ScraperT] | None, optional): A scraper class to initialize. Defaults to None.\r\n            scraper_id (str | None, optional): ID of a scraper to initialize. Defaults to None.\r\n            url (str | None, optional): A URL to match a scraper for to initialize. Defaults to None.\r\n            config_data (dict, optional): A dictionary containing scrapers config data to use\r\n                when creating a new scraper. Defaults to None.\r\n            raise_error (bool, optional): Whether to raise an error if no scraper was found. Defaults to False.\r\n\r\n        Returns:\r\n            ScraperT | Scraper | None: An instance of a scraper that matches the given URL or ID,\r\n                None otherwise (if raise_error is False).\r\n\r\n        Raises:\r\n            ValueError: If no scraper was found and raise_error is True.\r\n        \"\"\"\r\n        if scraper_class:\r\n            return self._get_scraper_instance(scraper_class=scraper_class,\r\n                                              scrapers_config_data=config_data)\r\n\r\n        if not (scraper_id or url):\r\n            raise ValueError(\"At least one of: 'scraper_class', 'scraper_id', or 'url' must be provided.\")\r\n\r\n        if scraper_id:\r\n            logger.debug(f\"Searching for a scraper object with ID '{scraper_id}'...\")\r\n            for scraper in self.get_scraper_classes():\r\n                if scraper.id == scraper_id:\r\n                    return self._get_scraper_instance(scraper_class=scraper, scrapers_config_data=config_data)\r\n\r\n        elif url:\r\n            logger.debug(f\"Searching for a scraper object that matches URL '{url}'...\")\r\n            for scraper in self.get_scraper_classes():\r\n                if scraper.match_url(url) is not None:\r\n                    return self._get_scraper_instance(scraper_class=scraper, scrapers_config_data=config_data)\r\n\r\n        if raise_error:\r\n            raise ValueError(f\"No matching scraper was found for URL '{url}'\")\r\n\r\n        logger.debug(\"No matching scraper was found.\")\r\n        return None\r\n\r\n\r\nclass ScraperError(Exception):\r\n    pass\r\n\r\n\r\nclass PlaylistLoadError(ScraperError):\r\n    pass\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/scrapers/scraper.py b/isubrip/scrapers/scraper.py
--- a/isubrip/scrapers/scraper.py	(revision 1a3bdb18864b8eb25cb7264b64c09b6d18a63d03)
+++ b/isubrip/scrapers/scraper.py	(date 1701116973414)
@@ -348,6 +348,35 @@
         return results
 
 
+class DASHScraper(Scraper, ABC):
+    """A base class for DASH (mpd) scrapers."""
+    def __init__(self, config_data: dict | None = None):
+        super().__init__(config_data)
+
+    def load_mpd(self, url: str, headers: dict | None = None) -> ET.Element | None:
+        """
+        Load an MPD file from a URL to a string.
+        The method uses caching to avoid loading the same MPD file multiple times.
+
+        Args:
+        url (str): URL of the MPD playlist to load.
+        headers (dict | None, optional): A dictionary of headers to use when making the request.
+            Defaults to None (results in using session's configured headers).
+        """
+        _headers = headers or self._session.headers
+
+        try:
+            response = self._session.get(url=url, headers=_headers)
+            response.raise_for_status()
+
+            return ET.fromstring(response.text.encode("utf-8"))
+
+        except Exception as e:
+            logger.debug(f"Failed to load MPD playlist '{url}': {e}")
+
+        return None
+
+
 class ScraperFactory(metaclass=SingletonMeta):
     def __init__(self):
         self._scraper_classes_cache: list[type[Scraper]] | None = None
Index: isubrip/scrapers/disneyplus_hotstar_scraper.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/scrapers/disneyplus_hotstar_scraper.py b/isubrip/scrapers/disneyplus_hotstar_scraper.py
new file mode 100644
--- /dev/null	(date 1701116973412)
+++ b/isubrip/scrapers/disneyplus_hotstar_scraper.py	(date 1701116973412)
@@ -0,0 +1,314 @@
+from __future__ import annotations
+
+import datetime as dt
+import hashlib
+import hmac
+from time import time
+from typing import TYPE_CHECKING, Iterator
+
+from lxml import etree as ET
+
+from isubrip.config import Config, ConfigSetting
+from isubrip.data_structures import Episode, Movie, ScrapedMediaResponse, Season, Series, SubtitlesData
+from isubrip.scrapers.scraper import DASHScraper, PlaylistLoadError, ScraperError
+from isubrip.subtitle_formats.webvtt import WebVTTSubtitles
+from isubrip.utils import (
+    extract_host_from_url,
+    generate_random_hex_string,
+    generate_url_params,
+    parse_duration,
+    parse_season_and_episode_tag,
+    parse_url_params,
+    raise_for_status,
+    single_to_list,
+)
+
+if TYPE_CHECKING:
+    from requests import Response
+
+
+class DisneyPlusHotstarScraper(DASHScraper):
+    """An Apple TV scraper."""
+    id = "dsnphs"
+    name = "Disney+ (Hotstar)"
+    abbreviation = "DSNP"
+    url_regex = r"(?P<base_url>https?://(?:www\.)?apps\.disneyplus\.com/(?P<slug>(?:(?P<country_code>[a-z]{2})/)?(?:(?P<media_type>movies|shows)/)?(?:(?P<media_name>[\w\-%]+)/)?(?P<media_id>(?:\d{4,10}))))(?:\?(?P<url_params>(?:).*))?"  # noqa: E501
+    # TODO: Update regex - slug can have episode data. Ex: il/shows/mshpkht-sympsvn/1260023404/some-enchanted-evening/1260023628
+    subtitles_class = WebVTTSubtitles
+    is_movie_scraper = True
+    is_series_scraper = True
+
+    _AKAMAI_ENCRYPTION_KEY = b'\x05\xfc\x1a\x01\xca\xc9\x4b\xc4\x12\xfc\x53\x12\x07\x75\xf9\xee'
+
+    _api_url = "https://www.apps.disneyplus.com/api/internal/bff"
+    _player_params = {
+        "client_capabilities":
+            {
+                "audio_channel": ["stereo"],
+                "container": ["fmp4", "ts"],
+                "dvr": ["short"],
+                "dynamic_range": ["sdr"],
+                "encryption": ["widevine", "plain"],
+                "ladder": ["tv", "phone"],
+                "package": ["dash", "hls"],
+                "resolution": ["sd", "hd", "fhd"],
+                "video_codec": ["h264"],
+            },
+        "drm_parameters":
+            {
+                "hdcp_version": ["HDCP_V2_2"],
+                "widevine_security_level": ["SW_SECURE_DECODE"],
+                "playready_security_level": [],
+            },
+    }
+
+    def __init__(self, config_data: dict | None = None):
+        super().__init__(config_data)
+
+        if self.config is None:
+            self.config = Config()
+
+        # Add "token" setting to config
+        self.config.add_settings(
+            ConfigSetting(
+                key="token",
+                type=str,
+                required=True,
+            ),
+            check_config=True)
+
+        self._session.headers.update({
+            "Accept": "application/json",  # TODO: Remove?
+            "X-Hs-Usertoken": self.config["token"],
+            "X-Hs-Platform": "web",
+            "X-Hs-Client": "platform:web;app_version:23.05.29.0;browser:Chrome;schema_version:0.0.854",
+        })
+
+        self._session.proxies = {
+            "http": "127.0.0.1:8085",
+            "https": "127.0.0.1:8085",
+        }
+        self._session.verify = False
+        # Disable SSL verification warning
+        import urllib3
+        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
+
+    def get(self, url: str,
+            additional_headers: dict | None = None,
+            include_hotstarauth: bool = False, **kwargs) -> Response:
+        response = self._session.get(url=url,
+                                     headers=self._generate_headers(url=url,
+                                                                    additional_headers=additional_headers,
+                                                                    include_hotstarauth=include_hotstarauth),
+                                     **kwargs)
+        raise_for_status(response)
+        return response
+
+    def _generate_headers(self, url: str, additional_headers: dict | None = None,
+                          include_hotstarauth: bool = False) -> dict:
+        """
+        Generate headers for a Disney+ Hotstar's API request.
+
+        Args:
+            url (str): URL to generate headers for.
+            additional_headers (dict, optional): Additional headers to add to the generated headers. Defaults to None.
+            include_hotstarauth (bool, optional): Whether to include the `hotstarauth` header. Defaults to False.
+
+        Returns:
+            dict: Generated headers for the request.
+        """
+        request_id = self._generate_request_id()
+
+        headers = {
+            **self._session.headers,
+            "Host": extract_host_from_url(url),
+            "X-Request-Id": request_id,
+            "X-Hs-Request-Id": request_id,
+            "Origin": "https://www.apps.disneyplus.com",
+            "Referer": "https://www.apps.disneyplus.com/",
+        }
+
+        if additional_headers:
+            headers.update(additional_headers)
+
+        if include_hotstarauth:
+            headers["hotstarauth"] = self._generate_hotstarauth_token()
+
+        return headers
+
+    def _generate_hotstarauth_token(self) -> str:
+        st = int(time())  # TODO: Check if possible to get time from server
+        exp = st + 6000
+        hotstarauth = f"st={st}~exp={exp}~acl=/*"
+        hotstarauth += "~hmac=" + hmac.new(key=self._AKAMAI_ENCRYPTION_KEY,
+                                           msg=hotstarauth.encode(),
+                                           digestmod=hashlib.sha256).hexdigest()
+
+        return hotstarauth
+
+    @staticmethod
+    def _generate_request_id() -> str:
+        request_id = generate_random_hex_string(8) + '-'
+
+        for _ in range(3):
+            request_id += generate_random_hex_string(4) + '-'
+
+        return request_id + generate_random_hex_string(12)
+
+    def _get_api_data(self, endpoint: str) -> dict:
+        """
+        Retrieve data from the Disney+ Hotstar's API.
+
+        Args:
+            endpoint (str): API endpoint.
+
+        Returns:
+            dict: Data returned by the API for the given endpoint.
+        """
+        response = self.get(f"{self._api_url}/{endpoint}")
+        raise_for_status(response)
+        return response.json()
+
+    def _get_episode_playlists(self, episode_slug: str) -> list[str]:
+        player_params = generate_url_params(data=self._player_params, remove_dict_spaces=True)
+        api_data = self._get_api_data(endpoint=f"v2/slugs/{episode_slug}?{player_params}")
+
+        player_config = (
+            api_data["success"]["page"]["spaces"]["player"]["widget_wrappers"][0]["widget"]["data"]["player_config"]
+        )
+
+        return_data = [
+            player_config.get("media_asset_v2", {}).get("primary", {}).get("content_url"),
+            player_config.get("media_asset_v2", {}).get("fallback", {}).get("content_url"),
+        ]
+
+        return [playlist_url for playlist_url in return_data if playlist_url]
+
+    def _get_season_data(self, show_id: str, season_id: str) -> dict[int, dict]:
+        endpoint = f"v2/pages/841/spaces/803/widgets/1196/widgets/168?content_id={show_id}&season_id={season_id}"
+        paginated_data = []
+
+        # Get all paginated episodes data for the season
+        while endpoint:  # TODO: Increase page size
+            api_data = self._get_api_data(endpoint)
+            episodes_paginated_data = api_data["success"]["widget_wrapper"]["widget"]["data"]
+            paginated_data.extend(episodes_paginated_data["items"])
+            endpoint = episodes_paginated_data.get("next_tray_url")
+
+        api_episodes_data = [episode_data["playable_content"]["data"] for episode_data in paginated_data]
+        result_data: dict[int, dict] = {}
+
+        for episode_data in api_episodes_data:
+            page_slug = episode_data["actions"]["on_click"][1]["page_navigation"]["page_slug"].split("?")[0]
+            episode_data["playlists"] = self._get_episode_playlists(episode_slug=page_slug.lstrip("/"))
+            episode_number = parse_season_and_episode_tag(episode_data["tags"][0]["value"])[1]
+            # Remove unnecessary data
+            if 'actions' in episode_data:
+                episode_data.pop('actions')
+
+            if 'download_options' in episode_data:
+                episode_data.pop('download_options')
+
+            result_data[episode_number] = episode_data
+
+        return result_data
+
+    def get_series_data(self, show_slug: str) -> ScrapedMediaResponse[Series]:
+        api_data = self._get_api_data(endpoint="v2/slugs/" + show_slug)
+        media_data = api_data["success"]["page"]["spaces"]["hero"]["widget_wrappers"][0]["widget"]["data"]
+        seasons_data = api_data["success"]["page"]["spaces"]["tray"]["widget_wrappers"][0]["widget"]["data"] \
+            ["category_picker"]["data"]["tabs"]
+
+        series_name = media_data["content_info"]["title"]
+        series_id = media_data["content_actions_row"]["content_action_buttons"][0]["watchlist_content_action_button"] \
+            ["info"]["content_id"]
+        series_seasons: list[Season] = []
+        result_seasons_data: dict[int, dict[int, dict]] = {}
+
+        for season_data in [season_data["tab"]["data"] for season_data in seasons_data]:
+            url_params = parse_url_params(season_data["tray_widget_url"])  # TODO: Use the URL instead of parsing it and recreating it
+            season_episodes_data = self._get_season_data(show_id=url_params["content_id"],
+                                                         season_id=url_params["season_id"])
+            season_number = int(season_data["title"].split(" ")[1])
+            result_seasons_data[season_number] = season_episodes_data
+
+            season_episodes: list[Episode] = []
+
+            for episode_number, episode_data in season_episodes_data.items():
+                season_episodes.append(
+                    Episode(
+                        id=episode_data["cw_info"]["content_id"],
+                        series_name=series_name,
+                        season_number=season_number,
+                        episode_number=episode_number,
+                        episode_name=episode_data["title"],
+                        episode_release_date=dt.datetime.strptime(episode_data["tags"][1]["value"], "%d %b %Y"),
+                        episode_duration=parse_duration(episode_data["tags"][2]["value"]),
+                        playlist=episode_data["playlists"].copy(),
+                    ),
+                )
+
+            series_seasons.append(
+                Season(
+                    id=series_id,
+                    series_name=series_name,
+                    season_number=season_number,
+                    release_date=None,
+                    episodes=season_episodes,
+                ))
+
+        series_data = Series(
+            id=series_id,
+            series_name=series_name,
+            seasons=series_seasons,
+        )
+
+        return ScrapedMediaResponse(
+            media_data=series_data,
+            metadata_scraper=self.id,
+            playlist_scraper=self.id,
+            original_data={
+                "series_data": api_data,
+                "seasons_data": result_seasons_data,
+            },
+        )
+
+    def get_movie_data(self, movie_id: str) -> ScrapedMediaResponse[Movie]:
+        pass
+
+    def get_data(self, url: str) -> ScrapedMediaResponse[Movie] | ScrapedMediaResponse[Series]:
+        regex_match = self.match_url(url, raise_error=True)
+        url_data = regex_match.groupdict()
+
+        if not all(url_data.get(key) for key in ("country_code", "media_type", "media_name", "media_id")):
+            raise ScraperError(f"Complete slug URL required for scraping from '{self.name}'.")
+
+        if url_data["media_type"] == "movies":
+            return self.get_movie_data(url_data["media_id"])
+
+        elif url_data["media_type"] == "shows":
+            return self.get_series_data(url_data["slug"])
+
+        else:
+            raise ScraperError(f"Unexpected media type URL '{url_data['media_type']}' for '{self.name}'.")
+
+    def get_subtitles(self, main_playlist: str | list[str], language_filter: list[str] | str | None = None,
+                      subrip_conversion: bool = False) -> Iterator[SubtitlesData]:
+        playlist_data: ET.Element | None = None
+        for url in single_to_list(main_playlist):
+            if playlist_data := self.load_mpd(url=url,
+                                              headers=self._generate_headers(
+                                                  url=url,
+                                                  additional_headers={"Accept": "application/dash+xml"},
+                                                  include_hotstarauth=True,
+                                              )):
+                break
+
+        if playlist_data:
+            pass
+
+        else:
+            raise PlaylistLoadError("Could not load MPD playlist.")
+
+        ET.tostring(playlist_data, encoding="unicode")
+        raise NotImplementedError
