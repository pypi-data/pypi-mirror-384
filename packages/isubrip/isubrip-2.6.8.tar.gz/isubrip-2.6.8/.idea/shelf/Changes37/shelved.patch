Index: isubrip/__main__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nimport atexit\r\nimport shutil\r\nimport sys\r\nfrom pathlib import Path\r\n\r\nimport requests\r\nfrom requests.utils import default_user_agent\r\n\r\nfrom isubrip.config import Config, ConfigException\r\nfrom isubrip.constants import ARCHIVE_FORMAT, DATA_FOLDER_PATH, DEFAULT_CONFIG_PATH, BASE_CONFIG_SETTINGS, \\\r\n    PACKAGE_NAME, TEMP_FOLDER_PATH, USER_CONFIG_FILE\r\nfrom isubrip.data_structures import EpisodeData,  MediaData, MovieData, SubtitlesDownloadResults, SubtitlesData\r\nfrom isubrip.scrapers.scraper import Scraper, ScraperFactory\r\nfrom isubrip.utils import download_subtitles_to_file, generate_non_conflicting_path, generate_release_name, \\\r\n    single_to_list\r\n\r\n\r\ndef main():\r\n    scraper_factory = None\r\n\r\n    try:\r\n        # Assure at least one argument was passed\r\n        if len(sys.argv) < 2:\r\n            print_usage()\r\n            exit(1)\r\n\r\n        config = generate_config()\r\n        update_settings(config)\r\n\r\n        if config.general.get(\"check-for-updates\", True):\r\n            check_for_updates()\r\n\r\n        scraper_factory = ScraperFactory()\r\n\r\n        multiple_urls = len(sys.argv) > 2\r\n\r\n        for idx, url in enumerate(sys.argv[1:]):\r\n            if idx > 0:\r\n                print(\"\\n--------------------------------------------------\\n\")  # Print between different movies\r\n\r\n            print(f\"Scraping {url}\")\r\n\r\n            try:\r\n                scraper = scraper_factory.get_scraper_instance(url=url, config_data=config.data.get(\"scrapers\"))\r\n                atexit.register(scraper.close)\r\n                scraper.config.check()\r\n\r\n                media_data: MovieData = scraper.get_data(url=url)\r\n                media_items: list[MovieData] = single_to_list(media_data)\r\n\r\n                print(f\"Found movie: {media_items[0].title} ({media_items[0].release_date.year})\")\r\n\r\n                if not media_data:\r\n                    print(f\"Error: No supported media data was found for {url}.\")\r\n                    continue\r\n\r\n                download_media_subtitles_args = {\r\n                    \"download_path\": Path(config.downloads[\"folder\"]),\r\n                    \"language_filter\": config.downloads.get(\"languages\"),\r\n                    \"convert_to_srt\": config.subtitles.get(\"convert-to-srt\", False),\r\n                    \"overwrite_existing\": config.downloads.get(\"overwrite-existing\", False),\r\n                    \"zip_files\": config.downloads.get(\"zip\", False),\r\n                }\r\n\r\n                multiple_media_items = len(media_items) > 1\r\n                if multiple_media_items:\r\n                    print(f\"{len(media_items)} media items were found.\")\r\n\r\n                for media_item in media_items:\r\n                    media_id = media_item.id or media_item.alt_id or media_item.title\r\n\r\n                    try:\r\n                        if multiple_media_items:\r\n                            print(f\"{media_id}:\")\r\n\r\n                        if not media_item.playlist:\r\n                            if media_data.preorder_availability_date:\r\n                                message = f\"{media_item.title} is currently unavailable on \" \\\r\n                                          f\"{media_item.scraper.name}.\\n\" \\\r\n                                          f\"Release date ({media_item.scraper.name}): \" \\\r\n                                          f\"{media_data.preorder_availability_date}.\"\r\n                            else:\r\n                                message = f\"No valid playlist was found for {media_item.title} on {scraper.name}.\"\r\n\r\n                            print(message)\r\n                            continue\r\n\r\n                        results = download_subtitles(media_data=media_item,\r\n                                                     **download_media_subtitles_args)\r\n\r\n                        success_count = len(results.successful_subtitles)\r\n                        failed_count = len(results.failed_subtitles)\r\n\r\n                        if success_count:\r\n                            print(f\"\\n{success_count}/{success_count + failed_count} matching subtitles \"\r\n                                  f\"have been successfully downloaded.\")\r\n\r\n                        elif failed_count:\r\n                            print(f\"\\n{failed_count} subtitles were matched, but failed to download.\")\r\n\r\n                        else:\r\n                            print(\"\\nNo matching subtitles were found.\")\r\n\r\n                    except Exception as e:\r\n                        if multiple_media_items:\r\n                            print(f\"Error: Encountered an error while scraping playlist for {media_id}: {e}\")\r\n                            continue\r\n\r\n                        else:\r\n                            raise e\r\n\r\n            except Exception as e:\r\n                if multiple_urls:\r\n                    print(f\"Error: Encountered an error while scraping {url}: {e}\")\r\n                    continue\r\n\r\n                else:\r\n                    raise e\r\n\r\n    except Exception as e:\r\n        print(f\"Error: {e}\")\r\n        exit(1)\r\n\r\n    finally:\r\n        # Note: This will only close scrapers that were initialized using the ScraperFactory.\r\n        if scraper_factory:\r\n            for scraper in scraper_factory.get_initialized_scrapers():\r\n                scraper.close()\r\n\r\n\r\ndef check_for_updates() -> None:\r\n    \"\"\"Check and print if a newer version of the package is available.\"\"\"\r\n    api_url = f\"https://pypi.org/pypi/{PACKAGE_NAME}/json\"\r\n\r\n    try:\r\n        current_version = sys.modules[PACKAGE_NAME].__version__\r\n\r\n        response = requests.get(\r\n            url=api_url,\r\n            headers={\"Accept\": \"application/json\"},\r\n            timeout=10,\r\n        )\r\n        response.raise_for_status()\r\n        response_data = response.json()\r\n\r\n        if latest_version := response_data[\"info\"][\"version\"]:\r\n            if latest_version != current_version:\r\n                print(f\"Note: You are currently using version {current_version} of {PACKAGE_NAME}, \"\r\n                      f\"however version {latest_version} is available.\",\r\n                      f\"\\nConsider upgrading by running \\\"python3 -m pip install --upgrade {PACKAGE_NAME}\\\"\\n\")\r\n\r\n    except Exception:\r\n        return\r\n\r\n\r\ndef download_subtitles(media_data: MovieData | EpisodeData, download_path: Path,\r\n                       language_filter: list[str] | None = None, convert_to_srt: bool = False,\r\n                       overwrite_existing: bool = True, zip_files: bool = False) -> SubtitlesDownloadResults:\r\n    \"\"\"\r\n    Download subtitles for the given media data.\r\n\r\n    Args:\r\n        media_data (MovieData | EpisodeData): A MovieData or an EpisodeData object of the media.\r\n        download_path (Path): Path to a folder where the subtitles will be downloaded to.\r\n        language_filter (list[str] | None): List of specific languages to download subtitles for.\r\n            None for all languages (no filter). Defaults to None.\r\n        convert_to_srt (bool, optional): Whether to convert the subtitles to SRT format. Defaults to False.\r\n        overwrite_existing (bool, optional): Whether to overwrite existing subtitles. Defaults to True.\r\n        zip_files (bool, optional): Whether to unite the subtitles into a single zip file\r\n            (only if there are multiple subtitles).\r\n\r\n    Returns:\r\n        Path: Path to the parent folder of the downloaded subtitles files / zip file.\r\n    \"\"\"\r\n    temp_download_path = generate_media_path(base_path=TEMP_FOLDER_PATH, media_data=media_data)\r\n    atexit.register(shutil.rmtree, TEMP_FOLDER_PATH, ignore_errors=False, onerror=None)\r\n\r\n    if not media_data.playlist:\r\n        raise ValueError(\"No playlist data was found for the given media data.\")\r\n\r\n    successful_downloads: list[SubtitlesData] = []\r\n    failed_downloads: list[SubtitlesData] = []\r\n    temp_downloads: list[Path] = []\r\n\r\n    playlist = single_to_list(media_data.playlist)[0]\r\n\r\n    for subtitles_data in media_data.scraper.get_subtitles(main_playlist=playlist.data,\r\n                                                           language_filter=language_filter,\r\n                                                           subrip_conversion=convert_to_srt):\r\n        language_data = f\"{subtitles_data.language_name} ({subtitles_data.language_code})\"\r\n\r\n        try:\r\n            temp_downloads.append(download_subtitles_to_file(\r\n                media_data=media_data,\r\n                subtitles_data=subtitles_data,\r\n                output_path=temp_download_path,\r\n                overwrite=overwrite_existing,\r\n            ))\r\n\r\n            print(f\"{language_data} subtitles were successfully downloaded.\")\r\n            successful_downloads.append(subtitles_data)\r\n\r\n        except Exception as e:\r\n            print(f\"Error: Failed to download '{language_data}' subtitles: {e}\")\r\n            failed_downloads.append(subtitles_data)\r\n            continue\r\n\r\n    if not zip_files or len(temp_downloads) == 1:\r\n        for file_path in temp_downloads:\r\n            if overwrite_existing:\r\n                new_path = download_path / file_path.name\r\n\r\n            else:\r\n                new_path = generate_non_conflicting_path(download_path / file_path.name)\r\n\r\n            # str conversion needed only for Python <= 3.8 - https://github.com/python/cpython/issues/76870\r\n            shutil.move(src=str(file_path), dst=new_path)\r\n\r\n    elif len(temp_downloads) > 0:\r\n        archive_path = Path(shutil.make_archive(\r\n            base_name=str(temp_download_path.parent / temp_download_path.name),\r\n            format=ARCHIVE_FORMAT,\r\n            root_dir=temp_download_path,\r\n        ))\r\n\r\n        file_name = generate_media_folder_name(media_data=media_data) + f\".{ARCHIVE_FORMAT}\"\r\n\r\n        if overwrite_existing:\r\n            destination_path = download_path / file_name\r\n\r\n        else:\r\n            destination_path = generate_non_conflicting_path(download_path / file_name)\r\n\r\n        shutil.move(src=str(archive_path), dst=destination_path)\r\n\r\n    shutil.rmtree(temp_download_path)\r\n    atexit.unregister(shutil.rmtree)\r\n\r\n    return SubtitlesDownloadResults(\r\n        media_data=media_data,\r\n        successful_subtitles=successful_downloads,\r\n        failed_subtitles=failed_downloads,\r\n        is_zip=zip_files,\r\n    )\r\n\r\n\r\ndef generate_config() -> Config:\r\n    \"\"\"\r\n    Generate a config object using config files, and validate it.\r\n\r\n    Returns:\r\n        Config: A config object.\r\n\r\n    Raises:\r\n        ConfigException: If there is a general config error.\r\n        MissingConfigValue: If a required config value is missing.\r\n        InvalidConfigValue: If a config value is invalid.\r\n    \"\"\"\r\n    config_files = [DEFAULT_CONFIG_PATH]\r\n\r\n    if not DEFAULT_CONFIG_PATH.is_file():\r\n        raise ConfigException(\"Default config file could not be found.\")\r\n\r\n    # If data folder doesn't exist, create it\r\n    if not DATA_FOLDER_PATH.is_dir():\r\n        DATA_FOLDER_PATH.mkdir(parents=True, exist_ok=True)\r\n\r\n    else:\r\n        # If a user config file exists, add it to config_files\r\n        if USER_CONFIG_FILE.is_file():\r\n            config_files.append(USER_CONFIG_FILE)\r\n\r\n    config = Config(config_settings=BASE_CONFIG_SETTINGS)\r\n\r\n    for file_path in config_files:\r\n        with open(file_path, 'r') as data:\r\n            config.loads(config_data=data.read(), check_config=True)\r\n\r\n    config.check()\r\n    return config\r\n\r\n\r\ndef generate_media_folder_name(media_data: MediaData) -> str:\r\n    \"\"\"\r\n    Generate a folder name for media data.\r\n\r\n    Args:\r\n        media_data (MediaData): A media data object.\r\n\r\n    Returns:\r\n        str: A folder name for the media data.\r\n    \"\"\"\r\n    return generate_release_name(\r\n        title=media_data.title,\r\n        release_year=media_data.release_date.year,\r\n        media_source=media_data.scraper.abbreviation,\r\n    )\r\n\r\n\r\ndef generate_media_path(base_path: Path, media_data: MediaData) -> Path:\r\n    \"\"\"\r\n    Generate a temporary folder for downloading media data.\r\n\r\n    Args:\r\n        base_path (Path): A base path to generate the folder in.\r\n        media_data (MediaData): A media data object.\r\n\r\n    Returns:\r\n        Path: A path to the temporary folder.\r\n    \"\"\"\r\n    temp_folder_name = generate_media_folder_name(media_data=media_data)\r\n    path = generate_non_conflicting_path(base_path / temp_folder_name, has_extension=False)\r\n    path.mkdir(parents=True, exist_ok=True)\r\n\r\n    return path\r\n\r\n\r\ndef update_settings(config: Config) -> None:\r\n    \"\"\"\r\n    Update settings according to config.\r\n\r\n    Args:\r\n        config (Config): An instance of a config to set settings according to.\r\n    \"\"\"\r\n    Scraper.subtitles_fix_rtl = config.subtitles[\"fix-rtl\"]\r\n    Scraper.subtitles_fix_rtl_languages = config.subtitles.get(\"rtl-languages\")\r\n    Scraper.subtitles_remove_duplicates = config.subtitles[\"remove-duplicates\"]\r\n    Scraper.default_user_agent = config.scrapers.get(\"user-agent\", default_user_agent())\r\n\r\n\r\ndef print_usage() -> None:\r\n    \"\"\"Print usage information.\"\"\"\r\n    print(f\"Usage: {PACKAGE_NAME} <iTunes movie URL> [iTunes movie URL...]\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/__main__.py b/isubrip/__main__.py
--- a/isubrip/__main__.py	(revision 4e9b49629e5b5efd853d0fb7467e661145c9afcf)
+++ b/isubrip/__main__.py	(date 1688161961004)
@@ -11,7 +11,7 @@
 from isubrip.config import Config, ConfigException
 from isubrip.constants import ARCHIVE_FORMAT, DATA_FOLDER_PATH, DEFAULT_CONFIG_PATH, BASE_CONFIG_SETTINGS, \
     PACKAGE_NAME, TEMP_FOLDER_PATH, USER_CONFIG_FILE
-from isubrip.data_structures import EpisodeData,  MediaData, MovieData, SubtitlesDownloadResults, SubtitlesData
+from isubrip.data_structures import Episode, Movie, SubtitlesDownloadResults, SubtitlesData
 from isubrip.scrapers.scraper import Scraper, ScraperFactory
 from isubrip.utils import download_subtitles_to_file, generate_non_conflicting_path, generate_release_name, \
     single_to_list
@@ -47,10 +47,10 @@
                 atexit.register(scraper.close)
                 scraper.config.check()
 
-                media_data: MovieData = scraper.get_data(url=url)
-                media_items: list[MovieData] = single_to_list(media_data)
+                media_data: Movie = scraper.get_data(url=url)
+                media_items: list[Movie] = single_to_list(media_data)
 
-                print(f"Found movie: {media_items[0].title} ({media_items[0].release_date.year})")
+                print(f"Found movie: {media_items[0].name} ({media_items[0].release_date.year})")
 
                 if not media_data:
                     print(f"Error: No supported media data was found for {url}.")
@@ -69,7 +69,7 @@
                     print(f"{len(media_items)} media items were found.")
 
                 for media_item in media_items:
-                    media_id = media_item.id or media_item.alt_id or media_item.title
+                    media_id = media_item.id or media_item.alt_id or media_item.name
 
                     try:
                         if multiple_media_items:
@@ -77,12 +77,12 @@
 
                         if not media_item.playlist:
                             if media_data.preorder_availability_date:
-                                message = f"{media_item.title} is currently unavailable on " \
+                                message = f"{media_item.name} is currently unavailable on " \
                                           f"{media_item.scraper.name}.\n" \
                                           f"Release date ({media_item.scraper.name}): " \
                                           f"{media_data.preorder_availability_date}."
                             else:
-                                message = f"No valid playlist was found for {media_item.title} on {scraper.name}."
+                                message = f"No valid playlist was found for {media_item.name} on {scraper.name}."
 
                             print(message)
                             continue
@@ -155,14 +155,14 @@
         return
 
 
-def download_subtitles(media_data: MovieData | EpisodeData, download_path: Path,
+def download_subtitles(media_data: Movie | Episode, download_path: Path,
                        language_filter: list[str] | None = None, convert_to_srt: bool = False,
                        overwrite_existing: bool = True, zip_files: bool = False) -> SubtitlesDownloadResults:
     """
     Download subtitles for the given media data.
 
     Args:
-        media_data (MovieData | EpisodeData): A MovieData or an EpisodeData object of the media.
+        media_data (Movie | Episode): A MovieData or an EpisodeData object of the media.
         download_path (Path): Path to a folder where the subtitles will be downloaded to.
         language_filter (list[str] | None): List of specific languages to download subtitles for.
             None for all languages (no filter). Defaults to None.
@@ -293,7 +293,7 @@
         str: A folder name for the media data.
     """
     return generate_release_name(
-        title=media_data.title,
+        title=media_data.name,
         release_year=media_data.release_date.year,
         media_source=media_data.scraper.abbreviation,
     )
Index: isubrip/utils.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nimport datetime as dt\r\nimport json\r\nimport os\r\nimport re\r\nimport sys\r\n\r\nfrom abc import ABCMeta\r\nfrom os import PathLike\r\nfrom pathlib import Path\r\nfrom typing import Any, Union, get_args, get_origin\r\n\r\nfrom isubrip.data_structures import EpisodeData, MovieData, SubtitlesData, SubtitlesFormat, SubtitlesType\r\n\r\n\r\nclass SingletonMeta(ABCMeta):\r\n    \"\"\"\r\n    A metaclass that implements the Singleton pattern.\r\n    When a class using this metaclass is initialized, it will return the same instance every time.\r\n    \"\"\"\r\n    _instances: dict[object, object] = {}\r\n\r\n    def __call__(cls, *args, **kwargs) -> object:\r\n        if cls._instances.get(cls) is None:\r\n            cls._instances[cls] = super().__call__(*args, **kwargs)\r\n\r\n        return cls._instances[cls]\r\n\r\n\r\ndef check_type(value: Any, type_) -> bool:\r\n    \"\"\"\r\n    Check if a value is of a certain type.\r\n    Works with parameterized generics.\r\n\r\n    Args:\r\n        value: Value to check.\r\n        type_: Type to check against.\r\n\r\n    Returns:\r\n        bool: True if the value is of the specified type, False otherwise.\r\n    \"\"\"\r\n    origin = get_origin(type_)\r\n    args = get_args(type_)\r\n\r\n    if origin is Union:\r\n        return any(check_type(value, union_sub_type) for union_sub_type in args)\r\n\r\n    elif origin is tuple:\r\n        if args[-1] is Ellipsis:\r\n            # Example: (int, str, ...)\r\n            args_len = len(args)\r\n\r\n            return check_type(value[:args_len - 1], tuple(args[:-1])) and \\\r\n                all(check_type(item, args[-2]) for item in value[args_len - 1:])\r\n\r\n        else:\r\n            return isinstance(value, tuple) and \\\r\n                len(value) == len(args) and \\\r\n                all(check_type(item, item_type) for item, item_type in zip(value, args))\r\n\r\n    elif origin is list:\r\n        return isinstance(value, list) and \\\r\n            all(check_type(item, args[0]) for item in value)\r\n\r\n    elif origin is dict:\r\n        return isinstance(value, dict) and \\\r\n            all(check_type(k, args[0]) and check_type(v, args[1]) for k, v in value.items())\r\n\r\n    return isinstance(value, type_)\r\n\r\n\r\ndef convert_epoch_to_datetime(epoch_timestamp: int) -> dt.datetime:\r\n    \"\"\"\r\n    Convert an epoch timestamp to a datetime object.\r\n\r\n    Args:\r\n        epoch_timestamp (int): Epoch timestamp.\r\n\r\n    Returns:\r\n        datetime: A datetime object representing the timestamp.\r\n    \"\"\"\r\n    if epoch_timestamp >= 0:\r\n        return dt.datetime.fromtimestamp(epoch_timestamp)\r\n\r\n    else:\r\n        return dt.datetime(1970, 1, 1) + dt.timedelta(seconds=epoch_timestamp)\r\n\r\n\r\ndef download_subtitles_to_file(media_data: MovieData | EpisodeData, subtitles_data: SubtitlesData,\r\n                               output_path: str | PathLike, overwrite: bool = False) -> Path:\r\n    \"\"\"\r\n    Download subtitles to a file.\r\n\r\n    Args:\r\n        media_data (MovieData | EpisodeData): An object containing media data.\r\n        subtitles_data (SubtitlesData): A SubtitlesData object containing subtitles data.\r\n        output_path (str | PathLike): Path to the output folder.\r\n        overwrite (bool, optional): Whether to overwrite files if they already exist. Defaults to True.\r\n\r\n    Returns:\r\n        Path: Path to the downloaded subtitles file.\r\n\r\n    Raises:\r\n        ValueError: If the path in `output_path` does not exist.\r\n    \"\"\"\r\n    if not os.path.isdir(output_path):\r\n        raise ValueError(f'Invalid path: {output_path}')\r\n\r\n    if isinstance(media_data, MovieData):\r\n        file_name = generate_release_name(title=media_data.title,\r\n                                          release_year=media_data.release_date.year,\r\n                                          media_source=media_data.scraper.abbreviation,\r\n                                          language_code=subtitles_data.language_code,\r\n                                          subtitles_type=subtitles_data.special_type,\r\n                                          file_format=subtitles_data.subtitles_format)\r\n    elif isinstance(media_data, EpisodeData):\r\n        file_name = generate_release_name(title=media_data.title,\r\n                                          release_year=media_data.release_date.year,\r\n                                          season_number=media_data.season_number,\r\n                                          episode_number=media_data.episode_number,\r\n                                          episode_name=media_data.episode_name,\r\n                                          media_source=media_data.scraper.abbreviation,\r\n                                          language_code=subtitles_data.language_code,\r\n                                          subtitles_type=subtitles_data.special_type,\r\n                                          file_format=subtitles_data.subtitles_format)\r\n\r\n    else:\r\n        raise TypeError(f'This function only supports MovieData and EpisodeData objects. Got {type(media_data)}.')\r\n\r\n    file_path = Path(output_path) / file_name\r\n\r\n    if file_path.exists() and not overwrite:\r\n        file_path = generate_non_conflicting_path(file_path)\r\n\r\n    with open(file_path, 'wb') as f:\r\n        f.write(subtitles_data.content)\r\n\r\n    return file_path\r\n\r\n\r\ndef generate_non_conflicting_path(file_path: str | Path, has_extension: bool = True) -> Path:\r\n    \"\"\"\r\n    Generate a non-conflicting path for a file.\r\n    If the file already exists, a number will be added to the end of the file name.\r\n\r\n    Args:\r\n        file_path (str | Path): Path to a file.\r\n        has_extension (bool, optional): Whether the name of the file includes file extension. Defaults to True.\r\n\r\n    Returns:\r\n        Path: A non-conflicting file path.\r\n    \"\"\"\r\n    if isinstance(file_path, str):\r\n        file_path = Path(file_path)\r\n\r\n    if not file_path.exists():\r\n        return file_path\r\n\r\n    i = 1\r\n    while True:\r\n        if has_extension:\r\n            new_file_path = file_path.parent / f'{file_path.stem}-{i}{file_path.suffix}'\r\n\r\n        else:\r\n            new_file_path = file_path.parent / f'{file_path}-{i}'\r\n\r\n        if not new_file_path.exists():\r\n            return new_file_path\r\n\r\n        i += 1\r\n\r\n\r\ndef generate_release_name(title: str,\r\n                          release_year: int | None = None,\r\n                          season_number: int | None = None,\r\n                          episode_number: int | None = None,\r\n                          episode_name: str | None = None,\r\n                          media_source: str | None = None,\r\n                          source_type: str | None = \"WEB\",\r\n                          additional_info: str | list[str] | None = None,\r\n                          language_code: str | None = None,\r\n                          subtitles_type: SubtitlesType | None = None,\r\n                          file_format: str | SubtitlesFormat | None = None) -> str:\r\n    \"\"\"\r\n    Generate a release name.\r\n\r\n    Args:\r\n        title (str): Media title.\r\n        release_year (int | None, optional): Release year. Defaults to None.\r\n        season_number (int | None, optional): Season number. Defaults to None.\r\n        episode_number (int | None, optional): Episode number. Defaults to None.\r\n        episode_name (str | None, optional): Episode name. Defaults to None.\r\n        media_source (str | None, optional): Media source name (full or abbreviation). Defaults to None.\r\n        source_type(str | None, optional): General source type (WEB, BluRay, etc.). Defaults to None.\r\n        additional_info (list[str] | str | None, optional): Additional info to add to the file name. Defaults to None.\r\n        language_code (str | None, optional): Language code. Defaults to None.\r\n        subtitles_type (SubtitlesType | None, optional): Subtitles type. Defaults to None.\r\n        file_format (SubtitlesFormat | str | None, optional): File format to use.  Defaults to None.\r\n\r\n    Returns:\r\n        str: Generated file name.\r\n    \"\"\"\r\n    file_name = standardize_title(title)\r\n\r\n    if release_year is not None:\r\n        file_name += f'.{release_year}'\r\n\r\n    if season_number is not None:\r\n        file_name += f'.S{season_number:02}'\r\n\r\n    if episode_number is not None:\r\n        file_name += f'.E{episode_number:02}'\r\n\r\n    if episode_name is not None:\r\n        file_name += f'.{standardize_title(episode_name)}'\r\n\r\n    if media_source is not None:\r\n        file_name += f'.{media_source}'\r\n\r\n    if source_type is not None:\r\n        file_name += f'.{source_type}'\r\n\r\n    if additional_info is not None:\r\n        if isinstance(additional_info, (list, tuple)):\r\n            additional_info = '.'.join(additional_info)\r\n\r\n        file_name += f'.{additional_info}'\r\n\r\n    if language_code is not None:\r\n        file_name += f'.{language_code}'\r\n\r\n    if subtitles_type is not None:\r\n        file_name += f'.{subtitles_type.value.lower()}'\r\n\r\n    if file_format is not None:\r\n        if isinstance(file_format, SubtitlesFormat):\r\n            file_format = file_format.value.file_extension\r\n\r\n        file_name += f'.{file_format}'\r\n\r\n    return file_name\r\n\r\n\r\ndef generate_url_params(data: dict[str, Any], remove_dict_spaces: bool = False) -> str:\r\n    \"\"\"\r\n    Generate a URL query string from a dictionary.\r\n\r\n    Args:\r\n        data (dict[str, Any]): Dictionary to generate a URL query string from.\r\n        remove_dict_spaces (bool, optional): Whether to remove spaces from stringified dictionary values.\r\n            Defaults to False.\r\n\r\n    Returns:\r\n        str: Generated URL query string.\r\n    \"\"\"\r\n    stringified_data = {}\r\n    json_dumps_separators = (',', ':') if remove_dict_spaces else None\r\n\r\n    for key, value in data.items():\r\n        if isinstance(value, (list, tuple, dict)):\r\n            stringified_data[key] = json.dumps(value, separators=json_dumps_separators)\r\n\r\n        elif isinstance(value, bool):\r\n            stringified_data[key] = str(value).lower()\r\n\r\n        else:\r\n            stringified_data[key] = str(value)\r\n\r\n    return '&'.join([f\"{key}={value}\" for key, value in stringified_data.items() if value is not None])\r\n\r\n\r\ndef merge_dict_values(*dictionaries: dict) -> dict:\r\n    \"\"\"\r\n    A function for merging the values of multiple dictionaries using the same keys.\r\n    If a key already exists, the value will be added to a list of values mapped to that key.\r\n\r\n    Args:\r\n        *dictionaries (dict): Dictionaries to merge.\r\n\r\n    Returns:\r\n        dict: A merged dictionary.\r\n    \"\"\"\r\n    result: dict = {}\r\n\r\n    for dict_ in dictionaries:\r\n        for key, value in dict_.items():\r\n            if key in result:\r\n                if isinstance(result[key], list) and value not in result[key]:\r\n                    result[key].append(value)\r\n\r\n                elif isinstance(result[key], tuple) and value not in result[key]:\r\n                    result[key] = result[key] + (value,)\r\n\r\n                elif value != result[key]:\r\n                    result[key] = [result[key], value]\r\n            else:\r\n                result[key] = value\r\n\r\n    return result\r\n\r\n\r\ndef parse_duration(duration_string: str) -> dt.timedelta:\r\n    \"\"\"\r\n    Parse a duration ISO 8601 string (e.g. PT1H30M15S), or a duration tag (e.g. '1h 30m', '30m') to a timedelta object.\r\n\r\n    Args:\r\n        duration_string (str): Duration tag to parse.\r\n\r\n    Returns:\r\n        dt.timedelta: A timedelta object representing the duration.\r\n    \"\"\"\r\n    iso8601_duration_regex = re.compile(\r\n        r\"(?i)^PT(?:(?P<hours>\\d{1,2})H)?(?:(?P<minutes>\\d{1,2})M)?(?:(?P<seconds>\\d{1,2})(?:\\.(?P<milliseconds>\\d{1,3}))?S)?\"  # noqa: E501\r\n    )\r\n\r\n    duration_tag_regex = re.compile(\r\n        r\"(?i)^(?:(?P<hours>\\d{1,2})H)?\\s?(?:(?P<minutes>\\d{1,2})M)?\\s?(?:(?P<seconds>\\d{1,2})S)?$\"\r\n    )\r\n\r\n    if regex_match := re.match(iso8601_duration_regex, duration_string):\r\n        data = regex_match.groupdict()\r\n\r\n    elif regex_match := re.match(duration_tag_regex, duration_string):\r\n        data = regex_match.groupdict()\r\n\r\n    else:\r\n        raise ValueError(f\"Invalid / unsupported duration string: '{duration_string}'\")\r\n\r\n    hours = int(data[\"hours\"]) if data.get(\"hours\") else 0\r\n    minutes = int(data[\"minutes\"]) if data.get(\"minutes\") else 0\r\n    seconds = int(data[\"seconds\"]) if data.get(\"seconds\") else 0\r\n    milliseconds = int(data[\"milliseconds\"]) if data.get(\"milliseconds\") else 0\r\n\r\n    return dt.timedelta(hours=hours, minutes=minutes, seconds=seconds, milliseconds=milliseconds)\r\n\r\n\r\ndef parse_season_and_episode_tag(tag: str) -> tuple[int, int]:\r\n    \"\"\"\r\n    Parse a season and episode tag (e.g. 'S01E01') to a tuple containing the season number and episode number.\r\n\r\n    Args:\r\n        tag (str): Season and episode tag. (e.g. 'S01E02')\r\n\r\n    Returns:\r\n        tuple[int, int]: A tuple containing the season number (first item) and episode number (second item).\r\n    \"\"\"\r\n    regex_pattern = re.compile(r\"(?i)^S(?P<season>\\d{1,2})[\\s.]?E(?P<episode>\\d{1,3})$\")\r\n\r\n    if regex_match := re.match(regex_pattern, tag):\r\n        return int(regex_match.group('season')), int(regex_match.group('episode'))\r\n\r\n    else:\r\n        raise ValueError(f\"Invalid season and episode tag: '{tag}'\")\r\n\r\n\r\ndef parse_url_params(url_params: str) -> dict:\r\n    \"\"\"\r\n    Parse GET parameters from a URL to a dictionary.\r\n\r\n    Args:\r\n        url_params (str): URL parameters. (e.g. 'param1=value1&param2=value2')\r\n\r\n    Returns:\r\n        dict: A dictionary containing the URL parameters.\r\n    \"\"\"\r\n    url_params = url_params.split('?')[-1].rstrip('&')\r\n    params_list = url_params.split('&')\r\n\r\n    if len(params_list) == 0 or \\\r\n            (len(params_list) == 1 and '=' not in params_list[0]):\r\n        return {}\r\n\r\n    return {key: value for key, value in (param.split('=') for param in params_list)}\r\n\r\n\r\ndef single_to_list(obj) -> list:\r\n    \"\"\"\r\n    Convert a single non-iterable object to a list.\r\n    If None is passed, an empty list will be returned.\r\n\r\n    Args:\r\n        obj: Object to convert.\r\n\r\n    Returns:\r\n        list: A list containing the object.\r\n            If the object is already an iterable, it will be converted to a list.\r\n    \"\"\"\r\n    if isinstance(obj, list):\r\n        return obj\r\n\r\n    elif obj is None:\r\n        return []\r\n\r\n    # tuple (not a namedtuple) or a set\r\n    elif (isinstance(obj, tuple) and not hasattr(obj, '_fields')) or isinstance(obj, set):\r\n        return list(obj)\r\n\r\n    return [obj]\r\n\r\n\r\ndef split_subtitles_timestamp(timestamp: str) -> tuple[dt.time, dt.time]:\r\n    \"\"\"\r\n    Split a subtitles timestamp into start and end.\r\n\r\n    Args:\r\n        timestamp (str): A subtitles timestamp. For example: \"00:00:00.000 --> 00:00:00.000\"\r\n\r\n    Returns:\r\n        tuple(time, time): A tuple containing start and end times as a datetime object.\r\n    \"\"\"\r\n    # Support ',' character in timestamp's milliseconds (used in SubRip format).\r\n    timestamp = timestamp.replace(',', '.')\r\n\r\n    start_time, end_time = timestamp.split(\" --> \")\r\n    return dt.time.fromisoformat(start_time), dt.time.fromisoformat(end_time)\r\n\r\n\r\ndef standardize_title(title: str) -> str:\r\n    \"\"\"\r\n    Format movie title to a standardized title that can be used as a file name.\r\n\r\n    Args:\r\n        title (str): A movie title.\r\n\r\n    Returns:\r\n        str: The movie title, in a file-name-friendly format.\r\n    \"\"\"\r\n    windows_reserved_file_names = (\"CON\", \"PRN\", \"AUX\", \"NUL\", \"COM1\", \"COM2\", \"COM3\", \"COM4\",\r\n                                   \"COM5\", \"COM6\", \"COM7\", \"COM8\", \"COM9\", \"LPT1\", \"LPT2\",\r\n                                   \"LPT3\", \"LPT4\", \"LPT5\", \"LPT6\", \"LPT7\", \"LPT8\", \"LPT9\")\r\n\r\n    title = title.strip()\r\n\r\n    # Replacements will be done in the same order of this list\r\n    replacement_pairs = [\r\n        (': ', '.'),\r\n        (':', '.'),\r\n        (' - ', '-'),\r\n        (', ', '.'),\r\n        ('. ', '.'),\r\n        (' ', '.'),\r\n        ('|', '.'),\r\n        ('/', '.'),\r\n        ('<', ''),\r\n        ('>', ''),\r\n        ('(', ''),\r\n        (')', ''),\r\n        ('\"', ''),\r\n        ('?', ''),\r\n        ('*', ''),\r\n    ]\r\n\r\n    for pair in replacement_pairs:\r\n        title = title.replace(pair[0], pair[1])\r\n\r\n    title = re.sub(r\"\\.+\", \".\", title)  # Replace multiple dots with a single dot\r\n\r\n    # If running on Windows, rename Windows reserved names to allow file creation\r\n    if sys.platform == 'win32':\r\n        split_title = title.split('.')\r\n\r\n        if split_title[0].upper() in windows_reserved_file_names:\r\n            if len(split_title) > 1:\r\n                return split_title[0] + split_title[1] + '.'.join(split_title[2:])\r\n\r\n            elif len(split_title) == 1:\r\n                return \"_\" + title\r\n\r\n    return title\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/utils.py b/isubrip/utils.py
--- a/isubrip/utils.py	(revision 4e9b49629e5b5efd853d0fb7467e661145c9afcf)
+++ b/isubrip/utils.py	(date 1688161034698)
@@ -11,7 +11,7 @@
 from pathlib import Path
 from typing import Any, Union, get_args, get_origin
 
-from isubrip.data_structures import EpisodeData, MovieData, SubtitlesData, SubtitlesFormat, SubtitlesType
+from isubrip.data_structures import Episode, Movie, SubtitlesData, SubtitlesFormat, SubtitlesType
 
 
 class SingletonMeta(ABCMeta):
@@ -87,13 +87,13 @@
         return dt.datetime(1970, 1, 1) + dt.timedelta(seconds=epoch_timestamp)
 
 
-def download_subtitles_to_file(media_data: MovieData | EpisodeData, subtitles_data: SubtitlesData,
+def download_subtitles_to_file(media_data: Movie | Episode, subtitles_data: SubtitlesData,
                                output_path: str | PathLike, overwrite: bool = False) -> Path:
     """
     Download subtitles to a file.
 
     Args:
-        media_data (MovieData | EpisodeData): An object containing media data.
+        media_data (Movie | Episode): An object containing media data.
         subtitles_data (SubtitlesData): A SubtitlesData object containing subtitles data.
         output_path (str | PathLike): Path to the output folder.
         overwrite (bool, optional): Whether to overwrite files if they already exist. Defaults to True.
@@ -107,15 +107,15 @@
     if not os.path.isdir(output_path):
         raise ValueError(f'Invalid path: {output_path}')
 
-    if isinstance(media_data, MovieData):
-        file_name = generate_release_name(title=media_data.title,
+    if isinstance(media_data, Movie):
+        file_name = generate_release_name(title=media_data.name,
                                           release_year=media_data.release_date.year,
                                           media_source=media_data.scraper.abbreviation,
                                           language_code=subtitles_data.language_code,
                                           subtitles_type=subtitles_data.special_type,
                                           file_format=subtitles_data.subtitles_format)
-    elif isinstance(media_data, EpisodeData):
-        file_name = generate_release_name(title=media_data.title,
+    elif isinstance(media_data, Episode):
+        file_name = generate_release_name(title=media_data.name,
                                           release_year=media_data.release_date.year,
                                           season_number=media_data.season_number,
                                           episode_number=media_data.episode_number,
Index: isubrip/scrapers/itunes_scraper.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nimport datetime as dt\r\n\r\nfrom isubrip.data_structures import MovieData\r\nfrom isubrip.scrapers.scraper import M3U8Scraper, MovieScraper, ScraperException, ScraperFactory\r\nfrom isubrip.subtitle_formats.webvtt import WebVTTSubtitles\r\n\r\n\r\nclass iTunesScraper(M3U8Scraper, MovieScraper):\r\n    \"\"\"An iTunes movie data scraper.\"\"\"\r\n    id = \"itunes\"\r\n    name = \"iTunes\"\r\n    abbreviation = \"iT\"\r\n    url_regex = r\"(?P<base_url>https?://itunes\\.apple\\.com/(?:(?P<country_code>[a-z]{2})/)?(?P<media_type>movie|tv-show|tv-season|show)/(?:(?P<media_name>[\\w\\-%]+)/)?(?P<media_id>id\\d{9,10}))(?:\\?(?P<url_params>(?:).*))?\"  # noqa: E501\r\n    subtitles_class = WebVTTSubtitles\r\n    is_movie_scraper = True\r\n    uses_scrapers = [\"appletv\"]\r\n\r\n    def __init__(self, config_data: dict | None = None):\r\n        super().__init__(config_data=config_data)\r\n        self._appletv_scraper = ScraperFactory().get_scraper_instance(scraper_id=\"appletv\",\r\n                                                                      config_data=self._config_data,\r\n                                                                      raise_error=True)\r\n\r\n    def get_data(self, url: str) -> MovieData:\r\n        \"\"\"\r\n        Scrape iTunes to find info about a movie, and it's M3U8 main_playlist.\r\n\r\n        Args:\r\n            url (str): An iTunes store movie URL.\r\n\r\n        Raises:\r\n            InvalidURL: `itunes_url` is not a valid iTunes store movie URL.\r\n            PageLoadError: HTML page did not load properly.\r\n            HTTPError: HTTP request failed.\r\n\r\n        Returns:\r\n            MovieData: A MovieData (NamedTuple) object with movie's name, and an M3U8 object of the main_playlist\r\n            if the main_playlist is found. None otherwise.\r\n        \"\"\"\r\n        regex_match = self.match_url(url, raise_error=True)\r\n        url = regex_match.group(1)\r\n        response = self._session.get(url=url, allow_redirects=False)\r\n        response.raise_for_status()\r\n\r\n        redirect_location = response.headers.get(\"Location\")\r\n\r\n        if response.status_code != 301 or not redirect_location:\r\n            raise ScraperException(\"Apple TV redirect URL not found.\")\r\n\r\n        if not self._appletv_scraper.match_url(redirect_location):\r\n            raise ScraperException(\"Redirect URL is not a valid Apple TV URL.\")\r\n\r\n        return self._appletv_scraper.get_data(redirect_location)\r\n\r\n    def _get_movie_data(self, json_data: dict) -> MovieData:\r\n        \"\"\"\r\n        Scrape an iTunes JSON response to get movie info.\r\n\r\n        Args:\r\n            json_data (dict): A dictionary with iTunes data loaded from a JSON response.\r\n\r\n        Returns:\r\n            MovieData: A MovieData (NamedTuple) object with movie's name, and an M3U8 object of the main_playlist\r\n            if the main_playlist is found. None otherwise.\r\n        \"\"\"\r\n        itunes_id = json_data[\"pageData\"][\"id\"]\r\n        movie_data = json_data[\"storePlatformData\"][\"product-dv\"][\"results\"][itunes_id]\r\n\r\n        movie_title = movie_data[\"nameRaw\"]\r\n        movie_release_date = dt.datetime.strptime(movie_data[\"releaseDate\"], \"%Y-%m-%d\")\r\n\r\n        # Loop safely to find a matching main_playlist\r\n        for offer in movie_data[\"offers\"]:\r\n            if isinstance(offer.get(\"type\"), str) and offer[\"type\"] in [\"buy\", \"rent\"]:\r\n                if isinstance(offer.get(\"assets\"), list) and len(offer[\"assets\"]) > 0:\r\n                    for asset in offer[\"assets\"]:\r\n                        if playlist_url := asset.get(\"hlsUrl\"):\r\n                            return MovieData(\r\n                                id=itunes_id,\r\n                                alt_id=None,\r\n                                title=movie_title,\r\n                                release_date=movie_release_date,\r\n                                playlist=playlist_url,\r\n                                scraper=self,\r\n                                original_scraper=self,\r\n                                original_data=json_data,\r\n                            )\r\n\r\n        return MovieData(\r\n            id=itunes_id,\r\n            alt_id=None,\r\n            title=movie_title,\r\n            release_date=movie_release_date,\r\n            playlist=None,\r\n            scraper=self,\r\n            original_scraper=self,\r\n            original_data=json_data,\r\n        )\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/scrapers/itunes_scraper.py b/isubrip/scrapers/itunes_scraper.py
--- a/isubrip/scrapers/itunes_scraper.py	(revision 4e9b49629e5b5efd853d0fb7467e661145c9afcf)
+++ b/isubrip/scrapers/itunes_scraper.py	(date 1688161034687)
@@ -2,7 +2,7 @@
 
 import datetime as dt
 
-from isubrip.data_structures import MovieData
+from isubrip.data_structures import Movie
 from isubrip.scrapers.scraper import M3U8Scraper, MovieScraper, ScraperException, ScraperFactory
 from isubrip.subtitle_formats.webvtt import WebVTTSubtitles
 
@@ -23,7 +23,7 @@
                                                                       config_data=self._config_data,
                                                                       raise_error=True)
 
-    def get_data(self, url: str) -> MovieData:
+    def get_data(self, url: str) -> Movie:
         """
         Scrape iTunes to find info about a movie, and it's M3U8 main_playlist.
 
@@ -36,7 +36,7 @@
             HTTPError: HTTP request failed.
 
         Returns:
-            MovieData: A MovieData (NamedTuple) object with movie's name, and an M3U8 object of the main_playlist
+            Movie: A MovieData (NamedTuple) object with movie's name, and an M3U8 object of the main_playlist
             if the main_playlist is found. None otherwise.
         """
         regex_match = self.match_url(url, raise_error=True)
@@ -54,7 +54,7 @@
 
         return self._appletv_scraper.get_data(redirect_location)
 
-    def _get_movie_data(self, json_data: dict) -> MovieData:
+    def _get_movie_data(self, json_data: dict) -> Movie:
         """
         Scrape an iTunes JSON response to get movie info.
 
@@ -62,7 +62,7 @@
             json_data (dict): A dictionary with iTunes data loaded from a JSON response.
 
         Returns:
-            MovieData: A MovieData (NamedTuple) object with movie's name, and an M3U8 object of the main_playlist
+            Movie: A MovieData (NamedTuple) object with movie's name, and an M3U8 object of the main_playlist
             if the main_playlist is found. None otherwise.
         """
         itunes_id = json_data["pageData"]["id"]
@@ -77,7 +77,7 @@
                 if isinstance(offer.get("assets"), list) and len(offer["assets"]) > 0:
                     for asset in offer["assets"]:
                         if playlist_url := asset.get("hlsUrl"):
-                            return MovieData(
+                            return Movie(
                                 id=itunes_id,
                                 alt_id=None,
                                 title=movie_title,
@@ -88,7 +88,7 @@
                                 original_data=json_data,
                             )
 
-        return MovieData(
+        return Movie(
             id=itunes_id,
             alt_id=None,
             title=movie_title,
Index: isubrip/data_structures.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nimport datetime as dt\r\nfrom abc import ABC\r\nfrom dataclasses import dataclass\r\nfrom enum import Enum\r\nfrom typing import NamedTuple, TYPE_CHECKING\r\n\r\nfrom m3u8 import M3U8\r\nfrom mpegdash.nodes import MPEGDASH\r\n\r\nif TYPE_CHECKING:\r\n    from isubrip.scrapers.scraper import Scraper\r\n\r\n\r\nclass SubtitlesDownloadResults(NamedTuple):\r\n    \"\"\"\r\n    A named tuple containing download results.\r\n\r\n    Attributes:\r\n        media_data (MediaData): Media data.\r\n        successful_subtitles (list[SubtitlesData]): List of subtitles that were successfully downloaded.\r\n        failed_subtitles (list[SubtitlesData]): List of subtitles that failed to download.\r\n        is_zip (bool): Whether the subtitles were saved in a zip file.\r\n    \"\"\"\r\n    media_data: MediaData\r\n    successful_subtitles: list[SubtitlesData]\r\n    failed_subtitles: list[SubtitlesData]\r\n    is_zip: bool\r\n\r\n\r\nclass SubtitlesFormatData(NamedTuple):\r\n    \"\"\"\r\n    A named tuple for containing metadata about subtitles formats.\r\n\r\n    Attributes:\r\n        name (str): Name of the format.\r\n        file_extension (str): File extension of the format.\r\n    \"\"\"\r\n    name: str\r\n    file_extension: str\r\n\r\n\r\nclass SubtitlesFormat(Enum):\r\n    \"\"\"\r\n    An Enum representing subtitles formats.\r\n\r\n    Attributes:\r\n        SUBRIP (SubtitlesFormatData): SubRip format.\r\n        WEBVTT (SubtitlesFormatData): WebVTT format.\r\n    \"\"\"\r\n    SUBRIP = SubtitlesFormatData(\"SubRip\", \"srt\")\r\n    WEBVTT = SubtitlesFormatData(\"WebVTT\", \"vtt\")\r\n\r\n\r\nclass SubtitlesType(Enum):\r\n    \"\"\"\r\n    Subtitles special type.\r\n\r\n    Attributes:\r\n        CC (SubtitlesType): Closed captions.\r\n        FORCED (SubtitlesType): Forced subtitles.\r\n    \"\"\"\r\n    CC = \"CC\"\r\n    FORCED = \"Forced\"\r\n\r\n\r\n@dataclass\r\nclass SubtitlesData:\r\n    \"\"\"\r\n    A named tuple containing subtitles metadata.\r\n\r\n    Attributes:\r\n        language_code (str): Language code of the language the subtitles are in.\r\n        language_name (str): Name of the language the subtitles are in.\r\n        subtitles_format (SubtitlesFormat): Format of the subtitles.\r\n        content (bytes): Content of the subtitles in binary format.\r\n        special_type (SubtitlesType | None): Type of the subtitles, if they're not regular. Defaults to None.\r\n    \"\"\"\r\n    language_code: str\r\n    language_name: str\r\n    subtitles_format: SubtitlesFormat\r\n    content: bytes\r\n    special_type: SubtitlesType | None = None\r\n\r\n    def __post_init__(self):\r\n        self.language_name = self.language_name.strip()\r\n\r\n\r\n# TODO: Use `kw_only` on dataclasses, and set default values of None for optional arguments once min version => 3.10\r\n\r\n@dataclass\r\nclass PlaylistData:\r\n    \"\"\"\r\n    A named tuple containing playlist metadata.\r\n\r\n    Attributes:\r\n        id (str | None, optional): ID of the playlist. Defaults to None.\r\n        url (str | None): URL to the playlist.\r\n        data (M3U8 | MPEGDASH): Playlist data.\r\n        duration (timedelta | None, optional): Duration of the playlist. Defaults to None.\r\n    \"\"\"\r\n    url: str\r\n    data: M3U8 | MPEGDASH\r\n    id: str | None = None\r\n    duration: dt.timedelta | None = None\r\n\r\n\r\n@dataclass\r\nclass MediaData(ABC):\r\n    \"\"\"\r\n    A base class for media data.\r\n\r\n    Attributes:\r\n        id (str | None, optional): ID of the media. Defaults to None.\r\n        alt_id (str | None, optional): Alternative ID of the media. Defaults to None.\r\n        title (str): Title of the media (movie title, episode title, etc.).\r\n        release_date (datetime | int | None, optional):\r\n            Release date of the media (datetime), or just a year (int). Defaults to None.\r\n        duration (timedelta | None, optional): Duration of the media. Defaults to None. Defaults to None.\r\n        playlist (PlaylistData | list[PlaylistData] | None, optional): URL to the playlist. Defaults to None.\r\n        scraper (Scraper): A reference to the scraper that should be used with the data.\r\n        original_scraper (Scraper): A reference to the scraper that was used to get the data.\r\n        original_data (dict): Original data that was used to create the object.\r\n    \"\"\"\r\n    id: str | None\r\n    alt_id: str | None\r\n    title: str\r\n    release_date: dt.datetime | int | None\r\n    duration: dt.timedelta | None\r\n    playlist: PlaylistData | list[PlaylistData] | None\r\n    scraper: Scraper\r\n    original_scraper: Scraper\r\n    original_data: dict\r\n\r\n\r\n@dataclass\r\nclass MovieData(MediaData):\r\n    \"\"\"\r\n    A named tuple containing movie metadata.\r\n\r\n    Attributes:\r\n        preorder_availability_date (datetime | None, optional): Date when the movie will be available for preorder.\r\n            None if not a preorder. Defaults to None.\r\n    \"\"\"\r\n    preorder_availability_date: dt.datetime | None = None\r\n\r\n\r\n@dataclass\r\nclass EpisodeData(MediaData):\r\n    \"\"\"\r\n    A named tuple containing episode metadata.\r\n\r\n    Attributes:\r\n        episode_number (int): Episode number.\r\n        season_number (int): Season number.\r\n        episode_name (str | None, optional): Episode name. Defaults to None.\r\n        season_name (str | None, optional): Season name. Defaults to None.\r\n        episode_release_date (datetime | None): Release date of the episode. Defaults to None.\r\n    \"\"\"\r\n    episode_number: int\r\n    episode_name: str\r\n    season_number: int\r\n    episode_release_date: dt.datetime | None = None\r\n    season_name: str | None = None\r\n\r\n\r\n@dataclass\r\nclass SeasonData(MediaData):\r\n    \"\"\"\r\n    A named tuple containing season metadata.\r\n\r\n    Attributes:\r\n        season_number (int): Season number.\r\n        season_name (str | None, optional): Season name. Defaults to None.\r\n        season_episodes (list[EpisodeData]): Episodes that belong to the season.\r\n        season_release_date (datetime | None, optional): Release date of the season, or release year. Defaults to None.\r\n    \"\"\"\r\n    season_number: int\r\n    season_episodes: list[EpisodeData]\r\n    season_release_date: dt.datetime | int | None = None\r\n    season_name: str | None = None\r\n\r\n\r\n@dataclass\r\nclass SeriesData(MediaData):\r\n    \"\"\"\r\n    A named tuple containing series metadata.\r\n\r\n    Attributes:\r\n        series_seasons (list[SeasonData]): Seasons that belong to the series.\r\n    \"\"\"\r\n    series_seasons: list[SeasonData]\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/data_structures.py b/isubrip/data_structures.py
--- a/isubrip/data_structures.py	(revision 4e9b49629e5b5efd853d0fb7467e661145c9afcf)
+++ b/isubrip/data_structures.py	(date 1688161961011)
@@ -8,6 +8,7 @@
 
 from m3u8 import M3U8
 from mpegdash.nodes import MPEGDASH
+from pydantic import BaseModel, field_validator
 
 if TYPE_CHECKING:
     from isubrip.scrapers.scraper import Scraper
@@ -29,7 +30,7 @@
     is_zip: bool
 
 
-class SubtitlesFormatData(NamedTuple):
+class SubtitlesFormatData(NamedTuple):  # TODO: Remove if not really needed?
     """
     A named tuple for containing metadata about subtitles formats.
 
@@ -65,10 +66,9 @@
     FORCED = "Forced"
 
 
-@dataclass
-class SubtitlesData:
+class SubtitlesData(BaseModel):
     """
-    A named tuple containing subtitles metadata.
+    An object containing subtitles data and metadata.
 
     Attributes:
         language_code (str): Language code of the language the subtitles are in.
@@ -83,16 +83,16 @@
     content: bytes
     special_type: SubtitlesType | None = None
 
-    def __post_init__(self):
-        self.language_name = self.language_name.strip()
+    @field_validator("language_name")
+    def language_name_strip(self, value):
+        return value.strip()
 
 
 # TODO: Use `kw_only` on dataclasses, and set default values of None for optional arguments once min version => 3.10
 
-@dataclass
-class PlaylistData:
+class PlaylistData(BaseModel):
     """
-    A named tuple containing playlist metadata.
+    An object containing playlist data and metadata.
 
     Attributes:
         id (str | None, optional): ID of the playlist. Defaults to None.
@@ -106,88 +106,107 @@
     duration: dt.timedelta | None = None
 
 
-@dataclass
-class MediaData(ABC):
+class ScrapedMediaResponse(BaseModel):
     """
-    A base class for media data.
+    An object containing scraped media data and metadata.
 
     Attributes:
-        id (str | None, optional): ID of the media. Defaults to None.
-        alt_id (str | None, optional): Alternative ID of the media. Defaults to None.
-        title (str): Title of the media (movie title, episode title, etc.).
-        release_date (datetime | int | None, optional):
-            Release date of the media (datetime), or just a year (int). Defaults to None.
-        duration (timedelta | None, optional): Duration of the media. Defaults to None. Defaults to None.
-        playlist (PlaylistData | list[PlaylistData] | None, optional): URL to the playlist. Defaults to None.
-        scraper (Scraper): A reference to the scraper that should be used with the data.
-        original_scraper (Scraper): A reference to the scraper that was used to get the data.
-        original_data (dict): Original data that was used to create the object.
+        media_data (Movie | list[Movie] | Episode | Season | Series):
+            An object containing the scraped media data.
+        metadata_scraper (Scraper): A reference to the instance of the scraper that was used to scrape the metadata.
+        playlist_scraper (type[Scraper]): A scraper class that should be used to parse and scrape the playlist.
+        original_data (dict): Original raw data from the API that was used to extract media's data.
     """
-    id: str | None
-    alt_id: str | None
-    title: str
-    release_date: dt.datetime | int | None
-    duration: dt.timedelta | None
-    playlist: PlaylistData | list[PlaylistData] | None
-    scraper: Scraper
-    original_scraper: Scraper
+    media_data: Movie | list[Movie] | Episode | Season | Series  # TODO: Remove `list[MovieData]`? Will require updating AppleTV's `get_media_data` method.
+    metadata_scraper: Scraper
+    playlist_scraper: type[Scraper]
     original_data: dict
 
 
-@dataclass
-class MovieData(MediaData):
+class Movie(BaseModel):
     """
-    A named tuple containing movie metadata.
+    An object containing movie metadata.
 
     Attributes:
-        preorder_availability_date (datetime | None, optional): Date when the movie will be available for preorder.
-            None if not a preorder. Defaults to None.
+        id (str | None, optional): ID of the movie on the service it was scraped from. Defaults to None.
+        name (str): Title of the movie.
+        release_date (datetime | int | None, optional): Release date (datetime), or year (int) of the movie.
+            Defaults to None.
+        duration (timedelta | None, optional): Duration of the movie. Defaults to None.
+        preorder_availability_date (datetime | None, optional):
+            Date when the movie will be available for pre-order on the service it was scraped from.
+            None if not a pre-order. Defaults to None.
     """
+    name: str
+    release_date: dt.datetime | int
+    id: str | None = None
+    duration: dt.timedelta | None = None
     preorder_availability_date: dt.datetime | None = None
+    playlist: PlaylistData | list[PlaylistData] | None = None
 
 
-@dataclass
-class EpisodeData(MediaData):
+class Episode(BaseModel):
     """
-    A named tuple containing episode metadata.
+    An object containing episode metadata.
 
     Attributes:
+        id (str | None, optional): ID of the episode on the service it was scraped from. Defaults to None.
+        series_name (str): Name of the series the episode is from.
+        series_release_date (datetime | int | None, optional): Release date (datetime), or year (int) of the series.
+            Defaults to None.
+        season_number (int): Season number.
+        season_name (str | None, optional): Season name. Defaults to None.
         episode_number (int): Episode number.
-        season_number (int): Season number.
         episode_name (str | None, optional): Episode name. Defaults to None.
-        season_name (str | None, optional): Season name. Defaults to None.
         episode_release_date (datetime | None): Release date of the episode. Defaults to None.
     """
+    series_name: str
+    season_number: int
     episode_number: int
-    episode_name: str
-    season_number: int
-    episode_release_date: dt.datetime | None = None
+    id: str | None = None
+    series_release_date: dt.datetime | int | None = None
     season_name: str | None = None
+    release_date: dt.datetime | None = None
+    duration: dt.timedelta | None = None
+    episode_name: str | None = None
+    episode_release_date: dt.datetime | None = None
 
 
-@dataclass
-class SeasonData(MediaData):
+class Season(BaseModel):
     """
-    A named tuple containing season metadata.
+    An object containing season metadata.
 
     Attributes:
-        season_number (int): Season number.
+        id (str | None, optional): ID of the season on the service it was scraped from. Defaults to None.
+        series_name (str): Name of the series the season is from.
+        series_release_date (datetime | int | None, optional): Release date (datetime), or year (int) of the series.
+            Defaults to None.
         season_name (str | None, optional): Season name. Defaults to None.
-        season_episodes (list[EpisodeData]): Episodes that belong to the season.
         season_release_date (datetime | None, optional): Release date of the season, or release year. Defaults to None.
+        episodes (list[Episode]): A list of episode objects containing metadata about episodes of the season.
     """
+    series_name: str
     season_number: int
-    season_episodes: list[EpisodeData]
-    season_release_date: dt.datetime | int | None = None
+    id: str | None = None
+    series_release_date: dt.datetime | int | None = None
     season_name: str | None = None
+    season_release_date: dt.datetime | int | None = None
+    episodes: list[Episode] = []
 
 
-@dataclass
-class SeriesData(MediaData):
+
+class Series(BaseModel):
     """
-    A named tuple containing series metadata.
+    An object containing series metadata.
 
     Attributes:
-        series_seasons (list[SeasonData]): Seasons that belong to the series.
+        series_name (str): Series name.
+        series_release_date (datetime | int | None, optional): Release date (datetime), or year (int) of the series.
+            Defaults to None.
+        seasons (list[Season]): A list of season objects containing metadata about seasons of the series.
     """
-    series_seasons: list[SeasonData]
+    series_name: str
+    seasons: list[Season] = []
+    series_release_date: dt.datetime | int | None = None
+
+
