Index: isubrip/scrapers/disneyplus_hotstar_scraper.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nimport datetime as dt\r\nimport re\r\nfrom typing import TYPE_CHECKING, Iterator\r\n\r\nimport httpx\r\n\r\nfrom isubrip.config import ConfigSetting\r\nfrom isubrip.data_structures import (\r\n    Episode,\r\n    Movie,\r\n    ScrapedMediaResponse,\r\n    Season,\r\n    Series,\r\n    SubtitlesData,\r\n    SubtitlesFormatType,\r\n)\r\nfrom isubrip.logger import logger\r\nfrom isubrip.parsers.mpeg_dash import MPD\r\nfrom isubrip.scrapers.scraper import DASHScraper, PlaylistLoadError, ScraperError, SubtitlesDownloadError\r\nfrom isubrip.subtitle_formats.webvtt import WebVTTSubtitles\r\nfrom isubrip.utils import (\r\n    extract_host_from_url,\r\n    generate_random_hex_string,\r\n    generate_url_params,\r\n    parse_duration,\r\n    parse_season_and_episode_tag,\r\n    parse_url_params,\r\n    raise_for_status,\r\n    single_to_list,\r\n)\r\n\r\nif TYPE_CHECKING:\r\n    import requests\r\n    from requests.models import Response\r\n\r\n\r\nclass DisneyPlusHotstarScraper(DASHScraper):\r\n    \"\"\"\r\n    A Disney+ Hotstar scraper\r\n\r\n    Attributes:\r\n        _api_base_url (str): Disney+ Hotstar's base API URL.\r\n        _player_params (dict): Parameters to send to the API to get the player config.\r\n        jwt_token (str): JWT token used to authenticate with the API.\r\n    \"\"\"\r\n    id = \"dsnphs\"\r\n    name = \"Disney+ (Hotstar)\"\r\n    abbreviation = \"DSNP\"\r\n    url_regex = re.compile(r\"(?i)(?P<base_url>https?://(?:www\\.)?apps\\.disneyplus\\.com/(?P<slug>(?:(?P<country_code>[a-z]{2})/)?(?:(?P<media_type>movies|shows)/)?(?:(?P<media_name>[\\w\\-%]+)/)?(?P<media_id>\\d{4,10})))(?:\\?(?P<url_params>.*))?\")  # noqa: E501\r\n    subtitles_class = WebVTTSubtitles\r\n    is_movie_scraper = True\r\n    is_series_scraper = True\r\n\r\n    _api_base_url = \"https://www.apps.disneyplus.com/api/internal/bff\"\r\n    _player_params = {\r\n        \"client_capabilities\":\r\n            {\r\n                \"audio_channel\": [\"stereo\"],\r\n                \"container\": [\"fmp4\", \"ts\"],\r\n                \"dvr\": [\"short\"],\r\n                \"dynamic_range\": [\"sdr\"],\r\n                \"encryption\": [\"widevine\", \"plain\"],\r\n                \"ladder\": [\"tv\", \"phone\"],\r\n                \"package\": [\"dash\", \"hls\"],\r\n                \"resolution\": [\"sd\", \"hd\", \"fhd\"],\r\n                \"video_codec\": [\"h264\"],\r\n            },\r\n        \"drm_parameters\":\r\n            {\r\n                \"hdcp_version\": [\"HDCP_V2_2\"],\r\n                \"widevine_security_level\": [\"SW_SECURE_DECODE\"],\r\n                \"playready_security_level\": [],\r\n            },\r\n    }\r\n\r\n    def __init__(self, user_agent: str | None = None, config_data: dict | None = None):\r\n        super().__init__(user_agent=user_agent, config_data=config_data)\r\n\r\n        # Add \"token\" setting to config\r\n        self.config.add_settings(\r\n            ConfigSetting(\r\n                key=\"token\",\r\n                value_type=str,\r\n                required=True,\r\n            ),\r\n            check_config=True)\r\n\r\n        self.jwt_token: str = self.config[\"token\"]\r\n        self._session.headers.update({\r\n            \"Accept\": \"application/json\",\r\n            \"X-Hs-Usertoken\": self.jwt_token,\r\n            \"X-Hs-Platform\": \"web\",\r\n            \"X-Hs-Client\": \"platform:web;app_version:23.05.29.0;browser:Chrome;schema_version:0.0.854\",\r\n        })\r\n        self._http2_session = httpx.Client(\r\n            http2=True,\r\n            headers={\"User-Agent\": self._user_agent},\r\n            proxy=(httpx.Proxy(url=self._proxy) if self._proxy else None),\r\n            verify=self._verify_ssl,\r\n        )\r\n\r\n    def _authenticated_get(self, url: str, additional_headers: dict | None = None, **kwargs) -> Response:\r\n        headers = self._generate_headers(url=url,\r\n                                         additional_headers=additional_headers)\r\n\r\n        response = self._session.get(url=url, headers=headers, **kwargs)\r\n        raise_for_status(response)\r\n        return response\r\n\r\n    def _generate_headers(self, url: str, additional_headers: dict | None = None) -> dict:\r\n        \"\"\"\r\n        Generate headers for a Disney+ Hotstar's API request.\r\n\r\n        Args:\r\n            url (str): URL to generate headers for.\r\n            additional_headers (dict, optional): Additional headers to add to the generated headers. Defaults to None.\r\n\r\n        Returns:\r\n            dict: Generated headers for the request.\r\n        \"\"\"\r\n        request_id = self._generate_request_id()\r\n\r\n        headers = {\r\n            **self._session.headers,\r\n            \"Host\": extract_host_from_url(url),\r\n            \"X-Request-Id\": request_id,\r\n            \"X-Hs-Request-Id\": request_id,\r\n            \"Origin\": \"https://www.apps.disneyplus.com\",\r\n            \"Referer\": \"https://www.apps.disneyplus.com/\",\r\n        }\r\n\r\n        if additional_headers:\r\n            headers.update(additional_headers)\r\n\r\n        return headers\r\n\r\n    @staticmethod\r\n    def _generate_request_id() -> str:\r\n        request_id = generate_random_hex_string(8) + '-'\r\n\r\n        for _ in range(3):\r\n            request_id += generate_random_hex_string(4) + '-'\r\n\r\n        return request_id + generate_random_hex_string(12)\r\n\r\n    def _get_api_data(self, endpoint: str) -> dict:\r\n        \"\"\"\r\n        Retrieve data from the Disney+ Hotstar's API.\r\n\r\n        Args:\r\n            endpoint (str): API endpoint.\r\n\r\n        Returns:\r\n            dict: Data returned by the API for the given endpoint.\r\n        \"\"\"\r\n        response = self._authenticated_get(f\"{self._api_base_url}/{endpoint}\")\r\n        return response.json()\r\n\r\n    def _get_media_playlists(self, media_slug: str) -> list[str]:\r\n        player_params = generate_url_params(data=self._player_params, remove_dict_spaces=True)\r\n        api_data = self._get_api_data(endpoint=f\"v2/slugs/{media_slug}/watch?{player_params}\")\r\n\r\n        player_config = (\r\n            api_data[\"success\"][\"page\"][\"spaces\"][\"player\"][\"widget_wrappers\"][0][\"widget\"][\"data\"][\"player_config\"]\r\n        )\r\n\r\n        return_data = [\r\n            player_config.get(\"media_asset_v2\", {}).get(\"primary\", {}).get(\"content_url\"),\r\n            player_config.get(\"media_asset_v2\", {}).get(\"fallback\", {}).get(\"content_url\"),\r\n        ]\r\n\r\n        return [playlist_url for playlist_url in return_data if playlist_url]\r\n\r\n    def _get_season_data(self, show_id: str, season_id: str) -> dict[int, dict]:\r\n        endpoint = f\"v2/pages/841/spaces/803/widgets/1196/widgets/168?content_id={show_id}&season_id={season_id}\"\r\n        paginated_data = []\r\n\r\n        # Get all paginated episodes data for the season\r\n        while endpoint:\r\n            api_data = self._get_api_data(endpoint)\r\n            episodes_paginated_data = api_data[\"success\"][\"widget_wrapper\"][\"widget\"][\"data\"]\r\n            paginated_data.extend(episodes_paginated_data[\"items\"])\r\n            endpoint = episodes_paginated_data.get(\"next_tray_url\")\r\n\r\n        api_episodes_data = [episode_data[\"playable_content\"][\"data\"] for episode_data in paginated_data]\r\n        result_data: dict[int, dict] = {}\r\n\r\n        for episode_data in api_episodes_data:\r\n            page_slug = episode_data[\"actions\"][\"on_click\"][1][\"page_navigation\"][\"page_slug\"].split(\"/watch\")[0]\r\n            episode_data[\"playlists\"] = self._get_media_playlists(media_slug=page_slug.lstrip(\"/\"))\r\n            episode_number = parse_season_and_episode_tag(episode_data[\"tags\"][0][\"value\"])[1]\r\n            # Remove unnecessary data\r\n            if 'actions' in episode_data:\r\n                episode_data.pop('actions')\r\n\r\n            if 'download_options' in episode_data:\r\n                episode_data.pop('download_options')\r\n\r\n            result_data[episode_number] = episode_data\r\n\r\n        return result_data\r\n\r\n    def close(self) -> None:\r\n        self._http2_session.close()\r\n        super().close()\r\n\r\n    def load_mpd(self, url: str | list[str], headers: dict | None = None) -> MPD | None:\r\n        _headers = headers or self._session.headers\r\n        _headers[\"Accept\"] = \"application/dash+xml\"\r\n\r\n        for url_item in single_to_list(url):\r\n            try:\r\n                if \"cdn.apps.disneyplus.com\" in url_item:\r\n                    response: requests.models.Response = self._session.get(url=url_item, headers=_headers)\r\n                    response.raise_for_status()\r\n\r\n                else:\r\n                    response = self._http2_session.get(url=url_item, headers=_headers)\r\n                    response.raise_for_status()\r\n\r\n            except Exception as e:\r\n                logger.debug(f\"Failed to load MPD playlist '{url_item}': {e}\")\r\n                continue\r\n\r\n            return MPD(playlist_data=response.text, uri=url_item)\r\n        return None\r\n\r\n    def get_movie_data(self, movie_slug: str) -> ScrapedMediaResponse[Movie]:\r\n        api_data = self._get_api_data(endpoint=\"v2/slugs/\" + movie_slug)\r\n        movie_data = api_data[\"success\"][\"page\"][\"spaces\"][\"hero\"][\"widget_wrappers\"][0][\"widget\"][\"data\"]\r\n\r\n        movie_name = movie_data[\"content_info\"][\"title\"]\r\n        movie_id = movie_data[\"cw_info\"][\"content_id\"]\r\n        movie_release_year = int(movie_data[\"content_info\"][\"core_meta_tags\"][0][\"value\"])\r\n        movie_duration = dt.timedelta(milliseconds=int(movie_data[\"cw_info\"][\"duration\"]))\r\n\r\n        playlists = self._get_media_playlists(media_slug=movie_slug)\r\n\r\n        return ScrapedMediaResponse(\r\n            media_data=[Movie(\r\n                name=movie_name,\r\n                id=movie_id,\r\n                release_date=movie_release_year,\r\n                duration=movie_duration,\r\n                playlist=playlists,\r\n            )],\r\n            metadata_scraper=self.id,\r\n            playlist_scraper=self.id,\r\n            original_data=api_data,\r\n        )\r\n\r\n    def get_series_data(self, show_slug: str) -> ScrapedMediaResponse[Series]:\r\n        api_data = self._get_api_data(endpoint=\"v2/slugs/\" + show_slug)\r\n        series_data = api_data[\"success\"][\"page\"][\"spaces\"][\"hero\"][\"widget_wrappers\"][0][\"widget\"][\"data\"]\r\n        seasons_data = (api_data[\"success\"][\"page\"][\"spaces\"][\"tray\"][\"widget_wrappers\"][0][\"widget\"]\r\n                        [\"data\"][\"category_picker\"][\"data\"][\"tabs\"])\r\n\r\n        series_name = series_data[\"content_info\"][\"title\"]\r\n        series_id = (series_data[\"content_actions_row\"][\"content_action_buttons\"][0]\r\n                     [\"watchlist_content_action_button\"][\"info\"][\"content_id\"])\r\n\r\n        series_seasons: list[Season] = []\r\n        result_seasons_data: dict[int, dict[int, dict]] = {}\r\n\r\n        for season_data in [season_data[\"tab\"][\"data\"] for season_data in seasons_data]:\r\n            season_number = int(season_data[\"title\"].split(\" \")[1])\r\n            url_params = parse_url_params(season_data[\"tray_widget_url\"])\r\n            season_episodes_data = self._get_season_data(show_id=url_params[\"content_id\"],\r\n                                                         season_id=url_params[\"season_id\"])\r\n            result_seasons_data[season_number] = season_episodes_data\r\n\r\n            season_episodes: list[Episode] = []\r\n\r\n            for episode_number, episode_data in season_episodes_data.items():\r\n                season_episodes.append(\r\n                    Episode(\r\n                        id=episode_data[\"cw_info\"][\"content_id\"],\r\n                        series_name=series_name,\r\n                        season_number=season_number,\r\n                        episode_number=episode_number,\r\n                        episode_name=episode_data[\"title\"],\r\n                        episode_release_date=dt.datetime.strptime(episode_data[\"tags\"][1][\"value\"], \"%d %b %Y\"),\r\n                        episode_duration=parse_duration(episode_data[\"tags\"][2][\"value\"]),\r\n                        playlist=episode_data[\"playlists\"].copy(),\r\n                    ),\r\n                )\r\n\r\n            series_seasons.append(\r\n                Season(\r\n                    id=series_id,\r\n                    series_name=series_name,\r\n                    season_number=season_number,\r\n                    release_date=None,\r\n                    episodes=season_episodes,\r\n                ))\r\n\r\n        return ScrapedMediaResponse(\r\n            media_data=[Series(\r\n                id=series_id,\r\n                series_name=series_name,\r\n                seasons=series_seasons,\r\n            )],\r\n            metadata_scraper=self.id,\r\n            playlist_scraper=self.id,\r\n            original_data=api_data,\r\n        )\r\n\r\n    def get_data(self, url: str) -> ScrapedMediaResponse[Movie] | ScrapedMediaResponse[Series]:\r\n        regex_match = self.match_url(url=url, raise_error=True)\r\n        url_data = regex_match.groupdict()\r\n\r\n        if not all(url_data.get(key) for key in (\"country_code\", \"media_type\", \"media_name\", \"media_id\")):\r\n            raise ScraperError(f\"Full URL containing the slug is required for scraping from '{self.name}'.\")\r\n\r\n        if url_data[\"media_type\"] == \"movies\":\r\n            return self.get_movie_data(movie_slug=url_data[\"slug\"])\r\n\r\n        elif url_data[\"media_type\"] == \"shows\":\r\n            return self.get_series_data(show_slug=url_data[\"slug\"])\r\n\r\n        else:\r\n            raise ScraperError(f\"Unexpected media type URL '{url_data['media_type']}' for '{self.name}'.\")\r\n\r\n    def get_subtitles(self, main_playlist: str | list[str], language_filter: list[str] | str | None = None,\r\n                      subrip_conversion: bool = False) -> Iterator[SubtitlesData | SubtitlesDownloadError]:\r\n        playlist_data = self.load_mpd(url=main_playlist, headers={})\r\n\r\n        if not playlist_data:  # No valid playlist found\r\n            raise PlaylistLoadError(\"Could not find a valid MPD playlist.\")\r\n\r\n        subtitles_period = playlist_data.get_periods(filters={\"id\": \"seq:0_0\"})[0]\r\n        for subtitles_adaptation_set in subtitles_period.get_adaptation_sets(filters={\"contentType\": \"text\",\r\n                                                                                      \"mimeType\": \"text/vtt\"}):\r\n            if language_filter and subtitles_adaptation_set.lang not in language_filter:\r\n                continue\r\n\r\n            for subtitles_representation in subtitles_adaptation_set.get_representations():\r\n                # Seems like the \"real\" subtitles are always under the \"seq:0_0\" period\r\n                # (and other periods have \"dummy\" subtitles), but this is a check just in case.\r\n                if subtitles_representation.id == \"subtitle/dummy\":\r\n                    logger.warning(\"Dummy subtitles found. Skipping...\")\r\n                    continue\r\n\r\n                subtitles_url = subtitles_representation.url\r\n                language_code = subtitles_adaptation_set.lang\r\n                subtitles_type = self.detect_subtitles_type(subtitles_adaptation_set=subtitles_adaptation_set)\r\n\r\n                try:\r\n                    subtitles_data = self._session.get(url=subtitles_url)\r\n                    subtitles = self.subtitles_class(data=subtitles_data.content, language_code=language_code)\r\n\r\n                    subtitles.polish(\r\n                        fix_rtl=self.subtitles_fix_rtl,\r\n                        remove_duplicates=self.subtitles_remove_duplicates,\r\n                    )\r\n\r\n                    if subrip_conversion:\r\n                        subtitles_format = SubtitlesFormatType.SUBRIP\r\n                        content = subtitles.to_srt().dump()\r\n\r\n                    else:\r\n                        subtitles_format = SubtitlesFormatType.WEBVTT\r\n                        content = subtitles.dump()\r\n\r\n                    yield SubtitlesData(\r\n                        language_code=language_code,\r\n                        language_name=None,\r\n                        subtitles_format=subtitles_format,\r\n                        content=content,\r\n                        content_encoding=subtitles.encoding,\r\n                        special_type=subtitles_type,\r\n                    )\r\n\r\n                except Exception as e:\r\n                    yield SubtitlesDownloadError(\r\n                        language_code=language_code,\r\n                        language_name=None,\r\n                        special_type=subtitles_type,\r\n                        original_exc=e,\r\n                    )\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/scrapers/disneyplus_hotstar_scraper.py b/isubrip/scrapers/disneyplus_hotstar_scraper.py
--- a/isubrip/scrapers/disneyplus_hotstar_scraper.py	(revision 9c3a45d3a5a34e6855721f59c81f9ff6e8b1828a)
+++ b/isubrip/scrapers/disneyplus_hotstar_scraper.py	(date 1720612285450)
@@ -17,7 +17,7 @@
     SubtitlesFormatType,
 )
 from isubrip.logger import logger
-from isubrip.parsers.mpeg_dash import MPD
+from isubrip.parsers.mpeg_dash import MPD, AdaptationSet
 from isubrip.scrapers.scraper import DASHScraper, PlaylistLoadError, ScraperError, SubtitlesDownloadError
 from isubrip.subtitle_formats.webvtt import WebVTTSubtitles
 from isubrip.utils import (
@@ -325,6 +325,7 @@
 
     def get_subtitles(self, main_playlist: str | list[str], language_filter: list[str] | str | None = None,
                       subrip_conversion: bool = False) -> Iterator[SubtitlesData | SubtitlesDownloadError]:
+        # TODO: Move to mpeg_dash parser
         playlist_data = self.load_mpd(url=main_playlist, headers={})
 
         if not playlist_data:  # No valid playlist found
@@ -380,3 +381,12 @@
                         special_type=subtitles_type,
                         original_exc=e,
                     )
+
+    def parse_language_name(self, media_data: AdaptationSet) -> str | None:
+        # TODO
+        name: str | None = media_data.name
+
+        if name:
+            return name.replace(' (forced)', '').strip()
+
+        return None
\ No newline at end of file
Index: isubrip/scripts/release_date_check.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\nfrom contextlib import suppress\r\nfrom dataclasses import dataclass\r\nimport sys\r\nfrom typing import TYPE_CHECKING, Any, Iterator\r\n\r\nfrom rich.console import Console\r\nfrom rich.progress import (\r\n    BarColumn,\r\n    MofNCompleteColumn,\r\n    Progress,\r\n    SpinnerColumn,\r\n    TaskProgressColumn,\r\n    TextColumn,\r\n    TimeElapsedColumn,\r\n)\r\nfrom rich.table import Table\r\n\r\nfrom isubrip.scrapers.appletv_scraper import AppleTVScraper\r\nfrom isubrip.scrapers.itunes_scraper import ItunesScraper\r\nfrom isubrip.scrapers.scraper import PlaylistLoadError\r\n\r\nif TYPE_CHECKING:\r\n    import datetime as dt\r\n\r\n    from m3u8.model import M3U8\r\n\r\n    from isubrip.data_structures import Movie\r\n\r\nUSER_AGENT = (\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) \"\r\n              \"Chrome/100.0.4896.127 Safari/537.36\")\r\n\r\n\r\n@dataclass\r\nclass AppleTVResult:\r\n    movie_data: Movie | None\r\n    storefront: str\r\n    released: bool\r\n    release_date: dt.datetime | None = None\r\n\r\n\r\ndef main():\r\n    apple_tv_scraper = AppleTVScraper(user_agent=USER_AGENT)\r\n    itunes_scraper = ItunesScraper(user_agent=USER_AGENT)\r\n\r\n    console = Console()\r\n\r\n    if len(sys.argv) != 2:\r\n        print(\"Usage: generate_release_dates_report.py <AppleTV URL>\")\r\n        sys.exit(1)\r\n\r\n    url = sys.argv[1]\r\n\r\n    released_items: list[AppleTVResult] = []\r\n    unreleased_items_with_release_date: list[AppleTVResult] = []\r\n    unknown_release_items: list[AppleTVResult] = []\r\n    no_store_page_items: list[AppleTVResult] = []\r\n\r\n    with Progress(\r\n            SpinnerColumn(),\r\n            TextColumn(\"[progress.description]{task.description}\"),\r\n            BarColumn(),\r\n            MofNCompleteColumn(),\r\n            TaskProgressColumn(),\r\n            TimeElapsedColumn(),\r\n            console=console,\r\n            transient=False,\r\n    ) as progress:\r\n        task = progress.add_task(\"[bold green]Fetching data from all storefronts[/bold green]\",\r\n                                 total=len(apple_tv_scraper.storefronts_mapping.keys()))\r\n\r\n        for results_list in fetch_movie_from_all_storefronts(apple_tv_scraper=apple_tv_scraper,\r\n                                                             itunes_scraper=itunes_scraper, url=url):\r\n            for result_item in results_list:\r\n                if result_item.movie_data is None:\r\n                    no_store_page_items.append(result_item)\r\n\r\n                elif result_item.released is True:\r\n                    released_items.append(result_item)\r\n\r\n                elif result_item.released is False:\r\n                    unreleased_items_with_release_date.append(result_item)\r\n\r\n                elif result_item.released is None:\r\n                    unknown_release_items.append(result_item)\r\n\r\n            progress.advance(task)\r\n\r\n    # Released Items Table:\r\n    if len(released_items) > 0:\r\n        released_items_table = create_released_results_table(\r\n            itunes_scraper=itunes_scraper,\r\n            result_items=released_items,\r\n        )\r\n        console.print(\"[bold green]Released Items:[/bold green]\")\r\n        console.print(released_items_table)\r\n\r\n    # Unreleased Items Table:\r\n    if len(unreleased_items_with_release_date) > 0:\r\n        unreleased_items_with_release_date_table = create_unreleased_results_table(\r\n            itunes_scraper=itunes_scraper,\r\n            result_items=unreleased_items_with_release_date,\r\n        )\r\n        console.print(\"[bold yellow]Unreleased Items:[/bold yellow]\")\r\n        console.print(unreleased_items_with_release_date_table)\r\n\r\n\r\ndef fetch_movie_from_all_storefronts(apple_tv_scraper: AppleTVScraper,\r\n                                     itunes_scraper: ItunesScraper, url: str) -> Iterator[list[AppleTVResult]]:\r\n    regex_match = apple_tv_scraper.match_url(url=url, raise_error=True)\r\n    regex_extracted_data = regex_match.groupdict()\r\n    movie_id = str(regex_extracted_data[\"media_id\"])\r\n    original_storefront = str(regex_extracted_data[\"country_code\"]).upper()\r\n\r\n    if regex_extracted_data[\"media_type\"] != \"movie\":\r\n        exit(\"Provided URL is not a movie URL.\")\r\n\r\n    storefronts = set(apple_tv_scraper.storefronts_mapping.keys())\r\n\r\n    with suppress(KeyError):\r\n        storefronts.remove(original_storefront)\r\n\r\n    with suppress(Exception):\r\n        yield fetch_movie_from_storefront(\r\n            apple_tv_scraper=apple_tv_scraper,\r\n            itunes_scraper=itunes_scraper,\r\n            movie_id=movie_id,\r\n            storefront=original_storefront,\r\n        )\r\n\r\n    for storefront in storefronts:\r\n        yield fetch_movie_from_storefront(\r\n            apple_tv_scraper=apple_tv_scraper,\r\n            itunes_scraper=itunes_scraper,\r\n            movie_id=movie_id,\r\n            storefront=storefront,\r\n        )\r\n\r\n\r\ndef fetch_movie_from_storefront(apple_tv_scraper: AppleTVScraper, itunes_scraper: ItunesScraper,\r\n                                movie_id: str, storefront: str) -> list[AppleTVResult] | None:\r\n    storefront_id = apple_tv_scraper.storefronts_mapping[storefront]\r\n\r\n    try:\r\n        response = apple_tv_scraper.get_movie_data(\r\n            storefront_id=storefront_id,\r\n            movie_id=movie_id,\r\n        )\r\n\r\n    except Exception:  # Movie is not available in this storefront\r\n        return [\r\n            AppleTVResult(\r\n                movie_data=None,\r\n                storefront=storefront,\r\n                released=False,\r\n                release_date=None,\r\n            ),\r\n        ]\r\n\r\n    results: list[AppleTVResult] = []\r\n\r\n    for movie_data in response.media_data:\r\n        if movie_data.playlist:\r\n            try:\r\n                playlist = itunes_scraper.load_m3u8(url=movie_data.playlist)\r\n\r\n            except Exception:\r\n                playlist = None\r\n\r\n        else:\r\n            playlist = None\r\n\r\n        results.append(\r\n            AppleTVResult(\r\n                movie_data=movie_data,\r\n                storefront=storefront,\r\n                released=determine_release_status(movie_data=movie_data, loaded_playlist=playlist),\r\n                release_date=movie_data.preorder_availability_date,\r\n            ),\r\n        )\r\n\r\n    return results\r\n\r\n\r\ndef determine_release_status(movie_data: Movie, loaded_playlist: M3U8 | None) -> bool | None:\r\n    if bool(loaded_playlist):\r\n        return True\r\n\r\n    else:\r\n        if movie_data.preorder_availability_date:\r\n            return False\r\n\r\n        return None\r\n\r\n\r\ndef create_released_results_table(itunes_scraper: ItunesScraper, result_items: list[AppleTVResult]) -> Table:\r\n    result_items = sorted(result_items, key=lambda item: item.storefront)\r\n    result_items_table = Table(show_header=True, header_style=\"bold green\", show_lines=True)\r\n    result_items_table.add_column(\"iTunes ID\")\r\n    result_items_table.add_column(\"Storefronts\")\r\n    result_items_table.add_column(\"Available Languages\")\r\n\r\n    id_mapping: dict[str, dict[str, Any]] = {}\r\n\r\n    for result in result_items:\r\n        result_id = result.movie_data.id\r\n\r\n        if result_id in id_mapping:\r\n            id_mapping[result_id][\"storefronts\"].append(result.storefront)\r\n\r\n            if id_mapping[result_id][\"languages\"] is None:\r\n                try:\r\n                    available_languages = list_available_subtitles_languages(\r\n                        itunes_scraper=itunes_scraper,\r\n                        main_playlist=result.movie_data.playlist,\r\n                    )\r\n\r\n                except PlaylistLoadError:\r\n                    available_languages = None\r\n\r\n                id_mapping[result_id][\"languages\"] = available_languages\r\n\r\n        else:\r\n            try:\r\n                available_languages = sorted(list_available_subtitles_languages(\r\n                    itunes_scraper=itunes_scraper,\r\n                    main_playlist=result.movie_data.playlist,\r\n                ))\r\n\r\n            except PlaylistLoadError:\r\n                available_languages = None\r\n\r\n            id_mapping[result_id] = {\r\n                \"storefronts\": [result.storefront],\r\n                \"languages\": available_languages if available_languages else [],\r\n            }\r\n\r\n    for result_id, data in id_mapping.items():\r\n        if data[\"languages\"] is None:\r\n            languages_str = \"Could not load languages.\"\r\n\r\n        else:\r\n            languages_str = \", \".join(data[\"languages\"])\r\n\r\n        result_items_table.add_row(\r\n            result_id,\r\n            \", \".join(data[\"storefronts\"]),\r\n            languages_str,\r\n        )\r\n\r\n    return result_items_table\r\n\r\n\r\ndef create_unreleased_results_table(itunes_scraper: ItunesScraper, result_items: list[AppleTVResult]) -> Table:\r\n    result_items = sorted(result_items, key=lambda item: item.storefront)\r\n    result_items_table = Table(show_header=True, header_style=\"bold green\", show_lines=True)\r\n    result_items_table.add_column(\"iTunes ID\")\r\n    result_items_table.add_column(\"Storefronts\")\r\n    result_items_table.add_column(\"Release Date\")\r\n    result_items_table.add_column(\"Available Languages\")\r\n\r\n    id_languages_mapping: dict[str, list[str] | None] = {}\r\n    results: list[dict[str, Any]] = []\r\n\r\n    for result in result_items:\r\n        result_id = result.movie_data.id\r\n\r\n        if result_id in id_languages_mapping:\r\n            available_languages = id_languages_mapping[result_id]\r\n\r\n            if id_languages_mapping[result_id] is None:\r\n                try:\r\n                    available_languages = list_available_subtitles_languages(\r\n                        itunes_scraper=itunes_scraper,\r\n                        main_playlist=result.movie_data.playlist,\r\n                    )\r\n                    id_languages_mapping[result_id] = available_languages\r\n\r\n                except PlaylistLoadError:\r\n                    pass\r\n\r\n        else:\r\n            try:\r\n                id_languages_mapping[result_id] = sorted(list_available_subtitles_languages(\r\n                    itunes_scraper=itunes_scraper,\r\n                    main_playlist=result.movie_data.playlist,\r\n                ))\r\n                available_languages = id_languages_mapping[result_id]\r\n\r\n            except PlaylistLoadError:\r\n                available_languages = None\r\n\r\n        results.append({\r\n            \"id\": result_id,\r\n            \"storefronts\": [result.storefront],\r\n            \"release_date\": result.release_date,\r\n            \"languages\": available_languages,\r\n        })\r\n\r\n    results = sorted(results, key=lambda x: x[\"release_date\"])\r\n\r\n    for result in results:\r\n        if result[\"languages\"] is None:\r\n            languages_str = \"Could not load languages.\"\r\n\r\n        else:\r\n            languages_str = \", \".join(result[\"languages\"])\r\n\r\n        result_items_table.add_row(\r\n            result[\"id\"],\r\n            \", \".join(result[\"storefronts\"]),\r\n            result[\"release_date\"].strftime(\"%Y-%m-%d\"),\r\n            languages_str,\r\n        )\r\n\r\n    return result_items_table\r\n\r\n\r\ndef list_available_subtitles_languages(itunes_scraper: ItunesScraper,\r\n                                       main_playlist: str | list[str]) -> list[str]:\r\n    main_playlist_m3u8 = itunes_scraper.load_m3u8(url=main_playlist)\r\n\r\n    if main_playlist_m3u8 is None:\r\n        raise PlaylistLoadError(\"Could not load M3U8 playlist.\")\r\n\r\n    playlist_results = itunes_scraper.get_media_playlists(main_playlist=main_playlist_m3u8,\r\n                                                          playlist_filters=itunes_scraper._subtitles_filters)\r\n\r\n    return list({\r\n        f\"{result.name} ({result.language})\" for result in playlist_results\r\n        if None not in (result.name, result.language)\r\n    })\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/isubrip/scripts/release_date_check.py b/isubrip/scripts/release_date_check.py
--- a/isubrip/scripts/release_date_check.py	(revision 9c3a45d3a5a34e6855721f59c81f9ff6e8b1828a)
+++ b/isubrip/scripts/release_date_check.py	(date 1721057494353)
@@ -1,5 +1,6 @@
 from __future__ import annotations
 
+import asyncio
 from contextlib import suppress
 from dataclasses import dataclass
 import sys
@@ -17,6 +18,7 @@
 )
 from rich.table import Table
 
+from isubrip.constants import EVENT_LOOP
 from isubrip.scrapers.appletv_scraper import AppleTVScraper
 from isubrip.scrapers.itunes_scraper import ItunesScraper
 from isubrip.scrapers.scraper import PlaylistLoadError
@@ -70,8 +72,15 @@
         task = progress.add_task("[bold green]Fetching data from all storefronts[/bold green]",
                                  total=len(apple_tv_scraper.storefronts_mapping.keys()))
 
-        for results_list in fetch_movie_from_all_storefronts(apple_tv_scraper=apple_tv_scraper,
-                                                             itunes_scraper=itunes_scraper, url=url):
+        results_lists = EVENT_LOOP.run_until_complete(
+            fetch_movie_from_all_storefronts(
+                apple_tv_scraper=apple_tv_scraper,
+                itunes_scraper=itunes_scraper,
+                url=url,
+            )
+        )
+
+        for results_list in results_lists:
             for result_item in results_list:
                 if result_item.movie_data is None:
                     no_store_page_items.append(result_item)
@@ -106,8 +115,8 @@
         console.print(unreleased_items_with_release_date_table)
 
 
-def fetch_movie_from_all_storefronts(apple_tv_scraper: AppleTVScraper,
-                                     itunes_scraper: ItunesScraper, url: str) -> Iterator[list[AppleTVResult]]:
+async def fetch_movie_from_all_storefronts(apple_tv_scraper: AppleTVScraper,
+                                     itunes_scraper: ItunesScraper, url: str) -> list[AppleTVResult | None]:
     regex_match = apple_tv_scraper.match_url(url=url, raise_error=True)
     regex_extracted_data = regex_match.groupdict()
     movie_id = str(regex_extracted_data["media_id"])
@@ -121,29 +130,37 @@
     with suppress(KeyError):
         storefronts.remove(original_storefront)
 
+    results: list[AppleTVResult | None] = []
+
     with suppress(Exception):
-        yield fetch_movie_from_storefront(
-            apple_tv_scraper=apple_tv_scraper,
-            itunes_scraper=itunes_scraper,
-            movie_id=movie_id,
-            storefront=original_storefront,
+        results.append(
+            await fetch_movie_from_storefront(
+                apple_tv_scraper=apple_tv_scraper,
+                itunes_scraper=itunes_scraper,
+                movie_id=movie_id,
+                storefront=original_storefront,
+            )
         )
 
-    for storefront in storefronts:
-        yield fetch_movie_from_storefront(
+    results_coroutines = [
+        fetch_movie_from_storefront(
             apple_tv_scraper=apple_tv_scraper,
             itunes_scraper=itunes_scraper,
             movie_id=movie_id,
             storefront=storefront,
-        )
+        ) for storefront in storefronts
+    ]
 
+    results.extend(await asyncio.gather(*results_coroutines))
+    return results
 
-def fetch_movie_from_storefront(apple_tv_scraper: AppleTVScraper, itunes_scraper: ItunesScraper,
-                                movie_id: str, storefront: str) -> list[AppleTVResult] | None:
+
+async def fetch_movie_from_storefront(apple_tv_scraper: AppleTVScraper, itunes_scraper: ItunesScraper,
+                                      movie_id: str, storefront: str) -> list[AppleTVResult] | None:
     storefront_id = apple_tv_scraper.storefronts_mapping[storefront]
 
     try:
-        response = apple_tv_scraper.get_movie_data(
+        response = await apple_tv_scraper.get_movie_data(
             storefront_id=storefront_id,
             movie_id=movie_id,
         )
@@ -163,7 +180,7 @@
     for movie_data in response.media_data:
         if movie_data.playlist:
             try:
-                playlist = itunes_scraper.load_m3u8(url=movie_data.playlist)
+                playlist = itunes_scraper.load_playlist(url=movie_data.playlist)
 
             except Exception:
                 playlist = None
@@ -319,13 +336,12 @@
 
 def list_available_subtitles_languages(itunes_scraper: ItunesScraper,
                                        main_playlist: str | list[str]) -> list[str]:
-    main_playlist_m3u8 = itunes_scraper.load_m3u8(url=main_playlist)
+    main_playlist_m3u8 = itunes_scraper.load_playlist(url=main_playlist)
 
     if main_playlist_m3u8 is None:
         raise PlaylistLoadError("Could not load M3U8 playlist.")
 
-    playlist_results = itunes_scraper.get_media_playlists(main_playlist=main_playlist_m3u8,
-                                                          playlist_filters=itunes_scraper._subtitles_filters)
+    playlist_results = itunes_scraper.find_matching_subtitles(main_playlist=main_playlist_m3u8)
 
     return list({
         f"{result.name} ({result.language})" for result in playlist_results
