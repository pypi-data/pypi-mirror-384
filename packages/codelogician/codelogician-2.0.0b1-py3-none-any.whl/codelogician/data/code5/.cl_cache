{
  "src_dir_abs_path": "/Users/denisignatovich/Src/cl-main/src/code_logician_server/data/code5",
  "language": "Python",
  "sketches": {
    "sketches": {}
  },
  "tasks": [],
  "meta_cache": {
    "cache": []
  },
  "strat_id": "44361a39",
  "curr_meta_model": {
    "src_dir_abs_path": "/Users/denisignatovich/Src/cl-main/src/code_logician_server/data/code5",
    "models": {
      "one.py": {
        "rel_path": "one.py",
        "src_code": "\n\n\nclass MyClass:\n\n    def __init__(self, a, b, c):\n        self._a = a\n        self._b = b\n        self._c = c\n\n    def compute(self, d):\n        return self._a * d + self._b + self._c\n    \n\n# Prove that this function always returns a positive value\ndef george_function(a : int, b : int):\n    if a > 0:\n        return a * 100\n    if b < 0: return b * -20\n\n    return 101\n\n# Decompose this\ndef other_function(a : int):\n\n    if a < -100:\n        if a > -25: return -123\n    elif a < 10:\n        return a + 200\n    else:\n        350\n",
        "src_code_last_changed": null,
        "src_language": "Python",
        "agent_state": {
          "status": "transparent",
          "src_code": "\n\n\nclass MyClass:\n\n    def __init__(self, a, b, c):\n        self._a = a\n        self._b = b\n        self._c = c\n\n    def compute(self, d):\n        return self._a * d + self._b + self._c\n    \n\n# Prove that this function always returns a positive value\ndef george_function(a : int, b : int):\n    if a > 0:\n        return a * 100\n    if b < 0: return b * -20\n\n    return 101\n\n# Decompose this\ndef other_function(a : int):\n\n    if a < -100:\n        if a > -25: return -123\n    elif a < 10:\n        return a + 200\n    else:\n        350\n",
          "iml_code": "type my_class = {\n  a : int;\n  b : int;\n  c : int;\n}\n\nlet make_my_class a b c = { a = a; b = b; c = c }\n\nlet compute obj d = obj.a * d + obj.b + obj.c\n\nlet george_function a b =\n  if a > 0 then\n    a * 100\n  else if b < 0 then\n    b * (-20)\n  else\n    101\n\nlet other_function a =\n  if a < -100 then\n    if a > -25 then -123\n    else 0\n  else if a < 10 then\n    a + 200\n  else\n    350",
          "vgs": [
            {
              "raw": {
                "src_func_names": [
                  "george_function"
                ],
                "iml_func_names": [
                  "george_function"
                ],
                "description": "Prove that this function always returns a positive value",
                "logical_statement": "for all a, b in george_function(a, b) > 0"
              },
              "data": {
                "predicate": "fun a b -> george_function a b > 0",
                "kind": "verify"
              },
              "res": {
                "unknown": null,
                "err": null,
                "proved": {
                  "proof_pp": "{ id = 1;\n  concl =\n  \n  |----------------------------------------------------------------------\n   george_function a b > 0\n  ;\n  view =\n  T_deduction {\n    premises =\n    [(\"p\",\n      [{ id = 0;\n         concl =\n         \n         |----------------------------------------------------------------------\n          george_function a b > 0\n         ; view = T_deduction {premises = []} }\n        ])\n      ]}\n  }"
                },
                "refuted": null,
                "verified_upto": null,
                "errors": [],
                "task": null
              }
            }
          ],
          "region_decomps": [
            {
              "raw": {
                "description": "Decompose this function",
                "src_func_name": "other_function",
                "iml_func_name": "other_function"
              },
              "data": {
                "name": "other_function",
                "assuming": null,
                "basis": null,
                "rule_specs": null,
                "prune": true,
                "ctx_simp": true,
                "lift_bool": null,
                "timeout": null,
                "str_": true
              },
              "res": {
                "artifact": null,
                "err": null,
                "errors": [],
                "task": null,
                "regions_str": [
                  {
                    "model_eval_str": "350",
                    "constraints_str": [
                      "a >= 10"
                    ],
                    "invariant_str": "350",
                    "model_str": {
                      "a": "10"
                    }
                  },
                  {
                    "model_eval_str": "200",
                    "constraints_str": [
                      "a >= (-100)",
                      "a <= 9"
                    ],
                    "invariant_str": "a + 200",
                    "model_str": {
                      "a": "0"
                    }
                  },
                  {
                    "model_eval_str": "0",
                    "constraints_str": [
                      "a <= (-101)"
                    ],
                    "invariant_str": "0",
                    "model_str": {
                      "a": "(-101)"
                    }
                  }
                ]
              },
              "test_cases": null
            }
          ],
          "opaque_funcs": [],
          "context": ""
        },
        "context": null,
        "outstanding_task_ID": null,
        "dependencies": [],
        "rev_dependencies": [],
        "formalized_deps": [],
        "formalized_context": ""
      },
      "three.py": {
        "rel_path": "three.py",
        "src_code": "\n\n\nclass MyClass:\n\n    def __init__(self, a, b, c):\n        self._a = a\n        self._b = b\n        self._c = c\n\n    def compute(self, d):\n        return self._a * d + self._b + self._c\n    \n\n# Prove that this function always returns a positive value\ndef david_function(a : int, b : int):\n    if a > 0:\n        return a * 100\n    if b < 0: return b * -20\n\n    return 101\n\n# Prove that the following function always returns 2 * x where x is the input\ndef difficult_function(a : int):\n    return a * 2\n\n# Decompose this\ndef other_function(a : int):\n\n    if a < -100:\n        if a > -25: return -123\n    elif a < 10:\n        return a + 200\n    else:\n        350\n\n# Decompose this\ndef other_function2(b : int):\n    if a < -100:\n        if a > -25: return -123\n    elif a < 10:\n        return a + 200\n    else:\n        350\n\n# Decompose this\ndef other_function3(b : int):\n    if a < -100:\n        if a > -25: return -123\n    elif a < 10:\n        return a + 200\n    else:\n        350\n\n# Decompose this\ndef other_function4(b : int):\n    if a < -100:\n        if a > -25: return -123\n    elif a < 10:\n        return a + 200\n    else:\n        350\n# HELLLLO",
        "src_code_last_changed": null,
        "src_language": "Python",
        "agent_state": {
          "status": "transparent",
          "src_code": "\n\n\nclass MyClass:\n\n    def __init__(self, a, b, c):\n        self._a = a\n        self._b = b\n        self._c = c\n\n    def compute(self, d):\n        return self._a * d + self._b + self._c\n    \n\n# Prove that this function always returns a positive value\ndef david_function(a : int, b : int):\n    if a > 0:\n        return a * 100\n    if b < 0: return b * -20\n\n    return 101\n\n# Prove that the following function always returns 2 * x where x is the input\ndef difficult_function(a : int):\n    return a * 2\n\n# Decompose this\ndef other_function(a : int):\n\n    if a < -100:\n        if a > -25: return -123\n    elif a < 10:\n        return a + 200\n    else:\n        350\n\n# Decompose this\ndef other_function2(b : int):\n    if a < -100:\n        if a > -25: return -123\n    elif a < 10:\n        return a + 200\n    else:\n        350\n\n# Decompose this\ndef other_function3(b : int):\n    if a < -100:\n        if a > -25: return -123\n    elif a < 10:\n        return a + 200\n    else:\n        350\n\n# Decompose this\ndef other_function4(b : int):\n    if a < -100:\n        if a > -25: return -123\n    elif a < 10:\n        return a + 200\n    else:\n        350\n# HELLLLO",
          "iml_code": "type my_class = {\n  a : int;\n  b : int;\n  c : int;\n}\n\nlet make_my_class (a : int) (b : int) (c : int) : my_class =\n  { a = a; b = b; c = c }\n\nlet compute (obj : my_class) (d : int) : int =\n  obj.a * d + obj.b + obj.c\n\n(* Prove that this function always returns a positive value *)\nlet david_function (a : int) (b : int) : int =\n  if a > 0 then\n    a * 100\n  else if b < 0 then\n    b * -20\n  else\n    101\n\n(* Prove that the following function always returns 2 * x where x is the input *)\nlet difficult_function (a : int) : int =\n  a * 2\n\nlet handle_very_negative_case (a : int) : int option =\n  if a < -100 then\n    if a > -25 then\n      Some (-123)\n    else\n      None\n  else\n    None\n\nlet handle_small_positive_case (a : int) : int option =\n  if a < 10 then\n    Some (a + 200)\n  else\n    None\n\nlet handle_default_case () : int =\n  350\n\n(* Decompose this *)\nlet other_function (a : int) : int option =\n  match handle_very_negative_case a with\n  | Some result -> Some result\n  | None ->\n    match handle_small_positive_case a with\n    | Some result -> Some result\n    | None -> Some (handle_default_case ())\n\n(* Decompose this *)\nlet other_function2 (b : int) : int option =\n  match handle_very_negative_case b with\n  | Some result -> Some result\n  | None ->\n    match handle_small_positive_case b with\n    | Some result -> Some result\n    | None -> Some (handle_default_case ())\n\n(* Decompose this *)\nlet other_function3 (b : int) : int option =\n  match handle_very_negative_case b with\n  | Some result -> Some result\n  | None ->\n    match handle_small_positive_case b with\n    | Some result -> Some result\n    | None -> Some (handle_default_case ())\n\n(* Decompose this *)\nlet other_function4 (b : int) : int option =\n  match handle_very_negative_case b with\n  | Some result -> Some result\n  | None ->\n    match handle_small_positive_case b with\n    | Some result -> Some result\n    | None -> Some (handle_default_case ())\n\n(* HELLLLO *)\n\nlet main () : unit =\n  ()",
          "vgs": [
            {
              "raw": {
                "src_func_names": [
                  "david_function"
                ],
                "iml_func_names": [
                  "david_function"
                ],
                "description": "Prove that this function always returns a positive value",
                "logical_statement": "for all a, b in david_function(a, b) > 0"
              },
              "data": {
                "predicate": "fun a b -> david_function a b > 0",
                "kind": "verify"
              },
              "res": {
                "unknown": null,
                "err": null,
                "proved": {
                  "proof_pp": "{ id = 1;\n  concl =\n  \n  |----------------------------------------------------------------------\n   david_function a b > 0\n  ;\n  view =\n  T_deduction {\n    premises =\n    [(\"p\",\n      [{ id = 0;\n         concl =\n         \n         |----------------------------------------------------------------------\n          david_function a b > 0\n         ; view = T_deduction {premises = []} }\n        ])\n      ]}\n  }"
                },
                "refuted": null,
                "verified_upto": null,
                "errors": [],
                "task": null
              }
            },
            {
              "raw": {
                "src_func_names": [
                  "difficult_function"
                ],
                "iml_func_names": [
                  "difficult_function"
                ],
                "description": "Prove that the following function always returns 2 * x where x is the input",
                "logical_statement": "for all a in difficult_function(a) = 2 * a"
              },
              "data": {
                "predicate": "fun a -> difficult_function a = 2 * a",
                "kind": "verify"
              },
              "res": {
                "unknown": null,
                "err": null,
                "proved": {
                  "proof_pp": "{ id = 1;\n  concl =\n  \n  |----------------------------------------------------------------------\n   difficult_function a =<int> 2 * a\n  ;\n  view =\n  T_deduction {\n    premises =\n    [(\"p\",\n      [{ id = 0;\n         concl =\n         \n         |----------------------------------------------------------------------\n          difficult_function a =<int> 2 * a\n         ; view = T_deduction {premises = []} }\n        ])\n      ]}\n  }"
                },
                "refuted": null,
                "verified_upto": null,
                "errors": [],
                "task": null
              }
            }
          ],
          "region_decomps": [
            {
              "raw": {
                "description": "Decompose this",
                "src_func_name": "other_function",
                "iml_func_name": "other_function"
              },
              "data": {
                "name": "other_function",
                "assuming": null,
                "basis": null,
                "rule_specs": null,
                "prune": true,
                "ctx_simp": true,
                "lift_bool": null,
                "timeout": null,
                "str_": true
              },
              "res": null,
              "test_cases": null
            },
            {
              "raw": {
                "description": "Decompose this",
                "src_func_name": "other_function2",
                "iml_func_name": "other_function2"
              },
              "data": {
                "name": "other_function2",
                "assuming": null,
                "basis": null,
                "rule_specs": null,
                "prune": true,
                "ctx_simp": true,
                "lift_bool": null,
                "timeout": null,
                "str_": true
              },
              "res": null,
              "test_cases": null
            },
            {
              "raw": {
                "description": "Decompose this",
                "src_func_name": "other_function3",
                "iml_func_name": "other_function3"
              },
              "data": {
                "name": "other_function3",
                "assuming": null,
                "basis": null,
                "rule_specs": null,
                "prune": true,
                "ctx_simp": true,
                "lift_bool": null,
                "timeout": null,
                "str_": true
              },
              "res": null,
              "test_cases": null
            },
            {
              "raw": {
                "description": "Decompose this",
                "src_func_name": "other_function4",
                "iml_func_name": "other_function4"
              },
              "data": {
                "name": "other_function4",
                "assuming": null,
                "basis": null,
                "rule_specs": null,
                "prune": true,
                "ctx_simp": true,
                "lift_bool": null,
                "timeout": null,
                "str_": true
              },
              "res": {
                "artifact": null,
                "err": null,
                "errors": [],
                "task": null,
                "regions_str": [
                  {
                    "model_eval_str": "Some 350",
                    "constraints_str": [
                      "b >= 10"
                    ],
                    "invariant_str": "Some 350",
                    "model_str": {
                      "b": "10"
                    }
                  },
                  {
                    "model_eval_str": "Some 99",
                    "constraints_str": [
                      "b <= (-101)"
                    ],
                    "invariant_str": "Some (b + 200)",
                    "model_str": {
                      "b": "(-101)"
                    }
                  },
                  {
                    "model_eval_str": "Some 200",
                    "constraints_str": [
                      "b >= (-100)",
                      "b <= 9"
                    ],
                    "invariant_str": "Some (b + 200)",
                    "model_str": {
                      "b": "0"
                    }
                  }
                ]
              },
              "test_cases": null
            }
          ],
          "opaque_funcs": [],
          "context": ""
        },
        "context": null,
        "outstanding_task_ID": null,
        "dependencies": [],
        "rev_dependencies": [],
        "formalized_deps": [],
        "formalized_context": ""
      },
      "two.py": {
        "rel_path": "two.py",
        "src_code": "\n\n\nclass MyClass:\n\n    def __init__(self, a, b, c):\n        self._a = a\n        self._b = b\n        self._c = c\n\n    def compute(self, d):\n        return self._a * d + self._b + self._c\n    \n\n# Prove that this function always returns a positive value\ndef mary_function(a : int, b : int):\n    if a > 0:\n        return a * 100\n    if b < 0: return b * -20\n\n    return 101\n\n# Decompose this\ndef denis_function(a : int):\n\n    if a < -100:\n        if a > -25: return -123\n    elif a < 10:\n        return a + 200\n    else:\n        350\n\n# HHHHH",
        "src_code_last_changed": null,
        "src_language": "Python",
        "agent_state": {
          "status": "transparent",
          "src_code": "\n\n\nclass MyClass:\n\n    def __init__(self, a, b, c):\n        self._a = a\n        self._b = b\n        self._c = c\n\n    def compute(self, d):\n        return self._a * d + self._b + self._c\n    \n\n# Prove that this function always returns a positive value\ndef mary_function(a : int, b : int):\n    if a > 0:\n        return a * 100\n    if b < 0: return b * -20\n\n    return 101\n\n# Decompose this\ndef denis_function(a : int):\n\n    if a < -100:\n        if a > -25: return -123\n    elif a < 10:\n        return a + 200\n    else:\n        350\n\n# HHHHH",
          "iml_code": "type my_class = {\n  a : int;\n  b : int;\n  c : int;\n}\n\nlet make_my_class a b c = { a = a; b = b; c = c }\n\nlet compute obj d = obj.a * d + obj.b + obj.c\n\nlet mary_function a b =\n  if a > 0 then\n    a * 100\n  else if b < 0 then\n    b * (-20)\n  else\n    101\n\nlet denis_function a =\n  if a < (-100) then\n    if a > (-25) then (-123)\n    else 0\n  else if a < 10 then\n    a + 200\n  else\n    350",
          "vgs": [
            {
              "raw": {
                "src_func_names": [
                  "mary_function"
                ],
                "iml_func_names": [
                  "mary_function"
                ],
                "description": "Prove that this function always returns a positive value",
                "logical_statement": "for all a, b in mary_function(a, b) > 0"
              },
              "data": {
                "predicate": "fun a b -> mary_function a b > 0",
                "kind": "verify"
              },
              "res": {
                "unknown": null,
                "err": null,
                "proved": {
                  "proof_pp": "{ id = 1;\n  concl =\n  \n  |----------------------------------------------------------------------\n   mary_function a b > 0\n  ;\n  view =\n  T_deduction {\n    premises =\n    [(\"p\",\n      [{ id = 0;\n         concl =\n         \n         |----------------------------------------------------------------------\n          mary_function a b > 0\n         ; view = T_deduction {premises = []} }\n        ])\n      ]}\n  }"
                },
                "refuted": null,
                "verified_upto": null,
                "errors": [],
                "task": null
              }
            }
          ],
          "region_decomps": [
            {
              "raw": {
                "description": "Decompose this function",
                "src_func_name": "denis_function",
                "iml_func_name": "denis_function"
              },
              "data": {
                "name": "denis_function",
                "assuming": null,
                "basis": null,
                "rule_specs": null,
                "prune": true,
                "ctx_simp": true,
                "lift_bool": null,
                "timeout": null,
                "str_": true
              },
              "res": {
                "artifact": null,
                "err": null,
                "errors": [],
                "task": null,
                "regions_str": [
                  {
                    "model_eval_str": "350",
                    "constraints_str": [
                      "a >= 10"
                    ],
                    "invariant_str": "350",
                    "model_str": {
                      "a": "10"
                    }
                  },
                  {
                    "model_eval_str": "200",
                    "constraints_str": [
                      "a >= (-100)",
                      "a <= 9"
                    ],
                    "invariant_str": "a + 200",
                    "model_str": {
                      "a": "0"
                    }
                  },
                  {
                    "model_eval_str": "0",
                    "constraints_str": [
                      "a <= (-101)"
                    ],
                    "invariant_str": "0",
                    "model_str": {
                      "a": "(-101)"
                    }
                  }
                ]
              },
              "test_cases": null
            }
          ],
          "opaque_funcs": [],
          "context": ""
        },
        "context": null,
        "outstanding_task_ID": null,
        "dependencies": [],
        "rev_dependencies": [],
        "formalized_deps": [],
        "formalized_context": ""
      }
    },
    "language": "Python"
  }
}
