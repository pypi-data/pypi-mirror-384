# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: proto/martin.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class JsonResponse(betterproto.Message):
    items: List[str] = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class StreamResponse(betterproto.Message):
    event: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class FetchFundingWalletRequest(betterproto.Message):
    client_id: int = betterproto.int64_field(1)
    trade_id: str = betterproto.string_field(2)
    asset: str = betterproto.string_field(3)
    need_btc_valuation: bool = betterproto.bool_field(4)


@dataclass(eq=False, repr=False)
class CancelOrderResponse(betterproto.Message):
    symbol: str = betterproto.string_field(1)
    orig_client_order_id: str = betterproto.string_field(2)
    order_id: int = betterproto.uint64_field(3)
    order_list_id: int = betterproto.int32_field(4)
    client_order_id: str = betterproto.string_field(5)
    transact_time: int = betterproto.uint64_field(6)
    price: str = betterproto.string_field(7)
    orig_qty: str = betterproto.string_field(8)
    executed_qty: str = betterproto.string_field(9)
    cummulative_quote_qty: str = betterproto.string_field(10)
    status: str = betterproto.string_field(11)
    time_in_force: str = betterproto.string_field(12)
    type: str = betterproto.string_field(13)
    side: str = betterproto.string_field(14)
    self_trade_prevention_mode: str = betterproto.string_field(15)


@dataclass(eq=False, repr=False)
class CancelOrderRequest(betterproto.Message):
    client_id: int = betterproto.int64_field(1)
    trade_id: str = betterproto.string_field(2)
    symbol: str = betterproto.string_field(3)
    order_id: int = betterproto.int64_field(4)


@dataclass(eq=False, repr=False)
class CreateLimitOrderResponse(betterproto.Message):
    symbol: str = betterproto.string_field(1)
    order_id: int = betterproto.uint64_field(2)
    order_list_id: int = betterproto.sint32_field(3)
    client_order_id: str = betterproto.string_field(4)
    transact_time: int = betterproto.uint64_field(5)
    price: str = betterproto.string_field(6)
    orig_qty: str = betterproto.string_field(7)
    executed_qty: str = betterproto.string_field(8)
    cummulative_quote_qty: str = betterproto.string_field(9)
    status: str = betterproto.string_field(10)
    time_in_force: str = betterproto.string_field(11)
    type: str = betterproto.string_field(12)
    side: str = betterproto.string_field(13)
    strategy_id: int = betterproto.uint64_field(14)
    strategy_type: int = betterproto.uint64_field(15)
    working_time: int = betterproto.sint64_field(16)
    self_trade_prevention_mode: str = betterproto.string_field(17)


@dataclass(eq=False, repr=False)
class CreateLimitOrderRequest(betterproto.Message):
    client_id: int = betterproto.int64_field(1)
    trade_id: str = betterproto.string_field(2)
    symbol: str = betterproto.string_field(3)
    buy_side: bool = betterproto.bool_field(4)
    quantity: str = betterproto.string_field(5)
    price: str = betterproto.string_field(6)
    new_client_order_id: int = betterproto.int64_field(7)


@dataclass(eq=False, repr=False)
class OnOrderUpdateResponse(betterproto.Message):
    symbol: str = betterproto.string_field(1)
    client_order_id: str = betterproto.string_field(2)
    side: str = betterproto.string_field(3)
    order_type: str = betterproto.string_field(4)
    time_in_force: str = betterproto.string_field(5)
    order_quantity: str = betterproto.string_field(6)
    order_price: str = betterproto.string_field(7)
    stop_price: str = betterproto.string_field(8)
    iceberg_quantity: str = betterproto.string_field(9)
    order_list_id: int = betterproto.sint32_field(10)
    original_client_id: str = betterproto.string_field(11)
    execution_type: str = betterproto.string_field(12)
    order_status: str = betterproto.string_field(13)
    order_reject_reason: str = betterproto.string_field(14)
    order_id: int = betterproto.uint64_field(15)
    last_executed_quantity: str = betterproto.string_field(16)
    cumulative_filled_quantity: str = betterproto.string_field(17)
    last_executed_price: str = betterproto.string_field(18)
    commission_amount: str = betterproto.string_field(19)
    commission_asset: str = betterproto.string_field(20)
    transaction_time: int = betterproto.uint64_field(21)
    trade_id: int = betterproto.sint64_field(22)
    ignore_a: int = betterproto.uint64_field(23)
    in_order_book: bool = betterproto.bool_field(24)
    is_maker_side: bool = betterproto.bool_field(25)
    ignore_b: bool = betterproto.bool_field(26)
    order_creation_time: int = betterproto.uint64_field(27)
    quote_asset_transacted: str = betterproto.string_field(28)
    last_quote_asset_transacted: str = betterproto.string_field(29)
    quote_order_quantity: str = betterproto.string_field(30)


@dataclass(eq=False, repr=False)
class OnFundsUpdateRequest(betterproto.Message):
    client_id: int = betterproto.int64_field(1)
    trade_id: str = betterproto.string_field(2)
    symbol: str = betterproto.string_field(3)
    base_asset: str = betterproto.string_field(4)
    quote_asset: str = betterproto.string_field(5)


@dataclass(eq=False, repr=False)
class SimpleResponse(betterproto.Message):
    success: bool = betterproto.bool_field(1)
    result: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class OnTickerUpdateResponse(betterproto.Message):
    open_price: str = betterproto.string_field(1)
    last_price: str = betterproto.string_field(2)
    close_time: int = betterproto.uint64_field(3)


@dataclass(eq=False, repr=False)
class AccountTradeListRequest(betterproto.Message):
    client_id: int = betterproto.int64_field(1)
    trade_id: str = betterproto.string_field(2)
    symbol: str = betterproto.string_field(3)
    limit: int = betterproto.uint32_field(4)
    start_time: int = betterproto.int64_field(5)


@dataclass(eq=False, repr=False)
class OnKlinesUpdateResponse(betterproto.Message):
    symbol: str = betterproto.string_field(1)
    interval: str = betterproto.string_field(2)
    candle: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class FetchKlinesRequest(betterproto.Message):
    client_id: int = betterproto.int64_field(1)
    trade_id: str = betterproto.string_field(2)
    symbol: str = betterproto.string_field(3)
    interval: str = betterproto.string_field(4)
    limit: int = betterproto.uint32_field(5)


@dataclass(eq=False, repr=False)
class FetchTickerPriceChangeStatisticsResponse(betterproto.Message):
    symbol: str = betterproto.string_field(1)
    price_change: str = betterproto.string_field(2)
    price_change_percent: str = betterproto.string_field(3)
    weighted_avg_price: str = betterproto.string_field(4)
    prev_close_price: str = betterproto.string_field(5)
    last_price: str = betterproto.string_field(6)
    last_qty: str = betterproto.string_field(7)
    bid_price: str = betterproto.string_field(8)
    bid_qty: str = betterproto.string_field(9)
    ask_price: str = betterproto.string_field(10)
    ask_qty: str = betterproto.string_field(11)
    open_price: str = betterproto.string_field(12)
    high_price: str = betterproto.string_field(13)
    low_price: str = betterproto.string_field(14)
    volume: str = betterproto.string_field(15)
    quote_volume: str = betterproto.string_field(16)
    open_time: int = betterproto.uint64_field(17)
    close_time: int = betterproto.uint64_field(18)
    first_id: int = betterproto.uint64_field(19)
    last_id: int = betterproto.uint64_field(20)
    count: int = betterproto.uint64_field(21)


@dataclass(eq=False, repr=False)
class FetchSymbolPriceTickerResponse(betterproto.Message):
    symbol: str = betterproto.string_field(1)
    price: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class FetchOrderBookResponse(betterproto.Message):
    last_update_id: int = betterproto.uint64_field(1)
    bids: List[str] = betterproto.string_field(2)
    asks: List[str] = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class FetchExchangeInfoSymbolResponse(betterproto.Message):
    symbol: str = betterproto.string_field(1)
    status: str = betterproto.string_field(2)
    base_asset: str = betterproto.string_field(3)
    base_asset_precision: int = betterproto.uint32_field(4)
    quote_asset: str = betterproto.string_field(5)
    quote_asset_precision: int = betterproto.uint32_field(6)
    base_commission_precision: int = betterproto.uint32_field(7)
    quote_commission_precision: int = betterproto.uint32_field(8)
    order_types: List[str] = betterproto.string_field(9)
    iceberg_allowed: bool = betterproto.bool_field(10)
    oco_allowed: bool = betterproto.bool_field(11)
    quote_order_qty_market_allowed: bool = betterproto.bool_field(12)
    allow_trailing_stop: bool = betterproto.bool_field(13)
    cancel_replace_allowed: bool = betterproto.bool_field(14)
    is_spot_trading_allowed: bool = betterproto.bool_field(15)
    is_margin_trading_allowed: bool = betterproto.bool_field(16)
    filters: "FetchExchangeInfoSymbolResponseFilters" = betterproto.message_field(17)
    permissions: List[str] = betterproto.string_field(18)
    default_self_trade_prevention_mode: str = betterproto.string_field(19)
    allowed_self_trade_prevention_modes: List[str] = betterproto.string_field(20)


@dataclass(eq=False, repr=False)
class FetchExchangeInfoSymbolResponseFilters(betterproto.Message):
    price_filter: Optional["FetchExchangeInfoSymbolResponseFiltersPriceFilter"] = (
        betterproto.message_field(1, optional=True)
    )
    percent_price: Optional["FetchExchangeInfoSymbolResponseFiltersPercentPrice"] = (
        betterproto.message_field(2, optional=True)
    )
    lot_size: Optional["FetchExchangeInfoSymbolResponseFiltersLotSize"] = (
        betterproto.message_field(3, optional=True)
    )
    min_notional: Optional["FetchExchangeInfoSymbolResponseFiltersMinNotional"] = (
        betterproto.message_field(4, optional=True)
    )
    iceberg_parts: Optional["FetchExchangeInfoSymbolResponseFiltersIcebergParts"] = (
        betterproto.message_field(5, optional=True)
    )
    market_lot_size: Optional["FetchExchangeInfoSymbolResponseFiltersMarketLotSize"] = (
        betterproto.message_field(6, optional=True)
    )
    max_num_orders: Optional["FetchExchangeInfoSymbolResponseFiltersMaxNumOrders"] = (
        betterproto.message_field(7, optional=True)
    )
    max_num_algo_orders: Optional[
        "FetchExchangeInfoSymbolResponseFiltersMaxNumAlgoOrders"
    ] = betterproto.message_field(8, optional=True)
    max_num_iceberg_orders: Optional[
        "FetchExchangeInfoSymbolResponseFiltersMaxNumIcebergOrders"
    ] = betterproto.message_field(9, optional=True)
    max_position: Optional["FetchExchangeInfoSymbolResponseFiltersMaxPosition"] = (
        betterproto.message_field(10, optional=True)
    )
    notional: Optional["FetchExchangeInfoSymbolResponseFiltersNotional"] = (
        betterproto.message_field(11, optional=True)
    )


@dataclass(eq=False, repr=False)
class FetchExchangeInfoSymbolResponseFiltersPriceFilter(betterproto.Message):
    filter_type: str = betterproto.string_field(1)
    min_price: str = betterproto.string_field(2)
    max_price: str = betterproto.string_field(3)
    tick_size: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class FetchExchangeInfoSymbolResponseFiltersPercentPrice(betterproto.Message):
    filter_type: str = betterproto.string_field(1)
    multiplier_up: str = betterproto.string_field(2)
    multiplier_down: str = betterproto.string_field(3)
    avg_price_mins: int = betterproto.uint32_field(4)


@dataclass(eq=False, repr=False)
class FetchExchangeInfoSymbolResponseFiltersLotSize(betterproto.Message):
    filter_type: str = betterproto.string_field(1)
    min_qty: str = betterproto.string_field(2)
    max_qty: str = betterproto.string_field(3)
    step_size: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class FetchExchangeInfoSymbolResponseFiltersMinNotional(betterproto.Message):
    filter_type: str = betterproto.string_field(1)
    min_notional: str = betterproto.string_field(2)
    apply_to_market: bool = betterproto.bool_field(3)
    avg_price_mins: int = betterproto.uint32_field(4)


@dataclass(eq=False, repr=False)
class FetchExchangeInfoSymbolResponseFiltersIcebergParts(betterproto.Message):
    filter_type: str = betterproto.string_field(1)
    limit: int = betterproto.uint32_field(2)


@dataclass(eq=False, repr=False)
class FetchExchangeInfoSymbolResponseFiltersMarketLotSize(betterproto.Message):
    filter_type: str = betterproto.string_field(1)
    min_qty: str = betterproto.string_field(2)
    max_qty: str = betterproto.string_field(3)
    step_size: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class FetchExchangeInfoSymbolResponseFiltersMaxNumOrders(betterproto.Message):
    filter_type: str = betterproto.string_field(1)
    max_num_orders: int = betterproto.uint32_field(2)


@dataclass(eq=False, repr=False)
class FetchExchangeInfoSymbolResponseFiltersMaxNumAlgoOrders(betterproto.Message):
    filter_type: str = betterproto.string_field(1)
    max_num_algo_orders: int = betterproto.uint32_field(2)


@dataclass(eq=False, repr=False)
class FetchExchangeInfoSymbolResponseFiltersMaxNumIcebergOrders(betterproto.Message):
    filter_type: str = betterproto.string_field(1)
    max_num_iceberg_orders: int = betterproto.uint32_field(2)


@dataclass(eq=False, repr=False)
class FetchExchangeInfoSymbolResponseFiltersMaxPosition(betterproto.Message):
    filter_type: str = betterproto.string_field(1)
    max_position: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class FetchExchangeInfoSymbolResponseFiltersNotional(betterproto.Message):
    filter_type: str = betterproto.string_field(1)
    min_notional: str = betterproto.string_field(2)
    apply_min_to_market: bool = betterproto.bool_field(3)
    max_notional: str = betterproto.string_field(4)
    apply_max_to_market: bool = betterproto.bool_field(5)
    avg_price_mins: int = betterproto.uint32_field(6)


@dataclass(eq=False, repr=False)
class FetchOrderRequest(betterproto.Message):
    client_id: int = betterproto.int64_field(1)
    trade_id: str = betterproto.string_field(2)
    symbol: str = betterproto.string_field(3)
    order_id: int = betterproto.int64_field(4)
    client_order_id: str = betterproto.string_field(5)
    filled_update_call: bool = betterproto.bool_field(6)


@dataclass(eq=False, repr=False)
class FetchOrderResponse(betterproto.Message):
    symbol: str = betterproto.string_field(1)
    order_id: int = betterproto.uint64_field(2)
    order_list_id: int = betterproto.sint32_field(3)
    client_order_id: str = betterproto.string_field(4)
    price: str = betterproto.string_field(5)
    orig_qty: str = betterproto.string_field(6)
    executed_qty: str = betterproto.string_field(7)
    cummulative_quote_qty: str = betterproto.string_field(8)
    status: str = betterproto.string_field(9)
    time_in_force: str = betterproto.string_field(10)
    type: str = betterproto.string_field(11)
    side: str = betterproto.string_field(12)
    stop_price: str = betterproto.string_field(13)
    iceberg_qty: str = betterproto.string_field(14)
    time: int = betterproto.uint64_field(15)
    update_time: int = betterproto.uint64_field(16)
    is_working: bool = betterproto.bool_field(17)
    working_time: int = betterproto.sint64_field(18)
    orig_quote_order_qty: str = betterproto.string_field(19)
    self_trade_prevention_mode: str = betterproto.string_field(20)


@dataclass(eq=False, repr=False)
class FetchOpenOrdersResponse(betterproto.Message):
    rate_limiter: int = betterproto.int32_field(1)
    orders: List[str] = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class MarketRequest(betterproto.Message):
    client_id: int = betterproto.int64_field(1)
    trade_id: str = betterproto.string_field(2)
    symbol: str = betterproto.string_field(3)
    amount: str = betterproto.string_field(4)
    data: str = betterproto.string_field(5)


@dataclass(eq=False, repr=False)
class StartStreamRequest(betterproto.Message):
    client_id: int = betterproto.int64_field(1)
    trade_id: str = betterproto.string_field(2)
    symbol: str = betterproto.string_field(3)
    market_stream_count: int = betterproto.int32_field(4)
    user_stream_count: int = betterproto.int32_field(5)
    update_max_queue_size: bool = betterproto.bool_field(6)


@dataclass(eq=False, repr=False)
class OpenClientConnectionRequest(betterproto.Message):
    trade_id: str = betterproto.string_field(1)
    account_name: str = betterproto.string_field(2)
    rate_limiter: int = betterproto.int32_field(3)
    symbol: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class OpenClientConnectionId(betterproto.Message):
    client_id: int = betterproto.int64_field(1)
    """if connection successfully open, return it id for next use"""

    trade_id: str = betterproto.string_field(2)
    srv_version: str = betterproto.string_field(3)
    rate_limiter: int = betterproto.int32_field(4)
    exchange: str = betterproto.string_field(5)
    real_market: bool = betterproto.bool_field(6)


@dataclass(eq=False, repr=False)
class FetchServerTimeRequest(betterproto.Message):
    client_id: int = betterproto.int64_field(1)
    trade_id: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class FetchServerTimeResponse(betterproto.Message):
    server_time: int = betterproto.uint64_field(1)


class MartinStub(betterproto.ServiceStub):
    async def cancel_all_orders(
        self,
        market_request: "MarketRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SimpleResponse":
        return await self._unary_unary(
            "/martin.Martin/CancelAllOrders",
            market_request,
            SimpleResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def cancel_order(
        self,
        cancel_order_request: "CancelOrderRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CancelOrderResponse":
        return await self._unary_unary(
            "/martin.Martin/CancelOrder",
            cancel_order_request,
            CancelOrderResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def check_stream(
        self,
        market_request: "MarketRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SimpleResponse":
        return await self._unary_unary(
            "/martin.Martin/CheckStream",
            market_request,
            SimpleResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def create_limit_order(
        self,
        create_limit_order_request: "CreateLimitOrderRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CreateLimitOrderResponse":
        return await self._unary_unary(
            "/martin.Martin/CreateLimitOrder",
            create_limit_order_request,
            CreateLimitOrderResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def fetch_account_information(
        self,
        open_client_connection_id: "OpenClientConnectionId",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "JsonResponse":
        return await self._unary_unary(
            "/martin.Martin/FetchAccountInformation",
            open_client_connection_id,
            JsonResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def fetch_account_trade_list(
        self,
        account_trade_list_request: "AccountTradeListRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "JsonResponse":
        return await self._unary_unary(
            "/martin.Martin/FetchAccountTradeList",
            account_trade_list_request,
            JsonResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def fetch_exchange_info_symbol(
        self,
        market_request: "MarketRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "FetchExchangeInfoSymbolResponse":
        return await self._unary_unary(
            "/martin.Martin/FetchExchangeInfoSymbol",
            market_request,
            FetchExchangeInfoSymbolResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def fetch_funding_wallet(
        self,
        fetch_funding_wallet_request: "FetchFundingWalletRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "JsonResponse":
        return await self._unary_unary(
            "/martin.Martin/FetchFundingWallet",
            fetch_funding_wallet_request,
            JsonResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def fetch_klines(
        self,
        fetch_klines_request: "FetchKlinesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "JsonResponse":
        return await self._unary_unary(
            "/martin.Martin/FetchKlines",
            fetch_klines_request,
            JsonResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def fetch_open_orders(
        self,
        market_request: "MarketRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "FetchOpenOrdersResponse":
        return await self._unary_unary(
            "/martin.Martin/FetchOpenOrders",
            market_request,
            FetchOpenOrdersResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def fetch_order(
        self,
        fetch_order_request: "FetchOrderRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "FetchOrderResponse":
        return await self._unary_unary(
            "/martin.Martin/FetchOrder",
            fetch_order_request,
            FetchOrderResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def fetch_order_book(
        self,
        market_request: "MarketRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "FetchOrderBookResponse":
        return await self._unary_unary(
            "/martin.Martin/FetchOrderBook",
            market_request,
            FetchOrderBookResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def fetch_server_time(
        self,
        open_client_connection_id: "OpenClientConnectionId",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "FetchServerTimeResponse":
        return await self._unary_unary(
            "/martin.Martin/FetchServerTime",
            open_client_connection_id,
            FetchServerTimeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def fetch_symbol_price_ticker(
        self,
        market_request: "MarketRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "FetchSymbolPriceTickerResponse":
        return await self._unary_unary(
            "/martin.Martin/FetchSymbolPriceTicker",
            market_request,
            FetchSymbolPriceTickerResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def fetch_ticker_price_change_statistics(
        self,
        market_request: "MarketRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "FetchTickerPriceChangeStatisticsResponse":
        return await self._unary_unary(
            "/martin.Martin/FetchTickerPriceChangeStatistics",
            market_request,
            FetchTickerPriceChangeStatisticsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def on_balance_update(
        self,
        market_request: "MarketRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[StreamResponse]:
        async for response in self._unary_stream(
            "/martin.Martin/OnBalanceUpdate",
            market_request,
            StreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def on_funds_update(
        self,
        on_funds_update_request: "OnFundsUpdateRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[StreamResponse]:
        async for response in self._unary_stream(
            "/martin.Martin/OnFundsUpdate",
            on_funds_update_request,
            StreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def on_klines_update(
        self,
        fetch_klines_request: "FetchKlinesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[OnKlinesUpdateResponse]:
        async for response in self._unary_stream(
            "/martin.Martin/OnKlinesUpdate",
            fetch_klines_request,
            OnKlinesUpdateResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def on_order_book_update(
        self,
        market_request: "MarketRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[FetchOrderBookResponse]:
        async for response in self._unary_stream(
            "/martin.Martin/OnOrderBookUpdate",
            market_request,
            FetchOrderBookResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def on_order_update(
        self,
        market_request: "MarketRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[SimpleResponse]:
        async for response in self._unary_stream(
            "/martin.Martin/OnOrderUpdate",
            market_request,
            SimpleResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def on_ticker_update(
        self,
        market_request: "MarketRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[OnTickerUpdateResponse]:
        async for response in self._unary_stream(
            "/martin.Martin/OnTickerUpdate",
            market_request,
            OnTickerUpdateResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def one_click_arrival_deposit(
        self,
        market_request: "MarketRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SimpleResponse":
        return await self._unary_unary(
            "/martin.Martin/OneClickArrivalDeposit",
            market_request,
            SimpleResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def open_client_connection(
        self,
        open_client_connection_request: "OpenClientConnectionRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "OpenClientConnectionId":
        return await self._unary_unary(
            "/martin.Martin/OpenClientConnection",
            open_client_connection_request,
            OpenClientConnectionId,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def reset_rate_limit(
        self,
        open_client_connection_id: "OpenClientConnectionId",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SimpleResponse":
        return await self._unary_unary(
            "/martin.Martin/ResetRateLimit",
            open_client_connection_id,
            SimpleResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def start_stream(
        self,
        start_stream_request: "StartStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SimpleResponse":
        return await self._unary_unary(
            "/martin.Martin/StartStream",
            start_stream_request,
            SimpleResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def stop_stream(
        self,
        market_request: "MarketRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SimpleResponse":
        return await self._unary_unary(
            "/martin.Martin/StopStream",
            market_request,
            SimpleResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def transfer_to_master(
        self,
        market_request: "MarketRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SimpleResponse":
        return await self._unary_unary(
            "/martin.Martin/TransferToMaster",
            market_request,
            SimpleResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def transfer_to_sub(
        self,
        market_request: "MarketRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SimpleResponse":
        return await self._unary_unary(
            "/martin.Martin/TransferToSub",
            market_request,
            SimpleResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def client_restart(
        self,
        market_request: "MarketRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SimpleResponse":
        return await self._unary_unary(
            "/martin.Martin/ClientRestart",
            market_request,
            SimpleResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class MartinBase(ServiceBase):

    async def cancel_all_orders(
        self, market_request: "MarketRequest"
    ) -> "SimpleResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def cancel_order(
        self, cancel_order_request: "CancelOrderRequest"
    ) -> "CancelOrderResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def check_stream(self, market_request: "MarketRequest") -> "SimpleResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def create_limit_order(
        self, create_limit_order_request: "CreateLimitOrderRequest"
    ) -> "CreateLimitOrderResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def fetch_account_information(
        self, open_client_connection_id: "OpenClientConnectionId"
    ) -> "JsonResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def fetch_account_trade_list(
        self, account_trade_list_request: "AccountTradeListRequest"
    ) -> "JsonResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def fetch_exchange_info_symbol(
        self, market_request: "MarketRequest"
    ) -> "FetchExchangeInfoSymbolResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def fetch_funding_wallet(
        self, fetch_funding_wallet_request: "FetchFundingWalletRequest"
    ) -> "JsonResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def fetch_klines(
        self, fetch_klines_request: "FetchKlinesRequest"
    ) -> "JsonResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def fetch_open_orders(
        self, market_request: "MarketRequest"
    ) -> "FetchOpenOrdersResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def fetch_order(
        self, fetch_order_request: "FetchOrderRequest"
    ) -> "FetchOrderResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def fetch_order_book(
        self, market_request: "MarketRequest"
    ) -> "FetchOrderBookResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def fetch_server_time(
        self, open_client_connection_id: "OpenClientConnectionId"
    ) -> "FetchServerTimeResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def fetch_symbol_price_ticker(
        self, market_request: "MarketRequest"
    ) -> "FetchSymbolPriceTickerResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def fetch_ticker_price_change_statistics(
        self, market_request: "MarketRequest"
    ) -> "FetchTickerPriceChangeStatisticsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def on_balance_update(
        self, market_request: "MarketRequest"
    ) -> AsyncIterator[StreamResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StreamResponse()

    async def on_funds_update(
        self, on_funds_update_request: "OnFundsUpdateRequest"
    ) -> AsyncIterator[StreamResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StreamResponse()

    async def on_klines_update(
        self, fetch_klines_request: "FetchKlinesRequest"
    ) -> AsyncIterator[OnKlinesUpdateResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield OnKlinesUpdateResponse()

    async def on_order_book_update(
        self, market_request: "MarketRequest"
    ) -> AsyncIterator[FetchOrderBookResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield FetchOrderBookResponse()

    async def on_order_update(
        self, market_request: "MarketRequest"
    ) -> AsyncIterator[SimpleResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield SimpleResponse()

    async def on_ticker_update(
        self, market_request: "MarketRequest"
    ) -> AsyncIterator[OnTickerUpdateResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield OnTickerUpdateResponse()

    async def one_click_arrival_deposit(
        self, market_request: "MarketRequest"
    ) -> "SimpleResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def open_client_connection(
        self, open_client_connection_request: "OpenClientConnectionRequest"
    ) -> "OpenClientConnectionId":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def reset_rate_limit(
        self, open_client_connection_id: "OpenClientConnectionId"
    ) -> "SimpleResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def start_stream(
        self, start_stream_request: "StartStreamRequest"
    ) -> "SimpleResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def stop_stream(self, market_request: "MarketRequest") -> "SimpleResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def transfer_to_master(
        self, market_request: "MarketRequest"
    ) -> "SimpleResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def transfer_to_sub(
        self, market_request: "MarketRequest"
    ) -> "SimpleResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def client_restart(self, market_request: "MarketRequest") -> "SimpleResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_cancel_all_orders(
        self, stream: "grpclib.server.Stream[MarketRequest, SimpleResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.cancel_all_orders(request)
        await stream.send_message(response)

    async def __rpc_cancel_order(
        self, stream: "grpclib.server.Stream[CancelOrderRequest, CancelOrderResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.cancel_order(request)
        await stream.send_message(response)

    async def __rpc_check_stream(
        self, stream: "grpclib.server.Stream[MarketRequest, SimpleResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.check_stream(request)
        await stream.send_message(response)

    async def __rpc_create_limit_order(
        self,
        stream: "grpclib.server.Stream[CreateLimitOrderRequest, CreateLimitOrderResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.create_limit_order(request)
        await stream.send_message(response)

    async def __rpc_fetch_account_information(
        self, stream: "grpclib.server.Stream[OpenClientConnectionId, JsonResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.fetch_account_information(request)
        await stream.send_message(response)

    async def __rpc_fetch_account_trade_list(
        self, stream: "grpclib.server.Stream[AccountTradeListRequest, JsonResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.fetch_account_trade_list(request)
        await stream.send_message(response)

    async def __rpc_fetch_exchange_info_symbol(
        self,
        stream: "grpclib.server.Stream[MarketRequest, FetchExchangeInfoSymbolResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.fetch_exchange_info_symbol(request)
        await stream.send_message(response)

    async def __rpc_fetch_funding_wallet(
        self, stream: "grpclib.server.Stream[FetchFundingWalletRequest, JsonResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.fetch_funding_wallet(request)
        await stream.send_message(response)

    async def __rpc_fetch_klines(
        self, stream: "grpclib.server.Stream[FetchKlinesRequest, JsonResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.fetch_klines(request)
        await stream.send_message(response)

    async def __rpc_fetch_open_orders(
        self, stream: "grpclib.server.Stream[MarketRequest, FetchOpenOrdersResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.fetch_open_orders(request)
        await stream.send_message(response)

    async def __rpc_fetch_order(
        self, stream: "grpclib.server.Stream[FetchOrderRequest, FetchOrderResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.fetch_order(request)
        await stream.send_message(response)

    async def __rpc_fetch_order_book(
        self, stream: "grpclib.server.Stream[MarketRequest, FetchOrderBookResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.fetch_order_book(request)
        await stream.send_message(response)

    async def __rpc_fetch_server_time(
        self,
        stream: "grpclib.server.Stream[OpenClientConnectionId, FetchServerTimeResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.fetch_server_time(request)
        await stream.send_message(response)

    async def __rpc_fetch_symbol_price_ticker(
        self,
        stream: "grpclib.server.Stream[MarketRequest, FetchSymbolPriceTickerResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.fetch_symbol_price_ticker(request)
        await stream.send_message(response)

    async def __rpc_fetch_ticker_price_change_statistics(
        self,
        stream: "grpclib.server.Stream[MarketRequest, FetchTickerPriceChangeStatisticsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.fetch_ticker_price_change_statistics(request)
        await stream.send_message(response)

    async def __rpc_on_balance_update(
        self, stream: "grpclib.server.Stream[MarketRequest, StreamResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.on_balance_update,
            stream,
            request,
        )

    async def __rpc_on_funds_update(
        self, stream: "grpclib.server.Stream[OnFundsUpdateRequest, StreamResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.on_funds_update,
            stream,
            request,
        )

    async def __rpc_on_klines_update(
        self,
        stream: "grpclib.server.Stream[FetchKlinesRequest, OnKlinesUpdateResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.on_klines_update,
            stream,
            request,
        )

    async def __rpc_on_order_book_update(
        self, stream: "grpclib.server.Stream[MarketRequest, FetchOrderBookResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.on_order_book_update,
            stream,
            request,
        )

    async def __rpc_on_order_update(
        self, stream: "grpclib.server.Stream[MarketRequest, SimpleResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.on_order_update,
            stream,
            request,
        )

    async def __rpc_on_ticker_update(
        self, stream: "grpclib.server.Stream[MarketRequest, OnTickerUpdateResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.on_ticker_update,
            stream,
            request,
        )

    async def __rpc_one_click_arrival_deposit(
        self, stream: "grpclib.server.Stream[MarketRequest, SimpleResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.one_click_arrival_deposit(request)
        await stream.send_message(response)

    async def __rpc_open_client_connection(
        self,
        stream: "grpclib.server.Stream[OpenClientConnectionRequest, OpenClientConnectionId]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.open_client_connection(request)
        await stream.send_message(response)

    async def __rpc_reset_rate_limit(
        self, stream: "grpclib.server.Stream[OpenClientConnectionId, SimpleResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.reset_rate_limit(request)
        await stream.send_message(response)

    async def __rpc_start_stream(
        self, stream: "grpclib.server.Stream[StartStreamRequest, SimpleResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.start_stream(request)
        await stream.send_message(response)

    async def __rpc_stop_stream(
        self, stream: "grpclib.server.Stream[MarketRequest, SimpleResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.stop_stream(request)
        await stream.send_message(response)

    async def __rpc_transfer_to_master(
        self, stream: "grpclib.server.Stream[MarketRequest, SimpleResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.transfer_to_master(request)
        await stream.send_message(response)

    async def __rpc_transfer_to_sub(
        self, stream: "grpclib.server.Stream[MarketRequest, SimpleResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.transfer_to_sub(request)
        await stream.send_message(response)

    async def __rpc_client_restart(
        self, stream: "grpclib.server.Stream[MarketRequest, SimpleResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.client_restart(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/martin.Martin/CancelAllOrders": grpclib.const.Handler(
                self.__rpc_cancel_all_orders,
                grpclib.const.Cardinality.UNARY_UNARY,
                MarketRequest,
                SimpleResponse,
            ),
            "/martin.Martin/CancelOrder": grpclib.const.Handler(
                self.__rpc_cancel_order,
                grpclib.const.Cardinality.UNARY_UNARY,
                CancelOrderRequest,
                CancelOrderResponse,
            ),
            "/martin.Martin/CheckStream": grpclib.const.Handler(
                self.__rpc_check_stream,
                grpclib.const.Cardinality.UNARY_UNARY,
                MarketRequest,
                SimpleResponse,
            ),
            "/martin.Martin/CreateLimitOrder": grpclib.const.Handler(
                self.__rpc_create_limit_order,
                grpclib.const.Cardinality.UNARY_UNARY,
                CreateLimitOrderRequest,
                CreateLimitOrderResponse,
            ),
            "/martin.Martin/FetchAccountInformation": grpclib.const.Handler(
                self.__rpc_fetch_account_information,
                grpclib.const.Cardinality.UNARY_UNARY,
                OpenClientConnectionId,
                JsonResponse,
            ),
            "/martin.Martin/FetchAccountTradeList": grpclib.const.Handler(
                self.__rpc_fetch_account_trade_list,
                grpclib.const.Cardinality.UNARY_UNARY,
                AccountTradeListRequest,
                JsonResponse,
            ),
            "/martin.Martin/FetchExchangeInfoSymbol": grpclib.const.Handler(
                self.__rpc_fetch_exchange_info_symbol,
                grpclib.const.Cardinality.UNARY_UNARY,
                MarketRequest,
                FetchExchangeInfoSymbolResponse,
            ),
            "/martin.Martin/FetchFundingWallet": grpclib.const.Handler(
                self.__rpc_fetch_funding_wallet,
                grpclib.const.Cardinality.UNARY_UNARY,
                FetchFundingWalletRequest,
                JsonResponse,
            ),
            "/martin.Martin/FetchKlines": grpclib.const.Handler(
                self.__rpc_fetch_klines,
                grpclib.const.Cardinality.UNARY_UNARY,
                FetchKlinesRequest,
                JsonResponse,
            ),
            "/martin.Martin/FetchOpenOrders": grpclib.const.Handler(
                self.__rpc_fetch_open_orders,
                grpclib.const.Cardinality.UNARY_UNARY,
                MarketRequest,
                FetchOpenOrdersResponse,
            ),
            "/martin.Martin/FetchOrder": grpclib.const.Handler(
                self.__rpc_fetch_order,
                grpclib.const.Cardinality.UNARY_UNARY,
                FetchOrderRequest,
                FetchOrderResponse,
            ),
            "/martin.Martin/FetchOrderBook": grpclib.const.Handler(
                self.__rpc_fetch_order_book,
                grpclib.const.Cardinality.UNARY_UNARY,
                MarketRequest,
                FetchOrderBookResponse,
            ),
            "/martin.Martin/FetchServerTime": grpclib.const.Handler(
                self.__rpc_fetch_server_time,
                grpclib.const.Cardinality.UNARY_UNARY,
                OpenClientConnectionId,
                FetchServerTimeResponse,
            ),
            "/martin.Martin/FetchSymbolPriceTicker": grpclib.const.Handler(
                self.__rpc_fetch_symbol_price_ticker,
                grpclib.const.Cardinality.UNARY_UNARY,
                MarketRequest,
                FetchSymbolPriceTickerResponse,
            ),
            "/martin.Martin/FetchTickerPriceChangeStatistics": grpclib.const.Handler(
                self.__rpc_fetch_ticker_price_change_statistics,
                grpclib.const.Cardinality.UNARY_UNARY,
                MarketRequest,
                FetchTickerPriceChangeStatisticsResponse,
            ),
            "/martin.Martin/OnBalanceUpdate": grpclib.const.Handler(
                self.__rpc_on_balance_update,
                grpclib.const.Cardinality.UNARY_STREAM,
                MarketRequest,
                StreamResponse,
            ),
            "/martin.Martin/OnFundsUpdate": grpclib.const.Handler(
                self.__rpc_on_funds_update,
                grpclib.const.Cardinality.UNARY_STREAM,
                OnFundsUpdateRequest,
                StreamResponse,
            ),
            "/martin.Martin/OnKlinesUpdate": grpclib.const.Handler(
                self.__rpc_on_klines_update,
                grpclib.const.Cardinality.UNARY_STREAM,
                FetchKlinesRequest,
                OnKlinesUpdateResponse,
            ),
            "/martin.Martin/OnOrderBookUpdate": grpclib.const.Handler(
                self.__rpc_on_order_book_update,
                grpclib.const.Cardinality.UNARY_STREAM,
                MarketRequest,
                FetchOrderBookResponse,
            ),
            "/martin.Martin/OnOrderUpdate": grpclib.const.Handler(
                self.__rpc_on_order_update,
                grpclib.const.Cardinality.UNARY_STREAM,
                MarketRequest,
                SimpleResponse,
            ),
            "/martin.Martin/OnTickerUpdate": grpclib.const.Handler(
                self.__rpc_on_ticker_update,
                grpclib.const.Cardinality.UNARY_STREAM,
                MarketRequest,
                OnTickerUpdateResponse,
            ),
            "/martin.Martin/OneClickArrivalDeposit": grpclib.const.Handler(
                self.__rpc_one_click_arrival_deposit,
                grpclib.const.Cardinality.UNARY_UNARY,
                MarketRequest,
                SimpleResponse,
            ),
            "/martin.Martin/OpenClientConnection": grpclib.const.Handler(
                self.__rpc_open_client_connection,
                grpclib.const.Cardinality.UNARY_UNARY,
                OpenClientConnectionRequest,
                OpenClientConnectionId,
            ),
            "/martin.Martin/ResetRateLimit": grpclib.const.Handler(
                self.__rpc_reset_rate_limit,
                grpclib.const.Cardinality.UNARY_UNARY,
                OpenClientConnectionId,
                SimpleResponse,
            ),
            "/martin.Martin/StartStream": grpclib.const.Handler(
                self.__rpc_start_stream,
                grpclib.const.Cardinality.UNARY_UNARY,
                StartStreamRequest,
                SimpleResponse,
            ),
            "/martin.Martin/StopStream": grpclib.const.Handler(
                self.__rpc_stop_stream,
                grpclib.const.Cardinality.UNARY_UNARY,
                MarketRequest,
                SimpleResponse,
            ),
            "/martin.Martin/TransferToMaster": grpclib.const.Handler(
                self.__rpc_transfer_to_master,
                grpclib.const.Cardinality.UNARY_UNARY,
                MarketRequest,
                SimpleResponse,
            ),
            "/martin.Martin/TransferToSub": grpclib.const.Handler(
                self.__rpc_transfer_to_sub,
                grpclib.const.Cardinality.UNARY_UNARY,
                MarketRequest,
                SimpleResponse,
            ),
            "/martin.Martin/ClientRestart": grpclib.const.Handler(
                self.__rpc_client_restart,
                grpclib.const.Cardinality.UNARY_UNARY,
                MarketRequest,
                SimpleResponse,
            ),
        }
