# generated by datamodel-codegen:
#   filename:  openapi_devnet.json
#   timestamp: 2025-10-15T16:08:53+00:00

from __future__ import annotations

from decimal import Decimal
from enum import Enum
from typing import List, Optional, Union
from uuid import UUID

from pydantic import BaseModel, Field, confloat, constr


class Type(Enum):
    market = 'MARKET'
    limit = 'LIMIT'


class Side(Enum):
    buy = 0
    sell = 1


class Status(Enum):
    new = 'NEW'
    pending = 'PENDING'
    filled_partial = 'FILLED_PARTIAL'
    filled = 'FILLED'
    rejected = 'REJECTED'
    canceled = 'CANCELED'
    expired = 'EXPIRED'


class StopType(Enum):
    gain = 0
    loss = 1


class StopPriceType(Enum):
    last_price = 0
    mark_price = 1


class TimeInForce(Enum):
    gtd = 'GTD'
    ioc = 'IOC'
    fok = 'FOK'


class GroupContingencyType(Enum):
    oto = 0
    oco = 1


class OrderDto(BaseModel):
    id: UUID = Field(
        ...,
        description='Id representing the order',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    client_order_id: Optional[str] = Field(
        None,
        alias='clientOrderId',
        description='A subaccount scoped unique client-generated order id (either a UUID or alphanumeric string up to 32 characters)',
        examples=['28850555-0968-44ca-bdee-b51e286656d9'],
    )
    type: Type = Field(
        ..., description='Trade order type e.g. MARKET or LIMIT', examples=['LIMIT']
    )
    available_quantity: str = Field(
        ...,
        alias='availableQuantity',
        description='Remaining quantity (if modified or reduced) in native units expressed as a decimal (precision: 9)',
        examples=['10.5'],
    )
    quantity: str = Field(
        ...,
        description='Original quantity (as per order submission) in native units expressed as a decimal (precision: 9)',
        examples=['10.5'],
    )
    side: Side = Field(
        ..., description='Side as either BUY (0) or SELL (1)', examples=[1]
    )
    product_id: UUID = Field(
        ...,
        alias='productId',
        description='Id of product this order was placed against',
        examples=['9c6bf870-a8ce-4de3-820b-542fd5c049ba'],
    )
    subaccount_id: UUID = Field(
        ...,
        alias='subaccountId',
        description='Id of the subaccount associated to order',
        examples=['c25c39d9-ce2b-4753-960c-c5ad558aace8'],
    )
    status: Status = Field(..., description='Status of the order', examples=['FILLED'])
    reduce_only: bool = Field(
        ...,
        alias='reduceOnly',
        description='Indicates if the order is reduce only',
        examples=[True],
    )
    close: bool = Field(..., description='Order closes the entire current position')
    updated_at: float = Field(
        ...,
        alias='updatedAt',
        description='Order last updated timestamp (ms since Unix Epoch)',
        examples=[1712019600000],
    )
    created_at: float = Field(
        ...,
        alias='createdAt',
        description='Order creation timestamp (ms since Unix Epoch)',
        examples=[1712019600000],
    )
    sender: str = Field(
        ...,
        description='Account or linked signer address that placed this order',
        examples=['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'],
    )
    price: str = Field(
        ...,
        description='Limit price in native units expressed as a decimal, zero if market order (precision: 9)',
        examples=['4200.5'],
    )
    filled: str = Field(
        ...,
        description='Filled amount in native units expressed as a decimal (precision: 9)',
        examples=['0.5'],
    )
    stop_price: str = Field(
        ...,
        alias='stopPrice',
        description='Stop price expressed as a decimal (zero if not a stop order, precision: 9)',
        examples=['4200.5'],
    )
    stop_type: Optional[StopType] = Field(
        None,
        alias='stopType',
        description='Side as either BUY (0) or SELL (1)',
        examples=[1],
    )
    stop_price_type: Optional[StopPriceType] = Field(
        None,
        alias='stopPriceType',
        description='Type of stop price (stop orders only)',
        examples=[1],
    )
    time_in_force: Optional[TimeInForce] = Field(
        None,
        alias='timeInForce',
        description='How long an order will remain until executed/expired (required if limit)',
        examples=['GTD'],
    )
    expires_at: float = Field(
        ...,
        alias='expiresAt',
        description='Order expiry timestamp (seconds since Unix Epoch)',
        examples=[1712019600],
    )
    post_only: Optional[bool] = Field(
        None,
        alias='postOnly',
        description='Only add order if it does not immediately fill (limit only)',
        examples=[True],
    )
    group_contingency_type: Optional[GroupContingencyType] = Field(
        None,
        alias='groupContingencyType',
        description='Type of OTOCO relationship (OTO or OCO)',
        examples=[0],
    )
    group_id: Optional[UUID] = Field(
        None,
        alias='groupId',
        description='Id of the group this order belongs to',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )


class PageOfOrderDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias='hasNext',
        description='Whether there are more objects to paginate through',
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias='nextCursor',
        description='Pointer to the next page in pagination dataset',
    )
    data: List[OrderDto] = Field(..., description='Array of order objects')


class StatusCode(Enum):
    number_400 = 400


class Error(Enum):
    bad_request = 'Bad Request'


class BadRequestDto(BaseModel):
    status_code: StatusCode = Field(..., alias='statusCode')
    message: Union[str, List[str]] = Field(
        ...,
        description='Validation error message(s). Can be a single string or an array of strings.',
    )
    error: Error


class StatusCode1(Enum):
    number_401 = 401


class Error1(Enum):
    unauthorized = 'Unauthorized'


class UnauthorizedDto(BaseModel):
    status_code: StatusCode1 = Field(..., alias='statusCode')
    message: str
    error: Error1


class StatusCode2(Enum):
    number_403 = 403


class Error2(Enum):
    forbidden = 'Forbidden'


class ForbiddenDto(BaseModel):
    status_code: StatusCode2 = Field(..., alias='statusCode')
    message: str
    error: Error2


class StatusCode3(Enum):
    number_404 = 404


class Error3(Enum):
    not_found = 'Not Found'


class NotFoundDto(BaseModel):
    status_code: StatusCode3 = Field(..., alias='statusCode')
    message: str
    error: Error3


class StatusCode4(Enum):
    number_422 = 422


class Error4(Enum):
    unprocessable_entity = 'Unprocessable Entity'


class UnprocessableEntityDto(BaseModel):
    status_code: StatusCode4 = Field(..., alias='statusCode')
    message: str
    error: Error4


class StatusCode5(Enum):
    number_429 = 429


class Error5(Enum):
    too_many_requests = 'Too Many Requests'


class TooManyRequestsDto(BaseModel):
    status_code: StatusCode5 = Field(..., alias='statusCode')
    message: str
    error: Error5


class Type1(Enum):
    market = 'MARKET'


class EngineType(Enum):
    perp = 0
    spot = 1


class SubmitOrderMarketDtoData(BaseModel):
    subaccount: str = Field(
        ...,
        description='Bytes32 encoded name of the subaccount (with 0x prefix, zero padded)',
        examples=['0x7072696d61727900000000000000000000000000000000000000000000000000'],
    )
    sender: str = Field(
        ...,
        description='Address of account',
        examples=['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'],
    )
    nonce: str = Field(
        ...,
        description='Message nonce timestamp (nanoseconds since Unix Epoch)',
        examples=['2687929537462333'],
    )
    type: Type1 = Field(..., description='Market order type', examples=['MARKET'])
    quantity: Decimal = Field(
        ...,
        description='Non-directional quantity of product in native units expressed as a decimal (precision: 9)',
        examples=['5.5'],
    )
    side: Side = Field(
        ..., description='Side as either BUY (0) or SELL (1)', examples=[1]
    )
    onchain_id: confloat(ge=1.0) = Field(
        ...,
        alias='onchainId',
        description='Onchain generated productId from prior product registration',
        examples=[1],
    )
    engine_type: EngineType = Field(
        ...,
        alias='engineType',
        description='Product engine type e.g. PERP (0)',
        examples=[0],
    )
    client_order_id: Optional[str] = Field(
        None,
        alias='clientOrderId',
        description='A subaccount scoped unique client-generated order id (either a UUID or alphanumeric string up to 32 characters)',
        examples=['16e2da4d-58ab-4453-bdb4-8e4a865c12c1'],
    )
    reduce_only: Optional[bool] = Field(
        False,
        alias='reduceOnly',
        description='Whether this should be a reduce-only order, required for close',
    )
    close: Optional[bool] = Field(
        False,
        description='Order closes the entire current position, requires zero quantity and reduceOnly',
    )
    stop_price: Optional[Decimal] = Field(
        Decimal("0"),
        alias='stopPrice',
        description='Stop price expressed as a decimal (precision: 9), requires stopType',
        examples=['4200.5'],
    )
    stop_type: Optional[StopType] = Field(
        None,
        alias='stopType',
        description='Stop type, either 0 (take-profit) or 1 (stop-loss), requires non-zero stopPrice',
        examples=[1],
    )
    signed_at: float = Field(
        ...,
        alias='signedAt',
        description='Message signedAt current timestamp (seconds since Unix Epoch)',
        examples=[1712019600],
    )
    expires_at: Optional[float] = Field(
        None,
        alias='expiresAt',
        description='Order expiry timestamp (seconds since Unix Epoch), defaults to the maximum allowed value: signedAt + 6652800',
    )
    group_id: Optional[UUID] = Field(
        None,
        alias='groupId',
        description='Group Id (UUID) for linking orders together in OCO/OTO relationships',
    )
    group_contingency_type: Optional[GroupContingencyType] = Field(
        None,
        alias='groupContingencyType',
        description='Contingency type for order groups: OTO (Order-Triggers-Order) or OCO (One-Cancels-Other)',
    )


class Type2(Enum):
    limit = 'LIMIT'


class SubmitOrderLimitDtoData(BaseModel):
    subaccount: str = Field(
        ...,
        description='Bytes32 encoded name of the subaccount (with 0x prefix, zero padded)',
        examples=['0x7072696d61727900000000000000000000000000000000000000000000000000'],
    )
    sender: str = Field(
        ...,
        description='Address of account',
        examples=['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'],
    )
    nonce: str = Field(
        ...,
        description='Message nonce timestamp (nanoseconds since Unix Epoch)',
        examples=['2687929537462333'],
    )
    type: Type2 = Field(..., description='Limit order type', examples=['LIMIT'])
    quantity: Decimal = Field(
        ...,
        description='Non-directional quantity of product in native units expressed as a decimal (precision: 9)',
        examples=['5.5'],
    )
    side: Side = Field(
        ..., description='Side as either BUY (0) or SELL (1)', examples=[1]
    )
    onchain_id: confloat(ge=1.0) = Field(
        ...,
        alias='onchainId',
        description='Onchain generated productId from prior product registration',
        examples=[1],
    )
    engine_type: EngineType = Field(
        ...,
        alias='engineType',
        description='Product engine type e.g. PERP (0)',
        examples=[0],
    )
    client_order_id: Optional[str] = Field(
        None,
        alias='clientOrderId',
        description='A subaccount scoped unique client-generated order id (either a UUID or alphanumeric string up to 32 characters)',
        examples=['16e2da4d-58ab-4453-bdb4-8e4a865c12c1'],
    )
    reduce_only: Optional[bool] = Field(
        False,
        alias='reduceOnly',
        description='Whether this should be a reduce-only order, required for close',
    )
    close: Optional[bool] = Field(
        False,
        description='Order closes the entire current position, requires zero quantity and reduceOnly',
    )
    stop_price: Optional[Decimal] = Field(
        Decimal("0"),
        alias='stopPrice',
        description='Stop price expressed as a decimal (precision: 9), requires stopType',
        examples=['4200.5'],
    )
    stop_type: Optional[StopType] = Field(
        None,
        alias='stopType',
        description='Stop type, either 0 (take-profit) or 1 (stop-loss), requires non-zero stopPrice',
        examples=[1],
    )
    signed_at: float = Field(
        ...,
        alias='signedAt',
        description='Message signedAt current timestamp (seconds since Unix Epoch)',
        examples=[1712019600],
    )
    expires_at: Optional[float] = Field(
        None,
        alias='expiresAt',
        description='Order expiry timestamp (seconds since Unix Epoch), defaults to the maximum allowed value: signedAt + 6652800',
    )
    group_id: Optional[UUID] = Field(
        None,
        alias='groupId',
        description='Group Id (UUID) for linking orders together in OCO/OTO relationships',
    )
    group_contingency_type: Optional[GroupContingencyType] = Field(
        None,
        alias='groupContingencyType',
        description='Contingency type for order groups: OTO (Order-Triggers-Order) or OCO (One-Cancels-Other)',
    )
    price: Decimal = Field(
        ...,
        description='Limit price expressed as a decimal (precision: 9)',
        examples=['4200.5'],
    )
    time_in_force: TimeInForce = Field(
        ...,
        alias='timeInForce',
        description='How long an order will remain until executed/expired',
        examples=['IOC'],
    )
    post_only: bool = Field(
        ...,
        alias='postOnly',
        description='Only add order if it does not immediately fill',
        examples=[True],
    )


class SubmitOrderDto(BaseModel):
    data: Union[SubmitOrderMarketDtoData, SubmitOrderLimitDtoData]
    signature: str = Field(
        ..., description='The signature from signTypedData(...) signed by the sender'
    )


class Result(Enum):
    account_suspended = 'AccountSuspended'
    causes_immediate_liquidation = 'CausesImmediateLiquidation'
    duplicate_same_side_oco = 'DuplicateSameSideOco'
    immediate_match_post_only = 'ImmediateMatchPostOnly'
    insufficient_balance = 'InsufficientBalance'
    liquidation_error = 'LiquidationError'
    market_order_reached_max_slippage = 'MarketOrderReachedMaxSlippage'
    oco_filled = 'OcoFilled'
    ok = 'Ok'
    open_value_cap_exceeded = 'OpenValueCapExceeded'
    order_increases_position = 'OrderIncreasesPosition'
    risk_limit_exceeded = 'RiskLimitExceeded'
    signer_revoked = 'SignerRevoked'
    trigger_canceled_error = 'TriggerCanceledError'
    unfilled_fill_or_kill = 'UnfilledFillOrKill'
    unfilled_immediate_or_cancel = 'UnfilledImmediateOrCancel'
    unfilled_market_order = 'UnfilledMarketOrder'


class SubmitOrderCreatedDto(BaseModel):
    id: UUID = Field(
        ...,
        description='Id representing the created order',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    client_order_id: Optional[str] = Field(
        None,
        alias='clientOrderId',
        description='A subaccount scoped unique client-generated order id (either a UUID or alphanumeric string up to 32 characters)',
    )
    filled: str = Field(
        ...,
        description='Filled amount in native units expressed as a decimal (precision: 9)',
        examples=['0.5'],
    )
    result: Result = Field(
        ..., description='Code indicating the result of the submission', examples=['Ok']
    )


class StatusCode6(Enum):
    number_422 = 422


class Message(Enum):
    account_suspended = 'AccountSuspended'
    duplicate_client_order_id = 'DuplicateClientOrderId'
    exchange_suspended = 'ExchangeSuspended'
    insufficient_balance = 'InsufficientBalance'
    invalid_binary_data = 'InvalidBinaryData'
    invalid_expire_time = 'InvalidExpireTime'
    invalid_group_contingency_type = 'InvalidGroupContingencyType'
    invalid_nonce_for_signer = 'InvalidNonceForSigner'
    invalid_signer = 'InvalidSigner'
    invalid_signer_address = 'InvalidSignerAddress'
    invalid_time_in_force = 'InvalidTimeInForce'
    liquidation_error = 'LiquidationError'
    margin_account_balance_zero = 'MarginAccountBalanceZero'
    nonce_already_used = 'NonceAlreadyUsed'
    price_above_maximum = 'PriceAboveMaximum'
    price_below_minimum = 'PriceBelowMinimum'
    risk_limit_exceeded = 'RiskLimitExceeded'
    too_many_open_orders = 'TooManyOpenOrders'
    too_many_positions = 'TooManyPositions'
    too_many_stop_orders = 'TooManyStopOrders'
    insurance_fund_cannot_open_positions = 'InsuranceFundCannotOpenPositions'
    instrument_open_value_cap_exceeded = 'InstrumentOpenValueCapExceeded'


class Error6(Enum):
    unprocessable_entity = 'Unprocessable Entity'


class SubmitOrderFailedDto(BaseModel):
    status_code: StatusCode6 = Field(..., alias='statusCode')
    message: Message = Field(
        ...,
        description='Code indicating the reason for failure',
        examples=['TooManyOpenOrders'],
    )
    error: Error6


class SubmitDryOrderDto(BaseModel):
    data: Union[SubmitOrderMarketDtoData, SubmitOrderLimitDtoData]


class Code(Enum):
    account_suspended = 'AccountSuspended'
    causes_immediate_liquidation = 'CausesImmediateLiquidation'
    duplicate_same_side_oco = 'DuplicateSameSideOco'
    immediate_match_post_only = 'ImmediateMatchPostOnly'
    insufficient_balance = 'InsufficientBalance'
    liquidation_error = 'LiquidationError'
    market_order_reached_max_slippage = 'MarketOrderReachedMaxSlippage'
    oco_filled = 'OcoFilled'
    ok = 'Ok'
    open_value_cap_exceeded = 'OpenValueCapExceeded'
    order_increases_position = 'OrderIncreasesPosition'
    risk_limit_exceeded = 'RiskLimitExceeded'
    signer_revoked = 'SignerRevoked'
    trigger_canceled_error = 'TriggerCanceledError'
    unfilled_fill_or_kill = 'UnfilledFillOrKill'
    unfilled_immediate_or_cancel = 'UnfilledImmediateOrCancel'
    unfilled_market_order = 'UnfilledMarketOrder'


class DryRunOrderCreatedDto(BaseModel):
    margin_required: str = Field(
        ...,
        alias='marginRequired',
        description='Margin required for order in USD expressed as a decimal (precision: 9)',
        examples=['1000.5'],
    )
    margin_available: str = Field(
        ...,
        alias='marginAvailable',
        description='Margin available excluding this order in USD expressed as a decimal (precision: 9)',
        examples=['5000.75'],
    )
    total_used_margin: str = Field(
        ...,
        alias='totalUsedMargin',
        description='Total used margin including this order in USD expressed as a decimal (precision: 9)',
        examples=['3000.25'],
    )
    risk_used: str = Field(
        ...,
        alias='riskUsed',
        description='Risk used including position and open orders in USD expressed as a decimal (precision: 9)',
        examples=['3000.25'],
    )
    risk_available: str = Field(
        ...,
        alias='riskAvailable',
        description='Risk available for the product in USD expressed as a decimal (precision: 9)',
        examples=['100000000'],
    )
    code: Code = Field(
        ..., description='Code indicating a result of the dry run', examples=['Ok']
    )


class Code1(Enum):
    account_suspended = 'AccountSuspended'
    duplicate_client_order_id = 'DuplicateClientOrderId'
    exchange_suspended = 'ExchangeSuspended'
    insufficient_balance = 'InsufficientBalance'
    invalid_binary_data = 'InvalidBinaryData'
    invalid_expire_time = 'InvalidExpireTime'
    invalid_group_contingency_type = 'InvalidGroupContingencyType'
    invalid_nonce_for_signer = 'InvalidNonceForSigner'
    invalid_signer = 'InvalidSigner'
    invalid_signer_address = 'InvalidSignerAddress'
    invalid_time_in_force = 'InvalidTimeInForce'
    liquidation_error = 'LiquidationError'
    margin_account_balance_zero = 'MarginAccountBalanceZero'
    nonce_already_used = 'NonceAlreadyUsed'
    price_above_maximum = 'PriceAboveMaximum'
    price_below_minimum = 'PriceBelowMinimum'
    risk_limit_exceeded = 'RiskLimitExceeded'
    too_many_open_orders = 'TooManyOpenOrders'
    too_many_positions = 'TooManyPositions'
    too_many_stop_orders = 'TooManyStopOrders'
    insurance_fund_cannot_open_positions = 'InsuranceFundCannotOpenPositions'
    instrument_open_value_cap_exceeded = 'InstrumentOpenValueCapExceeded'


class DryRunOrderFailedDto(BaseModel):
    margin_required: str = Field(
        ...,
        alias='marginRequired',
        description='Margin required for order in USD expressed as a decimal (precision: 9)',
        examples=['1000.5'],
    )
    margin_available: str = Field(
        ...,
        alias='marginAvailable',
        description='Margin available excluding this order in USD expressed as a decimal (precision: 9)',
        examples=['5000.75'],
    )
    total_used_margin: str = Field(
        ...,
        alias='totalUsedMargin',
        description='Total used margin including this order in USD expressed as a decimal (precision: 9)',
        examples=['3000.25'],
    )
    risk_used: str = Field(
        ...,
        alias='riskUsed',
        description='Risk used including position and open orders in USD expressed as a decimal (precision: 9)',
        examples=['3000.25'],
    )
    risk_available: str = Field(
        ...,
        alias='riskAvailable',
        description='Risk available for the product in USD expressed as a decimal (precision: 9)',
        examples=['100000000'],
    )
    code: Code1 = Field(
        ...,
        description='Code indicating the reason for failure',
        examples=['TooManyOpenOrders'],
    )


class DryRunOrderFailedUnprocessableEntityDto(BaseModel):
    status_code: StatusCode6 = Field(..., alias='statusCode')
    message: Message = Field(
        ...,
        description='Code indicating the reason for failure',
        examples=['TooManyOpenOrders'],
    )
    error: Error6
    data: DryRunOrderFailedDto = Field(..., description='Details of the failed dry run')


class CancelOrderDtoData(BaseModel):
    subaccount: str = Field(
        ...,
        description='Bytes32 encoded name of the subaccount (with 0x prefix, zero padded)',
        examples=['0x7072696d61727900000000000000000000000000000000000000000000000000'],
    )
    sender: str = Field(
        ...,
        description='Account or linked signer address that canceled this order',
        examples=['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'],
    )
    nonce: str = Field(
        ...,
        description='Message nonce timestamp (nanoseconds since Unix Epoch)',
        examples=['2687929537462333'],
    )
    order_ids: Optional[List[UUID]] = Field(
        None,
        alias='orderIds',
        description='Ids of the orders to be canceled (clientOrderIds combined length cannot exceed maximum)',
        examples=[['80569be0-afba-43f8-ac20-767d0974c6a3']],
        max_length=200,
    )
    client_order_ids: Optional[List[str]] = Field(
        None,
        alias='clientOrderIds',
        description='Client-generated order ids to be canceled (orderIds combined length cannot exceed maximum)',
        examples=[['80569be0-afba-43f8-ac20-767d0974c6a3']],
        max_length=200,
    )


class CancelOrderDto(BaseModel):
    signature: str = Field(
        ..., description='The signature from signTypedData(...) signed by the sender'
    )
    data: CancelOrderDtoData


class Result1(Enum):
    already_canceled = 'AlreadyCanceled'
    already_expired = 'AlreadyExpired'
    already_filled = 'AlreadyFilled'
    not_found = 'NotFound'
    ok = 'Ok'
    nonce_already_used = 'NonceAlreadyUsed'
    unknown = 'Unknown'


class CancelOrderResultDto(BaseModel):
    id: str = Field(
        ...,
        description='Id representing the order',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    client_order_id: Optional[str] = Field(
        None,
        alias='clientOrderId',
        description='A subaccount scoped unique client-generated order id (either a UUID or alphanumeric string up to 32 characters)',
        examples=['80569be0-afba-43f8-ac20-767d0974c6a3'],
    )
    result: Result1 = Field(
        ..., description='Code indicating the result of the submission', examples=['Ok']
    )


class ListOfCancelOrderResultDtos(BaseModel):
    data: List[CancelOrderResultDto] = Field(
        ..., description='Array of order cancelation results'
    )


class Type3(Enum):
    market = 'MARKET'
    limit = 'LIMIT'


class OrderFillDto(BaseModel):
    id: UUID = Field(
        ...,
        description='Id of the fill',
        examples=['b1234567-89ab-cdef-0123-456789abcdef'],
    )
    order_id: UUID = Field(
        ...,
        alias='orderId',
        description='Id of the order (from the context of the specified subaccount)',
        examples=['b1234567-89ab-cdef-0123-456789abcdef'],
    )
    client_order_id: Optional[str] = Field(
        None,
        alias='clientOrderId',
        description='A subaccount scoped unique client-generated order id (either a UUID or alphanumeric string up to 32 characters)',
        examples=['b1234567-89ab-cdef-0123-456789abcdef'],
    )
    price: str = Field(
        ...,
        description='Fill price in expressed as a decimal (precision: 9)',
        examples=['4200.5'],
    )
    filled: str = Field(
        ...,
        description='Quantity filled in native units expressed as a decimal (precision: 9)',
        examples=['2.420'],
    )
    type: Type3 = Field(
        ...,
        description="The provided order's type e.g. MARKET or LIMIT",
        examples=['LIMIT'],
    )
    side: Side = Field(
        ..., description='Side as either BUY (0) or SELL (1)', examples=[1]
    )
    reduce_only: bool = Field(
        ...,
        alias='reduceOnly',
        description='Indicates if the fill is reduce only',
        examples=[True],
    )
    fee_usd: str = Field(
        ...,
        alias='feeUsd',
        description="The provided subaccount's charged fee in USD expressed as a decimal (precision: 9)",
        examples=['3.049563'],
    )
    is_maker: bool = Field(
        ...,
        alias='isMaker',
        description='Indicates if the fill was a maker or taker',
        examples=[True],
    )
    product_id: UUID = Field(
        ...,
        alias='productId',
        description='Id of product the order fill was made against',
        examples=['9c6bf870-a8ce-4de3-820b-542fd5c049ba'],
    )
    subaccount_id: str = Field(
        ...,
        alias='subaccountId',
        description='Id of the subaccount associated to order fill',
        examples=['aa301f94-f5b7-4e54-8b16-01052fccb2f9'],
    )
    created_at: float = Field(
        ...,
        alias='createdAt',
        description='Fill creation timestamp (ms since Unix Epoch)',
        examples=[1712019600000],
    )


class PageOfOrderFillDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias='hasNext',
        description='Whether there are more objects to paginate through',
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias='nextCursor',
        description='Pointer to the next page in pagination dataset',
    )
    data: List[OrderFillDto] = Field(..., description='Array of order fill objects')


class MakerSide(Enum):
    buy = 0
    sell = 1


class TakerSide(Enum):
    buy = 0
    sell = 1


class TradeDto(BaseModel):
    id: UUID = Field(
        ...,
        description='Id representing the trade',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    taker_order_id: UUID = Field(
        ...,
        alias='takerOrderId',
        description='Id of the taker order',
        examples=['b1234567-89ab-cdef-0123-456789abcdef'],
    )
    maker_order_id: UUID = Field(
        ...,
        alias='makerOrderId',
        description='Id of the maker order',
        examples=['e3f0a8b7-6daa-498a-bf53-c16dc5e779de'],
    )
    taker_client_order_id: Optional[str] = Field(
        None,
        alias='takerClientOrderId',
        description='Client-generated order id of the taker order',
        examples=['b1234567-89ab-cdef-0123-456789abcdef'],
    )
    maker_client_order_id: Optional[str] = Field(
        None,
        alias='makerClientOrderId',
        description='Client-generated order id of the maker order',
        examples=['e3f0a8b7-6daa-498a-bf53-c16dc5e779de'],
    )
    maker_fee_usd: str = Field(
        ...,
        alias='makerFeeUsd',
        description='Maker fee in USD expressed as a decimal (precision: 9)',
        examples=['3.049563'],
    )
    taker_fee_usd: str = Field(
        ...,
        alias='takerFeeUsd',
        description='Taker fee in USD expressed as a decimal (precision: 9)',
        examples=['4.5743445'],
    )
    price: str = Field(
        ...,
        description='Price expressed as a decimal (precision: 9)',
        examples=['4200.5'],
    )
    filled: str = Field(
        ...,
        description='Quantity filled in native units expressed as a decimal (precision: 9)',
        examples=['2.420'],
    )
    maker_side: MakerSide = Field(
        ...,
        alias='makerSide',
        description='Maker side as either BUY (0) or SELL (1)',
        examples=[1],
    )
    taker_side: TakerSide = Field(
        ...,
        alias='takerSide',
        description='Taker side as either BUY (0) or SELL (1)',
        examples=[0],
    )
    product_id: UUID = Field(
        ...,
        alias='productId',
        description='Id of product the trade was made against',
        examples=['9c6bf870-a8ce-4de3-820b-542fd5c049ba'],
    )
    created_at: float = Field(
        ...,
        alias='createdAt',
        description='Trade creation timestamp (ms since Unix Epoch)',
        examples=[1712019600000],
    )


class PageOfTradeDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias='hasNext',
        description='Whether there are more objects to paginate through',
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias='nextCursor',
        description='Pointer to the next page in pagination dataset',
    )
    data: List[TradeDto] = Field(..., description='Array of trade objects')


class PositionDto(BaseModel):
    id: UUID = Field(
        ...,
        description='Id representing the position',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    cost: str = Field(
        ...,
        description='Current cost of the position in USD expressed as a decimal (precision: 9)',
        examples=['9.3'],
    )
    size: str = Field(
        ...,
        description='Position size in native units expressed as a decimal (precision: 9)',
        examples=['1.5'],
    )
    funding_usd: str = Field(
        ...,
        alias='fundingUsd',
        description='Charged but unapplied funding on position, negative if paid, expressed as a decimal (precision: 9)',
        examples=['1.35'],
    )
    funding_accrued_usd: str = Field(
        ...,
        alias='fundingAccruedUsd',
        description='Charged and applied funding on position, negative if paid, expressed as a decimal (precision: 9)',
        examples=['10.5'],
    )
    fees_accrued_usd: str = Field(
        ...,
        alias='feesAccruedUsd',
        description='Fees accrued in USD expressed as a decimal (precision: 9)',
        examples=['0.5'],
    )
    realized_pnl: str = Field(
        ...,
        alias='realizedPnl',
        description='Realized PnL in USD expressed as a decimal (precision: 9)',
        examples=['-12.5'],
    )
    total_increase_notional: str = Field(
        ...,
        alias='totalIncreaseNotional',
        description='Cumulative USD value of all position increases expressed as a decimal (precision: 9)',
        examples=['1000.0'],
    )
    total_increase_quantity: str = Field(
        ...,
        alias='totalIncreaseQuantity',
        description='Cumulative quantity of all position increases expressed as a decimal (precision: 9)',
        examples=['2.5'],
    )
    total_decrease_notional: str = Field(
        ...,
        alias='totalDecreaseNotional',
        description='Cumulative USD value of all position decreases expressed as a decimal (precision: 9)',
        examples=['1050.0'],
    )
    total_decrease_quantity: str = Field(
        ...,
        alias='totalDecreaseQuantity',
        description='Cumulative quantity of all position decreases expressed as a decimal (precision: 9)',
        examples=['2.5'],
    )
    side: Side = Field(
        ..., description='Side as either BUY (0) or SELL (1)', examples=[0]
    )
    product_id: UUID = Field(
        ...,
        alias='productId',
        description='Id of product to this position belongs to',
        examples=['9c6bf870-a8ce-4de3-820b-542fd5c049ba'],
    )
    updated_at: float = Field(
        ...,
        alias='updatedAt',
        description='Position last updated timestamp (ms since Unix Epoch)',
        examples=[1712019600000],
    )
    created_at: float = Field(
        ...,
        alias='createdAt',
        description='Position creation timestamp (ms since Unix Epoch)',
        examples=[1712019600000],
    )
    is_liquidated: bool = Field(
        ...,
        alias='isLiquidated',
        description='Whether the position was liquidated',
        examples=[False],
    )
    liquidation_price: Optional[str] = Field(
        None,
        alias='liquidationPrice',
        description='Product price at the time of liquidation (precision: 9)',
        examples=['1200.5'],
    )


class PageOfPositionDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias='hasNext',
        description='Whether there are more objects to paginate through',
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias='nextCursor',
        description='Pointer to the next page in pagination dataset',
    )
    data: List[PositionDto] = Field(..., description='Array of position objects')


class Type4(Enum):
    market = 'MARKET'
    limit = 'LIMIT'
    realized_pnl = 'REALIZED_PNL'
    liquidation = 'LIQUIDATION'


class PositionFillDto(BaseModel):
    price: str = Field(
        ...,
        description='Fill price expressed as a decimal (precision: 9)',
        examples=['4200.5'],
    )
    filled: str = Field(
        ...,
        description='Quantity filled in native units expressed as a decimal (precision: 9)',
        examples=['2.420'],
    )
    realized_pnl: str = Field(
        ...,
        alias='realizedPnl',
        description='Realized PnL from the fill in USD expressed as a decimal (precision: 9)',
        examples=['3.049563'],
    )
    type: Type4 = Field(
        ...,
        description='Corresponding order type that led to the position fill, LIQUIDATED if takeover',
        examples=['LIMIT'],
    )
    side: Side = Field(
        ...,
        description='Direction of the fill as either BUY (0) or SELL (1)',
        examples=[1],
    )
    reduce_only: bool = Field(
        ...,
        alias='reduceOnly',
        description='Indicates if the fill is reduce only',
        examples=[False],
    )
    fee_usd: str = Field(
        ...,
        alias='feeUsd',
        description='The charged fee in USD expressed as a decimal (precision: 9)',
        examples=['3.049563'],
    )
    created_at: float = Field(
        ...,
        alias='createdAt',
        description='Fill creation timestamp (ms since Unix Epoch)',
        examples=[1712019600000],
    )


class PageOfPositionFillDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias='hasNext',
        description='Whether there are more objects to paginate through',
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias='nextCursor',
        description='Pointer to the next page in pagination dataset',
    )
    data: List[PositionFillDto] = Field(
        ..., description='Array of position fill objects'
    )


class ProductDto(BaseModel):
    id: UUID = Field(
        ...,
        description='Id representing the registered product',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    ticker: str = Field(
        ...,
        description='Product ticker based on the base quote token',
        examples=['ETHUSD'],
    )
    display_ticker: str = Field(
        ...,
        alias='displayTicker',
        description='Product display ticker based on the base quote token',
        examples=['ETH-USD'],
    )
    base_token_address: str = Field(
        ...,
        alias='baseTokenAddress',
        description='Address of the base token (non-checksummed; zero address if virtual)',
        examples=['0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'],
    )
    quote_token_address: str = Field(
        ...,
        alias='quoteTokenAddress',
        description='Address of quote token (non-checksummed)',
        examples=['0x4c9EDD5852cd905f086C759E8383e09bff1E68B3'],
    )
    base_token_name: str = Field(
        ...,
        alias='baseTokenName',
        description='Name of the base token (e.g. BTC in BTCUSD)',
        examples=['ETH'],
    )
    quote_token_name: str = Field(
        ...,
        alias='quoteTokenName',
        description='Name of the quote token (e.g. USD in BTCUSD)',
        examples=['USDe'],
    )
    engine_type: EngineType = Field(
        ...,
        alias='engineType',
        description='The corresponding engine type this product was registered with',
        examples=[0],
    )
    onchain_id: float = Field(
        ...,
        alias='onchainId',
        description='The productId generated onchain after registering for the first time',
        examples=[1],
    )
    block_number: str = Field(
        ...,
        alias='blockNumber',
        description='Block number this product was registered on',
        examples=['123062737'],
    )
    cumulative_funding_usd: str = Field(
        ...,
        alias='cumulativeFundingUsd',
        description='Cumulative funding in USD of the product (precision: 9)',
        examples=['1.001'],
    )
    created_at: float = Field(
        ...,
        alias='createdAt',
        description='Product creation timestamp (ms since Unix Epoch)',
        examples=[1712019600000],
    )
    funding_updated_at: Optional[float] = Field(
        None,
        alias='fundingUpdatedAt',
        description='Unix timestamp when funding was last updated',
        examples=[1721724269],
    )
    min_quantity: str = Field(
        ...,
        alias='minQuantity',
        description='The minimum order quantity in native units expressed as a decimal (precision: 9)',
        examples=['0.05'],
    )
    lot_size: str = Field(
        ...,
        alias='lotSize',
        description='Quantity must be divisible by the lotSize in expressed as a decimal (precision: 9)',
        examples=['0.01'],
    )
    tick_size: str = Field(
        ...,
        alias='tickSize',
        description='Minimum price increment (tickSize) expressed as a decimal (precision: 9)',
        examples=['0.0001'],
    )
    maker_fee: str = Field(
        ...,
        alias='makerFee',
        description='Fee charged to the maker on order trades expressed as a decimal (precision: 9)',
        examples=['0.001'],
    )
    taker_fee: str = Field(
        ...,
        alias='takerFee',
        description='Fee charged to the taker on order trades expressed as a decimal (precision: 9)',
        examples=['0.004'],
    )
    max_quantity: str = Field(
        ...,
        alias='maxQuantity',
        description='Max quantity per order in native units expressed as a decimal (precision: 9)',
        examples=['100000'],
    )
    min_price: str = Field(
        ...,
        alias='minPrice',
        description='Min price in USD expressed as a decimal (precision: 9)',
        examples=['0'],
    )
    max_price: str = Field(
        ...,
        alias='maxPrice',
        description='Max price in USD expressed as a decimal (precision: 9)',
        examples=['100000'],
    )
    volume24h: str = Field(
        ...,
        description='24h volume in base token native units expressed as a decimal (precision: 9)',
        examples=['500000000.42'],
    )
    max_leverage: float = Field(
        ...,
        alias='maxLeverage',
        description='Maximum leverage allowed for the product',
        examples=[20],
    )
    pyth_feed_id: float = Field(
        ..., alias='pythFeedId', description='Pyth price feed id', examples=[2]
    )
    funding_rate1h: str = Field(
        ...,
        alias='fundingRate1h',
        description='Last computed hourly funding rate expressed as a decimal (precision: 9)',
        examples=['0.01'],
    )
    open_interest: str = Field(
        ...,
        alias='openInterest',
        description='Open interest in native units expressed as a decimal (precision: 9)',
        examples=['3300.17'],
    )
    max_open_interest_usd: str = Field(
        ...,
        alias='maxOpenInterestUsd',
        description='Max open interest in USD expressed as a decimal (precision: 9)',
        examples=['200000000.0'],
    )
    max_position_notional_usd: str = Field(
        ...,
        alias='maxPositionNotionalUsd',
        description='Max position notional value, in USD expressed as a decimal (precision: 9)',
        examples=['50000000.0'],
    )


class PageOfProductDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias='hasNext',
        description='Whether there are more objects to paginate through',
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias='nextCursor',
        description='Pointer to the next page in pagination dataset',
    )
    data: List[ProductDto] = Field(..., description='Array of product objects')


class MarketLiquidityDto(BaseModel):
    timestamp: float = Field(
        ...,
        description='Most recent book update, created timestamp if never updated (ms since Unix Epoch)',
        examples=[1731664105881],
    )
    previous_timestamp: Optional[float] = Field(
        None,
        alias='previousTimestamp',
        description='Previous book update, undefined if never updated (ms since Unix Epoch)',
        examples=[1731664105881],
    )
    product_id: UUID = Field(
        ...,
        alias='productId',
        description='Id representing the product',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    asks: List[List[str]] = Field(
        ...,
        description='An array of ask tuple pairs (price, quantity) ordered in asc',
        examples=[[['4200.69', '1337.420']]],
    )
    bids: List[List[str]] = Field(
        ...,
        description='An array of bid tuple pairs (price, quantity) ordered in desc',
        examples=[[['4199.42', '420.55']]],
    )


class MarketPriceDto(BaseModel):
    product_id: UUID = Field(
        ...,
        alias='productId',
        description='Id representing the registered product',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    best_bid_price: Optional[str] = Field(
        None,
        alias='bestBidPrice',
        description='Best bid price in USD expressed as a decimal (precision: 9)',
        examples=['104399.65'],
    )
    best_ask_price: Optional[str] = Field(
        None,
        alias='bestAskPrice',
        description='Best ask price in USD expressed as a decimal (precision: 9)',
        examples=['104400.1'],
    )
    oracle_price: Optional[str] = Field(
        None,
        alias='oraclePrice',
        description='Oracle price in USD expressed as a decimal (precision: 9)',
        examples=['104399.7'],
    )
    price24h_ago: Optional[str] = Field(
        None,
        alias='price24hAgo',
        description='Price of product 24hrs ago in USD expressed as a decimal (precision: 9)',
        examples=['101228.38'],
    )


class ListOfMarketPriceDtos(BaseModel):
    data: List[MarketPriceDto] = Field(..., description='Array of market price objects')


class FundingDto(BaseModel):
    created_at: float = Field(
        ...,
        alias='createdAt',
        description='Funding charge timestamp (ms since Unix Epoch)',
        examples=[1712019600000],
    )
    funding_rate1h: str = Field(
        ...,
        alias='fundingRate1h',
        description='Hourly funding rate',
        examples=['0.013876480'],
    )


class PageOfFundingDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias='hasNext',
        description='Whether there are more objects to paginate through',
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias='nextCursor',
        description='Pointer to the next page in pagination dataset',
    )
    data: List[FundingDto] = Field(
        ..., description='Array of funding rate history objects'
    )


class ProjectedFundingDto(BaseModel):
    funding_rate_projected1h: str = Field(
        ...,
        alias='fundingRateProjected1h',
        description='Projected funding rate',
        examples=['0.013876480'],
    )
    funding_rate1h: str = Field(
        ..., alias='fundingRate1h', description='Funding rate', examples=['0.013876480']
    )


class DomainTypeDto(BaseModel):
    name: str = Field(..., description='Name of signing domain')
    version: str = Field(..., description='Current major version of the signing domain')
    chain_id: float = Field(..., alias='chainId', description='The EIP-155 chain id')
    verifying_contract: str = Field(
        ...,
        alias='verifyingContract',
        description='Address of the contract that will verify the signature',
    )


class SignatureTypesDto(BaseModel):
    link_signer: str = Field(
        ..., alias='LinkSigner', description='LinkSigner signature type'
    )
    trade_order: str = Field(
        ..., alias='TradeOrder', description='TradeOrder signature type'
    )
    initiate_withdraw: str = Field(
        ..., alias='InitiateWithdraw', description='InitiateWithdraw signature type'
    )
    revoke_linked_signer: str = Field(
        ..., alias='RevokeLinkedSigner', description='RevokeLinkedSigner signature type'
    )
    cancel_order: str = Field(
        ..., alias='CancelOrder', description='CancelOrder signature type'
    )
    refresh_linked_signer: str = Field(
        ...,
        alias='RefreshLinkedSigner',
        description='RefreshLinkedSigner signature type',
    )


class RpcConfigDto(BaseModel):
    domain: DomainTypeDto = Field(..., description='Domain type')
    signature_types: SignatureTypesDto = Field(
        ..., alias='signatureTypes', description='Signature types'
    )


class SubaccountDto(BaseModel):
    id: UUID = Field(
        ...,
        description='Id representing the registered subaccount',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    name: str = Field(
        ...,
        description='Bytes32 encoded name of the subaccount (with 0x prefix, zero padded)',
        examples=['0x7072696d61727900000000000000000000000000000000000000000000000000'],
    )
    account: str = Field(
        ...,
        description='Address of the account which registered the subaccount (non-checksummed)',
        examples=['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'],
    )
    created_block_number: str = Field(
        ...,
        alias='createdBlockNumber',
        description='Block number this subaccount was created on',
        examples=['123062737'],
    )
    registered_block_number: Optional[str] = Field(
        None,
        alias='registeredBlockNumber',
        description='Block number this subaccount was registered on',
        examples=['123062737'],
    )
    created_at: float = Field(
        ...,
        alias='createdAt',
        description='Subaccount creation timestamp (ms since Unix Epoch)',
        examples=[1712019600000],
    )


class PageOfSubaccountDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias='hasNext',
        description='Whether there are more objects to paginate through',
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias='nextCursor',
        description='Pointer to the next page in pagination dataset',
    )
    data: List[SubaccountDto] = Field(..., description='Array of subaccount objects')


class SubaccountBalanceDto(BaseModel):
    subaccount_id: UUID = Field(
        ...,
        alias='subaccountId',
        description='Id representing the subaccount',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    token_id: UUID = Field(
        ...,
        alias='tokenId',
        description='Id representing the token',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    token_address: str = Field(
        ...,
        alias='tokenAddress',
        description='ERC20 deposited token address (non-checksummed, zero address if virtual)',
        examples=['0x4c9EDD5852cd905f086C759E8383e09bff1E68B3'],
    )
    token_name: str = Field(
        ...,
        alias='tokenName',
        description='The unique exchange defined token name driven by addToken onchain',
        examples=['ETH'],
    )
    amount: Decimal = Field(
        ...,
        description='Token balance in native units expressed as a decimal (precision: 9)',
        examples=['1.5'],
    )
    available: Decimal = Field(
        ...,
        description='Portion of balance transferrable in native units expressed as a decimal (precision: 9)',
        examples=['0.1337'],
    )
    total_used: Decimal = Field(
        ...,
        alias='totalUsed',
        description='Portion of balance non-transferrable in native units expressed as a decimal (precision: 9)',
        examples=['1.3663'],
    )
    updated_at: float = Field(
        ...,
        alias='updatedAt',
        description='Token balance last updated timestamp (ms since Unix Epoch)',
        examples=[1712019600000],
    )


class PageOfSubaccountBalanceDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias='hasNext',
        description='Whether there are more objects to paginate through',
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias='nextCursor',
        description='Pointer to the next page in pagination dataset',
    )
    data: List[SubaccountBalanceDto] = Field(
        ..., description='Array of order subaccount balances'
    )


class LinkSignerDtoData(BaseModel):
    subaccount_id: UUID = Field(
        ...,
        alias='subaccountId',
        description='Id representing the registered subaccount',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    sender: str = Field(
        ...,
        description='Account address that created the signature in this message',
        examples=['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'],
    )
    subaccount: str = Field(
        ...,
        description='Bytes32 encoded name of the subaccount (with 0x prefix, zero padded)',
        examples=['0x7072696d61727900000000000000000000000000000000000000000000000000'],
    )
    signer: str = Field(
        ...,
        description='Address of signer to allowed for delegated signing',
        examples=['0x1Db3439a222C519ab44bb1144fC28167b4Fa6EE6'],
    )
    nonce: str = Field(
        ...,
        description='Message nonce timestamp (nanoseconds since Unix Epoch)',
        examples=['2687929537462333'],
    )
    signed_at: float = Field(
        ...,
        alias='signedAt',
        description='Message signedAt current timestamp (seconds since Unix Epoch)',
        examples=[1712019600],
    )


class LinkSignerDto(BaseModel):
    signature: str = Field(
        ..., description='The signature from signTypedData(...) signed by the sender'
    )
    signer_signature: str = Field(
        ...,
        alias='signerSignature',
        description='The signature from signTypedData(...) signed by the signer',
    )
    data: LinkSignerDtoData


class Status1(Enum):
    pending = 'PENDING'
    active = 'ACTIVE'
    pending_revoke = 'PENDING_REVOKE'
    revoked = 'REVOKED'
    rejected = 'REJECTED'


class SignerDto(BaseModel):
    id: str = Field(
        ...,
        description='Id representing the linked signer',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    signer: str = Field(
        ...,
        description='Address of the signer linked with the subaccount (non-checksummed)',
        examples=['0x1Db3439a222C519ab44bb1144fC28167b4Fa6EE6'],
    )
    status: Status1 = Field(
        ..., description='Status of the signer', examples=['PENDING']
    )
    block_number: Optional[str] = Field(
        None,
        alias='blockNumber',
        description='Block number the signer has been linked on. Undefined means it has not be processed',
        examples=['123062737'],
    )
    linked_at: Optional[float] = Field(
        None,
        alias='linkedAt',
        description='Onchain linkage timestamp (ms since Unix Epoch)',
        examples=[1712019615000],
    )
    revoked_block_number: Optional[str] = Field(
        None,
        alias='revokedBlockNumber',
        description='Block number the signer has been revoked on. Undefined means it has not be processed',
        examples=['123062737'],
    )
    revoked_at: Optional[float] = Field(
        None,
        alias='revokedAt',
        description='Onchain revocation timestamp (ms since Unix Epoch)',
        examples=[1712019600000],
    )
    expires_at: float = Field(
        ...,
        alias='expiresAt',
        description='Signer expiry timestamp (ms since Unix Epoch)',
        examples=[1713229200000],
    )
    created_at: float = Field(
        ...,
        alias='createdAt',
        description='Link signer submission timestamp (ms since Unix Epoch)',
        examples=[1712019600000],
    )


class RevokeLinkedSignerDtoData(BaseModel):
    subaccount_id: UUID = Field(
        ...,
        alias='subaccountId',
        description='Id representing the registered subaccount',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    sender: str = Field(
        ...,
        description='Address of account that created the signature in this message',
        examples=['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'],
    )
    subaccount: str = Field(
        ...,
        description='Bytes32 encoded name of the subaccount (with 0x prefix, zero padded)',
        examples=['0x7072696d61727900000000000000000000000000000000000000000000000000'],
    )
    signer: str = Field(
        ...,
        description='Address of signer to revoke',
        examples=['0x1Db3439a222C519ab44bb1144fC28167b4Fa6EE6'],
    )
    nonce: str = Field(
        ...,
        description='Message nonce timestamp (nanoseconds since Unix Epoch)',
        examples=['2687929537462333'],
    )
    signed_at: float = Field(
        ...,
        alias='signedAt',
        description='Message signedAt current timestamp (seconds since Unix Epoch)',
        examples=[1712019600],
    )


class RevokeLinkedSignerDto(BaseModel):
    signature: str = Field(
        ..., description='The signature from signTypedData(...) signed by the sender'
    )
    data: RevokeLinkedSignerDtoData


class RefreshLinkedSignerDtoData(BaseModel):
    subaccount_id: UUID = Field(
        ...,
        alias='subaccountId',
        description='Id representing the registered subaccount',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    sender: str = Field(
        ...,
        description='Address of account that created the signature in this message',
        examples=['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'],
    )
    subaccount: str = Field(
        ...,
        description='Bytes32 encoded name of the subaccount (with 0x prefix, zero padded)',
        examples=['0x7072696d61727900000000000000000000000000000000000000000000000000'],
    )
    signer: str = Field(
        ...,
        description='Address of signer to refresh',
        examples=['0x1Db3439a222C519ab44bb1144fC28167b4Fa6EE6'],
    )
    nonce: str = Field(
        ...,
        description='Message nonce timestamp (nanoseconds since Unix Epoch)',
        examples=['2687929537462333'],
    )
    signed_at: float = Field(
        ...,
        alias='signedAt',
        description='Message signedAt current timestamp (seconds since Unix Epoch)',
        examples=[1712019600],
    )


class RefreshLinkedSignerDto(BaseModel):
    signature: str = Field(
        ..., description='The signature from signTypedData(...) signed by the sender'
    )
    data: RefreshLinkedSignerDtoData


class AccountSignerQuotaDto(BaseModel):
    max_linked_signers_period_days: float = Field(
        ...,
        alias='maxLinkedSignersPeriodDays',
        description='Ratelimit period in days for linking signers per account',
        examples=[7],
    )
    max_linked_signers_in_period: float = Field(
        ...,
        alias='maxLinkedSignersInPeriod',
        description='Max number of signer that can be linked within ratelimit period',
        examples=[10],
    )
    linked_signers_used_in_period: float = Field(
        ...,
        alias='linkedSignersUsedInPeriod',
        description='Number of signers linked within current ratelimit period',
        examples=[2],
    )
    linked_signer_refresh_hours_before_expiry: float = Field(
        ...,
        alias='linkedSignerRefreshHoursBeforeExpiry',
        description='Hours before expiry when a signer can be refreshed',
        examples=[48],
    )


class PageOfSignersDto(BaseModel):
    has_next: bool = Field(
        ...,
        alias='hasNext',
        description='Whether there are more objects to paginate through',
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias='nextCursor',
        description='Pointer to the next page in pagination dataset',
    )
    data: List[SignerDto] = Field(..., description='Array of signer objects')


class Status2(Enum):
    submitted = 'SUBMITTED'
    pending = 'PENDING'
    completed = 'COMPLETED'
    rejected = 'REJECTED'


class WithdrawDto(BaseModel):
    id: UUID = Field(
        ...,
        description='Id representing the withdraw',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    initiated_block_number: Optional[str] = Field(
        None,
        alias='initiatedBlockNumber',
        description='Block number the withdraw was initiated on',
        examples=['123062000'],
    )
    finalized_block_number: Optional[str] = Field(
        None,
        alias='finalizedBlockNumber',
        description='Block number the withdraw was completed on',
        examples=['123062992'],
    )
    status: Status2 = Field(
        ..., description='Current status of the withdraw', examples=['PENDING']
    )
    subaccount: str = Field(
        ...,
        description='Bytes32 encoded name of the subaccount (with 0x prefix, zero padded)',
        examples=['0x7072696d61727900000000000000000000000000000000000000000000000000'],
    )
    token: str = Field(
        ...,
        description='Address of asset to withdraw (non-checksummed)',
        examples=['0x4c9EDD5852cd905f086C759E8383e09bff1E68B3'],
    )
    lz_destination_address: Optional[str] = Field(
        None,
        alias='lzDestinationAddress',
        description='LayerZero destination address (leading 0x bytes32 encoded) for the transfer (if withdraw)',
    )
    lz_destination_eid: Optional[float] = Field(
        None,
        alias='lzDestinationEid',
        description='LayerZero destination endpoint ID for the transfer (if withdraw)',
        examples=[30391],
    )
    amount: str = Field(
        ...,
        description='Amount of asset transferred expressed as a decimal',
        examples=['1.5'],
    )
    created_at: float = Field(
        ...,
        alias='createdAt',
        description='Withdraw creation timestamp (ms since Unix Epoch)',
        examples=[1712019600000],
    )
    withdraw_digest: str = Field(
        ...,
        alias='withdrawDigest',
        description='Bytes32 hash of the withdraw data (with 0x prefix)',
    )


class PageOfWithdrawDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias='hasNext',
        description='Whether there are more objects to paginate through',
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias='nextCursor',
        description='Pointer to the next page in pagination dataset',
    )
    data: List[WithdrawDto] = Field(
        ..., description='Array of subaccount withdraw objects'
    )


class Type5(Enum):
    deposit = 'DEPOSIT'
    withdraw = 'WITHDRAW'


class TransferDto(BaseModel):
    id: UUID = Field(
        ...,
        description='Id representing the transfer',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    initiated_block_number: Optional[str] = Field(
        None,
        alias='initiatedBlockNumber',
        description='Block number the transfer was initiated on',
        examples=['123062000'],
    )
    finalized_block_number: Optional[str] = Field(
        None,
        alias='finalizedBlockNumber',
        description='Block number the transfer was completed on',
        examples=['123062992'],
    )
    status: Status2 = Field(
        ..., description='Current status of the transfer', examples=['PENDING']
    )
    subaccount_id: UUID = Field(
        ...,
        alias='subaccountId',
        description='Id representing the registered subaccount',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    token_name: str = Field(
        ...,
        alias='tokenName',
        description='The unique exchange defined token name driven by addToken onchain',
        examples=['ETH'],
    )
    token_address: str = Field(
        ...,
        alias='tokenAddress',
        description='Address of token transferred (non-checksummed)',
        examples=['0x4c9EDD5852cd905f086C759E8383e09bff1E68B3'],
    )
    type: Type5 = Field(
        ..., description='Type of transfer (WITHDRAW or DEPOSIT)', examples=['WITHDRAW']
    )
    amount: str = Field(
        ...,
        description='Amount of tokens transferred in native units expressed as a decimal (precision: 9)',
        examples=['0.42'],
    )
    lz_destination_address: Optional[str] = Field(
        None,
        alias='lzDestinationAddress',
        description='LayerZero destination address (leading 0x bytes32 encoded) for the transfer (if withdraw)',
    )
    lz_destination_eid: Optional[float] = Field(
        None,
        alias='lzDestinationEid',
        description='LayerZero destination endpoint ID for the transfer (if withdraw)',
        examples=[10422],
    )
    fee: str = Field(
        ...,
        description='Fee paid for the transfer in native units expressed as a decimal (precision: 9)',
        examples=['0.42'],
    )
    created_at: float = Field(
        ...,
        alias='createdAt',
        description='Transfer creation timestamp (ms since Unix Epoch)',
        examples=[1712019600000],
    )
    initiated_transaction_hash: Optional[str] = Field(
        None,
        alias='initiatedTransactionHash',
        description='Transaction hash for the initiation of the transfer',
        examples=['0x8ffa427c4079a78a64811e80fe4dbefa8bd8e2f4cc572cda9717297d220d4f8e'],
    )
    finalized_transaction_hash: Optional[str] = Field(
        None,
        alias='finalizedTransactionHash',
        description='Transaction hash for the finalization of the transfer',
        examples=['0x42aa378d58b92c639dda64d528a6123f14e59e071c4b56e058d3a54b819e2b79'],
    )


class PageOfTransfersDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias='hasNext',
        description='Whether there are more objects to paginate through',
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias='nextCursor',
        description='Pointer to the next page in pagination dataset',
    )
    data: List[TransferDto] = Field(..., description='Array of transfer objects')


class LzDestinationEid(Enum):
    none = 0
    ethereal_testnet = 10422
    ethereum_mainnet = 40231
    arbitrum_mainnet = 40161
    ethereal_mainnet = 30391
    ethereum_sepolia = 30110
    arbitrum_sepolia = 30101


class InitiateWithdrawDtoData(BaseModel):
    account: str = Field(
        ...,
        description='Account address to withdraw from',
        examples=['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'],
    )
    subaccount: str = Field(
        ...,
        description='Bytes32 encoded name of the subaccount (with 0x prefix, zero padded)',
        examples=['0x7072696d61727900000000000000000000000000000000000000000000000000'],
    )
    token: str = Field(
        ...,
        description='Address of token to be withdrawn',
        examples=['0x4c9EDD5852cd905f086C759E8383e09bff1E68B3'],
    )
    amount: Decimal = Field(
        ...,
        description='Amount to withdraw in native units expressed as a decimal (precision: 9)',
        examples=['1337.42'],
    )
    lz_destination_address: str = Field(
        ...,
        alias='lzDestinationAddress',
        description='Bytes32 encoded LayerZero destination address (with 0x prefix, left zero padded)',
        examples=['0x000000000000000000000000d8dA6BF26964aF9D7eEd9e03E53415D37aA96045'],
    )
    lz_destination_eid: LzDestinationEid = Field(
        ...,
        alias='lzDestinationEid',
        description='LayerZero destination endpoint ID for the transfer (zero if not bridging)',
        examples=[40231],
    )
    nonce: str = Field(
        ...,
        description='Message nonce timestamp (nanoseconds since Unix Epoch)',
        examples=['2687929537462333'],
    )
    signed_at: float = Field(
        ...,
        alias='signedAt',
        description='Message signedAt current timestamp (seconds since Unix Epoch)',
        examples=[1712019600],
    )


class InitiateWithdrawDto(BaseModel):
    signature: str = Field(
        ..., description='The signature from signTypedData(...) signed by the sender'
    )
    data: InitiateWithdrawDtoData


class Message2(Enum):
    account_suspended = 'AccountSuspended'
    engine_suspended = 'EngineSuspended'
    insufficient_balance = 'InsufficientBalance'
    insurance_fund_cannot_withdraw = 'InsuranceFundCannotWithdraw'


class WithdrawFailedDto(BaseModel):
    status_code: StatusCode6 = Field(..., alias='statusCode')
    message: Message2 = Field(
        ...,
        description='Error code indicating the reason for failure',
        examples=['InsufficientBalance'],
    )
    error: Error6


class TokenDto(BaseModel):
    id: UUID = Field(
        ...,
        description='Id representing the token',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    address: str = Field(
        ...,
        description='Address of the token (non-checksummed; zero address if virtual)',
        examples=['0x4c9EDD5852cd905f086C759E8383e09bff1E68B3'],
    )
    lz_oft_address: str = Field(
        ...,
        alias='lzOftAddress',
        description='LayerZero OFT address of the token (non-checksummed; if has LZ OFT or adapter, zero address if not)',
        examples=['0x41e038d9c9aF27369EcBCe72A69a96695A1fD0D3'],
    )
    name: str = Field(
        ...,
        description='The unique exchange defined token name driven by addToken onchain',
        examples=['USD'],
    )
    erc20_name: Optional[str] = Field(
        None,
        alias='erc20Name',
        description='ERC20 token name (available if not virtual)',
        examples=['Wrapped USDe'],
    )
    erc20_symbol: Optional[str] = Field(
        None,
        alias='erc20Symbol',
        description='ERC20 token symbol (available if not virtual)',
        examples=['WUSDe'],
    )
    erc20_decimals: Optional[float] = Field(
        None,
        alias='erc20Decimals',
        description='ERC20 token decimals (available if not virtual)',
        examples=[18],
    )
    deposit_enabled: bool = Field(
        ...,
        alias='depositEnabled',
        description='Whether the token is enabled for deposit',
        examples=[True],
    )
    withdraw_enabled: bool = Field(
        ...,
        alias='withdrawEnabled',
        description='Whether the token is enabled for withdraw',
        examples=[True],
    )
    deposit_fee: str = Field(
        ...,
        alias='depositFee',
        description='Amount of native units charged on deposit expressed as a decimal (precision: 9)',
        examples=['0'],
    )
    withdraw_fee: str = Field(
        ...,
        alias='withdrawFee',
        description='Amount of native units charged on withdraw expressed as a decimal (precision: 9)',
        examples=['1'],
    )
    min_deposit: str = Field(
        ...,
        alias='minDeposit',
        description='Min deposit amount as native units expressed as a decimal (precision: 9)',
        examples=['10.123456'],
    )
    created_at: float = Field(
        ...,
        alias='createdAt',
        description='Token creation timestamp (ms since Unix Epoch)',
        examples=[1712019600000],
    )


class PageOfTokensDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias='hasNext',
        description='Whether there are more objects to paginate through',
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias='nextCursor',
        description='Pointer to the next page in pagination dataset',
    )
    data: List[TokenDto] = Field(..., description='Array of token objects')


class SystemTimeDto(BaseModel):
    time: float = Field(
        ...,
        description='Current system timestamp (ms since Unix Epoch)',
        examples=[1712019600000],
    )


class WhitelistDto(BaseModel):
    is_whitelisted: bool = Field(
        ...,
        alias='isWhitelisted',
        description='Whether the address is whitelisted',
        examples=[True],
    )


class PointsPeriodDto(BaseModel):
    id: UUID = Field(
        ...,
        description='Id representing the points period entry',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    address: str = Field(
        ...,
        description='Address of the account (non-checksummed)',
        examples=['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'],
    )
    season: float = Field(..., description='Season number', examples=[1])
    epoch: float = Field(
        ..., description='Epoch number within the season', examples=[1]
    )
    points: str = Field(
        ...,
        description='Points earned in this epoch expressed as a decimal (precision: 9)',
        examples=['13.256'],
    )
    referral_points: str = Field(
        ...,
        alias='referralPoints',
        description='Referral points earned in this epoch expressed as a decimal (precision: 9)',
        examples=['1.95'],
    )
    started_at: float = Field(
        ...,
        alias='startedAt',
        description='Beginning of points period (ms since Unix Epoch)',
        examples=[1712019600000],
    )
    ended_at: float = Field(
        ...,
        alias='endedAt',
        description='End of points period (ms since Unix Epoch)',
        examples=[1712019600000],
    )
    created_at: float = Field(
        ...,
        alias='createdAt',
        description='Points period creation timestamp (ms since Unix Epoch)',
        examples=[1712019600000],
    )
    updated_at: float = Field(
        ...,
        alias='updatedAt',
        description='Points period last update timestamp (ms since Unix Epoch)',
        examples=[1712019600000],
    )


class ListOfPointsPeriodDtos(BaseModel):
    data: List[PointsPeriodDto] = Field(
        ..., description='Array of points period objects'
    )


class Tier(Enum):
    tier_0 = 0
    tier_1 = 1
    tier_2 = 2
    tier_3 = 3
    tier_4 = 4
    tier_5 = 5
    tier_6 = 6
    tier_7 = 7
    tier_8 = 8
    tier_9 = 9


class PointsSeasonSummaryDto(BaseModel):
    id: UUID = Field(
        ...,
        description='Id representing the summary of points in this season',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    address: str = Field(
        ...,
        description='Address of the account (non-checksummed)',
        examples=['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'],
    )
    season: float = Field(..., description='Season number', examples=[1])
    total_points: str = Field(
        ...,
        alias='totalPoints',
        description='Total points earned expressed as a decimal (precision: 9)',
        examples=['13.256'],
    )
    previous_total_points: str = Field(
        ...,
        alias='previousTotalPoints',
        description='Total points earned before most recent distribution expressed as a decimal (precision: 9)',
        examples=['13.256'],
    )
    referral_points: str = Field(
        ...,
        alias='referralPoints',
        description='Referral points earned expressed as a decimal (precision: 9)',
        examples=['1.95'],
    )
    previous_referral_points: str = Field(
        ...,
        alias='previousReferralPoints',
        description='Referral points earned before most recent distribution expressed as a decimal (precision: 9)',
        examples=['1.95'],
    )
    rank: float = Field(..., description='Current rank in this season', examples=[1])
    previous_rank: float = Field(
        ...,
        alias='previousRank',
        description='Rank before most recent distribution',
        examples=[2],
    )
    total_referrals: float = Field(
        ..., alias='totalReferrals', description='Total referrals', examples=[1]
    )
    total_referrals_deposited: float = Field(
        ...,
        alias='totalReferralsDeposited',
        description='Total referrals deposited',
        examples=[1],
    )
    tier: Tier = Field(
        ...,
        description='Account tier derived based on activity this season',
        examples=[0],
    )
    created_at: float = Field(
        ...,
        alias='createdAt',
        description='Points season summary creation timestamp (ms since Unix Epoch)',
        examples=[1712019600000],
    )
    updated_at: float = Field(
        ...,
        alias='updatedAt',
        description='Points season summary last update timestamp (ms since Unix Epoch)',
        examples=[1712019600000],
    )


class ListOfPointsSeasonSummariesDtos(BaseModel):
    data: List[PointsSeasonSummaryDto] = Field(
        ..., description='Array of points season summary objects'
    )


class BalanceHistoryDto(BaseModel):
    time: float = Field(
        ...,
        description='Timestamp of the balance record (ms since Unix Epoch)',
        examples=[1712019600000],
    )
    trading_fee: str = Field(
        ...,
        alias='tradingFee',
        description='Cumulative trading fees paid up to this point in time, expressed as a decimal (precision: 9)',
        examples=['10.5'],
    )
    realized_funding: str = Field(
        ...,
        alias='realizedFunding',
        description='Cumulative funding realized up to this point in time, expressed as a decimal (precision: 9)',
        examples=['5.25'],
    )
    realized_pnl: str = Field(
        ...,
        alias='realizedPnl',
        description='Cumulative realized PnL up to this point in time, expressed as a decimal (precision: 9)',
        examples=['150.75'],
    )
    deposit_fee: str = Field(
        ...,
        alias='depositFee',
        description='Cumulative deposit fees paid up to this point in time, expressed as a decimal (precision: 9)',
        examples=['2.0'],
    )
    deposit: str = Field(
        ...,
        description='Cumulative deposits made up to this point in time, expressed as a decimal (precision: 9)',
        examples=['1000.0'],
    )
    withdrawal_fee: str = Field(
        ...,
        alias='withdrawalFee',
        description='Cumulative withdrawal fees paid up to this point in time, expressed as a decimal (precision: 9)',
        examples=['3.5'],
    )
    withdrawal: str = Field(
        ...,
        description='Cumulative withdrawals made up to this point in time, expressed as a decimal (precision: 9)',
        examples=['500.0'],
    )
    balance: str = Field(
        ...,
        description='Total balance at this point in time, expressed as a decimal (precision: 9)',
        examples=['680.0'],
    )


class PageOfBalanceHistoryDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias='hasNext',
        description='Whether there are more objects to paginate through',
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias='nextCursor',
        description='Pointer to the next page in pagination dataset',
    )
    data: List[BalanceHistoryDto] = Field(
        ..., description='Array of balance history records'
    )


class PositionSide(Enum):
    buy = 0
    sell = 1


class PositionFundingHistoryDto(BaseModel):
    time: float = Field(
        ...,
        description='Timestamp of the funding charge (ms since Unix Epoch)',
        examples=[1712019600000],
    )
    settled_at: float = Field(
        ...,
        alias='settledAt',
        description='Timestamp of the funding settlement (ms since Unix Epoch)',
        examples=[1712019600000],
    )
    product_id: str = Field(
        ...,
        alias='productId',
        description='Id representing the product',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    product_ticker: str = Field(
        ..., alias='productTicker', description='Product ticker', examples=['ETHUSD']
    )
    position_id: str = Field(
        ...,
        alias='positionId',
        description='Id representing the position',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    position_side: PositionSide = Field(
        ...,
        alias='positionSide',
        description='Position side as either BUY (0) or SELL (1)',
        examples=[0],
    )
    position_quantity: str = Field(
        ...,
        alias='positionQuantity',
        description='Position quantity at the time of funding, expressed as a decimal (precision: 9)',
        examples=['10.5'],
    )
    funding_rate: str = Field(
        ...,
        alias='fundingRate',
        description='Funding rate for the period, expressed as a decimal (precision: 9)',
        examples=['0.0001'],
    )
    charge_per_unit_usd: str = Field(
        ...,
        alias='chargePerUnitUsd',
        description='Funding charge per unit in USD, expressed as a decimal (precision: 9)',
        examples=['0.5'],
    )
    funding_charge: str = Field(
        ...,
        alias='fundingCharge',
        description='Total funding charge for the position (positive means pay, negative means receive), expressed as a decimal (precision: 9)',
        examples=['5.25'],
    )


class PageOfPositionFundingHistoryDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias='hasNext',
        description='Whether there are more objects to paginate through',
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias='nextCursor',
        description='Pointer to the next page in pagination dataset',
    )
    data: List[PositionFundingHistoryDto] = Field(
        ..., description='Array of funding history records'
    )


class UnrealizedPnlHistoryDto(BaseModel):
    time: float = Field(
        ...,
        description='Timestamp of the unrealized PnL record (ms since Unix Epoch)',
        examples=[1712019600000],
    )
    unrealized_pnl: str = Field(
        ...,
        alias='unrealizedPnl',
        description='Unrealized PnL at this point in time, expressed as a decimal (precision: 9)',
        examples=['150.75'],
    )


class PageOfUnrealizedPnlHistoryDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias='hasNext',
        description='Whether there are more objects to paginate through',
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias='nextCursor',
        description='Pointer to the next page in pagination dataset',
    )
    data: List[UnrealizedPnlHistoryDto] = Field(
        ..., description='Array of unrealized PnL history records'
    )


class VolumeHistoryDto(BaseModel):
    time: float = Field(
        ...,
        description='Timestamp of the volume record (ms since Unix Epoch)',
        examples=[1712019600000],
    )
    volume_usd: str = Field(
        ...,
        alias='volumeUsd',
        description='Volume in USD during this time interval, expressed as a decimal (precision: 9)',
        examples=['150.75'],
    )


class PageOfVolumeHistoryDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias='hasNext',
        description='Whether there are more objects to paginate through',
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias='nextCursor',
        description='Pointer to the next page in pagination dataset',
    )
    data: List[VolumeHistoryDto] = Field(
        ..., description='Array of volume history records'
    )


class ProductFundingHistoryDto(BaseModel):
    time: float = Field(
        ...,
        description='Timestamp of the funding charge (ms since Unix Epoch)',
        examples=[1712019600000],
    )
    settled_at: float = Field(
        ...,
        alias='settledAt',
        description='Timestamp of the funding settlement (ms since Unix Epoch)',
        examples=[1712019600000],
    )
    product_id: str = Field(
        ...,
        alias='productId',
        description='Id representing the product',
        examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a'],
    )
    product_ticker: str = Field(
        ..., alias='productTicker', description='Product ticker', examples=['ETHUSD']
    )
    long_funding_charge: str = Field(
        ...,
        alias='longFundingCharge',
        description='Total funding charge for all longs (positive means pay, negative means receive), expressed as a decimal (precision: 9)',
        examples=['5.25'],
    )
    short_funding_charge: str = Field(
        ...,
        alias='shortFundingCharge',
        description='Total funding charge for all shorts (positive means pay, negative means receive), expressed as a decimal (precision: 9)',
        examples=['5.25'],
    )


class PageOfProductFundingHistoryDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias='hasNext',
        description='Whether there are more objects to paginate through',
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias='nextCursor',
        description='Pointer to the next page in pagination dataset',
    )
    data: List[ProductFundingHistoryDto] = Field(
        ..., description='Array of funding history records'
    )


class Order(Enum):
    asc = 'asc'
    desc = 'desc'


class Side6(Enum):
    number_0 = 0
    number_1 = 1


class StopType3(Enum):
    number_0 = 0
    number_1 = 1


class IsWorking(Enum):
    boolean_true = True


class IsPending(Enum):
    boolean_true = True


class OrderBy(Enum):
    created_at = 'createdAt'


class V1OrderGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    subaccount_id: UUID = Field(..., alias='subaccountId')
    client_order_id: Optional[str] = Field(None, alias='clientOrderId')
    product_ids: Optional[List[UUID]] = Field(None, alias='productIds', min_length=1)
    created_after: Optional[float] = Field(None, alias='createdAfter')
    created_before: Optional[float] = Field(None, alias='createdBefore')
    side: Optional[Side6] = None
    close: Optional[bool] = None
    stop_types: Optional[List[StopType3]] = Field(None, alias='stopTypes', examples=[0])
    is_working: Optional[IsWorking] = Field(None, alias='isWorking', examples=[True])
    is_pending: Optional[IsPending] = Field(None, alias='isPending', examples=[True])
    order_by: Optional[OrderBy] = Field(None, alias='orderBy', examples=['createdAt'])


class OrderBy1(Enum):
    product_id = 'productId'
    filled = 'filled'
    price = 'price'
    created_at = 'createdAt'


class V1OrderFillGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    subaccount_id: UUID = Field(..., alias='subaccountId')
    product_ids: Optional[List[UUID]] = Field(None, alias='productIds', min_length=1)
    created_after: Optional[float] = Field(None, alias='createdAfter')
    created_before: Optional[float] = Field(None, alias='createdBefore')
    side: Optional[Side6] = Field(None, examples=[0])
    order_by: Optional[OrderBy1] = Field(None, alias='orderBy', examples=['productId'])
    include_self_trades: Optional[bool] = Field(False, alias='includeSelfTrades')


class OrderBy2(Enum):
    created_at = 'createdAt'


class V1OrderTradeGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    product_id: UUID = Field(
        ..., alias='productId', examples=['1b67d5b3-9dc7-4410-bc9c-7fd23ebd32ee']
    )
    order_by: Optional[OrderBy2] = Field(None, alias='orderBy', examples=['createdAt'])


class OrderBy3(Enum):
    size = 'size'
    created_at = 'createdAt'
    updated_at = 'updatedAt'
    realized_pnl = 'realizedPnl'


class V1PositionGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    subaccount_id: UUID = Field(..., alias='subaccountId')
    product_ids: Optional[List[UUID]] = Field(None, alias='productIds', min_length=1)
    open: Optional[bool] = Field(None, examples=[True])
    order_by: Optional[OrderBy3] = Field(None, alias='orderBy', examples=['size'])
    created_after: Optional[float] = Field(None, alias='createdAfter')
    created_before: Optional[float] = Field(None, alias='createdBefore')
    side: Optional[Side6] = Field(None, examples=[0])
    is_liquidated: Optional[bool] = Field(None, alias='isLiquidated', examples=[False])


class V1PositionActiveGetParametersQuery(BaseModel):
    subaccount_id: UUID = Field(..., alias='subaccountId')
    product_id: UUID = Field(..., alias='productId')


class OrderBy4(Enum):
    price = 'price'
    filled = 'filled'
    created_at = 'createdAt'


class V1PositionFillGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    position_id: UUID = Field(
        ..., alias='positionId', examples=['81215694-2d9f-4a87-af57-a710118938c0']
    )
    order_by: Optional[OrderBy4] = Field(None, alias='orderBy', examples=['price'])


class OrderBy5(Enum):
    created_at = 'createdAt'
    open_interest = 'openInterest'
    base_token_name = 'baseTokenName'
    quote_token_name = 'quoteTokenName'


class V1ProductGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    order_by: Optional[OrderBy5] = Field(None, alias='orderBy', examples=['createdAt'])
    ticker: Optional[constr(min_length=1, max_length=32)] = Field(
        None, examples=['ETHUSD']
    )


class V1ProductMarketLiquidityGetParametersQuery(BaseModel):
    product_id: UUID = Field(
        ..., alias='productId', examples=['9036443a-441a-4a66-87f2-bd5c44cdca7a']
    )


class V1ProductMarketPriceGetParametersQuery(BaseModel):
    product_ids: List[UUID] = Field(
        ..., alias='productIds', max_length=20, min_length=1
    )


class Range(Enum):
    day = 'DAY'
    week = 'WEEK'
    month = 'MONTH'


class OrderBy6(Enum):
    created_at = 'createdAt'


class V1FundingGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    product_id: UUID = Field(..., alias='productId')
    range: Range = Field(..., examples=['DAY'])
    order_by: Optional[OrderBy6] = Field(None, alias='orderBy', examples=['createdAt'])


class V1FundingProjectedGetParametersQuery(BaseModel):
    product_id: UUID = Field(..., alias='productId')


class OrderBy7(Enum):
    created_at = 'createdAt'
    name = 'name'


class V1SubaccountGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    name: Optional[str] = None
    sender: str
    order_by: Optional[OrderBy7] = Field(None, alias='orderBy', examples=['createdAt'])


class OrderBy8(Enum):
    token_name = 'tokenName'
    updated_at = 'updatedAt'
    amount = 'amount'


class V1SubaccountBalanceGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    subaccount_id: UUID = Field(..., alias='subaccountId')
    order_by: Optional[OrderBy8] = Field(None, alias='orderBy', examples=['tokenName'])


class V1LinkedSignerQuotaGetParametersQuery(BaseModel):
    subaccount_id: UUID = Field(..., alias='subaccountId')


class Status4(Enum):
    pending = 'PENDING'
    active = 'ACTIVE'
    pending_revoke = 'PENDING_REVOKE'
    revoked = 'REVOKED'
    rejected = 'REJECTED'


class OrderBy9(Enum):
    created_at = 'createdAt'
    expires_at = 'expiresAt'


class V1LinkedSignerGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    subaccount_id: UUID = Field(..., alias='subaccountId')
    statuses: Optional[List[Status4]] = Field(None, examples=[['ACTIVE']])
    order_by: Optional[OrderBy9] = Field(None, alias='orderBy', examples=['createdAt'])


class OrderBy10(Enum):
    created_at = 'createdAt'


class V1TokenWithdrawGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    subaccount_id: UUID = Field(..., alias='subaccountId')
    is_active: Optional[bool] = Field(None, alias='isActive', examples=[True])
    order_by: Optional[OrderBy10] = Field(None, alias='orderBy', examples=['createdAt'])


class Status5(Enum):
    submitted = 'SUBMITTED'
    pending = 'PENDING'
    completed = 'COMPLETED'
    rejected = 'REJECTED'


class V1TokenTransferGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    subaccount_id: UUID = Field(..., alias='subaccountId')
    statuses: Optional[List[Status5]] = Field(None, examples=['COMPLETED'])
    types: Optional[List[Type5]] = Field(None, examples=['WITHDRAW'])
    order_by: Optional[OrderBy10] = Field(None, alias='orderBy', examples=['createdAt'])
    created_after: Optional[float] = Field(None, alias='createdAfter')
    created_before: Optional[float] = Field(None, alias='createdBefore')


class V1TokenGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    deposit_enabled: Optional[bool] = Field(
        None, alias='depositEnabled', examples=[True]
    )
    withdraw_enabled: Optional[bool] = Field(
        None, alias='withdrawEnabled', examples=[True]
    )
    order_by: Optional[OrderBy10] = Field(None, alias='orderBy', examples=['createdAt'])


class V1WhitelistGetParametersQuery(BaseModel):
    address: str = Field(..., examples=['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'])


class V1PointsGetParametersQuery(BaseModel):
    address: str = Field(..., examples=['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'])
    season: confloat(ge=0.0, le=10.0) = Field(..., examples=[1])
    epoch: confloat(ge=1.0, le=256.0) = Field(..., examples=[1])


class V1PointsSummaryGetParametersQuery(BaseModel):
    address: str = Field(..., examples=['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'])


class Resolution(Enum):
    day1 = 'day1'
    month1 = 'month1'
    week1 = 'week1'
    hour1 = 'hour1'
    hour12 = 'hour12'
    hour2 = 'hour2'
    hour4 = 'hour4'
    hour8 = 'hour8'
    minute1 = 'minute1'
    minute15 = 'minute15'
    minute3 = 'minute3'
    minute30 = 'minute30'
    minute5 = 'minute5'


class OrderBy13(Enum):
    time = 'time'


class ArchiveV1SubaccountBalanceGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    start_time: float = Field(..., alias='startTime')
    end_time: Optional[float] = Field('2025-10-14T23:56:45.590Z', alias='endTime')
    resolution: Resolution = Field(..., examples=['hour2'])
    order_by: Optional[OrderBy13] = Field(None, alias='orderBy', examples=['time'])
    subaccount_id: UUID = Field(..., alias='subaccountId')


class ArchiveV1SubaccountFundingGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    start_time: float = Field(..., alias='startTime')
    end_time: Optional[float] = Field('2025-10-14T23:56:44.756Z', alias='endTime')
    order_by: Optional[OrderBy13] = Field(None, alias='orderBy', examples=['time'])
    subaccount_id: UUID = Field(
        ..., alias='subaccountId', examples=['d290f1ee-6c54-4b01-90e6-d701748f0851']
    )
    position_ids: Optional[List[UUID]] = Field(
        None, alias='positionIds', max_length=128, min_length=1
    )
    product_ids: Optional[List[UUID]] = Field(None, alias='productIds', min_length=1)


class ArchiveV1SubaccountUnrealizedPnlGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    start_time: float = Field(..., alias='startTime')
    end_time: Optional[float] = Field('2025-10-14T23:56:45.603Z', alias='endTime')
    resolution: Resolution = Field(..., examples=['hour2'])
    order_by: Optional[OrderBy13] = Field(None, alias='orderBy', examples=['time'])
    subaccount_id: UUID = Field(..., alias='subaccountId')


class ArchiveV1SubaccountVolumeGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    start_time: float = Field(..., alias='startTime')
    end_time: Optional[float] = Field('2025-10-14T23:56:45.606Z', alias='endTime')
    resolution: Resolution = Field(..., examples=['hour2'])
    order_by: Optional[OrderBy13] = Field(None, alias='orderBy', examples=['time'])
    subaccount_id: UUID = Field(..., alias='subaccountId')
