syntax = "proto3";

package gitaly;

import "lint.proto";
import "raftpb/raft.proto"; // Upstream go.etcd.io/raft/v3/raftpb/raft.proto

option go_package = "gitlab.com/gitlab-org/gitaly/v16/proto/go/gitalypb";

// RaftEntry encapsulates critical data for replication using etcd/raft library.
// It has a request ID allowing the primary to track when the action is
// effectively applied.
message RaftEntry {
  // LogData contains serialized log data, including the log entry itself
  // and all attached files in the log entry's directory. These data are
  // exchanged at the Transport layer before sending and after receiving
  // messages. They remain transparent to the core Raft engine.
  message LogData {
    // local_path is the path to the staging log entry directory. Before the
    // request is sent to other nodes, this whole directory of the entry is
    // serialized. So, this field is only relevant to the primary node who
    // issues the request.
    bytes local_path = 1;
    // packed is the serialized form of the log entry data. Transport
    // implementations populates this field before sending out messages to other
    // members of a Raft group.
    bytes packed = 2;
  }

  // id is the unique identifier for the Raft message. This ID is generated by
  // an in-memory event registry. Raft uses this ID to track the commit status
  // of a log entry.
  uint64 id = 1;

  // data represents packed and serialized log data.
  LogData data = 2;
}

// RaftPartitionKey is a globally-unique identifier for a replicated partition.
// The replica which minted the partition is responsible for computing the RaftPartitionKey,
// which is a hash of the storage name and partition ID. The key is then consumed
// as-is by other replicas wishing to store the partition.
message RaftPartitionKey {
  // value is the SHA256 digest of the storage name and partition ID of the
  // newly-minted partition.
  string value = 1;
}

// ReplicaID uniquely identifies a replica in the Raft cluster.
// It combines partition information with node-specific details.
message ReplicaID {
  // partition_key identifies which partition this replica belongs to.
  RaftPartitionKey partition_key = 1;
  // member_id is the unique identifier assigned by etcd/raft.
  uint64 member_id = 2;
  // storage_name is the name of the storage where this replica is hosted.
  string storage_name = 3;
  // Metadata contains routing information for the replica.
  message Metadata {
    // address is the network address of the replica.
    string address = 1;
  }
  // metadata contains replica information.
  Metadata metadata = 4;
  // ReplicaType indicates whether a replica is a voter or learner in the Raft cluster
  enum ReplicaType {
    // REPLICA_TYPE_UNSPECIFIED.
    REPLICA_TYPE_UNSPECIFIED = 0;
    // REPLICA_TYPE_VOTER indicates a replica that can participate in Raft elections and voting.
    REPLICA_TYPE_VOTER = 1;
    // REPLICA_TYPE_LEARNER indicates a replica that receives updates but cannot vote.
    REPLICA_TYPE_LEARNER = 2;
  }
  // type indicates whether the replica is learner or voter.
  ReplicaType type = 5;
}

// RaftMessageRequest is a request for the SendMessage RPC. It serves as a
// wrapper for raftpb.Message. etcd/raft's state machines on each member emit
// this message. Since Gitaly employs multi-raft, routing metadata is attached
// to ensure the message reaches the correct Raft group inside the receiving
// Gitaly server.
message RaftMessageRequest {
  // cluster_id is the identifier of the Raft cluster to which this message belongs.
  string cluster_id = 1;

  // replica_id uniquely identifies a replica in the Raft cluster.
  ReplicaID replica_id = 2;

  // message is the Raft message to be delivered.
  raftpb.Message message = 3;
}

// RaftMessageResponse represents a response to the SendMessage RPC.
message RaftMessageResponse {
}

// RaftSnapshotMessageRequest is the input to SendSnapshot RPC.
message RaftSnapshotMessageRequest {
  oneof raft_snapshot_payload {
    // raft_msg is a wrapper for raftpb.Message
    RaftMessageRequest raft_msg = 1;
    // chunk of snapshot data
    bytes chunk = 2;
  }
}

// RaftSnapshotMessageResponse is the response to SendSnapshot RPC.
message RaftSnapshotMessageResponse {
  // destination is where the snapshot is saved.
  string destination = 1;
  // snapshot_size is the snapshot size in bytes.
  uint64 snapshot_size = 2;
}

// JoinClusterRequest is sent by the leader to a new node to join a specific partition.
message JoinClusterRequest {
  // partition_key identifies which partition the new node should join.
  RaftPartitionKey partition_key = 1;

  // leader_id is the Member ID of the current Raft group leader
  uint64 leader_id = 2;

  // member_id is the unique Raft member ID assigned by the leader for this replica.
  uint64 member_id = 3;

  // term is logical time in the Raft cluster
  uint64 term = 4;

  // index refers to the position of a log entry
  uint64 index = 5;

  // storage_name is the name of the storage where the replica should be created.
  string storage_name = 6 [(gitaly.storage) = true];

  // relative_path is the path within the storage where the partition data is located.
  string relative_path = 7;

  // replicas contains the current list of all cluster members for routing table initialization.
  repeated ReplicaID replicas = 8;
}

// JoinClusterResponse indicates the result of the join operation.
message JoinClusterResponse {
}

// RaftClusterInfoRequest is the request for the GetClusterInfo RPC.
message RaftClusterInfoRequest {
  // cluster_id is the identifier of the Raft cluster to query.
  string cluster_id = 1;
  // partition_key is an optional filter to get information about a specific partition.
  // If not provided, returns information about all partitions.
  RaftPartitionKey partition_key = 2;
  // include_replica_details determines whether to include detailed replica state information.
  bool include_replica_details = 3;
}

// RaftClusterInfoResponse is the response for the GetClusterInfo streaming RPC.
// Each response message contains information about a single partition.
message RaftClusterInfoResponse {
  // ReplicaStatus contains status information about a single replica.
  message ReplicaStatus {
    // replica_id uniquely identifies the replica.
    ReplicaID replica_id = 1;
    // is_leader indicates whether this replica is currently the leader.
    bool is_leader = 2;
    // is_healthy indicates whether the replica is reachable and functioning.
    bool is_healthy = 3;
    // last_index is the index of the last log entry this replica has.
    uint64 last_index = 4;
    // match_index is the highest log index known to be replicated on this replica.
    uint64 match_index = 5;
    // state represents the Raft state of this replica (follower, candidate, leader).
    string state = 6;
  }

  // cluster_id is the identifier of the Raft cluster.
  string cluster_id = 1;
  // partition_key identifies the partition this response describes.
  RaftPartitionKey partition_key = 2;
  // replicas contains information about all replicas in this partition.
  repeated ReplicaStatus replicas = 3;
  // leader_id is the member ID of the current leader, 0 if no leader.
  uint64 leader_id = 4;
  // term is the current Raft term for this partition.
  uint64 term = 5;
  // index is the current Raft log index for this partition.
  uint64 index = 6;
  // relative_path is the repository path for backward compatibility.
  string relative_path = 7;
}

// RaftService manages the sending of Raft messages to peers.
service RaftService {
  // SendMessage processes Raft messages and ensures they are handled by
  // the receiving node to update its Raft state machine.
  rpc SendMessage(stream RaftMessageRequest) returns (RaftMessageResponse) {
    option (op_type) = {
      op: MUTATOR
      scope_level: STORAGE
    };
  }
  // SendSnapshot sends raft snapshots from the leader to the follower node. Typically it
  // would be useful for nodes to catch up to the latest state.
  rpc SendSnapshot(stream RaftSnapshotMessageRequest) returns (RaftSnapshotMessageResponse) {
    option (op_type) = {
      op: MUTATOR
      scope_level: STORAGE
    };
  }

  // JoinCluster is called by the leader to instruct a new node to join an existing cluster.
  rpc JoinCluster(JoinClusterRequest) returns (JoinClusterResponse) {
    option (op_type) = {
      op: MUTATOR
      scope_level: STORAGE
    };
  }

  // GetClusterInfo retrieves comprehensive information about the Raft cluster topology,
  // partition states, and replica health. This is useful for monitoring and debugging.
  // Returns a stream of partition information, one response per partition.
  rpc GetClusterInfo(RaftClusterInfoRequest) returns (stream RaftClusterInfoResponse) {
    option (op_type) = {
      op: ACCESSOR
      scope_level: STORAGE
    };
  }
}
