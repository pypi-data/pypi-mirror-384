schema_version: "1.0.0"
metadata:
  title: "FastAPI Backend Assistant"
  description: "AI assistant for modern Python FastAPI backend development"
  version: "1.0.0"
  author: "Backend Team"
  tags: ["python", "fastapi", "rest-api", "async"]

targets:
  - copilot
  - cursor
  - continue
  - claude

context:
  project_type: "api"
  technologies:
    - "python"
    - "fastapi"
    - "pydantic"
    - "sqlalchemy"
    - "alembic"
    - "pytest"
    - "docker"
    - "postgresql"
  description: |
    High-performance async REST API built with FastAPI, using modern Python
    type hints, automatic documentation, and database migrations.

instructions:
  general:
    - "Use async/await for all I/O operations (database, external APIs)"
    - "Leverage Pydantic models for request/response validation"
    - "Follow REST API best practices and HTTP status code conventions"
    - "Use dependency injection for database sessions and services"
    - "Implement proper error handling with custom exception handlers"

  code_style:
    - "Use type hints for all function signatures"
    - "Follow PEP 8 style guide with Black formatter"
    - "Keep route handlers thin - delegate logic to services"
    - "Use descriptive variable names (avoid abbreviations)"
    - "Document all API endpoints with docstrings for auto-generated docs"

  architecture:
    - "Structure code: routers, schemas, models, services, repositories"
    - "Use repository pattern for database access"
    - "Implement service layer for business logic"
    - "Keep Pydantic schemas separate from SQLAlchemy models"
    - "Use Alembic for database migrations"

  testing:
    - "Write pytest tests for all API endpoints"
    - "Use pytest fixtures for test database and client"
    - "Test authentication and authorization thoroughly"
    - "Include tests for edge cases and error conditions"
    - "Use pytest-cov to maintain >85% code coverage"

  security:
    - "Use OAuth2 with JWT tokens for authentication"
    - "Hash passwords with bcrypt before storing"
    - "Implement rate limiting to prevent abuse"
    - "Validate and sanitize all user inputs"
    - "Use HTTPS in production and set secure headers"

  performance:
    - "Use connection pooling for database connections"
    - "Implement caching for frequently accessed data"
    - "Use async database drivers (asyncpg for PostgreSQL)"
    - "Index database columns used in queries"
    - "Consider pagination for large result sets"

examples:
  api_endpoint: |
    ```python
    from fastapi import APIRouter, Depends, HTTPException, status
    from sqlalchemy.ext.asyncio import AsyncSession

    from app.database import get_db
    from app.schemas import UserCreate, UserResponse
    from app.services import UserService

    router = APIRouter(prefix="/users", tags=["users"])

    @router.post("/", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
    async def create_user(
        user: UserCreate,
        db: AsyncSession = Depends(get_db),
    ) -> UserResponse:
        """Create a new user account."""
        service = UserService(db)
        try:
            return await service.create_user(user)
        except ValueError as e:
            raise HTTPException(status_code=400, detail=str(e))
    ```

  pydantic_schema: |
    ```python
    from pydantic import BaseModel, EmailStr, Field
    from datetime import datetime

    class UserBase(BaseModel):
        email: EmailStr
        username: str = Field(..., min_length=3, max_length=50)

    class UserCreate(UserBase):
        password: str = Field(..., min_length=8)

    class UserResponse(UserBase):
        id: int
        created_at: datetime

        class Config:
            from_attributes = True
    ```

  service_layer: |
    ```python
    from sqlalchemy.ext.asyncio import AsyncSession
    from app.models import User
    from app.schemas import UserCreate, UserResponse
    from app.security import hash_password

    class UserService:
        def __init__(self, db: AsyncSession):
            self.db = db

        async def create_user(self, user: UserCreate) -> User:
            hashed_password = hash_password(user.password)
            db_user = User(
                email=user.email,
                username=user.username,
                hashed_password=hashed_password,
            )
            self.db.add(db_user)
            await self.db.commit()
            await self.db.refresh(db_user)
            return db_user
    ```

variables:
  API_VERSION: "v1"
  DATABASE_URL: "postgresql+asyncpg://user:pass@localhost/dbname"
