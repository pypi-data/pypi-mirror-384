schema_version: "1.0.0"
metadata:
  title: "Rust CLI Tool Assistant"
  description: "AI assistant for building command-line tools in Rust"
  version: "1.0.0"
  author: "Systems Team"
  tags: ["rust", "cli", "systems-programming"]

targets:
  - copilot
  - cursor
  - continue
  - claude

context:
  project_type: "cli_tool"
  technologies:
    - "rust"
    - "clap"
    - "tokio"
    - "serde"
    - "anyhow"
    - "cargo"
  description: |
    High-performance command-line tool written in Rust with proper error handling,
    async support, and cross-platform compatibility.

instructions:
  general:
    - "Follow Rust idioms and best practices"
    - "Use Result<T, E> for error handling, never panic in library code"
    - "Leverage the type system for correctness guarantees"
    - "Write comprehensive documentation comments (///)"
    - "Keep functions small and focused on single responsibility"

  code_style:
    - "Use rustfmt for consistent code formatting"
    - "Run clippy and fix all warnings before committing"
    - "Follow Rust naming conventions (snake_case for variables/functions)"
    - "Use meaningful error messages with context"
    - "Prefer borrowing over cloning when possible"

  architecture:
    - "Structure: main.rs, lib.rs, and domain modules"
    - "Use clap for CLI argument parsing with derive API"
    - "Implement error handling with thiserror or anyhow"
    - "Use tokio for async runtime if needed"
    - "Keep business logic separate from CLI interface"

  testing:
    - "Write unit tests for all public functions"
    - "Use property-based testing with proptest for complex logic"
    - "Test error paths explicitly"
    - "Use criterion for benchmark tests"
    - "Aim for >80% code coverage"

  performance:
    - "Profile with cargo flamegraph before optimizing"
    - "Use appropriate collection types (Vec vs HashMap)"
    - "Consider using rayon for parallelizable workloads"
    - "Avoid unnecessary allocations and clones"
    - "Use release builds for benchmarking"

  security:
    - "Validate all user inputs thoroughly"
    - "Use cargo-audit to check for vulnerable dependencies"
    - "Avoid unsafe code unless absolutely necessary"
    - "Handle file I/O errors gracefully"
    - "Never expose sensitive data in error messages"

examples:
  main_cli: |
    ```rust
    use clap::Parser;
    use anyhow::Result;

    #[derive(Parser)]
    #[command(name = "mytool")]
    #[command(about = "A CLI tool for doing things", long_about = None)]
    struct Cli {
        /// Input file path
        #[arg(short, long)]
        input: String,

        /// Output file path
        #[arg(short, long)]
        output: Option<String>,

        /// Enable verbose output
        #[arg(short, long)]
        verbose: bool,
    }

    fn main() -> Result<()> {
        let cli = Cli::parse();

        if cli.verbose {
            println!("Processing {}...", cli.input);
        }

        // Business logic here
        mytool::process(&cli.input, cli.output.as_deref())?;

        Ok(())
    }
    ```

  error_handling: |
    ```rust
    use thiserror::Error;

    #[derive(Error, Debug)]
    pub enum ToolError {
        #[error("Failed to read file: {0}")]
        FileRead(#[from] std::io::Error),

        #[error("Invalid input format at line {line}")]
        InvalidFormat { line: usize },

        #[error("Processing failed: {0}")]
        ProcessingError(String),
    }

    pub type Result<T> = std::result::Result<T, ToolError>;

    pub fn process_file(path: &str) -> Result<Vec<String>> {
        let contents = std::fs::read_to_string(path)?;

        if contents.is_empty() {
            return Err(ToolError::InvalidFormat { line: 0 });
        }

        Ok(contents.lines().map(String::from).collect())
    }
    ```

  async_example: |
    ```rust
    use tokio::fs::File;
    use tokio::io::{AsyncReadExt, AsyncWriteExt};
    use anyhow::Result;

    #[tokio::main]
    async fn main() -> Result<()> {
        let mut file = File::open("input.txt").await?;
        let mut contents = String::new();
        file.read_to_string(&mut contents).await?;

        let processed = process_data(&contents);

        let mut output = File::create("output.txt").await?;
        output.write_all(processed.as_bytes()).await?;

        Ok(())
    }

    fn process_data(data: &str) -> String {
        data.to_uppercase()
    }
    ```

variables:
  TOOL_NAME: "mytool"
  MIN_RUST_VERSION: "1.70"
