# Example: Node.js API Service

schema_version: "1.0.0"

metadata:
  title: "Node.js API Service Assistant"
  description: "AI assistant configuration for a RESTful API service built with Node.js"
  version: "1.0.0"
  author: "backend-team@company.com"
  created: "2024-01-01"
  updated: "2024-01-15"
  tags: ["nodejs", "api", "backend", "express", "postgresql"]

targets:
  - copilot
  - cursor
  - continue

context:
  project_type: "api_service"
  technologies:
    - "node.js"
    - "express"
    - "typescript"
    - "postgresql"
    - "prisma"
    - "jwt"
    - "redis"
  description: |
    A RESTful API service built with Node.js, Express, and TypeScript.
    Uses PostgreSQL as the primary database with Prisma ORM.
    Implements JWT authentication, Redis for caching, and follows
    clean architecture principles with proper error handling.

instructions:
  general:
    - "Write clean, readable, and maintainable code"
    - "Use TypeScript with strict type checking enabled"
    - "Follow RESTful API design principles"
    - "Implement comprehensive error handling and logging"
    - "Use async/await instead of Promises for better readability"
  
  code_style:
    - "Use camelCase for variables and functions"
    - "Use PascalCase for classes and interfaces"
    - "Use UPPER_SNAKE_CASE for constants"
    - "Prefer const over let, avoid var"
    - "Use meaningful and descriptive names"
    - "Follow the existing ESLint and Prettier configuration"
  
  architecture:
    - "Follow the layered architecture: routes → controllers → services → repositories"
    - "Separate business logic from HTTP concerns"
    - "Use dependency injection for better testability"
    - "Implement proper validation for all endpoints"
    - "Use middleware for cross-cutting concerns"
  
  security:
    - "Validate and sanitize all user inputs"
    - "Use parameterized queries to prevent SQL injection"
    - "Implement proper authentication and authorization"
    - "Never log sensitive information like passwords or tokens"
    - "Use HTTPS in production and secure headers"
  
  testing:
    - "Write unit tests for all business logic"
    - "Use integration tests for API endpoints"
    - "Mock external dependencies in tests"
    - "Use descriptive test names that explain the scenario"
    - "Aim for at least 85% code coverage"
  
  performance:
    - "Use database indexing for frequently queried columns"
    - "Implement caching for expensive operations"
    - "Use connection pooling for database connections"
    - "Optimize database queries to avoid N+1 problems"
    - "Implement pagination for large data sets"

examples:
  controller: |
    ```typescript
    import { Request, Response, NextFunction } from 'express';
    import { UserService } from '../services/UserService';
    import { CreateUserDto, UpdateUserDto } from '../dto/UserDto';
    import { ValidationError } from '../errors/ValidationError';
    
    export class UserController {
      constructor(private userService: UserService) {}
    
      async createUser(req: Request, res: Response, next: NextFunction) {
        try {
          const createUserDto: CreateUserDto = req.body;
          const user = await this.userService.createUser(createUserDto);
          
          res.status(201).json({
            success: true,
            data: user,
            message: 'User created successfully'
          });
        } catch (error) {
          next(error);
        }
      }
    
      async getUserById(req: Request, res: Response, next: NextFunction) {
        try {
          const { id } = req.params;
          const user = await this.userService.getUserById(id);
          
          if (!user) {
            return res.status(404).json({
              success: false,
              message: 'User not found'
            });
          }
          
          res.json({
            success: true,
            data: user
          });
        } catch (error) {
          next(error);
        }
      }
    }
    ```
  
  service: |
    ```typescript
    import { User, CreateUserDto, UpdateUserDto } from '../types/User';
    import { UserRepository } from '../repositories/UserRepository';
    import { ValidationError } from '../errors/ValidationError';
    import { hashPassword } from '../utils/crypto';
    
    export class UserService {
      constructor(private userRepository: UserRepository) {}
    
      async createUser(createUserDto: CreateUserDto): Promise<User> {
        // Validate input
        if (!createUserDto.email || !createUserDto.password) {
          throw new ValidationError('Email and password are required');
        }
    
        // Check if user already exists
        const existingUser = await this.userRepository.findByEmail(createUserDto.email);
        if (existingUser) {
          throw new ValidationError('User with this email already exists');
        }
    
        // Hash password
        const hashedPassword = await hashPassword(createUserDto.password);
    
        // Create user
        const userData = {
          ...createUserDto,
          password: hashedPassword,
          createdAt: new Date(),
          updatedAt: new Date()
        };
    
        return this.userRepository.create(userData);
      }
    
      async getUserById(id: string): Promise<User | null> {
        return this.userRepository.findById(id);
      }
    }
    ```
  
  middleware: |
    ```typescript
    import { Request, Response, NextFunction } from 'express';
    import jwt from 'jsonwebtoken';
    import { AuthenticationError } from '../errors/AuthenticationError';
    
    interface AuthenticatedRequest extends Request {
      user?: { id: string; email: string };
    }
    
    export const authenticateToken = (
      req: AuthenticatedRequest,
      res: Response,
      next: NextFunction
    ) => {
      const authHeader = req.headers['authorization'];
      const token = authHeader && authHeader.split(' ')[1];
    
      if (!token) {
        throw new AuthenticationError('Access token required');
      }
    
      jwt.verify(token, process.env.JWT_SECRET!, (err, user) => {
        if (err) {
          throw new AuthenticationError('Invalid or expired token');
        }
        
        req.user = user as { id: string; email: string };
        next();
      });
    };
    
    export const errorHandler = (
      error: Error,
      req: Request,
      res: Response,
      next: NextFunction
    ) => {
      console.error('Error:', error);
    
      if (error instanceof ValidationError) {
        return res.status(400).json({
          success: false,
          message: error.message,
          type: 'ValidationError'
        });
      }
    
      if (error instanceof AuthenticationError) {
        return res.status(401).json({
          success: false,
          message: error.message,
          type: 'AuthenticationError'
        });
      }
    
      res.status(500).json({
        success: false,
        message: 'Internal server error',
        type: 'InternalError'
      });
    };
    ```

variables:
  PROJECT_NAME: "API Service"
  TEAM_EMAIL: "backend-team@company.com"
  DATABASE: "PostgreSQL"
  ORM: "Prisma"

editor_specific:
  copilot:
    additional_instructions:
      - "Generate comprehensive API documentation comments"
      - "Suggest appropriate error handling patterns"
      - "Provide TypeScript type definitions for DTOs"
      - "Focus on security best practices for APIs"
  
  cursor:
    additional_instructions:
      - "Focus on quick API endpoint implementations"
      - "Suggest database query optimizations"
      - "Prioritize security and validation"
  
  continue:
    custom_commands:
      - name: "endpoint"
        prompt: "Create a complete REST endpoint with controller, service, and types for: {{{ input }}}"
        description: "Generates a complete API endpoint with all layers"
      - name: "test-api"
        prompt: "Generate integration tests for this API endpoint: {{{ input }}}"
        description: "Creates comprehensive API tests"
      - name: "validate"
        prompt: "Add input validation and error handling to: {{{ input }}}"
        description: "Adds validation and error handling to API code"
