from ..assertion_engine import assertion_formatter_used as assertion_formatter_used, with_assertion_polling as with_assertion_polling
from ..base import LibraryComponent as LibraryComponent
from ..generated.playwright_pb2 import Request as Request
from ..utils import ClientCertificate as ClientCertificate, ColorScheme as ColorScheme, DownloadInfo as DownloadInfo, ForcedColors as ForcedColors, GeoLocation as GeoLocation, HttpCredentials as HttpCredentials, NewPageDetails as NewPageDetails, PageLoadStates as PageLoadStates, Permission as Permission, Proxy as Proxy, RecordHar as RecordHar, RecordVideo as RecordVideo, ReduceMotion as ReduceMotion, SelectionType as SelectionType, ServiceWorkersPermissions as ServiceWorkersPermissions, SupportedBrowsers as SupportedBrowsers, ViewportDimensions as ViewportDimensions, convert_typed_dict as convert_typed_dict, find_by_id as find_by_id, keyword as keyword, locals_to_params as locals_to_params, logger as logger
from ..utils.logger import LOGLEVEL as LOGLEVEL
from Browser.utils.data_types import BrowserInfo as BrowserInfo, TracingGroupMode as TracingGroupMode
from Browser.utils.misc import get_download_id as get_download_id
from Browser.utils.robot_booleans import is_truthy as is_truthy
from assertionengine import AssertionOperator as AssertionOperator
from datetime import timedelta
from pathlib import Path
from typing import Any

class PlaywrightState(LibraryComponent):
    def open_browser(self, url: str | None = None, browser: SupportedBrowsers = ..., headless: bool = False, pause_on_failure: bool = True, bypassCSP: bool = True): ...
    def close_browser(self, browser: SelectionType | str = ...): ...
    def delete_browser_id_from_arg_mapping(self, closed_browser_id: str) -> None: ...
    def close_context(self, context: SelectionType | str = ..., browser: SelectionType | str = ..., *, save_trace: bool = True): ...
    def close_page(self, page: SelectionType | NewPageDetails | str = ..., context: SelectionType | str = ..., browser: SelectionType | str = ..., runBeforeUnload: bool = False) -> list[dict]: ...
    def set_default_run_before_unload(self, runBeforeUnload: bool) -> bool: ...
    def connect_to_browser(self, wsEndpoint: str, browser: SupportedBrowsers = ..., use_cdp: bool = False, *, timeout: timedelta = ...): ...
    def new_browser(self, browser: SupportedBrowsers = ..., headless: bool = True, *, args: list[str] | None = None, channel: str | None = None, chromiumSandbox: bool = False, devtools: bool = False, downloadsPath: str | None = None, env: dict | None = None, executablePath: str | None = None, firefoxUserPrefs: dict[str, str | int | float | bool] | None = None, handleSIGHUP: bool = True, handleSIGINT: bool = True, handleSIGTERM: bool = True, ignoreDefaultArgs: list[str] | bool | None = None, proxy: Proxy | None = None, reuse_existing: bool = True, slowMo: timedelta = ..., timeout: timedelta = ...) -> str: ...
    def launch_browser_server(self, browser: SupportedBrowsers = ..., headless: bool = True, *, args: list[str] | None = None, channel: str | None = None, chromiumSandbox: bool = False, devtools: bool = False, downloadsPath: str | None = None, env: dict | None = None, executablePath: str | None = None, firefoxUserPrefs: dict[str, str | int | float | bool] | None = None, handleSIGHUP: bool = True, handleSIGINT: bool = True, handleSIGTERM: bool = True, ignoreDefaultArgs: list[str] | bool | None = None, port: int | None = None, proxy: Proxy | None = None, reuse_existing: bool = True, slowMo: timedelta = ..., timeout: timedelta = ..., wsPath: str | None = None) -> str: ...
    def close_browser_server(self, wsEndpoint: str) -> None: ...
    def new_context(self, *, acceptDownloads: bool = True, baseURL: str | None = None, bypassCSP: bool = False, clientCertificates: list[ClientCertificate] | None = None, colorScheme: ColorScheme | None = None, defaultBrowserType: SupportedBrowsers | None = None, deviceScaleFactor: float | None = None, extraHTTPHeaders: dict[str, str] | None = None, forcedColors: ForcedColors = ..., geolocation: GeoLocation | None = None, hasTouch: bool | None = None, httpCredentials: HttpCredentials | None = None, ignoreHTTPSErrors: bool = False, isMobile: bool | None = None, javaScriptEnabled: bool = True, locale: str | None = None, offline: bool = False, permissions: list[Permission] | None = None, proxy: Proxy | None = None, recordHar: RecordHar | None = None, recordVideo: RecordVideo | None = None, reducedMotion: ReduceMotion = ..., screen: dict[str, int] | None = None, serviceWorkers: ServiceWorkersPermissions | None = ..., storageState: str | None = None, timezoneId: str | None = None, tracing: bool | Path | None = None, userAgent: str | None = None, viewport: ViewportDimensions | None = ...) -> str: ...
    def new_persistent_context(self, userDataDir: str = '', browser: SupportedBrowsers = ..., headless: bool = True, *, acceptDownloads: bool = True, args: list[str] | None = None, baseURL: str | None = None, bypassCSP: bool = False, channel: str | None = None, chromiumSandbox: bool = False, colorScheme: ColorScheme | None = None, defaultBrowserType: SupportedBrowsers | None = None, deviceScaleFactor: float | None = None, devtools: bool = False, downloadsPath: str | None = None, env: dict | None = None, executablePath: str | None = None, extraHTTPHeaders: dict[str, str] | None = None, forcedColors: ForcedColors = ..., geolocation: GeoLocation | None = None, handleSIGHUP: bool = True, handleSIGINT: bool = True, handleSIGTERM: bool = True, hasTouch: bool | None = None, httpCredentials: HttpCredentials | None = None, ignoreDefaultArgs: list[str] | bool | None = None, ignoreHTTPSErrors: bool = False, isMobile: bool | None = None, javaScriptEnabled: bool = True, locale: str | None = None, offline: bool = False, permissions: list[Permission] | None = None, proxy: Proxy | None = None, recordHar: RecordHar | None = None, recordVideo: RecordVideo | None = None, reducedMotion: ReduceMotion = ..., screen: dict[str, int] | None = None, serviceWorkers: ServiceWorkersPermissions | None = ..., slowMo: timedelta = ..., timeout: timedelta = ..., timezoneId: str | None = None, tracing: bool | Path | None = None, url: str | None = None, userAgent: str | None = None, viewport: ViewportDimensions | None = ...): ...
    def add_context_and_keyword_call_stack_to_trace(self, trace_file, ctx_id): ...
    def new_page(self, url: str | None = None, wait_until: PageLoadStates = ...) -> NewPageDetails: ...
    @with_assertion_polling
    @assertion_formatter_used
    def get_browser_catalog(self, assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None) -> list[BrowserInfo]: ...
    def get_console_log(self, assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None, *, full: bool = False, last: int | timedelta | None = None) -> list[dict]: ...
    def get_page_errors(self, assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None, *, full: bool = False, last: int | timedelta | None = None) -> dict: ...
    def switch_browser(self, id: str) -> str: ...
    def switch_context(self, id: str, browser: SelectionType | str = ...) -> str: ...
    def switch_page(self, id: NewPageDetails | SelectionType | str, context: SelectionType | str = ..., browser: SelectionType | str = ...) -> str: ...
    @with_assertion_polling
    def get_browser_ids(self, browser: SelectionType = ..., assertion_operator: AssertionOperator | None = None, *assertion_expected: Any | None, message: str | None = None) -> list[str]: ...
    @with_assertion_polling
    def get_context_ids(self, context: SelectionType = ..., browser: SelectionType | str = ..., assertion_operator: AssertionOperator | None = None, *assertion_expected: Any | None, message: str | None = None) -> list: ...
    @with_assertion_polling
    def get_page_ids(self, page: SelectionType = ..., context: SelectionType | str = ..., browser: SelectionType | str = ..., assertion_operator: AssertionOperator | None = None, *assertion_expected: Any | None, message: str | None = None) -> list: ...
    def save_storage_state(self) -> str: ...
    def set_peer_id(self, new_id) -> str: ...
    def cancel_download(self, download: DownloadInfo | str): ...
    def open_trace_group(self, name: str, file: Path | str | None = None, line: int = 0, column: int = 0, context_id: str = ''): ...
    def close_trace_group(self) -> None: ...
