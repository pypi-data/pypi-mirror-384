# This file was generated by Nuitka

# Stubs included by default
from __future__ import annotations
from collections.abc import Callable
from honeio.layers._zge16igh8vuyile import u9lt3qzqagufl0qhvy
from honeio.layers.dropout import DropoutLayer
from honeio.layers.general import PytorchGeneralHSM
from honeio.layers.weighted import WeightedLayer
from sklearn.base import BaseEstimator, ClassifierMixin, RegressorMixin
from sklearn.preprocessing import StandardScaler
from torch.utils.data import DataLoader, TensorDataset
from typing import Self, TypedDict, Unpack
from typing_extensions import TypeAlias
from dataclasses import dataclass
import numpy
import torch

def _init_weighted_layer() -> WeightedLayer:
    ...

class ModelParameters(TypedDict):
    hilbert_space_dim: int
    epochs: int
    random_state: int
    lr: float
    weights_lr: float
    loss: str
    device: str
    batch_size: int | None
    groups: list[list[int]] | None
    dropout_rate: float
    input_operator_count: int
    output_operator_count: int
    classes_: list

class SaveModelKwargs(TypedDict):
    scaler: StandardScaler
    weighted_layer_state_dict: dict
    model_parameters: ModelParameters

SaveModelFn: TypeAlias = Callable[[Unpack[SaveModelKwargs]], None]
LoadStatesFn: TypeAlias = Callable[[], tuple[StandardScaler, dict, ModelParameters]]
@dataclass
class QCMLBase(BaseEstimator):
    def _train_loop(self: Self, X: np.ndarray, y: np.ndarray) -> Self: ...
    def _fit_no_batch(self: Self, X: np.ndarray, y: np.ndarray) -> None: ...
    def _fit_batch(self: Self, X: np.ndarray, y: np.ndarray, use_dataloader: bool) -> None: ...

@dataclass
class QCMLRegressor(QCMLBase, RegressorMixin):
    def __init__(self: Self) -> None: ...
    def _fit_transform_targets(self: Self, y: np.ndarray) -> np.ndarray: ...
    def _fit(self: Self, X: np.ndarray, y: np.ndarray) -> Self: ...
    def fit(self: Self, X: np.ndarray, y: np.ndarray) -> 'QCMLRegressor': ...
    def predict(self: Self, X: np.ndarray) -> np.ndarray: ...
    def save(self: Self) -> None: ...
    @classmethod
    def load(cls, load_states_fn: LoadStatesFn) -> Self: ...

@dataclass
class QCMLClassifier(QCMLBase, ClassifierMixin):
    def __init__(self: Self) -> None: ...
    def _fit(self: Self, X: np.ndarray, y: np.ndarray, classes: list | None) -> Self: ...
    def fit(self: Self, X: np.ndarray, y: np.ndarray, classes: list | None) -> 'QCMLClassifier': ...
    def predict_proba(self: Self, X: np.ndarray) -> np.ndarray: ...
    def predict(self: Self, X: np.ndarray) -> np.ndarray: ...
    def save(self: Self) -> None: ...
    @classmethod
    def load(cls, load_states_fn: LoadStatesFn) -> Self: ...


__name__ = ...



# Modules used internally, to allow implicit dependencies to be seen:
import collections
import collections.abc
import typing
import numpy
import torch
import honeio
import honeio.layers
import honeio.layers._zge16igh8vuyile
import honeio.layers.dropout
import honeio.layers.general
import honeio.layers.weighted
import sklearn
import sklearn.base
import sklearn.preprocessing
import torch.utils
import torch.utils.data