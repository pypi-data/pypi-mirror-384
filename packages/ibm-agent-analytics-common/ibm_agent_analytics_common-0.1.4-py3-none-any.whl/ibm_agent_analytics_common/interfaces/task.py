import json
from pydantic import BaseModel, Field, model_validator
from typing import List, Optional, Any, Dict, Union
from enum import Enum
from datetime import datetime
from .runnable import Runnable
from .elements import AttributeValue

class TaskTag(str, Enum):
    """
    Task classification tags combining existing and new categories.
    """
    # Existing tags from BaseTask
    LLM_CALL = 'llm_call'
    COMPLEX = 'complex'
    TOOL_CALL = 'tool_call'
    DB_CALL = 'vector_DB'
    
    # Additional semantic tags
    PLANNING = 'planning'
    RETRIEVAL = 'retrieval'
    REASONING = 'reasoning'
    EVALUATION = 'evaluation'
    SYNTHESIS = 'synthesis'

class TaskKind(str, Enum):
    """
    The core intent or purpose of the task (OpenTelemetry spec).
    """
    PLANNING = "planning"  # Designing a structured sequence of subtasks to reach a goal
    LEARNING = "learning"  # Update memory, DB or model with new information
    RETRIEVAL = "retrieval"  # Searching or acquiring relevant external or internal knowledge
    REASONING = "reasoning"  # Performing logical inference or decision-making
    ACTION = "action"  # Executing a concrete command (e.g., tool, API, function)
    EVALUATION = "evaluation"  # Assessing the quality, correctness, or utility of a result
    DELEGATION = "delegation"  # Assigning the task to another agent or system for completion
    SYNTHESIS = "synthesis"  # Generating a final result by combining multiple inputs
    COORDINATION = "coordination"  # Managing multi-agent flows, timing, and communication
    REFINEMENT = "refinement"  # Asking the user for clarification or additional information
    OTHER = "other"  # Anything else

class TaskStatus(str, Enum):
    """
    Combined status from BaseTask and OpenTelemetry final status.
    """
    # BaseTask statuses
    CREATED = "CREATED"
    RUNNING = "RUNNING"
    SUSPENDED = "SUSPENDED"
    ABORTED = "ABORTED"
    FAILED = "FAILED"
    COMPLETED = "COMPLETED"
    
    # Additional OTEL statuses
    TIMEOUT = "TIMEOUT"
    CANCELLED = "CANCELLED"
    UNKNOWN = "UNKNOWN"

class TaskState(str, Enum):
    """
    OpenTelemetry lifecycle state (can be mapped from Status).
    """
    CREATED = "created"
    SUBMITTED = "submitted"
    PLANNED = "planned"
    STARTED = "started"
    IN_PROGRESS = "in-progress"
    PAUSED = "paused"
    SUSPENDED = "suspended"
    ENDED = "ended"

class RequesterType(str, Enum):
    """
    Type of entity that initiated the task request.
    """
    HUMAN = "human"
    SYSTEM = "system"

class FeedbackSource(str, Enum):
    """
    Type of entity that provided feedback.
    """
    HUMAN = "human"
    GROUNDED = "grounded"
    EVALUATOR = "evaluator"

class TaskInput(BaseModel):
    """
    Structured input attributes for a task (OTEL compliant).
    """
    goal: Optional[str] = Field(None, description="A description of the desired task outcome")
    instructions: Optional[List[str]] = Field(None, description="A list of instructions that must be followed during task execution")
    examples: Optional[List[str]] = Field(None, description="Examples of similar tasks or expected results to guide execution")
    data: Optional[Any] = Field(None, description="Raw input data used directly by the task (string or structured)")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Structured metadata about task input")

class TaskOutput(BaseModel):
    """
    Structured output attributes for a task (OTEL compliant).
    """
    data: Optional[Any] = Field(None, description="Raw output data (can be string, list, or structured)")
    data_values: Optional[List[str]] = Field(None, description="The list of output strings generated by the task")
    data_ranking: Optional[List[float]] = Field(None, description="Ranking or confidence scores for the output values")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Metadata describing the output")

class TaskFeedback(BaseModel):
    """
    Feedback attributes for a task.
    """
    source: Optional[FeedbackSource] = Field(None, description="Type of entity that provided feedback")
    source_id: Optional[str] = Field(None, description="Identifier of the feedback source")
    rating: Optional[float] = Field(None, description="Normalized score from 0.0 to 1.0 representing task performance")
    value: Optional[str] = Field(None, description="Explanation or rationale for the feedback")

class Task(Runnable):
    """
    Unified task interface combining BaseTask functionality with OpenTelemetry semantic attributes.
    Represents a discrete unit of work in agentic and generative AI systems.
    """
    
    # Core identity (BaseTask compatibility)
    # Note: 'id' is replaced by 'element_id' from Element base class
    
    # Task classification
    kind: Optional[TaskKind] = Field(None, description="The core intent or purpose of the task (OTEL)")
    
    # Status and lifecycle
    status: TaskStatus = Field(TaskStatus.CREATED, description="Current status of the task")
    state: Optional[TaskState] = Field(None, description="OpenTelemetry lifecycle state (auto-derived from status)")
    
    # Input/Output - supporting both structured and unstructured
    input: Optional[Union[Any, TaskInput]] = Field(None, description="Task input - can be any data or structured TaskInput")
    output: Optional[Union[Any, TaskOutput]] = Field(None, description="Task output - can be any data or structured TaskOutput")
    
    # Timing
    start_time: Optional[datetime] = Field(None, description="Timestamp indicating when the task was created/started")
    end_time: Optional[datetime] = Field(None, description="Timestamp indicating when the task was terminated")

    # Events and issues
    events: List[Any] = Field(
        default_factory=list, 
        description="A list containing information about exceptions/events during task execution"
    )
    issues: List[str] = Field(
        default_factory=list, 
        description="A list containing issues related to task data"
    )
    
    # Metrics
    metrics: Dict[str, Any] = Field(
        default_factory=dict, 
        description="A dictionary containing analytics and metrics computed on task data"
    )
    
    # Metadata (combining BaseTask metadata with OTEL attributes field)
    metadata: Dict[str, Any] = Field(
        default_factory=dict, 
        description="A dictionary for additional metadata associated with the task"
    )
    
    # OpenTelemetry specific fields
    parent_id: Optional[str] = Field(None, description="The ID of the parent task, if the current task is a subtask")
    code_id: Optional[str] = Field(None, description="Fully qualified reference to the source code defining the task logic")
    code_vendor: Optional[str] = Field(None, description="The name of the vendor/framework")
    
    # Task Requester
    requester_id: Optional[str] = Field(None, description="Unique identifier of the entity that initiated the task request")
    requester_type: Optional[RequesterType] = Field(None, description="Indicates whether the requester is a person or a system")
    requester_role: Optional[str] = Field(None, description="Role or profile of the requester in the system")
    request_id: Optional[str] = Field(None, description="Unique identifier for the request that triggered this task")
    
    # Task Scheduling
    dependencies_ids: Optional[List[str]] = Field(None, description="A list of task IDs that this task depends on")
    expected_start_time: Optional[datetime] = Field(None, description="The expected time at which the task should begin")
    expected_end_time: Optional[datetime] = Field(None, description="The expected time by which the task should be completed")
    priority: Optional[int] = Field(None, description="Priority level of the task for scheduling")
    
    # Feedback
    feedback: Optional[TaskFeedback] = Field(None, description="Feedback information for the task")
    
    @property
    def BASIC_TAGS(self) -> List[str]:
        """Compatibility property for BaseTask.Tag.BASIC_TAGS"""
        return [TaskTag.LLM_CALL, TaskTag.COMPLEX, TaskTag.TOOL_CALL, TaskTag.DB_CALL]
    
    def add_tag(self, tags: List[str]) -> None:
        """
        Add tags to the task with special logic for COMPLEX and LLM_CALL tags.
        Maintains compatibility with BaseTask behavior.
        """
        # Convert to list if tags is None
        if self.tags is None:
            self.tags = []
        
        # Special logic: if COMPLEX or LLM_CALL is added, remove TOOL_CALL
        if TaskTag.COMPLEX in tags or TaskTag.LLM_CALL in tags:
            self.remove_tag([TaskTag.TOOL_CALL])
        
        # Add new tags (avoiding duplicates)
        self.tags = list(set(self.tags + tags))
    
    def remove_tag(self, tags: List[str]) -> None:
        """
        Remove tags from the task.
        Maintains compatibility with BaseTask behavior.
        """
        if self.tags is None:
            return
        
        for tag in tags:
            if tag in self.tags:
                self.tags.remove(tag)
    
    @model_validator(mode='after')
    def derive_state_from_status(self):
        """Automatically derive OTEL state from status if not explicitly set"""
        if self.state is None and self.status:
            status_to_state = {
                TaskStatus.CREATED: TaskState.CREATED,
                TaskStatus.RUNNING: TaskState.IN_PROGRESS,
                TaskStatus.SUSPENDED: TaskState.SUSPENDED,
                TaskStatus.ABORTED: TaskState.ENDED,
                TaskStatus.FAILED: TaskState.ENDED,
                TaskStatus.COMPLETED: TaskState.ENDED,
                TaskStatus.TIMEOUT: TaskState.ENDED,
                TaskStatus.CANCELLED: TaskState.ENDED,
                TaskStatus.UNKNOWN: TaskState.ENDED,
            }
            self.state = status_to_state.get(self.status, TaskState.CREATED)
        return self
    
    def get_structured_input(self) -> TaskInput:
        """
        Get input as structured TaskInput object.
        Converts unstructured input if necessary.
        """
        if isinstance(self.input, TaskInput):
            return self.input
        elif self.input is not None:
            # Convert unstructured input to TaskInput
            return TaskInput(data=self.input)
        return TaskInput()
    
    def get_structured_output(self) -> TaskOutput:
        """
        Get output as structured TaskOutput object.
        Converts unstructured output if necessary.
        """
        if isinstance(self.output, TaskOutput):
            return self.output
        elif self.output is not None:
            # Convert unstructured output to TaskOutput
            return TaskOutput(data=self.output)
        return TaskOutput()
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Task':
        """Create a task from a dictionary"""
        return cls(**data)
    
    @classmethod
    def from_json(cls, json_str: str) -> 'Task':
        """Create a task from a JSON string"""
        data = json.loads(json_str)
        return cls.from_dict(data)
    
    def to_otel_attributes(self) -> Dict[str, AttributeValue]:
        """
        Convert task to OpenTelemetry semantic attributes format.
        Returns a dictionary with gen_ai.task.* prefixed keys.
        """
        attrs = {}
        
        # Identity attributes
        attrs["gen_ai.task.id"] = self.element_id
        if self.parent_id:
            attrs["gen_ai.task.parent.id"] = self.parent_id
        if self.name:
            attrs["gen_ai.task.name"] = self.name
        if self.code_id:
            attrs["gen_ai.task.code.id"] = self.code_id
        if self.code_vendor:
            attrs["gen_ai.task.code.vendor"] = self.code_vendor
        if self.kind:
            attrs["gen_ai.task.kind"] = self.kind.value
        if self.tags:
            attrs["gen_ai.task.tags"] = [str(tag) for tag in self.tags]
        
        # Requester attributes
        if self.requester_id:
            attrs["gen_ai.task.requester.id"] = self.requester_id
        if self.requester_type:
            attrs["gen_ai.task.requester.type"] = self.requester_type.value
        if self.requester_role:
            attrs["gen_ai.task.requester.role"] = self.requester_role
        if self.request_id:
            attrs["gen_ai.task.request.id"] = self.request_id
        
        # Lifecycle attributes
        if self.state:
            attrs["gen_ai.task.state"] = self.state.value
        # Map status to OTEL status format
        if self.status in [TaskStatus.COMPLETED]:
            attrs["gen_ai.task.status"] = "success"
        elif self.status in [TaskStatus.FAILED]:
            attrs["gen_ai.task.status"] = "failure"
        elif self.status in [TaskStatus.TIMEOUT]:
            attrs["gen_ai.task.status"] = "timeout"
        elif self.status in [TaskStatus.CANCELLED, TaskStatus.ABORTED]:
            attrs["gen_ai.task.status"] = "cancelled"
        elif self.status in [TaskStatus.UNKNOWN]:
            attrs["gen_ai.task.status"] = "unknown"
        
        # Input attributes (handle both structured and unstructured)
        structured_input = self.get_structured_input()
        if structured_input.goal:
            attrs["gen_ai.task.input.goal"] = structured_input.goal
        if structured_input.instructions:
            attrs["gen_ai.task.input.instructions"] = structured_input.instructions
        if structured_input.examples:
            attrs["gen_ai.task.input.examples"] = structured_input.examples
        if structured_input.data is not None:
            attrs["gen_ai.task.input.data"] = str(structured_input.data)
        if structured_input.metadata:
            attrs["gen_ai.task.input.metadata"] = json.dumps(structured_input.metadata)
        
        # Output attributes (handle both structured and unstructured)
        structured_output = self.get_structured_output()
        if structured_output.data_values:
            attrs["gen_ai.task.output.data.values"] = structured_output.data_values
        elif structured_output.data is not None:
            # Convert unstructured data to list of strings
            if isinstance(structured_output.data, list):
                attrs["gen_ai.task.output.data.values"] = [str(v) for v in structured_output.data]
            else:
                attrs["gen_ai.task.output.data.values"] = [str(structured_output.data)]
        if structured_output.data_ranking:
            attrs["gen_ai.task.output.data.ranking"] = structured_output.data_ranking
        if structured_output.metadata:
            attrs["gen_ai.task.output.metadata"] = [json.dumps(structured_output.metadata)]
        
        # Scheduling attributes
        if self.dependencies_ids:
            attrs["gen_ai.task.dependencies.ids"] = self.dependencies_ids
        if self.expected_start_time:
            attrs["gen_ai.task.expected_start_time"] = self.expected_start_time.isoformat()
        if self.expected_end_time:
            attrs["gen_ai.task.expected_end_time"] = self.expected_end_time.isoformat()
        if self.priority is not None:
            attrs["gen_ai.task.priority"] = self.priority
        
        # Feedback attributes
        if self.feedback:
            if self.feedback.source:
                attrs["gen_ai.task.feedback.source"] = self.feedback.source.value
            if self.feedback.source_id:
                attrs["gen_ai.task.feedback.source.id"] = self.feedback.source_id
            if self.feedback.rating is not None:
                attrs["gen_ai.task.feedback.rating"] = self.feedback.rating
            if self.feedback.value:
                attrs["gen_ai.task.feedback.value"] = self.feedback.value
        
        return attrs