from graphex import (
    String,
    Number,
    Boolean,
    Dynamic,
    Node,
    Graph,
    NodeMetadata,
    NodeDynamicAttributes,
    InputSocket,
    ListInputSocket,
    LinkOutputSocket,
    ListOutputSocket,
    OptionalInputSocket,
    OutputSocket,
    constants,
)
from graphex.nodes.templates import DynamicInputTemplateNode
from graphex.runtime import NodeThread
from graphex.exceptions import ThreadedRunTimeError
import typing
import uuid


class StartThread(Node, include_forward_link=False):
    name = "Start Thread"
    description = "Run nodes in a separate background thread."
    hyperlink: typing.List[str] = ["https://docs.python.org/3/tutorial/stdlib2.html#multi-threading"]
    categories = ["Control Flow", "Threading"]
    color = constants.COLOR_THREADING

    forked = InputSocket(
        datatype=Boolean,
        name="Fork",
        description='Whether this thread should "fork" off the rest of the graph. A forked thread will run in a separate local context, meaning that changes made to the values variables or sockets from outside the thread will not affect the nodes within the thread (and vice versa). A forked thread effectively "freezes" the values of the rest of the graph at the time of its creation. Conversely, a non-forked thread will run alongside the rest of the graph, and any value changes made elsewhere will be immediately available to the thread. Later, upon joining a forked thread, it is possible to merge updated values with the rest of the graph.',
        input_field=True,
    )
    daemon = InputSocket(
        datatype=Boolean,
        name="Is Daemon",
        description="Whether this thread is a daemon thread. Daemon threads are terminated immediately when the main graph thread exits, regardless of whether this thread is still running. Note: Daemon threads are abruptly stopped at shutdown. Their resources (such as open files, database transactions, etc.) may not be released properly. If you want your threads to stop gracefully, make them non-daemonic.",
        input_field=False,
    )
    buffer_logs = InputSocket(
        datatype=Boolean,
        name="Buffer Logs",
        description="Whether to buffer logs generated by this thread until the thread is joined. This only applies to forked threads.",
        input_field=False,
    )
    pool = OptionalInputSocket(
        datatype=String,
        name="Pool",
        description="The pool that this thread should be sorted into. This may be used to group threads together.",
    )
    max_workers = OptionalInputSocket(
        datatype=Number,
        name="Max Pool Workers",
        description="The number of workers (concurrent threads) allowed for this pool. Only applies when 'Pool' specified. This value can only be set once, the first time the pool is created. Using a different value in future calls will result in an error. An empty value or a value less than 1 will not place any limits on the number of concurrent threads.",
    )

    thread_body = LinkOutputSocket(
        name="Thread Body", description="Branch for the body of the thread. This will be run in the background as a separate thread."
    )
    next_link = LinkOutputSocket(
        name="Next",
        description="The next node to execute after starting the thread. This will not be executed in a thread (i.e. this will continue the normal graph execution).",
    )
    thread_id = OutputSocket(
        datatype=Number,
        name="Thread ID",
        description="The ID for the created thread. This may be used to reference this particular thread later (e.g. for joining the thread). This is guaranteed to be a nonzero integer that also serves as the index of the thread created (i.e. increases by 1 for each thread, starting from 0).",
    )

    def run(self):
        body_nodes = self.forward("Thread Body")

        pool = self.pool.strip() if self.pool and self.pool.strip() else None
        max_workers = int(self.max_workers) if self.max_workers and self.max_workers >= 1 else None

        thread = self._runtime.execute_node_in_thread(
            body_nodes[0], forked=self.forked, daemon=self.daemon, pool=pool, max_workers=max_workers, buffer_logs=self.buffer_logs, start_immediately=False
        )
        self.thread_id = thread.thread_id

        additional_log_info = []
        if pool:
            additional_log_info.append(f"Pool='{pool}'")
        if max_workers:
            additional_log_info.append(f"Max Workers={max_workers}")

        if len(additional_log_info):
            additional_log_info = " (" + ", ".join(additional_log_info) + ")"
        else:
            additional_log_info = ""

        self.debug(f"Starting Thread{additional_log_info}: {self.thread_id}")
        thread.start()

    def run_next(self):
        for node in self.forward("Next"):
            self._runtime.execute_node(node)


class JoinThread(Node):
    name = "Join Thread"
    description = "Wait for a thread to complete before continuing. Threads may be joined multiple times."
    hyperlink: typing.List[str] = ["https://docs.python.org/3/tutorial/stdlib2.html#multi-threading"]
    categories = ["Control Flow", "Threading"]
    color = constants.COLOR_THREADING

    thread_id = InputSocket(datatype=Number, name="Thread ID", description="The ID of the thread to join / wait for.")
    merge_forked_state = InputSocket(
        datatype=Boolean,
        name="Merge Forked State",
        description="If the thread being joined is a forked thread and this is True, any changes made to variables or graph outputs by the thread will be applied to the main graph.",
        input_field=True,
    )
    raise_error = InputSocket(
        datatype=Boolean,
        name="Raise Error?",
        description="Whether to automatically raise an error if the joined thread failed with an error / did not succeed.",
        input_field=True,
    )

    succeeded = OutputSocket(datatype=Boolean, name="Succeeded", description="Whether this thread completed without errors.")
    error_message = OutputSocket(datatype=String, name="Error Message", description="The error message for this thread if this thread did not succeed.")

    def run(self):
        thread = self._runtime.get_thread(int(self.thread_id))

        self.debug(f"Joining thread: {thread.thread_id}")
        thread.join(merge_forked_state=self.merge_forked_state)

        self.succeeded = thread.exception is None
        self.error_message = str(thread.exception) if thread.exception else ""

        if thread.exception and self.raise_error:
            raise ThreadedRunTimeError(f"Thread {thread.thread_id} failed: {thread.exception}")


class JoinAllThreads(Node):
    name = "Join All Threads"
    description = "Wait for all threads within this graph to complete before continuing. Threads may be joined multiple times."
    hyperlink: typing.List[str] = ["https://docs.python.org/3/tutorial/stdlib2.html#multi-threading"]
    categories = ["Control Flow", "Threading"]
    color = constants.COLOR_THREADING

    merge_forked_state = InputSocket(
        datatype=Boolean,
        name="Merge Forked State",
        description="If the thread being joined is a forked thread and this is True, any changes made to variables or graph outputs by the thread will be applied to the main graph.",
        input_field=True,
    )
    raise_error = InputSocket(
        datatype=Boolean,
        name="Raise Error?",
        description="Whether to automatically raise an error if a joined thread failed with an error / did not succeed.",
        input_field=True,
    )

    succeeded = OutputSocket(datatype=Boolean, name="Succeeded", description="Whether all threads completed without errors.")
    error_messages = ListOutputSocket(datatype=String, name="Error Messages", description="The error messages for each thread that did not succeed.")

    def run(self):
        self.debug(f"Joining All Threads")
        errors: typing.Dict[int, str] = {}
        for thread in self._runtime.threads:
            self.debug(f"Joining thread: {thread.thread_id}")
            thread.join(merge_forked_state=self.merge_forked_state)
            if thread.exception:
                errors[thread.thread_id] = str(thread.exception)

        self.succeeded = len(errors) == 0
        self.error_messages = [f"ThreadID {thread_id}: {err}" for thread_id, err in errors.items()] if len(errors) else []

        if self.raise_error and len(self.error_messages):
            raise ThreadedRunTimeError(f"Threads failed:\n" + "\n\n".join(self.error_messages))


class JoinThreadsInPool(Node):
    name = "Join Threads In Pool"
    description = "Wait for all threads within a pool to complete before continuing. Threads may be joined multiple times."
    hyperlink: typing.List[str] = ["https://docs.python.org/3/tutorial/stdlib2.html#multi-threading"]
    categories = ["Control Flow", "Threading"]
    color = constants.COLOR_THREADING

    pool = InputSocket(
        datatype=String,
        name="Pool",
        description="The name of the pool of threads to join. If empty, threads not sorted into a pool will be joined instead.",
    )
    merge_forked_state = InputSocket(
        datatype=Boolean,
        name="Merge Forked State",
        description="If the thread being joined is a forked thread and this is True, any changes made to variables or graph outputs by the thread will be applied to the main graph.",
        input_field=True,
    )
    raise_error = InputSocket(
        datatype=Boolean,
        name="Raise Error?",
        description="Whether to automatically raise an error if a joined thread failed with an error / did not succeed.",
        input_field=True,
    )

    succeeded = OutputSocket(datatype=Boolean, name="Succeeded", description="Whether all threads completed without errors.")
    error_messages = ListOutputSocket(datatype=String, name="Error Messages", description="The error messages for each thread that did not succeed.")

    def run(self):
        pool = self.pool.strip()
        if pool:
            self.debug(f'Joining Threads in Pool "{self.pool}"')
        else:
            self.debug(f"Joining Non-Pooled Threads")

        errors: typing.Dict[int, str] = {}
        for thread in self._runtime.threads:
            if thread.pool != pool:
                continue
            self.debug(f"Joining thread: {thread.thread_id}")
            thread.join(merge_forked_state=self.merge_forked_state)
            if thread.exception:
                errors[thread.thread_id] = str(thread.exception)

        self.succeeded = len(errors) == 0
        self.error_messages = [f"ThreadID {thread_id}: {err}" for thread_id, err in errors.items()] if len(errors) else []

        if self.raise_error and len(self.error_messages):
            raise ThreadedRunTimeError(f"Threads failed:\n" + "\n\n".join(self.error_messages))


class ThreadedForEach(DynamicInputTemplateNode, include_forward_link=False):
    name = f"Threaded For Each"
    description = "Iterate/loop for each item in a list, starting a new thread for each iteration."
    hyperlink: typing.List[str] = ["https://docs.python.org/3/tutorial/stdlib2.html#multi-threading"]
    categories = ["Control Flow", "Threading"]
    color = constants.COLOR_THREADING

    list_items = ListInputSocket(
        datatype=Dynamic,
        name="List to Iterate",
        description="The list to iterate over. This can be a list of any type, and the output value of this node will depend on the type of the input list. Each item in this list will handled in a new forked thread.",
    )

    def run(self):
        dynamic_attributes = self.dynamic_attributes(self._graph, self._instance_metadata)
        if dynamic_attributes.error:
            raise RuntimeError(dynamic_attributes.error)

        dynamic_sockets = {socket.name: socket for socket in dynamic_attributes.sockets or []}

        index_socket = dynamic_sockets["Index"]
        value_socket = dynamic_sockets["Value"]
        thread_ids_socket = dynamic_sockets["Thread IDs"]
        self.disable_output_socket("Index")
        self.disable_output_socket("Value")
        self.disable_output_socket("Thread IDs")

        pool = self.id + "-" + str(uuid.uuid4())

        max_workers = dynamic_sockets["Max Workers"].get_value(self)
        max_workers = int(max_workers) if max_workers and max_workers >= 1 else None

        threads: typing.List[NodeThread] = []
        thread_ids: typing.List[int] = []
        for index, value in enumerate(dynamic_sockets["List to Iterate"].get_value(self)):
            index_socket.set_value(self, index)
            value_socket.set_value(self, value)

            for node in self.forward("Loop Body"):
                thread = self._runtime.execute_node_in_thread(
                    node,
                    forked=True,
                    daemon=dynamic_sockets["Is Daemon"].get_value(self),
                    pool=pool,
                    max_workers=max_workers,
                    buffer_logs=dynamic_sockets["Buffer Logs"].get_value(self),
                    start_immediately=False,
                )
                threads.append(thread)
                thread_ids.append(thread.thread_id)
                thread_ids_socket.set_value(self, thread_ids)

                self.debug(f"Starting Thread: {thread.thread_id}")
                thread.start()

        if dynamic_sockets["Join Threads"].get_value(self):
            errors: typing.Dict[int, str] = {}
            for thread in threads:
                self.debug(f"Joining thread: {thread.thread_id}")
                thread.join(merge_forked_state=dynamic_sockets["Merge Forked State"].get_value(self))
                if thread.exception:
                    errors[thread.thread_id] = str(thread.exception)

            error_messages = [f"ThreadID {thread_id}: {err}" for thread_id, err in errors.items()] if len(errors) else []
            if dynamic_sockets["Raise Error?"].get_value(self) and len(error_messages):
                raise ThreadedRunTimeError(f"Threads failed:\n" + "\n\n".join(error_messages))

    def run_next(self):
        for node in self.forward("Completed"):
            self._runtime.execute_node(node)

    @classmethod
    def dynamic_attributes(cls, graph: Graph, instance_metadata: NodeMetadata) -> NodeDynamicAttributes:
        try:
            datatype = cls.get_datatype("List to Iterate", graph, instance_metadata)
            if not datatype:
                return NodeDynamicAttributes(None, None, None, None)

            return NodeDynamicAttributes(
                sockets=[
                    ListInputSocket(
                        datatype=datatype,
                        name="List to Iterate",
                        description="The list to iterate over. This can be a list of any type, and the output value of this node will depend on the type of the input list.",
                    ),
                    OptionalInputSocket(
                        datatype=Number,
                        name="Max Workers",
                        description="The number of workers (concurrent threads). An empty value or a value less than 1 will not place any limits on the number of concurrent threads.",
                    ),
                    InputSocket(
                        datatype=Boolean,
                        name="Join Threads",
                        description="Whether to automatically join the started threads before completing this node. If True, each started thread will be joined after being started. If False, this node will not wait for the threads to complete.",
                        input_field=True,
                    ),
                    InputSocket(
                        datatype=Boolean,
                        name="Is Daemon",
                        description="Whether the started threads should be daemon threads. Daemon threads are terminated immediately when the main graph thread exits, regardless of whether they are still running. Note: Daemon threads are abruptly stopped at shutdown. Their resources (such as open files, database transactions, etc.) may not be released properly. If you want your threads to stop gracefully, make them non-daemonic.",
                        input_field=False,
                    ),
                    InputSocket(
                        datatype=Boolean,
                        name="Buffer Logs",
                        description="Whether to buffer logs generated by a thread until the thread is joined.",
                        input_field=False,
                    ),
                    InputSocket(
                        datatype=Boolean,
                        name="Merge Forked State",
                        description="If this is True, any changes made to variables or graph outputs by the threads will be applied to the main graph.",
                        input_field=True,
                    ),
                    InputSocket(
                        datatype=Boolean,
                        name="Raise Error?",
                        description="Whether to automatically raise an error if a joined thread failed with an error / did not succeed.",
                        input_field=True,
                    ),
                    LinkOutputSocket(name="Loop Body", description="Branch for the body of the loop, to be run on each iteration."),
                    OutputSocket(datatype=datatype, name="Value", description="The value for this iteration of the loop."),
                    OutputSocket(datatype=Number, name="Index", description="The loop index."),
                    LinkOutputSocket(name="Completed", description="Branch to run when the loop has completed."),
                    ListOutputSocket(datatype=Number, name="Thread IDs", description="The IDs of each thread started."),
                ],
                description=f"Iterate/loop for each item in a '{datatype.name}' list.",
                color=datatype.color,
                error=None,
            )
        except Exception as e:
            return NodeDynamicAttributes(None, None, None, error=str(e))
