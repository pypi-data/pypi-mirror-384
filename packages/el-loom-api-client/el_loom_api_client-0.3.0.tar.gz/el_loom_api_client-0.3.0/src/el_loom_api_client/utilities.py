## Some utility functions for basic threshold analysis and plotting

import itertools

import matplotlib.pyplot as plt
import numpy as np


def plot_ler_vs_per(results_object, noise_channel='depolarizing', title=None):

    """
    Produce a plot of logical error rates vs physical error rates, as generated by a
    ThresholdExperiment.
    """
    
    fig, ax = plt.subplots(1, 1)
    pers = []
    for p in results_object.raw_results['noise_parameters']:
        pers.append(p[noise_channel])

    lers = results_object.logical_error_rate
    
    if results_object.raw_results['metadata']['instance_labels']:
        labels = results_object.raw_results['metadata']['instance_labels']
    else:
        distances = results_object.raw_results['distance_range']
        labels = []
        for d in distances:
            labels.append(f"d={d}")

    lers_arranged = np.array(results_object.logical_error_rate).T
    for i, lers in enumerate(lers_arranged):
        ax.plot(pers, lers, 'o-', label=f'{labels[i]}')
    
    ax.loglog()
    ax.set_xlabel(f"Physical Error Rate ({noise_channel})")
    ax.set_ylabel("Logical Error Rate")
    ax.grid(which='major')
    ax.grid(which='minor')
    fig.set_dpi(120)
    ax.legend()

    if title:
        ax.set_title(title)

def plot_ler_vs_rounds(results_object, noise_channel='depolarizing', title=None):

    """
    Produce a plot of logical error rates vs number of QEC rounds, as generated by a
    MemoryExperiment.
    """
    
    fig, ax = plt.subplots(1, 1)
    pers = []
    for p in results_object.raw_results['noise_parameters']:
        pers.append(p[noise_channel])

    rounds = results_object.raw_results['num_rounds']
    
    lers = results_object.logical_error_rate
    for i, lers in enumerate(lers):
        ax.plot(rounds, lers, 'o-', label=f'p={pers[i]}')
    ax.set_yscale('log')
    ax.set_xlabel("Syndrome extraction round")
    ax.set_ylabel("Logical Error Rate")
    ax.grid(which='major')
    ax.grid(which='minor')
    fig.set_dpi(120)
    ax.legend(bbox_to_anchor=(1, 1))

    if title:
        ax.set_title(title)
    
def linear_loglog_fit(pers, lers):

    """
    Given a set of physical error rates (pers) and logical error rates (lers) for a set
    of code distances, returns the parameters that give a 
    straight line fit for each code distance on a log-log plot.
    """
    
    log_pers = [np.log(i) for i in pers]
    lers_arranged = np.array(lers).T
    log_lers = np.log(lers_arranged)
    fit_params = []
    for el in log_lers:
        b, m = np.polynomial.polynomial.polyfit(log_pers, el, 1)
        fit_params.append([float(b), float(m)])
        
    return fit_params