from typing import Any, Dict, List, Optional, Tuple
import numpy as np
import torch

class MaskFilteringUtils:
    """
    MIT Licensed utilities for post-processing and filtering masks.
    These utilities can be applied to masks generated by any segmentation model.
    """
    
    @staticmethod
    def filter_masks_by_relative_box_size(
        mask_annotations: List[Dict[str, Any]],
        max_rel_box_size: Optional[float] = None,
        min_rel_box_size: Optional[float] = None,
        image_height: int = None,
        image_width: int = None
    ) -> List[Dict[str, Any]]:
        """
        Filter mask annotations based on relative bounding box size.
        
        Args:
            mask_annotations: List of mask dictionaries from automatic mask generator
            max_rel_box_size: Maximum relative box size (as fraction of image dimensions)
            min_rel_box_size: Minimum relative box size (as fraction of image dimensions)
            image_height: Height of the source image
            image_width: Width of the source image
            
        Returns:
            Filtered list of mask annotations
        """
        if max_rel_box_size is None and min_rel_box_size is None:
            return mask_annotations
            
        if image_height is None or image_width is None:
            raise ValueError("image_height and image_width must be provided for relative size filtering")
        
        filtered_annotations = []
        
        for ann in mask_annotations:
            # Extract bbox in XYWH format
            bbox = ann.get('bbox', None)
            if bbox is None:
                continue
                
            x, y, w, h = bbox
            
            # Calculate relative sizes
            rel_width = w / image_width
            rel_height = h / image_height
            
            # Apply size filters
            width_ok = True
            height_ok = True
            
            if max_rel_box_size is not None:
                width_ok = width_ok and (rel_width < max_rel_box_size)
                height_ok = height_ok and (rel_height < max_rel_box_size)
                
            if min_rel_box_size is not None:
                width_ok = width_ok and (rel_width > min_rel_box_size)
                height_ok = height_ok and (rel_height > min_rel_box_size)
            
            if width_ok and height_ok:
                filtered_annotations.append(ann)
                
        return filtered_annotations
    
    @staticmethod
    def filter_masks_by_area(
        mask_annotations: List[Dict[str, Any]],
        min_area: Optional[int] = None,
        max_area: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """
        Filter mask annotations based on absolute area.
        
        Args:
            mask_annotations: List of mask dictionaries
            min_area: Minimum area in pixels
            max_area: Maximum area in pixels
            
        Returns:
            Filtered list of mask annotations
        """
        if min_area is None and max_area is None:
            return mask_annotations
            
        filtered_annotations = []
        
        for ann in mask_annotations:
            area = ann.get('area', 0)
            
            area_ok = True
            if min_area is not None:
                area_ok = area_ok and (area >= min_area)
            if max_area is not None:
                area_ok = area_ok and (area <= max_area)
                
            if area_ok:
                filtered_annotations.append(ann)
                
        return filtered_annotations
    
    @staticmethod
    def filter_masks_by_score(
        mask_annotations: List[Dict[str, Any]],
        min_predicted_iou: Optional[float] = None,
        min_stability_score: Optional[float] = None
    ) -> List[Dict[str, Any]]:
        """
        Filter mask annotations based on quality scores.
        
        Args:
            mask_annotations: List of mask dictionaries
            min_predicted_iou: Minimum predicted IoU threshold
            min_stability_score: Minimum stability score threshold
            
        Returns:
            Filtered list of mask annotations
        """
        filtered_annotations = []
        
        for ann in mask_annotations:
            iou_ok = True
            stability_ok = True
            
            if min_predicted_iou is not None:
                predicted_iou = ann.get('predicted_iou', 0.0)
                iou_ok = predicted_iou >= min_predicted_iou
                
            if min_stability_score is not None:
                stability_score = ann.get('stability_score', 0.0)
                stability_ok = stability_score >= min_stability_score
                
            if iou_ok and stability_ok:
                filtered_annotations.append(ann)
                
        return filtered_annotations


class FilteredSAM2MaskGenerator:
    """
    MIT Licensed wrapper that enhances any automatic mask generator with additional
    filtering capabilities. Uses composition to avoid license mixing.
    """
    
    def __init__(
        self,
        base_generator,
        min_rel_box_size: Optional[float] = None,
        max_rel_box_size: Optional[float] = None,
        min_area_filter: Optional[int] = None,
        max_area_filter: Optional[int] = None,
    ):
        """
        Initialize the enhanced mask generator.
        
        Args:
            base_generator: Any mask generator with a .generate(image) method
            min_rel_box_size: Minimum relative box size filter
            max_rel_box_size: Maximum relative box size filter
            min_area_filter: Minimum area filter (pixels)
        """
        self.base_generator = base_generator
        self.max_rel_box_size = max_rel_box_size
        self.min_rel_box_size = min_rel_box_size
        self.min_area_filter = min_area_filter
        self.max_area_filter = max_area_filter
        self.filter_utils = MaskFilteringUtils()
    
    def generate(self, image: np.ndarray) -> List[Dict[str, Any]]:
        """
        Generate masks with enhanced filtering.
        
        Args:
            image: Input image as numpy array (HWC format)
            
        Returns:
            List of filtered mask annotations
        """
        # Generate masks using the base generator
        mask_annotations = self.base_generator.generate(image)
        
        # Get image dimensions for relative size filtering
        image_height, image_width = image.shape[:2]
        
        # Apply filtering in sequence
        filtered_masks = mask_annotations
        
        # Filter by relative box size
        if self.max_rel_box_size is not None or self.min_rel_box_size is not None:
            filtered_masks = self.filter_utils.filter_masks_by_relative_box_size(
                filtered_masks,
                max_rel_box_size=self.max_rel_box_size,
                min_rel_box_size=self.min_rel_box_size,
                image_height=image_height,
                image_width=image_width
            )
        
        # Filter by area
        if self.min_area_filter is not None or self.max_area_filter is not None:
            filtered_masks = self.filter_utils.filter_masks_by_area(
                filtered_masks,
                min_area=self.min_area_filter,
                max_area=self.max_area_filter
            )
        
        return filtered_masks
    
    def set_filters(
        self,
        min_rel_box_size: Optional[float] = None,
        max_rel_box_size: Optional[float] = None,
        min_area_filter: Optional[int] = None,
    ):
        """
        Update filter parameters after initialization.
        """
        if min_rel_box_size is not None:
            self.min_rel_box_size = min_rel_box_size        
        if max_rel_box_size is not None:
            self.max_rel_box_size = max_rel_box_size
        if min_area_filter is not None:
            self.min_area_filter = min_area_filter
    
    # Delegate any other methods to the base generator
    def __getattr__(self, name):
        """Delegate unknown attributes to the base generator."""
        return getattr(self.base_generator, name)
