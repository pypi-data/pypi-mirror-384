/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_ADJOINTLOWERINGPASS
#define GEN_PASS_DECL_ANNOTATEFUNCTIONPASS
#define GEN_PASS_DECL_COPYGLOBALMEMREFPASS
#define GEN_PASS_DECL_DECOMPOSELOWERINGPASS
#define GEN_PASS_DECL_DISENTANGLECNOTPASS
#define GEN_PASS_DECL_DISENTANGLESWAPPASS
#define GEN_PASS_DECL_EMITCATALYSTPYINTERFACEPASS
#define GEN_PASS_DECL_IONSDECOMPOSITIONPASS
#define GEN_PASS_DECL_LOOPBOUNDARYOPTIMIZATIONPASS
#define GEN_PASS_DECL_MERGEROTATIONSPASS
#define GEN_PASS_DECL_QUANTUMCONVERSIONPASS
#define GEN_PASS_DECL_REMOVECHAINEDSELFINVERSEPASS
#define GEN_PASS_DECL_SPLITMULTIPLETAPESPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// AdjointLoweringPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ADJOINTLOWERINGPASS
#undef GEN_PASS_DECL_ADJOINTLOWERINGPASS
#endif // GEN_PASS_DECL_ADJOINTLOWERINGPASS
#ifdef GEN_PASS_DEF_ADJOINTLOWERINGPASS
namespace impl {

template <typename DerivedT>
class AdjointLoweringPassBase : public ::mlir::OperationPass<> {
public:
  using Base = AdjointLoweringPassBase;

  AdjointLoweringPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  AdjointLoweringPassBase(const AdjointLoweringPassBase &other) : ::mlir::OperationPass<>(other) {}
  AdjointLoweringPassBase& operator=(const AdjointLoweringPassBase &) = delete;
  AdjointLoweringPassBase(AdjointLoweringPassBase &&) = delete;
  AdjointLoweringPassBase& operator=(AdjointLoweringPassBase &&) = delete;
  ~AdjointLoweringPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("adjoint-lowering");
  }
  ::llvm::StringRef getArgument() const override { return "adjoint-lowering"; }

  ::llvm::StringRef getDescription() const override { return "Lower adjoint regions containing a single quantum operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AdjointLoweringPass");
  }
  ::llvm::StringRef getName() const override { return "AdjointLoweringPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<catalyst::CatalystDialect>();
    registry.insert<index::IndexDialect>();
    registry.insert<tensor::TensorDialect>();
    registry.insert<complex::ComplexDialect>();
    registry.insert<scf::SCFDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AdjointLoweringPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ADJOINTLOWERINGPASS
#endif // GEN_PASS_DEF_ADJOINTLOWERINGPASS

//===----------------------------------------------------------------------===//
// AnnotateFunctionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ANNOTATEFUNCTIONPASS
#undef GEN_PASS_DECL_ANNOTATEFUNCTIONPASS
#endif // GEN_PASS_DECL_ANNOTATEFUNCTIONPASS
#ifdef GEN_PASS_DEF_ANNOTATEFUNCTIONPASS
namespace impl {

template <typename DerivedT>
class AnnotateFunctionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = AnnotateFunctionPassBase;

  AnnotateFunctionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  AnnotateFunctionPassBase(const AnnotateFunctionPassBase &other) : ::mlir::OperationPass<>(other) {}
  AnnotateFunctionPassBase& operator=(const AnnotateFunctionPassBase &) = delete;
  AnnotateFunctionPassBase(AnnotateFunctionPassBase &&) = delete;
  AnnotateFunctionPassBase& operator=(AnnotateFunctionPassBase &&) = delete;
  ~AnnotateFunctionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("annotate-function");
  }
  ::llvm::StringRef getArgument() const override { return "annotate-function"; }

  ::llvm::StringRef getDescription() const override { return "Annotate functions that contain a measurement operation."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AnnotateFunctionPass");
  }
  ::llvm::StringRef getName() const override { return "AnnotateFunctionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<catalyst::CatalystDialect>();
    registry.insert<func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AnnotateFunctionPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ANNOTATEFUNCTIONPASS
#endif // GEN_PASS_DEF_ANNOTATEFUNCTIONPASS

//===----------------------------------------------------------------------===//
// CopyGlobalMemRefPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_COPYGLOBALMEMREFPASS
#undef GEN_PASS_DECL_COPYGLOBALMEMREFPASS
#endif // GEN_PASS_DECL_COPYGLOBALMEMREFPASS
#ifdef GEN_PASS_DEF_COPYGLOBALMEMREFPASS
namespace impl {

template <typename DerivedT>
class CopyGlobalMemRefPassBase : public ::mlir::OperationPass<> {
public:
  using Base = CopyGlobalMemRefPassBase;

  CopyGlobalMemRefPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  CopyGlobalMemRefPassBase(const CopyGlobalMemRefPassBase &other) : ::mlir::OperationPass<>(other) {}
  CopyGlobalMemRefPassBase& operator=(const CopyGlobalMemRefPassBase &) = delete;
  CopyGlobalMemRefPassBase(CopyGlobalMemRefPassBase &&) = delete;
  CopyGlobalMemRefPassBase& operator=(CopyGlobalMemRefPassBase &&) = delete;
  ~CopyGlobalMemRefPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("cp-global-memref");
  }
  ::llvm::StringRef getArgument() const override { return "cp-global-memref"; }

  ::llvm::StringRef getDescription() const override { return "Copy global memrefs before returning from C interface."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CopyGlobalMemRefPass");
  }
  ::llvm::StringRef getName() const override { return "CopyGlobalMemRefPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<memref::MemRefDialect>();
    registry.insert<func::FuncDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CopyGlobalMemRefPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_COPYGLOBALMEMREFPASS
#endif // GEN_PASS_DEF_COPYGLOBALMEMREFPASS

//===----------------------------------------------------------------------===//
// DecomposeLoweringPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_DECOMPOSELOWERINGPASS
#undef GEN_PASS_DECL_DECOMPOSELOWERINGPASS
#endif // GEN_PASS_DECL_DECOMPOSELOWERINGPASS
#ifdef GEN_PASS_DEF_DECOMPOSELOWERINGPASS
namespace impl {

template <typename DerivedT>
class DecomposeLoweringPassBase : public ::mlir::OperationPass<> {
public:
  using Base = DecomposeLoweringPassBase;

  DecomposeLoweringPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  DecomposeLoweringPassBase(const DecomposeLoweringPassBase &other) : ::mlir::OperationPass<>(other) {}
  DecomposeLoweringPassBase& operator=(const DecomposeLoweringPassBase &) = delete;
  DecomposeLoweringPassBase(DecomposeLoweringPassBase &&) = delete;
  DecomposeLoweringPassBase& operator=(DecomposeLoweringPassBase &&) = delete;
  ~DecomposeLoweringPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("decompose-lowering");
  }
  ::llvm::StringRef getArgument() const override { return "decompose-lowering"; }

  ::llvm::StringRef getDescription() const override { return "Replace quantum operations with compiled decomposition rules."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DecomposeLoweringPass");
  }
  ::llvm::StringRef getName() const override { return "DecomposeLoweringPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DecomposeLoweringPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_DECOMPOSELOWERINGPASS
#endif // GEN_PASS_DEF_DECOMPOSELOWERINGPASS

//===----------------------------------------------------------------------===//
// DisentangleCNOTPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_DISENTANGLECNOTPASS
struct DisentangleCNOTPassOptions {
  bool EmitFSMStateRemark = false;
};
#undef GEN_PASS_DECL_DISENTANGLECNOTPASS
#endif // GEN_PASS_DECL_DISENTANGLECNOTPASS
#ifdef GEN_PASS_DEF_DISENTANGLECNOTPASS
namespace impl {

template <typename DerivedT>
class DisentangleCNOTPassBase : public ::mlir::OperationPass<> {
public:
  using Base = DisentangleCNOTPassBase;

  DisentangleCNOTPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  DisentangleCNOTPassBase(const DisentangleCNOTPassBase &other) : ::mlir::OperationPass<>(other) {}
  DisentangleCNOTPassBase& operator=(const DisentangleCNOTPassBase &) = delete;
  DisentangleCNOTPassBase(DisentangleCNOTPassBase &&) = delete;
  DisentangleCNOTPassBase& operator=(DisentangleCNOTPassBase &&) = delete;
  ~DisentangleCNOTPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("disentangle-CNOT");
  }
  ::llvm::StringRef getArgument() const override { return "disentangle-CNOT"; }

  ::llvm::StringRef getDescription() const override { return "Replace a CNOT gate with two single qubit gates whenever possible."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DisentangleCNOTPass");
  }
  ::llvm::StringRef getName() const override { return "DisentangleCNOTPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DisentangleCNOTPassBase<DerivedT>)

  DisentangleCNOTPassBase(DisentangleCNOTPassOptions options) : DisentangleCNOTPassBase() {
    EmitFSMStateRemark = std::move(options.EmitFSMStateRemark);
  }
protected:
  ::mlir::Pass::Option<bool> EmitFSMStateRemark{*this, "emit-FSM-state-remark", ::llvm::cl::desc("Whether to emit the state analysis result from the simple states propagation FSM onto the gate operations."), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_DISENTANGLECNOTPASS
#endif // GEN_PASS_DEF_DISENTANGLECNOTPASS

//===----------------------------------------------------------------------===//
// DisentangleSWAPPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_DISENTANGLESWAPPASS
struct DisentangleSWAPPassOptions {
  bool EmitFSMStateRemark = false;
};
#undef GEN_PASS_DECL_DISENTANGLESWAPPASS
#endif // GEN_PASS_DECL_DISENTANGLESWAPPASS
#ifdef GEN_PASS_DEF_DISENTANGLESWAPPASS
namespace impl {

template <typename DerivedT>
class DisentangleSWAPPassBase : public ::mlir::OperationPass<> {
public:
  using Base = DisentangleSWAPPassBase;

  DisentangleSWAPPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  DisentangleSWAPPassBase(const DisentangleSWAPPassBase &other) : ::mlir::OperationPass<>(other) {}
  DisentangleSWAPPassBase& operator=(const DisentangleSWAPPassBase &) = delete;
  DisentangleSWAPPassBase(DisentangleSWAPPassBase &&) = delete;
  DisentangleSWAPPassBase& operator=(DisentangleSWAPPassBase &&) = delete;
  ~DisentangleSWAPPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("disentangle-SWAP");
  }
  ::llvm::StringRef getArgument() const override { return "disentangle-SWAP"; }

  ::llvm::StringRef getDescription() const override { return "Replace a SWAP gate with single qubit gates and a shorter SWAPZ gates whenever possible."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DisentangleSWAPPass");
  }
  ::llvm::StringRef getName() const override { return "DisentangleSWAPPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DisentangleSWAPPassBase<DerivedT>)

  DisentangleSWAPPassBase(DisentangleSWAPPassOptions options) : DisentangleSWAPPassBase() {
    EmitFSMStateRemark = std::move(options.EmitFSMStateRemark);
  }
protected:
  ::mlir::Pass::Option<bool> EmitFSMStateRemark{*this, "emit-FSM-state-remark", ::llvm::cl::desc("Whether to emit the state analysis result from the simple states propagation FSM onto the gate operations."), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_DISENTANGLESWAPPASS
#endif // GEN_PASS_DEF_DISENTANGLESWAPPASS

//===----------------------------------------------------------------------===//
// EmitCatalystPyInterfacePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EMITCATALYSTPYINTERFACEPASS
#undef GEN_PASS_DECL_EMITCATALYSTPYINTERFACEPASS
#endif // GEN_PASS_DECL_EMITCATALYSTPYINTERFACEPASS
#ifdef GEN_PASS_DEF_EMITCATALYSTPYINTERFACEPASS
namespace impl {

template <typename DerivedT>
class EmitCatalystPyInterfacePassBase : public ::mlir::OperationPass<> {
public:
  using Base = EmitCatalystPyInterfacePassBase;

  EmitCatalystPyInterfacePassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  EmitCatalystPyInterfacePassBase(const EmitCatalystPyInterfacePassBase &other) : ::mlir::OperationPass<>(other) {}
  EmitCatalystPyInterfacePassBase& operator=(const EmitCatalystPyInterfacePassBase &) = delete;
  EmitCatalystPyInterfacePassBase(EmitCatalystPyInterfacePassBase &&) = delete;
  EmitCatalystPyInterfacePassBase& operator=(EmitCatalystPyInterfacePassBase &&) = delete;
  ~EmitCatalystPyInterfacePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("emit-catalyst-py-interface");
  }
  ::llvm::StringRef getArgument() const override { return "emit-catalyst-py-interface"; }

  ::llvm::StringRef getDescription() const override { return "Emit catalyst python's default interface."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("EmitCatalystPyInterfacePass");
  }
  ::llvm::StringRef getName() const override { return "EmitCatalystPyInterfacePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(EmitCatalystPyInterfacePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EMITCATALYSTPYINTERFACEPASS
#endif // GEN_PASS_DEF_EMITCATALYSTPYINTERFACEPASS

//===----------------------------------------------------------------------===//
// IonsDecompositionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_IONSDECOMPOSITIONPASS
#undef GEN_PASS_DECL_IONSDECOMPOSITIONPASS
#endif // GEN_PASS_DECL_IONSDECOMPOSITIONPASS
#ifdef GEN_PASS_DEF_IONSDECOMPOSITIONPASS
namespace impl {

template <typename DerivedT>
class IonsDecompositionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = IonsDecompositionPassBase;

  IonsDecompositionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  IonsDecompositionPassBase(const IonsDecompositionPassBase &other) : ::mlir::OperationPass<>(other) {}
  IonsDecompositionPassBase& operator=(const IonsDecompositionPassBase &) = delete;
  IonsDecompositionPassBase(IonsDecompositionPassBase &&) = delete;
  IonsDecompositionPassBase& operator=(IonsDecompositionPassBase &&) = delete;
  ~IonsDecompositionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("ions-decomposition");
  }
  ::llvm::StringRef getArgument() const override { return "ions-decomposition"; }

  ::llvm::StringRef getDescription() const override { return "Decompose the gates to the set {RX, RY, MS}"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("IonsDecompositionPass");
  }
  ::llvm::StringRef getName() const override { return "IonsDecompositionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(IonsDecompositionPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_IONSDECOMPOSITIONPASS
#endif // GEN_PASS_DEF_IONSDECOMPOSITIONPASS

//===----------------------------------------------------------------------===//
// LoopBoundaryOptimizationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOOPBOUNDARYOPTIMIZATIONPASS
#undef GEN_PASS_DECL_LOOPBOUNDARYOPTIMIZATIONPASS
#endif // GEN_PASS_DECL_LOOPBOUNDARYOPTIMIZATIONPASS
#ifdef GEN_PASS_DEF_LOOPBOUNDARYOPTIMIZATIONPASS
namespace impl {

template <typename DerivedT>
class LoopBoundaryOptimizationPassBase : public ::mlir::OperationPass<> {
public:
  using Base = LoopBoundaryOptimizationPassBase;

  LoopBoundaryOptimizationPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  LoopBoundaryOptimizationPassBase(const LoopBoundaryOptimizationPassBase &other) : ::mlir::OperationPass<>(other) {}
  LoopBoundaryOptimizationPassBase& operator=(const LoopBoundaryOptimizationPassBase &) = delete;
  LoopBoundaryOptimizationPassBase(LoopBoundaryOptimizationPassBase &&) = delete;
  LoopBoundaryOptimizationPassBase& operator=(LoopBoundaryOptimizationPassBase &&) = delete;
  ~LoopBoundaryOptimizationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("loop-boundary");
  }
  ::llvm::StringRef getArgument() const override { return "loop-boundary"; }

  ::llvm::StringRef getDescription() const override { return "Perform loop boundary optimization to eliminate the redundancy of operations on loop boundary."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LoopBoundaryOptimizationPass");
  }
  ::llvm::StringRef getName() const override { return "LoopBoundaryOptimizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LoopBoundaryOptimizationPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOOPBOUNDARYOPTIMIZATIONPASS
#endif // GEN_PASS_DEF_LOOPBOUNDARYOPTIMIZATIONPASS

//===----------------------------------------------------------------------===//
// MergeRotationsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MERGEROTATIONSPASS
#undef GEN_PASS_DECL_MERGEROTATIONSPASS
#endif // GEN_PASS_DECL_MERGEROTATIONSPASS
#ifdef GEN_PASS_DEF_MERGEROTATIONSPASS
namespace impl {

template <typename DerivedT>
class MergeRotationsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = MergeRotationsPassBase;

  MergeRotationsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  MergeRotationsPassBase(const MergeRotationsPassBase &other) : ::mlir::OperationPass<>(other) {}
  MergeRotationsPassBase& operator=(const MergeRotationsPassBase &) = delete;
  MergeRotationsPassBase(MergeRotationsPassBase &&) = delete;
  MergeRotationsPassBase& operator=(MergeRotationsPassBase &&) = delete;
  ~MergeRotationsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("merge-rotations");
  }
  ::llvm::StringRef getArgument() const override { return "merge-rotations"; }

  ::llvm::StringRef getDescription() const override { return "Perform merging of chained rotation gates about the same axis."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MergeRotationsPass");
  }
  ::llvm::StringRef getName() const override { return "MergeRotationsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<math::MathDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MergeRotationsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_MERGEROTATIONSPASS
#endif // GEN_PASS_DEF_MERGEROTATIONSPASS

//===----------------------------------------------------------------------===//
// QuantumConversionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_QUANTUMCONVERSIONPASS
struct QuantumConversionPassOptions {
  bool useArrayBackedRegisters = false;
};
#undef GEN_PASS_DECL_QUANTUMCONVERSIONPASS
#endif // GEN_PASS_DECL_QUANTUMCONVERSIONPASS
#ifdef GEN_PASS_DEF_QUANTUMCONVERSIONPASS
namespace impl {

template <typename DerivedT>
class QuantumConversionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = QuantumConversionPassBase;

  QuantumConversionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  QuantumConversionPassBase(const QuantumConversionPassBase &other) : ::mlir::OperationPass<>(other) {}
  QuantumConversionPassBase& operator=(const QuantumConversionPassBase &) = delete;
  QuantumConversionPassBase(QuantumConversionPassBase &&) = delete;
  QuantumConversionPassBase& operator=(QuantumConversionPassBase &&) = delete;
  ~QuantumConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-quantum-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-quantum-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Perform a dialect conversion from Quantum to LLVM (QIR)."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("QuantumConversionPass");
  }
  ::llvm::StringRef getName() const override { return "QuantumConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(QuantumConversionPassBase<DerivedT>)

  QuantumConversionPassBase(QuantumConversionPassOptions options) : QuantumConversionPassBase() {
    useArrayBackedRegisters = std::move(options.useArrayBackedRegisters);
  }
protected:
  ::mlir::Pass::Option<bool> useArrayBackedRegisters{*this, "use-array-backed-registers", ::llvm::cl::desc("Use the array-backed-registers conversion pattern for quantum.insert ops."), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_QUANTUMCONVERSIONPASS
#endif // GEN_PASS_DEF_QUANTUMCONVERSIONPASS

//===----------------------------------------------------------------------===//
// RemoveChainedSelfInversePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REMOVECHAINEDSELFINVERSEPASS
#undef GEN_PASS_DECL_REMOVECHAINEDSELFINVERSEPASS
#endif // GEN_PASS_DECL_REMOVECHAINEDSELFINVERSEPASS
#ifdef GEN_PASS_DEF_REMOVECHAINEDSELFINVERSEPASS
namespace impl {

template <typename DerivedT>
class RemoveChainedSelfInversePassBase : public ::mlir::OperationPass<> {
public:
  using Base = RemoveChainedSelfInversePassBase;

  RemoveChainedSelfInversePassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  RemoveChainedSelfInversePassBase(const RemoveChainedSelfInversePassBase &other) : ::mlir::OperationPass<>(other) {}
  RemoveChainedSelfInversePassBase& operator=(const RemoveChainedSelfInversePassBase &) = delete;
  RemoveChainedSelfInversePassBase(RemoveChainedSelfInversePassBase &&) = delete;
  RemoveChainedSelfInversePassBase& operator=(RemoveChainedSelfInversePassBase &&) = delete;
  ~RemoveChainedSelfInversePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("remove-chained-self-inverse");
  }
  ::llvm::StringRef getArgument() const override { return "remove-chained-self-inverse"; }

  ::llvm::StringRef getDescription() const override { return "Perform removal of chained operations that are self inverses."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RemoveChainedSelfInversePass");
  }
  ::llvm::StringRef getName() const override { return "RemoveChainedSelfInversePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RemoveChainedSelfInversePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REMOVECHAINEDSELFINVERSEPASS
#endif // GEN_PASS_DEF_REMOVECHAINEDSELFINVERSEPASS

//===----------------------------------------------------------------------===//
// SplitMultipleTapesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SPLITMULTIPLETAPESPASS
#undef GEN_PASS_DECL_SPLITMULTIPLETAPESPASS
#endif // GEN_PASS_DECL_SPLITMULTIPLETAPESPASS
#ifdef GEN_PASS_DEF_SPLITMULTIPLETAPESPASS
namespace impl {

template <typename DerivedT>
class SplitMultipleTapesPassBase : public ::mlir::OperationPass<> {
public:
  using Base = SplitMultipleTapesPassBase;

  SplitMultipleTapesPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  SplitMultipleTapesPassBase(const SplitMultipleTapesPassBase &other) : ::mlir::OperationPass<>(other) {}
  SplitMultipleTapesPassBase& operator=(const SplitMultipleTapesPassBase &) = delete;
  SplitMultipleTapesPassBase(SplitMultipleTapesPassBase &&) = delete;
  SplitMultipleTapesPassBase& operator=(SplitMultipleTapesPassBase &&) = delete;
  ~SplitMultipleTapesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("split-multiple-tapes");
  }
  ::llvm::StringRef getArgument() const override { return "split-multiple-tapes"; }

  ::llvm::StringRef getDescription() const override { return "Given a qnode containing multiple tapes, split each tape into its own function."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SplitMultipleTapesPass");
  }
  ::llvm::StringRef getName() const override { return "SplitMultipleTapesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SplitMultipleTapesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SPLITMULTIPLETAPESPASS
#endif // GEN_PASS_DEF_SPLITMULTIPLETAPESPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// AdjointLoweringPass Registration
//===----------------------------------------------------------------------===//

inline void registerAdjointLoweringPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createAdjointLoweringPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAdjointLoweringPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createAdjointLoweringPass();
  });
}

//===----------------------------------------------------------------------===//
// AnnotateFunctionPass Registration
//===----------------------------------------------------------------------===//

inline void registerAnnotateFunctionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createAnnotateFunctionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAnnotateFunctionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createAnnotateFunctionPass();
  });
}

//===----------------------------------------------------------------------===//
// CopyGlobalMemRefPass Registration
//===----------------------------------------------------------------------===//

inline void registerCopyGlobalMemRefPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createCopyGlobalMemRefPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerCopyGlobalMemRefPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createCopyGlobalMemRefPass();
  });
}

//===----------------------------------------------------------------------===//
// DecomposeLoweringPass Registration
//===----------------------------------------------------------------------===//

inline void registerDecomposeLoweringPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createDecomposeLoweringPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerDecomposeLoweringPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createDecomposeLoweringPass();
  });
}

//===----------------------------------------------------------------------===//
// DisentangleCNOTPass Registration
//===----------------------------------------------------------------------===//

inline void registerDisentangleCNOTPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createDisentangleCNOTPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerDisentangleCNOTPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createDisentangleCNOTPass();
  });
}

//===----------------------------------------------------------------------===//
// DisentangleSWAPPass Registration
//===----------------------------------------------------------------------===//

inline void registerDisentangleSWAPPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createDisentangleSWAPPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerDisentangleSWAPPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createDisentangleSWAPPass();
  });
}

//===----------------------------------------------------------------------===//
// EmitCatalystPyInterfacePass Registration
//===----------------------------------------------------------------------===//

inline void registerEmitCatalystPyInterfacePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createEmitCatalystPyInterfacePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerEmitCatalystPyInterfacePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createEmitCatalystPyInterfacePass();
  });
}

//===----------------------------------------------------------------------===//
// IonsDecompositionPass Registration
//===----------------------------------------------------------------------===//

inline void registerIonsDecompositionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createIonsDecompositionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerIonsDecompositionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createIonsDecompositionPass();
  });
}

//===----------------------------------------------------------------------===//
// LoopBoundaryOptimizationPass Registration
//===----------------------------------------------------------------------===//

inline void registerLoopBoundaryOptimizationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createLoopBoundaryOptimizationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLoopBoundaryOptimizationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createLoopBoundaryOptimizationPass();
  });
}

//===----------------------------------------------------------------------===//
// MergeRotationsPass Registration
//===----------------------------------------------------------------------===//

inline void registerMergeRotationsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createMergeRotationsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMergeRotationsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createMergeRotationsPass();
  });
}

//===----------------------------------------------------------------------===//
// QuantumConversionPass Registration
//===----------------------------------------------------------------------===//

inline void registerQuantumConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createQuantumConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerQuantumConversionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createQuantumConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// RemoveChainedSelfInversePass Registration
//===----------------------------------------------------------------------===//

inline void registerRemoveChainedSelfInversePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createRemoveChainedSelfInversePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRemoveChainedSelfInversePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createRemoveChainedSelfInversePass();
  });
}

//===----------------------------------------------------------------------===//
// SplitMultipleTapesPass Registration
//===----------------------------------------------------------------------===//

inline void registerSplitMultipleTapesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createSplitMultipleTapesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSplitMultipleTapesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return catalyst::createSplitMultipleTapesPass();
  });
}

//===----------------------------------------------------------------------===//
// quantum Registration
//===----------------------------------------------------------------------===//

inline void registerquantumPasses() {
  registerAdjointLoweringPass();
  registerAnnotateFunctionPass();
  registerCopyGlobalMemRefPass();
  registerDecomposeLoweringPass();
  registerDisentangleCNOTPass();
  registerDisentangleSWAPPass();
  registerEmitCatalystPyInterfacePass();
  registerIonsDecompositionPass();
  registerLoopBoundaryOptimizationPass();
  registerMergeRotationsPass();
  registerQuantumConversionPass();
  registerRemoveChainedSelfInversePass();
  registerSplitMultipleTapesPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class AdjointLoweringPassBase : public ::mlir::OperationPass<> {
public:
  using Base = AdjointLoweringPassBase;

  AdjointLoweringPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  AdjointLoweringPassBase(const AdjointLoweringPassBase &other) : ::mlir::OperationPass<>(other) {}
  AdjointLoweringPassBase& operator=(const AdjointLoweringPassBase &) = delete;
  AdjointLoweringPassBase(AdjointLoweringPassBase &&) = delete;
  AdjointLoweringPassBase& operator=(AdjointLoweringPassBase &&) = delete;
  ~AdjointLoweringPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("adjoint-lowering");
  }
  ::llvm::StringRef getArgument() const override { return "adjoint-lowering"; }

  ::llvm::StringRef getDescription() const override { return "Lower adjoint regions containing a single quantum operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AdjointLoweringPass");
  }
  ::llvm::StringRef getName() const override { return "AdjointLoweringPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<catalyst::CatalystDialect>();
    registry.insert<index::IndexDialect>();
    registry.insert<tensor::TensorDialect>();
    registry.insert<complex::ComplexDialect>();
    registry.insert<scf::SCFDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AdjointLoweringPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class AnnotateFunctionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = AnnotateFunctionPassBase;

  AnnotateFunctionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  AnnotateFunctionPassBase(const AnnotateFunctionPassBase &other) : ::mlir::OperationPass<>(other) {}
  AnnotateFunctionPassBase& operator=(const AnnotateFunctionPassBase &) = delete;
  AnnotateFunctionPassBase(AnnotateFunctionPassBase &&) = delete;
  AnnotateFunctionPassBase& operator=(AnnotateFunctionPassBase &&) = delete;
  ~AnnotateFunctionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("annotate-function");
  }
  ::llvm::StringRef getArgument() const override { return "annotate-function"; }

  ::llvm::StringRef getDescription() const override { return "Annotate functions that contain a measurement operation."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AnnotateFunctionPass");
  }
  ::llvm::StringRef getName() const override { return "AnnotateFunctionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<catalyst::CatalystDialect>();
    registry.insert<func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AnnotateFunctionPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class CopyGlobalMemRefPassBase : public ::mlir::OperationPass<> {
public:
  using Base = CopyGlobalMemRefPassBase;

  CopyGlobalMemRefPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  CopyGlobalMemRefPassBase(const CopyGlobalMemRefPassBase &other) : ::mlir::OperationPass<>(other) {}
  CopyGlobalMemRefPassBase& operator=(const CopyGlobalMemRefPassBase &) = delete;
  CopyGlobalMemRefPassBase(CopyGlobalMemRefPassBase &&) = delete;
  CopyGlobalMemRefPassBase& operator=(CopyGlobalMemRefPassBase &&) = delete;
  ~CopyGlobalMemRefPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("cp-global-memref");
  }
  ::llvm::StringRef getArgument() const override { return "cp-global-memref"; }

  ::llvm::StringRef getDescription() const override { return "Copy global memrefs before returning from C interface."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CopyGlobalMemRefPass");
  }
  ::llvm::StringRef getName() const override { return "CopyGlobalMemRefPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<memref::MemRefDialect>();
    registry.insert<func::FuncDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CopyGlobalMemRefPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class DecomposeLoweringPassBase : public ::mlir::OperationPass<> {
public:
  using Base = DecomposeLoweringPassBase;

  DecomposeLoweringPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  DecomposeLoweringPassBase(const DecomposeLoweringPassBase &other) : ::mlir::OperationPass<>(other) {}
  DecomposeLoweringPassBase& operator=(const DecomposeLoweringPassBase &) = delete;
  DecomposeLoweringPassBase(DecomposeLoweringPassBase &&) = delete;
  DecomposeLoweringPassBase& operator=(DecomposeLoweringPassBase &&) = delete;
  ~DecomposeLoweringPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("decompose-lowering");
  }
  ::llvm::StringRef getArgument() const override { return "decompose-lowering"; }

  ::llvm::StringRef getDescription() const override { return "Replace quantum operations with compiled decomposition rules."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DecomposeLoweringPass");
  }
  ::llvm::StringRef getName() const override { return "DecomposeLoweringPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DecomposeLoweringPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class DisentangleCNOTPassBase : public ::mlir::OperationPass<> {
public:
  using Base = DisentangleCNOTPassBase;

  DisentangleCNOTPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  DisentangleCNOTPassBase(const DisentangleCNOTPassBase &other) : ::mlir::OperationPass<>(other) {}
  DisentangleCNOTPassBase& operator=(const DisentangleCNOTPassBase &) = delete;
  DisentangleCNOTPassBase(DisentangleCNOTPassBase &&) = delete;
  DisentangleCNOTPassBase& operator=(DisentangleCNOTPassBase &&) = delete;
  ~DisentangleCNOTPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("disentangle-CNOT");
  }
  ::llvm::StringRef getArgument() const override { return "disentangle-CNOT"; }

  ::llvm::StringRef getDescription() const override { return "Replace a CNOT gate with two single qubit gates whenever possible."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DisentangleCNOTPass");
  }
  ::llvm::StringRef getName() const override { return "DisentangleCNOTPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DisentangleCNOTPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> EmitFSMStateRemark{*this, "emit-FSM-state-remark", ::llvm::cl::desc("Whether to emit the state analysis result from the simple states propagation FSM onto the gate operations."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class DisentangleSWAPPassBase : public ::mlir::OperationPass<> {
public:
  using Base = DisentangleSWAPPassBase;

  DisentangleSWAPPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  DisentangleSWAPPassBase(const DisentangleSWAPPassBase &other) : ::mlir::OperationPass<>(other) {}
  DisentangleSWAPPassBase& operator=(const DisentangleSWAPPassBase &) = delete;
  DisentangleSWAPPassBase(DisentangleSWAPPassBase &&) = delete;
  DisentangleSWAPPassBase& operator=(DisentangleSWAPPassBase &&) = delete;
  ~DisentangleSWAPPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("disentangle-SWAP");
  }
  ::llvm::StringRef getArgument() const override { return "disentangle-SWAP"; }

  ::llvm::StringRef getDescription() const override { return "Replace a SWAP gate with single qubit gates and a shorter SWAPZ gates whenever possible."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DisentangleSWAPPass");
  }
  ::llvm::StringRef getName() const override { return "DisentangleSWAPPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DisentangleSWAPPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> EmitFSMStateRemark{*this, "emit-FSM-state-remark", ::llvm::cl::desc("Whether to emit the state analysis result from the simple states propagation FSM onto the gate operations."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class EmitCatalystPyInterfacePassBase : public ::mlir::OperationPass<> {
public:
  using Base = EmitCatalystPyInterfacePassBase;

  EmitCatalystPyInterfacePassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  EmitCatalystPyInterfacePassBase(const EmitCatalystPyInterfacePassBase &other) : ::mlir::OperationPass<>(other) {}
  EmitCatalystPyInterfacePassBase& operator=(const EmitCatalystPyInterfacePassBase &) = delete;
  EmitCatalystPyInterfacePassBase(EmitCatalystPyInterfacePassBase &&) = delete;
  EmitCatalystPyInterfacePassBase& operator=(EmitCatalystPyInterfacePassBase &&) = delete;
  ~EmitCatalystPyInterfacePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("emit-catalyst-py-interface");
  }
  ::llvm::StringRef getArgument() const override { return "emit-catalyst-py-interface"; }

  ::llvm::StringRef getDescription() const override { return "Emit catalyst python's default interface."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("EmitCatalystPyInterfacePass");
  }
  ::llvm::StringRef getName() const override { return "EmitCatalystPyInterfacePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(EmitCatalystPyInterfacePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class IonsDecompositionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = IonsDecompositionPassBase;

  IonsDecompositionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  IonsDecompositionPassBase(const IonsDecompositionPassBase &other) : ::mlir::OperationPass<>(other) {}
  IonsDecompositionPassBase& operator=(const IonsDecompositionPassBase &) = delete;
  IonsDecompositionPassBase(IonsDecompositionPassBase &&) = delete;
  IonsDecompositionPassBase& operator=(IonsDecompositionPassBase &&) = delete;
  ~IonsDecompositionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("ions-decomposition");
  }
  ::llvm::StringRef getArgument() const override { return "ions-decomposition"; }

  ::llvm::StringRef getDescription() const override { return "Decompose the gates to the set {RX, RY, MS}"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("IonsDecompositionPass");
  }
  ::llvm::StringRef getName() const override { return "IonsDecompositionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(IonsDecompositionPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LoopBoundaryOptimizationPassBase : public ::mlir::OperationPass<> {
public:
  using Base = LoopBoundaryOptimizationPassBase;

  LoopBoundaryOptimizationPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  LoopBoundaryOptimizationPassBase(const LoopBoundaryOptimizationPassBase &other) : ::mlir::OperationPass<>(other) {}
  LoopBoundaryOptimizationPassBase& operator=(const LoopBoundaryOptimizationPassBase &) = delete;
  LoopBoundaryOptimizationPassBase(LoopBoundaryOptimizationPassBase &&) = delete;
  LoopBoundaryOptimizationPassBase& operator=(LoopBoundaryOptimizationPassBase &&) = delete;
  ~LoopBoundaryOptimizationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("loop-boundary");
  }
  ::llvm::StringRef getArgument() const override { return "loop-boundary"; }

  ::llvm::StringRef getDescription() const override { return "Perform loop boundary optimization to eliminate the redundancy of operations on loop boundary."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LoopBoundaryOptimizationPass");
  }
  ::llvm::StringRef getName() const override { return "LoopBoundaryOptimizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LoopBoundaryOptimizationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MergeRotationsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = MergeRotationsPassBase;

  MergeRotationsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  MergeRotationsPassBase(const MergeRotationsPassBase &other) : ::mlir::OperationPass<>(other) {}
  MergeRotationsPassBase& operator=(const MergeRotationsPassBase &) = delete;
  MergeRotationsPassBase(MergeRotationsPassBase &&) = delete;
  MergeRotationsPassBase& operator=(MergeRotationsPassBase &&) = delete;
  ~MergeRotationsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("merge-rotations");
  }
  ::llvm::StringRef getArgument() const override { return "merge-rotations"; }

  ::llvm::StringRef getDescription() const override { return "Perform merging of chained rotation gates about the same axis."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MergeRotationsPass");
  }
  ::llvm::StringRef getName() const override { return "MergeRotationsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<math::MathDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MergeRotationsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class QuantumConversionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = QuantumConversionPassBase;

  QuantumConversionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  QuantumConversionPassBase(const QuantumConversionPassBase &other) : ::mlir::OperationPass<>(other) {}
  QuantumConversionPassBase& operator=(const QuantumConversionPassBase &) = delete;
  QuantumConversionPassBase(QuantumConversionPassBase &&) = delete;
  QuantumConversionPassBase& operator=(QuantumConversionPassBase &&) = delete;
  ~QuantumConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-quantum-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-quantum-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Perform a dialect conversion from Quantum to LLVM (QIR)."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("QuantumConversionPass");
  }
  ::llvm::StringRef getName() const override { return "QuantumConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(QuantumConversionPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> useArrayBackedRegisters{*this, "use-array-backed-registers", ::llvm::cl::desc("Use the array-backed-registers conversion pattern for quantum.insert ops."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class RemoveChainedSelfInversePassBase : public ::mlir::OperationPass<> {
public:
  using Base = RemoveChainedSelfInversePassBase;

  RemoveChainedSelfInversePassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  RemoveChainedSelfInversePassBase(const RemoveChainedSelfInversePassBase &other) : ::mlir::OperationPass<>(other) {}
  RemoveChainedSelfInversePassBase& operator=(const RemoveChainedSelfInversePassBase &) = delete;
  RemoveChainedSelfInversePassBase(RemoveChainedSelfInversePassBase &&) = delete;
  RemoveChainedSelfInversePassBase& operator=(RemoveChainedSelfInversePassBase &&) = delete;
  ~RemoveChainedSelfInversePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("remove-chained-self-inverse");
  }
  ::llvm::StringRef getArgument() const override { return "remove-chained-self-inverse"; }

  ::llvm::StringRef getDescription() const override { return "Perform removal of chained operations that are self inverses."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RemoveChainedSelfInversePass");
  }
  ::llvm::StringRef getName() const override { return "RemoveChainedSelfInversePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RemoveChainedSelfInversePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class SplitMultipleTapesPassBase : public ::mlir::OperationPass<> {
public:
  using Base = SplitMultipleTapesPassBase;

  SplitMultipleTapesPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  SplitMultipleTapesPassBase(const SplitMultipleTapesPassBase &other) : ::mlir::OperationPass<>(other) {}
  SplitMultipleTapesPassBase& operator=(const SplitMultipleTapesPassBase &) = delete;
  SplitMultipleTapesPassBase(SplitMultipleTapesPassBase &&) = delete;
  SplitMultipleTapesPassBase& operator=(SplitMultipleTapesPassBase &&) = delete;
  ~SplitMultipleTapesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("split-multiple-tapes");
  }
  ::llvm::StringRef getArgument() const override { return "split-multiple-tapes"; }

  ::llvm::StringRef getDescription() const override { return "Given a qnode containing multiple tapes, split each tape into its own function."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SplitMultipleTapesPass");
  }
  ::llvm::StringRef getName() const override { return "SplitMultipleTapesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SplitMultipleTapesPassBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
