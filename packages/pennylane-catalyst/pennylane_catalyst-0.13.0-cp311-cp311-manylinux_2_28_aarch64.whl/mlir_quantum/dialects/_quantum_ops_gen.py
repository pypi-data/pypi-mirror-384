
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "quantum"

@_ods_cext.register_operation(_Dialect)
class AdjointOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.adjoint"

  _ODS_REGIONS = (1, True)

  def __init__(self, out_qreg, qreg, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(qreg)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(out_qreg)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def qreg(self):
    return self.operation.operands[0]

  @builtins.property
  def out_qreg(self):
    return self.operation.results[0]

  @builtins.property
  def region(self):
    return self.regions[0]

def adjoint(out_qreg, qreg, *, loc=None, ip=None) -> _ods_ir.Value:
  return AdjointOp(out_qreg=out_qreg, qreg=qreg, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AllocOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.alloc"

  _ODS_REGIONS = (0, True)

  def __init__(self, qreg, *, nqubits=None, nqubits_attr=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    if nqubits is not None: operands.append(nqubits)
    _ods_context = _ods_get_default_loc_context(loc)
    if nqubits_attr is not None: attributes["nqubits_attr"] = (nqubits_attr if (
        isinstance(nqubits_attr, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(nqubits_attr, context=_ods_context))
    results.append(qreg)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def nqubits(self):
    return None if len(self.operation.operands) < 1 else self.operation.operands[0]

  @builtins.property
  def nqubits_attr(self):
    if "nqubits_attr" not in self.operation.attributes:
      return None
    return self.operation.attributes["nqubits_attr"]

  @nqubits_attr.setter
  def nqubits_attr(self, value):
    if value is not None:
      self.operation.attributes["nqubits_attr"] = value
    elif "nqubits_attr" in self.operation.attributes:
      del self.operation.attributes["nqubits_attr"]

  @nqubits_attr.deleter
  def nqubits_attr(self):
    del self.operation.attributes["nqubits_attr"]

  @builtins.property
  def qreg(self):
    return self.operation.results[0]

def alloc(qreg, *, nqubits=None, nqubits_attr=None, loc=None, ip=None) -> _ods_ir.Value:
  return AllocOp(qreg=qreg, nqubits=nqubits, nqubits_attr=nqubits_attr, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AllocQubitOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.alloc_qb"

  _ODS_REGIONS = (0, True)

  def __init__(self, qubit, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(qubit)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def qubit(self):
    return self.operation.results[0]

def alloc_qb(qubit, *, loc=None, ip=None) -> _ods_ir.Value:
  return AllocQubitOp(qubit=qubit, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ComputationalBasisOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.compbasis"

  _ODS_OPERAND_SEGMENTS = [-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, obs, qubits, *, qreg=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(qubits))
    operands.append(qreg)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(obs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def qubits(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def qreg(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def obs(self):
    return self.operation.results[0]

def compbasis(obs, qubits, *, qreg=None, loc=None, ip=None) -> _ods_ir.Value:
  return ComputationalBasisOp(obs=obs, qubits=qubits, qreg=qreg, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CountsOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.counts"

  _ODS_OPERAND_SEGMENTS = [1,0,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, eigvals, counts, obs, *, dynamic_shape=None, in_eigvals=None, in_counts=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(obs)
    operands.append(dynamic_shape)
    operands.append(in_eigvals)
    operands.append(in_counts)
    _ods_context = _ods_get_default_loc_context(loc)
    if eigvals is not None: results.append(eigvals)
    if counts is not None: results.append(counts)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def obs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def dynamic_shape(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def in_eigvals(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def in_counts(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def eigvals(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.results, 0, 2, 0, 0)
    return self.operation.results[start:start + elements_per_group]

  @builtins.property
  def counts(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.results, 0, 2, 0, 1)
    return self.operation.results[start:start + elements_per_group]

def counts(eigvals, counts, obs, *, dynamic_shape=None, in_eigvals=None, in_counts=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(CountsOp(eigvals=eigvals, counts=counts, obs=obs, dynamic_shape=dynamic_shape, in_eigvals=in_eigvals, in_counts=in_counts, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class CustomOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.custom"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,]

  _ODS_RESULT_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, out_qubits, out_ctrl_qubits, params, in_qubits, gate_name, in_ctrl_qubits, in_ctrl_values, *, adjoint=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(params))
    operands.append(_get_op_results_or_values(in_qubits))
    operands.append(_get_op_results_or_values(in_ctrl_qubits))
    operands.append(_get_op_results_or_values(in_ctrl_values))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["gate_name"] = (gate_name if (
    isinstance(gate_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(gate_name, context=_ods_context))
    if bool(adjoint): attributes["adjoint"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(out_qubits)
    results.append(out_ctrl_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def params(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def in_qubits(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def in_ctrl_qubits(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def in_ctrl_values(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def gate_name(self):
    return self.operation.attributes["gate_name"]

  @gate_name.setter
  def gate_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["gate_name"] = value

  @builtins.property
  def adjoint(self):
    return "adjoint" in self.operation.attributes

  @adjoint.setter
  def adjoint(self, value):
    if bool(value):
      self.operation.attributes["adjoint"] = _ods_ir.UnitAttr.get()
    elif "adjoint" in self.operation.attributes:
      del self.operation.attributes["adjoint"]

  @adjoint.deleter
  def adjoint(self):
    del self.operation.attributes["adjoint"]

  @builtins.property
  def out_qubits(self):
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 0)
    return result_range

  @builtins.property
  def out_ctrl_qubits(self):
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 1)
    return result_range

def custom(out_qubits, out_ctrl_qubits, params, in_qubits, gate_name, in_ctrl_qubits, in_ctrl_values, *, adjoint=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(CustomOp(out_qubits=out_qubits, out_ctrl_qubits=out_ctrl_qubits, params=params, in_qubits=in_qubits, gate_name=gate_name, in_ctrl_qubits=in_ctrl_qubits, in_ctrl_values=in_ctrl_values, adjoint=adjoint, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class DeallocOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.dealloc"

  _ODS_REGIONS = (0, True)

  def __init__(self, qreg, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(qreg)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def qreg(self):
    return self.operation.operands[0]

def dealloc(qreg, *, loc=None, ip=None) -> _ods_ir.Operation:
  return DeallocOp(qreg=qreg, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeallocQubitOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.dealloc_qb"

  _ODS_REGIONS = (0, True)

  def __init__(self, qubit, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(qubit)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def qubit(self):
    return self.operation.operands[0]

def dealloc_qb(qubit, *, loc=None, ip=None) -> _ods_ir.Operation:
  return DeallocQubitOp(qubit=qubit, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceInitOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.device"

  _ODS_REGIONS = (0, True)

  def __init__(self, lib, device_name, kwargs, *, shots=None, auto_qubit_management=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    if shots is not None: operands.append(shots)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(auto_qubit_management): attributes["auto_qubit_management"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    attributes["lib"] = (lib if (
    isinstance(lib, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(lib, context=_ods_context))
    attributes["device_name"] = (device_name if (
    isinstance(device_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(device_name, context=_ods_context))
    attributes["kwargs"] = (kwargs if (
    isinstance(kwargs, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(kwargs, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shots(self):
    return None if len(self.operation.operands) < 1 else self.operation.operands[0]

  @builtins.property
  def auto_qubit_management(self):
    return "auto_qubit_management" in self.operation.attributes

  @auto_qubit_management.setter
  def auto_qubit_management(self, value):
    if bool(value):
      self.operation.attributes["auto_qubit_management"] = _ods_ir.UnitAttr.get()
    elif "auto_qubit_management" in self.operation.attributes:
      del self.operation.attributes["auto_qubit_management"]

  @auto_qubit_management.deleter
  def auto_qubit_management(self):
    del self.operation.attributes["auto_qubit_management"]

  @builtins.property
  def lib(self):
    return self.operation.attributes["lib"]

  @lib.setter
  def lib(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lib"] = value

  @builtins.property
  def device_name(self):
    return self.operation.attributes["device_name"]

  @device_name.setter
  def device_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["device_name"] = value

  @builtins.property
  def kwargs(self):
    return self.operation.attributes["kwargs"]

  @kwargs.setter
  def kwargs(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kwargs"] = value

def device(lib, device_name, kwargs, *, shots=None, auto_qubit_management=None, loc=None, ip=None) -> _ods_ir.Operation:
  return DeviceInitOp(lib=lib, device_name=device_name, kwargs=kwargs, shots=shots, auto_qubit_management=auto_qubit_management, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceReleaseOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.device_release"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def device_release(*, loc=None, ip=None) -> _ods_ir.Operation:
  return DeviceReleaseOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExpvalOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.expval"

  _ODS_REGIONS = (0, True)

  def __init__(self, expval, obs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(obs)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(expval)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def obs(self):
    return self.operation.operands[0]

  @builtins.property
  def expval(self):
    return self.operation.results[0]

def expval(expval, obs, *, loc=None, ip=None) -> _ods_ir.Value:
  return ExpvalOp(expval=expval, obs=obs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExtractOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.extract"

  _ODS_REGIONS = (0, True)

  def __init__(self, qubit, qreg, *, idx=None, idx_attr=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(qreg)
    if idx is not None: operands.append(idx)
    _ods_context = _ods_get_default_loc_context(loc)
    if idx_attr is not None: attributes["idx_attr"] = (idx_attr if (
        isinstance(idx_attr, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(idx_attr, context=_ods_context))
    results.append(qubit)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def qreg(self):
    return self.operation.operands[0]

  @builtins.property
  def idx(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def idx_attr(self):
    if "idx_attr" not in self.operation.attributes:
      return None
    return self.operation.attributes["idx_attr"]

  @idx_attr.setter
  def idx_attr(self, value):
    if value is not None:
      self.operation.attributes["idx_attr"] = value
    elif "idx_attr" in self.operation.attributes:
      del self.operation.attributes["idx_attr"]

  @idx_attr.deleter
  def idx_attr(self):
    del self.operation.attributes["idx_attr"]

  @builtins.property
  def qubit(self):
    return self.operation.results[0]

def extract(qubit, qreg, *, idx=None, idx_attr=None, loc=None, ip=None) -> _ods_ir.Value:
  return ExtractOp(qubit=qubit, qreg=qreg, idx=idx, idx_attr=idx_attr, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FinalizeOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.finalize"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def finalize(*, loc=None, ip=None) -> _ods_ir.Operation:
  return FinalizeOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalPhaseOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.gphase"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, out_ctrl_qubits, params, in_ctrl_qubits, in_ctrl_values, *, adjoint=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(params)
    operands.append(_get_op_results_or_values(in_ctrl_qubits))
    operands.append(_get_op_results_or_values(in_ctrl_values))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(adjoint): attributes["adjoint"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.extend(out_ctrl_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def params(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def in_ctrl_qubits(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def in_ctrl_values(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def adjoint(self):
    return "adjoint" in self.operation.attributes

  @adjoint.setter
  def adjoint(self, value):
    if bool(value):
      self.operation.attributes["adjoint"] = _ods_ir.UnitAttr.get()
    elif "adjoint" in self.operation.attributes:
      del self.operation.attributes["adjoint"]

  @adjoint.deleter
  def adjoint(self):
    del self.operation.attributes["adjoint"]

  @builtins.property
  def out_ctrl_qubits(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def gphase(out_ctrl_qubits, params, in_ctrl_qubits, in_ctrl_values, *, adjoint=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(GlobalPhaseOp(out_ctrl_qubits=out_ctrl_qubits, params=params, in_ctrl_qubits=in_ctrl_qubits, in_ctrl_values=in_ctrl_values, adjoint=adjoint, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class HamiltonianOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.hamiltonian"

  _ODS_REGIONS = (0, True)

  def __init__(self, obs, coeffs, terms, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(coeffs)
    operands.extend(_get_op_results_or_values(terms))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(obs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def coeffs(self):
    return self.operation.operands[0]

  @builtins.property
  def terms(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def obs(self):
    return self.operation.results[0]

def hamiltonian(obs, coeffs, terms, *, loc=None, ip=None) -> _ods_ir.Value:
  return HamiltonianOp(obs=obs, coeffs=coeffs, terms=terms, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class HermitianOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.hermitian"

  _ODS_REGIONS = (0, True)

  def __init__(self, obs, matrix, qubits, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(matrix)
    operands.extend(_get_op_results_or_values(qubits))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(obs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def matrix(self):
    return self.operation.operands[0]

  @builtins.property
  def qubits(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def obs(self):
    return self.operation.results[0]

def hermitian(obs, matrix, qubits, *, loc=None, ip=None) -> _ods_ir.Value:
  return HermitianOp(obs=obs, matrix=matrix, qubits=qubits, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InitializeOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.init"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def init(*, loc=None, ip=None) -> _ods_ir.Operation:
  return InitializeOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class InsertOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.insert"

  _ODS_REGIONS = (0, True)

  def __init__(self, out_qreg, in_qreg, qubit, *, idx=None, idx_attr=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(in_qreg)
    if idx is not None: operands.append(idx)
    operands.append(qubit)
    _ods_context = _ods_get_default_loc_context(loc)
    if idx_attr is not None: attributes["idx_attr"] = (idx_attr if (
        isinstance(idx_attr, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(idx_attr, context=_ods_context))
    results.append(out_qreg)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def in_qreg(self):
    return self.operation.operands[0]

  @builtins.property
  def idx(self):
    return None if len(self.operation.operands) < 3 else self.operation.operands[1]

  @builtins.property
  def qubit(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def idx_attr(self):
    if "idx_attr" not in self.operation.attributes:
      return None
    return self.operation.attributes["idx_attr"]

  @idx_attr.setter
  def idx_attr(self, value):
    if value is not None:
      self.operation.attributes["idx_attr"] = value
    elif "idx_attr" in self.operation.attributes:
      del self.operation.attributes["idx_attr"]

  @idx_attr.deleter
  def idx_attr(self):
    del self.operation.attributes["idx_attr"]

  @builtins.property
  def out_qreg(self):
    return self.operation.results[0]

def insert(out_qreg, in_qreg, qubit, *, idx=None, idx_attr=None, loc=None, ip=None) -> _ods_ir.Value:
  return InsertOp(out_qreg=out_qreg, in_qreg=in_qreg, qubit=qubit, idx=idx, idx_attr=idx_attr, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MeasureOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.measure"

  _ODS_REGIONS = (0, True)

  def __init__(self, mres, out_qubit, in_qubit, *, postselect=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(in_qubit)
    _ods_context = _ods_get_default_loc_context(loc)
    if postselect is not None: attributes["postselect"] = (postselect if (
        isinstance(postselect, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(postselect, context=_ods_context))
    results.append(mres)
    results.append(out_qubit)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def in_qubit(self):
    return self.operation.operands[0]

  @builtins.property
  def postselect(self):
    if "postselect" not in self.operation.attributes:
      return None
    return self.operation.attributes["postselect"]

  @postselect.setter
  def postselect(self, value):
    if value is not None:
      self.operation.attributes["postselect"] = value
    elif "postselect" in self.operation.attributes:
      del self.operation.attributes["postselect"]

  @postselect.deleter
  def postselect(self):
    del self.operation.attributes["postselect"]

  @builtins.property
  def mres(self):
    return self.operation.results[0]

  @builtins.property
  def out_qubit(self):
    return self.operation.results[1]

def measure(mres, out_qubit, in_qubit, *, postselect=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return MeasureOp(mres=mres, out_qubit=out_qubit, in_qubit=in_qubit, postselect=postselect, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class MultiRZOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.multirz"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,-1,]

  _ODS_RESULT_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, out_qubits, out_ctrl_qubits, theta, in_qubits, in_ctrl_qubits, in_ctrl_values, *, adjoint=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(theta)
    operands.append(_get_op_results_or_values(in_qubits))
    operands.append(_get_op_results_or_values(in_ctrl_qubits))
    operands.append(_get_op_results_or_values(in_ctrl_values))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(adjoint): attributes["adjoint"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(out_qubits)
    results.append(out_ctrl_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def theta(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def in_qubits(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def in_ctrl_qubits(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def in_ctrl_values(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def adjoint(self):
    return "adjoint" in self.operation.attributes

  @adjoint.setter
  def adjoint(self, value):
    if bool(value):
      self.operation.attributes["adjoint"] = _ods_ir.UnitAttr.get()
    elif "adjoint" in self.operation.attributes:
      del self.operation.attributes["adjoint"]

  @adjoint.deleter
  def adjoint(self):
    del self.operation.attributes["adjoint"]

  @builtins.property
  def out_qubits(self):
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 0)
    return result_range

  @builtins.property
  def out_ctrl_qubits(self):
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 1)
    return result_range

def multirz(out_qubits, out_ctrl_qubits, theta, in_qubits, in_ctrl_qubits, in_ctrl_values, *, adjoint=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(MultiRZOp(out_qubits=out_qubits, out_ctrl_qubits=out_ctrl_qubits, theta=theta, in_qubits=in_qubits, in_ctrl_qubits=in_ctrl_qubits, in_ctrl_values=in_ctrl_values, adjoint=adjoint, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class NamedObsOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.namedobs"

  _ODS_REGIONS = (0, True)

  def __init__(self, obs, qubit, type_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(qubit)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('NamedObservableAttr')) else
      _ods_ir.AttrBuilder.get('NamedObservableAttr')(type_, context=_ods_context))
    results.append(obs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def qubit(self):
    return self.operation.operands[0]

  @builtins.property
  def type_(self):
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def obs(self):
    return self.operation.results[0]

def namedobs(obs, qubit, type_, *, loc=None, ip=None) -> _ods_ir.Value:
  return NamedObsOp(obs=obs, qubit=qubit, type_=type_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NumQubitsOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.num_qubits"

  _ODS_REGIONS = (0, True)

  def __init__(self, num_qubits, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(num_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def num_qubits(self):
    return self.operation.results[0]

def num_qubits(num_qubits, *, loc=None, ip=None) -> _ods_ir.Value:
  return NumQubitsOp(num_qubits=num_qubits, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PCPhaseOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.pcphase"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,-1,-1,]

  _ODS_RESULT_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, out_qubits, out_ctrl_qubits, theta, dim, in_qubits, in_ctrl_qubits, in_ctrl_values, *, adjoint=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(theta)
    operands.append(dim)
    operands.append(_get_op_results_or_values(in_qubits))
    operands.append(_get_op_results_or_values(in_ctrl_qubits))
    operands.append(_get_op_results_or_values(in_ctrl_values))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(adjoint): attributes["adjoint"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(out_qubits)
    results.append(out_ctrl_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def theta(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def dim(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def in_qubits(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def in_ctrl_qubits(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def in_ctrl_values(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def adjoint(self):
    return "adjoint" in self.operation.attributes

  @adjoint.setter
  def adjoint(self, value):
    if bool(value):
      self.operation.attributes["adjoint"] = _ods_ir.UnitAttr.get()
    elif "adjoint" in self.operation.attributes:
      del self.operation.attributes["adjoint"]

  @adjoint.deleter
  def adjoint(self):
    del self.operation.attributes["adjoint"]

  @builtins.property
  def out_qubits(self):
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 0)
    return result_range

  @builtins.property
  def out_ctrl_qubits(self):
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 1)
    return result_range

def pcphase(out_qubits, out_ctrl_qubits, theta, dim, in_qubits, in_ctrl_qubits, in_ctrl_values, *, adjoint=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(PCPhaseOp(out_qubits=out_qubits, out_ctrl_qubits=out_ctrl_qubits, theta=theta, dim=dim, in_qubits=in_qubits, in_ctrl_qubits=in_ctrl_qubits, in_ctrl_values=in_ctrl_values, adjoint=adjoint, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ProbsOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.probs"

  _ODS_OPERAND_SEGMENTS = [1,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, probabilities, obs, *, dynamic_shape=None, state_in=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(obs)
    operands.append(dynamic_shape)
    operands.append(state_in)
    _ods_context = _ods_get_default_loc_context(loc)
    if probabilities is not None: results.append(probabilities)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def obs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def dynamic_shape(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def state_in(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def probabilities(self):
    return None if len(self.operation.results) < 1 else self.operation.results[0]

def probs(probabilities, obs, *, dynamic_shape=None, state_in=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ProbsOp(probabilities=probabilities, obs=obs, dynamic_shape=dynamic_shape, state_in=state_in, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class QubitUnitaryOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.unitary"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,-1,]

  _ODS_RESULT_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, out_qubits, out_ctrl_qubits, matrix, in_qubits, in_ctrl_qubits, in_ctrl_values, *, adjoint=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(matrix)
    operands.append(_get_op_results_or_values(in_qubits))
    operands.append(_get_op_results_or_values(in_ctrl_qubits))
    operands.append(_get_op_results_or_values(in_ctrl_values))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(adjoint): attributes["adjoint"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(out_qubits)
    results.append(out_ctrl_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def matrix(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def in_qubits(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def in_ctrl_qubits(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def in_ctrl_values(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def adjoint(self):
    return "adjoint" in self.operation.attributes

  @adjoint.setter
  def adjoint(self, value):
    if bool(value):
      self.operation.attributes["adjoint"] = _ods_ir.UnitAttr.get()
    elif "adjoint" in self.operation.attributes:
      del self.operation.attributes["adjoint"]

  @adjoint.deleter
  def adjoint(self):
    del self.operation.attributes["adjoint"]

  @builtins.property
  def out_qubits(self):
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 0)
    return result_range

  @builtins.property
  def out_ctrl_qubits(self):
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 1)
    return result_range

def unitary(out_qubits, out_ctrl_qubits, matrix, in_qubits, in_ctrl_qubits, in_ctrl_values, *, adjoint=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(QubitUnitaryOp(out_qubits=out_qubits, out_ctrl_qubits=out_ctrl_qubits, matrix=matrix, in_qubits=in_qubits, in_ctrl_qubits=in_ctrl_qubits, in_ctrl_values=in_ctrl_values, adjoint=adjoint, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SampleOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.sample"

  _ODS_OPERAND_SEGMENTS = [1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, samples, obs, dynamic_shape, *, in_data=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(obs)
    operands.append(_get_op_results_or_values(dynamic_shape))
    operands.append(in_data)
    _ods_context = _ods_get_default_loc_context(loc)
    if samples is not None: results.append(samples)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def obs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def dynamic_shape(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def in_data(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def samples(self):
    return None if len(self.operation.results) < 1 else self.operation.results[0]

def sample(samples, obs, dynamic_shape, *, in_data=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SampleOp(samples=samples, obs=obs, dynamic_shape=dynamic_shape, in_data=in_data, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SetBasisStateOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.set_basis_state"

  _ODS_REGIONS = (0, True)

  def __init__(self, out_qubits, basis_state, in_qubits, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(basis_state)
    operands.extend(_get_op_results_or_values(in_qubits))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(out_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def basis_state(self):
    return self.operation.operands[0]

  @builtins.property
  def in_qubits(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def out_qubits(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def set_basis_state(out_qubits, basis_state, in_qubits, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SetBasisStateOp(out_qubits=out_qubits, basis_state=basis_state, in_qubits=in_qubits, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SetStateOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.set_state"

  _ODS_REGIONS = (0, True)

  def __init__(self, out_qubits, in_state, in_qubits, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(in_state)
    operands.extend(_get_op_results_or_values(in_qubits))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(out_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def in_state(self):
    return self.operation.operands[0]

  @builtins.property
  def in_qubits(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def out_qubits(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def set_state(out_qubits, in_state, in_qubits, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(SetStateOp(out_qubits=out_qubits, in_state=in_state, in_qubits=in_qubits, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class StateOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.state"

  _ODS_OPERAND_SEGMENTS = [1,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, state, obs, *, dynamic_shape=None, state_in=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(obs)
    operands.append(dynamic_shape)
    operands.append(state_in)
    _ods_context = _ods_get_default_loc_context(loc)
    if state is not None: results.append(state)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def obs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def dynamic_shape(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def state_in(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def state(self):
    return None if len(self.operation.results) < 1 else self.operation.results[0]

def state(state, obs, *, dynamic_shape=None, state_in=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(StateOp(state=state, obs=obs, dynamic_shape=dynamic_shape, state_in=state_in, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TensorOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, obs, terms, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(terms))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(obs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def terms(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def obs(self):
    return self.operation.results[0]

def tensor(obs, terms, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorOp(obs=obs, terms=terms, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class VarianceOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.var"

  _ODS_REGIONS = (0, True)

  def __init__(self, variance, obs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(obs)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(variance)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def obs(self):
    return self.operation.operands[0]

  @builtins.property
  def variance(self):
    return self.operation.results[0]

def var(variance, obs, *, loc=None, ip=None) -> _ods_ir.Value:
  return VarianceOp(variance=variance, obs=obs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, retvals, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(retvals))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def retvals(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def yield_(retvals, *, loc=None, ip=None) -> _ods_ir.Operation:
  return YieldOp(retvals=retvals, loc=loc, ip=ip)
