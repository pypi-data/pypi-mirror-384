from collections.abc import Sequence
from pathlib import Path
from types import TracebackType
from typing import Any, Literal, Protocol, Self, overload

from storix.typing import StrPathLike


class Storage(Protocol):
    """Protocol for storage provider interface."""

    @property
    def root(self) -> Path: ...
    @property
    def home(self) -> Path: ...

    def chroot(self, new_root: StrPathLike) -> Self: ...
    def touch(self, path: StrPathLike | None, data: Any | None = None) -> bool: ...
    def cat(self, path: StrPathLike) -> bytes: ...
    def cd(self, path: StrPathLike | None = None) -> Self: ...
    def pwd(self) -> Path: ...
    def mkdir(self, path: StrPathLike, *, parents: bool = False) -> None: ...
    def mv(self, source: StrPathLike, destination: StrPathLike) -> None: ...
    def cp(self, source: StrPathLike, destination: StrPathLike) -> None: ...
    def rm(self, path: StrPathLike) -> bool: ...
    def rmdir(self, path: StrPathLike, recursive: bool = False) -> bool: ...
    @overload
    def ls(
        self,
        path: StrPathLike | None = None,
        *,
        abs: Literal[False] = False,
        all: bool = True,
    ) -> list[str]: ...
    @overload
    def ls(
        self, path: StrPathLike | None = None, *, abs: Literal[True], all: bool = True
    ) -> list[Path]: ...
    def ls(
        self, path: StrPathLike | None = None, *, abs: bool = False, all: bool = True
    ) -> Sequence[Path | str]: ...
    def tree(
        self, path: StrPathLike | None = None, *, abs: bool = False
    ) -> list[Path]: ...
    # TODO(@mghali): bind stat and du return type to Node or Tree for du
    # the bound generic to TreeNode or Tree would cause circular import error...?
    def stat(self, path: StrPathLike) -> Any: ...
    def du(
        self, path: StrPathLike | None = None, *, human_readable: bool = True
    ) -> Any: ...

    # non unix commands but useful utils
    def exists(self, path: StrPathLike) -> bool: ...
    def isdir(self, path: StrPathLike) -> bool: ...
    def isfile(self, path: StrPathLike) -> bool: ...
    def make_url(
        self,
        path: StrPathLike,
        *,
        astype: Literal["data_url"] = "data_url",
    ) -> str: ...
    def make_data_url(self, path: StrPathLike) -> str: ...
    def parent(self, path: StrPathLike) -> Path: ...
    def parents(self, path: StrPathLike) -> Sequence[Path]: ...
    def empty(self, path: StrPathLike) -> bool: ...
    def is_root(self, path: StrPathLike) -> bool: ...

    def open(self) -> Self: ...
    def close(self) -> None: ...

    def __enter__(self) -> Self:
        return self.open()

    def __exit__(
        self,
        exc_type: type[BaseException],
        exc_value: BaseException,
        traceback: TracebackType,
    ) -> None:
        self.close()
