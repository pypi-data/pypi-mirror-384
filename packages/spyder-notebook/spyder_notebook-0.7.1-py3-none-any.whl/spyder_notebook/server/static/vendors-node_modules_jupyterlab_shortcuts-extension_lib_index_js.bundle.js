"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["vendors-node_modules_jupyterlab_shortcuts-extension_lib_index_js"],{

/***/ "../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutInput.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutInput.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONFLICT_CONTAINER_CLASS: () => (/* binding */ CONFLICT_CONTAINER_CLASS),\n/* harmony export */   ShortcutInput: () => (/* binding */ ShortcutInput)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/coreutils */ \"webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lumino_keyboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/keyboard */ \"webpack/sharing/consume/default/@lumino/keyboard/@lumino/keyboard\");\n/* harmony import */ var _lumino_keyboard__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_keyboard__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/ui-components */ \"webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components\");\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_3__);\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\n\n\n\nconst CONFLICT_CONTAINER_CLASS = 'jp-Shortcuts-ConflictContainer';\nclass ShortcutInput extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props) {\n        super(props);\n        this.handleSubmit = async () => {\n            if (!this._isReplacingExistingKeybinding) {\n                await this._updateShortcut();\n                this.props.toggleInput();\n            }\n            else {\n                /** don't replace if field has not been edited */\n                if (this.state.selected) {\n                    this.props.toggleInput();\n                }\n                else {\n                    await this._updateShortcut();\n                }\n            }\n        };\n        this._updateShortcut = async () => {\n            const keys = [...this.state.keys, this.state.currentChain];\n            this.setState({ keys });\n            if (this.props.keybinding) {\n                await this.props.replaceKeybinding(this.props.shortcut, this.props.keybinding, keys);\n            }\n            else {\n                await this.props.addKeybinding(this.props.shortcut, keys);\n            }\n        };\n        this._handleOverwrite = async (conflicts, keys) => {\n            for (const conflict of conflicts) {\n                const conflictingBinding = conflict.keybindings.filter(binding => _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.deepEqual(binding.keys, keys) ||\n                    keys.some(key => _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.deepEqual(binding.keys, [key])))[0];\n                if (!conflictingBinding) {\n                    console.error(`Conflicting binding could not be found for ${conflict} using keys ${keys}`);\n                    continue;\n                }\n                await this.props.deleteKeybinding(conflict, conflictingBinding);\n            }\n            await this._updateShortcut();\n        };\n        /** Parse user input for chained shortcuts */\n        this.parseChaining = (event, value, userInput, keys, currentChain) => {\n            let key = _lumino_keyboard__WEBPACK_IMPORTED_MODULE_2__.EN_US.keyForKeydownEvent(event.nativeEvent);\n            const modKeys = ['Shift', 'Control', 'Alt', 'Meta', 'Ctrl', 'Accel'];\n            if (event.key === 'Backspace') {\n                userInput = '';\n                value = '';\n                keys = [];\n                currentChain = '';\n                this.setState({\n                    value: value,\n                    userInput: userInput,\n                    keys: keys,\n                    currentChain: currentChain\n                });\n            }\n            else if (event.key !== 'CapsLock') {\n                const lastKey = userInput\n                    .substr(userInput.lastIndexOf(' ') + 1, userInput.length)\n                    .trim();\n                /** if last key was not a modifier then there is a chain */\n                if (modKeys.lastIndexOf(lastKey) === -1 && lastKey != '') {\n                    userInput = userInput + ',';\n                    keys.push(currentChain);\n                    currentChain = '';\n                    /** check if a modifier key was held down through chain */\n                    if (event.ctrlKey && event.key != 'Control') {\n                        userInput = (userInput + ' Ctrl').trim();\n                        currentChain = (currentChain + ' Ctrl').trim();\n                    }\n                    if (event.metaKey && event.key != 'Meta') {\n                        userInput = (userInput + ' Accel').trim();\n                        currentChain = (currentChain + ' Accel').trim();\n                    }\n                    if (event.altKey && event.key != 'Alt') {\n                        userInput = (userInput + ' Alt').trim();\n                        currentChain = (currentChain + ' Alt').trim();\n                    }\n                    if (event.shiftKey && event.key != 'Shift') {\n                        userInput = (userInput + ' Shift').trim();\n                        currentChain = (currentChain + ' Shift').trim();\n                    }\n                    /** if not a modifier key, add to user input and current chain */\n                    if (modKeys.lastIndexOf(event.key) === -1) {\n                        userInput = (userInput + ' ' + key).trim();\n                        currentChain = (currentChain + ' ' + key).trim();\n                        /** if a modifier key, add to user input and current chain */\n                    }\n                    else {\n                        if (event.key === 'Meta') {\n                            userInput = (userInput + ' Accel').trim();\n                            currentChain = (currentChain + ' Accel').trim();\n                        }\n                        else if (event.key === 'Control') {\n                            userInput = (userInput + ' Ctrl').trim();\n                            currentChain = (currentChain + ' Ctrl').trim();\n                        }\n                        else if (event.key === 'Shift') {\n                            userInput = (userInput + ' Shift').trim();\n                            currentChain = (currentChain + ' Shift').trim();\n                        }\n                        else if (event.key === 'Alt') {\n                            userInput = (userInput + ' Alt').trim();\n                            currentChain = (currentChain + ' Alt').trim();\n                        }\n                        else {\n                            userInput = (userInput + ' ' + event.key).trim();\n                            currentChain = (currentChain + ' ' + event.key).trim();\n                        }\n                    }\n                    /** if not a chain, add the key to user input and current chain */\n                }\n                else {\n                    /** if modifier key, rename */\n                    if (event.key === 'Control') {\n                        userInput = (userInput + ' Ctrl').trim();\n                        currentChain = (currentChain + ' Ctrl').trim();\n                    }\n                    else if (event.key === 'Meta') {\n                        userInput = (userInput + ' Accel').trim();\n                        currentChain = (currentChain + ' Accel').trim();\n                    }\n                    else if (event.key === 'Shift') {\n                        userInput = (userInput + ' Shift').trim();\n                        currentChain = (currentChain + ' Shift').trim();\n                    }\n                    else if (event.key === 'Alt') {\n                        userInput = (userInput + ' Alt').trim();\n                        currentChain = (currentChain + ' Alt').trim();\n                        /** if not a modifier key, add it regularly */\n                    }\n                    else {\n                        userInput = (userInput + ' ' + key).trim();\n                        currentChain = (currentChain + ' ' + key).trim();\n                    }\n                }\n            }\n            /** update state of keys and currentChain */\n            this.setState({\n                keys: keys,\n                currentChain: currentChain\n            });\n            return [userInput, keys, currentChain];\n        };\n        /**\n         * Check if shortcut being typed will work\n         * (does not end with ctrl, alt, command, or shift)\n         * */\n        this.checkNonFunctional = () => {\n            const dontEnd = ['Ctrl', 'Alt', 'Accel', 'Shift'];\n            const shortcutKeys = this.state.currentChain.split(' ');\n            const last = shortcutKeys[shortcutKeys.length - 1];\n            this.setState({\n                isFunctional: !(dontEnd.indexOf(last) !== -1)\n            });\n            return dontEnd.indexOf(last) !== -1;\n        };\n        /** Check if shortcut being typed is already taken */\n        this.checkShortcutAvailability = (userInput, keys, currentChain) => {\n            const conflicts = this.props.findConflictsFor([...keys, currentChain], this.props.shortcut.selector);\n            const isAvailable = userInput === '' || conflicts.length === 0;\n            // Allow to set shortcut to what it initially was if replacing.\n            if (!isAvailable) {\n                // TODO: should we keep this logic? It masks what may be a genuine\n                // conflict in the defaults or between extensions; ideally we would\n                // allow saving, but still warn the user.\n                if (conflicts.length === 1 &&\n                    conflicts[0].id === this.props.shortcut.id &&\n                    this._isReplacingExistingKeybinding) {\n                    this.setState({ isAvailable: true });\n                    return [];\n                }\n            }\n            this.setState({ isAvailable: isAvailable });\n            return conflicts;\n        };\n        /** Parse and normalize user input */\n        this.handleInput = (event) => {\n            event.preventDefault();\n            this.setState({ selected: false });\n            const parsed = this.parseChaining(event, this.state.value, this.state.userInput, this.state.keys, this.state.currentChain);\n            const userInput = parsed[0];\n            const keys = parsed[1];\n            const currentChain = parsed[2];\n            const value = this.props.toSymbols(userInput);\n            let conflicts = this.checkShortcutAvailability(userInput, keys, currentChain);\n            this.setState({\n                value: value,\n                userInput: userInput,\n                keys: keys,\n                currentChain: currentChain\n            }, () => {\n                this.checkNonFunctional();\n                this._emitConflicts(conflicts);\n            });\n        };\n        this._handleBlur = (event) => {\n            var _a, _b;\n            if ((_a = this._ref.current) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget)) {\n                // Do not hide when clicking inside the input\n                return;\n            }\n            if ((_b = event.relatedTarget) === null || _b === void 0 ? void 0 : _b.closest(`.${CONFLICT_CONTAINER_CLASS}`)) {\n                // Do not hide input when clicking on conflict container as this would destroy the state\n                return;\n            }\n            // Hide the input\n            this.props.toggleInput();\n        };\n        this._ref = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        this.state = {\n            value: this.props.placeholder,\n            userInput: '',\n            isAvailable: true,\n            isFunctional: this._isReplacingExistingKeybinding,\n            keys: [],\n            currentChain: '',\n            selected: true\n        };\n    }\n    /** Whether this input replaces existing keybinding or creates a new one */\n    get _isReplacingExistingKeybinding() {\n        return !!this.props.keybinding;\n    }\n    _emitConflicts(conflicts) {\n        const keys = [...this.state.keys, this.state.currentChain];\n        this.props.displayConflicts({\n            conflictsWith: conflicts,\n            keys: this.state.keys,\n            overwrite: async () => {\n                this.setState({\n                    // Since user decided to overwrite, no need to show it as conflicted anymore\n                    isAvailable: true\n                });\n                // Try to overwrite\n                await this._handleOverwrite(conflicts, keys);\n                // Only hide the input after the overwrite took place\n                this.props.toggleInput();\n            },\n            cancel: () => {\n                // Hide the input\n                this.props.toggleInput();\n            }\n        });\n    }\n    render() {\n        const trans = this.props.translator.load('jupyterlab');\n        let inputClassName = 'jp-Shortcuts-Input';\n        if (!this.state.isAvailable) {\n            inputClassName += ' jp-mod-unavailable-Input';\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: this.props.displayInput\n                ? !this._isReplacingExistingKeybinding\n                    ? 'jp-Shortcuts-InputBox jp-Shortcuts-InputBoxNew'\n                    : 'jp-Shortcuts-InputBox'\n                : 'jp-mod-hidden', ref: this._ref, onBlur: this._handleBlur },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { tabIndex: 0, className: inputClassName, onKeyDown: this.handleInput, ref: input => input && input.focus(), \"data-lm-suppress-shortcuts\": \"true\" },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", { className: this.state.selected && this._isReplacingExistingKeybinding\n                        ? 'jp-Shortcuts-InputText jp-mod-selected-InputText'\n                        : this.state.value === ''\n                            ? 'jp-Shortcuts-InputText jp-mod-waiting-InputText'\n                            : 'jp-Shortcuts-InputText' }, this.state.value === ''\n                    ? trans.__('press keys')\n                    : this.state.value)),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { className: !this.state.isFunctional\n                    ? 'jp-Shortcuts-Submit jp-mod-defunc-Submit'\n                    : !this.state.isAvailable\n                        ? 'jp-Shortcuts-Submit jp-mod-conflict-Submit'\n                        : 'jp-Shortcuts-Submit', disabled: !this.state.isAvailable || !this.state.isFunctional, onClick: this.handleSubmit, tabIndex: 0 }, this.state.isAvailable ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_3__.checkIcon.react, null) : react__WEBPACK_IMPORTED_MODULE_0__.createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_3__.errorIcon.react, null))));\n    }\n}\n//# sourceMappingURL=ShortcutInput.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutInput.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutItem.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutItem.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShortcutItem: () => (/* binding */ ShortcutItem)\n/* harmony export */ });\n/* harmony import */ var _lumino_domutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/domutils */ \"webpack/sharing/consume/default/@lumino/domutils/@lumino/domutils\");\n/* harmony import */ var _lumino_domutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_domutils__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ShortcutInput__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShortcutInput */ \"../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutInput.js\");\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\n\n\n/** React component for each command shortcut item */\nclass ShortcutItem extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n    constructor(props) {\n        super(props);\n        /** Toggle display state of input box */\n        this.toggleInputNew = () => {\n            this.setState({\n                displayNewInput: !this.state.displayNewInput,\n                // reset conflicts\n                conflicts: new Map()\n            });\n        };\n        /** Transform special key names into unicode characters */\n        this.toSymbols = (value) => {\n            return value.split(' ').reduce((result, key) => {\n                if (key === 'Ctrl') {\n                    return (result + ' ⌃').trim();\n                }\n                else if (key === 'Alt') {\n                    return (result + ' ⌥').trim();\n                }\n                else if (key === 'Shift') {\n                    return (result + ' ⇧').trim();\n                }\n                else if (key === 'Accel' && _lumino_domutils__WEBPACK_IMPORTED_MODULE_0__.Platform.IS_MAC) {\n                    return (result + ' ⌘').trim();\n                }\n                else if (key === 'Accel') {\n                    return (result + ' ⌃').trim();\n                }\n                else {\n                    return (result + ' ' + key).trim();\n                }\n            }, '');\n        };\n        this._trans = this.props.external.translator.load('jupyterlab');\n        this.state = {\n            displayNewInput: false,\n            displayReplaceInput: Object.freeze({}),\n            conflicts: new Map()\n        };\n    }\n    componentDidMount() {\n        this.props.external.actionRequested.connect(this._onActionRequested, this);\n    }\n    componentWillUnmount() {\n        this.props.external.actionRequested.disconnect(this._onActionRequested, this);\n    }\n    async _onActionRequested(_, action) {\n        if ('shortcutId' in action &&\n            action.shortcutId !== this.props.shortcut.id) {\n            return;\n        }\n        if (action.request === 'add-keybinding') {\n            return this.toggleInputNew();\n        }\n        if (action.request === 'edit-keybinding') {\n            this.toggleInputReplaceMethod(action.keybinding);\n        }\n        if (action.request === 'delete-keybinding') {\n            const target = this.props.shortcut;\n            const binding = target.keybindings[action.keybinding];\n            this.props.deleteKeybinding(target, binding).catch(console.error);\n        }\n    }\n    getCategoryCell() {\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Cell\" }, this.props.shortcut.category));\n    }\n    getLabelCell() {\n        var _a;\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Cell\" },\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-label\" }, (_a = this.props.shortcut.label) !== null && _a !== void 0 ? _a : this._trans.__('(Command label missing)'))));\n    }\n    getResetShortCutLink() {\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"a\", { className: \"jp-Shortcuts-Reset\", onClick: () => this.props.resetKeybindings(this.props.shortcut) }, this._trans.__('Reset')));\n    }\n    getSourceCell() {\n        const allDefault = this.props.shortcut.keybindings.every(binding => binding.isDefault);\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Cell\" },\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-SourceCell\" }, allDefault ? this._trans.__('Default') : this._trans.__('Custom')),\n            !allDefault ? this.getResetShortCutLink() : ''));\n    }\n    getOptionalSelectorCell() {\n        return this.props.showSelectors ? (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Cell\" },\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-selector\" }, this.props.shortcut.selector))) : null;\n    }\n    getClassNameForShortCuts(nonEmptyBindings) {\n        const classes = ['jp-Shortcuts-ShortcutCell'];\n        switch (nonEmptyBindings.length) {\n            case 1:\n                classes.push('jp-Shortcuts-SingleCell');\n                break;\n            case 0:\n                classes.push('jp-Shortcuts-EmptyCell');\n                break;\n        }\n        return classes.join(' ');\n    }\n    toggleInputReplaceMethod(location) {\n        const previous = this.state.displayReplaceInput[location];\n        this.setState({\n            displayReplaceInput: {\n                ...this.state.displayReplaceInput,\n                [location]: !previous\n            },\n            // Clear old conflicts\n            conflicts: new Map()\n        });\n    }\n    getDisplayReplaceInput(location) {\n        return this.state.displayReplaceInput[location];\n    }\n    getOrDiplayIfNeeded(force) {\n        const classes = ['jp-Shortcuts-Or'];\n        if (force || this.state.displayNewInput) {\n            classes.push('jp-Shortcuts-Or-Forced');\n        }\n        return react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: classes.join(' ') }, this._trans.__('or'));\n    }\n    getShortCutAsInput(binding, location) {\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(_ShortcutInput__WEBPACK_IMPORTED_MODULE_2__.ShortcutInput, { addKeybinding: this.props.addKeybinding, replaceKeybinding: this.props.replaceKeybinding, deleteKeybinding: this.props.deleteKeybinding, findConflictsFor: this.props.findConflictsFor, toggleInput: () => this.toggleInputReplaceMethod(location), shortcut: this.props.shortcut, keybinding: binding, displayConflicts: (data) => {\n                const conflicts = new Map(this.state.conflicts);\n                conflicts.set(binding, data);\n                this.setState({ conflicts });\n            }, toSymbols: this.toSymbols, displayInput: this.getDisplayReplaceInput(location), placeholder: this.toSymbols(binding.keys.join(', ')), translator: this.props.external.translator }));\n    }\n    getShortCutForDisplayOnly(binding) {\n        return binding.keys.map((keyboardKey, index) => (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-ShortcutKeysContainer\", key: index },\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-ShortcutKeys\" }, this.toSymbols(keyboardKey)),\n            index + 1 < binding.keys.length ? (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Comma\" }, \",\")) : null)));\n    }\n    isLocationBeingEdited(location) {\n        return this.state.displayReplaceInput[location];\n    }\n    getDivForKey(index, binding, nonEmptyBindings) {\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-ShortcutContainer\", key: this.props.shortcut.id + '_' + index, \"data-keybinding\": index, \"data-shortcut\": this.props.shortcut.id, onClick: () => this.toggleInputReplaceMethod(index) },\n            this.isLocationBeingEdited(index)\n                ? this.getShortCutAsInput(binding, index)\n                : this.getShortCutForDisplayOnly(binding),\n            !(index === this._nonEmptyBindings.length - 1 &&\n                Object.values(this.state.displayReplaceInput).some(Boolean)) &&\n                this.getOrDiplayIfNeeded(index < this._nonEmptyBindings.length - 1)));\n    }\n    getAddLink() {\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"a\", { className: !this.state.displayNewInput ? 'jp-Shortcuts-Plus' : '', onClick: () => {\n                this.toggleInputNew();\n            } }, this._trans.__('Add')));\n    }\n    getInputBoxWhenToggled() {\n        return this.state.displayNewInput ? (react__WEBPACK_IMPORTED_MODULE_1__.createElement(_ShortcutInput__WEBPACK_IMPORTED_MODULE_2__.ShortcutInput, { addKeybinding: this.props.addKeybinding, replaceKeybinding: this.props.replaceKeybinding, deleteKeybinding: this.props.deleteKeybinding, findConflictsFor: this.props.findConflictsFor, toggleInput: this.toggleInputNew, shortcut: this.props.shortcut, displayConflicts: (data) => {\n                const conflicts = new Map(this.state.conflicts);\n                conflicts.set(null, data);\n                this.setState({ conflicts });\n            }, toSymbols: this.toSymbols, displayInput: this.state.displayNewInput, placeholder: '', translator: this.props.external.translator })) : (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", null));\n    }\n    getShortCutsCell(nonEmptyBindings) {\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Cell\" },\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: this.getClassNameForShortCuts(nonEmptyBindings) },\n                nonEmptyBindings.map((key, index) => this.getDivForKey(index, key, nonEmptyBindings)),\n                nonEmptyBindings.length >= 1 &&\n                    !this.state.displayNewInput &&\n                    !Object.values(this.state.displayReplaceInput).some(Boolean) &&\n                    this.getAddLink(),\n                nonEmptyBindings.length === 0 &&\n                    !this.state.displayNewInput &&\n                    this.getAddLink(),\n                this.getInputBoxWhenToggled())));\n    }\n    getConflicts() {\n        const conflicts = [...this.state.conflicts.values()].filter(conflict => conflict.conflictsWith.length !== 0);\n        if (conflicts.length === 0) {\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null);\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Row jp-Shortcuts-RowWithConflict\" },\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: _ShortcutInput__WEBPACK_IMPORTED_MODULE_2__.CONFLICT_CONTAINER_CLASS }, conflicts.map(conflict => {\n                const key = conflict.keys.join(' ') +\n                    '_' +\n                    conflict.conflictsWith.map(target => target.id).join('');\n                return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Conflict\", key: key },\n                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-ErrorMessage\" }, this._trans.__('Shortcut already in use by %1. Overwrite it?', conflict.conflictsWith\n                        .map(target => { var _a; return (_a = target.label) !== null && _a !== void 0 ? _a : target.command; })\n                        .join(', '))),\n                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-ErrorButton\" },\n                        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"button\", { className: \"jp-Button jp-mod-reject jp-mod-styled\", onClick: () => {\n                                this._clearConflict(conflict);\n                                conflict.cancel();\n                            } }, this._trans.__('Cancel')),\n                        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"button\", { className: \"jp-Button jp-mod-warn jp-mod-styled\", onClick: () => {\n                                // Clear the conflict first to prevent user from accidentally clicking this button twice\n                                this._clearConflict(conflict);\n                                conflict.overwrite();\n                            } }, this._trans.__('Overwrite')))));\n            }))));\n    }\n    /**\n     * Mark conflict as resolved.\n     */\n    _clearConflict(conflictToClear) {\n        const conflicts = new Map();\n        const idToSkip = this._conflictId(conflictToClear);\n        for (const [binding, conflict] of this.state.conflicts.entries()) {\n            if (this._conflictId(conflict) !== idToSkip) {\n                conflicts.set(binding, conflict);\n            }\n        }\n        this.setState({ conflicts });\n    }\n    /**\n     * Create a unique conflict identifier.\n     */\n    _conflictId(conflict) {\n        return (conflict.keys.join(' ') +\n            '_' +\n            conflict.conflictsWith.map(target => target.id).join(''));\n    }\n    get _nonEmptyBindings() {\n        return this.props.shortcut.keybindings.filter(binding => binding.keys.filter(k => k != '').length !== 0);\n    }\n    render() {\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null,\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Row\", \"data-shortcut\": this.props.shortcut.id },\n                this.getCategoryCell(),\n                this.getLabelCell(),\n                this.getShortCutsCell(this._nonEmptyBindings),\n                this.getSourceCell(),\n                this.getOptionalSelectorCell()),\n            this.getConflicts()));\n    }\n}\n//# sourceMappingURL=ShortcutItem.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutItem.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutList.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutList.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShortcutList: () => (/* binding */ ShortcutList)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ShortcutItem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ShortcutItem */ \"../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutItem.js\");\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\n\nconst TOPNAV_HEIGHT = 115;\n/** React component for list of shortcuts */\nclass ShortcutList extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    render() {\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"jp-Shortcuts-ShortcutListContainer\", style: {\n                height: `${this.props.height - TOPNAV_HEIGHT}px`\n            }, id: \"shortcutListContainer\" },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"jp-Shortcuts-ShortcutList\" }, this.props.shortcuts.map((shortcut) => {\n                return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_ShortcutItem__WEBPACK_IMPORTED_MODULE_1__.ShortcutItem, { key: shortcut.id, addKeybinding: this.props.addKeybinding, replaceKeybinding: this.props.replaceKeybinding, deleteKeybinding: this.props.deleteKeybinding, resetKeybindings: this.props.resetKeybindings, findConflictsFor: this.props.findConflictsFor, shortcut: shortcut, showSelectors: this.props.showSelectors, external: this.props.external }));\n            }))));\n    }\n}\n//# sourceMappingURL=ShortcutList.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutList.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutTitleItem.js":
/*!*******************************************************************************************!*\
  !*** ../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutTitleItem.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShortcutTitleItem: () => (/* binding */ ShortcutTitleItem)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/ui-components */ \"webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components\");\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\n\nclass ShortcutTitleItem extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n    render() {\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: this.props.title.toLowerCase() === this.props.active\n                ? 'jp-Shortcuts-Header jp-Shortcuts-CurrentHeader'\n                : 'jp-Shortcuts-Header', onClick: () => this.props.updateSort(this.props.columnId) },\n            this.props.title,\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__.caretDownEmptyThinIcon.react, { className: 'jp-Shortcuts-SortButton jp-ShortcutTitleItem-sortButton' })));\n    }\n}\n//# sourceMappingURL=ShortcutTitleItem.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutTitleItem.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutUI.js":
/*!************************************************************************************!*\
  !*** ../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutUI.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShortcutUI: () => (/* binding */ ShortcutUI)\n/* harmony export */ });\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/algorithm */ \"webpack/sharing/consume/default/@lumino/algorithm/@lumino/algorithm\");\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/coreutils */ \"webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ShortcutList__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ShortcutList */ \"../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutList.js\");\n/* harmony import */ var _TopNav__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TopNav */ \"../node_modules/@jupyterlab/shortcuts-extension/lib/components/TopNav.js\");\n/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../registry */ \"../node_modules/@jupyterlab/shortcuts-extension/lib/registry.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\n\n\n\n\n\n/** Normalize the query text for a fuzzy search. */\nfunction normalizeQuery(text) {\n    return text.replace(/\\s+/g, '').toLowerCase();\n}\n/** Perform a fuzzy search on a single command item. */\nfunction fuzzySearch(item, query) {\n    var _a;\n    // Create the source text to be searched.\n    const category = item.category.toLowerCase();\n    const label = ((_a = item['label']) !== null && _a !== void 0 ? _a : '').toLowerCase();\n    const source = `${category} ${label}`;\n    // Set up the match score and indices array.\n    let score = Infinity;\n    let indices = null;\n    // The regex for search word boundaries\n    const rgx = /\\b\\w/g;\n    // Search the source by word boundary.\n    // eslint-disable-next-line\n    while (true) {\n        // Find the next word boundary in the source.\n        const rgxMatch = rgx.exec(source);\n        // Break if there is no more source context.\n        if (!rgxMatch) {\n            break;\n        }\n        // Run the string match on the relevant substring.\n        const match = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.StringExt.matchSumOfDeltas(source, query, rgxMatch.index);\n        // Break if there is no match.\n        if (!match) {\n            break;\n        }\n        // Update the match if the score is better.\n        if (match && match.score <= score) {\n            score = match.score;\n            indices = match.indices;\n        }\n    }\n    // Bail if there was no match.\n    if (!indices || score === Infinity) {\n        return null;\n    }\n    // Compute the pivot index between category and label text.\n    const pivot = category.length + 1;\n    // Find the slice index to separate matched indices.\n    const j = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.lowerBound(indices, pivot, (a, b) => a - b);\n    // Extract the matched category and label indices.\n    const categoryIndices = indices.slice(0, j);\n    const labelIndices = indices.slice(j);\n    // Adjust the label indices for the pivot offset.\n    for (let i = 0, n = labelIndices.length; i < n; ++i) {\n        labelIndices[i] -= pivot;\n    }\n    // Handle a pure label match.\n    if (categoryIndices.length === 0) {\n        return {\n            matchType: 0 /* MatchType.Label */,\n            categoryIndices: null,\n            labelIndices,\n            score,\n            item\n        };\n    }\n    // Handle a pure category match.\n    if (labelIndices.length === 0) {\n        return {\n            matchType: 1 /* MatchType.Category */,\n            categoryIndices,\n            labelIndices: null,\n            score,\n            item\n        };\n    }\n    // Handle a split match.\n    return {\n        matchType: 2 /* MatchType.Split */,\n        categoryIndices,\n        labelIndices,\n        score,\n        item\n    };\n}\n/** Perform a fuzzy match on an array of command items. */\nfunction matchItems(items, query) {\n    // Normalize the query text to lower case with no whitespace.\n    query = normalizeQuery(query);\n    // Create the array to hold the scores.\n    let scores = [];\n    // Iterate over the items and match against the query.\n    for (const item of items.values()) {\n        // If the query is empty, all items are matched by default.\n        if (!query) {\n            scores.push({\n                matchType: 3 /* MatchType.Default */,\n                categoryIndices: null,\n                labelIndices: null,\n                score: 0,\n                item\n            });\n            continue;\n        }\n        // Run the fuzzy search for the item and query.\n        let score = fuzzySearch(item, query);\n        // Ignore the item if it is not a match.\n        if (!score) {\n            continue;\n        }\n        // Add the score to the results.\n        scores.push(score);\n    }\n    // Return the final array of scores.\n    return scores;\n}\n/** Top level React component for widget */\nclass ShortcutUI extends react__WEBPACK_IMPORTED_MODULE_2__.Component {\n    constructor(props) {\n        super(props);\n        /** Set the current search query */\n        this.updateSearchQuery = (query) => {\n            this.setState({\n                searchQuery: query\n            }, () => {\n                const registry = this.state.shortcutRegistry;\n                this.setState({\n                    filteredShortcutList: this._searchFilterShortcuts(registry)\n                }, () => {\n                    this.sortShortcuts();\n                });\n            });\n        };\n        /**\n         * Reset all keybindings to their defaults\n         */\n        this.resetShortcuts = async () => {\n            const settings = await this.props.external.getSettings();\n            await settings.set('shortcuts', []);\n            await this._refreshShortcutList();\n        };\n        /**\n         * Reset keybindings for given target to defaults.\n         */\n        this.resetKeybindings = async (target) => {\n            await this._setKeybinding(target, []);\n        };\n        /**\n         * Replace the given keybinding with a new keybinding as defined by given keys.\n         */\n        this.replaceKeybinding = async (target, keybinding, keys) => {\n            return this._setKeybinding(target, keys, keybinding);\n        };\n        /**\n         * Delete a single keybinding for given shortcut target.\n         */\n        this.deleteKeybinding = async (target, keybinding) => {\n            await this._setKeybinding(target, [], keybinding);\n        };\n        /**\n         * Add a new keybinding.\n         */\n        this.addKeybinding = async (target, keys) => {\n            await this._setKeybinding(target, keys);\n        };\n        /** Toggles showing command selectors */\n        this.toggleSelectors = () => {\n            this.setState({ showSelectors: !this.state.showSelectors });\n        };\n        /**\n         * Set the sort order for the shortcuts listing.\n         */\n        this.updateSort = (value) => {\n            if (value !== this.state.currentSort) {\n                this.setState({ currentSort: value }, this.sortShortcuts);\n            }\n        };\n        this.state = {\n            shortcutRegistry: null,\n            filteredShortcutList: new Array(),\n            shortcutsFetched: false,\n            searchQuery: '',\n            showSelectors: false,\n            currentSort: 'category'\n        };\n    }\n    /** Fetch shortcut list on mount */\n    componentDidMount() {\n        this.props.external.actionRequested.connect(this._onActionRequested, this);\n        void this._refreshShortcutList();\n    }\n    componentWillUnmount() {\n        this.props.external.actionRequested.disconnect(this._onActionRequested, this);\n    }\n    async _onActionRequested(_, action) {\n        if (action.request === 'toggle-selectors') {\n            return this.toggleSelectors();\n        }\n        if (action.request === 'reset-all') {\n            await this.resetShortcuts();\n        }\n    }\n    /** Fetch shortcut list from SettingRegistry  */\n    async _refreshShortcutList() {\n        const settings = await this.props.external.getSettings();\n        const shortcutRegistry = new _registry__WEBPACK_IMPORTED_MODULE_3__.ShortcutRegistry({\n            commandRegistry: this.props.external.commandRegistry,\n            settings\n        });\n        this.setState({\n            shortcutRegistry: shortcutRegistry,\n            filteredShortcutList: this._searchFilterShortcuts(shortcutRegistry),\n            shortcutsFetched: true\n        }, () => {\n            this.sortShortcuts();\n        });\n    }\n    /** Filter shortcut list using current search query */\n    _searchFilterShortcuts(registry) {\n        if (!registry) {\n            return [];\n        }\n        const filteredShortcuts = matchItems(registry, this.state.searchQuery).map((item) => {\n            return item.item;\n        });\n        return filteredShortcuts;\n    }\n    /**\n     * Replace the given keybinding with a new keybinding as defined by given keys.\n     *\n     * If keybinding is not given a new keybinding will be created.\n     * If keys are empty (or include a single empty string) the keybinding will be deleted.\n     * If keybinding is a default keybinding and the provided keys differ from default, it will be disabled.\n     */\n    async _setKeybinding(target, keys, keybinding) {\n        var _a, _b, _c, _d, _e;\n        if (keys.length === 1 && keys[0] == '') {\n            keys = [];\n        }\n        const settings = await this.props.external.getSettings();\n        const userShortcuts = (_a = settings.user.shortcuts) !== null && _a !== void 0 ? _a : [];\n        const newUserShortcuts = [];\n        let found = false;\n        // Copy over existing user keybindings\n        for (let shortcut of userShortcuts) {\n            // If this is the query keybinding, update it with new `keys`\n            if (shortcut.command === target.command &&\n                shortcut.selector === target.selector &&\n                _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.deepEqual((_b = shortcut.args) !== null && _b !== void 0 ? _b : {}, (_c = target.args) !== null && _c !== void 0 ? _c : {}) &&\n                keybinding &&\n                _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.deepEqual(keybinding.keys, shortcut.keys)) {\n                const matchesDefault = keybinding &&\n                    keybinding.isDefault &&\n                    _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.deepEqual(keybinding.keys, keys);\n                // If the new `keys` are empty, do not copy this one over.\n                // Also, if the keybinding is a default keybinding and the desired\n                // new `keys` are the same as default, it does not need to be added.\n                if (keys.length !== 0 && !matchesDefault) {\n                    newUserShortcuts.push({\n                        command: shortcut.command,\n                        selector: shortcut.selector,\n                        keys: keys\n                    });\n                }\n                found = true;\n            }\n            else if (shortcut.command === target.command &&\n                shortcut.selector === target.selector &&\n                _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.deepEqual((_d = shortcut.args) !== null && _d !== void 0 ? _d : {}, (_e = target.args) !== null && _e !== void 0 ? _e : {}) &&\n                !keybinding &&\n                keys.length === 0) {\n                continue;\n            }\n            else {\n                newUserShortcuts.push(shortcut);\n            }\n        }\n        if (!found) {\n            const requiresChange = !keybinding || !_lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.deepEqual(keybinding.keys, keys);\n            const shouldDisableDefault = keybinding && keybinding.isDefault && requiresChange;\n            if (shouldDisableDefault) {\n                // If the replaced keybinding is the default, disable it.\n                newUserShortcuts.push({\n                    command: target.command,\n                    selector: target.selector,\n                    disabled: true,\n                    keys: keybinding.keys\n                });\n            }\n            if (keys.length !== 0) {\n                newUserShortcuts.push({\n                    command: target.command,\n                    selector: target.selector,\n                    keys: keys\n                });\n            }\n        }\n        await settings.set('shortcuts', newUserShortcuts);\n        await this._refreshShortcutList();\n    }\n    /**\n     * Sort shortcut list using current sort property.\n     */\n    sortShortcuts() {\n        const shortcuts = this.state.filteredShortcutList;\n        let sortCriteria = this.state.currentSort;\n        if (sortCriteria === 'command') {\n            sortCriteria = 'label';\n        }\n        const getValue = (target) => {\n            var _a;\n            if (sortCriteria === 'source') {\n                return target.keybindings.every(k => k.isDefault) ? 'default' : 'other';\n            }\n            return (_a = target[sortCriteria]) !== null && _a !== void 0 ? _a : '';\n        };\n        shortcuts.sort((a, b) => {\n            var _a, _b;\n            const compareA = getValue(a);\n            const compareB = getValue(b);\n            const compareResult = compareA.localeCompare(compareB);\n            if (compareResult) {\n                return compareResult;\n            }\n            else {\n                const aLabel = (_a = a['label']) !== null && _a !== void 0 ? _a : '';\n                const bLabel = (_b = b['label']) !== null && _b !== void 0 ? _b : '';\n                return aLabel.localeCompare(bLabel);\n            }\n        });\n        this.setState({ filteredShortcutList: shortcuts });\n    }\n    render() {\n        if (!this.state.shortcutsFetched) {\n            return null;\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"div\", { className: \"jp-Shortcuts-ShortcutUI\", id: \"jp-shortcutui\" },\n            react__WEBPACK_IMPORTED_MODULE_2__.createElement(_TopNav__WEBPACK_IMPORTED_MODULE_4__.TopNav, { updateSearchQuery: this.updateSearchQuery, resetShortcuts: this.resetShortcuts, toggleSelectors: this.toggleSelectors, showSelectors: this.state.showSelectors, updateSort: this.updateSort, currentSort: this.state.currentSort, width: this.props.width, translator: this.props.external.translator }),\n            react__WEBPACK_IMPORTED_MODULE_2__.createElement(_ShortcutList__WEBPACK_IMPORTED_MODULE_5__.ShortcutList, { shortcuts: this.state.filteredShortcutList, resetKeybindings: this.resetKeybindings, addKeybinding: this.addKeybinding, replaceKeybinding: this.replaceKeybinding, deleteKeybinding: this.deleteKeybinding, showSelectors: this.state.showSelectors, findConflictsFor: (keys, selector) => {\n                    if (this.state.shortcutRegistry) {\n                        return this.state.shortcutRegistry.findConflictsFor(keys, selector);\n                    }\n                    else {\n                        console.error('Cannot search for keybinding conflicts at this time: registry is not ready');\n                        return [];\n                    }\n                }, height: this.props.height, external: this.props.external })));\n    }\n}\n//# sourceMappingURL=ShortcutUI.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutUI.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/shortcuts-extension/lib/components/TopNav.js":
/*!********************************************************************************!*\
  !*** ../node_modules/@jupyterlab/shortcuts-extension/lib/components/TopNav.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TopNav: () => (/* binding */ TopNav)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/ui-components */ \"webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components\");\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ShortcutTitleItem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShortcutTitleItem */ \"../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutTitleItem.js\");\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\n\n\nfunction Symbols(props) {\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Symbols\" },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"table\", null,\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"tbody\", null,\n                react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"tr\", null,\n                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"td\", null,\n                        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"kbd\", null, \"Cmd\")),\n                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"td\", null, \"\\u2318\"),\n                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"td\", null,\n                        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"kbd\", null, \"Ctrl\")),\n                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"td\", null, \"\\u2303\")),\n                react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"tr\", null,\n                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"td\", null,\n                        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"kbd\", null, \"Alt\")),\n                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"td\", null, \"\\u2325\"),\n                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"td\", null,\n                        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"kbd\", null, \"Shift\")),\n                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"td\", null, \"\\u21E7\"))))));\n}\nfunction AdvancedOptions(props) {\n    const trans = props.translator.load('jupyterlab');\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-AdvancedOptions\" },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"a\", { className: \"jp-Shortcuts-AdvancedOptionsLink\", onClick: () => props.toggleSelectors() }, props.showSelectors\n            ? trans.__('Hide Selectors')\n            : trans.__('Show Selectors')),\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"a\", { className: \"jp-Shortcuts-AdvancedOptionsLink\", onClick: () => props.resetShortcuts() }, trans.__('Reset All'))));\n}\n/** React component for top navigation */\nclass TopNav extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n    constructor(props) {\n        super(props);\n    }\n    getShortCutTitleItem(title, columnId) {\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Cell\" },\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(_ShortcutTitleItem__WEBPACK_IMPORTED_MODULE_2__.ShortcutTitleItem, { title: title, updateSort: this.props.updateSort, active: this.props.currentSort, columnId: columnId })));\n    }\n    render() {\n        const trans = this.props.translator.load('jupyterlab');\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Top\" },\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-TopNav\" },\n                react__WEBPACK_IMPORTED_MODULE_1__.createElement(Symbols, null),\n                react__WEBPACK_IMPORTED_MODULE_1__.createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__.FilterBox, { \"aria-label\": trans.__('Search shortcuts'), updateFilter: (_, query) => this.props.updateSearchQuery(query !== null && query !== void 0 ? query : ''), placeholder: trans.__('Search…'), useFuzzyFilter: false }),\n                react__WEBPACK_IMPORTED_MODULE_1__.createElement(AdvancedOptions, { toggleSelectors: this.props.toggleSelectors, showSelectors: this.props.showSelectors, resetShortcuts: this.props.resetShortcuts, translator: this.props.translator })),\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-HeaderRowContainer\" },\n                react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-HeaderRow\" },\n                    this.getShortCutTitleItem(trans.__('Category'), 'category'),\n                    this.getShortCutTitleItem(trans.__('Command'), 'command'),\n                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Cell\" },\n                        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"title-div\" }, trans.__('Shortcut'))),\n                    this.getShortCutTitleItem(trans.__('Source'), 'source'),\n                    this.props.showSelectors &&\n                        this.getShortCutTitleItem(trans.__('Selectors'), 'selector')))));\n    }\n}\n//# sourceMappingURL=TopNav.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/shortcuts-extension/lib/components/TopNav.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/shortcuts-extension/lib/index.js":
/*!********************************************************************!*\
  !*** ../node_modules/@jupyterlab/shortcuts-extension/lib/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/settingregistry */ \"webpack/sharing/consume/default/@jupyterlab/settingregistry/@jupyterlab/settingregistry\");\n/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/translation */ \"webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation\");\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/ui-components */ \"webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components\");\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _lumino_commands__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lumino/commands */ \"webpack/sharing/consume/default/@lumino/commands/@lumino/commands\");\n/* harmony import */ var _lumino_commands__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lumino_commands__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lumino/coreutils */ \"webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _lumino_disposable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lumino/disposable */ \"webpack/sharing/consume/default/@lumino/disposable/@lumino/disposable\");\n/* harmony import */ var _lumino_disposable__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_lumino_disposable__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _lumino_domutils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lumino/domutils */ \"webpack/sharing/consume/default/@lumino/domutils/@lumino/domutils\");\n/* harmony import */ var _lumino_domutils__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_lumino_domutils__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./types */ \"../node_modules/@jupyterlab/shortcuts-extension/lib/types.js\");\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./renderer */ \"../node_modules/@jupyterlab/shortcuts-extension/lib/renderer.js\");\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lumino/signaling */ \"webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling\");\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_7__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module shortcuts-extension\n */\n\n\n\n\n\n\n\n\n\n\nconst SHORTCUT_PLUGIN_ID = '@jupyterlab/shortcuts-extension:shortcuts';\nfunction getExternalForJupyterLab(settingRegistry, app, translator, actionRequested) {\n    return {\n        translator,\n        getSettings: () => settingRegistry.load(SHORTCUT_PLUGIN_ID, true),\n        commandRegistry: app.commands,\n        actionRequested\n    };\n}\n/**\n * The default shortcuts extension.\n *\n * #### Notes\n * Shortcut values are stored in the setting system. The default values for each\n * shortcut are preset in the settings schema file of this extension.\n * Additionally, each shortcut can be individually set by the end user by\n * modifying its setting (either in the text editor or by modifying its\n * underlying JSON schema file).\n *\n * When setting shortcut selectors, there are two concepts to consider:\n * specificity and matchability. These two interact in sometimes\n * counterintuitive ways. Keyboard events are triggered from an element and\n * they propagate up the DOM until they reach the `documentElement` (`<body>`).\n *\n * When a registered shortcut sequence is fired, the shortcut manager checks\n * the node that fired the event and each of its ancestors until a node matches\n * one or more registered selectors. The *first* matching selector in the\n * chain of ancestors will invoke the shortcut handler and the traversal will\n * end at that point. If a node matches more than one selector, the handler for\n * whichever selector is more *specific* fires.\n * @see https://www.w3.org/TR/css3-selectors/#specificity\n *\n * The practical consequence of this is that a very broadly matching selector,\n * e.g. `'*'` or `'div'` may match and therefore invoke a handler *before* a\n * more specific selector. The most common pitfall is to use the universal\n * (`'*'`) selector. For almost any use case where a global keyboard shortcut is\n * required, using the `'body'` selector is more appropriate.\n */\nconst shortcuts = {\n    id: SHORTCUT_PLUGIN_ID,\n    description: 'Adds the keyboard shortcuts editor.',\n    requires: [_jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_0__.ISettingRegistry],\n    optional: [_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.ITranslator, _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.IFormRendererRegistry],\n    activate: async (app, registry, translator, editorRegistry) => {\n        const translator_ = translator !== null && translator !== void 0 ? translator : _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator;\n        const trans = translator_.load('jupyterlab');\n        const { commands } = app;\n        let canonical;\n        // Stores initial value of the shortcuts `default` value,\n        // which reflects the `overrides.json` contents.\n        let cannonicalOverrides;\n        let loaded = {};\n        if (editorRegistry) {\n            const actionRequested = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_7__.Signal({});\n            const isKeybindingNode = (node) => node.dataset['shortcut'] !== undefined;\n            app.commands.addCommand(_types__WEBPACK_IMPORTED_MODULE_8__.CommandIDs.editBinding, {\n                label: trans.__('Edit Keybinding'),\n                caption: trans.__('Edit existing keybinding'),\n                execute: () => {\n                    const node = app.contextMenuHitTest(isKeybindingNode);\n                    const keybinding = node === null || node === void 0 ? void 0 : node.dataset['keybinding'];\n                    const shortcutId = node === null || node === void 0 ? void 0 : node.dataset['shortcut'];\n                    if (!shortcutId || !keybinding) {\n                        return console.log('Missing shortcut id/keybinding information');\n                    }\n                    actionRequested.emit({\n                        request: 'edit-keybinding',\n                        keybinding: parseInt(keybinding, 10),\n                        shortcutId\n                    });\n                }\n            });\n            app.commands.addCommand(_types__WEBPACK_IMPORTED_MODULE_8__.CommandIDs.deleteBinding, {\n                label: trans.__('Delete Keybinding'),\n                caption: trans.__('Delete chosen keybinding'),\n                execute: () => {\n                    const node = app.contextMenuHitTest(isKeybindingNode);\n                    const keybinding = node === null || node === void 0 ? void 0 : node.dataset['keybinding'];\n                    const shortcutId = node === null || node === void 0 ? void 0 : node.dataset['shortcut'];\n                    if (!shortcutId || !keybinding) {\n                        return console.log('Missing shortcut id/keybinding information');\n                    }\n                    actionRequested.emit({\n                        request: 'delete-keybinding',\n                        keybinding: parseInt(keybinding, 10),\n                        shortcutId\n                    });\n                }\n            });\n            app.commands.addCommand(_types__WEBPACK_IMPORTED_MODULE_8__.CommandIDs.addBinding, {\n                label: trans.__('Add Keybinding'),\n                caption: trans.__('Add new keybinding for existing shortcut target'),\n                execute: () => {\n                    const node = app.contextMenuHitTest(isKeybindingNode);\n                    const shortcutId = node === null || node === void 0 ? void 0 : node.dataset['shortcut'];\n                    if (!shortcutId) {\n                        return console.log('Missing shortcut id to add keybinding to');\n                    }\n                    actionRequested.emit({\n                        request: 'add-keybinding',\n                        shortcutId\n                    });\n                }\n            });\n            commands.addCommand(_types__WEBPACK_IMPORTED_MODULE_8__.CommandIDs.toggleSelectors, {\n                label: trans.__('Toggle Selectors'),\n                caption: trans.__('Toggle command selectors'),\n                execute: () => {\n                    actionRequested.emit({\n                        request: 'toggle-selectors'\n                    });\n                }\n            });\n            commands.addCommand(_types__WEBPACK_IMPORTED_MODULE_8__.CommandIDs.resetAll, {\n                label: trans.__('Reset All'),\n                caption: trans.__('Reset all shortcuts'),\n                execute: () => {\n                    actionRequested.emit({\n                        request: 'reset-all'\n                    });\n                }\n            });\n            const component = {\n                fieldRenderer: (props) => {\n                    return (0,_renderer__WEBPACK_IMPORTED_MODULE_9__.renderShortCut)({\n                        external: getExternalForJupyterLab(registry, app, translator_, actionRequested),\n                        ...props\n                    });\n                }\n            };\n            editorRegistry.addRenderer(`${shortcuts.id}.shortcuts`, component);\n        }\n        /**\n         * Populate the plugin's schema defaults.\n         */\n        function populate(schema) {\n            const commands = app.commands.listCommands().join('\\n');\n            if (!cannonicalOverrides) {\n                cannonicalOverrides = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__.JSONExt.deepCopy(schema.properties.shortcuts.default);\n            }\n            loaded = {};\n            schema.properties.shortcuts.default = Object.keys(registry.plugins)\n                .map(plugin => {\n                const shortcuts = registry.plugins[plugin].schema['jupyter.lab.shortcuts'] || [];\n                loaded[plugin] = shortcuts;\n                return shortcuts;\n            })\n                .concat([cannonicalOverrides])\n                .reduce((acc, val) => {\n                if (_lumino_domutils__WEBPACK_IMPORTED_MODULE_6__.Platform.IS_MAC) {\n                    return acc.concat(val);\n                }\n                else {\n                    // If platform is not MacOS, remove all shortcuts containing Cmd\n                    // as they will be modified; e.g. `Cmd A` becomes `A`\n                    return acc.concat(val.filter(shortcut => !shortcut.keys.some(key => {\n                        const { cmd } = _lumino_commands__WEBPACK_IMPORTED_MODULE_3__.CommandRegistry.parseKeystroke(key);\n                        return cmd;\n                    })));\n                }\n            }, []) // flatten one level\n                .sort((a, b) => a.command.localeCompare(b.command));\n            schema.properties.shortcuts.description = trans.__(`Note: To disable a system default shortcut,\ncopy it to User Preferences and add the\n\"disabled\" key, for example:\n{\n    \"command\": \"application:activate-next-tab\",\n    \"keys\": [\n        \"Ctrl Shift ]\"\n    ],\n    \"selector\": \"body\",\n    \"disabled\": true\n}\n\nList of commands followed by keyboard shortcuts:\n%1\n\nList of keyboard shortcuts:`, commands);\n        }\n        registry.pluginChanged.connect(async (_, plugin) => {\n            if (plugin !== shortcuts.id) {\n                // If the plugin changed its shortcuts, reload everything.\n                const oldShortcuts = loaded[plugin];\n                const newShortcuts = registry.plugins[plugin].schema['jupyter.lab.shortcuts'] || [];\n                if (oldShortcuts === undefined ||\n                    !_lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__.JSONExt.deepEqual(oldShortcuts, newShortcuts)) {\n                    // Empty the default values to avoid shortcut collisions.\n                    canonical = null;\n                    const schema = registry.plugins[shortcuts.id].schema;\n                    schema.properties.shortcuts.default = cannonicalOverrides;\n                    // Reload the settings.\n                    await registry.load(shortcuts.id, true);\n                }\n            }\n        });\n        // Transform the plugin object to return different schema than the default.\n        registry.transform(shortcuts.id, {\n            compose: plugin => {\n                var _a, _b, _c, _d;\n                // Only override the canonical schema the first time.\n                if (!canonical) {\n                    canonical = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__.JSONExt.deepCopy(plugin.schema);\n                    populate(canonical);\n                }\n                const defaults = (_c = (_b = (_a = canonical.properties) === null || _a === void 0 ? void 0 : _a.shortcuts) === null || _b === void 0 ? void 0 : _b.default) !== null && _c !== void 0 ? _c : [];\n                const user = {\n                    shortcuts: (_d = plugin.data.user.shortcuts) !== null && _d !== void 0 ? _d : []\n                };\n                const composite = {\n                    shortcuts: _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_0__.SettingRegistry.reconcileShortcuts(defaults, user.shortcuts)\n                };\n                plugin.data = { composite, user };\n                return plugin;\n            },\n            fetch: plugin => {\n                // Only override the canonical schema the first time.\n                if (!canonical) {\n                    canonical = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__.JSONExt.deepCopy(plugin.schema);\n                    populate(canonical);\n                }\n                return {\n                    data: plugin.data,\n                    id: plugin.id,\n                    raw: plugin.raw,\n                    schema: canonical,\n                    version: plugin.version\n                };\n            }\n        });\n        try {\n            // Repopulate the canonical variable after the setting registry has\n            // preloaded all initial plugins.\n            canonical = null;\n            const settings = await registry.load(shortcuts.id);\n            Private.loadShortcuts(commands, settings.composite);\n            settings.changed.connect(() => {\n                Private.loadShortcuts(commands, settings.composite);\n            });\n        }\n        catch (error) {\n            console.error(`Loading ${shortcuts.id} failed.`, error);\n        }\n    },\n    autoStart: true\n};\n/**\n * Export the shortcut plugin as default.\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (shortcuts);\n/**\n * A namespace for private module data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The internal collection of currently loaded shortcuts.\n     */\n    let disposables;\n    /**\n     * Load the keyboard shortcuts from settings.\n     */\n    function loadShortcuts(commands, composite) {\n        var _a;\n        const shortcuts = ((_a = composite === null || composite === void 0 ? void 0 : composite.shortcuts) !== null && _a !== void 0 ? _a : []);\n        if (disposables) {\n            disposables.dispose();\n        }\n        disposables = shortcuts.reduce((acc, val) => {\n            const options = normalizeOptions(val);\n            if (options) {\n                acc.add(commands.addKeyBinding(options));\n            }\n            return acc;\n        }, new _lumino_disposable__WEBPACK_IMPORTED_MODULE_5__.DisposableSet());\n    }\n    Private.loadShortcuts = loadShortcuts;\n    /**\n     * Normalize potential keyboard shortcut options.\n     */\n    function normalizeOptions(value) {\n        if (!value || typeof value !== 'object') {\n            return undefined;\n        }\n        const { isArray } = Array;\n        const valid = 'command' in value &&\n            'keys' in value &&\n            'selector' in value &&\n            isArray(value.keys);\n        return valid ? value : undefined;\n    }\n})(Private || (Private = {}));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/shortcuts-extension/lib/index.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/shortcuts-extension/lib/registry.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@jupyterlab/shortcuts-extension/lib/registry.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShortcutRegistry: () => (/* binding */ ShortcutRegistry)\n/* harmony export */ });\n/**\n * Shortcut registry used by Shortcut UI component.\n */\nclass ShortcutRegistry extends Map {\n    constructor(options) {\n        var _a, _b, _c;\n        super();\n        const { settings, commandRegistry } = options;\n        const userBindings = (_a = settings.user.shortcuts) !== null && _a !== void 0 ? _a : [];\n        const setByUser = new Set(userBindings.map(this._computeKeybindingId.bind(this)));\n        const luminoKeybindings = (_b = settings.composite.shortcuts) !== null && _b !== void 0 ? _b : [];\n        for (const shortcut of luminoKeybindings) {\n            const targetKey = this._computeTargetId(shortcut);\n            const keybindingKey = this._computeKeybindingId(shortcut);\n            const keybinding = {\n                keys: shortcut.keys,\n                isDefault: !setByUser.has(keybindingKey)\n            };\n            const shortcutTarget = this.get(targetKey);\n            if (shortcutTarget) {\n                shortcutTarget.keybindings.push(keybinding);\n            }\n            else {\n                const commandParts = shortcut.command.split(':');\n                const label = (_c = commandRegistry.label(shortcut.command, shortcut.args)) !== null && _c !== void 0 ? _c : (commandParts.length > 1 ? commandParts[1] : undefined);\n                const category = commandParts[0];\n                this.set(targetKey, {\n                    id: targetKey,\n                    selector: shortcut.selector,\n                    command: shortcut.command,\n                    category,\n                    label,\n                    args: shortcut.args,\n                    keybindings: [keybinding]\n                });\n            }\n        }\n    }\n    /**\n     * Find targets that would conflict with given keys chord under given sequence.\n     */\n    findConflictsFor(keys, selector) {\n        const checker = new KeybindingsConflictChecker({ registry: this });\n        // First check the full chain\n        let conflicts = checker.findConflicts(keys, selector);\n        if (conflicts.length !== 0) {\n            return conflicts;\n        }\n        // Then check each piece of the chain\n        for (const binding of keys) {\n            conflicts = checker.findConflicts([binding], selector);\n            if (conflicts.length !== 0) {\n                return conflicts;\n            }\n        }\n        return [];\n    }\n    _computeTargetId(shortcut) {\n        var _a;\n        return (shortcut.command +\n            '_' +\n            shortcut.selector +\n            '_' +\n            JSON.stringify((_a = shortcut.args) !== null && _a !== void 0 ? _a : {}));\n    }\n    _computeKeybindingId(shortcut) {\n        var _a;\n        return [\n            shortcut.command,\n            shortcut.selector,\n            JSON.stringify((_a = shortcut.args) !== null && _a !== void 0 ? _a : {}),\n            shortcut.keys.join(' ')\n        ].join('_');\n    }\n}\n/**\n * Allows checking if a given keybinding is available, or directly conflicts with other targets.\n */\nclass KeybindingsConflictChecker {\n    constructor(options) {\n        var _a;\n        const keybindingsMap = new Map();\n        for (const shortcutTarget of options.registry.values()) {\n            for (const keybinding of shortcutTarget.keybindings) {\n                const hash = this._keybindingHash(keybinding.keys, shortcutTarget.selector);\n                const list = (_a = keybindingsMap.get(hash)) !== null && _a !== void 0 ? _a : [];\n                list.push(shortcutTarget);\n                keybindingsMap.set(hash, list);\n            }\n        }\n        this._keybindingsMap = keybindingsMap;\n    }\n    findConflicts(keys, selector) {\n        var _a;\n        const hash = this._keybindingHash(keys, selector);\n        return (_a = this._keybindingsMap.get(hash)) !== null && _a !== void 0 ? _a : [];\n    }\n    _keybindingHash(keys, selector) {\n        return keys.join(' ') + '_' + selector;\n    }\n}\n//# sourceMappingURL=registry.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/shortcuts-extension/lib/registry.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/shortcuts-extension/lib/renderer.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@jupyterlab/shortcuts-extension/lib/renderer.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   renderShortCut: () => (/* binding */ renderShortCut)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components */ \"../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutUI.js\");\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\n\nconst renderShortCut = (props) => {\n    return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_components__WEBPACK_IMPORTED_MODULE_1__.ShortcutUI, { external: props.external, height: 1000, width: 1000 });\n};\n//# sourceMappingURL=renderer.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/shortcuts-extension/lib/renderer.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/shortcuts-extension/lib/types.js":
/*!********************************************************************!*\
  !*** ../node_modules/@jupyterlab/shortcuts-extension/lib/types.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommandIDs: () => (/* binding */ CommandIDs)\n/* harmony export */ });\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n/**\n * Identifiers of commands registered by shortcuts UI.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.editBinding = 'shortcuts:edit-keybinding';\n    CommandIDs.addBinding = 'shortcuts:add-keybinding';\n    CommandIDs.deleteBinding = 'shortcuts:delete-keybinding';\n    CommandIDs.toggleSelectors = 'shortcuts:toggle-selectors';\n    CommandIDs.resetAll = 'shortcuts:reset-all';\n})(CommandIDs || (CommandIDs = {}));\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/shortcuts-extension/lib/types.js?");

/***/ })

}]);