"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["vendors-node_modules_jupyterlab_documentsearch-extension_lib_index_js"],{

/***/ "../node_modules/@jupyterlab/documentsearch-extension/lib/index.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@jupyterlab/documentsearch-extension/lib/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/application */ \"webpack/sharing/consume/default/@jupyterlab/application/@jupyterlab/application\");\n/* harmony import */ var _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/apputils */ \"webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils\");\n/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/documentsearch */ \"webpack/sharing/consume/default/@jupyterlab/documentsearch/@jupyterlab/documentsearch\");\n/* harmony import */ var _jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/settingregistry */ \"webpack/sharing/consume/default/@jupyterlab/settingregistry/@jupyterlab/settingregistry\");\n/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jupyterlab/translation */ \"webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation\");\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lumino/widgets */ \"webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets\");\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_5__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module documentsearch-extension\n */\n\n\n\n\n\n\n/**\n * Class added to widgets that can be searched (have a search provider).\n */\nconst SEARCHABLE_CLASS = 'jp-mod-searchable';\n/**\n * Class added to widgets with open search view (not necessarily focused).\n */\nconst SEARCH_ACTIVE_CLASS = 'jp-mod-search-active';\nvar CommandIDs;\n(function (CommandIDs) {\n    /**\n     * Start search in a document\n     */\n    CommandIDs.search = 'documentsearch:start';\n    /**\n     * Start search and replace in a document\n     */\n    CommandIDs.searchAndReplace = 'documentsearch:startWithReplace';\n    /**\n     * Find next search match\n     */\n    CommandIDs.findNext = 'documentsearch:highlightNext';\n    /**\n     * Find previous search match\n     */\n    CommandIDs.findPrevious = 'documentsearch:highlightPrevious';\n    /**\n     * End search in a document\n     */\n    CommandIDs.end = 'documentsearch:end';\n    /**\n     * Toggle search in selection\n     */\n    CommandIDs.toggleSearchInSelection = 'documentsearch:toggleSearchInSelection';\n})(CommandIDs || (CommandIDs = {}));\nconst labShellWidgetListener = {\n    id: '@jupyterlab/documentsearch-extension:labShellWidgetListener',\n    description: 'Active search on valid document',\n    requires: [_jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.ILabShell, _jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_2__.ISearchProviderRegistry],\n    autoStart: true,\n    activate: (app, labShell, registry) => {\n        // If a given widget is searchable, apply the searchable class.\n        // If it's not searchable, remove the class.\n        const transformWidgetSearchability = (widget) => {\n            if (!widget) {\n                return;\n            }\n            if (registry.hasProvider(widget)) {\n                widget.addClass(SEARCHABLE_CLASS);\n            }\n            else {\n                widget.removeClass(SEARCHABLE_CLASS);\n            }\n        };\n        // Update searchability of the active widget when the registry\n        // changes, in case a provider for the current widget was added\n        // or removed\n        registry.changed.connect(() => transformWidgetSearchability(labShell.activeWidget));\n        // Apply the searchable class only to the active widget if it is actually\n        // searchable. Remove the searchable class from a widget when it's\n        // no longer active.\n        labShell.activeChanged.connect((_, args) => {\n            const oldWidget = args.oldValue;\n            if (oldWidget) {\n                oldWidget.removeClass(SEARCHABLE_CLASS);\n            }\n            transformWidgetSearchability(args.newValue);\n        });\n    }\n};\n/**\n * Exposes the current keybindings to search box view.\n */\nclass SearchKeyBindings {\n    constructor(_commandRegistry) {\n        this._commandRegistry = _commandRegistry;\n        this._cache = this._buildCache();\n        this._commandRegistry.keyBindingChanged.connect(this._rebuildCache, this);\n    }\n    get next() {\n        return this._cache.next;\n    }\n    get previous() {\n        return this._cache.previous;\n    }\n    get toggleSearchInSelection() {\n        return this._cache.toggleSearchInSelection;\n    }\n    _rebuildCache() {\n        this._cache = this._buildCache();\n    }\n    _buildCache() {\n        const next = this._commandRegistry.keyBindings.find(binding => binding.command === CommandIDs.findNext);\n        const previous = this._commandRegistry.keyBindings.find(binding => binding.command === CommandIDs.findPrevious);\n        const toggleSearchInSelection = this._commandRegistry.keyBindings.find(binding => binding.command === CommandIDs.toggleSearchInSelection);\n        return {\n            next,\n            previous,\n            toggleSearchInSelection\n        };\n    }\n    dispose() {\n        this._commandRegistry.keyBindingChanged.disconnect(this._rebuildCache, this);\n    }\n}\n/**\n * Initialization data for the document-search extension.\n */\nconst extension = {\n    id: '@jupyterlab/documentsearch-extension:plugin',\n    description: 'Provides the document search registry.',\n    provides: _jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_2__.ISearchProviderRegistry,\n    requires: [_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_4__.ITranslator],\n    optional: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ICommandPalette, _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_3__.ISettingRegistry],\n    autoStart: true,\n    activate: (app, translator, palette, settingRegistry) => {\n        var _a;\n        const trans = translator.load('jupyterlab');\n        let searchDebounceTime = 500;\n        let autoSearchInSelection = 'never';\n        // Create registry\n        const registry = new _jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_2__.SearchProviderRegistry(translator);\n        const searchViews = new Map();\n        if (settingRegistry) {\n            const loadSettings = settingRegistry.load(extension.id);\n            const updateSettings = (settings) => {\n                searchDebounceTime = settings.get('searchDebounceTime')\n                    .composite;\n                autoSearchInSelection = settings.get('autoSearchInSelection')\n                    .composite;\n            };\n            Promise.all([loadSettings, app.restored])\n                .then(([settings]) => {\n                updateSettings(settings);\n                settings.changed.connect(settings => {\n                    updateSettings(settings);\n                });\n            })\n                .catch((reason) => {\n                console.error(reason.message);\n            });\n        }\n        const isEnabled = () => {\n            const widget = app.shell.currentWidget;\n            if (!widget) {\n                return false;\n            }\n            return registry.hasProvider(widget);\n        };\n        const getSearchWidget = (widget) => {\n            if (!widget) {\n                return;\n            }\n            const widgetId = widget.id;\n            let searchView = searchViews.get(widgetId);\n            if (!searchView) {\n                const searchProvider = registry.getProvider(widget);\n                if (!searchProvider) {\n                    return;\n                }\n                const searchModel = new _jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_2__.SearchDocumentModel(searchProvider, searchDebounceTime);\n                const keyBingingsInfo = new SearchKeyBindings(app.commands);\n                const newView = new _jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_2__.SearchDocumentView(searchModel, translator, keyBingingsInfo);\n                searchViews.set(widgetId, newView);\n                // find next, previous and end are now enabled\n                [\n                    CommandIDs.findNext,\n                    CommandIDs.findPrevious,\n                    CommandIDs.end,\n                    CommandIDs.toggleSearchInSelection\n                ].forEach(id => {\n                    app.commands.notifyCommandChanged(id);\n                });\n                /**\n                 * Activate the target widget when the search panel is closing\n                 */\n                newView.closed.connect(() => {\n                    if (!widget.isDisposed) {\n                        widget.activate();\n                        widget.removeClass(SEARCH_ACTIVE_CLASS);\n                    }\n                });\n                /**\n                 * Remove from mapping when the search view is disposed.\n                 */\n                newView.disposed.connect(() => {\n                    if (!widget.isDisposed) {\n                        widget.activate();\n                        widget.removeClass(SEARCH_ACTIVE_CLASS);\n                    }\n                    searchViews.delete(widgetId);\n                    // find next, previous and end are now disabled\n                    [\n                        CommandIDs.findNext,\n                        CommandIDs.findPrevious,\n                        CommandIDs.end,\n                        CommandIDs.toggleSearchInSelection\n                    ].forEach(id => {\n                        app.commands.notifyCommandChanged(id);\n                    });\n                });\n                /**\n                 * Dispose resources when the widget is disposed.\n                 */\n                widget.disposed.connect(() => {\n                    newView.dispose();\n                    searchModel.dispose();\n                    searchProvider.dispose();\n                    keyBingingsInfo.dispose();\n                });\n                searchView = newView;\n            }\n            if (!searchView.isAttached) {\n                _lumino_widgets__WEBPACK_IMPORTED_MODULE_5__.Widget.attach(searchView, widget.node);\n                widget.addClass(SEARCH_ACTIVE_CLASS);\n                if (widget instanceof _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.MainAreaWidget) {\n                    // Offset the position of the search widget to not cover the toolbar nor the content header.\n                    // TODO this does not update once the search widget is displayed.\n                    searchView.node.style.top = `${widget.toolbar.node.getBoundingClientRect().height +\n                        widget.contentHeader.node.getBoundingClientRect().height}px`;\n                }\n                if (searchView.model.searchExpression) {\n                    searchView.model.refresh();\n                }\n            }\n            return searchView;\n        };\n        app.commands.addCommand(CommandIDs.search, {\n            label: trans.__('Find…'),\n            isEnabled: isEnabled,\n            execute: async (args) => {\n                const searchWidget = getSearchWidget(app.shell.currentWidget);\n                if (searchWidget) {\n                    const searchText = args['searchText'];\n                    if (searchText) {\n                        searchWidget.setSearchText(searchText);\n                    }\n                    else {\n                        searchWidget.setSearchText(searchWidget.model.suggestedInitialQuery);\n                    }\n                    const selectionState = searchWidget.model.selectionState;\n                    let enableSelectionMode = false;\n                    switch (autoSearchInSelection) {\n                        case 'multiple-selected':\n                            enableSelectionMode = selectionState === 'multiple';\n                            break;\n                        case 'any-selected':\n                            enableSelectionMode =\n                                selectionState === 'multiple' || selectionState === 'single';\n                            break;\n                        case 'never':\n                            // no-op\n                            break;\n                    }\n                    if (enableSelectionMode) {\n                        await searchWidget.model.setFilter('selection', true);\n                    }\n                    searchWidget.focusSearchInput();\n                }\n            }\n        });\n        app.commands.addCommand(CommandIDs.searchAndReplace, {\n            label: trans.__('Find and Replace…'),\n            isEnabled: isEnabled,\n            execute: args => {\n                const searchWidget = getSearchWidget(app.shell.currentWidget);\n                if (searchWidget) {\n                    const searchText = args['searchText'];\n                    if (searchText) {\n                        searchWidget.setSearchText(searchText);\n                    }\n                    else {\n                        searchWidget.setSearchText(searchWidget.model.suggestedInitialQuery);\n                    }\n                    const replaceText = args['replaceText'];\n                    if (replaceText) {\n                        searchWidget.setReplaceText(replaceText);\n                    }\n                    searchWidget.showReplace();\n                    searchWidget.focusSearchInput();\n                }\n            }\n        });\n        app.commands.addCommand(CommandIDs.findNext, {\n            label: trans.__('Find Next'),\n            isEnabled: () => !!app.shell.currentWidget &&\n                searchViews.has(app.shell.currentWidget.id),\n            execute: async () => {\n                var _a;\n                const currentWidget = app.shell.currentWidget;\n                if (!currentWidget) {\n                    return;\n                }\n                await ((_a = searchViews.get(currentWidget.id)) === null || _a === void 0 ? void 0 : _a.model.highlightNext());\n            }\n        });\n        app.commands.addCommand(CommandIDs.findPrevious, {\n            label: trans.__('Find Previous'),\n            isEnabled: () => !!app.shell.currentWidget &&\n                searchViews.has(app.shell.currentWidget.id),\n            execute: async () => {\n                var _a;\n                const currentWidget = app.shell.currentWidget;\n                if (!currentWidget) {\n                    return;\n                }\n                await ((_a = searchViews.get(currentWidget.id)) === null || _a === void 0 ? void 0 : _a.model.highlightPrevious());\n            }\n        });\n        app.commands.addCommand(CommandIDs.end, {\n            label: trans.__('End Search'),\n            isEnabled: () => !!app.shell.currentWidget &&\n                searchViews.has(app.shell.currentWidget.id),\n            execute: async () => {\n                var _a;\n                const currentWidget = app.shell.currentWidget;\n                if (!currentWidget) {\n                    return;\n                }\n                (_a = searchViews.get(currentWidget.id)) === null || _a === void 0 ? void 0 : _a.close();\n            }\n        });\n        app.commands.addCommand(CommandIDs.toggleSearchInSelection, {\n            label: trans.__('Search in Selection'),\n            isEnabled: () => !!app.shell.currentWidget &&\n                searchViews.has(app.shell.currentWidget.id) &&\n                'selection' in\n                    searchViews.get(app.shell.currentWidget.id).model.filtersDefinition,\n            execute: async () => {\n                var _a;\n                const currentWidget = app.shell.currentWidget;\n                if (!currentWidget) {\n                    return;\n                }\n                const model = (_a = searchViews.get(currentWidget.id)) === null || _a === void 0 ? void 0 : _a.model;\n                if (!model) {\n                    return;\n                }\n                const currentValue = model.filters['selection'];\n                return model.setFilter('selection', !currentValue);\n            }\n        });\n        (_a = app.shell.currentChanged) === null || _a === void 0 ? void 0 : _a.connect(() => {\n            Object.values(CommandIDs).forEach(cmd => {\n                app.commands.notifyCommandChanged(cmd);\n            });\n        });\n        // Add the command to the palette.\n        if (palette) {\n            [\n                CommandIDs.search,\n                CommandIDs.findNext,\n                CommandIDs.findPrevious,\n                CommandIDs.end,\n                CommandIDs.toggleSearchInSelection\n            ].forEach(command => {\n                palette.addItem({\n                    command,\n                    category: trans.__('Main Area')\n                });\n            });\n        }\n        // Provide the registry to the system.\n        return registry;\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([extension, labShellWidgetListener]);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch-extension/lib/index.js?");

/***/ })

}]);