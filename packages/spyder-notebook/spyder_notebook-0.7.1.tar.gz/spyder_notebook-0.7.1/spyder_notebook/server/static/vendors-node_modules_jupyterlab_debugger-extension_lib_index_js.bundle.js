"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["vendors-node_modules_jupyterlab_debugger-extension_lib_index_js"],{

/***/ "../node_modules/@jupyterlab/debugger-extension/lib/index.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@jupyterlab/debugger-extension/lib/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/application */ \"webpack/sharing/consume/default/@jupyterlab/application/@jupyterlab/application\");\n/* harmony import */ var _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/apputils */ \"webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils\");\n/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/cells */ \"webpack/sharing/consume/default/@jupyterlab/cells/@jupyterlab/cells\");\n/* harmony import */ var _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_cells__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/codeeditor */ \"webpack/sharing/consume/default/@jupyterlab/codeeditor/@jupyterlab/codeeditor\");\n/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _jupyterlab_console__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jupyterlab/console */ \"webpack/sharing/consume/default/@jupyterlab/console/@jupyterlab/console\");\n/* harmony import */ var _jupyterlab_console__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_console__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @jupyterlab/coreutils */ \"webpack/sharing/consume/default/@jupyterlab/coreutils/@jupyterlab/coreutils\");\n/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @jupyterlab/debugger */ \"webpack/sharing/consume/default/@jupyterlab/debugger/@jupyterlab/debugger\");\n/* harmony import */ var _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @jupyterlab/docregistry */ \"webpack/sharing/consume/default/@jupyterlab/docregistry/@jupyterlab/docregistry\");\n/* harmony import */ var _jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _jupyterlab_fileeditor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @jupyterlab/fileeditor */ \"webpack/sharing/consume/default/@jupyterlab/fileeditor/@jupyterlab/fileeditor\");\n/* harmony import */ var _jupyterlab_fileeditor__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_fileeditor__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _jupyterlab_logconsole__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @jupyterlab/logconsole */ \"webpack/sharing/consume/default/@jupyterlab/logconsole/@jupyterlab/logconsole\");\n/* harmony import */ var _jupyterlab_logconsole__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_logconsole__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @jupyterlab/notebook */ \"webpack/sharing/consume/default/@jupyterlab/notebook/@jupyterlab/notebook\");\n/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @jupyterlab/rendermime */ \"webpack/sharing/consume/default/@jupyterlab/rendermime/@jupyterlab/rendermime\");\n/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @jupyterlab/settingregistry */ \"webpack/sharing/consume/default/@jupyterlab/settingregistry/@jupyterlab/settingregistry\");\n/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @jupyterlab/translation */ \"webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation\");\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_13__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module debugger-extension\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction notifyCommands(commands) {\n    Object.values(_jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.CommandIDs).forEach(command => {\n        if (commands.hasCommand(command)) {\n            commands.notifyCommandChanged(command);\n        }\n    });\n}\nfunction updateState(commands, debug) {\n    const hasStoppedThreads = debug.hasStoppedThreads();\n    if (hasStoppedThreads) {\n        document.body.dataset.jpDebuggerStoppedThreads = 'true';\n    }\n    else {\n        delete document.body.dataset.jpDebuggerStoppedThreads;\n    }\n    notifyCommands(commands);\n}\n/**\n * A plugin that provides visual debugging support for consoles.\n */\nconst consoles = {\n    // FIXME This should be in @jupyterlab/console-extension\n    id: '@jupyterlab/debugger-extension:consoles',\n    description: 'Add debugger capability to the consoles.',\n    autoStart: true,\n    requires: [_jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.IDebugger, _jupyterlab_console__WEBPACK_IMPORTED_MODULE_4__.IConsoleTracker],\n    optional: [_jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.ILabShell],\n    activate: (app, debug, consoleTracker, labShell) => {\n        const handler = new _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.Handler({\n            type: 'console',\n            shell: app.shell,\n            service: debug\n        });\n        const updateHandlerAndCommands = async (widget) => {\n            const { sessionContext } = widget;\n            await sessionContext.ready;\n            await handler.updateContext(widget, sessionContext);\n            updateState(app.commands, debug);\n        };\n        if (labShell) {\n            labShell.currentChanged.connect((_, update) => {\n                const widget = update.newValue;\n                if (widget instanceof _jupyterlab_console__WEBPACK_IMPORTED_MODULE_4__.ConsolePanel) {\n                    void updateHandlerAndCommands(widget);\n                }\n            });\n        }\n        else {\n            consoleTracker.currentChanged.connect((_, consolePanel) => {\n                if (consolePanel) {\n                    void updateHandlerAndCommands(consolePanel);\n                }\n            });\n        }\n    }\n};\n/**\n * A plugin that provides visual debugging support for file editors.\n */\nconst files = {\n    // FIXME This should be in @jupyterlab/fileeditor-extension\n    id: '@jupyterlab/debugger-extension:files',\n    description: 'Adds debugger capabilities to files.',\n    autoStart: true,\n    requires: [_jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.IDebugger, _jupyterlab_fileeditor__WEBPACK_IMPORTED_MODULE_8__.IEditorTracker],\n    optional: [_jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.ILabShell],\n    activate: (app, debug, editorTracker, labShell) => {\n        const handler = new _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.Handler({\n            type: 'file',\n            shell: app.shell,\n            service: debug\n        });\n        const activeSessions = {};\n        const updateHandlerAndCommands = async (widget) => {\n            const sessions = app.serviceManager.sessions;\n            try {\n                const model = await sessions.findByPath(widget.context.path);\n                if (!model) {\n                    return;\n                }\n                let session = activeSessions[model.id];\n                if (!session) {\n                    // Use `connectTo` only if the session does not exist.\n                    // `connectTo` sends a kernel_info_request on the shell\n                    // channel, which blocks the debug session restore when waiting\n                    // for the kernel to be ready\n                    session = sessions.connectTo({ model });\n                    activeSessions[model.id] = session;\n                }\n                await handler.update(widget, session);\n                updateState(app.commands, debug);\n            }\n            catch (_a) {\n                return;\n            }\n        };\n        if (labShell) {\n            labShell.currentChanged.connect((_, update) => {\n                const widget = update.newValue;\n                if (widget instanceof _jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_7__.DocumentWidget) {\n                    const { content } = widget;\n                    if (content instanceof _jupyterlab_fileeditor__WEBPACK_IMPORTED_MODULE_8__.FileEditor) {\n                        void updateHandlerAndCommands(widget);\n                    }\n                }\n            });\n        }\n        else {\n            editorTracker.currentChanged.connect((_, documentWidget) => {\n                if (documentWidget) {\n                    void updateHandlerAndCommands(documentWidget);\n                }\n            });\n        }\n    }\n};\n/**\n * A plugin that provides visual debugging support for notebooks.\n */\nconst notebooks = {\n    // FIXME This should be in @jupyterlab/notebook-extension\n    id: '@jupyterlab/debugger-extension:notebooks',\n    description: 'Adds debugger capability to notebooks and provides the debugger notebook handler.',\n    autoStart: true,\n    requires: [_jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.IDebugger, _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_10__.INotebookTracker],\n    optional: [_jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.ILabShell, _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ICommandPalette, _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ISessionContextDialogs, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_13__.ITranslator],\n    provides: _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.IDebuggerHandler,\n    activate: (app, service, notebookTracker, labShell, palette, sessionDialogs_, translator_) => {\n        const translator = translator_ !== null && translator_ !== void 0 ? translator_ : _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_13__.nullTranslator;\n        const sessionDialogs = sessionDialogs_ !== null && sessionDialogs_ !== void 0 ? sessionDialogs_ : new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.SessionContextDialogs({ translator });\n        const handler = new _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.Handler({\n            type: 'notebook',\n            shell: app.shell,\n            service\n        });\n        const trans = translator.load('jupyterlab');\n        app.commands.addCommand(_jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.CommandIDs.restartDebug, {\n            label: trans.__('Restart Kernel and Debug…'),\n            caption: trans.__('Restart Kernel and Debug…'),\n            isEnabled: () => service.isStarted,\n            execute: async () => {\n                const state = service.getDebuggerState();\n                await service.stop();\n                const widget = notebookTracker.currentWidget;\n                if (!widget) {\n                    return;\n                }\n                const { content, sessionContext } = widget;\n                const restarted = await sessionDialogs.restart(sessionContext);\n                if (!restarted) {\n                    return;\n                }\n                await service.restoreDebuggerState(state);\n                await handler.updateWidget(widget, sessionContext.session);\n                await _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_10__.NotebookActions.runAll(content, sessionContext, sessionDialogs, translator);\n            }\n        });\n        const updateHandlerAndCommands = async (widget) => {\n            if (widget) {\n                const { sessionContext } = widget;\n                await sessionContext.ready;\n                await handler.updateContext(widget, sessionContext);\n            }\n            updateState(app.commands, service);\n        };\n        if (labShell) {\n            labShell.currentChanged.connect((_, update) => {\n                const widget = update.newValue;\n                if (widget instanceof _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_10__.NotebookPanel) {\n                    void updateHandlerAndCommands(widget);\n                }\n            });\n        }\n        else {\n            notebookTracker.currentChanged.connect((_, notebookPanel) => {\n                if (notebookPanel) {\n                    void updateHandlerAndCommands(notebookPanel);\n                }\n            });\n        }\n        if (palette) {\n            palette.addItem({\n                category: 'Notebook Operations',\n                command: _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.CommandIDs.restartDebug\n            });\n        }\n        return handler;\n    }\n};\n/**\n * A plugin that provides a debugger service.\n */\nconst service = {\n    id: '@jupyterlab/debugger-extension:service',\n    description: 'Provides the debugger service.',\n    autoStart: true,\n    provides: _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.IDebugger,\n    requires: [_jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.IDebuggerConfig],\n    optional: [_jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.IDebuggerSources, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_13__.ITranslator],\n    activate: (app, config, debuggerSources, translator) => new _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.Service({\n        config,\n        debuggerSources,\n        specsManager: app.serviceManager.kernelspecs,\n        translator\n    })\n};\n/**\n * A plugin that provides a configuration with hash method.\n */\nconst configuration = {\n    id: '@jupyterlab/debugger-extension:config',\n    description: 'Provides the debugger configuration',\n    provides: _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.IDebuggerConfig,\n    autoStart: true,\n    activate: () => new _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.Config()\n};\n/**\n * A plugin that provides source/editor functionality for debugging.\n */\nconst sources = {\n    id: '@jupyterlab/debugger-extension:sources',\n    description: 'Provides the source feature for debugging',\n    autoStart: true,\n    provides: _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.IDebuggerSources,\n    requires: [_jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.IDebuggerConfig, _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_3__.IEditorServices],\n    optional: [_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_10__.INotebookTracker, _jupyterlab_console__WEBPACK_IMPORTED_MODULE_4__.IConsoleTracker, _jupyterlab_fileeditor__WEBPACK_IMPORTED_MODULE_8__.IEditorTracker],\n    activate: (app, config, editorServices, notebookTracker, consoleTracker, editorTracker) => {\n        return new _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.Sources({\n            config,\n            shell: app.shell,\n            editorServices,\n            notebookTracker,\n            consoleTracker,\n            editorTracker\n        });\n    }\n};\n/*\n * A plugin to open detailed views for variables.\n */\nconst variables = {\n    id: '@jupyterlab/debugger-extension:variables',\n    description: 'Adds variables renderer and inspection in the debugger variable panel.',\n    autoStart: true,\n    requires: [_jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.IDebugger, _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.IDebuggerHandler, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_13__.ITranslator],\n    optional: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.IThemeManager, _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_11__.IRenderMimeRegistry],\n    activate: (app, service, handler, translator, themeManager, rendermime) => {\n        const trans = translator.load('jupyterlab');\n        const { commands, shell } = app;\n        const tracker = new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.WidgetTracker({\n            namespace: 'debugger/inspect-variable'\n        });\n        const trackerMime = new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.WidgetTracker({\n            namespace: 'debugger/render-variable'\n        });\n        const CommandIDs = _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.CommandIDs;\n        // Add commands\n        commands.addCommand(CommandIDs.inspectVariable, {\n            label: trans.__('Inspect Variable'),\n            caption: trans.__('Inspect Variable'),\n            isEnabled: args => {\n                var _a, _b, _c, _d;\n                return !!((_a = service.session) === null || _a === void 0 ? void 0 : _a.isStarted) &&\n                    Number((_d = (_b = args.variableReference) !== null && _b !== void 0 ? _b : (_c = service.model.variables.selectedVariable) === null || _c === void 0 ? void 0 : _c.variablesReference) !== null && _d !== void 0 ? _d : 0) > 0;\n            },\n            execute: async (args) => {\n                var _a, _b, _c, _d;\n                let { variableReference, name } = args;\n                if (!variableReference) {\n                    variableReference =\n                        (_a = service.model.variables.selectedVariable) === null || _a === void 0 ? void 0 : _a.variablesReference;\n                }\n                if (!name) {\n                    name = (_b = service.model.variables.selectedVariable) === null || _b === void 0 ? void 0 : _b.name;\n                }\n                const id = `jp-debugger-variable-${name}`;\n                if (!name ||\n                    !variableReference ||\n                    tracker.find(widget => widget.id === id)) {\n                    return;\n                }\n                const variables = await service.inspectVariable(variableReference);\n                if (!variables || variables.length === 0) {\n                    return;\n                }\n                const model = service.model.variables;\n                const widget = new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.MainAreaWidget({\n                    content: new _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.VariablesGrid({\n                        model,\n                        commands,\n                        scopes: [{ name, variables }],\n                        themeManager\n                    })\n                });\n                widget.addClass('jp-DebuggerVariables');\n                widget.id = id;\n                widget.title.icon = _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.Icons.variableIcon;\n                widget.title.label = `${(_d = (_c = service.session) === null || _c === void 0 ? void 0 : _c.connection) === null || _d === void 0 ? void 0 : _d.name} - ${name}`;\n                void tracker.add(widget);\n                const disposeWidget = () => {\n                    widget.dispose();\n                    model.changed.disconnect(disposeWidget);\n                };\n                model.changed.connect(disposeWidget);\n                shell.add(widget, 'main', {\n                    mode: tracker.currentWidget ? 'split-right' : 'split-bottom',\n                    activate: false,\n                    type: 'Debugger Variables'\n                });\n            }\n        });\n        commands.addCommand(CommandIDs.renderMimeVariable, {\n            label: trans.__('Render Variable'),\n            caption: trans.__('Render variable according to its mime type'),\n            isEnabled: () => { var _a; return !!((_a = service.session) === null || _a === void 0 ? void 0 : _a.isStarted); },\n            isVisible: () => service.model.hasRichVariableRendering &&\n                (rendermime !== null || handler.activeWidget instanceof _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_10__.NotebookPanel),\n            execute: args => {\n                var _a, _b, _c, _d, _e, _f, _g, _h;\n                let { name, frameId } = args;\n                if (!name) {\n                    name = (_a = service.model.variables.selectedVariable) === null || _a === void 0 ? void 0 : _a.name;\n                }\n                if (!frameId) {\n                    frameId = (_b = service.model.callstack.frame) === null || _b === void 0 ? void 0 : _b.id;\n                }\n                const activeWidget = handler.activeWidget;\n                let activeRendermime = activeWidget instanceof _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_10__.NotebookPanel\n                    ? activeWidget.content.rendermime\n                    : rendermime;\n                if (!activeRendermime) {\n                    return;\n                }\n                const id = `jp-debugger-variable-mime-${name}-${(_d = (_c = service.session) === null || _c === void 0 ? void 0 : _c.connection) === null || _d === void 0 ? void 0 : _d.path.replace('/', '-')}`;\n                if (!name || // Name is mandatory\n                    trackerMime.find(widget => widget.id === id) || // Widget already exists\n                    (!frameId && service.hasStoppedThreads()) // frame id missing on breakpoint\n                ) {\n                    return;\n                }\n                const variablesModel = service.model.variables;\n                const widget = new _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.VariableRenderer({\n                    dataLoader: () => service.inspectRichVariable(name, frameId),\n                    rendermime: activeRendermime,\n                    translator\n                });\n                widget.addClass('jp-DebuggerRichVariable');\n                widget.id = id;\n                widget.title.icon = _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.Icons.variableIcon;\n                widget.title.label = `${name} - ${(_f = (_e = service.session) === null || _e === void 0 ? void 0 : _e.connection) === null || _f === void 0 ? void 0 : _f.name}`;\n                widget.title.caption = `${name} - ${(_h = (_g = service.session) === null || _g === void 0 ? void 0 : _g.connection) === null || _h === void 0 ? void 0 : _h.path}`;\n                void trackerMime.add(widget);\n                const disposeWidget = () => {\n                    widget.dispose();\n                    variablesModel.changed.disconnect(refreshWidget);\n                    activeWidget === null || activeWidget === void 0 ? void 0 : activeWidget.disposed.disconnect(disposeWidget);\n                };\n                const refreshWidget = () => {\n                    // Refresh the widget only if the active element is the same.\n                    if (handler.activeWidget === activeWidget) {\n                        void widget.refresh();\n                    }\n                };\n                widget.disposed.connect(disposeWidget);\n                variablesModel.changed.connect(refreshWidget);\n                activeWidget === null || activeWidget === void 0 ? void 0 : activeWidget.disposed.connect(disposeWidget);\n                shell.add(widget, 'main', {\n                    mode: trackerMime.currentWidget ? 'split-right' : 'split-bottom',\n                    activate: false,\n                    type: 'Debugger Variables'\n                });\n            }\n        });\n        commands.addCommand(CommandIDs.copyToClipboard, {\n            label: trans.__('Copy to Clipboard'),\n            caption: trans.__('Copy text representation of the value to clipboard'),\n            isEnabled: () => {\n                var _a, _b;\n                return (!!((_a = service.session) === null || _a === void 0 ? void 0 : _a.isStarted) &&\n                    !!((_b = service.model.variables.selectedVariable) === null || _b === void 0 ? void 0 : _b.value));\n            },\n            isVisible: () => handler.activeWidget instanceof _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_10__.NotebookPanel,\n            execute: async () => {\n                const value = service.model.variables.selectedVariable.value;\n                if (value) {\n                    _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Clipboard.copyToSystem(value);\n                }\n            }\n        });\n        commands.addCommand(CommandIDs.copyToGlobals, {\n            label: trans.__('Copy Variable to Globals'),\n            caption: trans.__('Copy variable to globals scope'),\n            isEnabled: () => { var _a; return !!((_a = service.session) === null || _a === void 0 ? void 0 : _a.isStarted); },\n            isVisible: () => handler.activeWidget instanceof _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_10__.NotebookPanel &&\n                service.model.supportCopyToGlobals,\n            execute: async (args) => {\n                const name = service.model.variables.selectedVariable.name;\n                await service.copyToGlobals(name);\n            }\n        });\n    }\n};\n/**\n * Debugger sidebar provider plugin.\n */\nconst sidebar = {\n    id: '@jupyterlab/debugger-extension:sidebar',\n    description: 'Provides the debugger sidebar.',\n    provides: _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.IDebuggerSidebar,\n    requires: [_jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.IDebugger, _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_3__.IEditorServices, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_13__.ITranslator],\n    optional: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.IThemeManager, _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_12__.ISettingRegistry],\n    autoStart: true,\n    activate: async (app, service, editorServices, translator, themeManager, settingRegistry) => {\n        const { commands } = app;\n        const CommandIDs = _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.CommandIDs;\n        const callstackCommands = {\n            registry: commands,\n            continue: CommandIDs.debugContinue,\n            terminate: CommandIDs.terminate,\n            next: CommandIDs.next,\n            stepIn: CommandIDs.stepIn,\n            stepOut: CommandIDs.stepOut,\n            evaluate: CommandIDs.evaluate\n        };\n        const breakpointsCommands = {\n            registry: commands,\n            pauseOnExceptions: CommandIDs.pauseOnExceptions\n        };\n        const sidebar = new _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.Sidebar({\n            service,\n            callstackCommands,\n            breakpointsCommands,\n            editorServices,\n            themeManager,\n            translator\n        });\n        if (settingRegistry) {\n            const setting = await settingRegistry.load(main.id);\n            const updateSettings = () => {\n                var _a, _b, _c, _d;\n                const filters = setting.get('variableFilters').composite;\n                const kernel = (_d = (_c = (_b = (_a = service.session) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.kernel) === null || _c === void 0 ? void 0 : _c.name) !== null && _d !== void 0 ? _d : '';\n                if (kernel && filters[kernel]) {\n                    sidebar.variables.filter = new Set(filters[kernel]);\n                }\n                const kernelSourcesFilter = setting.get('defaultKernelSourcesFilter')\n                    .composite;\n                sidebar.kernelSources.filter = kernelSourcesFilter;\n            };\n            updateSettings();\n            setting.changed.connect(updateSettings);\n            service.sessionChanged.connect(updateSettings);\n        }\n        return sidebar;\n    }\n};\n/**\n * The source viewer UI plugin.\n */\nconst sourceViewer = {\n    id: '@jupyterlab/debugger-extension:source-viewer',\n    description: 'Initialize the debugger sources viewer.',\n    requires: [_jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.IDebugger, _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_3__.IEditorServices, _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.IDebuggerSources, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_13__.ITranslator],\n    provides: _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.IDebuggerSourceViewer,\n    autoStart: true,\n    activate: async (app, service, editorServices, debuggerSources, translator) => {\n        const readOnlyEditorFactory = new _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.ReadOnlyEditorFactory({\n            editorServices\n        });\n        const { model } = service;\n        const onCurrentFrameChanged = (_, frame) => {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n            debuggerSources\n                .find({\n                focus: true,\n                kernel: (_d = (_c = (_b = (_a = service.session) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.kernel) === null || _c === void 0 ? void 0 : _c.name) !== null && _d !== void 0 ? _d : '',\n                path: (_g = (_f = (_e = service.session) === null || _e === void 0 ? void 0 : _e.connection) === null || _f === void 0 ? void 0 : _f.path) !== null && _g !== void 0 ? _g : '',\n                source: (_j = (_h = frame === null || frame === void 0 ? void 0 : frame.source) === null || _h === void 0 ? void 0 : _h.path) !== null && _j !== void 0 ? _j : ''\n            })\n                .forEach(editor => {\n                requestAnimationFrame(() => {\n                    void editor.reveal().then(() => {\n                        const edit = editor.get();\n                        if (edit) {\n                            _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.EditorHandler.showCurrentLine(edit, frame.line);\n                        }\n                    });\n                });\n            });\n        };\n        model.callstack.currentFrameChanged.connect(onCurrentFrameChanged);\n        const openSource = (source, breakpoint) => {\n            var _a, _b, _c, _d, _e, _f, _g;\n            if (!source) {\n                return;\n            }\n            const { content, mimeType, path } = source;\n            const results = debuggerSources.find({\n                focus: true,\n                kernel: (_d = (_c = (_b = (_a = service.session) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.kernel) === null || _c === void 0 ? void 0 : _c.name) !== null && _d !== void 0 ? _d : '',\n                path: (_g = (_f = (_e = service.session) === null || _e === void 0 ? void 0 : _e.connection) === null || _f === void 0 ? void 0 : _f.path) !== null && _g !== void 0 ? _g : '',\n                source: path\n            });\n            if (results.length > 0) {\n                if (breakpoint && typeof breakpoint.line !== 'undefined') {\n                    results.forEach(editor => {\n                        void editor.reveal().then(() => {\n                            var _a;\n                            (_a = editor.get()) === null || _a === void 0 ? void 0 : _a.revealPosition({\n                                line: breakpoint.line - 1,\n                                column: breakpoint.column || 0\n                            });\n                        });\n                    });\n                }\n                return;\n            }\n            const editorWrapper = readOnlyEditorFactory.createNewEditor({\n                content,\n                mimeType,\n                path\n            });\n            const editor = editorWrapper.editor;\n            const editorHandler = new _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.EditorHandler({\n                debuggerService: service,\n                editorReady: () => Promise.resolve(editor),\n                getEditor: () => editor,\n                path,\n                src: editor.model.sharedModel\n            });\n            editorWrapper.disposed.connect(() => editorHandler.dispose());\n            debuggerSources.open({\n                label: _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_5__.PathExt.basename(path),\n                caption: path,\n                editorWrapper\n            });\n            const frame = service.model.callstack.frame;\n            if (frame) {\n                _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.EditorHandler.showCurrentLine(editor, frame.line);\n            }\n        };\n        const trans = translator.load('jupyterlab');\n        app.commands.addCommand(_jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.CommandIDs.openSource, {\n            label: trans.__('Open Source'),\n            caption: trans.__('Open Source'),\n            isEnabled: () => !!sourceViewer,\n            execute: async (args) => {\n                const path = args.path || '';\n                if (!path) {\n                    throw Error('Path to open is needed');\n                }\n                if (!service.isStarted) {\n                    const choice = await (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.showDialog)({\n                        title: trans.__('Start debugger?'),\n                        body: trans.__('The debugger service is needed to open the source %1', path),\n                        buttons: [\n                            _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Dialog.cancelButton({ label: trans.__('Cancel') }),\n                            _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Dialog.okButton({ label: trans.__('Start debugger') })\n                        ]\n                    });\n                    if (choice.button.accept) {\n                        await service.start();\n                    }\n                    else {\n                        return;\n                    }\n                }\n                const source = await service.getSource({\n                    path\n                });\n                return openSource(source);\n            }\n        });\n        return Object.freeze({\n            open: openSource\n        });\n    }\n};\n/**\n * The main debugger UI plugin.\n */\nconst main = {\n    id: '@jupyterlab/debugger-extension:main',\n    description: 'Initialize the debugger user interface.',\n    requires: [_jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.IDebugger, _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.IDebuggerSidebar, _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_3__.IEditorServices, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_13__.ITranslator],\n    optional: [\n        _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ICommandPalette,\n        _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.IDebuggerSourceViewer,\n        _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.ILabShell,\n        _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.ILayoutRestorer,\n        _jupyterlab_logconsole__WEBPACK_IMPORTED_MODULE_9__.ILoggerRegistry,\n        _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_12__.ISettingRegistry\n    ],\n    autoStart: true,\n    activate: async (app, service, sidebar, editorServices, translator, palette, sourceViewer, labShell, restorer, loggerRegistry, settingRegistry) => {\n        var _a;\n        const trans = translator.load('jupyterlab');\n        const { commands, shell, serviceManager } = app;\n        const { kernelspecs } = serviceManager;\n        const CommandIDs = _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.CommandIDs;\n        // First check if there is a PageConfig override for the extension visibility\n        const alwaysShowDebuggerExtension = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_5__.PageConfig.getOption('alwaysShowDebuggerExtension').toLowerCase() ===\n            'true';\n        if (!alwaysShowDebuggerExtension) {\n            // hide the debugger sidebar if no kernel with support for debugging is available\n            await kernelspecs.ready;\n            const specs = (_a = kernelspecs.specs) === null || _a === void 0 ? void 0 : _a.kernelspecs;\n            if (!specs) {\n                return;\n            }\n            const enabled = Object.keys(specs).some(name => { var _a, _b, _c; return !!((_c = (_b = (_a = specs[name]) === null || _a === void 0 ? void 0 : _a.metadata) === null || _b === void 0 ? void 0 : _b['debugger']) !== null && _c !== void 0 ? _c : false); });\n            if (!enabled) {\n                return;\n            }\n        }\n        // get the mime type of the kernel language for the current debug session\n        const getMimeType = async () => {\n            var _a, _b, _c;\n            const kernel = (_b = (_a = service.session) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.kernel;\n            if (!kernel) {\n                return '';\n            }\n            const info = (await kernel.info).language_info;\n            const name = info.name;\n            const mimeType = (_c = editorServices.mimeTypeService.getMimeTypeByLanguage({ name })) !== null && _c !== void 0 ? _c : '';\n            return mimeType;\n        };\n        const rendermime = new _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_11__.RenderMimeRegistry({ initialFactories: _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_11__.standardRendererFactories });\n        commands.addCommand(CommandIDs.evaluate, {\n            label: trans.__('Evaluate Code'),\n            caption: trans.__('Evaluate Code'),\n            icon: _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.Icons.evaluateIcon,\n            isEnabled: () => service.hasStoppedThreads(),\n            execute: async () => {\n                var _a, _b, _c;\n                const mimeType = await getMimeType();\n                const result = await _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.Dialogs.getCode({\n                    title: trans.__('Evaluate Code'),\n                    okLabel: trans.__('Evaluate'),\n                    cancelLabel: trans.__('Cancel'),\n                    mimeType,\n                    contentFactory: new _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_2__.CodeCell.ContentFactory({\n                        editorFactory: options => editorServices.factoryService.newInlineEditor(options)\n                    }),\n                    rendermime\n                });\n                const code = result.value;\n                if (!result.button.accept || !code) {\n                    return;\n                }\n                const reply = await service.evaluate(code);\n                if (reply) {\n                    const data = reply.result;\n                    const path = (_b = (_a = service === null || service === void 0 ? void 0 : service.session) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.path;\n                    const logger = path ? (_c = loggerRegistry === null || loggerRegistry === void 0 ? void 0 : loggerRegistry.getLogger) === null || _c === void 0 ? void 0 : _c.call(loggerRegistry, path) : undefined;\n                    if (logger) {\n                        // print to log console of the notebook currently being debugged\n                        logger.log({ type: 'text', data, level: logger.level });\n                    }\n                    else {\n                        // fallback to printing to devtools console\n                        console.debug(data);\n                    }\n                }\n            }\n        });\n        commands.addCommand(CommandIDs.debugContinue, {\n            label: () => {\n                return service.hasStoppedThreads()\n                    ? trans.__('Continue')\n                    : trans.__('Pause');\n            },\n            caption: () => {\n                return service.hasStoppedThreads()\n                    ? trans.__('Continue')\n                    : trans.__('Pause');\n            },\n            icon: () => {\n                return service.hasStoppedThreads()\n                    ? _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.Icons.continueIcon\n                    : _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.Icons.pauseIcon;\n            },\n            isEnabled: () => { var _a, _b; return (_b = (_a = service.session) === null || _a === void 0 ? void 0 : _a.isStarted) !== null && _b !== void 0 ? _b : false; },\n            execute: async () => {\n                if (service.hasStoppedThreads()) {\n                    await service.continue();\n                }\n                else {\n                    await service.pause();\n                }\n                commands.notifyCommandChanged(CommandIDs.debugContinue);\n            }\n        });\n        commands.addCommand(CommandIDs.terminate, {\n            label: trans.__('Terminate'),\n            caption: trans.__('Terminate'),\n            icon: _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.Icons.terminateIcon,\n            isEnabled: () => service.hasStoppedThreads(),\n            execute: async () => {\n                await service.restart();\n                updateState(app.commands, service);\n            }\n        });\n        commands.addCommand(CommandIDs.next, {\n            label: trans.__('Next'),\n            caption: trans.__('Next'),\n            icon: _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.Icons.stepOverIcon,\n            isEnabled: () => service.hasStoppedThreads(),\n            execute: async () => {\n                await service.next();\n            }\n        });\n        commands.addCommand(CommandIDs.stepIn, {\n            label: trans.__('Step In'),\n            caption: trans.__('Step In'),\n            icon: _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.Icons.stepIntoIcon,\n            isEnabled: () => service.hasStoppedThreads(),\n            execute: async () => {\n                await service.stepIn();\n            }\n        });\n        commands.addCommand(CommandIDs.stepOut, {\n            label: trans.__('Step Out'),\n            caption: trans.__('Step Out'),\n            icon: _jupyterlab_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.Icons.stepOutIcon,\n            isEnabled: () => service.hasStoppedThreads(),\n            execute: async () => {\n                await service.stepOut();\n            }\n        });\n        commands.addCommand(CommandIDs.pauseOnExceptions, {\n            label: args => args.filter || 'Breakpoints on exception',\n            caption: args => args.description,\n            isToggled: args => { var _a; return ((_a = service.session) === null || _a === void 0 ? void 0 : _a.isPausingOnException(args.filter)) || false; },\n            isEnabled: () => service.pauseOnExceptionsIsValid(),\n            execute: async (args) => {\n                var _a, _b, _c;\n                if (args === null || args === void 0 ? void 0 : args.filter) {\n                    let filter = args.filter;\n                    await service.pauseOnExceptionsFilter(filter);\n                }\n                else {\n                    let items = [];\n                    (_b = (_a = service.session) === null || _a === void 0 ? void 0 : _a.exceptionBreakpointFilters) === null || _b === void 0 ? void 0 : _b.forEach(availableFilter => {\n                        items.push(availableFilter.filter);\n                    });\n                    const result = await _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.InputDialog.getMultipleItems({\n                        title: trans.__('Select a filter for breakpoints on exception'),\n                        items: items,\n                        defaults: ((_c = service.session) === null || _c === void 0 ? void 0 : _c.currentExceptionFilters) || []\n                    });\n                    let filters = result.button.accept ? result.value : null;\n                    if (filters !== null) {\n                        await service.pauseOnExceptions(filters);\n                    }\n                }\n            }\n        });\n        let autoCollapseSidebar = false;\n        if (settingRegistry) {\n            const setting = await settingRegistry.load(main.id);\n            const updateSettings = () => {\n                autoCollapseSidebar = setting.get('autoCollapseDebuggerSidebar')\n                    .composite;\n            };\n            updateSettings();\n            setting.changed.connect(updateSettings);\n        }\n        service.eventMessage.connect((_, event) => {\n            updateState(app.commands, service);\n            if (labShell && event.event === 'initialized') {\n                labShell.activateById(sidebar.id);\n            }\n            else if (labShell &&\n                sidebar.isVisible &&\n                event.event === 'terminated' &&\n                autoCollapseSidebar) {\n                labShell.collapseRight();\n            }\n        });\n        service.sessionChanged.connect(_ => {\n            updateState(app.commands, service);\n        });\n        if (restorer) {\n            restorer.add(sidebar, 'debugger-sidebar');\n        }\n        sidebar.node.setAttribute('role', 'region');\n        sidebar.node.setAttribute('aria-label', trans.__('Debugger section'));\n        sidebar.title.caption = trans.__('Debugger');\n        shell.add(sidebar, 'right', { type: 'Debugger' });\n        commands.addCommand(CommandIDs.showPanel, {\n            label: trans.__('Debugger Panel'),\n            execute: () => {\n                shell.activateById(sidebar.id);\n            }\n        });\n        if (palette) {\n            const category = trans.__('Debugger');\n            [\n                CommandIDs.debugContinue,\n                CommandIDs.terminate,\n                CommandIDs.next,\n                CommandIDs.stepIn,\n                CommandIDs.stepOut,\n                CommandIDs.evaluate,\n                CommandIDs.pauseOnExceptions\n            ].forEach(command => {\n                palette.addItem({ command, category });\n            });\n        }\n        if (sourceViewer) {\n            const { model } = service;\n            const onKernelSourceOpened = (_, source, breakpoint) => {\n                if (!source) {\n                    return;\n                }\n                sourceViewer.open(source, breakpoint);\n            };\n            model.sources.currentSourceOpened.connect((_, source) => {\n                sourceViewer.open(source);\n            });\n            model.kernelSources.kernelSourceOpened.connect(onKernelSourceOpened);\n            model.breakpoints.clicked.connect(async (_, breakpoint) => {\n                var _a;\n                const path = (_a = breakpoint.source) === null || _a === void 0 ? void 0 : _a.path;\n                const source = await service.getSource({\n                    sourceReference: 0,\n                    path\n                });\n                sourceViewer.open(source, breakpoint);\n            });\n        }\n    }\n};\n/**\n * Export the plugins as default.\n */\nconst plugins = [\n    service,\n    consoles,\n    files,\n    notebooks,\n    variables,\n    sidebar,\n    main,\n    sources,\n    sourceViewer,\n    configuration\n];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugins);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/debugger-extension/lib/index.js?");

/***/ })

}]);