"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["vendors-node_modules_jupyterlab_filebrowser-extension_lib_index_js"],{

/***/ "../node_modules/@jupyterlab/filebrowser-extension/lib/index.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@jupyterlab/filebrowser-extension/lib/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fileUploadStatus: () => (/* binding */ fileUploadStatus)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/application */ \"webpack/sharing/consume/default/@jupyterlab/application/@jupyterlab/application\");\n/* harmony import */ var _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/apputils */ \"webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils\");\n/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/coreutils */ \"webpack/sharing/consume/default/@jupyterlab/coreutils/@jupyterlab/coreutils\");\n/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/docmanager */ \"webpack/sharing/consume/default/@jupyterlab/docmanager/@jupyterlab/docmanager\");\n/* harmony import */ var _jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jupyterlab/filebrowser */ \"webpack/sharing/consume/default/@jupyterlab/filebrowser/@jupyterlab/filebrowser\");\n/* harmony import */ var _jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @jupyterlab/settingregistry */ \"webpack/sharing/consume/default/@jupyterlab/settingregistry/@jupyterlab/settingregistry\");\n/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _jupyterlab_statedb__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @jupyterlab/statedb */ \"webpack/sharing/consume/default/@jupyterlab/statedb/@jupyterlab/statedb\");\n/* harmony import */ var _jupyterlab_statedb__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_statedb__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @jupyterlab/statusbar */ \"webpack/sharing/consume/default/@jupyterlab/statusbar/@jupyterlab/statusbar\");\n/* harmony import */ var _jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @jupyterlab/translation */ \"webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation\");\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @jupyterlab/ui-components */ \"webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components\");\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @lumino/algorithm */ \"webpack/sharing/consume/default/@lumino/algorithm/@lumino/algorithm\");\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _lumino_commands__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @lumino/commands */ \"webpack/sharing/consume/default/@lumino/commands/@lumino/commands\");\n/* harmony import */ var _lumino_commands__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_lumino_commands__WEBPACK_IMPORTED_MODULE_11__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module filebrowser-extension\n */\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Toolbar factory for the top toolbar in the widget\n */\nconst FILE_BROWSER_FACTORY = 'FileBrowser';\nconst FILE_BROWSER_PLUGIN_ID = '@jupyterlab/filebrowser-extension:browser';\n/**\n * The command IDs used by the file browser plugin.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.copy = 'filebrowser:copy';\n    CommandIDs.copyDownloadLink = 'filebrowser:copy-download-link';\n    CommandIDs.cut = 'filebrowser:cut';\n    CommandIDs.del = 'filebrowser:delete';\n    CommandIDs.download = 'filebrowser:download';\n    CommandIDs.duplicate = 'filebrowser:duplicate';\n    // For main browser only.\n    CommandIDs.hideBrowser = 'filebrowser:hide-main';\n    CommandIDs.goToPath = 'filebrowser:go-to-path';\n    CommandIDs.goUp = 'filebrowser:go-up';\n    CommandIDs.openPath = 'filebrowser:open-path';\n    CommandIDs.openUrl = 'filebrowser:open-url';\n    CommandIDs.open = 'filebrowser:open';\n    CommandIDs.openBrowserTab = 'filebrowser:open-browser-tab';\n    CommandIDs.paste = 'filebrowser:paste';\n    CommandIDs.createNewDirectory = 'filebrowser:create-new-directory';\n    CommandIDs.createNewFile = 'filebrowser:create-new-file';\n    CommandIDs.createNewMarkdownFile = 'filebrowser:create-new-markdown-file';\n    CommandIDs.refresh = 'filebrowser:refresh';\n    CommandIDs.rename = 'filebrowser:rename';\n    // For main browser only.\n    CommandIDs.copyShareableLink = 'filebrowser:share-main';\n    // For main browser only.\n    CommandIDs.copyPath = 'filebrowser:copy-path';\n    CommandIDs.showBrowser = 'filebrowser:activate';\n    CommandIDs.shutdown = 'filebrowser:shutdown';\n    // For main browser only.\n    CommandIDs.toggleBrowser = 'filebrowser:toggle-main';\n    CommandIDs.toggleFileFilter = 'filebrowser:toggle-file-filter';\n    CommandIDs.toggleNavigateToCurrentDirectory = 'filebrowser:toggle-navigate-to-current-directory';\n    CommandIDs.toggleLastModified = 'filebrowser:toggle-last-modified';\n    CommandIDs.toggleShowFullPath = 'filebrowser:toggle-show-full-path';\n    CommandIDs.toggleFileSize = 'filebrowser:toggle-file-size';\n    CommandIDs.toggleSortNotebooksFirst = 'filebrowser:toggle-sort-notebooks-first';\n    CommandIDs.search = 'filebrowser:search';\n    CommandIDs.toggleHiddenFiles = 'filebrowser:toggle-hidden-files';\n    CommandIDs.toggleSingleClick = 'filebrowser:toggle-single-click-navigation';\n    CommandIDs.toggleFileCheckboxes = 'filebrowser:toggle-file-checkboxes';\n})(CommandIDs || (CommandIDs = {}));\n/**\n * The file browser namespace token.\n */\nconst namespace = 'filebrowser';\n/**\n * The default file browser extension.\n */\nconst browser = {\n    id: FILE_BROWSER_PLUGIN_ID,\n    description: 'Set up the default file browser commands and state restoration',\n    requires: [_jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4__.IDefaultFileBrowser, _jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4__.IFileBrowserFactory, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_8__.ITranslator],\n    optional: [\n        _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.ILayoutRestorer,\n        _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_5__.ISettingRegistry,\n        _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.ITreePathUpdater,\n        _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ICommandPalette\n    ],\n    provides: _jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4__.IFileBrowserCommands,\n    autoStart: true,\n    activate: async (app, defaultFileBrowser, factory, translator, restorer, settingRegistry, treePathUpdater, commandPalette) => {\n        const browser = defaultFileBrowser;\n        // Let the application restorer track the primary file browser (that is\n        // automatically created) for restoration of application state (e.g. setting\n        // the file browser as the current side bar widget).\n        //\n        // All other file browsers created by using the factory function are\n        // responsible for their own restoration behavior, if any.\n        if (restorer) {\n            restorer.add(browser, namespace);\n        }\n        // Navigate to preferred-dir trait if found\n        const preferredPath = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__.PageConfig.getOption('preferredPath');\n        if (preferredPath) {\n            await browser.model.cd(preferredPath);\n        }\n        addCommands(app, browser, factory, translator, settingRegistry, commandPalette);\n        void Promise.all([app.restored, browser.model.restored]).then(() => {\n            if (treePathUpdater) {\n                browser.model.pathChanged.connect((sender, args) => {\n                    treePathUpdater(args.newValue);\n                });\n            }\n        });\n        return {\n            openPath: CommandIDs.openPath\n        };\n    }\n};\n/**\n * Handle the file browser settings taking into account user defined settings.\n */\nconst browserSettings = {\n    id: '@jupyterlab/filebrowser-extension:settings',\n    description: 'Set up the default file browser settings',\n    requires: [_jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4__.IDefaultFileBrowser],\n    optional: [_jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_5__.ISettingRegistry],\n    autoStart: true,\n    activate: (app, browser, settingRegistry) => {\n        if (settingRegistry) {\n            void settingRegistry.load(FILE_BROWSER_PLUGIN_ID).then(settings => {\n                /**\n                 * File browser default configuration.\n                 */\n                const defaultFileBrowserConfig = {\n                    navigateToCurrentDirectory: false,\n                    singleClickNavigation: false,\n                    showLastModifiedColumn: true,\n                    showFileSizeColumn: false,\n                    showHiddenFiles: false,\n                    showFileCheckboxes: false,\n                    sortNotebooksFirst: false,\n                    showFullPath: false\n                };\n                function onSettingsChanged(settings) {\n                    let key;\n                    for (key in defaultFileBrowserConfig) {\n                        const value = settings.get(key).composite;\n                        browser[key] = value;\n                    }\n                    const filterDirectories = settings.get('filterDirectories')\n                        .composite;\n                    const useFuzzyFilter = settings.get('useFuzzyFilter')\n                        .composite;\n                    browser.model.filterDirectories = filterDirectories;\n                    browser.model.useFuzzyFilter = useFuzzyFilter;\n                }\n                settings.changed.connect(onSettingsChanged);\n                onSettingsChanged(settings);\n            });\n        }\n    }\n};\n/**\n * The default file browser factory provider.\n */\nconst factory = {\n    id: '@jupyterlab/filebrowser-extension:factory',\n    description: 'Provides the file browser factory.',\n    provides: _jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4__.IFileBrowserFactory,\n    requires: [_jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_3__.IDocumentManager, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_8__.ITranslator],\n    optional: [_jupyterlab_statedb__WEBPACK_IMPORTED_MODULE_6__.IStateDB, _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.JupyterLab.IInfo],\n    activate: async (app, docManager, translator, stateDB, info) => {\n        const tracker = new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.WidgetTracker({ namespace });\n        const createFileBrowser = (id, options = {}) => {\n            var _a;\n            const state = options.state === null\n                ? undefined\n                : options.state || stateDB || undefined;\n            const model = new _jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4__.FilterFileBrowserModel({\n                translator: translator,\n                auto: (_a = options.auto) !== null && _a !== void 0 ? _a : true,\n                manager: docManager,\n                driveName: options.driveName || '',\n                refreshInterval: options.refreshInterval,\n                refreshStandby: () => {\n                    if (info) {\n                        return !info.isConnected || 'when-hidden';\n                    }\n                    return 'when-hidden';\n                },\n                state\n            });\n            const restore = options.restore;\n            const widget = new _jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4__.FileBrowser({ id, model, restore, translator, state });\n            // Track the newly created file browser.\n            void tracker.add(widget);\n            return widget;\n        };\n        return { createFileBrowser, tracker };\n    }\n};\n/**\n * The default file browser factory provider.\n */\nconst defaultFileBrowser = {\n    id: '@jupyterlab/filebrowser-extension:default-file-browser',\n    description: 'Provides the default file browser',\n    provides: _jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4__.IDefaultFileBrowser,\n    requires: [_jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4__.IFileBrowserFactory],\n    optional: [_jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.IRouter, _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.JupyterFrontEnd.ITreeResolver, _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.ILabShell, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_8__.ITranslator],\n    activate: async (app, fileBrowserFactory, router, tree, labShell, translator) => {\n        const { commands } = app;\n        const trans = (translator !== null && translator !== void 0 ? translator : _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_8__.nullTranslator).load('jupyterlab');\n        // Manually restore and load the default file browser.\n        const defaultBrowser = fileBrowserFactory.createFileBrowser('filebrowser', {\n            auto: false,\n            restore: false\n        });\n        // Set attributes when adding the browser to the UI\n        defaultBrowser.node.setAttribute('role', 'region');\n        defaultBrowser.node.setAttribute('aria-label', trans.__('File Browser Section'));\n        defaultBrowser.title.icon = _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_9__.folderIcon;\n        // Show the current file browser shortcut in its title.\n        const updateBrowserTitle = () => {\n            const binding = app.commands.keyBindings.find(b => b.command === CommandIDs.toggleBrowser);\n            if (binding) {\n                const ks = binding.keys.map(_lumino_commands__WEBPACK_IMPORTED_MODULE_11__.CommandRegistry.formatKeystroke).join(', ');\n                defaultBrowser.title.caption = trans.__('File Browser (%1)', ks);\n            }\n            else {\n                defaultBrowser.title.caption = trans.__('File Browser');\n            }\n        };\n        updateBrowserTitle();\n        app.commands.keyBindingChanged.connect(() => {\n            updateBrowserTitle();\n        });\n        void Private.restoreBrowser(defaultBrowser, commands, router, tree, app, labShell);\n        return defaultBrowser;\n    }\n};\n/**\n * A plugin providing download + copy download link commands in the context menu.\n *\n * Disabling this plugin will NOT disable downloading files from the server.\n * Users will still be able to retrieve files from the file download URLs the\n * server provides.\n */\nconst downloadPlugin = {\n    id: '@jupyterlab/filebrowser-extension:download',\n    description: 'Adds the download file commands. Disabling this plugin will NOT disable downloading files from the server, if the user enters the appropriate download URLs.',\n    requires: [_jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4__.IFileBrowserFactory, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_8__.ITranslator],\n    autoStart: true,\n    activate: (app, factory, translator) => {\n        const trans = translator.load('jupyterlab');\n        const { commands } = app;\n        const { tracker } = factory;\n        commands.addCommand(CommandIDs.download, {\n            execute: () => {\n                const widget = tracker.currentWidget;\n                if (widget) {\n                    return widget.download();\n                }\n            },\n            icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_9__.downloadIcon.bindprops({ stylesheet: 'menuItem' }),\n            label: trans.__('Download')\n        });\n        commands.addCommand(CommandIDs.copyDownloadLink, {\n            execute: () => {\n                const widget = tracker.currentWidget;\n                if (!widget) {\n                    return;\n                }\n                return widget.model.manager.services.contents\n                    .getDownloadUrl(widget.selectedItems().next().value.path)\n                    .then(url => {\n                    _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Clipboard.copyToSystem(url);\n                });\n            },\n            isVisible: () => \n            // So long as this command only handles one file at time, don't show it\n            // if multiple files are selected.\n            !!tracker.currentWidget &&\n                Array.from(tracker.currentWidget.selectedItems()).length === 1,\n            icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_9__.copyIcon.bindprops({ stylesheet: 'menuItem' }),\n            label: trans.__('Copy Download Link'),\n            mnemonic: 0\n        });\n    }\n};\n/**\n * A plugin to add the file browser widget to an ILabShell\n */\nconst browserWidget = {\n    id: '@jupyterlab/filebrowser-extension:widget',\n    description: 'Adds the file browser to the application shell.',\n    requires: [\n        _jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_3__.IDocumentManager,\n        _jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4__.IDefaultFileBrowser,\n        _jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4__.IFileBrowserFactory,\n        _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_5__.ISettingRegistry,\n        _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.IToolbarWidgetRegistry,\n        _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_8__.ITranslator,\n        _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.ILabShell,\n        _jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4__.IFileBrowserCommands\n    ],\n    optional: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ICommandPalette],\n    autoStart: true,\n    activate: (app, docManager, browser, factory, settingRegistry, toolbarRegistry, translator, labShell, \n    // Wait until file browser commands are ready before activating file browser widget\n    fileBrowserCommands, commandPalette) => {\n        const { commands } = app;\n        const { tracker } = factory;\n        const trans = translator.load('jupyterlab');\n        // Top-level toolbar\n        toolbarRegistry.addFactory(FILE_BROWSER_FACTORY, 'uploader', (browser) => new _jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4__.Uploader({ model: browser.model, translator }));\n        (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.setToolbar)(browser, (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.createToolbarFactory)(toolbarRegistry, settingRegistry, FILE_BROWSER_FACTORY, browserWidget.id, translator));\n        labShell.add(browser, 'left', { rank: 100, type: 'File Browser' });\n        commands.addCommand(CommandIDs.toggleBrowser, {\n            label: trans.__('File Browser'),\n            execute: () => {\n                if (browser.isHidden) {\n                    return commands.execute(CommandIDs.showBrowser, void 0);\n                }\n                return commands.execute(CommandIDs.hideBrowser, void 0);\n            }\n        });\n        commands.addCommand(CommandIDs.showBrowser, {\n            label: trans.__('Open the file browser for the provided `path`.'),\n            execute: args => {\n                const path = args.path || '';\n                const browserForPath = Private.getBrowserForPath(path, browser, factory);\n                // Check for browser not found\n                if (!browserForPath) {\n                    return;\n                }\n                // Shortcut if we are using the main file browser\n                if (browser === browserForPath) {\n                    labShell.activateById(browser.id);\n                    return;\n                }\n                else {\n                    const areas = ['left', 'right'];\n                    for (const area of areas) {\n                        for (const widget of labShell.widgets(area)) {\n                            if (widget.contains(browserForPath)) {\n                                labShell.activateById(widget.id);\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n        });\n        commands.addCommand(CommandIDs.hideBrowser, {\n            label: trans.__('Hide the file browser.'),\n            execute: () => {\n                const widget = tracker.currentWidget;\n                if (widget && !widget.isHidden) {\n                    labShell.collapseLeft();\n                }\n            }\n        });\n        commands.addCommand(CommandIDs.toggleNavigateToCurrentDirectory, {\n            label: trans.__('Show Active File in File Browser'),\n            isToggled: () => browser.navigateToCurrentDirectory,\n            execute: () => {\n                const value = !browser.navigateToCurrentDirectory;\n                const key = 'navigateToCurrentDirectory';\n                return settingRegistry\n                    .set(FILE_BROWSER_PLUGIN_ID, key, value)\n                    .catch((reason) => {\n                    console.error(`Failed to set navigateToCurrentDirectory setting`);\n                });\n            }\n        });\n        if (commandPalette) {\n            commandPalette.addItem({\n                command: CommandIDs.toggleNavigateToCurrentDirectory,\n                category: trans.__('File Operations')\n            });\n        }\n        // If the layout is a fresh session without saved data and not in single document\n        // mode, open file browser.\n        void labShell.restored.then(layout => {\n            if (layout.fresh && labShell.mode !== 'single-document') {\n                void commands.execute(CommandIDs.showBrowser, void 0);\n            }\n        });\n        void Promise.all([app.restored, browser.model.restored]).then(() => {\n            // Whether to automatically navigate to a document's current directory\n            labShell.currentChanged.connect(async (_, change) => {\n                if (browser.navigateToCurrentDirectory && change.newValue) {\n                    const { newValue } = change;\n                    const context = docManager.contextForWidget(newValue);\n                    if (context) {\n                        const { path } = context;\n                        try {\n                            await Private.navigateToPath(path, browser, factory, translator);\n                        }\n                        catch (reason) {\n                            console.warn(`${CommandIDs.goToPath} failed to open: ${path}`, reason);\n                        }\n                    }\n                }\n            });\n        });\n    }\n};\n/**\n * The default file browser share-file plugin\n *\n * This extension adds a \"Copy Shareable Link\" command that generates a copy-\n * pastable URL. This url can be used to open a particular file in JupyterLab,\n * handy for emailing links or bookmarking for reference.\n *\n * If you need to change how this link is generated (for instance, to copy a\n * /user-redirect URL for JupyterHub), disable this plugin and replace it\n * with another implementation.\n */\nconst shareFile = {\n    id: '@jupyterlab/filebrowser-extension:share-file',\n    description: 'Adds the \"Copy Shareable Link\" command; useful for JupyterHub deployment for example.',\n    requires: [_jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4__.IFileBrowserFactory, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_8__.ITranslator],\n    autoStart: true,\n    activate: (app, factory, translator) => {\n        const trans = translator.load('jupyterlab');\n        const { commands } = app;\n        const { tracker } = factory;\n        commands.addCommand(CommandIDs.copyShareableLink, {\n            execute: () => {\n                const widget = tracker.currentWidget;\n                const model = widget === null || widget === void 0 ? void 0 : widget.selectedItems().next();\n                if (model === undefined || model.done) {\n                    return;\n                }\n                _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Clipboard.copyToSystem(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__.PageConfig.getUrl({\n                    workspace: _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__.PageConfig.defaultWorkspace,\n                    treePath: model.value.path,\n                    toShare: true\n                }));\n            },\n            isVisible: () => !!tracker.currentWidget &&\n                Array.from(tracker.currentWidget.selectedItems()).length === 1,\n            icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_9__.linkIcon.bindprops({ stylesheet: 'menuItem' }),\n            label: trans.__('Copy Shareable Link')\n        });\n    }\n};\n/**\n * The \"Open With\" context menu.\n *\n * This is its own plugin in case you would like to disable this feature.\n * e.g. jupyter labextension disable @jupyterlab/filebrowser-extension:open-with\n */\nconst openWithPlugin = {\n    id: '@jupyterlab/filebrowser-extension:open-with',\n    description: 'Adds the open-with feature allowing an user to pick the non-preferred document viewer.',\n    requires: [_jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4__.IFileBrowserFactory],\n    autoStart: true,\n    activate: (app, factory) => {\n        const { docRegistry } = app;\n        const { tracker } = factory;\n        let items = [];\n        function updateOpenWithMenu(contextMenu) {\n            var _a, _b;\n            const openWith = (_b = (_a = contextMenu.menu.items.find(item => {\n                var _a;\n                return item.type === 'submenu' &&\n                    ((_a = item.submenu) === null || _a === void 0 ? void 0 : _a.id) === 'jp-contextmenu-open-with';\n            })) === null || _a === void 0 ? void 0 : _a.submenu) !== null && _b !== void 0 ? _b : null;\n            if (!openWith) {\n                return; // Bail early if the open with menu is not displayed\n            }\n            // clear the current menu items\n            items.forEach(item => item.dispose());\n            items.length = 0;\n            // Ensure that the menu is empty\n            openWith.clearItems();\n            // get the widget factories that could be used to open all of the items\n            // in the current filebrowser selection\n            const factories = tracker.currentWidget\n                ? Private.OpenWith.intersection((0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_10__.map)(tracker.currentWidget.selectedItems(), i => {\n                    return Private.OpenWith.getFactories(docRegistry, i);\n                }))\n                : new Set();\n            // make new menu items from the widget factories\n            items = [...factories].map(factory => openWith.addItem({\n                args: { factory: factory.name, label: factory.label || factory.name },\n                command: CommandIDs.open\n            }));\n        }\n        app.contextMenu.opened.connect(updateOpenWithMenu);\n    }\n};\n/**\n * The \"Open in New Browser Tab\" context menu.\n *\n * This is its own plugin in case you would like to disable this feature.\n * e.g. jupyter labextension disable @jupyterlab/filebrowser-extension:open-browser-tab\n *\n * Note: If disabling this, you may also want to disable:\n * @jupyterlab/docmanager-extension:open-browser-tab\n */\nconst openBrowserTabPlugin = {\n    id: '@jupyterlab/filebrowser-extension:open-browser-tab',\n    description: 'Adds the open-in-new-browser-tab features.',\n    requires: [_jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4__.IFileBrowserFactory, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_8__.ITranslator],\n    autoStart: true,\n    activate: (app, factory, translator) => {\n        const { commands } = app;\n        const trans = translator.load('jupyterlab');\n        const { tracker } = factory;\n        commands.addCommand(CommandIDs.openBrowserTab, {\n            execute: args => {\n                const widget = tracker.currentWidget;\n                if (!widget) {\n                    return;\n                }\n                const mode = args['mode'];\n                return Promise.all(Array.from((0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_10__.map)(widget.selectedItems(), item => {\n                    if (mode === 'single-document') {\n                        const url = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__.PageConfig.getUrl({\n                            mode: 'single-document',\n                            treePath: item.path\n                        });\n                        const opened = window.open();\n                        if (opened) {\n                            opened.opener = null;\n                            opened.location.href = url;\n                        }\n                        else {\n                            throw new Error('Failed to open new browser tab.');\n                        }\n                    }\n                    else {\n                        return commands.execute('docmanager:open-browser-tab', {\n                            path: item.path\n                        });\n                    }\n                })));\n            },\n            icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_9__.addIcon.bindprops({ stylesheet: 'menuItem' }),\n            label: args => args['mode'] === 'single-document'\n                ? trans.__('Open in Simple Mode')\n                : trans.__('Open in New Browser Tab'),\n            mnemonic: 0\n        });\n    }\n};\n/**\n * A plugin providing file upload status.\n */\nconst fileUploadStatus = {\n    id: '@jupyterlab/filebrowser-extension:file-upload-status',\n    description: 'Adds a file upload status widget.',\n    autoStart: true,\n    requires: [_jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4__.IFileBrowserFactory, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_8__.ITranslator],\n    optional: [_jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_7__.IStatusBar],\n    activate: (app, browser, translator, statusBar) => {\n        if (!statusBar) {\n            // Automatically disable if statusbar missing\n            return;\n        }\n        const item = new _jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4__.FileUploadStatus({\n            tracker: browser.tracker,\n            translator\n        });\n        statusBar.registerStatusItem('@jupyterlab/filebrowser-extension:file-upload-status', {\n            item,\n            align: 'middle',\n            isActive: () => {\n                return !!item.model && item.model.items.length > 0;\n            },\n            activeStateChanged: item.model.stateChanged\n        });\n    }\n};\n/**\n * A plugin to open files from remote URLs\n */\nconst openUrlPlugin = {\n    id: '@jupyterlab/filebrowser-extension:open-url',\n    description: 'Adds the feature \"Open files from remote URLs\".',\n    autoStart: true,\n    requires: [_jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_4__.IDefaultFileBrowser, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_8__.ITranslator],\n    optional: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ICommandPalette],\n    activate: (app, browser, translator, palette) => {\n        const { commands } = app;\n        const trans = translator.load('jupyterlab');\n        const command = CommandIDs.openUrl;\n        commands.addCommand(command, {\n            label: args => args.url ? trans.__('Open %1', args.url) : trans.__('Open from URL…'),\n            caption: args => args.url ? trans.__('Open %1', args.url) : trans.__('Open from URL'),\n            execute: async (args) => {\n                var _a, _b, _c;\n                let url = (_a = args === null || args === void 0 ? void 0 : args.url) !== null && _a !== void 0 ? _a : '';\n                if (!url) {\n                    url =\n                        (_b = (await _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.InputDialog.getText({\n                            label: trans.__('URL'),\n                            placeholder: 'https://example.com/path/to/file',\n                            title: trans.__('Open URL'),\n                            okLabel: trans.__('Open')\n                        })).value) !== null && _b !== void 0 ? _b : undefined;\n                }\n                if (!url) {\n                    return;\n                }\n                let type = '';\n                let blob;\n                // fetch the file from the URL\n                try {\n                    const req = await fetch(url);\n                    blob = await req.blob();\n                    type = (_c = req.headers.get('Content-Type')) !== null && _c !== void 0 ? _c : '';\n                }\n                catch (reason) {\n                    if (reason.response && reason.response.status !== 200) {\n                        reason.message = trans.__('Could not open URL: %1', url);\n                    }\n                    return (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.showErrorMessage)(trans.__('Cannot fetch'), reason);\n                }\n                // upload the content of the file to the server\n                try {\n                    const name = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__.PathExt.basename(url);\n                    const file = new File([blob], name, { type });\n                    const model = await browser.model.upload(file);\n                    return commands.execute('docmanager:open', {\n                        path: model.path\n                    });\n                }\n                catch (error) {\n                    return (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.showErrorMessage)(trans._p('showErrorMessage', 'Upload Error'), error);\n                }\n            }\n        });\n        if (palette) {\n            palette.addItem({\n                command,\n                category: trans.__('File Operations')\n            });\n        }\n    }\n};\n/**\n * Add the main file browser commands to the application's command registry.\n */\nfunction addCommands(app, browser, factory, translator, settingRegistry, commandPalette) {\n    const trans = translator.load('jupyterlab');\n    const { docRegistry: registry, commands } = app;\n    const { tracker } = factory;\n    const deleteToTrash = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__.PageConfig.getOption('delete_to_trash') === 'true';\n    commands.addCommand(CommandIDs.del, {\n        execute: () => {\n            const widget = tracker.currentWidget;\n            if (widget) {\n                return widget.delete();\n            }\n        },\n        icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_9__.closeIcon.bindprops({ stylesheet: 'menuItem' }),\n        label: deleteToTrash ? trans.__('Move to Trash') : trans.__('Delete'),\n        mnemonic: 0\n    });\n    commands.addCommand(CommandIDs.copy, {\n        execute: () => {\n            const widget = tracker.currentWidget;\n            if (widget) {\n                return widget.copy();\n            }\n        },\n        icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_9__.copyIcon.bindprops({ stylesheet: 'menuItem' }),\n        label: trans.__('Copy'),\n        mnemonic: 0\n    });\n    commands.addCommand(CommandIDs.cut, {\n        execute: () => {\n            const widget = tracker.currentWidget;\n            if (widget) {\n                return widget.cut();\n            }\n        },\n        icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_9__.cutIcon.bindprops({ stylesheet: 'menuItem' }),\n        label: trans.__('Cut')\n    });\n    commands.addCommand(CommandIDs.duplicate, {\n        execute: () => {\n            const widget = tracker.currentWidget;\n            if (widget) {\n                return widget.duplicate();\n            }\n        },\n        icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_9__.copyIcon.bindprops({ stylesheet: 'menuItem' }),\n        label: trans.__('Duplicate')\n    });\n    commands.addCommand(CommandIDs.goToPath, {\n        label: trans.__('Update the file browser to display the provided `path`.'),\n        execute: async (args) => {\n            var _a;\n            const path = args.path || '';\n            const showBrowser = !((_a = args === null || args === void 0 ? void 0 : args.dontShowBrowser) !== null && _a !== void 0 ? _a : false);\n            try {\n                const item = await Private.navigateToPath(path, browser, factory, translator);\n                if (item.type !== 'directory' && showBrowser) {\n                    const browserForPath = Private.getBrowserForPath(path, browser, factory);\n                    if (browserForPath) {\n                        browserForPath.clearSelectedItems();\n                        const parts = path.split('/');\n                        const name = parts[parts.length - 1];\n                        if (name) {\n                            await browserForPath.selectItemByName(name);\n                        }\n                    }\n                }\n            }\n            catch (reason) {\n                console.warn(`${CommandIDs.goToPath} failed to go to: ${path}`, reason);\n            }\n            if (showBrowser) {\n                return commands.execute(CommandIDs.showBrowser, { path });\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.goUp, {\n        label: 'go up',\n        execute: async () => {\n            const browserForPath = Private.getBrowserForPath('', browser, factory);\n            if (!browserForPath) {\n                return;\n            }\n            const { model } = browserForPath;\n            await model.restored;\n            void browserForPath.goUp();\n        }\n    });\n    commands.addCommand(CommandIDs.openPath, {\n        label: args => args.path ? trans.__('Open %1', args.path) : trans.__('Open from Path…'),\n        caption: args => args.path ? trans.__('Open %1', args.path) : trans.__('Open from path'),\n        execute: async (args) => {\n            var _a;\n            let path;\n            if (args === null || args === void 0 ? void 0 : args.path) {\n                path = args.path;\n            }\n            else {\n                path =\n                    (_a = (await _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.InputDialog.getText({\n                        label: trans.__('Path'),\n                        placeholder: '/path/relative/to/jlab/root',\n                        title: trans.__('Open Path'),\n                        okLabel: trans.__('Open')\n                    })).value) !== null && _a !== void 0 ? _a : undefined;\n            }\n            if (!path) {\n                return;\n            }\n            try {\n                const trailingSlash = path !== '/' && path.endsWith('/');\n                if (trailingSlash) {\n                    // The normal contents service errors on paths ending in slash\n                    path = path.slice(0, path.length - 1);\n                }\n                const browserForPath = Private.getBrowserForPath(path, browser, factory);\n                const { services } = browserForPath.model.manager;\n                const item = await services.contents.get(path, {\n                    content: false\n                });\n                if (trailingSlash && item.type !== 'directory') {\n                    throw new Error(`Path ${path}/ is not a directory`);\n                }\n                await commands.execute(CommandIDs.goToPath, {\n                    path,\n                    dontShowBrowser: args.dontShowBrowser\n                });\n                if (item.type === 'directory') {\n                    return;\n                }\n                return commands.execute('docmanager:open', { path });\n            }\n            catch (reason) {\n                if (reason.response && reason.response.status === 404) {\n                    reason.message = trans.__('Could not find path: %1', path);\n                }\n                return (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.showErrorMessage)(trans.__('Cannot open'), reason);\n            }\n        }\n    });\n    // Add the openPath command to the command palette\n    if (commandPalette) {\n        commandPalette.addItem({\n            command: CommandIDs.openPath,\n            category: trans.__('File Operations')\n        });\n    }\n    commands.addCommand(CommandIDs.open, {\n        execute: args => {\n            const factory = args['factory'] || void 0;\n            const widget = tracker.currentWidget;\n            if (!widget) {\n                return;\n            }\n            const { contents } = widget.model.manager.services;\n            return Promise.all(Array.from((0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_10__.map)(widget.selectedItems(), item => {\n                if (item.type === 'directory') {\n                    const localPath = contents.localPath(item.path);\n                    return widget.model.cd(`/${localPath}`);\n                }\n                return commands.execute('docmanager:open', {\n                    factory: factory,\n                    path: item.path\n                });\n            })));\n        },\n        icon: args => {\n            var _a;\n            const factory = args['factory'] || void 0;\n            if (factory) {\n                // if an explicit factory is passed...\n                const ft = registry.getFileType(factory);\n                // ...set an icon if the factory name corresponds to a file type name...\n                // ...or leave the icon blank\n                return (_a = ft === null || ft === void 0 ? void 0 : ft.icon) === null || _a === void 0 ? void 0 : _a.bindprops({ stylesheet: 'menuItem' });\n            }\n            else {\n                return _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_9__.folderIcon.bindprops({ stylesheet: 'menuItem' });\n            }\n        },\n        label: args => (args['label'] || args['factory'] || trans.__('Open')),\n        mnemonic: 0\n    });\n    commands.addCommand(CommandIDs.paste, {\n        execute: () => {\n            const widget = tracker.currentWidget;\n            if (widget) {\n                return widget.paste();\n            }\n        },\n        icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_9__.pasteIcon.bindprops({ stylesheet: 'menuItem' }),\n        label: trans.__('Paste'),\n        mnemonic: 0\n    });\n    commands.addCommand(CommandIDs.createNewDirectory, {\n        execute: () => {\n            const widget = tracker.currentWidget;\n            if (widget) {\n                return widget.createNewDirectory();\n            }\n        },\n        icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_9__.newFolderIcon.bindprops({ stylesheet: 'menuItem' }),\n        label: trans.__('New Folder')\n    });\n    commands.addCommand(CommandIDs.createNewFile, {\n        execute: () => {\n            const widget = tracker.currentWidget;\n            if (widget) {\n                return widget.createNewFile({ ext: 'txt' });\n            }\n        },\n        icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_9__.textEditorIcon.bindprops({ stylesheet: 'menuItem' }),\n        label: trans.__('New File')\n    });\n    commands.addCommand(CommandIDs.createNewMarkdownFile, {\n        execute: () => {\n            const widget = tracker.currentWidget;\n            if (widget) {\n                return widget.createNewFile({ ext: 'md' });\n            }\n        },\n        icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_9__.markdownIcon.bindprops({ stylesheet: 'menuItem' }),\n        label: trans.__('New Markdown File')\n    });\n    commands.addCommand(CommandIDs.refresh, {\n        execute: args => {\n            const widget = tracker.currentWidget;\n            if (widget) {\n                return widget.model.refresh();\n            }\n        },\n        icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_9__.refreshIcon.bindprops({ stylesheet: 'menuItem' }),\n        caption: trans.__('Refresh the file browser.'),\n        label: trans.__('Refresh File List')\n    });\n    commands.addCommand(CommandIDs.rename, {\n        execute: args => {\n            const widget = tracker.currentWidget;\n            if (widget) {\n                return widget.rename();\n            }\n        },\n        isVisible: () => \n        // So long as this command only handles one file at time, don't show it\n        // if multiple files are selected.\n        !!tracker.currentWidget &&\n            Array.from(tracker.currentWidget.selectedItems()).length === 1,\n        icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_9__.editIcon.bindprops({ stylesheet: 'menuItem' }),\n        label: trans.__('Rename'),\n        mnemonic: 0\n    });\n    commands.addCommand(CommandIDs.copyPath, {\n        execute: () => {\n            var _a;\n            const widget = tracker.currentWidget;\n            if (!widget) {\n                return;\n            }\n            const item = widget.selectedItems().next();\n            if (item.done) {\n                return;\n            }\n            if (_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__.PageConfig.getOption('copyAbsolutePath') === 'true') {\n                const absolutePath = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__.PathExt.joinWithLeadingSlash((_a = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__.PageConfig.getOption('serverRoot')) !== null && _a !== void 0 ? _a : '', item.value.path);\n                _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Clipboard.copyToSystem(absolutePath);\n            }\n            else {\n                _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Clipboard.copyToSystem(item.value.path);\n            }\n        },\n        isVisible: () => \n        // So long as this command only handles one file at time, don't show it\n        // if multiple files are selected.\n        !!tracker.currentWidget &&\n            Array.from(tracker.currentWidget.selectedItems()).length === 1,\n        icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_9__.fileIcon.bindprops({ stylesheet: 'menuItem' }),\n        label: trans.__('Copy Path')\n    });\n    commands.addCommand(CommandIDs.shutdown, {\n        execute: () => {\n            const widget = tracker.currentWidget;\n            if (widget) {\n                return widget.shutdownKernels();\n            }\n        },\n        icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_9__.stopIcon.bindprops({ stylesheet: 'menuItem' }),\n        label: trans.__('Shut Down Kernel')\n    });\n    commands.addCommand(CommandIDs.toggleFileFilter, {\n        execute: () => {\n            // Update toggled state, then let the toolbar button update\n            browser.showFileFilter = !browser.showFileFilter;\n            commands.notifyCommandChanged(CommandIDs.toggleFileFilter);\n        },\n        isToggled: () => {\n            const toggled = browser.showFileFilter;\n            return toggled;\n        },\n        icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_9__.filterIcon.bindprops({ stylesheet: 'menuItem' }),\n        label: trans.__('Toggle File Filter')\n    });\n    commands.addCommand(CommandIDs.toggleLastModified, {\n        label: trans.__('Show Last Modified Column'),\n        isToggled: () => browser.showLastModifiedColumn,\n        execute: () => {\n            const value = !browser.showLastModifiedColumn;\n            const key = 'showLastModifiedColumn';\n            if (settingRegistry) {\n                return settingRegistry\n                    .set(FILE_BROWSER_PLUGIN_ID, key, value)\n                    .catch((reason) => {\n                    console.error(`Failed to set ${key} setting`);\n                });\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.toggleShowFullPath, {\n        label: trans.__('Show Full Path'),\n        isToggled: () => browser.showFullPath,\n        execute: () => {\n            const value = !browser.showFullPath;\n            const key = 'showFullPath';\n            if (settingRegistry) {\n                return settingRegistry\n                    .set(FILE_BROWSER_PLUGIN_ID, key, value)\n                    .catch((reason) => {\n                    console.error(`Failed to set ${key} setting`);\n                });\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.toggleSortNotebooksFirst, {\n        label: trans.__('Sort Notebooks Above Files'),\n        isToggled: () => browser.sortNotebooksFirst,\n        execute: () => {\n            const value = !browser.sortNotebooksFirst;\n            const key = 'sortNotebooksFirst';\n            if (settingRegistry) {\n                return settingRegistry\n                    .set(FILE_BROWSER_PLUGIN_ID, key, value)\n                    .catch((reason) => {\n                    console.error(`Failed to set ${key} setting`);\n                });\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.toggleFileSize, {\n        label: trans.__('Show File Size Column'),\n        isToggled: () => browser.showFileSizeColumn,\n        execute: () => {\n            const value = !browser.showFileSizeColumn;\n            const key = 'showFileSizeColumn';\n            if (settingRegistry) {\n                return settingRegistry\n                    .set(FILE_BROWSER_PLUGIN_ID, key, value)\n                    .catch((reason) => {\n                    console.error(`Failed to set ${key} setting`);\n                });\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.toggleSingleClick, {\n        label: trans.__('Enable Single Click Navigation'),\n        isToggled: () => browser.singleClickNavigation,\n        execute: () => {\n            const value = !browser.singleClickNavigation;\n            const key = 'singleClickNavigation';\n            if (settingRegistry) {\n                return settingRegistry\n                    .set(FILE_BROWSER_PLUGIN_ID, key, value)\n                    .catch((reason) => {\n                    console.error(`Failed to set singleClickNavigation setting`);\n                });\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.toggleHiddenFiles, {\n        label: trans.__('Show Hidden Files'),\n        isToggled: () => browser.showHiddenFiles,\n        isVisible: () => _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__.PageConfig.getOption('allow_hidden_files') === 'true',\n        execute: () => {\n            const value = !browser.showHiddenFiles;\n            const key = 'showHiddenFiles';\n            if (settingRegistry) {\n                return settingRegistry\n                    .set(FILE_BROWSER_PLUGIN_ID, key, value)\n                    .catch((reason) => {\n                    console.error(`Failed to set showHiddenFiles setting`);\n                });\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.toggleFileCheckboxes, {\n        label: trans.__('Show File Checkboxes'),\n        isToggled: () => browser.showFileCheckboxes,\n        execute: () => {\n            const value = !browser.showFileCheckboxes;\n            const key = 'showFileCheckboxes';\n            if (settingRegistry) {\n                return settingRegistry\n                    .set(FILE_BROWSER_PLUGIN_ID, key, value)\n                    .catch((reason) => {\n                    console.error(`Failed to set showFileCheckboxes setting`);\n                });\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.search, {\n        label: trans.__('Search on File Names'),\n        execute: () => alert('search')\n    });\n}\n/**\n * Export the plugins as default.\n */\nconst plugins = [\n    factory,\n    defaultFileBrowser,\n    browser,\n    browserSettings,\n    shareFile,\n    fileUploadStatus,\n    downloadPlugin,\n    browserWidget,\n    openWithPlugin,\n    openBrowserTabPlugin,\n    openUrlPlugin\n];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugins);\n/**\n * A namespace for private module data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Get browser object given file path.\n     */\n    function getBrowserForPath(path, browser, factory) {\n        const { tracker } = factory;\n        const driveName = browser.model.manager.services.contents.driveName(path);\n        if (driveName) {\n            const browserForPath = tracker.find(_path => _path.model.driveName === driveName);\n            if (!browserForPath) {\n                // warn that no filebrowser could be found for this driveName\n                console.warn(`${CommandIDs.goToPath} failed to find filebrowser for path: ${path}`);\n                return;\n            }\n            return browserForPath;\n        }\n        // if driveName is empty, assume the main filebrowser\n        return browser;\n    }\n    Private.getBrowserForPath = getBrowserForPath;\n    /**\n     * Navigate to a path or the path containing a file.\n     */\n    async function navigateToPath(path, browser, factory, translator) {\n        const trans = translator.load('jupyterlab');\n        const browserForPath = Private.getBrowserForPath(path, browser, factory);\n        if (!browserForPath) {\n            throw new Error(trans.__('No browser for path'));\n        }\n        const { services } = browserForPath.model.manager;\n        const localPath = services.contents.localPath(path);\n        await services.ready;\n        const item = await services.contents.get(path, { content: false });\n        const { model } = browserForPath;\n        await model.restored;\n        if (item.type === 'directory') {\n            await model.cd(`/${localPath}`);\n        }\n        else {\n            await model.cd(`/${_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__.PathExt.dirname(localPath)}`);\n        }\n        return item;\n    }\n    Private.navigateToPath = navigateToPath;\n    /**\n     * Restores file browser state and overrides state if tree resolver resolves.\n     */\n    async function restoreBrowser(browser, commands, router, tree, app, labShell) {\n        const restoring = 'jp-mod-restoring';\n        browser.addClass(restoring);\n        if (!router) {\n            await browser.model.restore(browser.id);\n            await browser.model.refresh();\n            browser.removeClass(restoring);\n            return;\n        }\n        const listener = async () => {\n            router.routed.disconnect(listener);\n            const paths = await (tree === null || tree === void 0 ? void 0 : tree.paths);\n            if ((paths === null || paths === void 0 ? void 0 : paths.file) || (paths === null || paths === void 0 ? void 0 : paths.browser)) {\n                // Restore the model without populating it.\n                await browser.model.restore(browser.id, false);\n                if (paths.file) {\n                    await commands.execute(CommandIDs.openPath, {\n                        path: paths.file,\n                        dontShowBrowser: true\n                    });\n                }\n                if (paths.browser) {\n                    await commands.execute(CommandIDs.openPath, {\n                        path: paths.browser,\n                        dontShowBrowser: true\n                    });\n                }\n            }\n            else {\n                await browser.model.restore(browser.id);\n                await browser.model.refresh();\n            }\n            browser.removeClass(restoring);\n            if (labShell === null || labShell === void 0 ? void 0 : labShell.isEmpty('main')) {\n                void commands.execute('launcher:create');\n            }\n        };\n        router.routed.connect(listener);\n    }\n    Private.restoreBrowser = restoreBrowser;\n    let OpenWith;\n    (function (OpenWith) {\n        /**\n         * Get the factories for the selected item\n         *\n         * @param docRegistry Application document registry\n         * @param item Selected item model\n         * @returns Available factories for the model\n         */\n        function getFactories(docRegistry, item) {\n            const factories = docRegistry.preferredWidgetFactories(item.path);\n            const notebookFactory = docRegistry.getWidgetFactory('notebook');\n            if (notebookFactory &&\n                item.type === 'notebook' &&\n                factories.indexOf(notebookFactory) === -1) {\n                factories.unshift(notebookFactory);\n            }\n            return factories;\n        }\n        OpenWith.getFactories = getFactories;\n        /**\n         * Return the intersection of multiple iterables.\n         *\n         * @param iterables Iterator of iterables\n         * @returns Set of common elements to all iterables\n         */\n        function intersection(iterables) {\n            let accumulator = undefined;\n            for (const current of iterables) {\n                // Initialize accumulator.\n                if (accumulator === undefined) {\n                    accumulator = new Set(current);\n                    continue;\n                }\n                // Return early if empty.\n                if (accumulator.size === 0) {\n                    return accumulator;\n                }\n                // Keep the intersection of accumulator and current.\n                let intersection = new Set();\n                for (const value of current) {\n                    if (accumulator.has(value)) {\n                        intersection.add(value);\n                    }\n                }\n                accumulator = intersection;\n            }\n            return accumulator !== null && accumulator !== void 0 ? accumulator : new Set();\n        }\n        OpenWith.intersection = intersection;\n    })(OpenWith = Private.OpenWith || (Private.OpenWith = {}));\n})(Private || (Private = {}));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/filebrowser-extension/lib/index.js?");

/***/ })

}]);