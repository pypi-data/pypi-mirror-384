"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["vendors-node_modules_lumino_polling_dist_index_es6_js"],{

/***/ "../node_modules/@lumino/polling/dist/index.es6.js":
/*!*********************************************************!*\
  !*** ../node_modules/@lumino/polling/dist/index.es6.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Debouncer: () => (/* binding */ Debouncer),\n/* harmony export */   Poll: () => (/* binding */ Poll),\n/* harmony export */   RateLimiter: () => (/* binding */ RateLimiter),\n/* harmony export */   Throttler: () => (/* binding */ Throttler)\n/* harmony export */ });\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ \"webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/signaling */ \"webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling\");\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * A class that wraps an asynchronous function to poll at a regular interval\n * with exponential increases to the interval length if the poll fails.\n *\n * @typeparam T - The resolved type of the factory's promises.\n * Defaults to `any`.\n *\n * @typeparam U - The rejected type of the factory's promises.\n * Defaults to `any`.\n *\n * @typeparam V - An optional type to extend the phases supported by a poll.\n * Defaults to `standby`, which already exists in the `Phase` type.\n */\nclass Poll {\n    /**\n     * Instantiate a new poll with exponential backoff in case of failure.\n     *\n     * @param options - The poll instantiation options.\n     */\n    constructor(options) {\n        var _a;\n        this._disposed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);\n        this._lingered = 0;\n        this._tick = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.PromiseDelegate();\n        this._ticked = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);\n        this._factory = options.factory;\n        this._linger = (_a = options.linger) !== null && _a !== void 0 ? _a : Private.DEFAULT_LINGER;\n        this._standby = options.standby || Private.DEFAULT_STANDBY;\n        this._state = { ...Private.DEFAULT_STATE, timestamp: new Date().getTime() };\n        // Normalize poll frequency `max` to be the greater of\n        // default `max`, `options.frequency.max`, or `options.frequency.interval`.\n        const frequency = options.frequency || {};\n        const max = Math.max(frequency.interval || 0, frequency.max || 0, Private.DEFAULT_FREQUENCY.max);\n        this.frequency = { ...Private.DEFAULT_FREQUENCY, ...frequency, ...{ max } };\n        this.name = options.name || Private.DEFAULT_NAME;\n        if ('auto' in options ? options.auto : true) {\n            setTimeout(() => this.start());\n        }\n    }\n    /**\n     * A signal emitted when the poll is disposed.\n     */\n    get disposed() {\n        return this._disposed;\n    }\n    /**\n     * The polling frequency parameters.\n     */\n    get frequency() {\n        return this._frequency;\n    }\n    set frequency(frequency) {\n        if (this.isDisposed || _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual(frequency, this.frequency || {})) {\n            return;\n        }\n        let { backoff, interval, max } = frequency;\n        interval = Math.round(interval);\n        max = Math.round(max);\n        if (typeof backoff === 'number' && backoff < 1) {\n            throw new Error('Poll backoff growth factor must be at least 1');\n        }\n        if ((interval < 0 || interval > max) && interval !== Poll.NEVER) {\n            throw new Error('Poll interval must be between 0 and max');\n        }\n        if (max > Poll.MAX_INTERVAL && max !== Poll.NEVER) {\n            throw new Error(`Max interval must be less than ${Poll.MAX_INTERVAL}`);\n        }\n        this._frequency = { backoff, interval, max };\n    }\n    /**\n     * Whether the poll is disposed.\n     */\n    get isDisposed() {\n        return this.state.phase === 'disposed';\n    }\n    /**\n     * Indicates when the poll switches to standby.\n     */\n    get standby() {\n        return this._standby;\n    }\n    set standby(standby) {\n        if (this.isDisposed || this.standby === standby) {\n            return;\n        }\n        this._standby = standby;\n    }\n    /**\n     * The poll state, which is the content of the current poll tick.\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     * A promise that resolves when the poll next ticks.\n     */\n    get tick() {\n        return this._tick.promise;\n    }\n    /**\n     * A signal emitted when the poll ticks and fires off a new request.\n     */\n    get ticked() {\n        return this._ticked;\n    }\n    /**\n     * Return an async iterator that yields every tick.\n     */\n    async *[Symbol.asyncIterator]() {\n        while (!this.isDisposed) {\n            yield this.state;\n            await this.tick.catch(() => undefined);\n        }\n    }\n    /**\n     * Dispose the poll.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._state = {\n            ...Private.DISPOSED_STATE,\n            timestamp: new Date().getTime()\n        };\n        this._tick.promise.catch(_ => undefined);\n        this._tick.reject(new Error(`Poll (${this.name}) is disposed.`));\n        this._disposed.emit(undefined);\n        _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal.clearData(this);\n    }\n    /**\n     * Refreshes the poll. Schedules `refreshed` tick if necessary.\n     *\n     * @returns A promise that resolves after tick is scheduled and never rejects.\n     *\n     * #### Notes\n     * The returned promise resolves after the tick is scheduled, but before\n     * the polling action is run. To wait until after the poll action executes,\n     * await the `poll.tick` promise: `await poll.refresh(); await poll.tick;`\n     */\n    refresh() {\n        return this.schedule({\n            cancel: ({ phase }) => phase === 'refreshed',\n            interval: Poll.IMMEDIATE,\n            phase: 'refreshed'\n        });\n    }\n    /**\n     * Schedule the next poll tick.\n     *\n     * @param next - The next poll state data to schedule. Defaults to standby.\n     *\n     * @param next.cancel - Cancels state transition if function returns `true`.\n     *\n     * @returns A promise that resolves when the next poll state is active.\n     *\n     * #### Notes\n     * This method is not meant to be invoked by user code typically. It is public\n     * to allow poll instances to be composed into classes that schedule ticks.\n     */\n    async schedule(next = {}) {\n        if (this.isDisposed) {\n            return;\n        }\n        // Check if the phase transition should be canceled.\n        if (next.cancel && next.cancel(this.state)) {\n            return;\n        }\n        // Update poll state.\n        const pending = this._tick;\n        const scheduled = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.PromiseDelegate();\n        const state = {\n            interval: this.frequency.interval,\n            payload: null,\n            phase: 'standby',\n            timestamp: new Date().getTime(),\n            ...next\n        };\n        this._state = state;\n        this._tick = scheduled;\n        // Clear the schedule if possible.\n        clearTimeout(this._timeout);\n        // Emit ticked signal, resolve pending promise, and await its settlement.\n        this._ticked.emit(this.state);\n        pending.resolve(this);\n        await pending.promise;\n        if (state.interval === Poll.NEVER) {\n            this._timeout = undefined;\n            return;\n        }\n        // Schedule next execution and cache its timeout handle.\n        const execute = () => {\n            if (this.isDisposed || this.tick !== scheduled.promise) {\n                return;\n            }\n            this._execute();\n        };\n        // Cache the handle in case it needs to be unscheduled.\n        this._timeout = setTimeout(execute, state.interval);\n    }\n    /**\n     * Starts the poll. Schedules `started` tick if necessary.\n     *\n     * @returns A promise that resolves after tick is scheduled and never rejects.\n     */\n    start() {\n        return this.schedule({\n            cancel: ({ phase }) => phase !== 'constructed' && phase !== 'standby' && phase !== 'stopped',\n            interval: Poll.IMMEDIATE,\n            phase: 'started'\n        });\n    }\n    /**\n     * Stops the poll. Schedules `stopped` tick if necessary.\n     *\n     * @returns A promise that resolves after tick is scheduled and never rejects.\n     */\n    stop() {\n        return this.schedule({\n            cancel: ({ phase }) => phase === 'stopped',\n            interval: Poll.NEVER,\n            phase: 'stopped'\n        });\n    }\n    /**\n     * Whether the poll is hidden.\n     *\n     * #### Notes\n     * This property is only relevant in a browser context.\n     */\n    get hidden() {\n        return Private.hidden;\n    }\n    /**\n     * Execute a new poll factory promise or stand by if necessary.\n     */\n    _execute() {\n        let standby = typeof this.standby === 'function' ? this.standby() : this.standby;\n        // Check if execution should proceed, linger, or stand by.\n        if (standby === 'never') {\n            standby = false;\n        }\n        else if (standby === 'when-hidden') {\n            if (this.hidden) {\n                standby = ++this._lingered > this._linger;\n            }\n            else {\n                this._lingered = 0;\n                standby = false;\n            }\n        }\n        // If in standby mode schedule next tick without calling the factory.\n        if (standby) {\n            void this.schedule();\n            return;\n        }\n        const pending = this.tick;\n        this._factory(this.state)\n            .then((resolved) => {\n            if (this.isDisposed || this.tick !== pending) {\n                return;\n            }\n            void this.schedule({\n                payload: resolved,\n                phase: this.state.phase === 'rejected' ? 'reconnected' : 'resolved'\n            });\n        })\n            .catch((rejected) => {\n            if (this.isDisposed || this.tick !== pending) {\n                return;\n            }\n            void this.schedule({\n                interval: Private.sleep(this.frequency, this.state),\n                payload: rejected,\n                phase: 'rejected'\n            });\n        });\n    }\n}\n/**\n * A namespace for `Poll` types, interfaces, and statics.\n */\n(function (Poll) {\n    /**\n     * An interval value in ms that indicates the poll should tick immediately.\n     */\n    Poll.IMMEDIATE = 0;\n    /**\n     * Delays are 32-bit integers in many browsers so intervals need to be capped.\n     *\n     * #### Notes\n     * https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout#Maximum_delay_value\n     */\n    Poll.MAX_INTERVAL = 2147483647;\n    /**\n     * An interval value that indicates the poll should never tick.\n     */\n    Poll.NEVER = Infinity;\n})(Poll || (Poll = {}));\n/**\n * A namespace for private module data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The default backoff growth rate if `backoff` is `true`.\n     */\n    Private.DEFAULT_BACKOFF = 3;\n    /**\n     * The default polling frequency.\n     */\n    Private.DEFAULT_FREQUENCY = {\n        backoff: true,\n        interval: 1000,\n        max: 30 * 1000\n    };\n    /**\n     * The default number of times to `linger` when a poll is hidden.\n     */\n    Private.DEFAULT_LINGER = 1;\n    /**\n     * The default poll name.\n     */\n    Private.DEFAULT_NAME = 'unknown';\n    /**\n     * The default poll standby behavior.\n     */\n    Private.DEFAULT_STANDBY = 'when-hidden';\n    /**\n     * The first poll tick state's default values superseded in constructor.\n     */\n    Private.DEFAULT_STATE = {\n        interval: Poll.NEVER,\n        payload: null,\n        phase: 'constructed',\n        timestamp: new Date(0).getTime()\n    };\n    /**\n     * The disposed tick state values.\n     */\n    Private.DISPOSED_STATE = {\n        interval: Poll.NEVER,\n        payload: null,\n        phase: 'disposed',\n        timestamp: new Date(0).getTime()\n    };\n    /**\n     * Returns the number of milliseconds to sleep before the next tick.\n     *\n     * @param frequency - The poll's base frequency.\n     * @param last - The poll's last tick.\n     */\n    function sleep(frequency, last) {\n        const { backoff, interval, max } = frequency;\n        if (interval === Poll.NEVER) {\n            return interval;\n        }\n        const growth = backoff === true ? Private.DEFAULT_BACKOFF : backoff === false ? 1 : backoff;\n        const random = getRandomIntInclusive(interval, last.interval * growth);\n        return Math.min(max, random);\n    }\n    Private.sleep = sleep;\n    /**\n     * Keep track of whether the document is hidden. This flag is only relevant in\n     * a browser context.\n     *\n     * Listen to `visibilitychange` event to set the `hidden` flag.\n     *\n     * Listening to `pagehide` is also necessary because Safari support for\n     * `visibilitychange` events is partial, cf.\n     * https://developer.mozilla.org/docs/Web/API/Document/visibilitychange_event\n     */\n    Private.hidden = (() => {\n        if (typeof document === 'undefined') {\n            return false;\n        }\n        document.addEventListener('visibilitychange', () => {\n            Private.hidden = document.visibilityState === 'hidden';\n        });\n        document.addEventListener('pagehide', () => {\n            Private.hidden = document.visibilityState === 'hidden';\n        });\n        return document.visibilityState === 'hidden';\n    })();\n    /**\n     * Get a random integer between min and max, inclusive of both.\n     *\n     * #### Notes\n     * From\n     * https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Math/random#Getting_a_random_integer_between_two_values_inclusive\n     *\n     * From the MDN page: It might be tempting to use Math.round() to accomplish\n     * that, but doing so would cause your random numbers to follow a non-uniform\n     * distribution, which may not be acceptable for your needs.\n     */\n    function getRandomIntInclusive(min, max) {\n        min = Math.ceil(min);\n        max = Math.floor(max);\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n})(Private || (Private = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * A base class to implement rate limiters with different invocation strategies.\n *\n * @typeparam T - The resolved type of the underlying function.\n *\n * @typeparam U - The rejected type of the underlying function.\n *\n * @typeparam V - Arguments for the underlying function.\n */\nclass RateLimiter {\n    /**\n     * Instantiate a rate limiter.\n     *\n     * @param fn - The function to rate limit.\n     *\n     * @param limit - The rate limit; defaults to 500ms.\n     */\n    constructor(fn, limit = 500) {\n        /**\n         * Arguments for the underlying function.\n         */\n        this.args = undefined;\n        /**\n         * A promise that resolves on each successful invocation.\n         */\n        this.payload = null;\n        this.limit = limit;\n        this.poll = new Poll({\n            auto: false,\n            factory: async () => {\n                const { args } = this;\n                this.args = undefined;\n                return fn(...args);\n            },\n            frequency: { backoff: false, interval: Poll.NEVER, max: Poll.NEVER },\n            standby: 'never'\n        });\n        this.payload = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.PromiseDelegate();\n        this.poll.ticked.connect((_, state) => {\n            const { payload } = this;\n            if (state.phase === 'resolved') {\n                this.payload = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.PromiseDelegate();\n                payload.resolve(state.payload);\n                return;\n            }\n            if (state.phase === 'rejected' || state.phase === 'stopped') {\n                this.payload = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.PromiseDelegate();\n                payload.promise.catch(_ => undefined);\n                payload.reject(state.payload);\n                return;\n            }\n        }, this);\n    }\n    /**\n     * Whether the rate limiter is disposed.\n     */\n    get isDisposed() {\n        return this.payload === null;\n    }\n    /**\n     * Disposes the rate limiter.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this.args = undefined;\n        this.payload = null;\n        this.poll.dispose();\n    }\n    /**\n     * Stop the function if it is mid-flight.\n     */\n    async stop() {\n        return this.poll.stop();\n    }\n}\n/**\n * Wraps and debounces a function that can be called multiple times and only\n * executes the underlying function one `interval` after the last invocation.\n *\n * @typeparam T - The resolved type of the underlying function. Defaults to any.\n *\n * @typeparam U - The rejected type of the underlying function. Defaults to any.\n *\n * @typeparam V - Arguments for the underlying function. Defaults to any[].\n */\nclass Debouncer extends RateLimiter {\n    /**\n     * Invokes the function and only executes after rate limit has elapsed.\n     * Each invocation resets the timer.\n     */\n    invoke(...args) {\n        this.args = args;\n        void this.poll.schedule({ interval: this.limit, phase: 'invoked' });\n        return this.payload.promise;\n    }\n}\n/**\n * Wraps and throttles a function that can be called multiple times and only\n * executes the underlying function once per `interval`.\n *\n * @typeparam T - The resolved type of the underlying function. Defaults to any.\n *\n * @typeparam U - The rejected type of the underlying function. Defaults to any.\n *\n * @typeparam V - Arguments for the underlying function. Defaults to any[].\n */\nclass Throttler extends RateLimiter {\n    /**\n     * Instantiate a throttler.\n     *\n     * @param fn - The function being throttled.\n     *\n     * @param options - Throttling configuration or throttling limit in ms.\n     *\n     * #### Notes\n     * The `edge` defaults to `leading`; the `limit` defaults to `500`.\n     */\n    constructor(fn, options) {\n        super(fn, typeof options === 'number' ? options : options && options.limit);\n        this._trailing = false;\n        if (typeof options !== 'number' && options && options.edge === 'trailing') {\n            this._trailing = true;\n        }\n        this._interval = this._trailing ? this.limit : Poll.IMMEDIATE;\n    }\n    /**\n     * Throttles function invocations if one is currently in flight.\n     */\n    invoke(...args) {\n        const idle = this.poll.state.phase !== 'invoked';\n        if (idle || this._trailing) {\n            this.args = args;\n        }\n        if (idle) {\n            void this.poll.schedule({ interval: this._interval, phase: 'invoked' });\n        }\n        return this.payload.promise;\n    }\n}\n\n\n//# sourceMappingURL=index.es6.js.map\n\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/polling/dist/index.es6.js?");

/***/ })

}]);