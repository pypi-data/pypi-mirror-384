"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["vendors-node_modules_jupyterlab_cells_lib_index_js"],{

/***/ "../node_modules/@jupyterlab/attachments/lib/model.js":
/*!************************************************************!*\
  !*** ../node_modules/@jupyterlab/attachments/lib/model.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AttachmentsModel: () => (/* binding */ AttachmentsModel),\n/* harmony export */   AttachmentsResolver: () => (/* binding */ AttachmentsResolver)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/observables */ \"webpack/sharing/consume/default/@jupyterlab/observables/@jupyterlab/observables\");\n/* harmony import */ var _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_observables__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/rendermime */ \"webpack/sharing/consume/default/@jupyterlab/rendermime/@jupyterlab/rendermime\");\n/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/signaling */ \"webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling\");\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_2__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\n\n\n/**\n * The default implementation of the IAttachmentsModel.\n */\nclass AttachmentsModel {\n    /**\n     * Construct a new observable outputs instance.\n     */\n    constructor(options) {\n        var _a;\n        this._map = new _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_0__.ObservableMap();\n        this._isDisposed = false;\n        this._stateChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__.Signal(this);\n        this._changed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__.Signal(this);\n        this._serialized = null;\n        this._changeGuard = false;\n        this.contentFactory =\n            (_a = options.contentFactory) !== null && _a !== void 0 ? _a : AttachmentsModel.defaultContentFactory;\n        if (options.values) {\n            for (const key of Object.keys(options.values)) {\n                if (options.values[key] !== undefined) {\n                    this.set(key, options.values[key]);\n                }\n            }\n        }\n        this._map.changed.connect(this._onMapChanged, this);\n    }\n    /**\n     * A signal emitted when the model state changes.\n     */\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    /**\n     * A signal emitted when the model changes.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * The keys of the attachments in the model.\n     */\n    get keys() {\n        return this._map.keys();\n    }\n    /**\n     * Get the length of the items in the model.\n     */\n    get length() {\n        return this._map.keys().length;\n    }\n    /**\n     * Test whether the model is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources used by the model.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this._map.dispose();\n        _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__.Signal.clearData(this);\n    }\n    /**\n     * Whether the specified key is set.\n     */\n    has(key) {\n        return this._map.has(key);\n    }\n    /**\n     * Get an item at the specified key.\n     */\n    get(key) {\n        return this._map.get(key);\n    }\n    /**\n     * Set the value at the specified key.\n     */\n    set(key, value) {\n        // Normalize stream data.\n        const item = this._createItem({ value });\n        this._map.set(key, item);\n    }\n    /**\n     * Remove the attachment whose name is the specified key\n     */\n    remove(key) {\n        this._map.delete(key);\n    }\n    /**\n     * Clear all of the attachments.\n     */\n    clear() {\n        this._map.values().forEach((item) => {\n            item.dispose();\n        });\n        this._map.clear();\n    }\n    /**\n     * Deserialize the model from JSON.\n     *\n     * #### Notes\n     * This will clear any existing data.\n     */\n    fromJSON(values) {\n        this.clear();\n        Object.keys(values).forEach(key => {\n            if (values[key] !== undefined) {\n                this.set(key, values[key]);\n            }\n        });\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        const ret = {};\n        for (const key of this._map.keys()) {\n            ret[key] = this._map.get(key).toJSON();\n        }\n        return ret;\n    }\n    /**\n     * Create an attachment item and hook up its signals.\n     */\n    _createItem(options) {\n        const factory = this.contentFactory;\n        const item = factory.createAttachmentModel(options);\n        item.changed.connect(this._onGenericChange, this);\n        return item;\n    }\n    /**\n     * Handle a change to the list.\n     */\n    _onMapChanged(sender, args) {\n        if (this._serialized && !this._changeGuard) {\n            this._changeGuard = true;\n            this._serialized.set(this.toJSON());\n            this._changeGuard = false;\n        }\n        this._changed.emit(args);\n        this._stateChanged.emit(void 0);\n    }\n    /**\n     * Handle a change to an item.\n     */\n    _onGenericChange() {\n        this._stateChanged.emit(void 0);\n    }\n}\n/**\n * The namespace for AttachmentsModel class statics.\n */\n(function (AttachmentsModel) {\n    /**\n     * The default implementation of a `IAttachmentsModel.IContentFactory`.\n     */\n    class ContentFactory {\n        /**\n         * Create an attachment model.\n         */\n        createAttachmentModel(options) {\n            return new _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_1__.AttachmentModel(options);\n        }\n    }\n    AttachmentsModel.ContentFactory = ContentFactory;\n    /**\n     * The default attachment model factory.\n     */\n    AttachmentsModel.defaultContentFactory = new ContentFactory();\n})(AttachmentsModel || (AttachmentsModel = {}));\n/**\n * A resolver for cell attachments 'attachment:filename'.\n *\n * Will resolve to a data: url.\n */\nclass AttachmentsResolver {\n    /**\n     * Create an attachments resolver object.\n     */\n    constructor(options) {\n        this._parent = options.parent || null;\n        this._model = options.model;\n    }\n    /**\n     * Resolve a relative url to a correct server path.\n     */\n    async resolveUrl(url) {\n        if (this._parent && !url.startsWith('attachment:')) {\n            return this._parent.resolveUrl(url);\n        }\n        return url;\n    }\n    /**\n     * Get the download url of a given absolute server path.\n     *\n     * #### Notes\n     * The returned URL may include a query parameter.\n     */\n    async getDownloadUrl(path) {\n        if (this._parent && !path.startsWith('attachment:')) {\n            return this._parent.getDownloadUrl(path);\n        }\n        // Return a data URL with the data of the url\n        const key = path.slice('attachment:'.length);\n        const attachment = this._model.get(key);\n        if (attachment === undefined) {\n            // Resolve with unprocessed path, to show as broken image\n            return path;\n        }\n        const { data } = attachment;\n        const mimeType = Object.keys(data)[0];\n        // Only support known safe types:\n        if (mimeType === undefined ||\n            _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_1__.imageRendererFactory.mimeTypes.indexOf(mimeType) === -1) {\n            throw new Error(`Cannot render unknown image mime type \"${mimeType}\".`);\n        }\n        const dataUrl = `data:${mimeType};base64,${data[mimeType]}`;\n        return dataUrl;\n    }\n    /**\n     * Whether the URL should be handled by the resolver\n     * or not.\n     */\n    isLocal(url) {\n        var _a, _b, _c;\n        if (this._parent && !url.startsWith('attachment:')) {\n            return (_c = (_b = (_a = this._parent).isLocal) === null || _b === void 0 ? void 0 : _b.call(_a, url)) !== null && _c !== void 0 ? _c : true;\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=model.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/attachments/lib/model.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/cells/lib/celldragutils.js":
/*!**************************************************************!*\
  !*** ../node_modules/@jupyterlab/cells/lib/celldragutils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CellDragUtils: () => (/* binding */ CellDragUtils)\n/* harmony export */ });\n/* harmony import */ var _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/virtualdom */ \"webpack/sharing/consume/default/@lumino/virtualdom/@lumino/virtualdom\");\n/* harmony import */ var _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__);\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n\n/**\n * Constants for drag\n */\n/**\n * The threshold in pixels to start a drag event.\n */\nconst DRAG_THRESHOLD = 5;\n/**\n * The class name added to drag images.\n */\nconst DRAG_IMAGE_CLASS = 'jp-dragImage';\n/**\n * The class name added to singular drag images\n */\nconst SINGLE_DRAG_IMAGE_CLASS = 'jp-dragImage-singlePrompt';\n/**\n * The class name added to the drag image cell content.\n */\nconst CELL_DRAG_CONTENT_CLASS = 'jp-dragImage-content';\n/**\n * The class name added to the drag image cell content.\n */\nconst CELL_DRAG_PROMPT_CLASS = 'jp-dragImage-prompt';\n/**\n * The class name added to the drag image cell content.\n */\nconst CELL_DRAG_MULTIPLE_BACK = 'jp-dragImage-multipleBack';\nvar CellDragUtils;\n(function (CellDragUtils) {\n    /**\n     * Find the cell index containing the target html element.\n     * This function traces up the DOM hierarchy to find the root cell\n     * node. Then find the corresponding child and select it.\n     *\n     * @param node - the cell node or a child of the cell node.\n     * @param cells - an iterable of Cells\n     * @param isCellNode - a function that takes in a node and checks if\n     * it is a cell node.\n     *\n     * @returns index of the cell we're looking for. Returns -1 if\n     * the cell is not founds\n     */\n    function findCell(node, cells, isCellNode) {\n        let cellIndex = -1;\n        while (node && node.parentElement) {\n            if (isCellNode(node)) {\n                let index = -1;\n                for (const cell of cells) {\n                    if (cell.node === node) {\n                        cellIndex = ++index;\n                        break;\n                    }\n                }\n                break;\n            }\n            node = node.parentElement;\n        }\n        return cellIndex;\n    }\n    CellDragUtils.findCell = findCell;\n    /**\n     * Detect which part of the cell triggered the MouseEvent\n     *\n     * @param cell - The cell which contains the MouseEvent's target\n     * @param target - The DOM node which triggered the MouseEvent\n     */\n    function detectTargetArea(cell, target) {\n        var _a, _b;\n        let targetArea;\n        if (cell) {\n            if ((_a = cell.editorWidget) === null || _a === void 0 ? void 0 : _a.node.contains(target)) {\n                targetArea = 'input';\n            }\n            else if ((_b = cell.promptNode) === null || _b === void 0 ? void 0 : _b.contains(target)) {\n                targetArea = 'prompt';\n            }\n            else {\n                targetArea = 'cell';\n            }\n        }\n        else {\n            targetArea = 'unknown';\n        }\n        return targetArea;\n    }\n    CellDragUtils.detectTargetArea = detectTargetArea;\n    /**\n     * Detect if a drag event should be started. This is down if the\n     * mouse is moved beyond a certain distance (DRAG_THRESHOLD).\n     *\n     * @param prevX - X Coordinate of the mouse pointer during the mousedown event\n     * @param prevY - Y Coordinate of the mouse pointer during the mousedown event\n     * @param nextX - Current X Coordinate of the mouse pointer\n     * @param nextY - Current Y Coordinate of the mouse pointer\n     */\n    function shouldStartDrag(prevX, prevY, nextX, nextY) {\n        const dx = Math.abs(nextX - prevX);\n        const dy = Math.abs(nextY - prevY);\n        return dx >= DRAG_THRESHOLD || dy >= DRAG_THRESHOLD;\n    }\n    CellDragUtils.shouldStartDrag = shouldStartDrag;\n    /**\n     * Create an image for the cell(s) to be dragged\n     *\n     * @param activeCell - The cell from where the drag event is triggered\n     * @param selectedCells - The cells to be dragged\n     */\n    function createCellDragImage(activeCell, selectedCells) {\n        const count = selectedCells.length;\n        let promptNumber;\n        if (activeCell.model.type === 'code') {\n            const executionCount = activeCell.model\n                .executionCount;\n            promptNumber = ' ';\n            if (executionCount) {\n                promptNumber = executionCount.toString();\n            }\n        }\n        else {\n            promptNumber = '';\n        }\n        const cellContent = activeCell.model.sharedModel\n            .getSource()\n            .split('\\n')[0]\n            .slice(0, 26);\n        if (count > 1) {\n            if (promptNumber !== '') {\n                return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__.VirtualDOM.realize(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__.h.div(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__.h.div({ className: DRAG_IMAGE_CLASS }, _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__.h.span({ className: CELL_DRAG_PROMPT_CLASS }, '[' + promptNumber + ']:'), _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__.h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent)), _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__.h.div({ className: CELL_DRAG_MULTIPLE_BACK }, '')));\n            }\n            else {\n                return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__.VirtualDOM.realize(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__.h.div(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__.h.div({ className: DRAG_IMAGE_CLASS }, _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__.h.span({ className: CELL_DRAG_PROMPT_CLASS }), _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__.h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent)), _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__.h.div({ className: CELL_DRAG_MULTIPLE_BACK }, '')));\n            }\n        }\n        else {\n            if (promptNumber !== '') {\n                return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__.VirtualDOM.realize(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__.h.div(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__.h.div({ className: `${DRAG_IMAGE_CLASS} ${SINGLE_DRAG_IMAGE_CLASS}` }, _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__.h.span({ className: CELL_DRAG_PROMPT_CLASS }, '[' + promptNumber + ']:'), _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__.h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent))));\n            }\n            else {\n                return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__.VirtualDOM.realize(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__.h.div(_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__.h.div({ className: `${DRAG_IMAGE_CLASS} ${SINGLE_DRAG_IMAGE_CLASS}` }, _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__.h.span({ className: CELL_DRAG_PROMPT_CLASS }), _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_0__.h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent))));\n            }\n        }\n    }\n    CellDragUtils.createCellDragImage = createCellDragImage;\n})(CellDragUtils || (CellDragUtils = {}));\n//# sourceMappingURL=celldragutils.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/cells/lib/celldragutils.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/cells/lib/collapser.js":
/*!**********************************************************!*\
  !*** ../node_modules/@jupyterlab/cells/lib/collapser.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Collapser: () => (/* binding */ Collapser),\n/* harmony export */   InputCollapser: () => (/* binding */ InputCollapser),\n/* harmony export */   OutputCollapser: () => (/* binding */ OutputCollapser)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/ui-components */ \"webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components\");\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/domutils */ \"webpack/sharing/consume/default/@lumino/domutils/@lumino/domutils\");\n/* harmony import */ var _lumino_domutils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_domutils__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n\n\n\n/**\n * The CSS class added to all collapsers.\n */\nconst COLLAPSER_CLASS = 'jp-Collapser';\n/**\n * The CSS class added to the collapser child.\n */\nconst COLLAPSER_CHILD_CLASS = 'jp-Collapser-child';\n/**\n * The CSS class added to input collapsers.\n */\nconst INPUT_COLLAPSER = 'jp-InputCollapser';\n/**\n * The CSS class added to output collapsers.\n */\nconst OUTPUT_COLLAPSER = 'jp-OutputCollapser';\n/**\n * Abstract collapser base class.\n *\n * ### Notes\n * A collapser is a visible div to the left of a cell's\n * input/output that a user can click on to collapse the\n * input/output.\n */\nclass Collapser extends _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__.ReactWidget {\n    /**\n     * Construct a new collapser.\n     */\n    constructor() {\n        super();\n        this.addClass(COLLAPSER_CLASS);\n    }\n    /**\n     * Is the input/output of the parent collapsed.\n     */\n    get collapsed() {\n        return false;\n    }\n    /**\n     * Render the collapser with the virtual DOM.\n     */\n    render() {\n        const childClass = COLLAPSER_CHILD_CLASS;\n        return react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"div\", { className: childClass, onClick: e => this.handleClick(e) });\n    }\n}\n/**\n * A collapser subclass to collapse a cell's input area.\n */\nclass InputCollapser extends Collapser {\n    /**\n     * Construct a new input collapser.\n     */\n    constructor() {\n        super();\n        this.addClass(INPUT_COLLAPSER);\n    }\n    /**\n     * Is the cell's input collapsed?\n     */\n    get collapsed() {\n        var _a;\n        const cell = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.parent;\n        if (cell) {\n            return cell.inputHidden;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Handle a click event for the user to collapse the cell's input.\n     */\n    handleClick(e) {\n        var _a;\n        const cell = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.parent;\n        if (cell) {\n            cell.inputHidden = !cell.inputHidden;\n        }\n        /* We need this until we watch the cell state */\n        this.update();\n    }\n}\n/**\n * A collapser subclass to collapse a cell's output area.\n */\nclass OutputCollapser extends Collapser {\n    /**\n     * Construct a new output collapser.\n     */\n    constructor() {\n        super();\n        this.addClass(OUTPUT_COLLAPSER);\n    }\n    /**\n     * Is the cell's output collapsed?\n     */\n    get collapsed() {\n        var _a;\n        const cell = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.parent;\n        if (cell) {\n            return cell.outputHidden;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Handle a click event for the user to collapse the cell's output.\n     */\n    handleClick(e) {\n        var _a, _b;\n        const cell = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.parent;\n        if (cell) {\n            cell.outputHidden = !cell.outputHidden;\n            /* Scroll cell into view after output collapse */\n            if (cell.outputHidden) {\n                let area = (_b = cell.parent) === null || _b === void 0 ? void 0 : _b.node;\n                if (area) {\n                    _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.scrollIntoViewIfNeeded(area, cell.node);\n                }\n            }\n        }\n        /* We need this until we watch the cell state */\n        this.update();\n    }\n}\n//# sourceMappingURL=collapser.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/cells/lib/collapser.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/cells/lib/headerfooter.js":
/*!*************************************************************!*\
  !*** ../node_modules/@jupyterlab/cells/lib/headerfooter.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CellFooter: () => (/* binding */ CellFooter),\n/* harmony export */   CellHeader: () => (/* binding */ CellHeader)\n/* harmony export */ });\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/widgets */ \"webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets\");\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_0__);\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n\n/**\n * The CSS class added to the cell header.\n */\nconst CELL_HEADER_CLASS = 'jp-CellHeader';\n/**\n * The CSS class added to the cell footer.\n */\nconst CELL_FOOTER_CLASS = 'jp-CellFooter';\n/**\n * Default implementation of a cell header.\n */\nclass CellHeader extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget {\n    /**\n     * Construct a new cell header.\n     */\n    constructor() {\n        super();\n        this.addClass(CELL_HEADER_CLASS);\n    }\n}\n/**\n * Default implementation of a cell footer.\n */\nclass CellFooter extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget {\n    /**\n     * Construct a new cell footer.\n     */\n    constructor() {\n        super();\n        this.addClass(CELL_FOOTER_CLASS);\n    }\n}\n//# sourceMappingURL=headerfooter.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/cells/lib/headerfooter.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/cells/lib/index.js":
/*!******************************************************!*\
  !*** ../node_modules/@jupyterlab/cells/lib/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AttachmentsCell: () => (/* reexport safe */ _widget__WEBPACK_IMPORTED_MODULE_7__.AttachmentsCell),\n/* harmony export */   AttachmentsCellModel: () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_4__.AttachmentsCellModel),\n/* harmony export */   Cell: () => (/* reexport safe */ _widget__WEBPACK_IMPORTED_MODULE_7__.Cell),\n/* harmony export */   CellDragUtils: () => (/* reexport safe */ _celldragutils__WEBPACK_IMPORTED_MODULE_0__.CellDragUtils),\n/* harmony export */   CellFooter: () => (/* reexport safe */ _headerfooter__WEBPACK_IMPORTED_MODULE_2__.CellFooter),\n/* harmony export */   CellHeader: () => (/* reexport safe */ _headerfooter__WEBPACK_IMPORTED_MODULE_2__.CellHeader),\n/* harmony export */   CellModel: () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_4__.CellModel),\n/* harmony export */   CellSearchProvider: () => (/* reexport safe */ _searchprovider__WEBPACK_IMPORTED_MODULE_6__.CellSearchProvider),\n/* harmony export */   CodeCell: () => (/* reexport safe */ _widget__WEBPACK_IMPORTED_MODULE_7__.CodeCell),\n/* harmony export */   CodeCellLayout: () => (/* reexport safe */ _widget__WEBPACK_IMPORTED_MODULE_7__.CodeCellLayout),\n/* harmony export */   CodeCellModel: () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_4__.CodeCellModel),\n/* harmony export */   Collapser: () => (/* reexport safe */ _collapser__WEBPACK_IMPORTED_MODULE_1__.Collapser),\n/* harmony export */   InputArea: () => (/* reexport safe */ _inputarea__WEBPACK_IMPORTED_MODULE_3__.InputArea),\n/* harmony export */   InputCollapser: () => (/* reexport safe */ _collapser__WEBPACK_IMPORTED_MODULE_1__.InputCollapser),\n/* harmony export */   InputPlaceholder: () => (/* reexport safe */ _placeholder__WEBPACK_IMPORTED_MODULE_5__.InputPlaceholder),\n/* harmony export */   InputPrompt: () => (/* reexport safe */ _inputarea__WEBPACK_IMPORTED_MODULE_3__.InputPrompt),\n/* harmony export */   MarkdownCell: () => (/* reexport safe */ _widget__WEBPACK_IMPORTED_MODULE_7__.MarkdownCell),\n/* harmony export */   MarkdownCellModel: () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_4__.MarkdownCellModel),\n/* harmony export */   OutputCollapser: () => (/* reexport safe */ _collapser__WEBPACK_IMPORTED_MODULE_1__.OutputCollapser),\n/* harmony export */   OutputPlaceholder: () => (/* reexport safe */ _placeholder__WEBPACK_IMPORTED_MODULE_5__.OutputPlaceholder),\n/* harmony export */   Placeholder: () => (/* reexport safe */ _placeholder__WEBPACK_IMPORTED_MODULE_5__.Placeholder),\n/* harmony export */   RawCell: () => (/* reexport safe */ _widget__WEBPACK_IMPORTED_MODULE_7__.RawCell),\n/* harmony export */   RawCellModel: () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_4__.RawCellModel),\n/* harmony export */   SELECTED_HIGHLIGHT_CLASS: () => (/* reexport safe */ _searchprovider__WEBPACK_IMPORTED_MODULE_6__.SELECTED_HIGHLIGHT_CLASS),\n/* harmony export */   createCellSearchProvider: () => (/* reexport safe */ _searchprovider__WEBPACK_IMPORTED_MODULE_6__.createCellSearchProvider),\n/* harmony export */   isCodeCellModel: () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_4__.isCodeCellModel),\n/* harmony export */   isMarkdownCellModel: () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_4__.isMarkdownCellModel),\n/* harmony export */   isRawCellModel: () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_4__.isRawCellModel)\n/* harmony export */ });\n/* harmony import */ var _celldragutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./celldragutils */ \"../node_modules/@jupyterlab/cells/lib/celldragutils.js\");\n/* harmony import */ var _collapser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./collapser */ \"../node_modules/@jupyterlab/cells/lib/collapser.js\");\n/* harmony import */ var _headerfooter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./headerfooter */ \"../node_modules/@jupyterlab/cells/lib/headerfooter.js\");\n/* harmony import */ var _inputarea__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./inputarea */ \"../node_modules/@jupyterlab/cells/lib/inputarea.js\");\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./model */ \"../node_modules/@jupyterlab/cells/lib/model.js\");\n/* harmony import */ var _placeholder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./placeholder */ \"../node_modules/@jupyterlab/cells/lib/placeholder.js\");\n/* harmony import */ var _searchprovider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./searchprovider */ \"../node_modules/@jupyterlab/cells/lib/searchprovider.js\");\n/* harmony import */ var _widget__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./widget */ \"../node_modules/@jupyterlab/cells/lib/widget.js\");\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module cells\n */\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/cells/lib/index.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/cells/lib/inputarea.js":
/*!**********************************************************!*\
  !*** ../node_modules/@jupyterlab/cells/lib/inputarea.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InputArea: () => (/* binding */ InputArea),\n/* harmony export */   InputPrompt: () => (/* binding */ InputPrompt)\n/* harmony export */ });\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/widgets */ \"webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets\");\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/codeeditor */ \"webpack/sharing/consume/default/@jupyterlab/codeeditor/@jupyterlab/codeeditor\");\n/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__);\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n\n\n\n/**\n * The class name added to input area widgets.\n */\nconst INPUT_AREA_CLASS = 'jp-InputArea';\n/**\n * The class name added to the prompt area of cell.\n */\nconst INPUT_AREA_PROMPT_CLASS = 'jp-InputArea-prompt';\n/**\n * The class name added to OutputPrompt.\n */\nconst INPUT_PROMPT_CLASS = 'jp-InputPrompt';\n/**\n * The class name added to the editor area of the cell.\n */\nconst INPUT_AREA_EDITOR_CLASS = 'jp-InputArea-editor';\n/** ****************************************************************************\n * InputArea\n ******************************************************************************/\n/**\n * An input area widget, which hosts a prompt and an editor widget.\n */\nclass InputArea extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget {\n    /**\n     * Construct an input area widget.\n     */\n    constructor(options) {\n        super();\n        this.addClass(INPUT_AREA_CLASS);\n        const { contentFactory, editorOptions, model } = options;\n        this.model = model;\n        this.contentFactory = contentFactory;\n        // Prompt\n        const prompt = (this._prompt = contentFactory.createInputPrompt());\n        prompt.addClass(INPUT_AREA_PROMPT_CLASS);\n        // Editor\n        const editor = (this._editor = new _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__.CodeEditorWrapper({\n            factory: contentFactory.editorFactory,\n            model,\n            editorOptions\n        }));\n        editor.addClass(INPUT_AREA_EDITOR_CLASS);\n        const layout = (this.layout = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.PanelLayout());\n        layout.addWidget(prompt);\n        layout.addWidget(editor);\n    }\n    /**\n     * Get the CodeEditorWrapper used by the cell.\n     */\n    get editorWidget() {\n        return this._editor;\n    }\n    /**\n     * Get the CodeEditor used by the cell.\n     */\n    get editor() {\n        return this._editor.editor;\n    }\n    /**\n     * Get the prompt node used by the cell.\n     */\n    get promptNode() {\n        return this._prompt.node;\n    }\n    /**\n     * Get the rendered input area widget, if any.\n     */\n    get renderedInput() {\n        return this._rendered;\n    }\n    /**\n     * Render an input instead of the text editor.\n     */\n    renderInput(widget) {\n        const layout = this.layout;\n        if (this._rendered) {\n            this._rendered.parent = null;\n        }\n        this._editor.hide();\n        this._rendered = widget;\n        layout.addWidget(widget);\n    }\n    /**\n     * Show the text editor.\n     */\n    showEditor() {\n        if (this._rendered) {\n            this._rendered.parent = null;\n        }\n        this._editor.show();\n    }\n    /**\n     * Set the prompt of the input area.\n     */\n    setPrompt(value) {\n        this._prompt.executionCount = value;\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        // Do nothing if already disposed.\n        if (this.isDisposed) {\n            return;\n        }\n        this._prompt = null;\n        this._editor = null;\n        this._rendered = null;\n        super.dispose();\n    }\n}\n/**\n * A namespace for `InputArea` statics.\n */\n(function (InputArea) {\n    /**\n     * Default implementation of `IContentFactory`.\n     *\n     * This defaults to using an `editorFactory` based on CodeMirror.\n     */\n    class ContentFactory {\n        /**\n         * Construct a `ContentFactory`.\n         */\n        constructor(options) {\n            this._editor = options.editorFactory;\n        }\n        /**\n         * Return the `CodeEditor.Factory` being used.\n         */\n        get editorFactory() {\n            return this._editor;\n        }\n        /**\n         * Create an input prompt.\n         */\n        createInputPrompt() {\n            return new InputPrompt();\n        }\n    }\n    InputArea.ContentFactory = ContentFactory;\n})(InputArea || (InputArea = {}));\n/**\n * The default input prompt implementation.\n */\nclass InputPrompt extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget {\n    /*\n     * Create an output prompt widget.\n     */\n    constructor() {\n        super();\n        this._executionCount = null;\n        this.addClass(INPUT_PROMPT_CLASS);\n    }\n    /**\n     * The execution count for the prompt.\n     */\n    get executionCount() {\n        return this._executionCount;\n    }\n    set executionCount(value) {\n        this._executionCount = value;\n        if (value === null) {\n            this.node.textContent = ' ';\n        }\n        else {\n            this.node.textContent = `[${value || ' '}]:`;\n        }\n    }\n}\n//# sourceMappingURL=inputarea.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/cells/lib/inputarea.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/cells/lib/model.js":
/*!******************************************************!*\
  !*** ../node_modules/@jupyterlab/cells/lib/model.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AttachmentsCellModel: () => (/* binding */ AttachmentsCellModel),\n/* harmony export */   CellModel: () => (/* binding */ CellModel),\n/* harmony export */   CodeCellModel: () => (/* binding */ CodeCellModel),\n/* harmony export */   MarkdownCellModel: () => (/* binding */ MarkdownCellModel),\n/* harmony export */   RawCellModel: () => (/* binding */ RawCellModel),\n/* harmony export */   isCodeCellModel: () => (/* binding */ isCodeCellModel),\n/* harmony export */   isMarkdownCellModel: () => (/* binding */ isMarkdownCellModel),\n/* harmony export */   isRawCellModel: () => (/* binding */ isRawCellModel)\n/* harmony export */ });\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/signaling */ \"webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling\");\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_attachments__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jupyterlab/attachments */ \"../node_modules/@jupyterlab/attachments/lib/model.js\");\n/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/codeeditor */ \"webpack/sharing/consume/default/@jupyterlab/codeeditor/@jupyterlab/codeeditor\");\n/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/outputarea */ \"webpack/sharing/consume/default/@jupyterlab/outputarea/@jupyterlab/outputarea\");\n/* harmony import */ var _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _jupyter_ydoc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyter/ydoc */ \"webpack/sharing/consume/default/@jupyter/ydoc/@jupyter/ydoc\");\n/* harmony import */ var _jupyter_ydoc__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyter_ydoc__WEBPACK_IMPORTED_MODULE_3__);\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n\n\n\n\n\nconst globalModelDBMutex = (0,_jupyter_ydoc__WEBPACK_IMPORTED_MODULE_3__.createMutex)();\nfunction isCodeCellModel(model) {\n    return model.type === 'code';\n}\nfunction isMarkdownCellModel(model) {\n    return model.type === 'markdown';\n}\nfunction isRawCellModel(model) {\n    return model.type === 'raw';\n}\n/**\n * An implementation of the cell model.\n */\nclass CellModel extends _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_1__.CodeEditor.Model {\n    constructor(options = {}) {\n        const { cell_type, sharedModel, ...others } = options;\n        super({\n            sharedModel: sharedModel !== null && sharedModel !== void 0 ? sharedModel : (0,_jupyter_ydoc__WEBPACK_IMPORTED_MODULE_3__.createStandaloneCell)({\n                cell_type: cell_type !== null && cell_type !== void 0 ? cell_type : 'raw',\n                id: options.id\n            }),\n            ...others\n        });\n        /**\n         * A signal emitted when the state of the model changes.\n         */\n        this.contentChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);\n        /**\n         * A signal emitted when a model state changes.\n         */\n        this.stateChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);\n        this._metadataChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);\n        this._trusted = false;\n        this.standaloneModel = typeof options.sharedModel === 'undefined';\n        this.trusted = !!this.getMetadata('trusted') || !!options.trusted;\n        this.sharedModel.changed.connect(this.onGenericChange, this);\n        this.sharedModel.metadataChanged.connect(this._onMetadataChanged, this);\n    }\n    /**\n     * Signal emitted when cell metadata changes.\n     */\n    get metadataChanged() {\n        return this._metadataChanged;\n    }\n    /**\n     * The id for the cell.\n     */\n    get id() {\n        return this.sharedModel.getId();\n    }\n    /**\n     * The metadata associated with the cell.\n     */\n    get metadata() {\n        return this.sharedModel.metadata;\n    }\n    /**\n     * The trusted state of the model.\n     */\n    get trusted() {\n        return this._trusted;\n    }\n    set trusted(newValue) {\n        const oldValue = this.trusted;\n        if (oldValue !== newValue) {\n            this._trusted = newValue;\n            this.onTrustedChanged(this, { newValue, oldValue });\n        }\n    }\n    /**\n     * Dispose of the resources held by the model.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this.sharedModel.changed.disconnect(this.onGenericChange, this);\n        this.sharedModel.metadataChanged.disconnect(this._onMetadataChanged, this);\n        super.dispose();\n    }\n    /**\n     * Handle a change to the trusted state.\n     *\n     * The default implementation is a no-op.\n     */\n    onTrustedChanged(trusted, args) {\n        /* no-op */\n    }\n    /**\n     * Delete a metadata\n     *\n     * @param key Metadata key\n     */\n    deleteMetadata(key) {\n        return this.sharedModel.deleteMetadata(key);\n    }\n    /**\n     * Get a metadata\n     *\n     * ### Notes\n     * This returns a copy of the key value.\n     *\n     * @param key Metadata key\n     */\n    getMetadata(key) {\n        return this.sharedModel.getMetadata(key);\n    }\n    /**\n     * Set a metadata\n     *\n     * @param key Metadata key\n     * @param value Metadata value\n     */\n    setMetadata(key, value) {\n        if (typeof value === 'undefined') {\n            this.sharedModel.deleteMetadata(key);\n        }\n        else {\n            this.sharedModel.setMetadata(key, value);\n        }\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        return this.sharedModel.toJSON();\n    }\n    /**\n     * Handle a change to the observable value.\n     */\n    onGenericChange() {\n        this.contentChanged.emit(void 0);\n    }\n    _onMetadataChanged(sender, change) {\n        this._metadataChanged.emit(change);\n    }\n}\n/**\n * A base implementation for cell models with attachments.\n */\nclass AttachmentsCellModel extends CellModel {\n    /**\n     * Construct a new cell with optional attachments.\n     */\n    constructor(options) {\n        var _a;\n        super(options);\n        const factory = (_a = options.contentFactory) !== null && _a !== void 0 ? _a : AttachmentsCellModel.defaultContentFactory;\n        const values = this.sharedModel.getAttachments();\n        this._attachments = factory.createAttachmentsModel({ values });\n        this._attachments.stateChanged.connect(this.onGenericChange, this);\n        this._attachments.changed.connect(this._onAttachmentsChange, this);\n        this.sharedModel.changed.connect(this._onSharedModelChanged, this);\n    }\n    /**\n     * Get the attachments of the model.\n     */\n    get attachments() {\n        return this._attachments;\n    }\n    /**\n     * Dispose of the resources held by the model.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._attachments.stateChanged.disconnect(this.onGenericChange, this);\n        this._attachments.changed.disconnect(this._onAttachmentsChange, this);\n        this._attachments.dispose();\n        this.sharedModel.changed.disconnect(this._onSharedModelChanged, this);\n        super.dispose();\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        return super.toJSON();\n    }\n    /**\n     * Handle a change to the cell outputs modelDB and reflect it in the shared model.\n     */\n    _onAttachmentsChange(sender, event) {\n        const cell = this.sharedModel;\n        globalModelDBMutex(() => cell.setAttachments(sender.toJSON()));\n    }\n    /**\n     * Handle a change to the code cell value.\n     */\n    _onSharedModelChanged(slot, change) {\n        if (change.attachmentsChange) {\n            const cell = this.sharedModel;\n            globalModelDBMutex(() => { var _a; return this._attachments.fromJSON((_a = cell.getAttachments()) !== null && _a !== void 0 ? _a : {}); });\n        }\n    }\n}\n/**\n * The namespace for `AttachmentsCellModel` statics.\n */\n(function (AttachmentsCellModel) {\n    /**\n     * The default implementation of an `IContentFactory`.\n     */\n    class ContentFactory {\n        /**\n         * Create an attachments model.\n         */\n        createAttachmentsModel(options) {\n            return new _jupyterlab_attachments__WEBPACK_IMPORTED_MODULE_4__.AttachmentsModel(options);\n        }\n    }\n    AttachmentsCellModel.ContentFactory = ContentFactory;\n    /**\n     * The shared `ContentFactory` instance.\n     */\n    AttachmentsCellModel.defaultContentFactory = new ContentFactory();\n})(AttachmentsCellModel || (AttachmentsCellModel = {}));\n/**\n * An implementation of a raw cell model.\n */\nclass RawCellModel extends AttachmentsCellModel {\n    /**\n     * Construct a raw cell model from optional shared model.\n     */\n    constructor(options = {}) {\n        super({\n            cell_type: 'raw',\n            ...options\n        });\n    }\n    /**\n     * The type of the cell.\n     */\n    get type() {\n        return 'raw';\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        return super.toJSON();\n    }\n}\n/**\n * An implementation of a markdown cell model.\n */\nclass MarkdownCellModel extends AttachmentsCellModel {\n    /**\n     * Construct a markdown cell model from optional shared model.\n     */\n    constructor(options = {}) {\n        super({\n            cell_type: 'markdown',\n            ...options\n        });\n        // Use the Github-flavored markdown mode.\n        this.mimeType = 'text/x-ipythongfm';\n    }\n    /**\n     * The type of the cell.\n     */\n    get type() {\n        return 'markdown';\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        return super.toJSON();\n    }\n}\n/**\n * An implementation of a code cell Model.\n */\nclass CodeCellModel extends CellModel {\n    /**\n     * Construct a new code cell with optional original cell content.\n     */\n    constructor(options = {}) {\n        var _a;\n        super({\n            cell_type: 'code',\n            ...options\n        });\n        this._executedCode = '';\n        this._isDirty = false;\n        const factory = (_a = options === null || options === void 0 ? void 0 : options.contentFactory) !== null && _a !== void 0 ? _a : CodeCellModel.defaultContentFactory;\n        const trusted = this.trusted;\n        const outputs = this.sharedModel.getOutputs();\n        this._outputs = factory.createOutputArea({ trusted, values: outputs });\n        this.sharedModel.changed.connect(this._onSharedModelChanged, this);\n        this._outputs.changed.connect(this.onGenericChange, this);\n        this._outputs.changed.connect(this.onOutputsChange, this);\n    }\n    /**\n     * The type of the cell.\n     */\n    get type() {\n        return 'code';\n    }\n    /**\n     * The execution count of the cell.\n     */\n    get executionCount() {\n        return this.sharedModel.execution_count || null;\n    }\n    set executionCount(newValue) {\n        this.sharedModel.execution_count = newValue || null;\n    }\n    /**\n     * The execution state of the cell.\n     */\n    get executionState() {\n        return this.sharedModel.executionState;\n    }\n    set executionState(newValue) {\n        this.sharedModel.executionState = newValue;\n    }\n    /**\n     * Whether the cell is dirty or not.\n     *\n     * A cell is dirty if it is output is not empty and does not\n     * result of the input code execution.\n     */\n    get isDirty() {\n        // Test could be done dynamically with this._executedCode\n        // but for performance reason, the diff status is stored in a boolean.\n        return this._isDirty;\n    }\n    /**\n     * Public Set whether the cell is dirty or not.\n     */\n    set isDirty(dirty) {\n        this._setDirty(dirty);\n    }\n    /**\n     * The cell outputs.\n     */\n    get outputs() {\n        return this._outputs;\n    }\n    clearExecution() {\n        this.outputs.clear();\n        this.executionCount = null;\n        this.executionState = 'idle';\n        this._setDirty(false);\n        this.sharedModel.deleteMetadata('execution');\n        // We trust this cell as it no longer has any outputs.\n        this.trusted = true;\n    }\n    /**\n     * Dispose of the resources held by the model.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this.sharedModel.changed.disconnect(this._onSharedModelChanged, this);\n        this._outputs.changed.disconnect(this.onGenericChange, this);\n        this._outputs.changed.disconnect(this.onOutputsChange, this);\n        this._outputs.dispose();\n        this._outputs = null;\n        super.dispose();\n    }\n    /**\n     * Handle a change to the trusted state.\n     */\n    onTrustedChanged(trusted, args) {\n        const newTrusted = args.newValue;\n        if (this._outputs) {\n            this._outputs.trusted = newTrusted;\n        }\n        if (newTrusted) {\n            const codeCell = this.sharedModel;\n            const metadata = codeCell.getMetadata();\n            metadata.trusted = true;\n            codeCell.setMetadata(metadata);\n        }\n        this.stateChanged.emit({\n            name: 'trusted',\n            oldValue: args.oldValue,\n            newValue: newTrusted\n        });\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        return super.toJSON();\n    }\n    /**\n     * Handle a change to the cell outputs modelDB and reflect it in the shared model.\n     */\n    onOutputsChange(sender, event) {\n        const codeCell = this.sharedModel;\n        globalModelDBMutex(() => {\n            switch (event.type) {\n                case 'add': {\n                    for (const output of event.newValues) {\n                        if (output.type === 'stream') {\n                            output.streamText.changed.connect((sender, textEvent) => {\n                                if (textEvent.options !== undefined &&\n                                    textEvent.options['silent']) {\n                                    return;\n                                }\n                                const codeCell = this.sharedModel;\n                                if (textEvent.type === 'remove') {\n                                    codeCell.removeStreamOutput(event.newIndex, textEvent.start, 'silent-change');\n                                }\n                                else {\n                                    codeCell.appendStreamOutput(event.newIndex, textEvent.value, 'silent-change');\n                                }\n                            }, this);\n                        }\n                    }\n                    const outputs = event.newValues.map(output => output.toJSON());\n                    codeCell.updateOutputs(event.newIndex, event.newIndex, outputs, 'silent-change');\n                    break;\n                }\n                case 'set': {\n                    const newValues = event.newValues.map(output => output.toJSON());\n                    codeCell.updateOutputs(event.oldIndex, event.oldIndex + newValues.length, newValues, 'silent-change');\n                    break;\n                }\n                case 'remove':\n                    codeCell.updateOutputs(event.oldIndex, event.oldValues.length, [], 'silent-change');\n                    break;\n                case 'clear':\n                    codeCell.clearOutputs();\n                    break;\n                default:\n                    throw new Error(`Invalid event type: ${event.type}`);\n            }\n        });\n    }\n    /**\n     * Handle a change to the code cell value.\n     */\n    _onSharedModelChanged(slot, change) {\n        if (change.streamOutputChange) {\n            globalModelDBMutex(() => {\n                for (const streamOutputChange of change.streamOutputChange) {\n                    if ('delete' in streamOutputChange) {\n                        this._outputs.removeStreamOutput(streamOutputChange.delete);\n                    }\n                    if ('insert' in streamOutputChange) {\n                        this._outputs.appendStreamOutput(streamOutputChange.insert.toString());\n                    }\n                }\n            });\n        }\n        if (change.outputsChange) {\n            globalModelDBMutex(() => {\n                let retain = 0;\n                for (const outputsChange of change.outputsChange) {\n                    if ('retain' in outputsChange) {\n                        retain += outputsChange.retain;\n                    }\n                    if ('delete' in outputsChange) {\n                        for (let i = 0; i < outputsChange.delete; i++) {\n                            this._outputs.remove(retain);\n                        }\n                    }\n                    if ('insert' in outputsChange) {\n                        // Inserting an output always results in appending it.\n                        for (const output of outputsChange.insert) {\n                            // For compatibility with older ydoc where a plain object,\n                            // (rather than a Map instance) could be provided.\n                            // In a future major release the use of Map will be required.\n                            this._outputs.add('toJSON' in output ? output.toJSON() : output);\n                        }\n                    }\n                }\n            });\n        }\n        if (change.executionCountChange) {\n            if (change.executionCountChange.newValue &&\n                (this.isDirty || !change.executionCountChange.oldValue)) {\n                this._setDirty(false);\n            }\n            this.stateChanged.emit({\n                name: 'executionCount',\n                oldValue: change.executionCountChange.oldValue,\n                newValue: change.executionCountChange.newValue\n            });\n        }\n        if (change.executionStateChange) {\n            this.stateChanged.emit({\n                name: 'executionState',\n                oldValue: change.executionStateChange.oldValue,\n                newValue: change.executionStateChange.newValue\n            });\n        }\n        if (change.sourceChange && this.executionCount !== null) {\n            this._setDirty(this._executedCode !== this.sharedModel.getSource().trim());\n        }\n    }\n    /**\n     * Set whether the cell is dirty or not.\n     */\n    _setDirty(v) {\n        if (!v) {\n            this._executedCode = this.sharedModel.getSource().trim();\n        }\n        if (v !== this._isDirty) {\n            this._isDirty = v;\n            this.stateChanged.emit({\n                name: 'isDirty',\n                oldValue: !v,\n                newValue: v\n            });\n        }\n    }\n}\n/**\n * The namespace for `CodeCellModel` statics.\n */\n(function (CodeCellModel) {\n    /**\n     * The default implementation of an `IContentFactory`.\n     */\n    class ContentFactory {\n        /**\n         * Create an output area.\n         */\n        createOutputArea(options) {\n            return new _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_2__.OutputAreaModel(options);\n        }\n    }\n    CodeCellModel.ContentFactory = ContentFactory;\n    /**\n     * The shared `ContentFactory` instance.\n     */\n    CodeCellModel.defaultContentFactory = new ContentFactory();\n})(CodeCellModel || (CodeCellModel = {}));\n//# sourceMappingURL=model.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/cells/lib/model.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/cells/lib/placeholder.js":
/*!************************************************************!*\
  !*** ../node_modules/@jupyterlab/cells/lib/placeholder.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InputPlaceholder: () => (/* binding */ InputPlaceholder),\n/* harmony export */   OutputPlaceholder: () => (/* binding */ OutputPlaceholder),\n/* harmony export */   Placeholder: () => (/* binding */ Placeholder)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/ui-components */ \"webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components\");\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/widgets */ \"webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets\");\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/translation */ \"webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation\");\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2__);\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n\n\n\n/**\n * The CSS class added to placeholders.\n */\nconst PLACEHOLDER_CLASS = 'jp-Placeholder';\n/**\n * The CSS classes added to input placeholder prompts.\n */\nconst INPUT_PROMPT_CLASS = 'jp-Placeholder-prompt jp-InputPrompt';\n/**\n * The CSS classes added to output placeholder prompts.\n */\nconst OUTPUT_PROMPT_CLASS = 'jp-Placeholder-prompt jp-OutputPrompt';\n/**\n * The CSS class added to placeholder content.\n */\nconst CONTENT_CLASS = 'jp-Placeholder-content';\n/**\n * The CSS class added to input placeholders.\n */\nconst INPUT_PLACEHOLDER_CLASS = 'jp-InputPlaceholder';\n/**\n * The CSS class added to output placeholders.\n */\nconst OUTPUT_PLACEHOLDER_CLASS = 'jp-OutputPlaceholder';\n/**\n * An base class for placeholders\n *\n * ### Notes\n * A placeholder is the element that is shown when input/output\n * is hidden.\n */\nclass Placeholder extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__.Widget {\n    /**\n     * Construct a new placeholder.\n     */\n    constructor(options) {\n        var _a, _b, _c;\n        const node = document.createElement('div');\n        super({ node });\n        const trans = ((_a = options.translator) !== null && _a !== void 0 ? _a : _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2__.nullTranslator).load('jupyterlab');\n        const innerNode = document.createElement('div');\n        innerNode.className = (_b = options.promptClass) !== null && _b !== void 0 ? _b : '';\n        node.insertAdjacentHTML('afterbegin', innerNode.outerHTML);\n        this._cell = document.createElement('div');\n        this._cell.classList.add(CONTENT_CLASS);\n        this._cell.title = trans.__('Click to expand');\n        const container = this._cell.appendChild(document.createElement('div'));\n        container.classList.add('jp-Placeholder-contentContainer');\n        this._textContent = container.appendChild(document.createElement('span'));\n        this._textContent.className = 'jp-PlaceholderText';\n        this._textContent.innerText = (_c = options.text) !== null && _c !== void 0 ? _c : '';\n        node.appendChild(this._cell);\n        _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__.ellipsesIcon.element({\n            container: container.appendChild(document.createElement('span')),\n            className: 'jp-MoreHorizIcon',\n            elementPosition: 'center',\n            height: 'auto',\n            width: '32px'\n        });\n        this.addClass(PLACEHOLDER_CLASS);\n        this._callback = options.callback;\n    }\n    /**\n     * The text displayed in the placeholder.\n     */\n    set text(t) {\n        this._textContent.innerText = t;\n    }\n    get text() {\n        return this._textContent.innerText;\n    }\n    onAfterAttach(msg) {\n        super.onAfterAttach(msg);\n        this.node.addEventListener('click', this._callback);\n    }\n    onBeforeDetach(msg) {\n        this.node.removeEventListener('click', this._callback);\n        super.onBeforeDetach(msg);\n    }\n}\n/**\n * The input placeholder class.\n */\nclass InputPlaceholder extends Placeholder {\n    /**\n     * Construct a new input placeholder.\n     */\n    constructor(options) {\n        super({ ...options, promptClass: INPUT_PROMPT_CLASS });\n        this.addClass(INPUT_PLACEHOLDER_CLASS);\n    }\n}\n/**\n * The output placeholder class.\n */\nclass OutputPlaceholder extends Placeholder {\n    /**\n     * Construct a new output placeholder.\n     */\n    constructor(options) {\n        super({ ...options, promptClass: OUTPUT_PROMPT_CLASS });\n        this.addClass(OUTPUT_PLACEHOLDER_CLASS);\n    }\n}\n//# sourceMappingURL=placeholder.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/cells/lib/placeholder.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/cells/lib/resizeHandle.js":
/*!*************************************************************!*\
  !*** ../node_modules/@jupyterlab/cells/lib/resizeHandle.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResizeHandle: () => (/* binding */ ResizeHandle)\n/* harmony export */ });\n/* harmony import */ var _lumino_polling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/polling */ \"webpack/sharing/consume/default/@lumino/polling/@lumino/polling\");\n/* harmony import */ var _lumino_polling__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_polling__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/widgets */ \"webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets\");\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/signaling */ \"webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling\");\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_2__);\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\n\n\nconst RESIZE_HANDLE_CLASS = 'jp-CellResizeHandle';\nconst CELL_RESIZED_CLASS = 'jp-mod-resizedCell';\n/**\n * A handle that allows to change input/output proportions in side-by-side mode.\n */\nclass ResizeHandle extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__.Widget {\n    constructor(targetNode) {\n        super();\n        this.targetNode = targetNode;\n        this._isActive = false;\n        this._isDragging = false;\n        /**\n         * A public signal used to indicate the size of the cell and output has changed.\n         */\n        this.sizeChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__.Signal(this);\n        this.addClass(RESIZE_HANDLE_CLASS);\n        this._resizer = new _lumino_polling__WEBPACK_IMPORTED_MODULE_0__.Throttler(event => this._resize(event), 50);\n    }\n    /**\n     * Dispose the resizer handle.\n     */\n    dispose() {\n        this._resizer.dispose();\n        super.dispose();\n    }\n    /**\n     * Handle the DOM events for the widget.\n     *\n     * @param event - The DOM event sent to the widget.\n     *\n     */\n    handleEvent(event) {\n        var _a, _b;\n        switch (event.type) {\n            case 'dblclick':\n                (_a = this.targetNode.parentNode) === null || _a === void 0 ? void 0 : _a.childNodes.forEach(node => {\n                    node.classList.remove(CELL_RESIZED_CLASS);\n                });\n                document.documentElement.style.setProperty('--jp-side-by-side-output-size', `1fr`);\n                this._isActive = false;\n                break;\n            case 'mousedown':\n                this._isDragging = true;\n                if (!this._isActive) {\n                    (_b = this.targetNode.parentNode) === null || _b === void 0 ? void 0 : _b.childNodes.forEach(node => {\n                        node.classList.add(CELL_RESIZED_CLASS);\n                    });\n                    this._isActive = true;\n                }\n                window.addEventListener('mousemove', this);\n                window.addEventListener('mouseup', this);\n                break;\n            case 'mousemove': {\n                if (this._isActive && this._isDragging) {\n                    void this._resizer.invoke(event);\n                }\n                break;\n            }\n            case 'mouseup':\n                this._isDragging = false;\n                window.removeEventListener('mousemove', this);\n                window.removeEventListener('mouseup', this);\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle `after-attach` messages.\n     */\n    onAfterAttach(msg) {\n        this.node.addEventListener('dblclick', this);\n        this.node.addEventListener('mousedown', this);\n        super.onAfterAttach(msg);\n    }\n    /**\n     * Handle `before-detach` messages.\n     */\n    onBeforeDetach(msg) {\n        this.node.removeEventListener('dblclick', this);\n        this.node.removeEventListener('mousedown', this);\n        super.onBeforeDetach(msg);\n    }\n    _resize(event) {\n        // Gate the output size ratio between {0.05, 50} as sensible defaults.\n        const { width, x } = this.targetNode.getBoundingClientRect();\n        const position = event.clientX - x;\n        const ratio = width / position - 1;\n        if (0 < ratio) {\n            const normalized = Math.max(Math.min(Math.abs(ratio), 50), 0.05);\n            document.documentElement.style.setProperty('--jp-side-by-side-output-size', `${normalized}fr`);\n            this.sizeChanged.emit(normalized);\n        }\n    }\n}\n//# sourceMappingURL=resizeHandle.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/cells/lib/resizeHandle.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/cells/lib/searchprovider.js":
/*!***************************************************************!*\
  !*** ../node_modules/@jupyterlab/cells/lib/searchprovider.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CellSearchProvider: () => (/* binding */ CellSearchProvider),\n/* harmony export */   SELECTED_HIGHLIGHT_CLASS: () => (/* binding */ SELECTED_HIGHLIGHT_CLASS),\n/* harmony export */   createCellSearchProvider: () => (/* binding */ createCellSearchProvider)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/codemirror */ \"webpack/sharing/consume/default/@jupyterlab/codemirror/@jupyterlab/codemirror\");\n/* harmony import */ var _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/coreutils */ \"webpack/sharing/consume/default/@jupyterlab/coreutils/@jupyterlab/coreutils\");\n/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/documentsearch */ \"webpack/sharing/consume/default/@jupyterlab/documentsearch/@jupyterlab/documentsearch\");\n/* harmony import */ var _jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_2__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\n\n\n/**\n * Class applied on highlighted search matches\n */\nconst SELECTED_HIGHLIGHT_CLASS = 'jp-mod-selected';\n/**\n * Search provider for cells.\n */\nclass CellSearchProvider extends _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_0__.EditorSearchProvider {\n    constructor(cell) {\n        super();\n        this.cell = cell;\n        if (!this.cell.inViewport && !this.cell.editor) {\n            void (0,_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__.signalToPromise)(cell.inViewportChanged).then(([, inViewport]) => {\n                if (inViewport) {\n                    this.cmHandler.setEditor(this.editor);\n                }\n            });\n        }\n    }\n    /**\n     * Text editor\n     */\n    get editor() {\n        return this.cell.editor;\n    }\n    /**\n     * Editor content model\n     */\n    get model() {\n        return this.cell.model;\n    }\n}\n/**\n * Code cell search provider\n */\nclass CodeCellSearchProvider extends CellSearchProvider {\n    /**\n     * Constructor\n     *\n     * @param cell Cell widget\n     */\n    constructor(cell) {\n        super(cell);\n        this.currentProviderIndex = -1;\n        this.outputsProvider = [];\n        const outputs = this.cell.outputArea;\n        this._onOutputsChanged(outputs, outputs.widgets.length).catch(reason => {\n            console.error(`Failed to initialize search on cell outputs.`, reason);\n        });\n        outputs.outputLengthChanged.connect(this._onOutputsChanged, this);\n        outputs.disposed.connect(() => {\n            outputs.outputLengthChanged.disconnect(this._onOutputsChanged);\n        }, this);\n    }\n    /**\n     * Number of matches in the cell.\n     */\n    get matchesCount() {\n        if (!this.isActive) {\n            return 0;\n        }\n        return (super.matchesCount +\n            this.outputsProvider.reduce((sum, provider) => { var _a; return sum + ((_a = provider.matchesCount) !== null && _a !== void 0 ? _a : 0); }, 0));\n    }\n    /**\n     * Clear currently highlighted match.\n     */\n    async clearHighlight() {\n        await super.clearHighlight();\n        await Promise.all(this.outputsProvider.map(provider => provider.clearHighlight()));\n    }\n    /**\n     * Dispose the search provider\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        super.dispose();\n        this.outputsProvider.map(provider => {\n            provider.dispose();\n        });\n        this.outputsProvider.length = 0;\n    }\n    /**\n     * Highlight the next match.\n     *\n     * @returns The next match if there is one.\n     */\n    async highlightNext(loop, options) {\n        var _a;\n        // If we're scanning from the previous match, test whether we're\n        // at the end of the matches list.\n        const from = (_a = options === null || options === void 0 ? void 0 : options.from) !== null && _a !== void 0 ? _a : '';\n        if (this.matchesCount === 0 ||\n            (from === 'previous-match' &&\n                this.currentIndex !== null &&\n                this.currentIndex + 1 >= this.cmHandler.matches.length) ||\n            !this.isActive) {\n            this.currentIndex = null;\n        }\n        else {\n            if (this.currentProviderIndex === -1) {\n                const match = await super.highlightNext(loop, options);\n                if (match) {\n                    this.currentIndex = this.cmHandler.currentIndex;\n                    return match;\n                }\n                else {\n                    this.currentProviderIndex = 0;\n                }\n            }\n            while (this.currentProviderIndex < this.outputsProvider.length) {\n                const provider = this.outputsProvider[this.currentProviderIndex];\n                const match = await provider.highlightNext(false);\n                if (match) {\n                    this.currentIndex =\n                        super.matchesCount +\n                            this.outputsProvider\n                                .slice(0, this.currentProviderIndex)\n                                .reduce((sum, provider) => { var _a; return (sum += (_a = provider.matchesCount) !== null && _a !== void 0 ? _a : 0); }, 0) +\n                            provider.currentMatchIndex;\n                    return match;\n                }\n                else {\n                    this.currentProviderIndex += 1;\n                }\n            }\n            this.currentProviderIndex = -1;\n            this.currentIndex = null;\n            return undefined;\n        }\n    }\n    /**\n     * Highlight the previous match.\n     *\n     * @returns The previous match if there is one.\n     */\n    async highlightPrevious() {\n        if (this.matchesCount === 0 || !this.isActive) {\n            this.currentIndex = null;\n        }\n        else {\n            if (this.currentIndex === null) {\n                this.currentProviderIndex = this.outputsProvider.length - 1;\n            }\n            while (this.currentProviderIndex >= 0) {\n                const provider = this.outputsProvider[this.currentProviderIndex];\n                const match = await provider.highlightPrevious(false);\n                if (match) {\n                    this.currentIndex =\n                        super.matchesCount +\n                            this.outputsProvider\n                                .slice(0, this.currentProviderIndex)\n                                .reduce((sum, provider) => { var _a; return (sum += (_a = provider.matchesCount) !== null && _a !== void 0 ? _a : 0); }, 0) +\n                            provider.currentMatchIndex;\n                    return match;\n                }\n                else {\n                    this.currentProviderIndex -= 1;\n                }\n            }\n            const match = await super.highlightPrevious();\n            if (match) {\n                this.currentIndex = this.cmHandler.currentIndex;\n                return match;\n            }\n            else {\n                this.currentIndex = null;\n                return undefined;\n            }\n        }\n    }\n    /**\n     * Initialize the search using the provided options. Should update the UI to highlight\n     * all matches and \"select\" the first match.\n     *\n     * @param query A RegExp to be use to perform the search\n     * @param filters Filter parameters to pass to provider\n     */\n    async startQuery(query, filters) {\n        await super.startQuery(query, filters);\n        // Search outputs\n        if ((filters === null || filters === void 0 ? void 0 : filters.output) !== false && this.isActive) {\n            await Promise.all(this.outputsProvider.map(provider => provider.startQuery(query)));\n        }\n    }\n    async endQuery() {\n        var _a;\n        await super.endQuery();\n        if (((_a = this.filters) === null || _a === void 0 ? void 0 : _a.output) !== false && this.isActive) {\n            await Promise.all(this.outputsProvider.map(provider => provider.endQuery()));\n        }\n    }\n    /**\n     * Replace all matches in the cell source with the provided text\n     *\n     * @param newText The replacement text.\n     * @returns Whether a replace occurred.\n     */\n    async replaceAllMatches(newText, options) {\n        if (this.model.getMetadata('editable') === false)\n            return Promise.resolve(false);\n        const result = await super.replaceAllMatches(newText, options);\n        return result;\n    }\n    /**\n     * Replace the currently selected match with the provided text.\n     * If no match is selected, it won't do anything.\n     *\n     * @param newText The replacement text.\n     * @returns Whether a replace occurred.\n     */\n    async replaceCurrentMatch(newText, loop, options) {\n        if (this.model.getMetadata('editable') === false)\n            return Promise.resolve(false);\n        const result = await super.replaceCurrentMatch(newText, loop, options);\n        return result;\n    }\n    async _onOutputsChanged(outputArea, changes) {\n        var _a;\n        this.outputsProvider.forEach(provider => {\n            provider.dispose();\n        });\n        this.outputsProvider.length = 0;\n        this.currentProviderIndex = -1;\n        this.outputsProvider = this.cell.outputArea.widgets.map(output => new _jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_2__.GenericSearchProvider(output));\n        if (this.isActive && this.query && ((_a = this.filters) === null || _a === void 0 ? void 0 : _a.output) !== false) {\n            await Promise.all([\n                this.outputsProvider.map(provider => {\n                    void provider.startQuery(this.query);\n                })\n            ]);\n        }\n        this._stateChanged.emit();\n    }\n}\n/**\n * Markdown cell search provider\n */\nclass MarkdownCellSearchProvider extends CellSearchProvider {\n    /**\n     * Constructor\n     *\n     * @param cell Cell widget\n     */\n    constructor(cell) {\n        super(cell);\n        this._unrenderedByHighlight = false;\n        this.renderedProvider = new _jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_2__.GenericSearchProvider(cell.renderer);\n    }\n    /**\n     * Clear currently highlighted match\n     */\n    async clearHighlight() {\n        await super.clearHighlight();\n        await this.renderedProvider.clearHighlight();\n    }\n    /**\n     * Dispose the search provider\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        super.dispose();\n        this.renderedProvider.dispose();\n    }\n    /**\n     * Stop the search and clean any UI elements.\n     */\n    async endQuery() {\n        await super.endQuery();\n        await this.renderedProvider.endQuery();\n    }\n    /**\n     * Highlight the next match.\n     *\n     * @returns The next match if there is one.\n     */\n    async highlightNext(loop = true, options) {\n        let match = undefined;\n        if (!this.isActive) {\n            return match;\n        }\n        const cell = this.cell;\n        if (cell.rendered && this.matchesCount > 0) {\n            // Unrender the cell\n            this._unrenderedByHighlight = true;\n            const waitForRendered = (0,_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__.signalToPromise)(cell.renderedChanged);\n            cell.rendered = false;\n            await waitForRendered;\n        }\n        match = await super.highlightNext(loop, options);\n        return match;\n    }\n    /**\n     * Highlight the previous match.\n     *\n     * @returns The previous match if there is one.\n     */\n    async highlightPrevious() {\n        let match = undefined;\n        const cell = this.cell;\n        if (cell.rendered && this.matchesCount > 0) {\n            // Unrender the cell if there are matches within the cell\n            this._unrenderedByHighlight = true;\n            const waitForRendered = (0,_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__.signalToPromise)(cell.renderedChanged);\n            cell.rendered = false;\n            await waitForRendered;\n        }\n        match = await super.highlightPrevious();\n        return match;\n    }\n    /**\n     * Initialize the search using the provided options. Should update the UI\n     * to highlight all matches and \"select\" the first match.\n     *\n     * @param query A RegExp to be use to perform the search\n     * @param filters Filter parameters to pass to provider\n     */\n    async startQuery(query, filters) {\n        await super.startQuery(query, filters);\n        const cell = this.cell;\n        if (cell.rendered) {\n            this.onRenderedChanged(cell, cell.rendered);\n        }\n        cell.renderedChanged.connect(this.onRenderedChanged, this);\n    }\n    /**\n     * Replace all matches in the cell source with the provided text\n     *\n     * @param newText The replacement text.\n     * @returns Whether a replace occurred.\n     */\n    async replaceAllMatches(newText, options) {\n        if (this.model.getMetadata('editable') === false)\n            return Promise.resolve(false);\n        const result = await super.replaceAllMatches(newText, options);\n        // if the cell is rendered force update\n        if (this.cell.rendered) {\n            this.cell.update();\n        }\n        return result;\n    }\n    /**\n     * Replace the currently selected match with the provided text.\n     * If no match is selected, it won't do anything.\n     *\n     * @param newText The replacement text.\n     * @returns Whether a replace occurred.\n     */\n    async replaceCurrentMatch(newText, loop, options) {\n        if (this.model.getMetadata('editable') === false)\n            return Promise.resolve(false);\n        const result = await super.replaceCurrentMatch(newText, loop, options);\n        return result;\n    }\n    /**\n     * Callback on rendered state change\n     *\n     * @param cell Cell that emitted the change\n     * @param rendered New rendered value\n     */\n    onRenderedChanged(cell, rendered) {\n        var _a;\n        if (!this._unrenderedByHighlight) {\n            this.currentIndex = null;\n        }\n        this._unrenderedByHighlight = false;\n        if (this.isActive) {\n            if (rendered) {\n                void this.renderedProvider.startQuery(this.query);\n            }\n            else {\n                // Force cursor position to ensure reverse search is working as expected\n                (_a = cell.editor) === null || _a === void 0 ? void 0 : _a.setCursorPosition({ column: 0, line: 0 });\n                void this.renderedProvider.endQuery();\n            }\n        }\n    }\n}\n/**\n * Factory to create a cell search provider\n *\n * @param cell Cell widget\n * @returns Cell search provider\n */\nfunction createCellSearchProvider(cell) {\n    if (cell.isPlaceholder()) {\n        return new CellSearchProvider(cell);\n    }\n    switch (cell.model.type) {\n        case 'code':\n            return new CodeCellSearchProvider(cell);\n        case 'markdown':\n            return new MarkdownCellSearchProvider(cell);\n        default:\n            return new CellSearchProvider(cell);\n    }\n}\n//# sourceMappingURL=searchprovider.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/cells/lib/searchprovider.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/cells/lib/widget.js":
/*!*******************************************************!*\
  !*** ../node_modules/@jupyterlab/cells/lib/widget.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AttachmentsCell: () => (/* binding */ AttachmentsCell),\n/* harmony export */   Cell: () => (/* binding */ Cell),\n/* harmony export */   CodeCell: () => (/* binding */ CodeCell),\n/* harmony export */   CodeCellLayout: () => (/* binding */ CodeCellLayout),\n/* harmony export */   MarkdownCell: () => (/* binding */ MarkdownCell),\n/* harmony export */   RawCell: () => (/* binding */ RawCell)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/view */ \"webpack/sharing/consume/default/@codemirror/view/@codemirror/view\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_codemirror_view__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/domutils */ \"webpack/sharing/consume/default/@lumino/domutils/@lumino/domutils\");\n/* harmony import */ var _lumino_domutils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_domutils__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jupyterlab_attachments__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @jupyterlab/attachments */ \"../node_modules/@jupyterlab/attachments/lib/model.js\");\n/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/apputils */ \"webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils\");\n/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/coreutils */ \"webpack/sharing/consume/default/@jupyterlab/coreutils/@jupyterlab/coreutils\");\n/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jupyterlab/outputarea */ \"webpack/sharing/consume/default/@jupyterlab/outputarea/@jupyterlab/outputarea\");\n/* harmony import */ var _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @jupyterlab/rendermime */ \"webpack/sharing/consume/default/@jupyterlab/rendermime/@jupyterlab/rendermime\");\n/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _jupyterlab_toc__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @jupyterlab/toc */ \"webpack/sharing/consume/default/@jupyterlab/toc/@jupyterlab/toc\");\n/* harmony import */ var _jupyterlab_toc__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_toc__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @jupyterlab/translation */ \"webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation\");\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @jupyterlab/ui-components */ \"webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components\");\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lumino/coreutils */ \"webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @lumino/algorithm */ \"webpack/sharing/consume/default/@lumino/algorithm/@lumino/algorithm\");\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _lumino_messaging__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @lumino/messaging */ \"webpack/sharing/consume/default/@lumino/messaging/@lumino/messaging\");\n/* harmony import */ var _lumino_messaging__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_lumino_messaging__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var _lumino_polling__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @lumino/polling */ \"webpack/sharing/consume/default/@lumino/polling/@lumino/polling\");\n/* harmony import */ var _lumino_polling__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_lumino_polling__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @lumino/signaling */ \"webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling\");\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @lumino/widgets */ \"webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets\");\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var _collapser__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./collapser */ \"../node_modules/@jupyterlab/cells/lib/collapser.js\");\n/* harmony import */ var _headerfooter__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./headerfooter */ \"../node_modules/@jupyterlab/cells/lib/headerfooter.js\");\n/* harmony import */ var _inputarea__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./inputarea */ \"../node_modules/@jupyterlab/cells/lib/inputarea.js\");\n/* harmony import */ var _placeholder__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./placeholder */ \"../node_modules/@jupyterlab/cells/lib/placeholder.js\");\n/* harmony import */ var _resizeHandle__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./resizeHandle */ \"../node_modules/@jupyterlab/cells/lib/resizeHandle.js\");\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * The CSS class added to cell widgets.\n */\nconst CELL_CLASS = 'jp-Cell';\n/**\n * The CSS class added to the cell header.\n */\nconst CELL_HEADER_CLASS = 'jp-Cell-header';\n/**\n * The CSS class added to the cell footer.\n */\nconst CELL_FOOTER_CLASS = 'jp-Cell-footer';\n/**\n * The CSS class added to the cell input wrapper.\n */\nconst CELL_INPUT_WRAPPER_CLASS = 'jp-Cell-inputWrapper';\n/**\n * The CSS class added to the cell output wrapper.\n */\nconst CELL_OUTPUT_WRAPPER_CLASS = 'jp-Cell-outputWrapper';\n/**\n * The CSS class added to the cell input area.\n */\nconst CELL_INPUT_AREA_CLASS = 'jp-Cell-inputArea';\n/**\n * The CSS class added to the cell output area.\n */\nconst CELL_OUTPUT_AREA_CLASS = 'jp-Cell-outputArea';\n/**\n * The CSS class added to the cell input collapser.\n */\nconst CELL_INPUT_COLLAPSER_CLASS = 'jp-Cell-inputCollapser';\n/**\n * The CSS class added to the cell output collapser.\n */\nconst CELL_OUTPUT_COLLAPSER_CLASS = 'jp-Cell-outputCollapser';\n/**\n * The class name added to the cell when dirty.\n */\nconst DIRTY_CLASS = 'jp-mod-dirty';\n/**\n * The class name added to code cells.\n */\nconst CODE_CELL_CLASS = 'jp-CodeCell';\n/**\n * The class name added to markdown cells.\n */\nconst MARKDOWN_CELL_CLASS = 'jp-MarkdownCell';\n/**\n * The class name added to rendered markdown output widgets.\n */\nconst MARKDOWN_OUTPUT_CLASS = 'jp-MarkdownOutput';\nconst MARKDOWN_HEADING_COLLAPSED = 'jp-MarkdownHeadingCollapsed';\nconst HEADING_COLLAPSER_CLASS = 'jp-collapseHeadingButton';\nconst SHOW_HIDDEN_CELLS_CLASS = 'jp-showHiddenCellsButton';\n/**\n * The class name added to raw cells.\n */\nconst RAW_CELL_CLASS = 'jp-RawCell';\n/**\n * The class name added to a rendered input area.\n */\nconst RENDERED_CLASS = 'jp-mod-rendered';\nconst NO_OUTPUTS_CLASS = 'jp-mod-noOutputs';\n/**\n * The text applied to an empty markdown cell.\n */\nconst DEFAULT_MARKDOWN_TEXT = 'Type Markdown and LaTeX: $ α^2 $';\n/**\n * The timeout to wait for change activity to have ceased before rendering.\n */\nconst RENDER_TIMEOUT = 1000;\n/**\n * The mime type for a rich contents drag object.\n */\nconst CONTENTS_MIME_RICH = 'application/x-jupyter-icontentsrich';\n/** ****************************************************************************\n * Cell\n ******************************************************************************/\n/**\n * A base cell widget.\n */\nclass Cell extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_14__.Widget {\n    /**\n     * Construct a new base cell widget.\n     */\n    constructor(options) {\n        var _a, _b, _c, _d;\n        super();\n        this.prompt = '';\n        this._displayChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_13__.Signal(this);\n        this._scrollRequested = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_13__.Signal(this);\n        /**\n         * Editor extension emitting `scrollRequested` signal on scroll.\n         *\n         * Scrolling within editor will be prevented when a cell is out out viewport.\n         * Windowed containers including cells should listen to the scroll request\n         * signal and invoke the `scrollWithinCell()` callback after scrolling the cell\n         * back into the view (and after updating the `inViewport` property).\n         */\n        this._scrollHandlerExtension = _codemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView.scrollHandler.of((view, range, options) => {\n            // When cell is in the viewport we can scroll within the editor immediately.\n            // When cell is out of viewport, the windowed container needs to first\n            // scroll the cell into the viewport (otherwise CodeMirror is unable to\n            // calculate the correct scroll delta) before invoking scrolling in editor.\n            const inWindowedContainer = this._inViewport !== null;\n            const preventDefault = inWindowedContainer && !this._inViewport;\n            this._scrollRequested.emit({\n                defaultPrevented: preventDefault,\n                scrollWithinCell: () => {\n                    view.dispatch({\n                        effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView.scrollIntoView(range, options)\n                    });\n                }\n            });\n            return preventDefault;\n        });\n        this._editorConfig = {};\n        this._editorExtensions = [];\n        this._inputHidden = false;\n        this._inViewportChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_13__.Signal(this);\n        this._readOnly = false;\n        this._ready = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_9__.PromiseDelegate();\n        this._resizeDebouncer = new _lumino_polling__WEBPACK_IMPORTED_MODULE_12__.Debouncer(() => {\n            this._displayChanged.emit();\n        }, 0);\n        this._syncCollapse = false;\n        this._syncEditable = false;\n        this.addClass(CELL_CLASS);\n        const model = (this._model = options.model);\n        this.contentFactory = options.contentFactory;\n        this.layout = (_a = options.layout) !== null && _a !== void 0 ? _a : new _lumino_widgets__WEBPACK_IMPORTED_MODULE_14__.PanelLayout();\n        // Set up translator for aria labels\n        this.translator = (_b = options.translator) !== null && _b !== void 0 ? _b : _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_7__.nullTranslator;\n        // For cells disable searching with CodeMirror search panel.\n        this._editorConfig = { searchWithCM: false, ...options.editorConfig };\n        this._editorExtensions = (_c = options.editorExtensions) !== null && _c !== void 0 ? _c : [];\n        this._editorExtensions.push(this._scrollHandlerExtension);\n        this._placeholder = true;\n        this._inViewport = null;\n        this.placeholder = (_d = options.placeholder) !== null && _d !== void 0 ? _d : true;\n        model.metadataChanged.connect(this.onMetadataChanged, this);\n    }\n    /**\n     * Initialize view state from model.\n     *\n     * #### Notes\n     * Should be called after construction. For convenience, returns this, so it\n     * can be chained in the construction, like `new Foo().initializeState();`\n     */\n    initializeState() {\n        this.loadCollapseState();\n        this.loadEditableState();\n        return this;\n    }\n    /**\n     * Signal to indicate that widget has changed visibly (in size, in type, etc)\n     */\n    get displayChanged() {\n        return this._displayChanged;\n    }\n    /**\n     * Whether the cell is in viewport or not.\n     *\n     * #### Notes\n     * This property is managed by the windowed container which holds the cell.\n     * When a cell is not in a windowed container, it always returns `false`,\n     * but this may change in the future major version.\n     */\n    get inViewport() {\n        var _a;\n        return (_a = this._inViewport) !== null && _a !== void 0 ? _a : false;\n    }\n    set inViewport(v) {\n        if (this._inViewport !== v) {\n            this._inViewport = v;\n            this._inViewportChanged.emit(this._inViewport);\n        }\n    }\n    /**\n     * Will emit true just after the node is attached to the DOM\n     * Will emit false just before the node is detached of the DOM\n     */\n    get inViewportChanged() {\n        return this._inViewportChanged;\n    }\n    /**\n     * Whether the cell is a placeholder not yet fully rendered or not.\n     */\n    get placeholder() {\n        return this._placeholder;\n    }\n    set placeholder(v) {\n        if (this._placeholder !== v && v === false) {\n            this.initializeDOM();\n            this._placeholder = v;\n            this._ready.resolve();\n        }\n    }\n    /**\n     * Get the prompt node used by the cell.\n     */\n    get promptNode() {\n        if (this.placeholder) {\n            return null;\n        }\n        if (!this._inputHidden) {\n            return this._input.promptNode;\n        }\n        else {\n            return this._inputPlaceholder.node\n                .firstElementChild;\n        }\n    }\n    /**\n     * Get the CodeEditorWrapper used by the cell.\n     */\n    get editorWidget() {\n        var _a, _b;\n        return (_b = (_a = this._input) === null || _a === void 0 ? void 0 : _a.editorWidget) !== null && _b !== void 0 ? _b : null;\n    }\n    /**\n     * Get the CodeEditor used by the cell.\n     */\n    get editor() {\n        var _a, _b;\n        return (_b = (_a = this._input) === null || _a === void 0 ? void 0 : _a.editor) !== null && _b !== void 0 ? _b : null;\n    }\n    /**\n     * Editor configuration\n     */\n    get editorConfig() {\n        return this._editorConfig;\n    }\n    /**\n     * Cell headings\n     */\n    get headings() {\n        return new Array();\n    }\n    /**\n     * Get the model used by the cell.\n     */\n    get model() {\n        return this._model;\n    }\n    /**\n     * Get the input area for the cell.\n     */\n    get inputArea() {\n        return this._input;\n    }\n    /**\n     * The read only state of the cell.\n     */\n    get readOnly() {\n        return this._readOnly;\n    }\n    set readOnly(value) {\n        if (value === this._readOnly) {\n            return;\n        }\n        this._readOnly = value;\n        if (this.syncEditable) {\n            this.saveEditableState();\n        }\n        this.update();\n    }\n    /**\n     * Whether the cell is a placeholder that defer rendering\n     *\n     * #### Notes\n     * You can wait for the promise `Cell.ready` to wait for the\n     * cell to be rendered.\n     */\n    isPlaceholder() {\n        return this.placeholder;\n    }\n    /**\n     * Save view editable state to model\n     */\n    saveEditableState() {\n        const { sharedModel } = this.model;\n        const current = sharedModel.getMetadata('editable');\n        if ((this.readOnly && current === false) ||\n            (!this.readOnly && current === undefined)) {\n            return;\n        }\n        if (this.readOnly) {\n            sharedModel.setMetadata('editable', false);\n        }\n        else {\n            sharedModel.deleteMetadata('editable');\n        }\n    }\n    /**\n     * Load view editable state from model.\n     */\n    loadEditableState() {\n        this.readOnly =\n            this.model.sharedModel.getMetadata('editable') ===\n                false;\n    }\n    /**\n     * A promise that resolves when the widget renders for the first time.\n     */\n    get ready() {\n        return this._ready.promise;\n    }\n    /**\n     * Set the prompt for the widget.\n     * @deprecated - set the `executionState` on the model instead.\n     */\n    setPrompt(value) {\n        return this._setPrompt(value);\n    }\n    /**\n     * Set the prompt for the widget.\n     *\n     * Note: this method is protected because it is needed in the CodeCell subclass,\n     * but it cannot be defined there because input is private to Cell class.\n     */\n    _setPrompt(value) {\n        var _a;\n        this.prompt = value;\n        (_a = this._input) === null || _a === void 0 ? void 0 : _a.setPrompt(value);\n    }\n    /**\n     * The view state of input being hidden.\n     */\n    get inputHidden() {\n        return this._inputHidden;\n    }\n    set inputHidden(value) {\n        var _a;\n        if (this._inputHidden === value) {\n            return;\n        }\n        if (!this.placeholder) {\n            const layout = this._inputWrapper.layout;\n            if (value) {\n                this._input.parent = null;\n                if (this._inputPlaceholder) {\n                    this._inputPlaceholder.text = (_a = this.model.sharedModel\n                        .getSource()\n                        .split('\\n')) === null || _a === void 0 ? void 0 : _a[0];\n                }\n                layout.addWidget(this._inputPlaceholder);\n            }\n            else {\n                this._inputPlaceholder.parent = null;\n                layout.addWidget(this._input);\n            }\n        }\n        this._inputHidden = value;\n        if (this.syncCollapse) {\n            this.saveCollapseState();\n        }\n        this.handleInputHidden(value);\n    }\n    /**\n     * Save view collapse state to model\n     */\n    saveCollapseState() {\n        const jupyter = { ...this.model.getMetadata('jupyter') };\n        if ((this.inputHidden && jupyter.source_hidden === true) ||\n            (!this.inputHidden && jupyter.source_hidden === undefined)) {\n            return;\n        }\n        if (this.inputHidden) {\n            jupyter.source_hidden = true;\n        }\n        else {\n            delete jupyter.source_hidden;\n        }\n        if (Object.keys(jupyter).length === 0) {\n            this.model.deleteMetadata('jupyter');\n        }\n        else {\n            this.model.setMetadata('jupyter', jupyter);\n        }\n    }\n    /**\n     * Revert view collapse state from model.\n     */\n    loadCollapseState() {\n        var _a;\n        const jupyter = (_a = this.model.getMetadata('jupyter')) !== null && _a !== void 0 ? _a : {};\n        this.inputHidden = !!jupyter.source_hidden;\n    }\n    /**\n     * Handle the input being hidden.\n     *\n     * #### Notes\n     * This is called by the `inputHidden` setter so that subclasses\n     * can perform actions upon the input being hidden without accessing\n     * private state.\n     */\n    handleInputHidden(value) {\n        return;\n    }\n    /**\n     * Whether to sync the collapse state to the cell model.\n     */\n    get syncCollapse() {\n        return this._syncCollapse;\n    }\n    set syncCollapse(value) {\n        if (this._syncCollapse === value) {\n            return;\n        }\n        this._syncCollapse = value;\n        if (value) {\n            this.loadCollapseState();\n        }\n    }\n    /**\n     * Whether to sync the editable state to the cell model.\n     */\n    get syncEditable() {\n        return this._syncEditable;\n    }\n    set syncEditable(value) {\n        if (this._syncEditable === value) {\n            return;\n        }\n        this._syncEditable = value;\n        if (value) {\n            this.loadEditableState();\n        }\n    }\n    /**\n     * Clone the cell, using the same model.\n     */\n    clone() {\n        const constructor = this.constructor;\n        return new constructor({\n            model: this.model,\n            contentFactory: this.contentFactory,\n            placeholder: false,\n            translator: this.translator\n        });\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        // Do nothing if already disposed.\n        if (this.isDisposed) {\n            return;\n        }\n        this._resizeDebouncer.dispose();\n        this._input = null;\n        this._model = null;\n        this._inputWrapper = null;\n        this._inputPlaceholder = null;\n        super.dispose();\n    }\n    /**\n     * Update the editor configuration with the partial provided dictionary.\n     *\n     * @param v Partial editor configuration\n     */\n    updateEditorConfig(v) {\n        this._editorConfig = { ...this._editorConfig, ...v };\n        if (this.editor) {\n            this.editor.setBaseOptions(this._editorConfig);\n        }\n    }\n    /**\n     * Signal emitted when cell requests scrolling to its element.\n     */\n    get scrollRequested() {\n        return this._scrollRequested;\n    }\n    /**\n     * Create children widgets.\n     */\n    initializeDOM() {\n        if (!this.placeholder) {\n            return;\n        }\n        const contentFactory = this.contentFactory;\n        const model = this._model;\n        // Header\n        const header = contentFactory.createCellHeader();\n        header.addClass(CELL_HEADER_CLASS);\n        this.layout.addWidget(header);\n        // Input\n        const inputWrapper = (this._inputWrapper = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_14__.Panel());\n        inputWrapper.addClass(CELL_INPUT_WRAPPER_CLASS);\n        const inputCollapser = new _collapser__WEBPACK_IMPORTED_MODULE_15__.InputCollapser();\n        inputCollapser.addClass(CELL_INPUT_COLLAPSER_CLASS);\n        const input = (this._input = new _inputarea__WEBPACK_IMPORTED_MODULE_16__.InputArea({\n            model,\n            contentFactory,\n            editorOptions: this.getEditorOptions()\n        }));\n        input.addClass(CELL_INPUT_AREA_CLASS);\n        inputWrapper.addWidget(inputCollapser);\n        inputWrapper.addWidget(input);\n        this.layout.addWidget(inputWrapper);\n        this._inputPlaceholder = new _placeholder__WEBPACK_IMPORTED_MODULE_17__.InputPlaceholder({\n            callback: () => {\n                this.inputHidden = !this.inputHidden;\n            },\n            text: input.model.sharedModel.getSource().split('\\n')[0],\n            translator: this.translator\n        });\n        input.model.contentChanged.connect((sender, args) => {\n            var _a;\n            if (this._inputPlaceholder && this.inputHidden) {\n                this._inputPlaceholder.text = (_a = sender.sharedModel\n                    .getSource()\n                    .split('\\n')) === null || _a === void 0 ? void 0 : _a[0];\n            }\n        });\n        if (this.inputHidden) {\n            input.parent = null;\n            inputWrapper.layout.addWidget(this._inputPlaceholder);\n        }\n        // Footer\n        const footer = this.contentFactory.createCellFooter();\n        footer.addClass(CELL_FOOTER_CLASS);\n        this.layout.addWidget(footer);\n    }\n    /**\n     * Get the editor options at initialization.\n     *\n     * @returns Editor options\n     */\n    getEditorOptions() {\n        return { config: this.editorConfig, extensions: this._editorExtensions };\n    }\n    /**\n     * Handle `before-attach` messages.\n     */\n    onBeforeAttach(msg) {\n        if (this.placeholder) {\n            this.placeholder = false;\n        }\n    }\n    /**\n     * Handle `after-attach` messages.\n     */\n    onAfterAttach(msg) {\n        this.update();\n    }\n    /**\n     * Handle `'activate-request'` messages.\n     */\n    onActivateRequest(msg) {\n        var _a;\n        (_a = this.editor) === null || _a === void 0 ? void 0 : _a.focus();\n    }\n    /**\n     * Handle `resize` messages.\n     */\n    onResize(msg) {\n        void this._resizeDebouncer.invoke();\n    }\n    /**\n     * Handle `update-request` messages.\n     */\n    onUpdateRequest(msg) {\n        var _a, _b;\n        if (!this._model) {\n            return;\n        }\n        // Handle read only state.\n        if (((_a = this.editor) === null || _a === void 0 ? void 0 : _a.getOption('readOnly')) !== this._readOnly) {\n            (_b = this.editor) === null || _b === void 0 ? void 0 : _b.setOption('readOnly', this._readOnly);\n        }\n    }\n    onContentChanged() {\n        var _a;\n        if (this.inputHidden && this._inputPlaceholder) {\n            this._inputPlaceholder.text = (_a = this.model.sharedModel\n                .getSource()\n                .split('\\n')) === null || _a === void 0 ? void 0 : _a[0];\n        }\n    }\n    /**\n     * Handle changes in the metadata.\n     */\n    onMetadataChanged(model, args) {\n        switch (args.key) {\n            case 'jupyter':\n                if (this.syncCollapse) {\n                    this.loadCollapseState();\n                }\n                break;\n            case 'editable':\n                if (this.syncEditable) {\n                    this.loadEditableState();\n                }\n                break;\n            default:\n                break;\n        }\n    }\n}\n/**\n * The namespace for the `Cell` class statics.\n */\n(function (Cell) {\n    /**\n     * Type of headings\n     */\n    let HeadingType;\n    (function (HeadingType) {\n        /**\n         * Heading from HTML output\n         */\n        HeadingType[HeadingType[\"HTML\"] = 0] = \"HTML\";\n        /**\n         * Heading from Markdown cell or Markdown output\n         */\n        HeadingType[HeadingType[\"Markdown\"] = 1] = \"Markdown\";\n    })(HeadingType = Cell.HeadingType || (Cell.HeadingType = {}));\n    /**\n     * The default implementation of an `IContentFactory`.\n     *\n     * This includes a CodeMirror editor factory to make it easy to use out of the box.\n     */\n    class ContentFactory {\n        /**\n         * Create a content factory for a cell.\n         */\n        constructor(options) {\n            this._editorFactory = options.editorFactory;\n        }\n        /**\n         * The readonly editor factory that create code editors\n         */\n        get editorFactory() {\n            return this._editorFactory;\n        }\n        /**\n         * Create a new cell header for the parent widget.\n         */\n        createCellHeader() {\n            return new _headerfooter__WEBPACK_IMPORTED_MODULE_18__.CellHeader();\n        }\n        /**\n         * Create a new cell footer for the parent widget.\n         */\n        createCellFooter() {\n            return new _headerfooter__WEBPACK_IMPORTED_MODULE_18__.CellFooter();\n        }\n        /**\n         * Create an input prompt.\n         */\n        createInputPrompt() {\n            return new _inputarea__WEBPACK_IMPORTED_MODULE_16__.InputPrompt();\n        }\n        /**\n         * Create the output prompt for the widget.\n         */\n        createOutputPrompt() {\n            return new _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_4__.OutputPrompt();\n        }\n        /**\n         * Create an stdin widget.\n         */\n        createStdin(options) {\n            return new _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_4__.Stdin(options);\n        }\n    }\n    Cell.ContentFactory = ContentFactory;\n})(Cell || (Cell = {}));\n/** ****************************************************************************\n * CodeCell\n ******************************************************************************/\n/**\n * Code cell layout\n *\n * It will not detached the output area when the cell is detached.\n */\nclass CodeCellLayout extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_14__.PanelLayout {\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     *\n     * #### Notes\n     * The default implementation of this method forwards the message\n     * to all widgets. It assumes all widget nodes are attached to the\n     * parent widget node.\n     *\n     * This may be reimplemented by subclasses as needed.\n     */\n    onBeforeAttach(msg) {\n        let beforeOutputArea = true;\n        const outputAreaWrapper = this.parent.node.firstElementChild;\n        for (const widget of this) {\n            if (outputAreaWrapper) {\n                if (widget.node === outputAreaWrapper) {\n                    beforeOutputArea = false;\n                }\n                else {\n                    _lumino_messaging__WEBPACK_IMPORTED_MODULE_11__.MessageLoop.sendMessage(widget, msg);\n                    if (beforeOutputArea) {\n                        this.parent.node.insertBefore(widget.node, outputAreaWrapper);\n                    }\n                    else {\n                        this.parent.node.appendChild(widget.node);\n                    }\n                    // Force setting isVisible to true as it requires the parent widget to be\n                    // visible. But that flag will be set only during the `onAfterAttach` call.\n                    if (!this.parent.isHidden) {\n                        widget.setFlag(_lumino_widgets__WEBPACK_IMPORTED_MODULE_14__.Widget.Flag.IsVisible);\n                    }\n                    // Not called in NotebookWindowedLayout to avoid outputArea\n                    // widgets unwanted update or reset.\n                    _lumino_messaging__WEBPACK_IMPORTED_MODULE_11__.MessageLoop.sendMessage(widget, _lumino_widgets__WEBPACK_IMPORTED_MODULE_14__.Widget.Msg.AfterAttach);\n                }\n            }\n        }\n    }\n    /**\n     * A message handler invoked on an `'after-detach'` message.\n     *\n     * #### Notes\n     * The default implementation of this method forwards the message\n     * to all widgets. It assumes all widget nodes are attached to the\n     * parent widget node.\n     *\n     * This may be reimplemented by subclasses as needed.\n     */\n    onAfterDetach(msg) {\n        for (const widget of this) {\n            // TODO we could improve this further by removing outputs based\n            // on their mime type (for example plain/text or markdown could safely be detached)\n            // If the cell is out of the view port, its children are already detached -> skip detaching\n            if (!widget.hasClass(CELL_OUTPUT_WRAPPER_CLASS) &&\n                widget.node.isConnected) {\n                // Not called in NotebookWindowedLayout for windowed notebook\n                _lumino_messaging__WEBPACK_IMPORTED_MODULE_11__.MessageLoop.sendMessage(widget, _lumino_widgets__WEBPACK_IMPORTED_MODULE_14__.Widget.Msg.BeforeDetach);\n                this.parent.node.removeChild(widget.node);\n                _lumino_messaging__WEBPACK_IMPORTED_MODULE_11__.MessageLoop.sendMessage(widget, msg);\n            }\n        }\n    }\n}\n/**\n * A widget for a code cell.\n */\nclass CodeCell extends Cell {\n    /**\n     * Construct a code cell widget.\n     */\n    constructor(options) {\n        var _a;\n        super({ layout: new CodeCellLayout(), ...options, placeholder: true });\n        /**\n         * Detect the movement of the caret in the output area.\n         *\n         * Emits scroll request if the caret moved.\n         */\n        this._detectCaretMovementInOuput = (e) => {\n            const inWindowedContainer = this._inViewport !== null;\n            const defaultPrevented = inWindowedContainer && !this._inViewport;\n            // Because we do not want to scroll on any key, but only on keys which\n            // move the caret (this on keys which cause input and on keys like left,\n            // right, top, bottom arrow, home, end, page down/up - but only if the\n            // cursor is not at the respective end of the input) we need to listen\n            // to the `selectionchange` event on target inputs/textareas, etc.\n            const target = e.target;\n            if (!target || !(target instanceof HTMLElement)) {\n                return;\n            }\n            // Make sure the previous listener gets disconnected\n            if (this._lastTarget) {\n                this._lastTarget.removeEventListener('selectionchange', this._lastOnCaretMovedHandler);\n                document.removeEventListener('selectionchange', this._lastOnCaretMovedHandler);\n            }\n            const onCaretMoved = () => {\n                this._scrollRequested.emit({\n                    scrollWithinCell: ({ scroller }) => {\n                        _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.scrollIntoViewIfNeeded(scroller, target);\n                    },\n                    defaultPrevented\n                });\n            };\n            // Remember the most recent target/handler to disconnect them next time.\n            this._lastTarget = target;\n            this._lastOnCaretMovedHandler = onCaretMoved;\n            // Firefox only supports `selectionchange` on the actual input element,\n            // all other browsers only support it on the top-level document.\n            target.addEventListener('selectionchange', onCaretMoved, { once: true });\n            document.addEventListener('selectionchange', onCaretMoved, {\n                once: true\n            });\n            // Schedule removal of the listener.\n            setTimeout(() => {\n                target.removeEventListener('selectionchange', onCaretMoved);\n                document.removeEventListener('selectionchange', onCaretMoved);\n            }, 250);\n        };\n        this._headingsCache = null;\n        this._outputHidden = false;\n        this._outputWrapper = null;\n        this._outputPlaceholder = null;\n        this._syncScrolled = false;\n        this._lastTarget = null;\n        this._lastOutputHeight = '';\n        this.addClass(CODE_CELL_CLASS);\n        const trans = this.translator.load('jupyterlab');\n        // Only save options not handled by parent constructor.\n        const rendermime = (this._rendermime = options.rendermime);\n        const contentFactory = this.contentFactory;\n        const model = this.model;\n        this.maxNumberOutputs = options.maxNumberOutputs;\n        // Note that modifying the below label warrants one to also modify\n        // the same in this._outputLengthHandler. Ideally, this label must\n        // have been a constant and used in both places but it is not done\n        // so because of limitations in the translation manager.\n        const ariaLabel = model.outputs.length === 0\n            ? trans.__('Code Cell Content')\n            : trans.__('Code Cell Content with Output');\n        this.node.setAttribute('aria-label', ariaLabel);\n        const output = (this._output = new _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_4__.OutputArea({\n            model: this.model.outputs,\n            rendermime,\n            contentFactory: contentFactory,\n            maxNumberOutputs: this.maxNumberOutputs,\n            translator: this.translator,\n            promptOverlay: true,\n            inputHistoryScope: options.inputHistoryScope,\n            showInputPlaceholder: options.showInputPlaceholder\n        }));\n        output.node.addEventListener('keydown', this._detectCaretMovementInOuput);\n        output.addClass(CELL_OUTPUT_AREA_CLASS);\n        output.toggleScrolling.connect(() => {\n            this.outputsScrolled = !this.outputsScrolled;\n        });\n        output.initialize.connect(() => {\n            this.updatePromptOverlayIcon();\n        });\n        // Defer setting placeholder as OutputArea must be instantiated before initializing the DOM\n        this.placeholder = (_a = options.placeholder) !== null && _a !== void 0 ? _a : true;\n        model.outputs.changed.connect(this.onOutputChanged, this);\n        model.outputs.stateChanged.connect(this.onOutputChanged, this);\n        model.stateChanged.connect(this.onStateChanged, this);\n    }\n    /**\n     * Create children widgets.\n     */\n    initializeDOM() {\n        if (!this.placeholder) {\n            return;\n        }\n        super.initializeDOM();\n        this._updatePrompt();\n        // Insert the output before the cell footer.\n        const outputWrapper = (this._outputWrapper = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_14__.Panel());\n        outputWrapper.addClass(CELL_OUTPUT_WRAPPER_CLASS);\n        const outputCollapser = new _collapser__WEBPACK_IMPORTED_MODULE_15__.OutputCollapser();\n        outputCollapser.addClass(CELL_OUTPUT_COLLAPSER_CLASS);\n        outputWrapper.addWidget(outputCollapser);\n        // Set a CSS if there are no outputs, and connect a signal for future\n        // changes to the number of outputs. This is for conditional styling\n        // if there are no outputs.\n        if (this.model.outputs.length === 0) {\n            this.addClass(NO_OUTPUTS_CLASS);\n        }\n        this._output.outputLengthChanged.connect(this._outputLengthHandler, this);\n        outputWrapper.addWidget(this._output);\n        const layout = this.layout;\n        const resizeHandle = new _resizeHandle__WEBPACK_IMPORTED_MODULE_19__.ResizeHandle(this.node);\n        resizeHandle.sizeChanged.connect(this._sizeChangedHandler, this);\n        layout.insertWidget(layout.widgets.length - 1, resizeHandle);\n        layout.insertWidget(layout.widgets.length - 1, outputWrapper);\n        if (this.model.isDirty) {\n            this.addClass(DIRTY_CLASS);\n        }\n        this._outputPlaceholder = new _placeholder__WEBPACK_IMPORTED_MODULE_17__.OutputPlaceholder({\n            callback: () => {\n                this.outputHidden = !this.outputHidden;\n            },\n            text: this.getOutputPlaceholderText(),\n            translator: this.translator\n        });\n        const layoutWrapper = outputWrapper.layout;\n        if (this.outputHidden) {\n            layoutWrapper.removeWidget(this._output);\n            layoutWrapper.addWidget(this._outputPlaceholder);\n            if (this.inputHidden && !outputWrapper.isHidden) {\n                this._outputWrapper.hide();\n            }\n        }\n        const trans = this.translator.load('jupyterlab');\n        const ariaLabel = this.model.outputs.length === 0\n            ? trans.__('Code Cell Content')\n            : trans.__('Code Cell Content with Output');\n        this.node.setAttribute('aria-label', ariaLabel);\n    }\n    getOutputPlaceholderText() {\n        var _a;\n        const firstOutput = this.model.outputs.get(0);\n        const outputData = firstOutput === null || firstOutput === void 0 ? void 0 : firstOutput.data;\n        if (!outputData) {\n            return undefined;\n        }\n        const supportedOutputTypes = [\n            'text/html',\n            'image/svg+xml',\n            'application/pdf',\n            'text/markdown',\n            'text/plain',\n            'application/vnd.jupyter.stderr',\n            'application/vnd.jupyter.stdout',\n            'text'\n        ];\n        const preferredOutput = supportedOutputTypes.find(mt => {\n            const data = firstOutput.data[mt];\n            return (Array.isArray(data) ? typeof data[0] : typeof data) === 'string';\n        });\n        const dataToDisplay = firstOutput.data[preferredOutput !== null && preferredOutput !== void 0 ? preferredOutput : ''];\n        if (dataToDisplay !== undefined) {\n            return (_a = (Array.isArray(dataToDisplay)\n                ? dataToDisplay\n                : dataToDisplay === null || dataToDisplay === void 0 ? void 0 : dataToDisplay.split('\\n'))) === null || _a === void 0 ? void 0 : _a.find(part => part !== '');\n        }\n        return undefined;\n    }\n    /**\n     * Initialize view state from model.\n     *\n     * #### Notes\n     * Should be called after construction. For convenience, returns this, so it\n     * can be chained in the construction, like `new Foo().initializeState();`\n     */\n    initializeState() {\n        super.initializeState();\n        this.loadScrolledState();\n        this._updatePrompt();\n        return this;\n    }\n    get headings() {\n        if (!this._headingsCache) {\n            const headings = [];\n            // Iterate over the code cell outputs to check for Markdown or HTML from which we can generate ToC headings...\n            const outputs = this.model.outputs;\n            for (let j = 0; j < outputs.length; j++) {\n                const m = outputs.get(j);\n                let htmlType = null;\n                let mdType = null;\n                Object.keys(m.data).forEach(t => {\n                    if (!mdType && _jupyterlab_toc__WEBPACK_IMPORTED_MODULE_6__.TableOfContentsUtils.Markdown.isMarkdown(t)) {\n                        mdType = t;\n                    }\n                    else if (!htmlType && _jupyterlab_toc__WEBPACK_IMPORTED_MODULE_6__.TableOfContentsUtils.isHTML(t)) {\n                        htmlType = t;\n                    }\n                });\n                // Parse HTML output\n                if (htmlType) {\n                    let htmlData = m.data[htmlType];\n                    if (typeof htmlData !== 'string') {\n                        htmlData = htmlData.join('\\n');\n                    }\n                    headings.push(..._jupyterlab_toc__WEBPACK_IMPORTED_MODULE_6__.TableOfContentsUtils.getHTMLHeadings(this._rendermime.sanitizer.sanitize(htmlData)).map(heading => {\n                        return {\n                            ...heading,\n                            outputIndex: j,\n                            type: Cell.HeadingType.HTML\n                        };\n                    }));\n                }\n                else if (mdType) {\n                    headings.push(..._jupyterlab_toc__WEBPACK_IMPORTED_MODULE_6__.TableOfContentsUtils.Markdown.getHeadings(m.data[mdType]).map(heading => {\n                        return {\n                            ...heading,\n                            outputIndex: j,\n                            type: Cell.HeadingType.Markdown\n                        };\n                    }));\n                }\n            }\n            this._headingsCache = headings;\n        }\n        return [...this._headingsCache];\n    }\n    /**\n     * Get the output area for the cell.\n     */\n    get outputArea() {\n        return this._output;\n    }\n    /**\n     * The view state of output being collapsed.\n     */\n    get outputHidden() {\n        return this._outputHidden;\n    }\n    set outputHidden(value) {\n        var _a;\n        if (this._outputHidden === value) {\n            return;\n        }\n        if (!this.placeholder) {\n            const layout = this._outputWrapper.layout;\n            if (value) {\n                layout.removeWidget(this._output);\n                layout.addWidget(this._outputPlaceholder);\n                if (this.inputHidden && !this._outputWrapper.isHidden) {\n                    this._outputWrapper.hide();\n                }\n                if (this._outputPlaceholder) {\n                    this._outputPlaceholder.text = (_a = this.getOutputPlaceholderText()) !== null && _a !== void 0 ? _a : '';\n                }\n            }\n            else {\n                if (this._outputWrapper.isHidden) {\n                    this._outputWrapper.show();\n                }\n                layout.removeWidget(this._outputPlaceholder);\n                layout.addWidget(this._output);\n            }\n        }\n        this._outputHidden = value;\n        if (this.syncCollapse) {\n            this.saveCollapseState();\n        }\n    }\n    /**\n     * Save view collapse state to model\n     */\n    saveCollapseState() {\n        // Because collapse state for a code cell involves two different pieces of\n        // metadata (the `collapsed` and `jupyter` metadata keys), we block reacting\n        // to changes in metadata until we have fully committed our changes.\n        // Otherwise setting one key can trigger a write to the other key to\n        // maintain the synced consistency.\n        this.model.sharedModel.transact(() => {\n            super.saveCollapseState();\n            const collapsed = this.model.getMetadata('collapsed');\n            if ((this.outputHidden && collapsed === true) ||\n                (!this.outputHidden && collapsed === undefined)) {\n                return;\n            }\n            // Do not set jupyter.outputs_hidden since it is redundant. See\n            // and https://github.com/jupyter/nbformat/issues/137\n            if (this.outputHidden) {\n                this.model.setMetadata('collapsed', true);\n            }\n            else {\n                this.model.deleteMetadata('collapsed');\n            }\n        }, false, 'silent-change');\n    }\n    /**\n     * Revert view collapse state from model.\n     *\n     * We consider the `collapsed` metadata key as the source of truth for outputs\n     * being hidden.\n     */\n    loadCollapseState() {\n        super.loadCollapseState();\n        this.outputHidden = !!this.model.getMetadata('collapsed');\n    }\n    /**\n     * Whether the output is in a scrolled state?\n     */\n    get outputsScrolled() {\n        return this._outputsScrolled;\n    }\n    set outputsScrolled(value) {\n        this.toggleClass('jp-mod-outputsScrolled', value);\n        this._outputsScrolled = value;\n        if (this.syncScrolled) {\n            this.saveScrolledState();\n        }\n        this.updatePromptOverlayIcon();\n    }\n    /**\n     * Update the Prompt Overlay Icon\n     */\n    updatePromptOverlayIcon() {\n        var _a;\n        const overlay = _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_2__.DOMUtils.findElement(this.node, 'jp-OutputArea-promptOverlay');\n        if (!overlay) {\n            return;\n        }\n        // If you are changing this, don't forget about svg.\n        const ICON_HEIGHT = 16 + 4 + 4; // 4px for padding\n        if (overlay.clientHeight <= ICON_HEIGHT) {\n            (_a = overlay.firstChild) === null || _a === void 0 ? void 0 : _a.remove();\n            return;\n        }\n        let overlayTitle;\n        if (this._outputsScrolled) {\n            _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_8__.expandIcon.element({\n                container: overlay\n            });\n            overlayTitle = 'Expand Output';\n        }\n        else {\n            _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_8__.collapseIcon.element({\n                container: overlay\n            });\n            overlayTitle = 'Collapse Output';\n        }\n        const trans = this.translator.load('jupyterlab');\n        overlay.title = trans.__(overlayTitle);\n    }\n    /**\n     * Save view collapse state to model\n     */\n    saveScrolledState() {\n        const current = this.model.getMetadata('scrolled');\n        if ((this.outputsScrolled && current === true) ||\n            (!this.outputsScrolled && current === undefined)) {\n            return;\n        }\n        if (this.outputsScrolled) {\n            this.model.setMetadata('scrolled', true);\n        }\n        else {\n            this.outputArea.node.style.height = '';\n            this.model.deleteMetadata('scrolled');\n        }\n    }\n    /**\n     * Revert view collapse state from model.\n     */\n    loadScrolledState() {\n        // We don't have the notion of 'auto' scrolled, so we make it false.\n        if (this.model.getMetadata('scrolled') === 'auto') {\n            this.outputsScrolled = false;\n        }\n        else {\n            this.outputsScrolled = !!this.model.getMetadata('scrolled');\n        }\n    }\n    /**\n     * Whether to sync the scrolled state to the cell model.\n     */\n    get syncScrolled() {\n        return this._syncScrolled;\n    }\n    set syncScrolled(value) {\n        if (this._syncScrolled === value) {\n            return;\n        }\n        this._syncScrolled = value;\n        if (value) {\n            this.loadScrolledState();\n        }\n    }\n    /**\n     * Handle the input being hidden.\n     *\n     * #### Notes\n     * This method is called by the case cell implementation and is\n     * subclasses here so the code cell can watch to see when input\n     * is hidden without accessing private state.\n     */\n    handleInputHidden(value) {\n        if (this.placeholder) {\n            return;\n        }\n        if (!value && this._outputWrapper.isHidden) {\n            this._outputWrapper.show();\n        }\n        else if (value && !this._outputWrapper.isHidden && this._outputHidden) {\n            this._outputWrapper.hide();\n        }\n    }\n    /**\n     * Clone the cell, using the same model.\n     */\n    clone() {\n        const constructor = this.constructor;\n        return new constructor({\n            model: this.model,\n            contentFactory: this.contentFactory,\n            rendermime: this._rendermime,\n            placeholder: false,\n            translator: this.translator\n        });\n    }\n    /**\n     * Clone the OutputArea alone, returning a simplified output area, using the same model.\n     */\n    cloneOutputArea() {\n        return new _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_4__.SimplifiedOutputArea({\n            model: this.model.outputs,\n            contentFactory: this.contentFactory,\n            rendermime: this._rendermime\n        });\n    }\n    /**\n     * Dispose of the resources used by the widget.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._output.outputLengthChanged.disconnect(this._outputLengthHandler, this);\n        this._output.node.removeEventListener('keydown', this._detectCaretMovementInOuput);\n        this._rendermime = null;\n        this._output = null;\n        this._outputWrapper = null;\n        this._outputPlaceholder = null;\n        super.dispose();\n    }\n    /**\n     * Handle changes in the model.\n     */\n    onStateChanged(model, args) {\n        switch (args.name) {\n            case 'executionCount':\n                if (args.newValue !== null) {\n                    // Mark execution state if execution count was set.\n                    this.model.executionState = 'idle';\n                }\n                this._updatePrompt();\n                break;\n            case 'executionState':\n                this._updatePrompt();\n                break;\n            case 'isDirty':\n                if (model.isDirty) {\n                    this.addClass(DIRTY_CLASS);\n                }\n                else {\n                    this.removeClass(DIRTY_CLASS);\n                }\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Callback on output changes\n     */\n    onOutputChanged() {\n        var _a;\n        this._headingsCache = null;\n        if (this._outputPlaceholder && this.outputHidden) {\n            this._outputPlaceholder.text = (_a = this.getOutputPlaceholderText()) !== null && _a !== void 0 ? _a : '';\n        }\n        // This is to hide/show icon on single line output.\n        this.updatePromptOverlayIcon();\n        // Clear output area when empty\n        const height = this.outputArea.node.style.height;\n        if (this.model.outputs.length === 0 && height !== '') {\n            this._lastOutputHeight = height;\n            this.outputArea.node.style.height = '';\n        }\n        else if (this.model.outputs.length > 0 && height === '') {\n            this.outputArea.node.style.height = this._lastOutputHeight;\n        }\n    }\n    /**\n     * Handle changes in the metadata.\n     */\n    onMetadataChanged(model, args) {\n        switch (args.key) {\n            case 'scrolled':\n                if (this.syncScrolled) {\n                    this.loadScrolledState();\n                }\n                break;\n            case 'collapsed':\n                if (this.syncCollapse) {\n                    this.loadCollapseState();\n                }\n                break;\n            default:\n                break;\n        }\n        super.onMetadataChanged(model, args);\n    }\n    _updatePrompt() {\n        let prompt;\n        if (this.model.executionState == 'running') {\n            prompt = '*';\n        }\n        else {\n            prompt = `${this.model.executionCount || ''}`;\n        }\n        this._setPrompt(prompt);\n    }\n    /**\n     * Handle changes in the number of outputs in the output area.\n     */\n    _outputLengthHandler(sender, args) {\n        const force = args === 0 ? true : false;\n        this.toggleClass(NO_OUTPUTS_CLASS, force);\n        const trans = this.translator.load('jupyterlab');\n        const ariaLabel = force\n            ? trans.__('Code Cell Content')\n            : trans.__('Code Cell Content with Output');\n        this.node.setAttribute('aria-label', ariaLabel);\n    }\n    /**\n     * Handle changes in input/output proportions in side-by-side mode.\n     */\n    _sizeChangedHandler(sender) {\n        this._displayChanged.emit();\n    }\n}\n/**\n * The namespace for the `CodeCell` class statics.\n */\n(function (CodeCell) {\n    /**\n     * Execute a cell given a client session.\n     */\n    async function execute(cell, sessionContext, metadata) {\n        var _a;\n        const model = cell.model;\n        const code = model.sharedModel.getSource();\n        if (!code.trim() || !((_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel)) {\n            model.sharedModel.transact(() => {\n                model.clearExecution();\n            }, false);\n            return;\n        }\n        const cellId = { cellId: model.sharedModel.getId() };\n        metadata = {\n            ...model.metadata,\n            ...metadata,\n            ...cellId\n        };\n        const { recordTiming } = metadata;\n        model.sharedModel.transact(() => {\n            model.clearExecution();\n            cell.outputHidden = false;\n        }, false, 'silent-change');\n        // note: in future we would like to distinguish running from scheduled\n        model.executionState = 'running';\n        model.trusted = true;\n        let future;\n        try {\n            const msgPromise = _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_4__.OutputArea.execute(code, cell.outputArea, sessionContext, metadata);\n            // cell.outputArea.future assigned synchronously in `execute`\n            if (recordTiming) {\n                const recordTimingHook = (msg) => {\n                    let label;\n                    switch (msg.header.msg_type) {\n                        case 'status':\n                            label = `status.${msg.content.execution_state}`;\n                            break;\n                        case 'execute_input':\n                            label = 'execute_input';\n                            break;\n                        default:\n                            return true;\n                    }\n                    // If the data is missing, estimate it to now\n                    // Date was added in 5.1: https://jupyter-client.readthedocs.io/en/stable/messaging.html#message-header\n                    const value = msg.header.date || new Date().toISOString();\n                    const timingInfo = Object.assign({}, model.getMetadata('execution'));\n                    timingInfo[`iopub.${label}`] = value;\n                    model.setMetadata('execution', timingInfo);\n                    return true;\n                };\n                cell.outputArea.future.registerMessageHook(recordTimingHook);\n            }\n            else {\n                model.deleteMetadata('execution');\n            }\n            // Save this execution's future so we can compare in the catch below.\n            future = cell.outputArea.future;\n            const msg = (await msgPromise);\n            model.executionCount = msg.content.execution_count;\n            if (recordTiming) {\n                const timingInfo = Object.assign({}, model.getMetadata('execution'));\n                const started = msg.metadata.started;\n                // Started is not in the API, but metadata IPyKernel sends\n                if (started) {\n                    timingInfo['shell.execute_reply.started'] = started;\n                }\n                // Per above, the 5.0 spec does not assume date, so we estimate is required\n                const finished = msg.header.date;\n                timingInfo['shell.execute_reply'] =\n                    finished || new Date().toISOString();\n                model.setMetadata('execution', timingInfo);\n            }\n            return msg;\n        }\n        catch (e) {\n            // If we started executing, and the cell is still indicating this\n            // execution, clear the prompt.\n            if (future && !cell.isDisposed && cell.outputArea.future === future) {\n                cell.model.executionState = 'idle';\n                if (recordTiming && future.isDisposed) {\n                    // Record the time when the cell execution was aborted\n                    const timingInfo = Object.assign({}, model.getMetadata('execution'));\n                    timingInfo['execution_failed'] = new Date().toISOString();\n                    model.setMetadata('execution', timingInfo);\n                }\n            }\n            throw e;\n        }\n    }\n    CodeCell.execute = execute;\n})(CodeCell || (CodeCell = {}));\n/**\n * `AttachmentsCell` - A base class for a cell widget that allows\n *  attachments to be drag/drop'd or pasted onto it\n */\nclass AttachmentsCell extends Cell {\n    /**\n     * Handle the DOM events for the widget.\n     *\n     * @param event - The DOM event sent to the widget.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the notebook panel's node. It should\n     * not be called directly by user code.\n     */\n    handleEvent(event) {\n        switch (event.type) {\n            case 'lm-dragover':\n                this._evtDragOver(event);\n                break;\n            case 'lm-drop':\n                this._evtDrop(event);\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Get the editor options at initialization.\n     *\n     * @returns Editor options\n     */\n    getEditorOptions() {\n        var _a, _b;\n        const base = (_a = super.getEditorOptions()) !== null && _a !== void 0 ? _a : {};\n        base.extensions = [\n            ...((_b = base.extensions) !== null && _b !== void 0 ? _b : []),\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView.domEventHandlers({\n                dragenter: (event) => {\n                    event.preventDefault();\n                },\n                dragover: (event) => {\n                    event.preventDefault();\n                },\n                drop: (event) => {\n                    this._evtNativeDrop(event);\n                },\n                paste: (event) => {\n                    this._evtPaste(event);\n                }\n            })\n        ];\n        return base;\n    }\n    /**\n     * Handle `after-attach` messages for the widget.\n     */\n    onAfterAttach(msg) {\n        super.onAfterAttach(msg);\n        const node = this.node;\n        node.addEventListener('lm-dragover', this);\n        node.addEventListener('lm-drop', this);\n    }\n    /**\n     * A message handler invoked on a `'before-detach'`\n     * message\n     */\n    onBeforeDetach(msg) {\n        const node = this.node;\n        node.removeEventListener('lm-dragover', this);\n        node.removeEventListener('lm-drop', this);\n        super.onBeforeDetach(msg);\n    }\n    _evtDragOver(event) {\n        const supportedMimeType = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_10__.some)(_jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_5__.imageRendererFactory.mimeTypes, mimeType => {\n            if (!event.mimeData.hasData(CONTENTS_MIME_RICH)) {\n                return false;\n            }\n            const data = event.mimeData.getData(CONTENTS_MIME_RICH);\n            return data.model.mimetype === mimeType;\n        });\n        if (!supportedMimeType) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        event.dropAction = event.proposedAction;\n    }\n    /**\n     * Handle the `paste` event for the widget\n     */\n    _evtPaste(event) {\n        var _a;\n        const isEditable = (_a = this.model.getMetadata('editable')) !== null && _a !== void 0 ? _a : true;\n        if (event.clipboardData && isEditable) {\n            const items = event.clipboardData.items;\n            for (let i = 0; i < items.length; i++) {\n                if (items[i].type === 'text/plain') {\n                    // Skip if this text is the path to a file\n                    if (i < items.length - 1 && items[i + 1].kind === 'file') {\n                        continue;\n                    }\n                    items[i].getAsString(text => {\n                        var _a, _b;\n                        (_b = (_a = this.editor).replaceSelection) === null || _b === void 0 ? void 0 : _b.call(_a, text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n'));\n                    });\n                }\n                this._attachFiles(event.clipboardData.items);\n            }\n        }\n        event.preventDefault();\n    }\n    /**\n     * Handle the `drop` event for the widget\n     */\n    _evtNativeDrop(event) {\n        if (event.dataTransfer) {\n            this._attachFiles(event.dataTransfer.items);\n        }\n        event.preventDefault();\n    }\n    /**\n     * Handle the `'lm-drop'` event for the widget.\n     */\n    _evtDrop(event) {\n        const supportedMimeTypes = event.mimeData.types().filter(mimeType => {\n            if (mimeType === CONTENTS_MIME_RICH) {\n                const data = event.mimeData.getData(CONTENTS_MIME_RICH);\n                return (_jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_5__.imageRendererFactory.mimeTypes.indexOf(data.model.mimetype) !== -1);\n            }\n            return _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_5__.imageRendererFactory.mimeTypes.indexOf(mimeType) !== -1;\n        });\n        if (supportedMimeTypes.length === 0) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        if (event.proposedAction === 'none') {\n            event.dropAction = 'none';\n            return;\n        }\n        event.dropAction = 'copy';\n        for (const mimeType of supportedMimeTypes) {\n            if (mimeType === CONTENTS_MIME_RICH) {\n                const { model, withContent } = event.mimeData.getData(CONTENTS_MIME_RICH);\n                if (model.type === 'file') {\n                    const URI = this._generateURI(model.name);\n                    this.updateCellSourceWithAttachment(model.name, URI);\n                    void withContent().then(fullModel => {\n                        this.model.attachments.set(URI, {\n                            [fullModel.mimetype]: fullModel.content\n                        });\n                    });\n                }\n            }\n            else {\n                // Pure mimetype, no useful name to infer\n                const URI = this._generateURI();\n                this.model.attachments.set(URI, {\n                    [mimeType]: event.mimeData.getData(mimeType)\n                });\n                this.updateCellSourceWithAttachment(URI, URI);\n            }\n        }\n    }\n    /**\n     * Attaches all DataTransferItems (obtained from\n     * clipboard or native drop events) to the cell\n     */\n    _attachFiles(items) {\n        for (let i = 0; i < items.length; i++) {\n            const item = items[i];\n            if (item.kind === 'file') {\n                const blob = item.getAsFile();\n                if (blob) {\n                    this._attachFile(blob);\n                }\n            }\n        }\n    }\n    /**\n     * Takes in a file object and adds it to\n     * the cell attachments\n     */\n    _attachFile(blob) {\n        const reader = new FileReader();\n        reader.onload = evt => {\n            const { href, protocol } = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_3__.URLExt.parse(reader.result);\n            if (protocol !== 'data:') {\n                return;\n            }\n            const dataURIRegex = /([\\w+\\/\\+]+)?(?:;(charset=[\\w\\d-]*|base64))?,(.*)/;\n            const matches = dataURIRegex.exec(href);\n            if (!matches || matches.length !== 4) {\n                return;\n            }\n            const mimeType = matches[1];\n            const encodedData = matches[3];\n            const bundle = { [mimeType]: encodedData };\n            const URI = this._generateURI(blob.name);\n            if (mimeType.startsWith('image/')) {\n                this.model.attachments.set(URI, bundle);\n                this.updateCellSourceWithAttachment(blob.name, URI);\n            }\n        };\n        reader.onerror = evt => {\n            console.error(`Failed to attach ${blob.name}` + evt);\n        };\n        reader.readAsDataURL(blob);\n    }\n    /**\n     * Generates a unique URI for a file\n     * while preserving the file extension.\n     */\n    _generateURI(name = '') {\n        const lastIndex = name.lastIndexOf('.');\n        return lastIndex !== -1\n            ? _lumino_coreutils__WEBPACK_IMPORTED_MODULE_9__.UUID.uuid4().concat(name.substring(lastIndex))\n            : _lumino_coreutils__WEBPACK_IMPORTED_MODULE_9__.UUID.uuid4();\n    }\n}\n/** ****************************************************************************\n * MarkdownCell\n ******************************************************************************/\n/**\n * A widget for a Markdown cell.\n *\n * #### Notes\n * Things get complicated if we want the rendered text to update\n * any time the text changes, the text editor model changes,\n * or the input area model changes.  We don't support automatically\n * updating the rendered text in all of these cases.\n */\nclass MarkdownCell extends AttachmentsCell {\n    /**\n     * Construct a Markdown cell widget.\n     */\n    constructor(options) {\n        var _a, _b, _c, _d;\n        super({ ...options, placeholder: true });\n        this._headingsCache = null;\n        this._headingCollapsedChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_13__.Signal(this);\n        this._prevText = '';\n        this._rendered = true;\n        this._renderedChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_13__.Signal(this);\n        this._showEditorForReadOnlyMarkdown = true;\n        this.addClass(MARKDOWN_CELL_CLASS);\n        this.model.contentChanged.connect(this.onContentChanged, this);\n        const trans = this.translator.load('jupyterlab');\n        this.node.setAttribute('aria-label', trans.__('Markdown Cell Content'));\n        // Ensure we can resolve attachments:\n        this._rendermime = options.rendermime.clone({\n            resolver: new _jupyterlab_attachments__WEBPACK_IMPORTED_MODULE_20__.AttachmentsResolver({\n                parent: (_a = options.rendermime.resolver) !== null && _a !== void 0 ? _a : undefined,\n                model: this.model.attachments\n            })\n        });\n        this._renderer = this._rendermime.createRenderer('text/markdown');\n        this._renderer.addClass(MARKDOWN_OUTPUT_CLASS);\n        // Check if heading cell is set to be collapsed\n        this._headingCollapsed = ((_b = this.model.getMetadata(MARKDOWN_HEADING_COLLAPSED)) !== null && _b !== void 0 ? _b : false);\n        this._showEditorForReadOnlyMarkdown =\n            (_c = options.showEditorForReadOnlyMarkdown) !== null && _c !== void 0 ? _c : MarkdownCell.defaultShowEditorForReadOnlyMarkdown;\n        // Defer setting placeholder as the renderer must be instantiated before initializing the DOM\n        this.placeholder = (_d = options.placeholder) !== null && _d !== void 0 ? _d : true;\n        this._monitor = new _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_3__.ActivityMonitor({\n            signal: this.model.contentChanged,\n            timeout: RENDER_TIMEOUT\n        });\n        // Throttle the rendering rate of the widget.\n        this.ready\n            .then(() => {\n            if (this.isDisposed) {\n                // Bail early\n                return;\n            }\n            this._monitor.activityStopped.connect(() => {\n                if (this._rendered) {\n                    this.update();\n                }\n            }, this);\n        })\n            .catch(reason => {\n            console.error('Failed to be ready', reason);\n        });\n    }\n    /**\n     * Text that represents the highest heading (i.e. lowest level) if cell is a heading.\n     * Returns empty string if not a heading.\n     */\n    get headingInfo() {\n        // Use table of content algorithm for consistency\n        const headings = this.headings;\n        if (headings.length > 0) {\n            // Return the highest level\n            const { text, level } = headings.reduce((prev, curr) => (prev.level <= curr.level ? prev : curr), headings[0]);\n            return { text, level };\n        }\n        else {\n            return { text: '', level: -1 };\n        }\n    }\n    get headings() {\n        if (!this._headingsCache) {\n            // Use table of content algorithm for consistency\n            const headings = _jupyterlab_toc__WEBPACK_IMPORTED_MODULE_6__.TableOfContentsUtils.Markdown.getHeadings(this.model.sharedModel.getSource());\n            this._headingsCache = headings.map(h => {\n                return { ...h, type: Cell.HeadingType.Markdown };\n            });\n        }\n        return [...this._headingsCache];\n    }\n    /**\n     * Whether the heading is collapsed or not.\n     */\n    get headingCollapsed() {\n        return this._headingCollapsed;\n    }\n    set headingCollapsed(value) {\n        var _a;\n        if (this._headingCollapsed !== value) {\n            this._headingCollapsed = value;\n            if (value) {\n                this.model.setMetadata(MARKDOWN_HEADING_COLLAPSED, value);\n            }\n            else if (this.model.getMetadata(MARKDOWN_HEADING_COLLAPSED) !== 'undefined') {\n                this.model.deleteMetadata(MARKDOWN_HEADING_COLLAPSED);\n            }\n            const collapseButton = (_a = this.inputArea) === null || _a === void 0 ? void 0 : _a.promptNode.getElementsByClassName(HEADING_COLLAPSER_CLASS)[0];\n            if (collapseButton) {\n                if (value) {\n                    collapseButton.classList.add('jp-mod-collapsed');\n                }\n                else {\n                    collapseButton.classList.remove('jp-mod-collapsed');\n                }\n            }\n            this.renderCollapseButtons(this._renderer);\n            this._headingCollapsedChanged.emit(this._headingCollapsed);\n        }\n    }\n    /**\n     * Number of collapsed sub cells.\n     */\n    get numberChildNodes() {\n        return this._numberChildNodes;\n    }\n    set numberChildNodes(value) {\n        this._numberChildNodes = value;\n        this.renderCollapseButtons(this._renderer);\n    }\n    /**\n     * Signal emitted when the cell collapsed state changes.\n     */\n    get headingCollapsedChanged() {\n        return this._headingCollapsedChanged;\n    }\n    /**\n     * Whether the cell is rendered.\n     */\n    get rendered() {\n        return this._rendered;\n    }\n    set rendered(value) {\n        // Show cell as rendered when cell is not editable\n        if (this.readOnly && this._showEditorForReadOnlyMarkdown === false) {\n            value = true;\n        }\n        if (value === this._rendered) {\n            return;\n        }\n        this._rendered = value;\n        this._handleRendered()\n            .then(() => {\n            // If the rendered state changed, raise an event.\n            this._displayChanged.emit();\n            this._renderedChanged.emit(this._rendered);\n        })\n            .catch(reason => {\n            console.error('Failed to render', reason);\n        });\n    }\n    /**\n     * Signal emitted when the markdown cell rendered state changes\n     */\n    get renderedChanged() {\n        return this._renderedChanged;\n    }\n    /*\n     * Whether the Markdown editor is visible in read-only mode.\n     */\n    get showEditorForReadOnly() {\n        return this._showEditorForReadOnlyMarkdown;\n    }\n    set showEditorForReadOnly(value) {\n        this._showEditorForReadOnlyMarkdown = value;\n        if (value === false) {\n            this.rendered = true;\n        }\n    }\n    /**\n     * Renderer\n     */\n    get renderer() {\n        return this._renderer;\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._monitor.dispose();\n        super.dispose();\n    }\n    /**\n     * Create children widgets.\n     */\n    initializeDOM() {\n        if (!this.placeholder) {\n            return;\n        }\n        super.initializeDOM();\n        this.renderCollapseButtons(this._renderer);\n        this._handleRendered().catch(reason => {\n            console.error('Failed to render', reason);\n        });\n    }\n    maybeCreateCollapseButton() {\n        var _a;\n        const { level } = this.headingInfo;\n        if (level > 0 &&\n            ((_a = this.inputArea) === null || _a === void 0 ? void 0 : _a.promptNode.getElementsByClassName(HEADING_COLLAPSER_CLASS).length) == 0) {\n            let collapseButton = this.inputArea.promptNode.appendChild(document.createElement('button'));\n            collapseButton.className = `jp-Button ${HEADING_COLLAPSER_CLASS}`;\n            collapseButton.setAttribute('data-heading-level', level.toString());\n            if (this._headingCollapsed) {\n                collapseButton.classList.add('jp-mod-collapsed');\n            }\n            else {\n                collapseButton.classList.remove('jp-mod-collapsed');\n            }\n            collapseButton.onclick = (event) => {\n                this.headingCollapsed = !this.headingCollapsed;\n            };\n        }\n    }\n    /**\n     * Create, update or remove the hidden cells button.\n     * Note that the actual visibility is controlled in Static Notebook by toggling jp-mod-showHiddenCellsButton class.\n     */\n    maybeCreateOrUpdateExpandButton() {\n        const showHiddenCellsButtonList = this.node.getElementsByClassName(SHOW_HIDDEN_CELLS_CLASS);\n        let trans = this.translator.load('jupyterlab');\n        let buttonText = trans._n('%1 cell hidden', '%1 cells hidden', this._numberChildNodes);\n        let needToCreateButton = this.headingCollapsed &&\n            this._numberChildNodes > 0 &&\n            showHiddenCellsButtonList.length == 0;\n        if (needToCreateButton) {\n            const newShowHiddenCellsButton = document.createElement('button');\n            newShowHiddenCellsButton.className = `jp-mod-minimal jp-Button ${SHOW_HIDDEN_CELLS_CLASS}`;\n            _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_8__.addIcon.render(newShowHiddenCellsButton);\n            const buttonTextElement = document.createElement('div');\n            buttonTextElement.textContent = buttonText;\n            newShowHiddenCellsButton.appendChild(buttonTextElement);\n            newShowHiddenCellsButton.onclick = () => {\n                this.headingCollapsed = false;\n            };\n            this.node.appendChild(newShowHiddenCellsButton);\n        }\n        let needToUpdateButtonText = this.headingCollapsed &&\n            this._numberChildNodes > 0 &&\n            showHiddenCellsButtonList.length == 1;\n        if (needToUpdateButtonText) {\n            showHiddenCellsButtonList[0].childNodes[1].textContent = buttonText;\n        }\n        let needToRemoveButton = !(this.headingCollapsed && this._numberChildNodes > 0);\n        if (needToRemoveButton) {\n            for (const button of showHiddenCellsButtonList) {\n                this.node.removeChild(button);\n            }\n        }\n    }\n    /**\n     * Callback on content changed\n     */\n    onContentChanged() {\n        super.onContentChanged();\n        this._headingsCache = null;\n    }\n    /**\n     * Render the collapse button for heading cells,\n     * and for collapsed heading cells render the \"expand hidden cells\"\n     * button.\n     */\n    renderCollapseButtons(widget) {\n        this.node.classList.toggle(MARKDOWN_HEADING_COLLAPSED, this._headingCollapsed);\n        this.maybeCreateCollapseButton();\n        this.maybeCreateOrUpdateExpandButton();\n    }\n    /**\n     * Render an input instead of the text editor.\n     */\n    renderInput(widget) {\n        this.addClass(RENDERED_CLASS);\n        if (!this.placeholder && !this.isDisposed) {\n            this.renderCollapseButtons(widget);\n            this.inputArea.renderInput(widget);\n        }\n    }\n    /**\n     * Show the text editor instead of rendered input.\n     */\n    showEditor() {\n        this.removeClass(RENDERED_CLASS);\n        if (!this.placeholder && !this.isDisposed) {\n            this.inputArea.showEditor();\n            // if this is going to be a heading, place the cursor accordingly\n            let numHashAtStart = (this.model.sharedModel\n                .getSource()\n                .match(/^#+/g) || [''])[0].length;\n            if (numHashAtStart > 0) {\n                this.inputArea.editor.setCursorPosition({\n                    column: numHashAtStart + 1,\n                    line: 0\n                }, { scroll: false });\n            }\n        }\n    }\n    /*\n     * Handle `update-request` messages.\n     */\n    onUpdateRequest(msg) {\n        // Make sure we are properly rendered.\n        this._handleRendered().catch(reason => {\n            console.error('Failed to render', reason);\n        });\n        super.onUpdateRequest(msg);\n    }\n    /**\n     * Modify the cell source to include a reference to the attachment.\n     */\n    updateCellSourceWithAttachment(attachmentName, URI) {\n        var _a, _b;\n        const textToBeAppended = `![${attachmentName}](attachment:${URI !== null && URI !== void 0 ? URI : attachmentName})`;\n        // TODO this should be done on the model...\n        (_b = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.replaceSelection) === null || _b === void 0 ? void 0 : _b.call(_a, textToBeAppended);\n    }\n    /**\n     * Handle the rendered state.\n     */\n    async _handleRendered() {\n        if (!this._rendered) {\n            this.showEditor();\n        }\n        else {\n            // TODO: It would be nice for the cell to provide a way for\n            // its consumers to hook into when the rendering is done.\n            await this._updateRenderedInput();\n            if (this._rendered) {\n                // The rendered flag may be updated in the mean time\n                this.renderInput(this._renderer);\n            }\n        }\n    }\n    /**\n     * Update the rendered input.\n     */\n    _updateRenderedInput() {\n        if (this.placeholder) {\n            return Promise.resolve();\n        }\n        const model = this.model;\n        const text = (model && model.sharedModel.getSource()) || DEFAULT_MARKDOWN_TEXT;\n        // Do not re-render if the text has not changed.\n        if (text !== this._prevText) {\n            const mimeModel = new _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_5__.MimeModel({ data: { 'text/markdown': text } });\n            this._prevText = text;\n            return this._renderer.renderModel(mimeModel);\n        }\n        return Promise.resolve();\n    }\n    /**\n     * Clone the cell, using the same model.\n     */\n    clone() {\n        const constructor = this.constructor;\n        return new constructor({\n            model: this.model,\n            contentFactory: this.contentFactory,\n            rendermime: this._rendermime,\n            placeholder: false,\n            translator: this.translator\n        });\n    }\n}\n/**\n * The namespace for the `CodeCell` class statics.\n */\n(function (MarkdownCell) {\n    /**\n     * Default value for showEditorForReadOnlyMarkdown.\n     */\n    MarkdownCell.defaultShowEditorForReadOnlyMarkdown = true;\n})(MarkdownCell || (MarkdownCell = {}));\n/** ****************************************************************************\n * RawCell\n ******************************************************************************/\n/**\n * A widget for a raw cell.\n */\nclass RawCell extends Cell {\n    /**\n     * Construct a raw cell widget.\n     */\n    constructor(options) {\n        super(options);\n        this.addClass(RAW_CELL_CLASS);\n        const trans = this.translator.load('jupyterlab');\n        this.node.setAttribute('aria-label', trans.__('Raw Cell Content'));\n    }\n    /**\n     * Clone the cell, using the same model.\n     */\n    clone() {\n        const constructor = this.constructor;\n        return new constructor({\n            model: this.model,\n            contentFactory: this.contentFactory,\n            placeholder: false,\n            translator: this.translator\n        });\n    }\n}\n//# sourceMappingURL=widget.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/cells/lib/widget.js?");

/***/ })

}]);