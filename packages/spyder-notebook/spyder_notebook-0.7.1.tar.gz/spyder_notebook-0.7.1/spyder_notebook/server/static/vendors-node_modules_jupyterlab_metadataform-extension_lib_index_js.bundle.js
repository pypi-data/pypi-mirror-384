"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["vendors-node_modules_jupyterlab_metadataform-extension_lib_index_js"],{

/***/ "../node_modules/@jupyterlab/metadataform-extension/lib/index.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@jupyterlab/metadataform-extension/lib/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/notebook */ \"webpack/sharing/consume/default/@jupyterlab/notebook/@jupyterlab/notebook\");\n/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/settingregistry */ \"webpack/sharing/consume/default/@jupyterlab/settingregistry/@jupyterlab/settingregistry\");\n/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/translation */ \"webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation\");\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/ui-components */ \"webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components\");\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lumino/coreutils */ \"webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _jupyterlab_metadataform__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @jupyterlab/metadataform */ \"webpack/sharing/consume/default/@jupyterlab/metadataform/@jupyterlab/metadataform\");\n/* harmony import */ var _jupyterlab_metadataform__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_metadataform__WEBPACK_IMPORTED_MODULE_5__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module metadataform-extension\n */\n\n\n\n\n\n\nconst PLUGIN_ID = '@jupyterlab/metadataform-extension:metadataforms';\nvar Private;\n(function (Private) {\n    async function loadSettingsMetadataForm(app, registry, notebookTools, translator, formComponentRegistry) {\n        var _a;\n        let canonical;\n        let loaded = {};\n        /**\n         * Populate the plugin's schema defaults.\n         */\n        function populate(schema) {\n            loaded = {};\n            schema.properties.metadataforms.default = Object.keys(registry.plugins)\n                .map(plugin => {\n                var _a;\n                const metadataForms = (_a = registry.plugins[plugin].schema['jupyter.lab.metadataforms']) !== null && _a !== void 0 ? _a : [];\n                metadataForms.forEach(metadataForm => {\n                    metadataForm._origin = plugin;\n                });\n                loaded[plugin] = metadataForms;\n                return metadataForms;\n            })\n                .concat([schema['jupyter.lab.metadataforms']])\n                .reduce((acc, val) => {\n                // If a MetadataForm with the same ID already exists,\n                // the metadataKeys will be concatenated to this MetadataForm's metadataKeys .\n                // Otherwise, the whole MetadataForm will be pushed as a new form.\n                val.forEach(value => {\n                    const metadataForm = acc.find(addedValue => {\n                        return addedValue.id === value.id;\n                    });\n                    if (metadataForm) {\n                        // TODO do insertion of metadataSchema properties in a generic way.\n                        // Currently this only support 'properties', 'allOf' and 'required'.\n                        //  - add or replace entries if it is an object.\n                        //  - concat if it is an array.\n                        //  - replace if it is a primitive ?\n                        // Includes new metadataKey in the existing metadataSchema.\n                        // Overwrites if the metadataKey already exists.\n                        for (let [metadataKey, properties] of Object.entries(value.metadataSchema.properties)) {\n                            metadataForm.metadataSchema.properties[metadataKey] =\n                                properties;\n                        }\n                        // Includes required fields.\n                        if (value.metadataSchema.required) {\n                            if (!metadataForm.metadataSchema.required) {\n                                metadataForm.metadataSchema.required =\n                                    value.metadataSchema.required;\n                            }\n                            else {\n                                metadataForm.metadataSchema.required.concat(value.metadataSchema.required);\n                            }\n                        }\n                        // Includes allOf array in the existing metadataSchema.\n                        if (value.metadataSchema.allOf) {\n                            if (!metadataForm.metadataSchema.allOf) {\n                                metadataForm.metadataSchema.allOf =\n                                    value.metadataSchema.allOf;\n                            }\n                            else {\n                                metadataForm.metadataSchema.allOf.concat(value.metadataSchema.allOf);\n                            }\n                        }\n                        // Includes uiSchema in the existing uiSchema.\n                        // Overwrites if the uiSchema already exists for that metadataKey.\n                        if (value.uiSchema) {\n                            if (!metadataForm.uiSchema)\n                                metadataForm.uiSchema = {};\n                            for (let [metadataKey, ui] of Object.entries(value.uiSchema)) {\n                                metadataForm.uiSchema[metadataKey] = ui;\n                            }\n                        }\n                        // Includes metadataOptions in the existing uiSchema.\n                        // Overwrites if options already exists for that metadataKey.\n                        if (value.metadataOptions) {\n                            if (!metadataForm.metadataOptions)\n                                metadataForm.metadataOptions = {};\n                            for (let [metadataKey, options] of Object.entries(value.metadataOptions)) {\n                                metadataForm.metadataOptions[metadataKey] = options;\n                            }\n                        }\n                    }\n                    else {\n                        acc.push(value);\n                    }\n                });\n                return acc;\n            }, []); // flatten one level;\n        }\n        // Transform the plugin object to return different schema than the default.\n        registry.transform(PLUGIN_ID, {\n            compose: plugin => {\n                var _a, _b, _c, _d;\n                // Only override the canonical schema the first time.\n                if (!canonical) {\n                    canonical = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__.JSONExt.deepCopy(plugin.schema);\n                    populate(canonical);\n                }\n                const defaults = (_c = (_b = (_a = canonical.properties) === null || _a === void 0 ? void 0 : _a.metadataforms) === null || _b === void 0 ? void 0 : _b.default) !== null && _c !== void 0 ? _c : [];\n                const user = {\n                    metadataforms: (_d = plugin.data.user.metadataforms) !== null && _d !== void 0 ? _d : []\n                };\n                const composite = {\n                    metadataforms: defaults.concat(user.metadataforms)\n                };\n                plugin.data = { composite, user };\n                return plugin;\n            },\n            fetch: plugin => {\n                // Only override the canonical schema the first time.\n                if (!canonical) {\n                    canonical = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__.JSONExt.deepCopy(plugin.schema);\n                    populate(canonical);\n                }\n                return {\n                    data: plugin.data,\n                    id: plugin.id,\n                    raw: plugin.raw,\n                    schema: canonical,\n                    version: plugin.version\n                };\n            }\n        });\n        // Repopulate the canonical variable after the setting registry has\n        // preloaded all initial plugins.\n        canonical = null;\n        const settings = await registry.load(PLUGIN_ID);\n        const metadataForms = new _jupyterlab_metadataform__WEBPACK_IMPORTED_MODULE_5__.MetadataFormProvider();\n        // Creates all the forms from extensions settings.\n        for (let schema of settings.composite\n            .metadataforms) {\n            let metaInformation = {};\n            let metadataSchema = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__.JSONExt.deepCopy(schema.metadataSchema);\n            let uiSchema = {};\n            if (schema.uiSchema) {\n                uiSchema = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__.JSONExt.deepCopy(schema.uiSchema);\n            }\n            for (let [metadataKey, properties] of Object.entries(metadataSchema.properties)) {\n                if (properties.default) {\n                    if (!metaInformation[metadataKey])\n                        metaInformation[metadataKey] = {};\n                    metaInformation[metadataKey].default = properties.default;\n                }\n            }\n            if (schema.metadataOptions) {\n                for (let [metadataKey, options] of Object.entries(schema.metadataOptions)) {\n                    // Optionally links key to cell type.\n                    if (options.cellTypes) {\n                        if (!metaInformation[metadataKey])\n                            metaInformation[metadataKey] = {};\n                        metaInformation[metadataKey].cellTypes = options.cellTypes;\n                    }\n                    // Optionally links key to metadata level.\n                    if (options.metadataLevel) {\n                        if (!metaInformation[metadataKey])\n                            metaInformation[metadataKey] = {};\n                        metaInformation[metadataKey].level = options.metadataLevel;\n                    }\n                    // Optionally set the writeDefault flag.\n                    if (options.writeDefault !== undefined) {\n                        if (!metaInformation[metadataKey])\n                            metaInformation[metadataKey] = {};\n                        metaInformation[metadataKey].writeDefault = options.writeDefault;\n                    }\n                    // Optionally links key to a custom widget.\n                    if (options.customRenderer) {\n                        const component = formComponentRegistry.getRenderer(options.customRenderer);\n                        // If renderer is defined (custom widget has been registered), set it as used widget.\n                        if (component !== undefined) {\n                            if (!uiSchema[metadataKey])\n                                uiSchema[metadataKey] = {};\n                            if (component.fieldRenderer) {\n                                uiSchema[metadataKey]['ui:field'] = component.fieldRenderer;\n                            }\n                            else {\n                                uiSchema[metadataKey]['ui:widget'] = component.widgetRenderer;\n                            }\n                        }\n                    }\n                }\n            }\n            // Adds a section to notebookTools.\n            notebookTools.addSection({\n                sectionName: schema.id,\n                rank: schema.rank,\n                label: (_a = schema.label) !== null && _a !== void 0 ? _a : schema.id\n            });\n            // Creates the tool.\n            const tool = new _jupyterlab_metadataform__WEBPACK_IMPORTED_MODULE_5__.MetadataFormWidget({\n                metadataSchema: metadataSchema,\n                metaInformation: metaInformation,\n                uiSchema: uiSchema,\n                pluginId: schema._origin,\n                translator: translator,\n                showModified: schema.showModified\n            });\n            // Adds the form to the section.\n            notebookTools.addItem({ section: schema.id, tool: tool });\n            metadataForms.add(schema.id, tool);\n        }\n        return metadataForms;\n    }\n    Private.loadSettingsMetadataForm = loadSettingsMetadataForm;\n})(Private || (Private = {}));\n/**\n * The metadata form plugin.\n */\nconst metadataForm = {\n    id: PLUGIN_ID,\n    description: 'Provides the metadata form registry.',\n    autoStart: true,\n    requires: [\n        _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_0__.INotebookTools,\n        _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2__.ITranslator,\n        _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_3__.IFormRendererRegistry,\n        _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_1__.ISettingRegistry\n    ],\n    provides: _jupyterlab_metadataform__WEBPACK_IMPORTED_MODULE_5__.IMetadataFormProvider,\n    activate: async (app, notebookTools, translator, componentsRegistry, settings) => {\n        return await Private.loadSettingsMetadataForm(app, settings, notebookTools, translator, componentsRegistry);\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (metadataForm);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/metadataform-extension/lib/index.js?");

/***/ })

}]);