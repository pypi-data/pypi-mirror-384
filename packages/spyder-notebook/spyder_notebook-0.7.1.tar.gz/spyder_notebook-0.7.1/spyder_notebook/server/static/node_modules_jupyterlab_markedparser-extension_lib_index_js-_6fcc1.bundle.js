"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["node_modules_jupyterlab_markedparser-extension_lib_index_js-_6fcc1"],{

/***/ "../node_modules/@jupyterlab/markedparser-extension/lib/index.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@jupyterlab/markedparser-extension/lib/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createMarkdownParser: () => (/* binding */ createMarkdownParser),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ \"webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/coreutils */ \"webpack/sharing/consume/default/@jupyterlab/coreutils/@jupyterlab/coreutils\");\n/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/codemirror */ \"webpack/sharing/consume/default/@jupyterlab/codemirror/@jupyterlab/codemirror\");\n/* harmony import */ var _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/rendermime */ \"webpack/sharing/consume/default/@jupyterlab/rendermime/@jupyterlab/rendermime\");\n/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _jupyterlab_mermaid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jupyterlab/mermaid */ \"webpack/sharing/consume/default/@jupyterlab/mermaid/@jupyterlab/mermaid\");\n/* harmony import */ var _jupyterlab_mermaid__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_mermaid__WEBPACK_IMPORTED_MODULE_4__);\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module markedparser-extension\n */\n\n\n\n\n\n// highlight cache key separator\nconst FENCE = '```~~~';\n/**\n * Create a markdown parser\n *\n * @param languages Editor languages\n * @returns Markdown parser\n */\nfunction createMarkdownParser(languages, options) {\n    return {\n        render: (content) => {\n            return Private.render(content, languages, options);\n        }\n    };\n}\n/**\n * The markdown parser plugin.\n */\nconst plugin = {\n    id: '@jupyterlab/markedparser-extension:plugin',\n    description: 'Provides the Markdown parser.',\n    autoStart: true,\n    provides: _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_3__.IMarkdownParser,\n    requires: [_jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_2__.IEditorLanguageRegistry],\n    optional: [_jupyterlab_mermaid__WEBPACK_IMPORTED_MODULE_4__.IMermaidMarkdown],\n    activate: (app, languages, mermaidMarkdown) => {\n        return createMarkdownParser(languages, {\n            blocks: mermaidMarkdown ? [mermaidMarkdown] : []\n        });\n    }\n};\n/**\n * Export the plugin as default.\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);\n/**\n * A namespace for private marked functions\n */\nvar Private;\n(function (Private) {\n    let _initializing = null;\n    let _marked = null;\n    let _blocks = [];\n    let _languages = null;\n    let _markedOptions = {};\n    let _highlights = new _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__.LruCache();\n    async function render(content, languages, options) {\n        _languages = languages;\n        if (!_marked) {\n            _marked = await initializeMarked(options);\n        }\n        return _marked(content, _markedOptions);\n    }\n    Private.render = render;\n    /**\n     * Load marked lazily and exactly once.\n     */\n    async function initializeMarked(options) {\n        if (_marked) {\n            return _marked;\n        }\n        if (_initializing) {\n            return await _initializing.promise;\n        }\n        // order blocks by `rank`\n        _blocks = (options === null || options === void 0 ? void 0 : options.blocks) || [];\n        _blocks = _blocks.sort((a, b) => { var _a, _b; return ((_a = a.rank) !== null && _a !== void 0 ? _a : Infinity) - ((_b = b.rank) !== null && _b !== void 0 ? _b : Infinity); });\n        _initializing = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.PromiseDelegate();\n        // load marked lazily, and exactly once\n        const [{ marked, Renderer }, plugins] = await Promise.all([\n            __webpack_require__.e(/*! import() */ \"webpack_sharing_consume_default_marked_marked\").then(__webpack_require__.t.bind(__webpack_require__, /*! marked */ \"webpack/sharing/consume/default/marked/marked\", 23)),\n            loadMarkedPlugins()\n        ]);\n        // use load marked plugins\n        for (const plugin of plugins) {\n            marked.use(plugin);\n        }\n        // finish marked configuration\n        _markedOptions = {\n            // use the explicit async paradigm for `walkTokens`\n            async: true,\n            // enable all built-in GitHub-flavored Markdown opinions\n            gfm: true,\n            // asynchronously prepare for any special tokens, like highlighting and mermaid\n            walkTokens,\n            // use custom renderer\n            renderer: makeRenderer(Renderer)\n        };\n        // complete initialization\n        _marked = marked;\n        _initializing.resolve(_marked);\n        return _marked;\n    }\n    Private.initializeMarked = initializeMarked;\n    /**\n     * Load and use marked plugins.\n     *\n     * As of writing, both of these features would work without plugins, but emit\n     * deprecation warnings.\n     */\n    async function loadMarkedPlugins() {\n        // use loaded marked plugins\n        return Promise.all([\n            (async () => (await __webpack_require__.e(/*! import() */ \"webpack_sharing_consume_default_marked-gfm-heading-id_marked-gfm-heading-id\").then(__webpack_require__.t.bind(__webpack_require__, /*! marked-gfm-heading-id */ \"webpack/sharing/consume/default/marked-gfm-heading-id/marked-gfm-heading-id\", 23))).gfmHeadingId())(),\n            (async () => (await __webpack_require__.e(/*! import() */ \"webpack_sharing_consume_default_marked-mangle_marked-mangle\").then(__webpack_require__.t.bind(__webpack_require__, /*! marked-mangle */ \"webpack/sharing/consume/default/marked-mangle/marked-mangle\", 23))).mangle())()\n        ]);\n    }\n    /**\n     * Build a custom marked renderer.\n     */\n    function makeRenderer(Renderer_) {\n        const renderer = new Renderer_();\n        const originalCode = renderer.code;\n        renderer.code = ({ text, lang, escaped }) => {\n            // handle block renderers\n            for (const block of _blocks) {\n                if (lang && block.languages.includes(lang)) {\n                    const rendered = block.render(text);\n                    if (rendered != null) {\n                        return rendered;\n                    }\n                }\n            }\n            // handle known highlighting\n            const key = `${lang}${FENCE}${text}${FENCE}`;\n            const highlight = _highlights.get(key);\n            if (highlight != null) {\n                return highlight;\n            }\n            // fall back to calling with the renderer as `this`\n            return originalCode.call(renderer, { text, lang, escaped });\n        };\n        return renderer;\n    }\n    /**\n     * Apply and cache syntax highlighting for code blocks.\n     */\n    async function highlight(token) {\n        const { lang, text } = token;\n        if (!lang || !_languages) {\n            // no language(s), no highlight\n            return;\n        }\n        const key = `${lang}${FENCE}${text}${FENCE}`;\n        if (_highlights.get(key)) {\n            // already cached, don't make another DOM element\n            return;\n        }\n        const el = document.createElement('div');\n        try {\n            await _languages.highlight(text, _languages.findBest(lang), el);\n            const html = `<pre><code class=\"language-${lang}\">${el.innerHTML}</code></pre>`;\n            _highlights.set(key, html);\n        }\n        catch (err) {\n            console.error(`Failed to highlight ${lang} code`, err);\n        }\n        finally {\n            el.remove();\n        }\n    }\n    /**\n     * After parsing, lazily load and render or highlight code blocks\n     */\n    async function walkTokens(token) {\n        switch (token.type) {\n            case 'code':\n                if (token.lang) {\n                    for (const block of _blocks) {\n                        if (block.languages.includes(token.lang)) {\n                            await block.walk(token.text);\n                            return;\n                        }\n                    }\n                }\n                await highlight(token);\n        }\n    }\n})(Private || (Private = {}));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/markedparser-extension/lib/index.js?");

/***/ })

}]);