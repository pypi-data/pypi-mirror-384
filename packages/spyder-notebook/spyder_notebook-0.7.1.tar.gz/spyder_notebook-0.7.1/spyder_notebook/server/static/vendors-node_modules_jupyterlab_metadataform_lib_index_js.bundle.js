"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["vendors-node_modules_jupyterlab_metadataform_lib_index_js"],{

/***/ "../node_modules/@jupyterlab/metadataform/lib/form.js":
/*!************************************************************!*\
  !*** ../node_modules/@jupyterlab/metadataform/lib/form.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FormWidget: () => (/* binding */ FormWidget)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ \"webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils\");\n/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/ui-components */ \"webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components\");\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _rjsf_validator_ajv8__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rjsf/validator-ajv8 */ \"webpack/sharing/consume/default/@rjsf/validator-ajv8/@rjsf/validator-ajv8\");\n/* harmony import */ var _rjsf_validator_ajv8__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rjsf_validator_ajv8__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module metadataform\n */\n\n\n\n\n/**\n * A ReactWidget with the form itself.\n */\nclass FormWidget extends _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ReactWidget {\n    /**\n     * Constructs a new FormWidget.\n     */\n    constructor(props) {\n        super();\n        this.addClass('jp-FormWidget');\n        this._props = props;\n    }\n    /**\n     * Render the form.\n     * @returns - The rendered form\n     */\n    render() {\n        const formContext = {\n            defaultFormData: this._props.settings.default(),\n            updateMetadata: this._props.metadataFormWidget.updateMetadata\n        };\n        return (react__WEBPACK_IMPORTED_MODULE_3___default().createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__.FormComponent, { validator: (_rjsf_validator_ajv8__WEBPACK_IMPORTED_MODULE_2___default()), schema: this._props.properties, formData: this._props.formData, formContext: formContext, uiSchema: this._props.uiSchema, liveValidate: true, idPrefix: `jp-MetadataForm-${this._props.pluginId}`, onChange: (e) => {\n                this._props.metadataFormWidget.updateMetadata(e.formData || {});\n            }, compact: true, showModifiedFromDefault: this._props.showModified, translator: this._props.translator }));\n    }\n}\n//# sourceMappingURL=form.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/metadataform/lib/form.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/metadataform/lib/index.js":
/*!*************************************************************!*\
  !*** ../node_modules/@jupyterlab/metadataform/lib/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FormWidget: () => (/* reexport safe */ _form__WEBPACK_IMPORTED_MODULE_0__.FormWidget),\n/* harmony export */   IMetadataFormProvider: () => (/* reexport safe */ _token__WEBPACK_IMPORTED_MODULE_3__.IMetadataFormProvider),\n/* harmony export */   MetadataFormProvider: () => (/* reexport safe */ _metadataformProvider__WEBPACK_IMPORTED_MODULE_2__.MetadataFormProvider),\n/* harmony export */   MetadataFormWidget: () => (/* reexport safe */ _metadataform__WEBPACK_IMPORTED_MODULE_1__.MetadataFormWidget)\n/* harmony export */ });\n/* harmony import */ var _form__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./form */ \"../node_modules/@jupyterlab/metadataform/lib/form.js\");\n/* harmony import */ var _metadataform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./metadataform */ \"../node_modules/@jupyterlab/metadataform/lib/metadataform.js\");\n/* harmony import */ var _metadataformProvider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./metadataformProvider */ \"../node_modules/@jupyterlab/metadataform/lib/metadataformProvider.js\");\n/* harmony import */ var _token__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./token */ \"../node_modules/@jupyterlab/metadataform/lib/token.js\");\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module metadataform\n */\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/metadataform/lib/index.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/metadataform/lib/metadataform.js":
/*!********************************************************************!*\
  !*** ../node_modules/@jupyterlab/metadataform/lib/metadataform.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MetadataFormWidget: () => (/* binding */ MetadataFormWidget)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/notebook */ \"webpack/sharing/consume/default/@jupyterlab/notebook/@jupyterlab/notebook\");\n/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/settingregistry */ \"webpack/sharing/consume/default/@jupyterlab/settingregistry/@jupyterlab/settingregistry\");\n/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/translation */ \"webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation\");\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lumino/coreutils */ \"webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lumino/widgets */ \"webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets\");\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _form__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./form */ \"../node_modules/@jupyterlab/metadataform/lib/form.js\");\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module metadataform\n */\n\n\n\n\n\n\n/**\n * A class that create a metadata form widget\n */\nclass MetadataFormWidget extends _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_0__.NotebookTools.Tool {\n    /**\n     * Construct an empty widget.\n     */\n    constructor(options) {\n        super();\n        /**\n         * Update the metadata of the current cell or notebook.\n         *\n         * @param formData - the cell metadata set in the form.\n         * @param reload - whether to update the form after updating the metadata.\n         *\n         * ## Notes\n         * Metadata are updated from root only. If some metadata is nested,\n         * the whole root object must be updated.\n         * This function build an object with all the root object to update\n         * in metadata before performing update.\n         * It uses an arrow function to allow using 'this' properly when called from a custom field.\n         */\n        this.updateMetadata = (formData, reload) => {\n            var _a, _b, _c, _d, _e, _f, _g, _h;\n            if (this.notebookTools == undefined)\n                return;\n            const notebook = this.notebookTools.activeNotebookPanel;\n            const cell = this.notebookTools.activeCell;\n            if (cell == null)\n                return;\n            this._updatingMetadata = true;\n            // An object representing the cell metadata to modify.\n            const cellMetadataObject = {};\n            // An object representing the notebook metadata to modify.\n            const notebookMetadataObject = {};\n            for (let [metadataKey, value] of Object.entries(formData)) {\n                // Continue if the metadataKey does not exist in schema.\n                if (!this.metadataKeys.includes(metadataKey))\n                    continue;\n                // Continue if the metadataKey is a notebook level one and there is no NotebookModel.\n                if (((_a = this._metaInformation[metadataKey]) === null || _a === void 0 ? void 0 : _a.level) === 'notebook' &&\n                    this._notebookModelNull)\n                    continue;\n                // Continue if the metadataKey is not applicable to the cell type.\n                if (((_b = this._metaInformation[metadataKey]) === null || _b === void 0 ? void 0 : _b.cellTypes) &&\n                    !((_d = (_c = this._metaInformation[metadataKey]) === null || _c === void 0 ? void 0 : _c.cellTypes) === null || _d === void 0 ? void 0 : _d.includes(cell.model.type))) {\n                    continue;\n                }\n                let currentMetadata;\n                let metadataObject;\n                // Linking the working variable to the corresponding metadata and representation.\n                if (((_e = this._metaInformation[metadataKey]) === null || _e === void 0 ? void 0 : _e.level) === 'notebook') {\n                    // Working on notebook metadata.\n                    currentMetadata = notebook.model.metadata;\n                    metadataObject = notebookMetadataObject;\n                }\n                else {\n                    // Working on cell metadata.\n                    currentMetadata = cell.model.metadata;\n                    metadataObject = cellMetadataObject;\n                }\n                // Remove first and last '/' if necessary and split the path.\n                let nestedKey = metadataKey\n                    .replace(/^\\/+/, '')\n                    .replace(/\\/+$/, '')\n                    .split('/');\n                let baseMetadataKey = nestedKey[0];\n                if (baseMetadataKey == undefined)\n                    continue;\n                let writeFinalData = value !== undefined &&\n                    (((_g = (_f = this._metaInformation[metadataKey]) === null || _f === void 0 ? void 0 : _f.writeDefault) !== null && _g !== void 0 ? _g : true) ||\n                        value !== ((_h = this._metaInformation[metadataKey]) === null || _h === void 0 ? void 0 : _h.default));\n                // If metadata key is at root of metadata no need to go further.\n                if (nestedKey.length == 1) {\n                    if (writeFinalData)\n                        metadataObject[baseMetadataKey] = value;\n                    else\n                        metadataObject[baseMetadataKey] = undefined;\n                    continue;\n                }\n                let intermediateMetadataKeys = nestedKey.slice(1, -1);\n                let finalMetadataKey = nestedKey[nestedKey.length - 1];\n                // Deep copy of the metadata if not already done.\n                if (!(baseMetadataKey in metadataObject)) {\n                    metadataObject[baseMetadataKey] = currentMetadata[baseMetadataKey];\n                }\n                if (metadataObject[baseMetadataKey] === undefined)\n                    metadataObject[baseMetadataKey] = {};\n                // Let's have an object which points to the nested key.\n                let workingObject = metadataObject[baseMetadataKey];\n                let finalObjectReached = true;\n                for (let nested of intermediateMetadataKeys) {\n                    // If one of the nested object does not exist, this object is created\n                    // only if there is a final data to write.\n                    if (!(nested in workingObject)) {\n                        if (!writeFinalData) {\n                            finalObjectReached = false;\n                            break;\n                        }\n                        else\n                            workingObject[nested] = {};\n                    }\n                    workingObject = workingObject[nested];\n                }\n                // Write the value to the nested key or remove all empty object before the nested key,\n                // only if the final object has been reached.\n                if (finalObjectReached) {\n                    if (!writeFinalData)\n                        delete workingObject[finalMetadataKey];\n                    else\n                        workingObject[finalMetadataKey] = value;\n                }\n                // If the final nested data has been deleted, let see if there is not remaining\n                // empty objects to remove.\n                if (!writeFinalData) {\n                    metadataObject[baseMetadataKey] = Private.deleteEmptyNested(metadataObject[baseMetadataKey], nestedKey.slice(1));\n                    if (!Object.keys(metadataObject[baseMetadataKey])\n                        .length)\n                        metadataObject[baseMetadataKey] = undefined;\n                }\n            }\n            // Set the cell metadata or delete it if value is undefined or empty object.\n            for (let [key, value] of Object.entries(cellMetadataObject)) {\n                if (value === undefined)\n                    cell.model.deleteMetadata(key);\n                else\n                    cell.model.setMetadata(key, value);\n            }\n            // Set the notebook metadata or delete it if value is undefined or empty object.\n            if (!this._notebookModelNull) {\n                for (let [key, value] of Object.entries(notebookMetadataObject)) {\n                    if (value === undefined)\n                        notebook.model.deleteMetadata(key);\n                    else\n                        notebook.model.setMetadata(key, value);\n                }\n            }\n            this._updatingMetadata = false;\n            if (reload) {\n                this._update();\n            }\n        };\n        this._notebookModelNull = false;\n        this._metadataSchema = options.metadataSchema;\n        this._metaInformation = options.metaInformation;\n        this._uiSchema = options.uiSchema || {};\n        this._pluginId = options.pluginId;\n        this._showModified = options.showModified || false;\n        this.translator = options.translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2__.nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        this._updatingMetadata = false;\n        const layout = (this.layout = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_4__.SingletonLayout());\n        const node = document.createElement('div');\n        const content = document.createElement('div');\n        content.textContent = this._trans.__('No metadata.');\n        content.className = 'jp-MetadataForm-placeholderContent';\n        node.appendChild(content);\n        this._placeholder = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_4__.Widget({ node });\n        this._placeholder.addClass('jp-MetadataForm-placeholder');\n        layout.widget = this._placeholder;\n    }\n    /**\n     * Get the form object itself.\n     */\n    get form() {\n        return this._form;\n    }\n    /**\n     * Get the list of existing metadataKey (array of string).\n     *\n     * ## NOTE:\n     * The list contains also the conditional fields, which are not necessary\n     * displayed and filled.\n     */\n    get metadataKeys() {\n        var _a;\n        const metadataKeys = [];\n        // MetadataKey from schema.\n        for (let metadataKey of Object.keys(this._metadataSchema.properties)) {\n            metadataKeys.push(metadataKey);\n        }\n        // Possible additional metadataKeys from conditional schema.\n        (_a = this._metadataSchema.allOf) === null || _a === void 0 ? void 0 : _a.forEach(conditional => {\n            if (conditional.then !== undefined) {\n                if (conditional.then.properties !== undefined) {\n                    let properties = conditional.then\n                        .properties;\n                    for (let metadataKey of Object.keys(properties)) {\n                        if (!metadataKeys.includes(metadataKey))\n                            metadataKeys.push(metadataKey);\n                    }\n                }\n            }\n            if (conditional.else !== undefined) {\n                if (conditional.else.properties !== undefined) {\n                    let properties = conditional.else\n                        .properties;\n                    for (let metadataKey of Object.keys(properties)) {\n                        if (!metadataKeys.includes(metadataKey))\n                            metadataKeys.push(metadataKey);\n                    }\n                }\n            }\n        });\n        return metadataKeys;\n    }\n    /**\n     * Get the properties of a MetadataKey.\n     *\n     * @param metadataKey - metadataKey (string).\n     */\n    getProperties(metadataKey) {\n        return (_lumino_coreutils__WEBPACK_IMPORTED_MODULE_3__.JSONExt.deepCopy(this._metadataSchema.properties[metadataKey]) || null);\n    }\n    /**\n     * Set properties to a metadataKey.\n     *\n     * @param metadataKey - metadataKey (string).\n     * @param properties - the properties to add or modify.\n     */\n    setProperties(metadataKey, properties) {\n        Object.entries(properties).forEach(([key, value]) => {\n            this._metadataSchema.properties[metadataKey][key] = value;\n        });\n    }\n    /**\n     * Set the content of the widget.\n     */\n    setContent(content) {\n        const layout = this.layout;\n        if (layout.widget) {\n            layout.widget.removeClass('jp-MetadataForm-content');\n            layout.removeWidget(layout.widget);\n        }\n        if (!content) {\n            content = this._placeholder;\n        }\n        content.addClass('jp-MetadataForm-content');\n        layout.widget = content;\n    }\n    /**\n     * Build widget.\n     */\n    buildWidget(props) {\n        this._form = new _form__WEBPACK_IMPORTED_MODULE_5__.FormWidget(props);\n        this._form.addClass('jp-MetadataForm');\n        this.setContent(this._form);\n    }\n    /**\n     * Update the form when the widget is displayed.\n     */\n    onAfterShow(msg) {\n        this._update();\n    }\n    /**\n     * Handle a change to the active cell.\n     */\n    onActiveCellChanged(msg) {\n        if (this.isVisible)\n            this._update();\n    }\n    /**\n     * Handle a change to the active cell metadata.\n     */\n    onActiveCellMetadataChanged(_) {\n        if (!this._updatingMetadata && this.isVisible)\n            this._update();\n    }\n    /**\n     * Handle when the active notebook panel changes.\n     */\n    onActiveNotebookPanelChanged(_) {\n        const notebook = this.notebookTools.activeNotebookPanel;\n        this._notebookModelNull = notebook === null || notebook.model === null;\n        if (!this._updatingMetadata && this.isVisible)\n            this._update();\n    }\n    /**\n     * Handle a change to the active notebook metadata.\n     */\n    onActiveNotebookPanelMetadataChanged(msg) {\n        if (!this._updatingMetadata && this.isVisible)\n            this._update();\n    }\n    /**\n     * Update the form with current cell metadata, and remove inconsistent fields.\n     */\n    _update() {\n        var _a, _b, _c, _d, _e;\n        const notebook = this.notebookTools.activeNotebookPanel;\n        const cell = this.notebookTools.activeCell;\n        if (cell == undefined)\n            return;\n        const formProperties = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_3__.JSONExt.deepCopy(this._metadataSchema);\n        const formData = {};\n        for (let metadataKey of Object.keys(this._metadataSchema.properties || _lumino_coreutils__WEBPACK_IMPORTED_MODULE_3__.JSONExt.emptyObject)) {\n            // Do not display the field if it's Notebook metadata and the notebook model is null.\n            if (((_a = this._metaInformation[metadataKey]) === null || _a === void 0 ? void 0 : _a.level) === 'notebook' &&\n                this._notebookModelNull) {\n                delete formProperties.properties[metadataKey];\n                continue;\n            }\n            // Do not display the field if the active cell's type is not involved.\n            if (((_b = this._metaInformation[metadataKey]) === null || _b === void 0 ? void 0 : _b.cellTypes) &&\n                !((_d = (_c = this._metaInformation[metadataKey]) === null || _c === void 0 ? void 0 : _c.cellTypes) === null || _d === void 0 ? void 0 : _d.includes(cell.model.type))) {\n                delete formProperties.properties[metadataKey];\n                continue;\n            }\n            let workingObject;\n            // Remove the first and last '/' if exist, nad split the path.\n            let nestedKeys = metadataKey\n                .replace(/^\\/+/, '')\n                .replace(/\\/+$/, '')\n                .split('/');\n            // Associates the correct metadata object to the working object.\n            if (((_e = this._metaInformation[metadataKey]) === null || _e === void 0 ? void 0 : _e.level) === 'notebook') {\n                workingObject = notebook.model.metadata;\n            }\n            else {\n                workingObject = cell.model.metadata;\n            }\n            let hasValue = true;\n            // Navigate to the value.\n            for (let nested of nestedKeys) {\n                if (nested in workingObject)\n                    workingObject = workingObject[nested];\n                else {\n                    hasValue = false;\n                    break;\n                }\n            }\n            // Fill the formData with the current metadata value.\n            if (hasValue)\n                formData[metadataKey] = workingObject;\n        }\n        this.buildWidget({\n            properties: formProperties,\n            settings: new _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_1__.BaseSettings({\n                schema: this._metadataSchema\n            }),\n            uiSchema: this._uiSchema,\n            translator: this.translator || null,\n            formData: formData,\n            metadataFormWidget: this,\n            showModified: this._showModified,\n            pluginId: this._pluginId\n        });\n    }\n}\nvar Private;\n(function (Private) {\n    /**\n     * Recursive function to clean the empty nested metadata before updating real metadata.\n     * this function is called when a nested metadata is undefined (or default), so maybe some\n     * object are now empty.\n     * @param metadataObject PartialJSONObject representing the metadata to update.\n     * @param metadataKeysList Array<string> of the undefined nested metadata.\n     * @returns PartialJSONObject without empty object.\n     */\n    function deleteEmptyNested(metadataObject, metadataKeysList) {\n        let metadataKey = metadataKeysList.shift();\n        if (metadataKey !== undefined && metadataKey in metadataObject) {\n            if (Object.keys(metadataObject[metadataKey]).length)\n                metadataObject[metadataKey] = deleteEmptyNested(metadataObject[metadataKey], metadataKeysList);\n            if (!Object.keys(metadataObject[metadataKey]).length)\n                delete metadataObject[metadataKey];\n        }\n        return metadataObject;\n    }\n    Private.deleteEmptyNested = deleteEmptyNested;\n})(Private || (Private = {}));\n//# sourceMappingURL=metadataform.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/metadataform/lib/metadataform.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/metadataform/lib/metadataformProvider.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@jupyterlab/metadataform/lib/metadataformProvider.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MetadataFormProvider: () => (/* binding */ MetadataFormProvider)\n/* harmony export */ });\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\nclass MetadataFormProvider {\n    constructor() {\n        this._items = {};\n    }\n    add(id, widget) {\n        if (!this._items[id]) {\n            this._items[id] = widget;\n        }\n        else {\n            console.warn(`A MetadataformWidget is already registered with id ${id}`);\n        }\n    }\n    get(id) {\n        if (this._items[id]) {\n            return this._items[id];\n        }\n        else {\n            console.warn(`There is no MetadataformWidget registered with id ${id}`);\n        }\n    }\n}\n//# sourceMappingURL=metadataformProvider.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/metadataform/lib/metadataformProvider.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/metadataform/lib/token.js":
/*!*************************************************************!*\
  !*** ../node_modules/@jupyterlab/metadataform/lib/token.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IMetadataFormProvider: () => (/* binding */ IMetadataFormProvider)\n/* harmony export */ });\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ \"webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module metadataform\n */\n\n/**\n * The metadata form provider token.\n */\nconst IMetadataFormProvider = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.Token('@jupyterlab/metadataform:IMetadataFormProvider', `A service to register new metadata editor widgets.`);\n//# sourceMappingURL=token.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/metadataform/lib/token.js?");

/***/ })

}]);