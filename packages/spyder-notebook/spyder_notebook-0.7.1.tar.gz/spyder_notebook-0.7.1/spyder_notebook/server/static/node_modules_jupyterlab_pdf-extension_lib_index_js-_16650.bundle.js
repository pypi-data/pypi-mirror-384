"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["node_modules_jupyterlab_pdf-extension_lib_index_js-_16650"],{

/***/ "../node_modules/@jupyterlab/pdf-extension/lib/index.js":
/*!**************************************************************!*\
  !*** ../node_modules/@jupyterlab/pdf-extension/lib/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RenderedPDF: () => (/* binding */ RenderedPDF),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   rendererFactory: () => (/* binding */ rendererFactory)\n/* harmony export */ });\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ \"webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lumino_disposable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/disposable */ \"webpack/sharing/consume/default/@lumino/disposable/@lumino/disposable\");\n/* harmony import */ var _lumino_disposable__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_disposable__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/widgets */ \"webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets\");\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_2__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module pdf-extension\n */\n\n\n\n/**\n * The MIME type for PDF.\n */\nconst MIME_TYPE = 'application/pdf';\n/**\n * A class for rendering a PDF document.\n */\nclass RenderedPDF extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Widget {\n    constructor() {\n        super();\n        this._base64 = '';\n        this._disposable = null;\n        this._ready = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.PromiseDelegate();\n        this.addClass('jp-PDFContainer');\n        // We put the object in an iframe, which seems to have a better chance\n        // of retaining its scroll position upon tab focusing, moving around etc.\n        const iframe = document.createElement('iframe');\n        // Sets iframe loading to lazy\n        iframe.setAttribute('loading', 'lazy');\n        this.node.appendChild(iframe);\n        // The iframe content window is not available until the onload event.\n        iframe.onload = () => {\n            const body = iframe.contentWindow.document.createElement('body');\n            body.style.margin = '0px';\n            iframe.contentWindow.document.body = body;\n            this._object = iframe.contentWindow.document.createElement('object');\n            // work around for https://discussions.apple.com/thread/252247740\n            // Detect if running on Desktop Safari\n            if (!window.safari) {\n                this._object.type = MIME_TYPE;\n            }\n            this._object.width = '100%';\n            this._object.height = '100%';\n            body.appendChild(this._object);\n            this._ready.resolve(void 0);\n        };\n    }\n    /**\n     * Render PDF into this widget's node.\n     */\n    async renderModel(model) {\n        await this._ready.promise;\n        const data = model.data[MIME_TYPE];\n        if (!data ||\n            (data.length === this._base64.length && data === this._base64)) {\n            // If there is no data, or if the string has not changed, we do not\n            // need to re-parse the data and rerender. We do, however, check\n            // for a fragment if the user wants to scroll the output.\n            if (model.metadata.fragment && this._object.data) {\n                const url = this._object.data;\n                this._object.data = `${url.split('#')[0]}${model.metadata.fragment}`;\n            }\n            // For some opaque reason, Firefox seems to loose its scroll position\n            // upon unhiding a PDF. But triggering a refresh of the URL makes it\n            // find it again. No idea what the reason for this is.\n            if (Private.IS_FIREFOX) {\n                this._object.data = this._object.data; // eslint-disable-line\n            }\n            return Promise.resolve(void 0);\n        }\n        this._base64 = data;\n        const blob = Private.b64toBlob(data, MIME_TYPE);\n        // Release reference to any previous object url.\n        if (this._disposable) {\n            this._disposable.dispose();\n        }\n        let objectUrl = URL.createObjectURL(blob);\n        if (model.metadata.fragment) {\n            objectUrl += model.metadata.fragment;\n        }\n        this._object.data = objectUrl;\n        // Set the disposable release the object URL.\n        this._disposable = new _lumino_disposable__WEBPACK_IMPORTED_MODULE_1__.DisposableDelegate(() => {\n            try {\n                URL.revokeObjectURL(objectUrl);\n            }\n            catch (error) {\n                /* no-op */\n            }\n        });\n        return;\n    }\n    /**\n     * Handle a `before-hide` message.\n     */\n    onBeforeHide() {\n        // Dispose of any URL fragment before hiding the widget\n        // so that it is not remembered upon show. Only Firefox\n        // seems to have a problem with this.\n        if (Private.IS_FIREFOX) {\n            this._object.data = this._object.data.split('#')[0];\n        }\n    }\n    /**\n     * Dispose of the resources held by the pdf widget.\n     */\n    dispose() {\n        if (this._disposable) {\n            this._disposable.dispose();\n        }\n        super.dispose();\n    }\n}\n/**\n * A mime renderer factory for PDF data.\n */\nconst rendererFactory = {\n    safe: false,\n    mimeTypes: [MIME_TYPE],\n    defaultRank: 100,\n    createRenderer: options => new RenderedPDF()\n};\nconst extensions = [\n    {\n        id: '@jupyterlab/pdf-extension:factory',\n        description: 'Adds renderer for PDF content.',\n        rendererFactory,\n        dataType: 'string',\n        documentWidgetFactoryOptions: {\n            name: 'PDF',\n            // TODO: translate label\n            modelName: 'base64',\n            primaryFileType: 'PDF',\n            fileTypes: ['PDF'],\n            defaultFor: ['PDF']\n        }\n    }\n];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (extensions);\n/**\n * A namespace for PDF widget private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A flag for determining whether the user is using Firefox.\n     * There are some different PDF viewer behaviors on Firefox,\n     * and we try to address them with this. User agent string parsing\n     * is *not* reliable, so this should be considered a best-effort test.\n     */\n    Private.IS_FIREFOX = /Firefox/.test(navigator.userAgent);\n    /**\n     * Convert a base64 encoded string to a Blob object.\n     * Modified from a snippet found here:\n     * https://stackoverflow.com/questions/16245767/creating-a-blob-from-a-base64-string-in-javascript\n     *\n     * @param b64Data - The base64 encoded data.\n     *\n     * @param contentType - The mime type of the data.\n     *\n     * @param sliceSize - The size to chunk the data into for processing.\n     *\n     * @returns a Blob for the data.\n     */\n    function b64toBlob(b64Data, contentType = '', sliceSize = 512) {\n        const byteCharacters = atob(b64Data);\n        const byteArrays = [];\n        for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {\n            const slice = byteCharacters.slice(offset, offset + sliceSize);\n            const byteNumbers = new Array(slice.length);\n            for (let i = 0; i < slice.length; i++) {\n                byteNumbers[i] = slice.charCodeAt(i);\n            }\n            const byteArray = new Uint8Array(byteNumbers);\n            byteArrays.push(byteArray);\n        }\n        return new Blob(byteArrays, { type: contentType });\n    }\n    Private.b64toBlob = b64toBlob;\n})(Private || (Private = {}));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/pdf-extension/lib/index.js?");

/***/ })

}]);