"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["vendors-node_modules_jupyterlab_notebook-extension_lib_index_js"],{

/***/ "../node_modules/@jupyterlab/notebook-extension/lib/cellexecutor.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@jupyterlab/notebook-extension/lib/cellexecutor.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cellExecutor: () => (/* binding */ cellExecutor)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/notebook */ \"webpack/sharing/consume/default/@jupyterlab/notebook/@jupyterlab/notebook\");\n/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_0__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\n/**\n * Notebook cell executor plugin.\n */\nconst cellExecutor = {\n    id: '@jupyterlab/notebook-extension:cell-executor',\n    description: 'Provides the notebook cell executor.',\n    autoStart: true,\n    provides: _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_0__.INotebookCellExecutor,\n    activate: () => {\n        return Object.freeze({ runCell: _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_0__.runCell });\n    }\n};\n//# sourceMappingURL=cellexecutor.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook-extension/lib/cellexecutor.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/notebook-extension/lib/index.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@jupyterlab/notebook-extension/lib/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   commandEditItem: () => (/* binding */ commandEditItem),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   executionIndicator: () => (/* binding */ executionIndicator),\n/* harmony export */   exportPlugin: () => (/* binding */ exportPlugin),\n/* harmony export */   notebookTrustItem: () => (/* binding */ notebookTrustItem)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/application */ \"webpack/sharing/consume/default/@jupyterlab/application/@jupyterlab/application\");\n/* harmony import */ var _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/apputils */ \"webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils\");\n/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/cells */ \"webpack/sharing/consume/default/@jupyterlab/cells/@jupyterlab/cells\");\n/* harmony import */ var _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_cells__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/codeeditor */ \"webpack/sharing/consume/default/@jupyterlab/codeeditor/@jupyterlab/codeeditor\");\n/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jupyterlab/coreutils */ \"webpack/sharing/consume/default/@jupyterlab/coreutils/@jupyterlab/coreutils\");\n/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @jupyterlab/codemirror */ \"webpack/sharing/consume/default/@jupyterlab/codemirror/@jupyterlab/codemirror\");\n/* harmony import */ var _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _jupyterlab_completer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @jupyterlab/completer */ \"webpack/sharing/consume/default/@jupyterlab/completer/@jupyterlab/completer\");\n/* harmony import */ var _jupyterlab_completer__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_completer__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @jupyterlab/docmanager */ \"webpack/sharing/consume/default/@jupyterlab/docmanager/@jupyterlab/docmanager\");\n/* harmony import */ var _jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _jupyterlab_docmanager_extension__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @jupyterlab/docmanager-extension */ \"webpack/sharing/consume/default/@jupyterlab/docmanager-extension/@jupyterlab/docmanager-extension\");\n/* harmony import */ var _jupyterlab_docmanager_extension__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_docmanager_extension__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @jupyterlab/documentsearch */ \"webpack/sharing/consume/default/@jupyterlab/documentsearch/@jupyterlab/documentsearch\");\n/* harmony import */ var _jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @jupyterlab/filebrowser */ \"webpack/sharing/consume/default/@jupyterlab/filebrowser/@jupyterlab/filebrowser\");\n/* harmony import */ var _jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _jupyterlab_launcher__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @jupyterlab/launcher */ \"webpack/sharing/consume/default/@jupyterlab/launcher/@jupyterlab/launcher\");\n/* harmony import */ var _jupyterlab_launcher__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_launcher__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var _jupyterlab_lsp__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @jupyterlab/lsp */ \"webpack/sharing/consume/default/@jupyterlab/lsp/@jupyterlab/lsp\");\n/* harmony import */ var _jupyterlab_lsp__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_lsp__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var _jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @jupyterlab/mainmenu */ \"webpack/sharing/consume/default/@jupyterlab/mainmenu/@jupyterlab/mainmenu\");\n/* harmony import */ var _jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var _jupyterlab_metadataform__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @jupyterlab/metadataform */ \"webpack/sharing/consume/default/@jupyterlab/metadataform/@jupyterlab/metadataform\");\n/* harmony import */ var _jupyterlab_metadataform__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_metadataform__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @jupyterlab/notebook */ \"webpack/sharing/consume/default/@jupyterlab/notebook/@jupyterlab/notebook\");\n/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__);\n/* harmony import */ var _jupyterlab_property_inspector__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @jupyterlab/property-inspector */ \"webpack/sharing/consume/default/@jupyterlab/property-inspector/@jupyterlab/property-inspector\");\n/* harmony import */ var _jupyterlab_property_inspector__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_property_inspector__WEBPACK_IMPORTED_MODULE_16__);\n/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @jupyterlab/rendermime */ \"webpack/sharing/consume/default/@jupyterlab/rendermime/@jupyterlab/rendermime\");\n/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_17__);\n/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @jupyterlab/settingregistry */ \"webpack/sharing/consume/default/@jupyterlab/settingregistry/@jupyterlab/settingregistry\");\n/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_18__);\n/* harmony import */ var _jupyterlab_statedb__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @jupyterlab/statedb */ \"webpack/sharing/consume/default/@jupyterlab/statedb/@jupyterlab/statedb\");\n/* harmony import */ var _jupyterlab_statedb__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_statedb__WEBPACK_IMPORTED_MODULE_19__);\n/* harmony import */ var _jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @jupyterlab/statusbar */ \"webpack/sharing/consume/default/@jupyterlab/statusbar/@jupyterlab/statusbar\");\n/* harmony import */ var _jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_20__);\n/* harmony import */ var _jupyterlab_toc__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @jupyterlab/toc */ \"webpack/sharing/consume/default/@jupyterlab/toc/@jupyterlab/toc\");\n/* harmony import */ var _jupyterlab_toc__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_toc__WEBPACK_IMPORTED_MODULE_21__);\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @jupyterlab/translation */ \"webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation\");\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_22___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_22__);\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @jupyterlab/ui-components */ \"webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components\");\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_23__);\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @lumino/algorithm */ \"webpack/sharing/consume/default/@lumino/algorithm/@lumino/algorithm\");\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_24__);\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @lumino/coreutils */ \"webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_25___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_25__);\n/* harmony import */ var _lumino_disposable__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @lumino/disposable */ \"webpack/sharing/consume/default/@lumino/disposable/@lumino/disposable\");\n/* harmony import */ var _lumino_disposable__WEBPACK_IMPORTED_MODULE_26___default = /*#__PURE__*/__webpack_require__.n(_lumino_disposable__WEBPACK_IMPORTED_MODULE_26__);\n/* harmony import */ var _lumino_messaging__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @lumino/messaging */ \"webpack/sharing/consume/default/@lumino/messaging/@lumino/messaging\");\n/* harmony import */ var _lumino_messaging__WEBPACK_IMPORTED_MODULE_27___default = /*#__PURE__*/__webpack_require__.n(_lumino_messaging__WEBPACK_IMPORTED_MODULE_27__);\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @lumino/widgets */ \"webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets\");\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_28___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_28__);\n/* harmony import */ var _jupyterlab_cell_toolbar__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! @jupyterlab/cell-toolbar */ \"webpack/sharing/consume/default/@jupyterlab/cell-toolbar/@jupyterlab/cell-toolbar\");\n/* harmony import */ var _jupyterlab_cell_toolbar__WEBPACK_IMPORTED_MODULE_29___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_cell_toolbar__WEBPACK_IMPORTED_MODULE_29__);\n/* harmony import */ var _cellexecutor__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./cellexecutor */ \"../node_modules/@jupyterlab/notebook-extension/lib/cellexecutor.js\");\n/* harmony import */ var _nboutput__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./nboutput */ \"../node_modules/@jupyterlab/notebook-extension/lib/nboutput.js\");\n/* harmony import */ var _tool_widgets_activeCellToolWidget__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./tool-widgets/activeCellToolWidget */ \"../node_modules/@jupyterlab/notebook-extension/lib/tool-widgets/activeCellToolWidget.js\");\n/* harmony import */ var _tool_widgets_metadataEditorFields__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./tool-widgets/metadataEditorFields */ \"../node_modules/@jupyterlab/notebook-extension/lib/tool-widgets/metadataEditorFields.js\");\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module notebook-extension\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * The command IDs used by the notebook plugin.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.createNew = 'notebook:create-new';\n    CommandIDs.interrupt = 'notebook:interrupt-kernel';\n    CommandIDs.restart = 'notebook:restart-kernel';\n    CommandIDs.restartClear = 'notebook:restart-clear-output';\n    CommandIDs.restartAndRunToSelected = 'notebook:restart-and-run-to-selected';\n    CommandIDs.restartRunAll = 'notebook:restart-run-all';\n    CommandIDs.reconnectToKernel = 'notebook:reconnect-to-kernel';\n    CommandIDs.changeKernel = 'notebook:change-kernel';\n    CommandIDs.getKernel = 'notebook:get-kernel';\n    CommandIDs.createConsole = 'notebook:create-console';\n    CommandIDs.createSubshellConsole = 'notebook:create-subshell-console';\n    CommandIDs.createOutputView = 'notebook:create-output-view';\n    CommandIDs.clearAllOutputs = 'notebook:clear-all-cell-outputs';\n    CommandIDs.shutdown = 'notebook:shutdown-kernel';\n    CommandIDs.closeAndShutdown = 'notebook:close-and-shutdown';\n    CommandIDs.trust = 'notebook:trust';\n    CommandIDs.exportToFormat = 'notebook:export-to-format';\n    CommandIDs.run = 'notebook:run-cell';\n    CommandIDs.runAndAdvance = 'notebook:run-cell-and-select-next';\n    CommandIDs.runAndInsert = 'notebook:run-cell-and-insert-below';\n    CommandIDs.runInConsole = 'notebook:run-in-console';\n    CommandIDs.runAll = 'notebook:run-all-cells';\n    CommandIDs.runAllAbove = 'notebook:run-all-above';\n    CommandIDs.runAllBelow = 'notebook:run-all-below';\n    CommandIDs.renderAllMarkdown = 'notebook:render-all-markdown';\n    CommandIDs.toCode = 'notebook:change-cell-to-code';\n    CommandIDs.toMarkdown = 'notebook:change-cell-to-markdown';\n    CommandIDs.toRaw = 'notebook:change-cell-to-raw';\n    CommandIDs.cut = 'notebook:cut-cell';\n    CommandIDs.copy = 'notebook:copy-cell';\n    CommandIDs.pasteAbove = 'notebook:paste-cell-above';\n    CommandIDs.pasteBelow = 'notebook:paste-cell-below';\n    CommandIDs.duplicateBelow = 'notebook:duplicate-below';\n    CommandIDs.pasteAndReplace = 'notebook:paste-and-replace-cell';\n    CommandIDs.moveUp = 'notebook:move-cell-up';\n    CommandIDs.moveDown = 'notebook:move-cell-down';\n    CommandIDs.clearOutputs = 'notebook:clear-cell-output';\n    CommandIDs.deleteCell = 'notebook:delete-cell';\n    CommandIDs.insertAbove = 'notebook:insert-cell-above';\n    CommandIDs.insertBelow = 'notebook:insert-cell-below';\n    CommandIDs.selectAbove = 'notebook:move-cursor-up';\n    CommandIDs.selectBelow = 'notebook:move-cursor-down';\n    CommandIDs.selectHeadingAboveOrCollapse = 'notebook:move-cursor-heading-above-or-collapse';\n    CommandIDs.selectHeadingBelowOrExpand = 'notebook:move-cursor-heading-below-or-expand';\n    CommandIDs.insertHeadingAbove = 'notebook:insert-heading-above';\n    CommandIDs.insertHeadingBelow = 'notebook:insert-heading-below';\n    CommandIDs.extendAbove = 'notebook:extend-marked-cells-above';\n    CommandIDs.extendTop = 'notebook:extend-marked-cells-top';\n    CommandIDs.extendBelow = 'notebook:extend-marked-cells-below';\n    CommandIDs.extendBottom = 'notebook:extend-marked-cells-bottom';\n    CommandIDs.selectAll = 'notebook:select-all';\n    CommandIDs.deselectAll = 'notebook:deselect-all';\n    CommandIDs.editMode = 'notebook:enter-edit-mode';\n    CommandIDs.merge = 'notebook:merge-cells';\n    CommandIDs.mergeAbove = 'notebook:merge-cell-above';\n    CommandIDs.mergeBelow = 'notebook:merge-cell-below';\n    CommandIDs.split = 'notebook:split-cell-at-cursor';\n    CommandIDs.commandMode = 'notebook:enter-command-mode';\n    CommandIDs.toggleAllLines = 'notebook:toggle-all-cell-line-numbers';\n    CommandIDs.undoCellAction = 'notebook:undo-cell-action';\n    CommandIDs.redoCellAction = 'notebook:redo-cell-action';\n    CommandIDs.redo = 'notebook:redo';\n    CommandIDs.undo = 'notebook:undo';\n    CommandIDs.markdown1 = 'notebook:change-cell-to-heading-1';\n    CommandIDs.markdown2 = 'notebook:change-cell-to-heading-2';\n    CommandIDs.markdown3 = 'notebook:change-cell-to-heading-3';\n    CommandIDs.markdown4 = 'notebook:change-cell-to-heading-4';\n    CommandIDs.markdown5 = 'notebook:change-cell-to-heading-5';\n    CommandIDs.markdown6 = 'notebook:change-cell-to-heading-6';\n    CommandIDs.hideCode = 'notebook:hide-cell-code';\n    CommandIDs.showCode = 'notebook:show-cell-code';\n    CommandIDs.hideAllCode = 'notebook:hide-all-cell-code';\n    CommandIDs.showAllCode = 'notebook:show-all-cell-code';\n    CommandIDs.hideOutput = 'notebook:hide-cell-outputs';\n    CommandIDs.showOutput = 'notebook:show-cell-outputs';\n    CommandIDs.toggleOutput = 'notebook:toggle-cell-outputs';\n    CommandIDs.hideAllOutputs = 'notebook:hide-all-cell-outputs';\n    CommandIDs.showAllOutputs = 'notebook:show-all-cell-outputs';\n    CommandIDs.toggleRenderSideBySideCurrentNotebook = 'notebook:toggle-render-side-by-side-current';\n    CommandIDs.setSideBySideRatio = 'notebook:set-side-by-side-ratio';\n    CommandIDs.enableOutputScrolling = 'notebook:enable-output-scrolling';\n    CommandIDs.disableOutputScrolling = 'notebook:disable-output-scrolling';\n    CommandIDs.selectLastRunCell = 'notebook:select-last-run-cell';\n    CommandIDs.replaceSelection = 'notebook:replace-selection';\n    CommandIDs.autoClosingBrackets = 'notebook:toggle-autoclosing-brackets';\n    CommandIDs.toggleCollapseCmd = 'notebook:toggle-heading-collapse';\n    CommandIDs.collapseAllCmd = 'notebook:collapse-all-headings';\n    CommandIDs.expandAllCmd = 'notebook:expand-all-headings';\n    CommandIDs.copyToClipboard = 'notebook:copy-to-clipboard';\n    CommandIDs.invokeCompleter = 'completer:invoke-notebook';\n    CommandIDs.selectCompleter = 'completer:select-notebook';\n    CommandIDs.tocRunCells = 'toc:run-cells';\n    CommandIDs.accessPreviousHistory = 'notebook:access-previous-history-entry';\n    CommandIDs.accessNextHistory = 'notebook:access-next-history-entry';\n    CommandIDs.virtualScrollbar = 'notebook:toggle-virtual-scrollbar';\n})(CommandIDs || (CommandIDs = {}));\n/**\n * The name of the factory that creates notebooks.\n */\nconst FACTORY = 'Notebook';\n/**\n * The excluded Export To ...\n * (returned from nbconvert's export list)\n */\nconst FORMAT_EXCLUDE = ['notebook', 'python', 'custom'];\n/**\n * Setting Id storing the customized toolbar definition.\n */\nconst PANEL_SETTINGS = '@jupyterlab/notebook-extension:panel';\n/**\n * The id to use on the style tag for the side by side margins.\n */\nconst SIDE_BY_SIDE_STYLE_ID = 'jp-NotebookExtension-sideBySideMargins';\n/**\n * The notebook widget tracker provider.\n */\nconst trackerPlugin = {\n    id: '@jupyterlab/notebook-extension:tracker',\n    description: 'Provides the notebook widget tracker.',\n    provides: _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.INotebookTracker,\n    requires: [\n        _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.INotebookWidgetFactory,\n        _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_5__.IEditorExtensionRegistry,\n        _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.INotebookCellExecutor\n    ],\n    optional: [\n        _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ICommandPalette,\n        _jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_10__.IDefaultFileBrowser,\n        _jupyterlab_launcher__WEBPACK_IMPORTED_MODULE_11__.ILauncher,\n        _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.ILayoutRestorer,\n        _jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_13__.IMainMenu,\n        _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.IRouter,\n        _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_18__.ISettingRegistry,\n        _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ISessionContextDialogs,\n        _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_22__.ITranslator,\n        _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_23__.IFormRendererRegistry,\n        _jupyterlab_filebrowser__WEBPACK_IMPORTED_MODULE_10__.IFileBrowserFactory\n    ],\n    activate: activateNotebookHandler,\n    autoStart: true\n};\n/**\n * The notebook cell factory provider.\n */\nconst factory = {\n    id: '@jupyterlab/notebook-extension:factory',\n    description: 'Provides the notebook cell factory.',\n    provides: _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookPanel.IContentFactory,\n    requires: [_jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_3__.IEditorServices],\n    autoStart: true,\n    activate: (app, editorServices) => {\n        const editorFactory = editorServices.factoryService.newInlineEditor;\n        return new _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookPanel.ContentFactory({ editorFactory });\n    }\n};\n/**\n * The notebook tools extension.\n */\nconst tools = {\n    activate: activateNotebookTools,\n    provides: _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.INotebookTools,\n    id: '@jupyterlab/notebook-extension:tools',\n    description: 'Provides the notebook tools.',\n    autoStart: true,\n    requires: [\n        _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.INotebookTracker,\n        _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_3__.IEditorServices,\n        _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_5__.IEditorLanguageRegistry,\n        _jupyterlab_statedb__WEBPACK_IMPORTED_MODULE_19__.IStateDB,\n        _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_22__.ITranslator\n    ],\n    optional: [_jupyterlab_property_inspector__WEBPACK_IMPORTED_MODULE_16__.IPropertyInspectorProvider]\n};\n/**\n * A plugin providing a CommandEdit status item.\n */\nconst commandEditItem = {\n    id: '@jupyterlab/notebook-extension:mode-status',\n    description: 'Adds a notebook mode status widget.',\n    autoStart: true,\n    requires: [_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.INotebookTracker, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_22__.ITranslator],\n    optional: [_jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_20__.IStatusBar],\n    activate: (app, tracker, translator, statusBar) => {\n        if (!statusBar) {\n            // Automatically disable if statusbar missing\n            return;\n        }\n        const { shell } = app;\n        const item = new _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.CommandEditStatus(translator);\n        // Keep the status item up-to-date with the current notebook.\n        tracker.currentChanged.connect(() => {\n            const current = tracker.currentWidget;\n            item.model.notebook = current && current.content;\n        });\n        statusBar.registerStatusItem('@jupyterlab/notebook-extension:mode-status', {\n            priority: 1,\n            item,\n            align: 'right',\n            rank: 4,\n            isActive: () => !!shell.currentWidget &&\n                !!tracker.currentWidget &&\n                shell.currentWidget === tracker.currentWidget\n        });\n    }\n};\n/**\n * A plugin that provides a execution indicator item to the status bar.\n */\nconst executionIndicator = {\n    id: '@jupyterlab/notebook-extension:execution-indicator',\n    description: 'Adds a notebook execution status widget.',\n    autoStart: true,\n    requires: [_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.INotebookTracker, _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.ILabShell, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_22__.ITranslator],\n    optional: [_jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_20__.IStatusBar, _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_18__.ISettingRegistry],\n    activate: (app, notebookTracker, labShell, translator, statusBar, settingRegistry) => {\n        let statusbarItem;\n        let labShellCurrentChanged;\n        let statusBarDisposable;\n        const updateSettings = (settings) => {\n            var _a, _b;\n            let { showOnToolBar, showProgress } = settings;\n            if (!showOnToolBar) {\n                // Status bar mode, only one `ExecutionIndicator` is needed.\n                if (!statusBar) {\n                    // Automatically disable if statusbar missing\n                    return;\n                }\n                if (!(statusbarItem === null || statusbarItem === void 0 ? void 0 : statusbarItem.model)) {\n                    statusbarItem = new _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.ExecutionIndicator(translator);\n                    labShellCurrentChanged = (_, change) => {\n                        const { newValue } = change;\n                        if (newValue && notebookTracker.has(newValue)) {\n                            const panel = newValue;\n                            statusbarItem.model.attachNotebook({\n                                content: panel.content,\n                                context: panel.sessionContext\n                            });\n                        }\n                    };\n                    statusBarDisposable = statusBar.registerStatusItem('@jupyterlab/notebook-extension:execution-indicator', {\n                        item: statusbarItem,\n                        align: 'left',\n                        rank: 3,\n                        isActive: () => {\n                            const current = labShell.currentWidget;\n                            return !!current && notebookTracker.has(current);\n                        }\n                    });\n                    statusbarItem.model.attachNotebook({\n                        content: (_a = notebookTracker.currentWidget) === null || _a === void 0 ? void 0 : _a.content,\n                        context: (_b = notebookTracker.currentWidget) === null || _b === void 0 ? void 0 : _b.sessionContext\n                    });\n                    labShell.currentChanged.connect(labShellCurrentChanged);\n                    statusbarItem.disposed.connect(() => {\n                        labShell.currentChanged.disconnect(labShellCurrentChanged);\n                    });\n                }\n                statusbarItem.model.displayOption = {\n                    showOnToolBar,\n                    showProgress\n                };\n            }\n            else {\n                //Remove old indicator widget on status bar\n                if (statusBarDisposable) {\n                    labShell.currentChanged.disconnect(labShellCurrentChanged);\n                    statusBarDisposable.dispose();\n                }\n            }\n        };\n        if (settingRegistry) {\n            // Indicator is default in tool bar, user needs to specify its\n            // position in settings in order to have indicator on status bar.\n            const loadSettings = settingRegistry.load(trackerPlugin.id);\n            Promise.all([loadSettings, app.restored])\n                .then(([settings]) => {\n                updateSettings(_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.ExecutionIndicator.getSettingValue(settings));\n                settings.changed.connect(sender => updateSettings(_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.ExecutionIndicator.getSettingValue(sender)));\n            })\n                .catch((reason) => {\n                console.error(reason.message);\n            });\n        }\n    }\n};\n/**\n * A plugin providing export commands in the main menu and command palette\n */\nconst exportPlugin = {\n    id: '@jupyterlab/notebook-extension:export',\n    description: 'Adds the export notebook commands.',\n    autoStart: true,\n    requires: [_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_22__.ITranslator, _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.INotebookTracker],\n    optional: [_jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_13__.IMainMenu, _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ICommandPalette],\n    activate: (app, translator, tracker, mainMenu, palette) => {\n        var _a;\n        const trans = translator.load('jupyterlab');\n        const { commands, shell } = app;\n        const services = app.serviceManager;\n        const isEnabled = () => {\n            return Private.isEnabled(shell, tracker);\n        };\n        commands.addCommand(CommandIDs.exportToFormat, {\n            label: args => {\n                if (args.label === undefined) {\n                    return trans.__('Save and Export Notebook to the given `format`.');\n                }\n                const formatLabel = args['label'];\n                return args['isPalette']\n                    ? trans.__('Save and Export Notebook: %1', formatLabel)\n                    : formatLabel;\n            },\n            execute: args => {\n                const current = getCurrent(tracker, shell, args);\n                if (!current) {\n                    return;\n                }\n                const url = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_4__.PageConfig.getNBConvertURL({\n                    format: args['format'],\n                    download: true,\n                    path: current.context.path\n                });\n                const { context } = current;\n                if (context.model.dirty && !context.model.readOnly) {\n                    return context.save().then(() => {\n                        window.open(url, '_blank', 'noopener');\n                    });\n                }\n                return new Promise(resolve => {\n                    window.open(url, '_blank', 'noopener');\n                    resolve(undefined);\n                });\n            },\n            isEnabled\n        });\n        // Add a notebook group to the File menu.\n        let exportTo;\n        if (mainMenu) {\n            exportTo = (_a = mainMenu.fileMenu.items.find(item => {\n                var _a;\n                return item.type === 'submenu' &&\n                    ((_a = item.submenu) === null || _a === void 0 ? void 0 : _a.id) === 'jp-mainmenu-file-notebookexport';\n            })) === null || _a === void 0 ? void 0 : _a.submenu;\n        }\n        let formatsInitialized = false;\n        /** Request formats only when a notebook might use them. */\n        const maybeInitializeFormats = async () => {\n            if (formatsInitialized) {\n                return;\n            }\n            tracker.widgetAdded.disconnect(maybeInitializeFormats);\n            formatsInitialized = true;\n            const response = await services.nbconvert.getExportFormats(false);\n            if (!response) {\n                return;\n            }\n            const formatLabels = Private.getFormatLabels(translator);\n            // Convert export list to palette and menu items.\n            const formatList = Object.keys(response);\n            formatList.forEach(function (key) {\n                const capCaseKey = trans.__(key[0].toUpperCase() + key.substr(1));\n                const labelStr = formatLabels[key] ? formatLabels[key] : capCaseKey;\n                let args = {\n                    format: key,\n                    label: labelStr,\n                    isPalette: false\n                };\n                if (FORMAT_EXCLUDE.indexOf(key) === -1) {\n                    if (exportTo) {\n                        exportTo.addItem({\n                            command: CommandIDs.exportToFormat,\n                            args: args\n                        });\n                    }\n                    if (palette) {\n                        args = {\n                            format: key,\n                            label: labelStr,\n                            isPalette: true\n                        };\n                        const category = trans.__('Notebook Operations');\n                        palette.addItem({\n                            command: CommandIDs.exportToFormat,\n                            category,\n                            args\n                        });\n                    }\n                }\n            });\n        };\n        tracker.widgetAdded.connect(maybeInitializeFormats);\n    }\n};\n/**\n * A plugin that adds a notebook trust status item to the status bar.\n */\nconst notebookTrustItem = {\n    id: '@jupyterlab/notebook-extension:trust-status',\n    description: 'Adds the notebook trusted status widget.',\n    autoStart: true,\n    requires: [_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.INotebookTracker, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_22__.ITranslator],\n    optional: [_jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_20__.IStatusBar],\n    activate: (app, tracker, translator, statusBar) => {\n        if (!statusBar) {\n            // Automatically disable if statusbar missing\n            return;\n        }\n        const { shell } = app;\n        const item = new _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookTrustStatus(translator);\n        // Keep the status item up-to-date with the current notebook.\n        tracker.currentChanged.connect(() => {\n            const current = tracker.currentWidget;\n            item.model.notebook = current && current.content;\n        });\n        statusBar.registerStatusItem('@jupyterlab/notebook-extension:trust-status', {\n            item,\n            align: 'right',\n            rank: 3,\n            isActive: () => !!shell.currentWidget &&\n                !!tracker.currentWidget &&\n                shell.currentWidget === tracker.currentWidget\n        });\n    }\n};\n/**\n * The notebook widget factory provider.\n */\nconst widgetFactoryPlugin = {\n    id: '@jupyterlab/notebook-extension:widget-factory',\n    description: 'Provides the notebook widget factory.',\n    provides: _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.INotebookWidgetFactory,\n    requires: [\n        _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookPanel.IContentFactory,\n        _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_3__.IEditorServices,\n        _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_17__.IRenderMimeRegistry,\n        _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.IToolbarWidgetRegistry\n    ],\n    optional: [_jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_18__.ISettingRegistry, _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ISessionContextDialogs, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_22__.ITranslator],\n    activate: activateWidgetFactory,\n    autoStart: true\n};\n/**\n * The cloned output provider.\n */\nconst clonedOutputsPlugin = {\n    id: '@jupyterlab/notebook-extension:cloned-outputs',\n    description: 'Adds the clone output feature.',\n    requires: [_jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_7__.IDocumentManager, _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.INotebookTracker, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_22__.ITranslator],\n    optional: [_jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.ILayoutRestorer],\n    activate: activateClonedOutputs,\n    autoStart: true\n};\n/**\n * A plugin for code consoles functionalities.\n */\nconst codeConsolePlugin = {\n    id: '@jupyterlab/notebook-extension:code-console',\n    description: 'Adds the notebook code consoles features.',\n    requires: [_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.INotebookTracker, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_22__.ITranslator],\n    activate: activateCodeConsole,\n    autoStart: true\n};\n/**\n * A plugin to copy CodeCell outputs.\n */\nconst copyOutputPlugin = {\n    id: '@jupyterlab/notebook-extension:copy-output',\n    description: 'Adds the copy cell outputs feature.',\n    activate: activateCopyOutput,\n    requires: [_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_22__.ITranslator, _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.INotebookTracker],\n    autoStart: true\n};\n/**\n * Kernel status indicator.\n */\nconst kernelStatus = {\n    id: '@jupyterlab/notebook-extension:kernel-status',\n    description: 'Adds the notebook kernel status.',\n    activate: (app, tracker, kernelStatus) => {\n        const provider = (widget) => {\n            let session = null;\n            if (widget && tracker.has(widget)) {\n                return widget.sessionContext;\n            }\n            return session;\n        };\n        kernelStatus.addSessionProvider(provider);\n    },\n    requires: [_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.INotebookTracker, _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.IKernelStatusModel],\n    autoStart: true\n};\n/**\n * Cursor position.\n */\nconst lineColStatus = {\n    id: '@jupyterlab/notebook-extension:cursor-position',\n    description: 'Adds the notebook cursor position status.',\n    activate: (app, tracker, positionModel) => {\n        let previousWidget = null;\n        const provider = async (widget) => {\n            let editor = null;\n            if (widget !== previousWidget) {\n                previousWidget === null || previousWidget === void 0 ? void 0 : previousWidget.content.activeCellChanged.disconnect(positionModel.update);\n                previousWidget = null;\n                if (widget && tracker.has(widget)) {\n                    widget.content.activeCellChanged.connect(positionModel.update);\n                    const activeCell = widget.content.activeCell;\n                    editor = null;\n                    if (activeCell) {\n                        await activeCell.ready;\n                        editor = activeCell.editor;\n                    }\n                    previousWidget = widget;\n                }\n            }\n            else if (widget) {\n                const activeCell = widget.content.activeCell;\n                editor = null;\n                if (activeCell) {\n                    await activeCell.ready;\n                    editor = activeCell.editor;\n                }\n            }\n            return editor;\n        };\n        positionModel.addEditorProvider(provider);\n    },\n    requires: [_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.INotebookTracker, _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_3__.IPositionModel],\n    autoStart: true\n};\nconst completerPlugin = {\n    id: '@jupyterlab/notebook-extension:completer',\n    description: 'Adds the code completion capability to notebooks.',\n    requires: [_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.INotebookTracker],\n    optional: [_jupyterlab_completer__WEBPACK_IMPORTED_MODULE_6__.ICompletionProviderManager, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_22__.ITranslator, _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ISanitizer],\n    activate: activateNotebookCompleterService,\n    autoStart: true\n};\n/**\n * A plugin to search notebook documents\n */\nconst searchProvider = {\n    id: '@jupyterlab/notebook-extension:search',\n    description: 'Adds search capability to notebooks.',\n    requires: [_jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_9__.ISearchProviderRegistry],\n    autoStart: true,\n    activate: (app, registry) => {\n        registry.add('jp-notebookSearchProvider', _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookSearchProvider);\n    }\n};\nconst tocPlugin = {\n    id: '@jupyterlab/notebook-extension:toc',\n    description: 'Adds table of content capability to the notebooks',\n    requires: [_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.INotebookTracker, _jupyterlab_toc__WEBPACK_IMPORTED_MODULE_21__.ITableOfContentsRegistry, _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ISanitizer],\n    optional: [_jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_17__.IMarkdownParser, _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_18__.ISettingRegistry],\n    autoStart: true,\n    activate: (app, tracker, tocRegistry, sanitizer, mdParser, settingRegistry) => {\n        const nbTocFactory = new _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookToCFactory(tracker, mdParser, sanitizer);\n        tocRegistry.add(nbTocFactory);\n        if (settingRegistry) {\n            Promise.all([app.restored, settingRegistry.load(trackerPlugin.id)])\n                .then(([_, setting]) => {\n                const onSettingsUpdate = () => {\n                    var _a;\n                    nbTocFactory.scrollToTop =\n                        (_a = setting.composite['scrollHeadingToTop']) !== null && _a !== void 0 ? _a : true;\n                };\n                onSettingsUpdate();\n                setting.changed.connect(onSettingsUpdate);\n            })\n                .catch(error => {\n                console.error('Failed to load notebook table of content settings.', error);\n            });\n        }\n    }\n};\nconst languageServerPlugin = {\n    id: '@jupyterlab/notebook-extension:language-server',\n    description: 'Adds language server capability to the notebooks.',\n    requires: [\n        _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.INotebookTracker,\n        _jupyterlab_lsp__WEBPACK_IMPORTED_MODULE_12__.ILSPDocumentConnectionManager,\n        _jupyterlab_lsp__WEBPACK_IMPORTED_MODULE_12__.ILSPFeatureManager,\n        _jupyterlab_lsp__WEBPACK_IMPORTED_MODULE_12__.ILSPCodeExtractorsManager,\n        _jupyterlab_lsp__WEBPACK_IMPORTED_MODULE_12__.IWidgetLSPAdapterTracker\n    ],\n    activate: activateNotebookLanguageServer,\n    autoStart: true\n};\n/**\n * Metadata editor for the raw cell mimetype.\n */\nconst updateRawMimetype = {\n    id: '@jupyterlab/notebook-extension:update-raw-mimetype',\n    description: 'Adds metadata form editor for raw cell mimetype.',\n    autoStart: true,\n    requires: [_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.INotebookTracker, _jupyterlab_metadataform__WEBPACK_IMPORTED_MODULE_14__.IMetadataFormProvider, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_22__.ITranslator],\n    activate: (app, tracker, metadataForms, translator) => {\n        const trans = translator.load('jupyterlab');\n        let formatsInitialized = false;\n        async function maybeInitializeFormats() {\n            if (formatsInitialized) {\n                return;\n            }\n            if (!metadataForms.get('commonToolsSection')) {\n                return;\n            }\n            const properties = metadataForms\n                .get('commonToolsSection')\n                .getProperties('/raw_mimetype');\n            if (!properties) {\n                return;\n            }\n            tracker.widgetAdded.disconnect(maybeInitializeFormats);\n            formatsInitialized = true;\n            const services = app.serviceManager;\n            const response = await services.nbconvert.getExportFormats(false);\n            if (!response) {\n                return;\n            }\n            // convert exportList to palette and menu items\n            const formatList = Object.keys(response);\n            const formatLabels = Private.getFormatLabels(translator);\n            formatList.forEach(function (key) {\n                var _a;\n                const mimetypeExists = ((_a = properties.oneOf) === null || _a === void 0 ? void 0 : _a.filter(value => value.const === key).length) > 0;\n                if (!mimetypeExists) {\n                    const altOption = trans.__(key[0].toUpperCase() + key.substr(1));\n                    const option = formatLabels[key] ? formatLabels[key] : altOption;\n                    const mimeTypeValue = response[key].output_mimetype;\n                    properties.oneOf.push({\n                        const: mimeTypeValue,\n                        title: option\n                    });\n                }\n            });\n            metadataForms\n                .get('commonToolsSection')\n                .setProperties('/raw_mimetype', properties);\n        }\n        tracker.widgetAdded.connect(maybeInitializeFormats);\n    }\n};\n/**\n * Registering metadata editor fields.\n */\nconst customMetadataEditorFields = {\n    id: '@jupyterlab/notebook-extension:metadata-editor',\n    description: 'Adds metadata form for full metadata editor.',\n    autoStart: true,\n    requires: [_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.INotebookTracker, _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_3__.IEditorServices, _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_23__.IFormRendererRegistry],\n    optional: [_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_22__.ITranslator],\n    activate: (app, tracker, editorServices, formRegistry, translator) => {\n        const editorFactory = options => editorServices.factoryService.newInlineEditor(options);\n        // Register the custom fields.\n        const cellComponent = {\n            fieldRenderer: (props) => {\n                return new _tool_widgets_metadataEditorFields__WEBPACK_IMPORTED_MODULE_30__.CellMetadataField({\n                    editorFactory,\n                    tracker,\n                    label: 'Cell metadata',\n                    translator: translator\n                }).render(props);\n            }\n        };\n        formRegistry.addRenderer('@jupyterlab/notebook-extension:metadata-editor.cell-metadata', cellComponent);\n        const notebookComponent = {\n            fieldRenderer: (props) => {\n                return new _tool_widgets_metadataEditorFields__WEBPACK_IMPORTED_MODULE_30__.NotebookMetadataField({\n                    editorFactory,\n                    tracker,\n                    label: 'Notebook metadata',\n                    translator: translator\n                }).render(props);\n            }\n        };\n        formRegistry.addRenderer('@jupyterlab/notebook-extension:metadata-editor.notebook-metadata', notebookComponent);\n    }\n};\n/**\n * Registering active cell field.\n */\nconst activeCellTool = {\n    id: '@jupyterlab/notebook-extension:active-cell-tool',\n    description: 'Adds active cell field in the metadata editor tab.',\n    autoStart: true,\n    requires: [_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.INotebookTracker, _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_23__.IFormRendererRegistry, _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_5__.IEditorLanguageRegistry],\n    activate: (\n    // Register the custom field.\n    app, tracker, formRegistry, languages) => {\n        const component = {\n            fieldRenderer: (props) => {\n                return new _tool_widgets_activeCellToolWidget__WEBPACK_IMPORTED_MODULE_31__.ActiveCellTool({\n                    tracker,\n                    languages\n                }).render(props);\n            }\n        };\n        formRegistry.addRenderer('@jupyterlab/notebook-extension:active-cell-tool.renderer', component);\n    }\n};\n/**\n * Export the plugins as default.\n */\nconst plugins = [\n    _cellexecutor__WEBPACK_IMPORTED_MODULE_32__.cellExecutor,\n    factory,\n    trackerPlugin,\n    executionIndicator,\n    exportPlugin,\n    tools,\n    commandEditItem,\n    notebookTrustItem,\n    widgetFactoryPlugin,\n    _nboutput__WEBPACK_IMPORTED_MODULE_33__.logNotebookOutput,\n    clonedOutputsPlugin,\n    codeConsolePlugin,\n    copyOutputPlugin,\n    kernelStatus,\n    lineColStatus,\n    completerPlugin,\n    searchProvider,\n    tocPlugin,\n    languageServerPlugin,\n    updateRawMimetype,\n    customMetadataEditorFields,\n    activeCellTool\n];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugins);\n/**\n * Activate the notebook tools extension.\n */\nfunction activateNotebookTools(app, tracker, editorServices, languages, state, translator, inspectorProvider) {\n    const trans = translator.load('jupyterlab');\n    const id = 'notebook-tools';\n    const notebookTools = new _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookTools({ tracker, translator });\n    // Create message hook for triggers to save to the database.\n    const hook = (sender, message) => {\n        switch (message.type) {\n            case 'activate-request':\n                void state.save(id, { open: true });\n                break;\n            case 'after-hide':\n            case 'close-request':\n                void state.remove(id);\n                break;\n            default:\n                break;\n        }\n        return true;\n    };\n    notebookTools.title.icon = _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_23__.buildIcon;\n    notebookTools.title.caption = trans.__('Notebook Tools');\n    notebookTools.id = id;\n    _lumino_messaging__WEBPACK_IMPORTED_MODULE_27__.MessageLoop.installMessageHook(notebookTools, hook);\n    if (inspectorProvider) {\n        tracker.widgetAdded.connect((sender, panel) => {\n            const inspector = inspectorProvider.register(panel);\n            inspector.render(notebookTools);\n        });\n    }\n    return notebookTools;\n}\n/**\n * Activate the notebook widget factory.\n */\nfunction activateWidgetFactory(app, contentFactory, editorServices, rendermime, toolbarRegistry, settingRegistry, sessionContextDialogs_, translator_) {\n    const translator = translator_ !== null && translator_ !== void 0 ? translator_ : _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_22__.nullTranslator;\n    const sessionContextDialogs = sessionContextDialogs_ !== null && sessionContextDialogs_ !== void 0 ? sessionContextDialogs_ : new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.SessionContextDialogs({ translator });\n    const preferKernelOption = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_4__.PageConfig.getOption('notebookStartsKernel');\n    // If the option is not set, assume `true`\n    const preferKernelValue = preferKernelOption === '' || preferKernelOption.toLowerCase() === 'true';\n    const { commands } = app;\n    let toolbarFactory;\n    // Register notebook toolbar widgets\n    toolbarRegistry.addFactory(FACTORY, 'save', panel => _jupyterlab_docmanager_extension__WEBPACK_IMPORTED_MODULE_8__.ToolbarItems.createSaveButton(commands, panel.context.fileChanged));\n    toolbarRegistry.addFactory(FACTORY, 'cellType', panel => _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.ToolbarItems.createCellTypeItem(panel, translator));\n    toolbarRegistry.addFactory(FACTORY, 'kernelName', panel => _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Toolbar.createKernelNameItem(panel.sessionContext, sessionContextDialogs, translator));\n    toolbarRegistry.addFactory(FACTORY, 'executionProgress', panel => {\n        const loadingSettings = settingRegistry === null || settingRegistry === void 0 ? void 0 : settingRegistry.load(trackerPlugin.id);\n        const indicator = _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.ExecutionIndicator.createExecutionIndicatorItem(panel, translator, loadingSettings);\n        void (loadingSettings === null || loadingSettings === void 0 ? void 0 : loadingSettings.then(settings => {\n            panel.disposed.connect(() => {\n                settings.dispose();\n            });\n        }));\n        return indicator;\n    });\n    if (settingRegistry) {\n        // Create the factory\n        toolbarFactory = (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.createToolbarFactory)(toolbarRegistry, settingRegistry, FACTORY, PANEL_SETTINGS, translator);\n    }\n    const trans = translator.load('jupyterlab');\n    const factory = new _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookWidgetFactory({\n        name: FACTORY,\n        label: trans.__('Notebook'),\n        fileTypes: ['notebook'],\n        modelName: 'notebook',\n        defaultFor: ['notebook'],\n        preferKernel: preferKernelValue,\n        canStartKernel: true,\n        rendermime,\n        contentFactory,\n        editorConfig: _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.StaticNotebook.defaultEditorConfig,\n        notebookConfig: _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.StaticNotebook.defaultNotebookConfig,\n        mimeTypeService: editorServices.mimeTypeService,\n        toolbarFactory,\n        translator\n    });\n    app.docRegistry.addWidgetFactory(factory);\n    return factory;\n}\n/**\n * Activate the plugin to create and track cloned outputs.\n */\nfunction activateClonedOutputs(app, docManager, notebookTracker, translator, restorer) {\n    const trans = translator.load('jupyterlab');\n    const clonedOutputs = new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.WidgetTracker({\n        namespace: 'cloned-outputs'\n    });\n    if (restorer) {\n        void restorer.restore(clonedOutputs, {\n            command: CommandIDs.createOutputView,\n            args: widget => ({\n                path: widget.content.path,\n                index: widget.content.index\n            }),\n            name: widget => `${widget.content.path}:${widget.content.index}`,\n            when: notebookTracker.restored // After the notebook widgets (but not contents).\n        });\n    }\n    const { commands, shell } = app;\n    const isEnabledAndSingleSelected = () => {\n        return Private.isEnabledAndSingleSelected(shell, notebookTracker);\n    };\n    commands.addCommand(CommandIDs.createOutputView, {\n        label: trans.__('Create New View for Cell Output'),\n        execute: async (args) => {\n            var _a;\n            let cell;\n            let current;\n            // If we are given a notebook path and cell index, then\n            // use that, otherwise use the current active cell.\n            const path = args.path;\n            let index = args.index;\n            if (path && index !== undefined && index !== null) {\n                current = docManager.findWidget(path, FACTORY);\n                if (!current) {\n                    return;\n                }\n            }\n            else {\n                current = notebookTracker.currentWidget;\n                if (!current) {\n                    return;\n                }\n                cell = current.content.activeCell;\n                index = current.content.activeCellIndex;\n            }\n            // Create a MainAreaWidget\n            const content = new Private.ClonedOutputArea({\n                notebook: current,\n                cell,\n                index,\n                translator\n            });\n            const widget = new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.MainAreaWidget({ content });\n            current.context.addSibling(widget, {\n                ref: current.id,\n                mode: 'split-bottom',\n                type: 'Cloned Output'\n            });\n            const updateCloned = () => {\n                void clonedOutputs.save(widget);\n            };\n            current.context.pathChanged.connect(updateCloned);\n            (_a = current.context.model) === null || _a === void 0 ? void 0 : _a.cells.changed.connect(updateCloned);\n            // Add the cloned output to the output widget tracker.\n            void clonedOutputs.add(widget);\n            // Remove the output view if the parent notebook is closed.\n            current.content.disposed.connect(() => {\n                var _a;\n                current.context.pathChanged.disconnect(updateCloned);\n                (_a = current.context.model) === null || _a === void 0 ? void 0 : _a.cells.changed.disconnect(updateCloned);\n                widget.dispose();\n            });\n        },\n        isEnabled: isEnabledAndSingleSelected\n    });\n}\n/**\n * Activate the plugin to add code console functionalities\n */\nfunction activateCodeConsole(app, tracker, translator) {\n    const trans = translator.load('jupyterlab');\n    const { commands, shell } = app;\n    const isEnabled = () => Private.isEnabled(shell, tracker);\n    commands.addCommand(CommandIDs.createConsole, {\n        label: trans.__('New Console for Notebook'),\n        execute: args => {\n            const current = tracker.currentWidget;\n            if (!current) {\n                return;\n            }\n            return Private.createConsole(commands, current, args['activate']);\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.createSubshellConsole, {\n        label: trans.__('New Subshell Console for Notebook'),\n        execute: args => {\n            const current = tracker.currentWidget;\n            if (!current) {\n                return;\n            }\n            return Private.createConsole(commands, current, args['activate'], true);\n        },\n        isEnabled,\n        isVisible: () => {\n            var _a, _b, _c;\n            const kernel = (_b = (_a = tracker.currentWidget) === null || _a === void 0 ? void 0 : _a.context.sessionContext.session) === null || _b === void 0 ? void 0 : _b.kernel;\n            return (_c = kernel === null || kernel === void 0 ? void 0 : kernel.supportsSubshells) !== null && _c !== void 0 ? _c : false;\n        }\n    });\n    commands.addCommand(CommandIDs.runInConsole, {\n        label: trans.__('Run Selected Text or Current Line in Console'),\n        execute: async (args) => {\n            var _a, _b;\n            // Default to not activating the notebook (thereby putting the notebook\n            // into command mode)\n            const current = tracker.currentWidget;\n            if (!current) {\n                return;\n            }\n            const { context, content } = current;\n            const cell = content.activeCell;\n            const metadata = cell === null || cell === void 0 ? void 0 : cell.model.metadata;\n            const path = context.path;\n            // ignore action in non-code cell\n            if (!cell || cell.model.type !== 'code') {\n                return;\n            }\n            let code;\n            const editor = cell.editor;\n            if (!editor) {\n                return;\n            }\n            const selection = editor.getSelection();\n            const { start, end } = selection;\n            const selected = start.column !== end.column || start.line !== end.line;\n            if (selected) {\n                // Get the selected code from the editor.\n                const start = editor.getOffsetAt(selection.start);\n                const end = editor.getOffsetAt(selection.end);\n                code = editor.model.sharedModel.getSource().substring(start, end);\n            }\n            else {\n                // no selection, find the complete statement around the current line\n                const cursor = editor.getCursorPosition();\n                const srcLines = editor.model.sharedModel.getSource().split('\\n');\n                let curLine = selection.start.line;\n                while (curLine < editor.lineCount &&\n                    !srcLines[curLine].replace(/\\s/g, '').length) {\n                    curLine += 1;\n                }\n                // if curLine > 0, we first do a search from beginning\n                let fromFirst = curLine > 0;\n                let firstLine = 0;\n                let lastLine = firstLine + 1;\n                // eslint-disable-next-line\n                while (true) {\n                    code = srcLines.slice(firstLine, lastLine).join('\\n');\n                    const reply = await ((_b = (_a = current.context.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel) === null || _b === void 0 ? void 0 : _b.requestIsComplete({\n                        // ipython needs an empty line at the end to correctly identify completeness of indented code\n                        code: code + '\\n\\n'\n                    }));\n                    if ((reply === null || reply === void 0 ? void 0 : reply.content.status) === 'complete') {\n                        if (curLine < lastLine) {\n                            // we find a block of complete statement containing the current line, great!\n                            while (lastLine < editor.lineCount &&\n                                !srcLines[lastLine].replace(/\\s/g, '').length) {\n                                lastLine += 1;\n                            }\n                            editor.setCursorPosition({\n                                line: lastLine,\n                                column: cursor.column\n                            });\n                            break;\n                        }\n                        else {\n                            // discard the complete statement before the current line and continue\n                            firstLine = lastLine;\n                            lastLine = firstLine + 1;\n                        }\n                    }\n                    else if (lastLine < editor.lineCount) {\n                        // if incomplete and there are more lines, add the line and check again\n                        lastLine += 1;\n                    }\n                    else if (fromFirst) {\n                        // we search from the first line and failed, we search again from current line\n                        firstLine = curLine;\n                        lastLine = curLine + 1;\n                        fromFirst = false;\n                    }\n                    else {\n                        // if we have searched both from first line and from current line and we\n                        // cannot find anything, we submit the current line.\n                        code = srcLines[curLine];\n                        while (curLine + 1 < editor.lineCount &&\n                            !srcLines[curLine + 1].replace(/\\s/g, '').length) {\n                            curLine += 1;\n                        }\n                        editor.setCursorPosition({\n                            line: curLine + 1,\n                            column: cursor.column\n                        });\n                        break;\n                    }\n                }\n            }\n            if (!code) {\n                return;\n            }\n            await commands.execute('console:open', {\n                activate: false,\n                insertMode: 'split-bottom',\n                path\n            });\n            await commands.execute('console:inject', {\n                activate: false,\n                code,\n                path,\n                metadata\n            });\n        },\n        isEnabled\n    });\n}\n/**\n * Activate the output copying extension\n */\nfunction activateCopyOutput(app, translator, tracker) {\n    const trans = translator.load('jupyterlab');\n    /**\n     * Copy the contents of an HTMLElement to the system clipboard\n     */\n    function copyElement(e) {\n        const sel = window.getSelection();\n        if (sel == null) {\n            return;\n        }\n        // Save the current selection.\n        const savedRanges = [];\n        for (let i = 0; i < sel.rangeCount; ++i) {\n            savedRanges[i] = sel.getRangeAt(i).cloneRange();\n        }\n        const range = document.createRange();\n        range.selectNodeContents(e);\n        sel.removeAllRanges();\n        sel.addRange(range);\n        document.execCommand('copy');\n        // Restore the saved selection.\n        sel.removeAllRanges();\n        savedRanges.forEach(r => sel.addRange(r));\n    }\n    app.commands.addCommand(CommandIDs.copyToClipboard, {\n        label: trans.__('Copy Output to Clipboard'),\n        execute: args => {\n            var _a;\n            const cell = (_a = tracker.currentWidget) === null || _a === void 0 ? void 0 : _a.content.activeCell;\n            if (cell == null) {\n                return;\n            }\n            const output = cell.outputArea.outputTracker.currentWidget;\n            if (output == null) {\n                return;\n            }\n            const outputAreaAreas = output.node.getElementsByClassName('jp-OutputArea-output');\n            if (outputAreaAreas.length > 0) {\n                const area = outputAreaAreas[0];\n                copyElement(area);\n            }\n        }\n    });\n    app.contextMenu.addItem({\n        command: CommandIDs.copyToClipboard,\n        selector: '.jp-Notebook .jp-OutputArea-child',\n        rank: 0\n    });\n}\n/**\n * Activate the notebook handler extension.\n */\nfunction activateNotebookHandler(app, factory, extensions, executor, palette, defaultBrowser, launcher, restorer, mainMenu, router, settingRegistry, sessionDialogs_, translator_, formRegistry, filebrowserFactory) {\n    (0,_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.setCellExecutor)(executor);\n    const translator = translator_ !== null && translator_ !== void 0 ? translator_ : _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_22__.nullTranslator;\n    const sessionDialogs = sessionDialogs_ !== null && sessionDialogs_ !== void 0 ? sessionDialogs_ : new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.SessionContextDialogs({ translator });\n    const trans = translator.load('jupyterlab');\n    const services = app.serviceManager;\n    const { commands, shell } = app;\n    const tracker = new _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookTracker({ namespace: 'notebook' });\n    // Use the router to deal with hash navigation\n    function onRouted(router, location) {\n        if (location.hash && tracker.currentWidget) {\n            tracker.currentWidget.setFragment(location.hash);\n        }\n    }\n    router === null || router === void 0 ? void 0 : router.routed.connect(onRouted);\n    const isEnabled = () => {\n        return Private.isEnabled(shell, tracker);\n    };\n    const setSideBySideOutputRatio = (sideBySideOutputRatio) => document.documentElement.style.setProperty('--jp-side-by-side-output-size', `${sideBySideOutputRatio}fr`);\n    // Fetch settings if possible.\n    const fetchSettings = settingRegistry\n        ? settingRegistry.load(trackerPlugin.id)\n        : Promise.reject(new Error(`No setting registry for ${trackerPlugin.id}`));\n    fetchSettings\n        .then(settings => {\n        updateConfig(settings);\n        settings.changed.connect(() => {\n            updateConfig(settings);\n            commands.notifyCommandChanged(CommandIDs.virtualScrollbar);\n        });\n        const updateSessionSettings = (session, changes) => {\n            const { newValue, oldValue } = changes;\n            const autoStartDefault = newValue.autoStartDefault;\n            if (typeof autoStartDefault === 'boolean' &&\n                autoStartDefault !== oldValue.autoStartDefault) {\n                // Ensure we break the cycle\n                if (autoStartDefault !==\n                    settings.get('autoStartDefaultKernel').composite)\n                    // Once the settings is changed `updateConfig` will take care\n                    // of the propagation to existing session context.\n                    settings\n                        .set('autoStartDefaultKernel', autoStartDefault)\n                        .catch(reason => {\n                        console.error(`Failed to set ${settings.id}.autoStartDefaultKernel`);\n                    });\n            }\n        };\n        const sessionContexts = new WeakSet();\n        const listenToKernelPreference = (panel) => {\n            const session = panel.context.sessionContext;\n            if (!session.isDisposed && !sessionContexts.has(session)) {\n                sessionContexts.add(session);\n                session.kernelPreferenceChanged.connect(updateSessionSettings);\n                session.disposed.connect(() => {\n                    session.kernelPreferenceChanged.disconnect(updateSessionSettings);\n                });\n            }\n        };\n        tracker.forEach(listenToKernelPreference);\n        tracker.widgetAdded.connect((tracker, panel) => {\n            listenToKernelPreference(panel);\n        });\n        commands.addCommand(CommandIDs.autoClosingBrackets, {\n            execute: args => {\n                var _a;\n                const codeConfig = settings.get('codeCellConfig')\n                    .composite;\n                const markdownConfig = settings.get('markdownCellConfig')\n                    .composite;\n                const rawConfig = settings.get('rawCellConfig')\n                    .composite;\n                const anyToggled = codeConfig.autoClosingBrackets ||\n                    markdownConfig.autoClosingBrackets ||\n                    rawConfig.autoClosingBrackets;\n                const toggled = !!((_a = args['force']) !== null && _a !== void 0 ? _a : !anyToggled);\n                [\n                    codeConfig.autoClosingBrackets,\n                    markdownConfig.autoClosingBrackets,\n                    rawConfig.autoClosingBrackets\n                ] = [toggled, toggled, toggled];\n                void settings.set('codeCellConfig', codeConfig);\n                void settings.set('markdownCellConfig', markdownConfig);\n                void settings.set('rawCellConfig', rawConfig);\n            },\n            label: trans.__('Auto Close Brackets for All Notebook Cell Types'),\n            isToggled: () => ['codeCellConfig', 'markdownCellConfig', 'rawCellConfig'].some(x => {\n                var _a;\n                return ((_a = settings.get(x).composite.autoClosingBrackets) !== null && _a !== void 0 ? _a : extensions.baseConfiguration['autoClosingBrackets']) === true;\n            })\n        });\n        commands.addCommand(CommandIDs.setSideBySideRatio, {\n            label: trans.__('Set side-by-side ratio'),\n            execute: args => {\n                _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.InputDialog.getNumber({\n                    title: trans.__('Width of the output in side-by-side mode'),\n                    value: settings.get('sideBySideOutputRatio').composite\n                })\n                    .then(result => {\n                    setSideBySideOutputRatio(result.value);\n                    if (result.value) {\n                        void settings.set('sideBySideOutputRatio', result.value);\n                    }\n                })\n                    .catch(console.error);\n            }\n        });\n        addCommands(app, tracker, translator, sessionDialogs, settings, isEnabled);\n    })\n        .catch((reason) => {\n        console.warn(reason.message);\n        updateTracker({\n            editorConfig: factory.editorConfig,\n            notebookConfig: factory.notebookConfig,\n            kernelShutdown: factory.shutdownOnClose,\n            autoStartDefault: factory.autoStartDefault\n        });\n        addCommands(app, tracker, translator, sessionDialogs, null, isEnabled);\n    });\n    if (formRegistry) {\n        const CMRenderer = formRegistry.getRenderer('@jupyterlab/codemirror-extension:plugin.defaultConfig');\n        if (CMRenderer) {\n            formRegistry.addRenderer('@jupyterlab/notebook-extension:tracker.codeCellConfig', CMRenderer);\n            formRegistry.addRenderer('@jupyterlab/notebook-extension:tracker.markdownCellConfig', CMRenderer);\n            formRegistry.addRenderer('@jupyterlab/notebook-extension:tracker.rawCellConfig', CMRenderer);\n        }\n    }\n    // Handle state restoration.\n    if (restorer) {\n        void restorer.restore(tracker, {\n            command: 'docmanager:open',\n            args: panel => ({ path: panel.context.path, factory: FACTORY }),\n            name: panel => panel.context.path,\n            when: services.ready\n        });\n    }\n    const registry = app.docRegistry;\n    const modelFactory = new _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookModelFactory({\n        disableDocumentWideUndoRedo: factory.notebookConfig.disableDocumentWideUndoRedo,\n        collaborative: true\n    });\n    registry.addModelFactory(modelFactory);\n    if (palette) {\n        populatePalette(palette, translator);\n    }\n    let id = 0; // The ID counter for notebook panels.\n    const ft = app.docRegistry.getFileType('notebook');\n    factory.widgetCreated.connect((sender, widget) => {\n        var _a, _b;\n        // If the notebook panel does not have an ID, assign it one.\n        widget.id = widget.id || `notebook-${++id}`;\n        // Set up the title icon\n        widget.title.icon = ft === null || ft === void 0 ? void 0 : ft.icon;\n        widget.title.iconClass = (_a = ft === null || ft === void 0 ? void 0 : ft.iconClass) !== null && _a !== void 0 ? _a : '';\n        widget.title.iconLabel = (_b = ft === null || ft === void 0 ? void 0 : ft.iconLabel) !== null && _b !== void 0 ? _b : '';\n        // Notify the widget tracker if restore data needs to update.\n        widget.context.pathChanged.connect(() => {\n            void tracker.save(widget);\n        });\n        // Add the notebook panel to the tracker.\n        void tracker.add(widget);\n    });\n    /**\n     * Update the settings of the current tracker.\n     */\n    function updateTracker(options) {\n        tracker.forEach(widget => {\n            widget.setConfig(options);\n        });\n        if (options.notebookConfig.windowingMode !== 'full') {\n            // Disable all virtual scrollbars if any was enabled\n            tracker.forEach(widget => {\n                if (widget.content.scrollbar) {\n                    widget.content.scrollbar = false;\n                }\n            });\n        }\n    }\n    /**\n     * Update the setting values.\n     */\n    function updateConfig(settings) {\n        const code = {\n            ..._jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.StaticNotebook.defaultEditorConfig.code,\n            ...settings.get('codeCellConfig').composite\n        };\n        const markdown = {\n            ..._jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.StaticNotebook.defaultEditorConfig.markdown,\n            ...settings.get('markdownCellConfig').composite\n        };\n        const raw = {\n            ..._jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.StaticNotebook.defaultEditorConfig.raw,\n            ...settings.get('rawCellConfig').composite\n        };\n        factory.editorConfig = { code, markdown, raw };\n        factory.notebookConfig = {\n            enableKernelInitNotification: settings.get('enableKernelInitNotification')\n                .composite,\n            autoRenderMarkdownCells: settings.get('autoRenderMarkdownCells')\n                .composite,\n            showHiddenCellsButton: settings.get('showHiddenCellsButton')\n                .composite,\n            scrollPastEnd: settings.get('scrollPastEnd').composite,\n            defaultCell: settings.get('defaultCell').composite,\n            recordTiming: settings.get('recordTiming').composite,\n            overscanCount: settings.get('overscanCount').composite,\n            showInputPlaceholder: settings.get('showInputPlaceholder')\n                .composite,\n            inputHistoryScope: settings.get('inputHistoryScope').composite,\n            maxNumberOutputs: settings.get('maxNumberOutputs').composite,\n            showEditorForReadOnlyMarkdown: settings.get('showEditorForReadOnlyMarkdown').composite,\n            disableDocumentWideUndoRedo: !settings.get('documentWideUndoRedo')\n                .composite,\n            renderingLayout: settings.get('renderingLayout').composite,\n            sideBySideLeftMarginOverride: settings.get('sideBySideLeftMarginOverride')\n                .composite,\n            sideBySideRightMarginOverride: settings.get('sideBySideRightMarginOverride').composite,\n            sideBySideOutputRatio: settings.get('sideBySideOutputRatio')\n                .composite,\n            windowingMode: settings.get('windowingMode').composite,\n            accessKernelHistory: settings.get('accessKernelHistory')\n                .composite\n        };\n        setSideBySideOutputRatio(factory.notebookConfig.sideBySideOutputRatio);\n        const sideBySideMarginStyle = `.jp-mod-sideBySide.jp-Notebook .jp-Notebook-cell {\n      margin-left: ${factory.notebookConfig.sideBySideLeftMarginOverride} !important;\n      margin-right: ${factory.notebookConfig.sideBySideRightMarginOverride} !important;`;\n        const sideBySideMarginTag = document.getElementById(SIDE_BY_SIDE_STYLE_ID);\n        if (sideBySideMarginTag) {\n            sideBySideMarginTag.innerText = sideBySideMarginStyle;\n        }\n        else {\n            document.head.insertAdjacentHTML('beforeend', `<style id=\"${SIDE_BY_SIDE_STYLE_ID}\">${sideBySideMarginStyle}}</style>`);\n        }\n        factory.autoStartDefault = settings.get('autoStartDefaultKernel')\n            .composite;\n        factory.shutdownOnClose = settings.get('kernelShutdown')\n            .composite;\n        modelFactory.disableDocumentWideUndoRedo = !settings.get('documentWideUndoRedo').composite;\n        updateTracker({\n            editorConfig: factory.editorConfig,\n            notebookConfig: factory.notebookConfig,\n            kernelShutdown: factory.shutdownOnClose,\n            autoStartDefault: factory.autoStartDefault\n        });\n    }\n    // Add main menu notebook menu.\n    if (mainMenu) {\n        populateMenus(mainMenu, isEnabled);\n    }\n    // Utility function to create a new notebook.\n    const createNew = async (cwd, kernelId, kernelName) => {\n        const model = await commands.execute('docmanager:new-untitled', {\n            path: cwd,\n            type: 'notebook'\n        });\n        if (model !== undefined) {\n            const widget = (await commands.execute('docmanager:open', {\n                path: model.path,\n                factory: FACTORY,\n                kernel: { id: kernelId, name: kernelName }\n            }));\n            widget.isUntitled = true;\n            return widget;\n        }\n    };\n    // Add a command for creating a new notebook.\n    commands.addCommand(CommandIDs.createNew, {\n        label: args => {\n            var _a, _b, _c;\n            const kernelName = args['kernelName'] || '';\n            if (args['isLauncher'] && args['kernelName'] && services.kernelspecs) {\n                return ((_c = (_b = (_a = services.kernelspecs.specs) === null || _a === void 0 ? void 0 : _a.kernelspecs[kernelName]) === null || _b === void 0 ? void 0 : _b.display_name) !== null && _c !== void 0 ? _c : '');\n            }\n            if (args['isPalette'] || args['isContextMenu']) {\n                return trans.__('New Notebook');\n            }\n            return trans.__('Notebook');\n        },\n        caption: trans.__('Create a new notebook'),\n        icon: args => (args['isPalette'] ? undefined : _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_23__.notebookIcon),\n        execute: args => {\n            var _a, _b;\n            const currentBrowser = (_a = filebrowserFactory === null || filebrowserFactory === void 0 ? void 0 : filebrowserFactory.tracker.currentWidget) !== null && _a !== void 0 ? _a : defaultBrowser;\n            const cwd = args['cwd'] || ((_b = currentBrowser === null || currentBrowser === void 0 ? void 0 : currentBrowser.model.path) !== null && _b !== void 0 ? _b : '');\n            const kernelId = args['kernelId'] || '';\n            const kernelName = args['kernelName'] || '';\n            return createNew(cwd, kernelId, kernelName);\n        }\n    });\n    // Add a launcher item if the launcher is available.\n    if (launcher) {\n        void services.ready.then(() => {\n            let disposables = null;\n            const onSpecsChanged = () => {\n                if (disposables) {\n                    disposables.dispose();\n                    disposables = null;\n                }\n                const specs = services.kernelspecs.specs;\n                if (!specs) {\n                    return;\n                }\n                disposables = new _lumino_disposable__WEBPACK_IMPORTED_MODULE_26__.DisposableSet();\n                for (const name in specs.kernelspecs) {\n                    const rank = name === specs.default ? 0 : Infinity;\n                    const spec = specs.kernelspecs[name];\n                    const kernelIconUrl = spec.resources['logo-svg'] || spec.resources['logo-64x64'];\n                    disposables.add(launcher.add({\n                        command: CommandIDs.createNew,\n                        args: { isLauncher: true, kernelName: name },\n                        category: trans.__('Notebook'),\n                        rank,\n                        kernelIconUrl,\n                        metadata: {\n                            kernel: _lumino_coreutils__WEBPACK_IMPORTED_MODULE_25__.JSONExt.deepCopy(spec.metadata || {})\n                        }\n                    }));\n                }\n            };\n            onSpecsChanged();\n            services.kernelspecs.specsChanged.connect(onSpecsChanged);\n        });\n    }\n    return tracker;\n}\n/**\n * Activate the completer service for notebook.\n */\nfunction activateNotebookCompleterService(app, notebooks, manager, translator, appSanitizer) {\n    if (!manager) {\n        return;\n    }\n    const trans = (translator !== null && translator !== void 0 ? translator : _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_22__.nullTranslator).load('jupyterlab');\n    const sanitizer = appSanitizer !== null && appSanitizer !== void 0 ? appSanitizer : new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Sanitizer();\n    app.commands.addCommand(CommandIDs.invokeCompleter, {\n        label: trans.__('Display the completion helper.'),\n        execute: args => {\n            var _a;\n            const panel = notebooks.currentWidget;\n            if (panel && ((_a = panel.content.activeCell) === null || _a === void 0 ? void 0 : _a.model.type) === 'code') {\n                manager.invoke(panel.id);\n            }\n        }\n    });\n    app.commands.addCommand(CommandIDs.selectCompleter, {\n        label: trans.__('Select the completion suggestion.'),\n        execute: () => {\n            const id = notebooks.currentWidget && notebooks.currentWidget.id;\n            if (id) {\n                return manager.select(id);\n            }\n        }\n    });\n    app.commands.addKeyBinding({\n        command: CommandIDs.selectCompleter,\n        keys: ['Enter'],\n        selector: '.jp-Notebook .jp-mod-completer-active'\n    });\n    const updateCompleter = async (_, notebook) => {\n        var _a, _b;\n        const completerContext = {\n            editor: (_b = (_a = notebook.content.activeCell) === null || _a === void 0 ? void 0 : _a.editor) !== null && _b !== void 0 ? _b : null,\n            session: notebook.sessionContext.session,\n            widget: notebook,\n            sanitizer: sanitizer\n        };\n        await manager.updateCompleter(completerContext);\n        notebook.content.activeCellChanged.connect((_, cell) => {\n            // Ensure the editor will exist on the cell before adding the completer\n            cell === null || cell === void 0 ? void 0 : cell.ready.then(() => {\n                const newCompleterContext = {\n                    editor: cell.editor,\n                    session: notebook.sessionContext.session,\n                    widget: notebook,\n                    sanitizer: sanitizer\n                };\n                return manager.updateCompleter(newCompleterContext);\n            }).catch(console.error);\n        });\n        notebook.sessionContext.sessionChanged.connect(() => {\n            var _a;\n            // Ensure the editor will exist on the cell before adding the completer\n            (_a = notebook.content.activeCell) === null || _a === void 0 ? void 0 : _a.ready.then(() => {\n                var _a, _b;\n                const newCompleterContext = {\n                    editor: (_b = (_a = notebook.content.activeCell) === null || _a === void 0 ? void 0 : _a.editor) !== null && _b !== void 0 ? _b : null,\n                    session: notebook.sessionContext.session,\n                    widget: notebook\n                };\n                return manager.updateCompleter(newCompleterContext);\n            }).catch(console.error);\n        });\n    };\n    notebooks.widgetAdded.connect(updateCompleter);\n    manager.activeProvidersChanged.connect(() => {\n        notebooks.forEach(panel => {\n            updateCompleter(undefined, panel).catch(e => console.error(e));\n        });\n    });\n}\n/**\n * Activate the language server for notebook.\n */\nfunction activateNotebookLanguageServer(app, notebooks, connectionManager, featureManager, codeExtractorManager, adapterTracker) {\n    notebooks.widgetAdded.connect(async (_, notebook) => {\n        const adapter = new _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookAdapter(notebook, {\n            connectionManager,\n            featureManager,\n            foreignCodeExtractorsManager: codeExtractorManager\n        });\n        adapterTracker.add(adapter);\n    });\n}\n// Get the current widget and activate unless the args specify otherwise.\nfunction getCurrent(tracker, shell, args) {\n    var _a, _b;\n    let widget = null;\n    // Check for panelId in args (used by cell toolbars)\n    if (args[_jupyterlab_cell_toolbar__WEBPACK_IMPORTED_MODULE_29__.CellBarExtension.WIDGET_ID_ARG]) {\n        widget =\n            (_a = tracker.find(panel => panel.id === args[_jupyterlab_cell_toolbar__WEBPACK_IMPORTED_MODULE_29__.CellBarExtension.WIDGET_ID_ARG])) !== null && _a !== void 0 ? _a : null;\n    }\n    else if (args[_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.SemanticCommand.WIDGET]) {\n        widget =\n            (_b = tracker.find(panel => panel.id === args[_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.SemanticCommand.WIDGET])) !== null && _b !== void 0 ? _b : null;\n    }\n    else {\n        widget = tracker.currentWidget;\n    }\n    const activate = args['activate'] !== false;\n    if (activate && widget) {\n        shell.activateById(widget.id);\n    }\n    return widget;\n}\n/**\n * Add the notebook commands to the application's command registry.\n */\nfunction addCommands(app, tracker, translator, sessionDialogs, settings, isEnabled) {\n    var _a;\n    const trans = translator.load('jupyterlab');\n    const { commands, shell } = app;\n    const isEnabledAndSingleSelected = () => {\n        return Private.isEnabledAndSingleSelected(shell, tracker);\n    };\n    const refreshCellCollapsed = (notebook) => {\n        var _a, _b;\n        for (const cell of notebook.widgets) {\n            if (cell instanceof _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_2__.MarkdownCell && cell.headingCollapsed) {\n                _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.setHeadingCollapse(cell, true, notebook);\n            }\n            if (cell.model.id === ((_b = (_a = notebook.activeCell) === null || _a === void 0 ? void 0 : _a.model) === null || _b === void 0 ? void 0 : _b.id)) {\n                _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.expandParent(cell, notebook);\n            }\n        }\n    };\n    const isEnabledAndHeadingSelected = () => {\n        return Private.isEnabledAndHeadingSelected(shell, tracker);\n    };\n    // Set up signal handler to keep the collapse state consistent\n    tracker.currentChanged.connect((sender, panel) => {\n        var _a, _b;\n        if (!((_b = (_a = panel === null || panel === void 0 ? void 0 : panel.content) === null || _a === void 0 ? void 0 : _a.model) === null || _b === void 0 ? void 0 : _b.cells)) {\n            return;\n        }\n        panel.content.model.cells.changed.connect((list, args) => {\n            // Might be overkill to refresh this every time, but\n            // it helps to keep the collapse state consistent.\n            refreshCellCollapsed(panel.content);\n        });\n        panel.content.activeCellChanged.connect((notebook, cell) => {\n            _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.expandParent(cell, notebook);\n        });\n    });\n    tracker.selectionChanged.connect(() => {\n        commands.notifyCommandChanged(CommandIDs.duplicateBelow);\n        commands.notifyCommandChanged(CommandIDs.deleteCell);\n        commands.notifyCommandChanged(CommandIDs.copy);\n        commands.notifyCommandChanged(CommandIDs.cut);\n        commands.notifyCommandChanged(CommandIDs.pasteBelow);\n        commands.notifyCommandChanged(CommandIDs.pasteAbove);\n        commands.notifyCommandChanged(CommandIDs.pasteAndReplace);\n        commands.notifyCommandChanged(CommandIDs.moveUp);\n        commands.notifyCommandChanged(CommandIDs.moveDown);\n        commands.notifyCommandChanged(CommandIDs.run);\n        commands.notifyCommandChanged(CommandIDs.runAll);\n        commands.notifyCommandChanged(CommandIDs.runAndAdvance);\n        commands.notifyCommandChanged(CommandIDs.runAndInsert);\n    });\n    tracker.activeCellChanged.connect(() => {\n        commands.notifyCommandChanged(CommandIDs.moveUp);\n        commands.notifyCommandChanged(CommandIDs.moveDown);\n    });\n    commands.addCommand(CommandIDs.runAndAdvance, {\n        label: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            return trans._n('Run Selected Cell', 'Run Selected Cells', (_a = current === null || current === void 0 ? void 0 : current.content.selectedCells.length) !== null && _a !== void 0 ? _a : 1);\n        },\n        caption: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            return trans._n('Run this cell and advance', 'Run these %1 cells and advance', (_a = current === null || current === void 0 ? void 0 : current.content.selectedCells.length) !== null && _a !== void 0 ? _a : 1);\n        },\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                const { context, content } = current;\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.runAndAdvance(content, context.sessionContext, sessionDialogs, translator);\n            }\n        },\n        isEnabled: args => (args.toolbar ? true : isEnabled()),\n        icon: args => (args.toolbar ? _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_23__.runIcon : undefined)\n    });\n    commands.addCommand(CommandIDs.run, {\n        label: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            return trans._n('Run Selected Cell and Do not Advance', 'Run Selected Cells and Do not Advance', (_a = current === null || current === void 0 ? void 0 : current.content.selectedCells.length) !== null && _a !== void 0 ? _a : 1);\n        },\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                const { context, content } = current;\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.run(content, context.sessionContext, sessionDialogs, translator);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.runAndInsert, {\n        label: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            return trans._n('Run Selected Cell and Insert Below', 'Run Selected Cells and Insert Below', (_a = current === null || current === void 0 ? void 0 : current.content.selectedCells.length) !== null && _a !== void 0 ? _a : 1);\n        },\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                const { context, content } = current;\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.runAndInsert(content, context.sessionContext, sessionDialogs, translator);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.runAll, {\n        label: trans.__('Run All Cells'),\n        caption: trans.__('Run all cells'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                const { context, content } = current;\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.runAll(content, context.sessionContext, sessionDialogs, translator);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.runAllAbove, {\n        label: trans.__('Run All Above Selected Cell'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                const { context, content } = current;\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.runAllAbove(content, context.sessionContext, sessionDialogs, translator);\n            }\n        },\n        isEnabled: () => {\n            // Can't run above if there are multiple cells selected,\n            // or if we are at the top of the notebook.\n            return (isEnabledAndSingleSelected() &&\n                tracker.currentWidget.content.activeCellIndex !== 0);\n        }\n    });\n    commands.addCommand(CommandIDs.runAllBelow, {\n        label: trans.__('Run Selected Cell and All Below'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                const { context, content } = current;\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.runAllBelow(content, context.sessionContext, sessionDialogs, translator);\n            }\n        },\n        isEnabled: () => {\n            // Can't run below if there are multiple cells selected,\n            // or if we are at the bottom of the notebook.\n            return (isEnabledAndSingleSelected() &&\n                (tracker.currentWidget.content.widgets.length === 1 ||\n                    tracker.currentWidget.content.activeCellIndex !==\n                        tracker.currentWidget.content.widgets.length - 1));\n        }\n    });\n    commands.addCommand(CommandIDs.renderAllMarkdown, {\n        label: trans.__('Render All Markdown Cells'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                const { content } = current;\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.renderAllMarkdown(content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.restart, {\n        label: trans.__('Restart Kernel…'),\n        caption: trans.__('Restart the kernel'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return sessionDialogs.restart(current.sessionContext);\n            }\n        },\n        isEnabled: args => (args.toolbar ? true : isEnabled()),\n        icon: args => (args.toolbar ? _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_23__.refreshIcon : undefined)\n    });\n    commands.addCommand(CommandIDs.shutdown, {\n        label: trans.__('Shut Down Kernel'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (!current) {\n                return;\n            }\n            return current.context.sessionContext.shutdown();\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.closeAndShutdown, {\n        label: trans.__('Close and Shut Down Notebook…'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (!current) {\n                return;\n            }\n            const fileName = current.title.label;\n            return (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.showDialog)({\n                title: trans.__('Shut down the notebook?'),\n                body: trans.__('Are you sure you want to close \"%1\"?', fileName),\n                buttons: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Dialog.cancelButton(), _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Dialog.warnButton()]\n            }).then(result => {\n                if (result.button.accept) {\n                    return commands\n                        .execute(CommandIDs.shutdown, { activate: false })\n                        .then(() => {\n                        current.dispose();\n                    });\n                }\n            });\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.trust, {\n        label: () => trans.__('Trust Notebook'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                const { context, content } = current;\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.trust(content).then(() => context.save());\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.restartClear, {\n        label: trans.__('Restart Kernel and Clear Outputs of All Cells…'),\n        caption: trans.__('Restart the kernel and clear all outputs of all cells'),\n        execute: async () => {\n            const restarted = await commands.execute(CommandIDs.restart, {\n                activate: false\n            });\n            if (restarted) {\n                await commands.execute(CommandIDs.clearAllOutputs);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.restartAndRunToSelected, {\n        label: trans.__('Restart Kernel and Run up to Selected Cell…'),\n        execute: async (args) => {\n            const current = getCurrent(tracker, shell, { activate: false, ...args });\n            if (!current) {\n                return;\n            }\n            const { context, content } = current;\n            const cells = content.widgets.slice(0, content.activeCellIndex + 1);\n            const restarted = await sessionDialogs.restart(current.sessionContext);\n            if (restarted) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.runCells(content, cells, context.sessionContext, sessionDialogs, translator);\n            }\n        },\n        isEnabled: isEnabledAndSingleSelected\n    });\n    commands.addCommand(CommandIDs.restartRunAll, {\n        label: trans.__('Restart Kernel and Run All Cells…'),\n        caption: trans.__('Restart the kernel and run all cells'),\n        execute: async (args) => {\n            const current = getCurrent(tracker, shell, { activate: false, ...args });\n            if (!current) {\n                return;\n            }\n            const { context, content } = current;\n            const cells = content.widgets;\n            const restarted = await sessionDialogs.restart(current.sessionContext);\n            if (restarted) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.runCells(content, cells, context.sessionContext, sessionDialogs, translator);\n            }\n        },\n        isEnabled: args => (args.toolbar ? true : isEnabled()),\n        icon: args => (args.toolbar ? _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_23__.fastForwardIcon : undefined)\n    });\n    commands.addCommand(CommandIDs.clearAllOutputs, {\n        label: trans.__('Clear Outputs of All Cells'),\n        caption: trans.__('Clear all outputs of all cells'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.clearAllOutputs(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.clearOutputs, {\n        label: trans.__('Clear Cell Output'),\n        caption: trans.__('Clear outputs for the selected cells'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.clearOutputs(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.interrupt, {\n        label: trans.__('Interrupt Kernel'),\n        caption: trans.__('Interrupt the kernel'),\n        execute: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, args);\n            if (!current) {\n                return;\n            }\n            const kernel = (_a = current.context.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;\n            if (kernel) {\n                return kernel.interrupt();\n            }\n        },\n        isEnabled: args => (args.toolbar ? true : isEnabled()),\n        icon: args => (args.toolbar ? _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_23__.stopIcon : undefined)\n    });\n    commands.addCommand(CommandIDs.toCode, {\n        label: trans.__('Change to Code Cell Type'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.changeCellType(current.content, 'code', translator);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.toMarkdown, {\n        label: trans.__('Change to Markdown Cell Type'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.changeCellType(current.content, 'markdown', translator);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.toRaw, {\n        label: trans.__('Change to Raw Cell Type'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.changeCellType(current.content, 'raw', translator);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.cut, {\n        label: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            return trans._n('Cut Cell', 'Cut Cells', (_a = current === null || current === void 0 ? void 0 : current.content.selectedCells.length) !== null && _a !== void 0 ? _a : 1);\n        },\n        caption: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            return trans._n('Cut this cell', 'Cut these %1 cells', (_a = current === null || current === void 0 ? void 0 : current.content.selectedCells.length) !== null && _a !== void 0 ? _a : 1);\n        },\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.cut(current.content);\n            }\n        },\n        icon: args => (args.toolbar ? _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_23__.cutIcon : undefined),\n        isEnabled: args => (args.toolbar ? true : isEnabled())\n    });\n    commands.addCommand(CommandIDs.copy, {\n        label: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            return trans._n('Copy Cell', 'Copy Cells', (_a = current === null || current === void 0 ? void 0 : current.content.selectedCells.length) !== null && _a !== void 0 ? _a : 1);\n        },\n        caption: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            return trans._n('Copy this cell', 'Copy these %1 cells', (_a = current === null || current === void 0 ? void 0 : current.content.selectedCells.length) !== null && _a !== void 0 ? _a : 1);\n        },\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.copy(current.content);\n            }\n        },\n        icon: args => (args.toolbar ? _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_23__.copyIcon : undefined),\n        isEnabled: args => (args.toolbar ? true : isEnabled())\n    });\n    commands.addCommand(CommandIDs.pasteBelow, {\n        label: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            return trans._n('Paste Cell Below', 'Paste Cells Below', (_a = current === null || current === void 0 ? void 0 : current.content.selectedCells.length) !== null && _a !== void 0 ? _a : 1);\n        },\n        caption: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            return trans._n('Paste this cell from the clipboard', 'Paste these %1 cells from the clipboard', (_a = current === null || current === void 0 ? void 0 : current.content.selectedCells.length) !== null && _a !== void 0 ? _a : 1);\n        },\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.paste(current.content, 'below');\n            }\n        },\n        icon: args => (args.toolbar ? _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_23__.pasteIcon : undefined),\n        isEnabled: args => (args.toolbar ? true : isEnabled())\n    });\n    commands.addCommand(CommandIDs.pasteAbove, {\n        label: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            return trans._n('Paste Cell Above', 'Paste Cells Above', (_a = current === null || current === void 0 ? void 0 : current.content.selectedCells.length) !== null && _a !== void 0 ? _a : 1);\n        },\n        caption: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            return trans._n('Paste this cell from the clipboard', 'Paste these %1 cells from the clipboard', (_a = current === null || current === void 0 ? void 0 : current.content.selectedCells.length) !== null && _a !== void 0 ? _a : 1);\n        },\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.paste(current.content, 'above');\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.duplicateBelow, {\n        label: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            return trans._n('Duplicate Cell Below', 'Duplicate Cells Below', (_a = current === null || current === void 0 ? void 0 : current.content.selectedCells.length) !== null && _a !== void 0 ? _a : 1);\n        },\n        caption: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            return trans._n('Create a duplicate of this cell below', 'Create duplicates of %1 cells below', (_a = current === null || current === void 0 ? void 0 : current.content.selectedCells.length) !== null && _a !== void 0 ? _a : 1);\n        },\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.duplicate(current.content, 'belowSelected');\n            }\n        },\n        icon: args => (args.toolbar ? _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_23__.duplicateIcon : undefined),\n        isEnabled: args => (args.toolbar ? true : isEnabled())\n    });\n    commands.addCommand(CommandIDs.pasteAndReplace, {\n        label: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            return trans._n('Paste Cell and Replace', 'Paste Cells and Replace', (_a = current === null || current === void 0 ? void 0 : current.content.selectedCells.length) !== null && _a !== void 0 ? _a : 1);\n        },\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.paste(current.content, 'replace');\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.deleteCell, {\n        label: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            return trans._n('Delete Cell', 'Delete Cells', (_a = current === null || current === void 0 ? void 0 : current.content.selectedCells.length) !== null && _a !== void 0 ? _a : 1);\n        },\n        caption: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            return trans._n('Delete this cell', 'Delete these %1 cells', (_a = current === null || current === void 0 ? void 0 : current.content.selectedCells.length) !== null && _a !== void 0 ? _a : 1);\n        },\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.deleteCells(current.content);\n            }\n        },\n        isEnabled: args => (args.toolbar ? true : isEnabled())\n    });\n    commands.addCommand(CommandIDs.split, {\n        label: trans.__('Split Cell'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.splitCell(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.merge, {\n        label: trans.__('Merge Selected Cells'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.mergeCells(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.mergeAbove, {\n        label: trans.__('Merge Cell Above'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.mergeCells(current.content, true);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.mergeBelow, {\n        label: trans.__('Merge Cell Below'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.mergeCells(current.content, false);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.insertAbove, {\n        label: trans.__('Insert Cell Above'),\n        caption: trans.__('Insert a cell above'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.insertAbove(current.content);\n            }\n        },\n        icon: args => (args.toolbar ? _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_23__.addAboveIcon : undefined),\n        isEnabled: args => (args.toolbar ? true : isEnabled())\n    });\n    commands.addCommand(CommandIDs.insertBelow, {\n        label: trans.__('Insert Cell Below'),\n        caption: trans.__('Insert a cell below'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.insertBelow(current.content);\n            }\n        },\n        icon: args => (args.toolbar ? _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_23__.addBelowIcon : undefined),\n        isEnabled: args => (args.toolbar ? true : isEnabled())\n    });\n    commands.addCommand(CommandIDs.selectAbove, {\n        label: trans.__('Select Cell Above'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.selectAbove(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.selectBelow, {\n        label: trans.__('Select Cell Below'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.selectBelow(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.insertHeadingAbove, {\n        label: trans.__('Insert Heading Above Current Heading'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.insertSameLevelHeadingAbove(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.insertHeadingBelow, {\n        label: trans.__('Insert Heading Below Current Heading'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.insertSameLevelHeadingBelow(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.selectHeadingAboveOrCollapse, {\n        label: trans.__('Select Heading Above or Collapse Heading'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.selectHeadingAboveOrCollapseHeading(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.selectHeadingBelowOrExpand, {\n        label: trans.__('Select Heading Below or Expand Heading'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.selectHeadingBelowOrExpandHeading(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.extendAbove, {\n        label: trans.__('Extend Selection Above'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.extendSelectionAbove(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.extendTop, {\n        label: trans.__('Extend Selection to Top'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.extendSelectionAbove(current.content, true);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.extendBelow, {\n        label: trans.__('Extend Selection Below'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.extendSelectionBelow(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.extendBottom, {\n        label: trans.__('Extend Selection to Bottom'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.extendSelectionBelow(current.content, true);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.selectAll, {\n        label: trans.__('Select All Cells'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.selectAll(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.deselectAll, {\n        label: trans.__('Deselect All Cells'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.deselectAll(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.moveUp, {\n        label: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            return trans._n('Move Cell Up', 'Move Cells Up', (_a = current === null || current === void 0 ? void 0 : current.content.selectedCells.length) !== null && _a !== void 0 ? _a : 1);\n        },\n        caption: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            return trans._n('Move this cell up', 'Move these %1 cells up', (_a = current === null || current === void 0 ? void 0 : current.content.selectedCells.length) !== null && _a !== void 0 ? _a : 1);\n        },\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.moveUp(current.content);\n                Private.raiseSilentNotification(trans.__('Notebook cell shifted up successfully'), current.node);\n            }\n        },\n        isEnabled: args => {\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            if (!current) {\n                return false;\n            }\n            return current.content.activeCellIndex >= 1;\n        },\n        icon: args => (args.toolbar ? _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_23__.moveUpIcon : undefined)\n    });\n    commands.addCommand(CommandIDs.moveDown, {\n        label: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            return trans._n('Move Cell Down', 'Move Cells Down', (_a = current === null || current === void 0 ? void 0 : current.content.selectedCells.length) !== null && _a !== void 0 ? _a : 1);\n        },\n        caption: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            return trans._n('Move this cell down', 'Move these %1 cells down', (_a = current === null || current === void 0 ? void 0 : current.content.selectedCells.length) !== null && _a !== void 0 ? _a : 1);\n        },\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.moveDown(current.content);\n                Private.raiseSilentNotification(trans.__('Notebook cell shifted down successfully'), current.node);\n            }\n        },\n        isEnabled: args => {\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            if (!current || !current.content.model) {\n                return false;\n            }\n            const length = current.content.model.cells.length;\n            return current.content.activeCellIndex < length - 1;\n        },\n        icon: args => (args.toolbar ? _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_23__.moveDownIcon : undefined)\n    });\n    commands.addCommand(CommandIDs.toggleAllLines, {\n        label: trans.__('Show Line Numbers'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.toggleAllLineNumbers(current.content);\n            }\n        },\n        isEnabled,\n        isToggled: args => {\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            if (current) {\n                const config = current.content.editorConfig;\n                return !!(config.code.lineNumbers &&\n                    config.markdown.lineNumbers &&\n                    config.raw.lineNumbers);\n            }\n            else {\n                return false;\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.commandMode, {\n        label: trans.__('Enter Command Mode'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                current.content.mode = 'command';\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.editMode, {\n        label: trans.__('Enter Edit Mode'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                current.content.mode = 'edit';\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.undoCellAction, {\n        label: trans.__('Undo Cell Operation'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.undo(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.redoCellAction, {\n        label: trans.__('Redo Cell Operation'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.redo(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.redo, {\n        label: trans.__('Redo'),\n        execute: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                const cell = current.content.activeCell;\n                if (cell) {\n                    cell.inputHidden = false;\n                    return (_a = cell.editor) === null || _a === void 0 ? void 0 : _a.redo();\n                }\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.undo, {\n        label: trans.__('Undo'),\n        execute: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                const cell = current.content.activeCell;\n                if (cell) {\n                    cell.inputHidden = false;\n                    return (_a = cell.editor) === null || _a === void 0 ? void 0 : _a.undo();\n                }\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.changeKernel, {\n        label: trans.__('Change Kernel…'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return sessionDialogs.selectKernel(current.context.sessionContext);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.getKernel, {\n        label: trans.__('Get Kernel'),\n        execute: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, { activate: false, ...args });\n            if (current) {\n                return (_a = current.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.reconnectToKernel, {\n        label: trans.__('Reconnect to Kernel'),\n        execute: args => {\n            var _a;\n            const current = getCurrent(tracker, shell, args);\n            if (!current) {\n                return;\n            }\n            const kernel = (_a = current.context.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;\n            if (kernel) {\n                return kernel.reconnect();\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.markdown1, {\n        label: trans.__('Change to Heading 1'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.setMarkdownHeader(current.content, 1, translator);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.markdown2, {\n        label: trans.__('Change to Heading 2'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.setMarkdownHeader(current.content, 2, translator);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.markdown3, {\n        label: trans.__('Change to Heading 3'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.setMarkdownHeader(current.content, 3, translator);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.markdown4, {\n        label: trans.__('Change to Heading 4'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.setMarkdownHeader(current.content, 4, translator);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.markdown5, {\n        label: trans.__('Change to Heading 5'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.setMarkdownHeader(current.content, 5, translator);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.markdown6, {\n        label: trans.__('Change to Heading 6'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.setMarkdownHeader(current.content, 6, translator);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.hideCode, {\n        label: trans.__('Collapse Selected Code'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.hideCode(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.showCode, {\n        label: trans.__('Expand Selected Code'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.showCode(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.hideAllCode, {\n        label: trans.__('Collapse All Code'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.hideAllCode(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.showAllCode, {\n        label: trans.__('Expand All Code'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.showAllCode(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.hideOutput, {\n        label: trans.__('Collapse Selected Outputs'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.hideOutput(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.showOutput, {\n        label: trans.__('Expand Selected Outputs'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.showOutput(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.toggleOutput, {\n        label: trans.__('Toggle Visibility of Selected Outputs'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.toggleOutput(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.hideAllOutputs, {\n        label: trans.__('Collapse All Outputs'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.hideAllOutputs(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.toggleRenderSideBySideCurrentNotebook, {\n        label: trans.__('Render Side-by-Side'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                if (current.content.renderingLayout === 'side-by-side') {\n                    return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.renderDefault(current.content);\n                }\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.renderSideBySide(current.content);\n            }\n        },\n        isEnabled,\n        isToggled: args => {\n            const current = getCurrent(tracker, shell, { ...args, activate: false });\n            if (current) {\n                return current.content.renderingLayout === 'side-by-side';\n            }\n            else {\n                return false;\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.showAllOutputs, {\n        label: trans.__('Expand All Outputs'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.showAllOutputs(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.enableOutputScrolling, {\n        label: trans.__('Enable Scrolling for Outputs'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.enableOutputScrolling(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.disableOutputScrolling, {\n        label: trans.__('Disable Scrolling for Outputs'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.disableOutputScrolling(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.selectLastRunCell, {\n        label: trans.__('Select current running or last run cell'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.selectLastRunCell(current.content);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.replaceSelection, {\n        label: trans.__('Replace Selection in Notebook Cell'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            const text = args['text'] || '';\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.replaceSelection(current.content, text);\n            }\n        },\n        isEnabled\n    });\n    commands.addCommand(CommandIDs.toggleCollapseCmd, {\n        label: trans.__('Toggle Collapse Notebook Heading'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.toggleCurrentHeadingCollapse(current.content);\n            }\n        },\n        isEnabled: isEnabledAndHeadingSelected\n    });\n    commands.addCommand(CommandIDs.collapseAllCmd, {\n        label: trans.__('Collapse All Headings'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.collapseAllHeadings(current.content);\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.expandAllCmd, {\n        label: trans.__('Expand All Headings'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.expandAllHeadings(current.content);\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.tocRunCells, {\n        label: trans.__('Select and Run Cell(s) for this Heading'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, { activate: false, ...args });\n            if (current === null) {\n                return;\n            }\n            const activeCell = current.content.activeCell;\n            let lastIndex = current.content.activeCellIndex;\n            if (activeCell instanceof _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_2__.MarkdownCell) {\n                const cells = current.content.widgets;\n                const level = activeCell.headingInfo.level;\n                for (let i = current.content.activeCellIndex + 1; i < cells.length; i++) {\n                    const cell = cells[i];\n                    if (cell instanceof _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_2__.MarkdownCell &&\n                        // cell.headingInfo.level === -1 if no heading\n                        cell.headingInfo.level >= 0 &&\n                        cell.headingInfo.level <= level) {\n                        break;\n                    }\n                    lastIndex = i;\n                }\n            }\n            current.content.extendContiguousSelectionTo(lastIndex);\n            void _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.run(current.content, current.sessionContext, sessionDialogs, translator);\n        }\n    });\n    commands.addCommand(CommandIDs.accessPreviousHistory, {\n        label: trans.__('Access Previous Kernel History Entry'),\n        execute: async (args) => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return await _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.accessPreviousHistory(current.content);\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.accessNextHistory, {\n        label: trans.__('Access Next Kernel History Entry'),\n        execute: async (args) => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                return await _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_15__.NotebookActions.accessNextHistory(current.content);\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.virtualScrollbar, {\n        label: trans.__('Show Minimap'),\n        caption: trans.__('Show Minimap (virtual scrollbar, enabled with windowing mode: full)'),\n        execute: args => {\n            const current = getCurrent(tracker, shell, args);\n            if (current) {\n                current.content.scrollbar = !current.content.scrollbar;\n            }\n        },\n        icon: args => (args.toolbar ? _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_23__.tableRowsIcon : undefined),\n        isEnabled: args => {\n            var _a;\n            const enabled = (args.toolbar ? true : isEnabled()) &&\n                ((_a = (settings === null || settings === void 0 ? void 0 : settings.composite.windowingMode) === 'full') !== null && _a !== void 0 ? _a : false);\n            return enabled;\n        },\n        isToggled: () => {\n            var _a;\n            const current = tracker.currentWidget;\n            return (_a = current === null || current === void 0 ? void 0 : current.content.scrollbar) !== null && _a !== void 0 ? _a : false;\n        },\n        isVisible: args => {\n            var _a;\n            const visible = (args.toolbar ? true : isEnabled()) &&\n                ((_a = (settings === null || settings === void 0 ? void 0 : settings.composite.windowingMode) === 'full') !== null && _a !== void 0 ? _a : false);\n            return visible;\n        }\n    });\n    // All commands with isEnabled defined directly or in a semantic commands\n    // To simplify here we added all commands as most of them have isEnabled\n    const skip = [CommandIDs.createNew, CommandIDs.createOutputView];\n    const notify = () => {\n        Object.values(CommandIDs)\n            .filter(id => !skip.includes(id) && app.commands.hasCommand(id))\n            .forEach(id => app.commands.notifyCommandChanged(id));\n    };\n    tracker.currentChanged.connect(notify);\n    (_a = shell.currentChanged) === null || _a === void 0 ? void 0 : _a.connect(notify);\n}\n/**\n * Populate the application's command palette with notebook commands.\n */\nfunction populatePalette(palette, translator) {\n    const trans = translator.load('jupyterlab');\n    let category = trans.__('Notebook Operations');\n    [\n        CommandIDs.interrupt,\n        CommandIDs.restart,\n        CommandIDs.restartClear,\n        CommandIDs.restartRunAll,\n        CommandIDs.runAll,\n        CommandIDs.renderAllMarkdown,\n        CommandIDs.runAllAbove,\n        CommandIDs.runAllBelow,\n        CommandIDs.restartAndRunToSelected,\n        CommandIDs.selectAll,\n        CommandIDs.deselectAll,\n        CommandIDs.clearAllOutputs,\n        CommandIDs.toggleAllLines,\n        CommandIDs.editMode,\n        CommandIDs.commandMode,\n        CommandIDs.changeKernel,\n        CommandIDs.reconnectToKernel,\n        CommandIDs.createConsole,\n        CommandIDs.createSubshellConsole,\n        CommandIDs.closeAndShutdown,\n        CommandIDs.trust,\n        CommandIDs.toggleCollapseCmd,\n        CommandIDs.collapseAllCmd,\n        CommandIDs.expandAllCmd,\n        CommandIDs.accessPreviousHistory,\n        CommandIDs.accessNextHistory,\n        CommandIDs.virtualScrollbar\n    ].forEach(command => {\n        palette.addItem({ command, category });\n    });\n    palette.addItem({\n        command: CommandIDs.createNew,\n        category,\n        args: { isPalette: true }\n    });\n    category = trans.__('Notebook Cell Operations');\n    [\n        CommandIDs.run,\n        CommandIDs.runAndAdvance,\n        CommandIDs.runAndInsert,\n        CommandIDs.runInConsole,\n        CommandIDs.clearOutputs,\n        CommandIDs.toCode,\n        CommandIDs.toMarkdown,\n        CommandIDs.toRaw,\n        CommandIDs.cut,\n        CommandIDs.copy,\n        CommandIDs.pasteBelow,\n        CommandIDs.pasteAbove,\n        CommandIDs.pasteAndReplace,\n        CommandIDs.deleteCell,\n        CommandIDs.split,\n        CommandIDs.merge,\n        CommandIDs.mergeAbove,\n        CommandIDs.mergeBelow,\n        CommandIDs.insertAbove,\n        CommandIDs.insertBelow,\n        CommandIDs.selectAbove,\n        CommandIDs.selectBelow,\n        CommandIDs.selectHeadingAboveOrCollapse,\n        CommandIDs.selectHeadingBelowOrExpand,\n        CommandIDs.insertHeadingAbove,\n        CommandIDs.insertHeadingBelow,\n        CommandIDs.extendAbove,\n        CommandIDs.extendTop,\n        CommandIDs.extendBelow,\n        CommandIDs.extendBottom,\n        CommandIDs.moveDown,\n        CommandIDs.moveUp,\n        CommandIDs.undoCellAction,\n        CommandIDs.redoCellAction,\n        CommandIDs.markdown1,\n        CommandIDs.markdown2,\n        CommandIDs.markdown3,\n        CommandIDs.markdown4,\n        CommandIDs.markdown5,\n        CommandIDs.markdown6,\n        CommandIDs.hideCode,\n        CommandIDs.showCode,\n        CommandIDs.hideAllCode,\n        CommandIDs.showAllCode,\n        CommandIDs.hideOutput,\n        CommandIDs.showOutput,\n        CommandIDs.toggleOutput,\n        CommandIDs.hideAllOutputs,\n        CommandIDs.showAllOutputs,\n        CommandIDs.toggleRenderSideBySideCurrentNotebook,\n        CommandIDs.setSideBySideRatio,\n        CommandIDs.enableOutputScrolling,\n        CommandIDs.disableOutputScrolling\n    ].forEach(command => {\n        palette.addItem({ command, category });\n    });\n}\n/**\n * Populates the application menus for the notebook.\n */\nfunction populateMenus(mainMenu, isEnabled) {\n    // Add undo/redo hooks to the edit menu.\n    mainMenu.editMenu.undoers.redo.add({\n        id: CommandIDs.redo,\n        isEnabled\n    });\n    mainMenu.editMenu.undoers.undo.add({\n        id: CommandIDs.undo,\n        isEnabled\n    });\n    // Add a clearer to the edit menu\n    mainMenu.editMenu.clearers.clearAll.add({\n        id: CommandIDs.clearAllOutputs,\n        isEnabled\n    });\n    mainMenu.editMenu.clearers.clearCurrent.add({\n        id: CommandIDs.clearOutputs,\n        isEnabled\n    });\n    // Add a console creator the the Kernel menu\n    mainMenu.fileMenu.consoleCreators.add({\n        id: CommandIDs.createConsole,\n        isEnabled\n    });\n    // Add a close and shutdown command to the file menu.\n    mainMenu.fileMenu.closeAndCleaners.add({\n        id: CommandIDs.closeAndShutdown,\n        isEnabled\n    });\n    // Add a kernel user to the Kernel menu\n    mainMenu.kernelMenu.kernelUsers.changeKernel.add({\n        id: CommandIDs.changeKernel,\n        isEnabled\n    });\n    mainMenu.kernelMenu.kernelUsers.clearWidget.add({\n        id: CommandIDs.clearAllOutputs,\n        isEnabled\n    });\n    mainMenu.kernelMenu.kernelUsers.interruptKernel.add({\n        id: CommandIDs.interrupt,\n        isEnabled\n    });\n    mainMenu.kernelMenu.kernelUsers.reconnectToKernel.add({\n        id: CommandIDs.reconnectToKernel,\n        isEnabled\n    });\n    mainMenu.kernelMenu.kernelUsers.restartKernel.add({\n        id: CommandIDs.restart,\n        isEnabled\n    });\n    mainMenu.kernelMenu.kernelUsers.shutdownKernel.add({\n        id: CommandIDs.shutdown,\n        isEnabled\n    });\n    // Add an IEditorViewer to the application view menu\n    mainMenu.viewMenu.editorViewers.toggleLineNumbers.add({\n        id: CommandIDs.toggleAllLines,\n        isEnabled\n    });\n    // Add an ICodeRunner to the application run menu\n    mainMenu.runMenu.codeRunners.restart.add({\n        id: CommandIDs.restart,\n        isEnabled\n    });\n    mainMenu.runMenu.codeRunners.run.add({\n        id: CommandIDs.runAndAdvance,\n        isEnabled\n    });\n    mainMenu.runMenu.codeRunners.runAll.add({ id: CommandIDs.runAll, isEnabled });\n    // Add kernel information to the application help menu.\n    mainMenu.helpMenu.getKernel.add({\n        id: CommandIDs.getKernel,\n        isEnabled\n    });\n}\n/**\n * A namespace for module private functionality.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Create a console connected with a notebook kernel\n     *\n     * @param commands Commands registry\n     * @param widget Notebook panel\n     * @param activate Should the console be activated\n     * @param subshell Should the console contain a subshell or the main shell\n     */\n    function createConsole(commands, widget, activate, subshell) {\n        const options = {\n            path: widget.context.path,\n            preferredLanguage: widget.context.model.defaultKernelLanguage,\n            activate: activate,\n            subshell: subshell,\n            ref: widget.id,\n            insertMode: 'split-bottom',\n            type: 'Linked Console'\n        };\n        return commands.execute('console:create', options);\n    }\n    Private.createConsole = createConsole;\n    /**\n     * Whether there is an active notebook.\n     */\n    function isEnabled(shell, tracker) {\n        return (tracker.currentWidget !== null &&\n            tracker.currentWidget === shell.currentWidget);\n    }\n    Private.isEnabled = isEnabled;\n    /**\n     * Whether there is an notebook active, with a single selected cell.\n     */\n    function isEnabledAndSingleSelected(shell, tracker) {\n        if (!Private.isEnabled(shell, tracker)) {\n            return false;\n        }\n        const { content } = tracker.currentWidget;\n        const index = content.activeCellIndex;\n        // If there are selections that are not the active cell,\n        // this command is confusing, so disable it.\n        for (let i = 0; i < content.widgets.length; ++i) {\n            if (content.isSelected(content.widgets[i]) && i !== index) {\n                return false;\n            }\n        }\n        return true;\n    }\n    Private.isEnabledAndSingleSelected = isEnabledAndSingleSelected;\n    /**\n     * Whether there is an notebook active, with a single selected cell.\n     */\n    function isEnabledAndHeadingSelected(shell, tracker) {\n        if (!Private.isEnabled(shell, tracker)) {\n            return false;\n        }\n        const { content } = tracker.currentWidget;\n        const index = content.activeCellIndex;\n        if (!(content.activeCell instanceof _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_2__.MarkdownCell)) {\n            return false;\n        }\n        // If there are selections that are not the active cell,\n        // this command is confusing, so disable it.\n        for (let i = 0; i < content.widgets.length; ++i) {\n            if (content.isSelected(content.widgets[i]) && i !== index) {\n                return false;\n            }\n        }\n        return true;\n    }\n    Private.isEnabledAndHeadingSelected = isEnabledAndHeadingSelected;\n    /**\n     * The default Export To ... formats and their human readable labels.\n     */\n    function getFormatLabels(translator) {\n        translator = translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_22__.nullTranslator;\n        const trans = translator.load('jupyterlab');\n        return {\n            html: trans.__('HTML'),\n            latex: trans.__('LaTeX'),\n            markdown: trans.__('Markdown'),\n            pdf: trans.__('PDF'),\n            rst: trans.__('ReStructured Text'),\n            script: trans.__('Executable Script'),\n            slides: trans.__('Reveal.js Slides')\n        };\n    }\n    Private.getFormatLabels = getFormatLabels;\n    /**\n     * Raises a silent notification that is read by screen readers\n     *\n     * FIXME: Once a notificatiom API is introduced (https://github.com/jupyterlab/jupyterlab/issues/689),\n     * this can be refactored to use the same.\n     *\n     * More discussion at https://github.com/jupyterlab/jupyterlab/pull/9031#issuecomment-773541469\n     *\n     *\n     * @param message Message to be relayed to screen readers\n     * @param notebookNode DOM node to which the notification container is attached\n     */\n    function raiseSilentNotification(message, notebookNode) {\n        const hiddenAlertContainerId = `sr-message-container-${notebookNode.id}`;\n        const hiddenAlertContainer = document.getElementById(hiddenAlertContainerId) ||\n            document.createElement('div');\n        // If the container is not available, append the newly created container\n        // to the current notebook panel and set related properties\n        if (hiddenAlertContainer.getAttribute('id') !== hiddenAlertContainerId) {\n            hiddenAlertContainer.classList.add('sr-only');\n            hiddenAlertContainer.setAttribute('id', hiddenAlertContainerId);\n            hiddenAlertContainer.setAttribute('role', 'alert');\n            hiddenAlertContainer.hidden = true;\n            notebookNode.appendChild(hiddenAlertContainer);\n        }\n        // Insert/Update alert container with the notification message\n        hiddenAlertContainer.innerText = message;\n    }\n    Private.raiseSilentNotification = raiseSilentNotification;\n    /**\n     * A widget hosting a cloned output area.\n     */\n    class ClonedOutputArea extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_28__.Panel {\n        constructor(options) {\n            super();\n            this._cell = null;\n            const trans = (options.translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_22__.nullTranslator).load('jupyterlab');\n            this._notebook = options.notebook;\n            this._index = options.index !== undefined ? options.index : -1;\n            this._cell = options.cell || null;\n            this.id = `LinkedOutputView-${_lumino_coreutils__WEBPACK_IMPORTED_MODULE_25__.UUID.uuid4()}`;\n            this.title.label = 'Output View';\n            this.title.icon = _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_23__.notebookIcon;\n            this.title.caption = this._notebook.title.label\n                ? trans.__('For Notebook: %1', this._notebook.title.label)\n                : trans.__('For Notebook:');\n            this.addClass('jp-LinkedOutputView');\n            // Wait for the notebook to be loaded before\n            // cloning the output area.\n            void this._notebook.context.ready.then(() => {\n                if (!this._cell) {\n                    this._cell = this._notebook.content.widgets[this._index];\n                }\n                if (!this._cell || this._cell.model.type !== 'code') {\n                    this.dispose();\n                    return;\n                }\n                const clone = this._cell.cloneOutputArea();\n                this.addWidget(clone);\n            });\n        }\n        /**\n         * The index of the cell in the notebook.\n         */\n        get index() {\n            return this._cell\n                ? _lumino_algorithm__WEBPACK_IMPORTED_MODULE_24__.ArrayExt.findFirstIndex(this._notebook.content.widgets, c => c === this._cell)\n                : this._index;\n        }\n        /**\n         * The path of the notebook for the cloned output area.\n         */\n        get path() {\n            return this._notebook.context.path;\n        }\n    }\n    Private.ClonedOutputArea = ClonedOutputArea;\n})(Private || (Private = {}));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook-extension/lib/index.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/notebook-extension/lib/nboutput.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@jupyterlab/notebook-extension/lib/nboutput.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   logNotebookOutput: () => (/* binding */ logNotebookOutput)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_logconsole__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/logconsole */ \"webpack/sharing/consume/default/@jupyterlab/logconsole/@jupyterlab/logconsole\");\n/* harmony import */ var _jupyterlab_logconsole__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_logconsole__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/notebook */ \"webpack/sharing/consume/default/@jupyterlab/notebook/@jupyterlab/notebook\");\n/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jupyterlab_services__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/services */ \"webpack/sharing/consume/default/@jupyterlab/services/@jupyterlab/services\");\n/* harmony import */ var _jupyterlab_services__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_services__WEBPACK_IMPORTED_MODULE_2__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\n\n\n/**\n * The Log Console extension.\n */\nconst logNotebookOutput = {\n    activate: activateNBOutput,\n    id: '@jupyterlab/notebook-extension:log-output',\n    description: 'Adds cell outputs log to the application logger.',\n    requires: [_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_1__.INotebookTracker],\n    optional: [_jupyterlab_logconsole__WEBPACK_IMPORTED_MODULE_0__.ILoggerRegistry],\n    autoStart: true\n};\nfunction activateNBOutput(app, nbtracker, loggerRegistry) {\n    if (!loggerRegistry) {\n        // Automatically disable if logconsole is missing\n        return;\n    }\n    function registerNB(nb) {\n        function logOutput(msg, levelNormal, levelError) {\n            if (_jupyterlab_services__WEBPACK_IMPORTED_MODULE_2__.KernelMessage.isDisplayDataMsg(msg) ||\n                _jupyterlab_services__WEBPACK_IMPORTED_MODULE_2__.KernelMessage.isStreamMsg(msg) ||\n                _jupyterlab_services__WEBPACK_IMPORTED_MODULE_2__.KernelMessage.isErrorMsg(msg) ||\n                _jupyterlab_services__WEBPACK_IMPORTED_MODULE_2__.KernelMessage.isExecuteResultMsg(msg)) {\n                const logger = loggerRegistry.getLogger(nb.context.path);\n                logger.rendermime = nb.content.rendermime;\n                const data = {\n                    ...msg.content,\n                    output_type: msg.header.msg_type\n                };\n                let level = levelNormal;\n                if (_jupyterlab_services__WEBPACK_IMPORTED_MODULE_2__.KernelMessage.isErrorMsg(msg) ||\n                    (_jupyterlab_services__WEBPACK_IMPORTED_MODULE_2__.KernelMessage.isStreamMsg(msg) && msg.content.name === 'stderr')) {\n                    level = levelError;\n                }\n                logger.log({ type: 'output', data, level });\n            }\n        }\n        // There is overlap here since unhandled messages are also emitted in the\n        // iopubMessage signal. However, unhandled messages warrant a higher log\n        // severity, so we'll accept that they are logged twice.\n        nb.context.sessionContext.iopubMessage.connect((_, msg) => logOutput(msg, 'info', 'info'));\n        nb.context.sessionContext.unhandledMessage.connect((_, msg) => logOutput(msg, 'warning', 'error'));\n    }\n    nbtracker.forEach(nb => registerNB(nb));\n    nbtracker.widgetAdded.connect((_, nb) => registerNB(nb));\n}\n//# sourceMappingURL=nboutput.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook-extension/lib/nboutput.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/notebook-extension/lib/tool-widgets/activeCellToolWidget.js":
/*!***********************************************************************************************!*\
  !*** ../node_modules/@jupyterlab/notebook-extension/lib/tool-widgets/activeCellToolWidget.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActiveCellTool: () => (/* binding */ ActiveCellTool)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/notebook */ \"webpack/sharing/consume/default/@jupyterlab/notebook/@jupyterlab/notebook\");\n/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/widgets */ \"webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets\");\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/cells */ \"webpack/sharing/consume/default/@jupyterlab/cells/@jupyterlab/cells\");\n/* harmony import */ var _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_cells__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _lumino_polling__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lumino/polling */ \"webpack/sharing/consume/default/@lumino/polling/@lumino/polling\");\n/* harmony import */ var _lumino_polling__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_lumino_polling__WEBPACK_IMPORTED_MODULE_4__);\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\n\n\n\n\n/**\n * The class name added to the ActiveCellTool.\n */\nconst ACTIVE_CELL_TOOL_CLASS = 'jp-ActiveCellTool';\n/**\n * The class name added to the ActiveCellTool content.\n */\nconst ACTIVE_CELL_TOOL_CONTENT_CLASS = 'jp-ActiveCellTool-Content';\n/**\n * The class name added to the ActiveCellTool cell content.\n */\nconst ACTIVE_CELL_TOOL_CELL_CONTENT_CLASS = 'jp-ActiveCellTool-CellContent';\n/**\n * The active cell field, displaying the first line and execution count of the active cell.\n *\n * ## Note\n * This field does not work as other metadata form fields, as it does not update metadata.\n */\nclass ActiveCellTool extends _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_1__.NotebookTools.Tool {\n    constructor(options) {\n        super();\n        const { languages } = options;\n        this._tracker = options.tracker;\n        this.addClass(ACTIVE_CELL_TOOL_CLASS);\n        this.layout = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.PanelLayout();\n        this._inputPrompt = new _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_3__.InputPrompt();\n        this.layout.addWidget(this._inputPrompt);\n        // First code line container\n        const node = document.createElement('div');\n        node.classList.add(ACTIVE_CELL_TOOL_CONTENT_CLASS);\n        const container = node.appendChild(document.createElement('div'));\n        const editor = container.appendChild(document.createElement('pre'));\n        container.className = ACTIVE_CELL_TOOL_CELL_CONTENT_CLASS;\n        this._editorEl = editor;\n        this.layout.addWidget(new _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Widget({ node }));\n        const update = async () => {\n            var _a, _b;\n            this._editorEl.innerHTML = '';\n            if (((_a = this._cellModel) === null || _a === void 0 ? void 0 : _a.type) === 'code') {\n                this._inputPrompt.executionCount = `${(_b = this._cellModel.executionCount) !== null && _b !== void 0 ? _b : ''}`;\n                this._inputPrompt.show();\n            }\n            else {\n                this._inputPrompt.executionCount = null;\n                this._inputPrompt.hide();\n            }\n            if (this._cellModel) {\n                await languages.highlight(this._cellModel.sharedModel.getSource().split('\\n')[0], languages.findByMIME(this._cellModel.mimeType), this._editorEl);\n            }\n        };\n        this._refreshDebouncer = new _lumino_polling__WEBPACK_IMPORTED_MODULE_4__.Debouncer(update, 150);\n    }\n    render(props) {\n        var _a, _b;\n        const activeCell = this._tracker.activeCell;\n        if (activeCell)\n            this._cellModel = (activeCell === null || activeCell === void 0 ? void 0 : activeCell.model) || null;\n        ((_a = this._cellModel) === null || _a === void 0 ? void 0 : _a.sharedModel).changed.connect(this.refresh, this);\n        (_b = this._cellModel) === null || _b === void 0 ? void 0 : _b.mimeTypeChanged.connect(this.refresh, this);\n        this.refresh()\n            .then(() => undefined)\n            .catch(() => undefined);\n        return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", { ref: ref => ref === null || ref === void 0 ? void 0 : ref.appendChild(this.node) });\n    }\n    async refresh() {\n        await this._refreshDebouncer.invoke();\n    }\n}\n//# sourceMappingURL=activeCellToolWidget.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook-extension/lib/tool-widgets/activeCellToolWidget.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/notebook-extension/lib/tool-widgets/metadataEditorFields.js":
/*!***********************************************************************************************!*\
  !*** ../node_modules/@jupyterlab/notebook-extension/lib/tool-widgets/metadataEditorFields.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CellMetadataField: () => (/* binding */ CellMetadataField),\n/* harmony export */   NotebookMetadataField: () => (/* binding */ NotebookMetadataField)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/notebook */ \"webpack/sharing/consume/default/@jupyterlab/notebook/@jupyterlab/notebook\");\n/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/observables */ \"webpack/sharing/consume/default/@jupyterlab/observables/@jupyterlab/observables\");\n/* harmony import */ var _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_observables__WEBPACK_IMPORTED_MODULE_2__);\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\n\n\nconst CELL_METADATA_EDITOR_CLASS = 'jp-CellMetadataEditor';\nconst NOTEBOOK_METADATA_EDITOR_CLASS = 'jp-NotebookMetadataEditor';\n/**\n * The cell metadata field.\n *\n * ## Note\n * This field does not work as other metadata form fields, as it does not use RJSF to update metadata.\n * It extends the MetadataEditorTool which updates itself the metadata.\n * It only renders the node of MetadataEditorTool in a React element instead of displaying a RJSF field.\n */\nclass CellMetadataField extends _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_1__.NotebookTools.MetadataEditorTool {\n    constructor(options) {\n        super(options);\n        this._tracker = options.tracker;\n        this.editor.editorHostNode.addEventListener('blur', this.editor, true);\n        this.editor.editorHostNode.addEventListener('click', this.editor, true);\n        this.editor.headerNode.addEventListener('click', this.editor);\n    }\n    _onSourceChanged() {\n        var _a, _b, _c;\n        const activeCell = (_a = this._tracker.activeCell) === null || _a === void 0 ? void 0 : _a.model.sharedModel;\n        if (activeCell && this.editor.source) {\n            const metadataKeys = Object.keys((_b = activeCell.metadata) !== null && _b !== void 0 ? _b : {});\n            const source = (_c = this.editor.source.toJSON()) !== null && _c !== void 0 ? _c : {};\n            activeCell.transact(() => {\n                // Iterate over all existing metadata keys and delete each one.\n                // This ensures that any keys not present in the new metadata are removed.\n                metadataKeys.forEach(key => activeCell.deleteMetadata(key));\n                activeCell.setMetadata(source);\n            });\n        }\n    }\n    render(props) {\n        var _a;\n        const cell = this._tracker.activeCell;\n        this.editor.source = cell\n            ? new _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_2__.ObservableJSON({ values: cell.model.metadata })\n            : null;\n        (_a = this.editor.source) === null || _a === void 0 ? void 0 : _a.changed.connect(this._onSourceChanged, this);\n        return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", { className: CELL_METADATA_EDITOR_CLASS },\n            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", { ref: ref => ref === null || ref === void 0 ? void 0 : ref.appendChild(this.node) })));\n    }\n}\n/**\n * The notebook metadata field.\n *\n * ## Note\n * This field does not work as other metadata form fields, as it does not use RJSF to update metadata.\n * It extends the MetadataEditorTool which updates itself the metadata.\n * It only renders the node of MetadataEditorTool in a React element instead of displaying a RJSF field.\n */\nclass NotebookMetadataField extends _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_1__.NotebookTools.MetadataEditorTool {\n    constructor(options) {\n        super(options);\n        this._tracker = options.tracker;\n        this.editor.editorHostNode.addEventListener('blur', this.editor, true);\n        this.editor.editorHostNode.addEventListener('click', this.editor, true);\n        this.editor.headerNode.addEventListener('click', this.editor);\n    }\n    _onSourceChanged() {\n        var _a, _b;\n        if (this.editor.source) {\n            (_b = (_a = this._tracker.currentWidget) === null || _a === void 0 ? void 0 : _a.model) === null || _b === void 0 ? void 0 : _b.sharedModel.setMetadata(this.editor.source.toJSON());\n        }\n    }\n    render(props) {\n        var _a, _b;\n        const notebook = this._tracker.currentWidget;\n        this.editor.source = notebook\n            ? new _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_2__.ObservableJSON({ values: (_a = notebook.model) === null || _a === void 0 ? void 0 : _a.metadata })\n            : null;\n        (_b = this.editor.source) === null || _b === void 0 ? void 0 : _b.changed.connect(this._onSourceChanged, this);\n        return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", { className: NOTEBOOK_METADATA_EDITOR_CLASS },\n            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", { ref: ref => ref === null || ref === void 0 ? void 0 : ref.appendChild(this.node) })));\n    }\n}\n//# sourceMappingURL=metadataEditorFields.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook-extension/lib/tool-widgets/metadataEditorFields.js?");

/***/ })

}]);