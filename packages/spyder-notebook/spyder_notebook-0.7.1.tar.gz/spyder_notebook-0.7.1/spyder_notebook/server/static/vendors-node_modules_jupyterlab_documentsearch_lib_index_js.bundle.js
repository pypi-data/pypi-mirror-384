"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["vendors-node_modules_jupyterlab_documentsearch_lib_index_js"],{

/***/ "../node_modules/@jupyterlab/documentsearch/lib/index.js":
/*!***************************************************************!*\
  !*** ../node_modules/@jupyterlab/documentsearch/lib/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FOUND_CLASSES: () => (/* reexport safe */ _providers_genericsearchprovider__WEBPACK_IMPORTED_MODULE_0__.FOUND_CLASSES),\n/* harmony export */   GenericSearchProvider: () => (/* reexport safe */ _providers_genericsearchprovider__WEBPACK_IMPORTED_MODULE_0__.GenericSearchProvider),\n/* harmony export */   HTMLSearchEngine: () => (/* reexport safe */ _providers_genericsearchprovider__WEBPACK_IMPORTED_MODULE_0__.HTMLSearchEngine),\n/* harmony export */   ISearchProviderRegistry: () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_6__.ISearchProviderRegistry),\n/* harmony export */   SearchDocumentModel: () => (/* reexport safe */ _searchmodel__WEBPACK_IMPORTED_MODULE_2__.SearchDocumentModel),\n/* harmony export */   SearchDocumentView: () => (/* reexport safe */ _searchview__WEBPACK_IMPORTED_MODULE_3__.SearchDocumentView),\n/* harmony export */   SearchProvider: () => (/* reexport safe */ _searchprovider__WEBPACK_IMPORTED_MODULE_4__.SearchProvider),\n/* harmony export */   SearchProviderRegistry: () => (/* reexport safe */ _searchproviderregistry__WEBPACK_IMPORTED_MODULE_5__.SearchProviderRegistry),\n/* harmony export */   TextSearchEngine: () => (/* reexport safe */ _providers_textprovider__WEBPACK_IMPORTED_MODULE_1__.TextSearchEngine)\n/* harmony export */ });\n/* harmony import */ var _providers_genericsearchprovider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./providers/genericsearchprovider */ \"../node_modules/@jupyterlab/documentsearch/lib/providers/genericsearchprovider.js\");\n/* harmony import */ var _providers_textprovider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./providers/textprovider */ \"../node_modules/@jupyterlab/documentsearch/lib/providers/textprovider.js\");\n/* harmony import */ var _searchmodel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./searchmodel */ \"../node_modules/@jupyterlab/documentsearch/lib/searchmodel.js\");\n/* harmony import */ var _searchview__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./searchview */ \"../node_modules/@jupyterlab/documentsearch/lib/searchview.js\");\n/* harmony import */ var _searchprovider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./searchprovider */ \"../node_modules/@jupyterlab/documentsearch/lib/searchprovider.js\");\n/* harmony import */ var _searchproviderregistry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./searchproviderregistry */ \"../node_modules/@jupyterlab/documentsearch/lib/searchproviderregistry.js\");\n/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tokens */ \"../node_modules/@jupyterlab/documentsearch/lib/tokens.js\");\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module documentsearch\n */\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/index.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/documentsearch/lib/providers/genericsearchprovider.js":
/*!*****************************************************************************************!*\
  !*** ../node_modules/@jupyterlab/documentsearch/lib/providers/genericsearchprovider.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FOUND_CLASSES: () => (/* binding */ FOUND_CLASSES),\n/* harmony export */   GenericSearchProvider: () => (/* binding */ GenericSearchProvider),\n/* harmony export */   HTMLSearchEngine: () => (/* binding */ HTMLSearchEngine)\n/* harmony export */ });\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/widgets */ \"webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets\");\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _searchprovider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../searchprovider */ \"../node_modules/@jupyterlab/documentsearch/lib/searchprovider.js\");\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\n\nconst FOUND_CLASSES = ['cm-string', 'cm-overlay', 'cm-searching'];\nconst SELECTED_CLASSES = ['CodeMirror-selectedtext'];\n/**\n * HTML search engine\n */\nclass HTMLSearchEngine {\n    /**\n     * Search for a `query` in a DOM tree.\n     *\n     * @param query Regular expression to search\n     * @param rootNode DOM root node to search in\n     * @returns The list of matches\n     */\n    static search(query, rootNode) {\n        if (!(rootNode instanceof Node)) {\n            console.warn('Unable to search with HTMLSearchEngine the provided object.', rootNode);\n            return Promise.resolve([]);\n        }\n        if (!query.global) {\n            query = new RegExp(query.source, query.flags + 'g');\n        }\n        const matches = [];\n        const walker = document.createTreeWalker(rootNode, NodeFilter.SHOW_TEXT, {\n            acceptNode: node => {\n                // Filter subtrees of UNSUPPORTED_ELEMENTS and nodes that\n                // do not contain our search text\n                let parentElement = node.parentElement;\n                while (parentElement !== rootNode) {\n                    if (parentElement.nodeName in HTMLSearchEngine.UNSUPPORTED_ELEMENTS) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n                    parentElement = parentElement.parentElement;\n                }\n                return query.test(node.textContent)\n                    ? NodeFilter.FILTER_ACCEPT\n                    : NodeFilter.FILTER_REJECT;\n            }\n        });\n        let node = null;\n        while ((node = walker.nextNode()) !== null) {\n            // Reset query index\n            query.lastIndex = 0;\n            let match = null;\n            while ((match = query.exec(node.textContent)) !== null) {\n                matches.push({\n                    text: match[0],\n                    position: match.index,\n                    node: node\n                });\n            }\n        }\n        return Promise.resolve(matches);\n    }\n}\n/**\n * We choose opt out as most node types should be searched (e.g. script).\n * Even nodes like <data>, could have textContent we care about.\n *\n * Note:\n * We will be checking each node's nodeName attribute in the Node interface.\n * ref: https://dom.spec.whatwg.org/#dom-node-nodename\n *\n * Specifically for Element nodes, where nodeName is stated as the\n * 'HTML-uppercased qualified name'. However, that does not mean that HTML\n * elements qualified name is guaranteed to be uppercased even when the\n * content type is HTML, i.e. XML tags like <svg>. This only applies when the\n * node's namespace is in HTML and the node document is a HTML document.\n * ref: https://dom.spec.whatwg.org/#element-html-uppercased-qualified-name\n */\nHTMLSearchEngine.UNSUPPORTED_ELEMENTS = {\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Document_metadata\n    BASE: true,\n    HEAD: true,\n    LINK: true,\n    META: true,\n    STYLE: true,\n    TITLE: true,\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Sectioning_root\n    BODY: true,\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Content_sectioning\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Text_content\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Inline_text_semantics\n    // Above is searched\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Image_and_multimedia\n    AREA: true,\n    AUDIO: true,\n    IMG: true,\n    MAP: true,\n    TRACK: true,\n    VIDEO: true,\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Embedded_content\n    APPLET: true,\n    EMBED: true,\n    IFRAME: true,\n    NOEMBED: true,\n    OBJECT: true,\n    PARAM: true,\n    PICTURE: true,\n    SOURCE: true,\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Scripting\n    CANVAS: true,\n    NOSCRIPT: true,\n    SCRIPT: true,\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Demarcating_edits\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Table_content\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Forms\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Interactive_elements\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Web_Components\n    // Above is searched\n    /*\n     * While XML tags local name is case sensitive, XHTML tags need to be\n     * lowercased.\n     * ref: https://www.w3.org/TR/xhtml1/#h-4.2\n     *\n     * Which in practice means I've seen SVG tags local name to be lowercased.\n     * I don't believe enumerating all possible cases would be useful as such,\n     * and similarly transforming the nodeName to uppercase would seem like\n     * unnecessary overhead.\n     */\n    svg: true,\n    SVG: true\n};\n/**\n * Generic DOM tree search provider.\n */\nclass GenericSearchProvider extends _searchprovider__WEBPACK_IMPORTED_MODULE_1__.SearchProvider {\n    constructor() {\n        super(...arguments);\n        /**\n         * Set to true if the widget under search is read-only, false\n         * if it is editable.  Will be used to determine whether to show\n         * the replace option.\n         */\n        this.isReadOnly = true;\n        this._matches = [];\n        this._mutationObserver = new MutationObserver(this._onWidgetChanged.bind(this));\n        this._markNodes = new Array();\n    }\n    /**\n     * Report whether or not this provider has the ability to search on the given object\n     */\n    static isApplicable(domain) {\n        return domain instanceof _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget;\n    }\n    /**\n     * Instantiate a generic search provider for the widget.\n     *\n     * #### Notes\n     * The widget provided is always checked using `isApplicable` before calling\n     * this factory.\n     *\n     * @param widget The widget to search on\n     * @param registry The search provider registry\n     * @param translator [optional] The translator object\n     *\n     * @returns The search provider on the widget\n     */\n    static createNew(widget, registry, translator) {\n        return new GenericSearchProvider(widget);\n    }\n    /**\n     * The current index of the selected match.\n     */\n    get currentMatchIndex() {\n        return this._currentMatchIndex >= 0 ? this._currentMatchIndex : null;\n    }\n    /**\n     * The current match\n     */\n    get currentMatch() {\n        var _a;\n        return (_a = this._matches[this._currentMatchIndex]) !== null && _a !== void 0 ? _a : null;\n    }\n    /**\n     * The current matches\n     */\n    get matches() {\n        // Ensure that no other fn can overwrite matches index property\n        // We shallow clone each node\n        return this._matches\n            ? this._matches.map(m => Object.assign({}, m))\n            : this._matches;\n    }\n    /**\n     * The number of matches.\n     */\n    get matchesCount() {\n        return this._matches.length;\n    }\n    /**\n     * Clear currently highlighted match.\n     */\n    clearHighlight() {\n        if (this._currentMatchIndex >= 0) {\n            const hit = this._markNodes[this._currentMatchIndex];\n            hit.classList.remove(...SELECTED_CLASSES);\n        }\n        this._currentMatchIndex = -1;\n        return Promise.resolve();\n    }\n    /**\n     * Dispose of the resources held by the search provider.\n     *\n     * #### Notes\n     * If the object's `dispose` method is called more than once, all\n     * calls made after the first will be a no-op.\n     *\n     * #### Undefined Behavior\n     * It is undefined behavior to use any functionality of the object\n     * after it has been disposed unless otherwise explicitly noted.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this.endQuery().catch(reason => {\n            console.error(`Failed to end search query.`, reason);\n        });\n        super.dispose();\n    }\n    /**\n     * Move the current match indicator to the next match.\n     *\n     * @param loop Whether to loop within the matches list.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async highlightNext(loop) {\n        var _a;\n        return (_a = this._highlightNext(false, loop !== null && loop !== void 0 ? loop : true)) !== null && _a !== void 0 ? _a : undefined;\n    }\n    /**\n     * Move the current match indicator to the previous match.\n     *\n     * @param loop Whether to loop within the matches list.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async highlightPrevious(loop) {\n        var _a;\n        return (_a = this._highlightNext(true, loop !== null && loop !== void 0 ? loop : true)) !== null && _a !== void 0 ? _a : undefined;\n    }\n    /**\n     * Replace the currently selected match with the provided text\n     *\n     * @param newText The replacement text\n     * @param loop Whether to loop within the matches list.\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceCurrentMatch(newText, loop) {\n        return Promise.resolve(false);\n    }\n    /**\n     * Replace all matches in the notebook with the provided text\n     *\n     * @param newText The replacement text\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceAllMatches(newText) {\n        // This is read only, but we could loosen this in theory for input boxes...\n        return Promise.resolve(false);\n    }\n    /**\n     * Initialize the search using the provided options.  Should update the UI\n     * to highlight all matches and \"select\" whatever the first match should be.\n     *\n     * @param query A RegExp to be use to perform the search\n     * @param filters Filter parameters to pass to provider\n     */\n    async startQuery(query, filters = {}) {\n        await this.endQuery();\n        this._query = query;\n        if (query === null) {\n            return Promise.resolve();\n        }\n        const matches = await HTMLSearchEngine.search(query, this.widget.node);\n        // Transform the DOM\n        let nodeIdx = 0;\n        while (nodeIdx < matches.length) {\n            let activeNode = matches[nodeIdx].node;\n            let parent = activeNode.parentNode;\n            let subMatches = [matches[nodeIdx]];\n            while (++nodeIdx < matches.length &&\n                matches[nodeIdx].node === activeNode) {\n                subMatches.unshift(matches[nodeIdx]);\n            }\n            const markedNodes = subMatches.map(match => {\n                // TODO: support tspan for svg when svg support is added\n                const markedNode = document.createElement('mark');\n                markedNode.classList.add(...FOUND_CLASSES);\n                markedNode.textContent = match.text;\n                const newNode = activeNode.splitText(match.position);\n                newNode.textContent = newNode.textContent.slice(match.text.length);\n                parent.insertBefore(markedNode, newNode);\n                return markedNode;\n            });\n            // Insert node in reverse order as we replace from last to first\n            // to maintain match position.\n            for (let i = markedNodes.length - 1; i >= 0; i--) {\n                this._markNodes.push(markedNodes[i]);\n            }\n        }\n        // Watch for future changes:\n        this._mutationObserver.observe(this.widget.node, \n        // https://developer.mozilla.org/en-US/docs/Web/API/MutationObserverInit\n        {\n            attributes: false,\n            characterData: true,\n            childList: true,\n            subtree: true\n        });\n        this._matches = matches;\n    }\n    /**\n     * Clear the highlighted matches and any internal state.\n     */\n    async endQuery() {\n        this._mutationObserver.disconnect();\n        this._markNodes.forEach(el => {\n            const parent = el.parentNode;\n            parent.replaceChild(document.createTextNode(el.textContent), el);\n            parent.normalize();\n        });\n        this._markNodes = [];\n        this._matches = [];\n        this._currentMatchIndex = -1;\n    }\n    _highlightNext(reverse, loop) {\n        if (this._matches.length === 0) {\n            return null;\n        }\n        if (this._currentMatchIndex === -1) {\n            this._currentMatchIndex = reverse ? this.matches.length - 1 : 0;\n        }\n        else {\n            const hit = this._markNodes[this._currentMatchIndex];\n            hit.classList.remove(...SELECTED_CLASSES);\n            this._currentMatchIndex = reverse\n                ? this._currentMatchIndex - 1\n                : this._currentMatchIndex + 1;\n            if (loop &&\n                (this._currentMatchIndex < 0 ||\n                    this._currentMatchIndex >= this._matches.length)) {\n                // Cheap way to make this a circular buffer\n                this._currentMatchIndex =\n                    (this._currentMatchIndex + this._matches.length) %\n                        this._matches.length;\n            }\n        }\n        if (this._currentMatchIndex >= 0 &&\n            this._currentMatchIndex < this._matches.length) {\n            const hit = this._markNodes[this._currentMatchIndex];\n            hit.classList.add(...SELECTED_CLASSES);\n            // If not in view, scroll just enough to see it\n            if (!elementInViewport(hit)) {\n                hit.scrollIntoView(reverse);\n            }\n            hit.focus();\n            return this._matches[this._currentMatchIndex];\n        }\n        else {\n            this._currentMatchIndex = -1;\n            return null;\n        }\n    }\n    async _onWidgetChanged(mutations, observer) {\n        this._currentMatchIndex = -1;\n        // This is typically cheap, but we do not control the rate of change or size of the output\n        await this.startQuery(this._query);\n        this._stateChanged.emit();\n    }\n}\nfunction elementInViewport(el) {\n    const boundingClientRect = el.getBoundingClientRect();\n    return (boundingClientRect.top >= 0 &&\n        boundingClientRect.bottom <=\n            (window.innerHeight || document.documentElement.clientHeight) &&\n        boundingClientRect.left >= 0 &&\n        boundingClientRect.right <=\n            (window.innerWidth || document.documentElement.clientWidth));\n}\n//# sourceMappingURL=genericsearchprovider.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/providers/genericsearchprovider.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/documentsearch/lib/providers/textprovider.js":
/*!********************************************************************************!*\
  !*** ../node_modules/@jupyterlab/documentsearch/lib/providers/textprovider.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextSearchEngine: () => (/* binding */ TextSearchEngine)\n/* harmony export */ });\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * Search provider for text/plain\n */\nconst TextSearchEngine = {\n    /**\n     * Search for regular expression matches in a string.\n     *\n     * @param query Query regular expression\n     * @param data String to look into\n     * @returns List of matches\n     */\n    search(query, data) {\n        // If data is not a string, try to JSON serialize the data.\n        if (typeof data !== 'string') {\n            try {\n                data = JSON.stringify(data);\n            }\n            catch (reason) {\n                console.warn('Unable to search with TextSearchEngine non-JSON serializable object.', reason, data);\n                return Promise.resolve([]);\n            }\n        }\n        if (!query.global) {\n            query = new RegExp(query.source, query.flags + 'g');\n        }\n        const matches = new Array();\n        let match = null;\n        while ((match = query.exec(data)) !== null) {\n            matches.push({\n                text: match[0],\n                position: match.index\n            });\n        }\n        return Promise.resolve(matches);\n    }\n};\n//# sourceMappingURL=textprovider.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/providers/textprovider.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/documentsearch/lib/searchmodel.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@jupyterlab/documentsearch/lib/searchmodel.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SearchDocumentModel: () => (/* binding */ SearchDocumentModel)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/ui-components */ \"webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components\");\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lumino_polling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/polling */ \"webpack/sharing/consume/default/@lumino/polling/@lumino/polling\");\n/* harmony import */ var _lumino_polling__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_polling__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/signaling */ \"webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling\");\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_2__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\n\n\n/**\n * Search in a document model.\n */\nclass SearchDocumentModel extends _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__.VDomModel {\n    /**\n     * Search document model\n     * @param searchProvider Provider for the current document\n     * @param searchDebounceTime Debounce search time\n     */\n    constructor(searchProvider, searchDebounceTime) {\n        super();\n        this.searchProvider = searchProvider;\n        this._caseSensitive = false;\n        this._disposed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__.Signal(this);\n        this._parsingError = '';\n        this._preserveCase = false;\n        this._initialQuery = '';\n        this._filters = {};\n        this._replaceText = '';\n        this._searchActive = false;\n        this._searchExpression = '';\n        this._useRegex = false;\n        this._wholeWords = false;\n        this._filters = {};\n        if (this.searchProvider.getFilters) {\n            const filters = this.searchProvider.getFilters();\n            for (const filter in filters) {\n                this._filters[filter] = filters[filter].default;\n            }\n        }\n        searchProvider.stateChanged.connect(this._onProviderStateChanged, this);\n        this._searchDebouncer = new _lumino_polling__WEBPACK_IMPORTED_MODULE_1__.Debouncer(() => {\n            this._updateSearch().catch(reason => {\n                console.error('Failed to update search on document.', reason);\n            });\n        }, searchDebounceTime);\n    }\n    /**\n     * Whether the search is case sensitive or not.\n     */\n    get caseSensitive() {\n        return this._caseSensitive;\n    }\n    set caseSensitive(v) {\n        if (this._caseSensitive !== v) {\n            this._caseSensitive = v;\n            this.stateChanged.emit();\n            this.refresh();\n        }\n    }\n    /**\n     * Current highlighted match index.\n     */\n    get currentIndex() {\n        return this.searchProvider.currentMatchIndex;\n    }\n    /**\n     * A signal emitted when the object is disposed.\n     */\n    get disposed() {\n        return this._disposed;\n    }\n    /**\n     * Filter values.\n     */\n    get filters() {\n        return this._filters;\n    }\n    /**\n     * Filter definitions for the current provider.\n     */\n    get filtersDefinition() {\n        var _a, _b, _c;\n        return (_c = (_b = (_a = this.searchProvider).getFilters) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : {};\n    }\n    /**\n     * Filter definitions changed.\n     */\n    get filtersDefinitionChanged() {\n        return this.searchProvider.filtersChanged || null;\n    }\n    /**\n     * The initial query string.\n     */\n    get initialQuery() {\n        return this._initialQuery;\n    }\n    set initialQuery(v) {\n        // The value comes from user selection (set by search provider).\n        this._initialQuery = v;\n    }\n    /**\n     * Initial query as suggested by provider.\n     *\n     * A common choice is the text currently selected by the user.\n     */\n    get suggestedInitialQuery() {\n        return this.searchProvider.getInitialQuery();\n    }\n    /**\n     * Whether the selection includes a single item or multiple items;\n     * this is used by the heuristic auto-enabling \"search in selection\" mode.\n     *\n     * Returns `undefined` if the provider does not expose this information.\n     */\n    get selectionState() {\n        return this.searchProvider.getSelectionState\n            ? this.searchProvider.getSelectionState()\n            : undefined;\n    }\n    /**\n     * Whether the document is read-only or not.\n     */\n    get isReadOnly() {\n        return this.searchProvider.isReadOnly;\n    }\n    /**\n     * Replace options support.\n     */\n    get replaceOptionsSupport() {\n        return this.searchProvider.replaceOptionsSupport;\n    }\n    /**\n     * Parsing regular expression error message.\n     */\n    get parsingError() {\n        return this._parsingError;\n    }\n    /**\n     * Whether to preserve case when replacing.\n     */\n    get preserveCase() {\n        return this._preserveCase;\n    }\n    set preserveCase(v) {\n        if (this._preserveCase !== v) {\n            this._preserveCase = v;\n            this.stateChanged.emit();\n            this.refresh();\n        }\n    }\n    /**\n     * Replacement expression\n     */\n    get replaceText() {\n        return this._replaceText;\n    }\n    set replaceText(v) {\n        if (this._replaceText !== v) {\n            this._replaceText = v;\n            this.stateChanged.emit();\n        }\n    }\n    /**\n     * Search expression\n     */\n    get searchExpression() {\n        return this._searchExpression;\n    }\n    set searchExpression(v) {\n        if (this._searchExpression !== v) {\n            this._searchExpression = v;\n            this.stateChanged.emit();\n            this.refresh();\n        }\n    }\n    /**\n     * Total number of matches.\n     */\n    get totalMatches() {\n        return this.searchProvider.matchesCount;\n    }\n    /**\n     * Whether to use regular expression or not.\n     */\n    get useRegex() {\n        return this._useRegex;\n    }\n    set useRegex(v) {\n        if (this._useRegex !== v) {\n            this._useRegex = v;\n            this.stateChanged.emit();\n            this.refresh();\n        }\n    }\n    /**\n     * Whether to match whole words or not.\n     */\n    get wholeWords() {\n        return this._wholeWords;\n    }\n    set wholeWords(v) {\n        if (this._wholeWords !== v) {\n            this._wholeWords = v;\n            this.stateChanged.emit();\n            this.refresh();\n        }\n    }\n    /**\n     * Dispose the model.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        if (this._searchExpression) {\n            this.endQuery().catch(reason => {\n                console.error(`Failed to end query '${this._searchExpression}.`, reason);\n            });\n        }\n        this.searchProvider.stateChanged.disconnect(this._onProviderStateChanged, this);\n        this._searchDebouncer.dispose();\n        super.dispose();\n    }\n    /**\n     * End the query.\n     */\n    async endQuery() {\n        this._searchActive = false;\n        await this.searchProvider.endQuery();\n        this.stateChanged.emit();\n    }\n    /**\n     * Highlight the next match.\n     */\n    async highlightNext() {\n        await this.searchProvider.highlightNext();\n        // Emit state change as the index needs to be updated\n        this.stateChanged.emit();\n    }\n    /**\n     * Highlight the previous match\n     */\n    async highlightPrevious() {\n        await this.searchProvider.highlightPrevious();\n        // Emit state change as the index needs to be updated\n        this.stateChanged.emit();\n    }\n    /**\n     * Refresh search\n     */\n    refresh() {\n        this._searchDebouncer.invoke().catch(reason => {\n            console.error('Failed to invoke search document debouncer.', reason);\n        });\n    }\n    /**\n     * Replace all matches.\n     */\n    async replaceAllMatches() {\n        await this.searchProvider.replaceAllMatches(this._replaceText, {\n            preserveCase: this.preserveCase,\n            regularExpression: this.useRegex\n        });\n        // Emit state change as the index needs to be updated\n        this.stateChanged.emit();\n    }\n    /**\n     * Replace the current match.\n     */\n    async replaceCurrentMatch() {\n        await this.searchProvider.replaceCurrentMatch(this._replaceText, true, {\n            preserveCase: this.preserveCase,\n            regularExpression: this.useRegex\n        });\n        // Emit state change as the index needs to be updated\n        this.stateChanged.emit();\n    }\n    /**\n     * Set the value of a given filter.\n     *\n     * @param name Filter name\n     * @param v Filter value\n     */\n    async setFilter(name, v) {\n        if (this._filters[name] !== v) {\n            if (this.searchProvider.validateFilter) {\n                this._filters[name] = await this.searchProvider.validateFilter(name, v);\n                // If the value was changed\n                if (this._filters[name] === v) {\n                    this.stateChanged.emit();\n                    this.refresh();\n                }\n            }\n            else {\n                this._filters[name] = v;\n                this.stateChanged.emit();\n                this.refresh();\n            }\n        }\n    }\n    async _updateSearch() {\n        if (this._parsingError) {\n            this._parsingError = '';\n            this.stateChanged.emit();\n        }\n        try {\n            const query = this.searchExpression\n                ? Private.parseQuery(this.searchExpression, this.caseSensitive, this.useRegex, this.wholeWords)\n                : null;\n            if (query) {\n                this._searchActive = true;\n                await this.searchProvider.startQuery(query, this._filters);\n            }\n            else {\n                this._searchActive = false;\n                await this.searchProvider.endQuery();\n            }\n            // Emit state change as the index needs to be updated\n            this.stateChanged.emit();\n        }\n        catch (reason) {\n            this._parsingError = reason.toString();\n            this.stateChanged.emit();\n            console.error(`Failed to parse expression ${this.searchExpression}`, reason);\n        }\n    }\n    _onProviderStateChanged() {\n        if (this._searchActive) {\n            this.refresh();\n        }\n    }\n}\nvar Private;\n(function (Private) {\n    /**\n     * Build the regular expression to use for searching.\n     *\n     * @param queryString Query string\n     * @param caseSensitive Whether the search is case sensitive or not\n     * @param regex Whether the expression is a regular expression\n     * @returns The regular expression to use\n     */\n    function parseQuery(queryString, caseSensitive, regex, wholeWords) {\n        const flag = caseSensitive ? 'gm' : 'gim';\n        // escape regex characters in query if its a string search\n        let queryText = regex\n            ? queryString\n            : queryString.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, '\\\\$&');\n        if (wholeWords) {\n            queryText = '\\\\b' + queryText + '\\\\b';\n        }\n        const ret = new RegExp(queryText, flag);\n        // If the empty string is hit, the search logic will freeze the browser tab\n        //  Trying /^/ or /$/ on the codemirror search demo, does not find anything.\n        //  So this is a limitation of the editor.\n        if (ret.test('')) {\n            return null;\n        }\n        return ret;\n    }\n    Private.parseQuery = parseQuery;\n})(Private || (Private = {}));\n//# sourceMappingURL=searchmodel.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/searchmodel.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/documentsearch/lib/searchprovider.js":
/*!************************************************************************!*\
  !*** ../node_modules/@jupyterlab/documentsearch/lib/searchprovider.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SearchProvider: () => (/* binding */ SearchProvider)\n/* harmony export */ });\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/signaling */ \"webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling\");\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_0__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\n/**\n * Abstract class implementing the search provider interface.\n */\nclass SearchProvider {\n    /**\n     * Constructor\n     *\n     * @param widget The widget to search in\n     */\n    constructor(widget) {\n        this.widget = widget;\n        this._stateChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);\n        this._filtersChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);\n        this._disposed = false;\n    }\n    /**\n     * Signal indicating that something in the search has changed, so the UI should update\n     */\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    /**\n     * Signal indicating that filter definition changed.\n     */\n    get filtersChanged() {\n        return this._filtersChanged;\n    }\n    /**\n     * The current index of the selected match.\n     */\n    get currentMatchIndex() {\n        return null;\n    }\n    /**\n     * Whether the search provider is disposed or not.\n     */\n    get isDisposed() {\n        return this._disposed;\n    }\n    /**\n     * The number of matches.\n     */\n    get matchesCount() {\n        return null;\n    }\n    /**\n     * Dispose of the resources held by the search provider.\n     *\n     * #### Notes\n     * If the object's `dispose` method is called more than once, all\n     * calls made after the first will be a no-op.\n     *\n     * #### Undefined Behavior\n     * It is undefined behavior to use any functionality of the object\n     * after it has been disposed unless otherwise explicitly noted.\n     */\n    dispose() {\n        if (this._disposed) {\n            return;\n        }\n        this._disposed = true;\n        _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal.clearData(this);\n    }\n    /**\n     * Get an initial query value if applicable so that it can be entered\n     * into the search box as an initial query\n     *\n     * @returns Initial value used to populate the search box.\n     */\n    getInitialQuery() {\n        return '';\n    }\n    /**\n     * Get the filters for the given provider.\n     *\n     * @returns The filters.\n     *\n     * ### Notes\n     * TODO For now it only supports boolean filters (represented with checkboxes)\n     */\n    getFilters() {\n        return {};\n    }\n    /**\n     * Utility for copying the letter case from old to new text.\n     */\n    static preserveCase(oldText, newText) {\n        if (oldText.toUpperCase() === oldText) {\n            return newText.toUpperCase();\n        }\n        if (oldText.toLowerCase() === oldText) {\n            return newText.toLowerCase();\n        }\n        if (toSentenceCase(oldText) === oldText) {\n            return toSentenceCase(newText);\n        }\n        return newText;\n    }\n}\n/**\n * Capitalise first letter of provided word.\n */\nfunction toSentenceCase([first = '', ...suffix]) {\n    return first.toUpperCase() + '' + suffix.join('').toLowerCase();\n}\n//# sourceMappingURL=searchprovider.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/searchprovider.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/documentsearch/lib/searchproviderregistry.js":
/*!********************************************************************************!*\
  !*** ../node_modules/@jupyterlab/documentsearch/lib/searchproviderregistry.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SearchProviderRegistry: () => (/* binding */ SearchProviderRegistry)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/translation */ \"webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation\");\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lumino_disposable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/disposable */ \"webpack/sharing/consume/default/@lumino/disposable/@lumino/disposable\");\n/* harmony import */ var _lumino_disposable__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_disposable__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/signaling */ \"webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling\");\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_2__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\n\n\n/**\n * Search provider registry\n */\nclass SearchProviderRegistry {\n    /**\n     * Constructor\n     *\n     * @param translator Application translator object\n     */\n    constructor(translator = _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__.nullTranslator) {\n        this.translator = translator;\n        this._changed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__.Signal(this);\n        this._providerMap = new Map();\n    }\n    /**\n     * Add a provider to the registry.\n     *\n     * @param key - The provider key.\n     * @returns A disposable delegate that, when disposed, deregisters the given search provider\n     */\n    add(key, provider) {\n        this._providerMap.set(key, provider);\n        this._changed.emit();\n        return new _lumino_disposable__WEBPACK_IMPORTED_MODULE_1__.DisposableDelegate(() => {\n            this._providerMap.delete(key);\n            this._changed.emit();\n        });\n    }\n    /**\n     * Returns a matching provider for the widget.\n     *\n     * @param widget - The widget to search over.\n     * @returns the search provider, or undefined if none exists.\n     */\n    getProvider(widget) {\n        // iterate through all providers and ask each one if it can search on the\n        // widget.\n        for (const P of this._providerMap.values()) {\n            if (P.isApplicable(widget)) {\n                return P.createNew(widget, this.translator);\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Whether the registry as a matching provider for the widget.\n     *\n     * @param widget - The widget to search over.\n     * @returns Provider existence\n     */\n    hasProvider(widget) {\n        for (const P of this._providerMap.values()) {\n            if (P.isApplicable(widget)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Signal that emits when a new search provider has been registered\n     * or removed.\n     */\n    get changed() {\n        return this._changed;\n    }\n}\n//# sourceMappingURL=searchproviderregistry.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/searchproviderregistry.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/documentsearch/lib/searchview.js":
/*!********************************************************************!*\
  !*** ../node_modules/@jupyterlab/documentsearch/lib/searchview.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SearchDocumentView: () => (/* binding */ SearchDocumentView)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/translation */ \"webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation\");\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/ui-components */ \"webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components\");\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/signaling */ \"webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling\");\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _lumino_commands__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lumino/commands */ \"webpack/sharing/consume/default/@lumino/commands/@lumino/commands\");\n/* harmony import */ var _lumino_commands__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lumino_commands__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jupyterlab/apputils */ \"webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils\");\n/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\n\n\n\n\n\n\nconst OVERLAY_CLASS = 'jp-DocumentSearch-overlay';\nconst OVERLAY_ROW_CLASS = 'jp-DocumentSearch-overlay-row';\nconst INPUT_CLASS = 'jp-DocumentSearch-input';\nconst INPUT_LABEL_CLASS = 'jp-DocumentSearch-input-label';\nconst INPUT_WRAPPER_CLASS = 'jp-DocumentSearch-input-wrapper';\nconst INPUT_BUTTON_CLASS_OFF = 'jp-DocumentSearch-input-button-off';\nconst INPUT_BUTTON_CLASS_ON = 'jp-DocumentSearch-input-button-on';\nconst INDEX_COUNTER_CLASS = 'jp-DocumentSearch-index-counter';\nconst UP_DOWN_BUTTON_WRAPPER_CLASS = 'jp-DocumentSearch-up-down-wrapper';\nconst UP_DOWN_BUTTON_CLASS = 'jp-DocumentSearch-up-down-button';\nconst FILTER_BUTTON_CLASS = 'jp-DocumentSearch-filter-button';\nconst FILTER_BUTTON_ENABLED_CLASS = 'jp-DocumentSearch-filter-button-enabled';\nconst REGEX_ERROR_CLASS = 'jp-DocumentSearch-regex-error';\nconst SEARCH_OPTIONS_CLASS = 'jp-DocumentSearch-search-options';\nconst SEARCH_FILTER_DISABLED_CLASS = 'jp-DocumentSearch-search-filter-disabled';\nconst SEARCH_FILTER_CLASS = 'jp-DocumentSearch-search-filter';\nconst REPLACE_BUTTON_CLASS = 'jp-DocumentSearch-replace-button';\nconst REPLACE_BUTTON_WRAPPER_CLASS = 'jp-DocumentSearch-replace-button-wrapper';\nconst REPLACE_WRAPPER_CLASS = 'jp-DocumentSearch-replace-wrapper-class';\nconst REPLACE_TOGGLE_CLASS = 'jp-DocumentSearch-replace-toggle';\nconst TOGGLE_WRAPPER = 'jp-DocumentSearch-toggle-wrapper';\nconst TOGGLE_PLACEHOLDER = 'jp-DocumentSearch-toggle-placeholder';\nconst BUTTON_CONTENT_CLASS = 'jp-DocumentSearch-button-content';\nconst BUTTON_WRAPPER_CLASS = 'jp-DocumentSearch-button-wrapper';\nconst SPACER_CLASS = 'jp-DocumentSearch-spacer';\nfunction SearchInput(props) {\n    const [rows, setRows] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)(1);\n    const updateDimensions = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)((event) => {\n        var _a;\n        const element = event\n            ? event.target\n            : (_a = props.inputRef) === null || _a === void 0 ? void 0 : _a.current;\n        if (element) {\n            const split = element.value.split(/\\n/);\n            // use the longest string out of all lines to compute the width.\n            let longest = split.reduce((a, b) => (a.length > b.length ? a : b), '');\n            if (element.parentNode && element.parentNode instanceof HTMLElement) {\n                element.parentNode.dataset.value = longest;\n            }\n            setRows(split.length);\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_5__.useEffect)(() => {\n        var _a, _b;\n        // For large part, `focusSearchInput()` is responsible for focusing and\n        // selecting the search input, however when `initialValue` changes, this\n        // triggers React re-render to update `defaultValue` (implemented via `key`)\n        // which means that `focusSearchInput` is no longer effective as it has\n        // already fired before the re-render, hence we use this conditional effect.\n        (_b = (_a = props.inputRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.select();\n        // After any change to initial value we also want to update rows in case if\n        // multi-line text was selected.\n        updateDimensions();\n    }, [props.initialValue]);\n    return (react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"label\", { className: INPUT_LABEL_CLASS },\n        react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"textarea\", { onChange: e => {\n                props.onChange(e);\n                updateDimensions(e);\n            }, onKeyDown: e => {\n                props.onKeyDown(e);\n                updateDimensions(e);\n            }, rows: rows, placeholder: props.placeholder, className: INPUT_CLASS, \n            // Setting a key ensures that `defaultValue` will become updated\n            // when the initial value changes.\n            key: props.autoUpdate ? props.initialValue : null, tabIndex: 0, ref: props.inputRef, title: props.title, defaultValue: props.initialValue || props.lastSearchText, autoFocus: props.autoFocus })));\n}\nfunction SearchEntry(props) {\n    var _a;\n    const trans = ((_a = props.translator) !== null && _a !== void 0 ? _a : _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__.nullTranslator).load('jupyterlab');\n    const caseButtonToggleClass = (0,_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__.classes)(props.caseSensitive ? INPUT_BUTTON_CLASS_ON : INPUT_BUTTON_CLASS_OFF, BUTTON_CONTENT_CLASS);\n    const regexButtonToggleClass = (0,_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__.classes)(props.useRegex ? INPUT_BUTTON_CLASS_ON : INPUT_BUTTON_CLASS_OFF, BUTTON_CONTENT_CLASS);\n    const wordButtonToggleClass = (0,_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__.classes)(props.wholeWords ? INPUT_BUTTON_CLASS_ON : INPUT_BUTTON_CLASS_OFF, BUTTON_CONTENT_CLASS);\n    const wrapperClass = INPUT_WRAPPER_CLASS;\n    return (react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"div\", { className: wrapperClass },\n        react__WEBPACK_IMPORTED_MODULE_5__.createElement(SearchInput, { placeholder: trans.__('Find'), onChange: e => props.onChange(e), onKeyDown: e => props.onKeydown(e), inputRef: props.inputRef, initialValue: props.initialSearchText, lastSearchText: props.lastSearchText, title: trans.__('Find'), autoFocus: true, autoUpdate: true }),\n        react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => {\n                props.onCaseSensitiveToggled();\n            }, tabIndex: 0, title: trans.__('Match Case') },\n            react__WEBPACK_IMPORTED_MODULE_5__.createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__.caseSensitiveIcon.react, { className: caseButtonToggleClass, tag: \"span\" })),\n        react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => props.onWordToggled(), tabIndex: 0, title: trans.__('Match Whole Word') },\n            react__WEBPACK_IMPORTED_MODULE_5__.createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__.wordIcon.react, { className: wordButtonToggleClass, tag: \"span\" })),\n        react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => props.onRegexToggled(), tabIndex: 0, title: trans.__('Use Regular Expression') },\n            react__WEBPACK_IMPORTED_MODULE_5__.createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__.regexIcon.react, { className: regexButtonToggleClass, tag: \"span\" }))));\n}\nfunction ReplaceEntry(props) {\n    var _a, _b, _c;\n    const trans = ((_a = props.translator) !== null && _a !== void 0 ? _a : _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__.nullTranslator).load('jupyterlab');\n    const preserveCaseButtonToggleClass = (0,_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__.classes)(props.preserveCase ? INPUT_BUTTON_CLASS_ON : INPUT_BUTTON_CLASS_OFF, BUTTON_CONTENT_CLASS);\n    return (react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"div\", { className: REPLACE_WRAPPER_CLASS },\n        react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"div\", { className: INPUT_WRAPPER_CLASS },\n            react__WEBPACK_IMPORTED_MODULE_5__.createElement(SearchInput, { placeholder: trans.__('Replace'), initialValue: (_b = props.replaceText) !== null && _b !== void 0 ? _b : '', onKeyDown: e => props.onReplaceKeydown(e), onChange: e => props.onChange(e), title: trans.__('Replace'), autoFocus: false, autoUpdate: false }),\n            ((_c = props.replaceOptionsSupport) === null || _c === void 0 ? void 0 : _c.preserveCase) ? (react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => props.onPreserveCaseToggled(), tabIndex: 0, title: trans.__('Preserve Case') },\n                react__WEBPACK_IMPORTED_MODULE_5__.createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__.caseSensitiveIcon.react, { className: preserveCaseButtonToggleClass, tag: \"span\" }))) : null),\n        react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"button\", { className: REPLACE_BUTTON_WRAPPER_CLASS, onClick: () => props.onReplaceCurrent(), tabIndex: 0 },\n            react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"span\", { className: `${REPLACE_BUTTON_CLASS} ${BUTTON_CONTENT_CLASS}`, tabIndex: 0 }, trans.__('Replace'))),\n        react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"button\", { className: REPLACE_BUTTON_WRAPPER_CLASS, tabIndex: 0, onClick: () => props.onReplaceAll() },\n            react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"span\", { className: `${REPLACE_BUTTON_CLASS} ${BUTTON_CONTENT_CLASS}`, tabIndex: -1 }, trans.__('Replace All')))));\n}\nfunction UpDownButtons(props) {\n    var _a, _b;\n    const nextBinding = (_a = props.keyBindings) === null || _a === void 0 ? void 0 : _a.next;\n    const prevBinding = (_b = props.keyBindings) === null || _b === void 0 ? void 0 : _b.previous;\n    const nextKeys = nextBinding\n        ? _lumino_commands__WEBPACK_IMPORTED_MODULE_3__.CommandRegistry.formatKeystroke(nextBinding.keys)\n        : '';\n    const prevKeys = prevBinding\n        ? _lumino_commands__WEBPACK_IMPORTED_MODULE_3__.CommandRegistry.formatKeystroke(prevBinding.keys)\n        : '';\n    const prevShortcut = prevKeys ? ` (${prevKeys})` : '';\n    const nextShortcut = nextKeys ? ` (${nextKeys})` : '';\n    const upButton = (react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => (props.isEnabled ? props.onHighlightPrevious() : false), tabIndex: 0, title: `${props.trans.__('Previous Match')}${prevShortcut}`, disabled: !props.isEnabled },\n        react__WEBPACK_IMPORTED_MODULE_5__.createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__.caretUpEmptyThinIcon.react, { className: (0,_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__.classes)(UP_DOWN_BUTTON_CLASS, BUTTON_CONTENT_CLASS), tag: \"span\" })));\n    const downButton = (react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => (props.isEnabled ? props.onHighlightNext() : false), tabIndex: 0, title: `${props.trans.__('Next Match')}${nextShortcut}`, disabled: !props.isEnabled },\n        react__WEBPACK_IMPORTED_MODULE_5__.createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__.caretDownEmptyThinIcon.react, { className: (0,_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__.classes)(UP_DOWN_BUTTON_CLASS, BUTTON_CONTENT_CLASS), tag: \"span\" })));\n    return (react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"div\", { className: UP_DOWN_BUTTON_WRAPPER_CLASS },\n        upButton,\n        downButton));\n}\nfunction SearchIndices(props) {\n    return (react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"div\", { className: INDEX_COUNTER_CLASS }, props.totalMatches === 0\n        ? '-/-'\n        : `${props.currentIndex === null ? '-' : props.currentIndex + 1}/${props.totalMatches}`));\n}\nfunction FilterToggle(props) {\n    let className = `${FILTER_BUTTON_CLASS} ${BUTTON_CONTENT_CLASS}`;\n    if (props.visible) {\n        className = `${className} ${FILTER_BUTTON_ENABLED_CLASS}`;\n    }\n    const icon = props.anyEnabled ? _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__.filterDotIcon : _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__.filterIcon;\n    return (react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => props.toggleVisible(), tabIndex: 0, title: props.visible\n            ? props.trans.__('Hide Search Filters')\n            : props.trans.__('Show Search Filters') },\n        react__WEBPACK_IMPORTED_MODULE_5__.createElement(icon.react, { className: className, tag: \"span\", height: \"20px\", width: \"20px\" })));\n}\nfunction FilterSelection(props) {\n    return (react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"label\", { className: props.isEnabled\n            ? SEARCH_FILTER_CLASS\n            : `${SEARCH_FILTER_CLASS} ${SEARCH_FILTER_DISABLED_CLASS}`, title: props.description },\n        react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"input\", { type: \"checkbox\", className: \"jp-mod-styled\", disabled: !props.isEnabled, checked: props.value, onChange: props.onToggle }),\n        props.title));\n}\nclass SearchOverlay extends react__WEBPACK_IMPORTED_MODULE_5__.Component {\n    constructor(props) {\n        super(props);\n        this.translator = props.translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__.nullTranslator;\n    }\n    _onSearchChange(event) {\n        const searchText = event.target.value;\n        this.props.onSearchChanged(searchText);\n    }\n    _onSearchKeydown(event) {\n        if (event.keyCode === 13) {\n            // Enter pressed\n            event.stopPropagation();\n            event.preventDefault();\n            if (event.ctrlKey) {\n                const textarea = event.target;\n                this._insertNewLine(textarea);\n                this.props.onSearchChanged(textarea.value);\n            }\n            else {\n                event.shiftKey\n                    ? this.props.onHighlightPrevious()\n                    : this.props.onHighlightNext();\n            }\n        }\n    }\n    _onReplaceKeydown(event) {\n        if (event.keyCode === 13) {\n            // Enter pressed\n            event.stopPropagation();\n            event.preventDefault();\n            if (event.ctrlKey) {\n                this._insertNewLine(event.target);\n            }\n            else {\n                this.props.onReplaceCurrent();\n            }\n        }\n    }\n    _insertNewLine(textarea) {\n        const [start, end] = [textarea.selectionStart, textarea.selectionEnd];\n        textarea.setRangeText('\\n', start, end, 'end');\n    }\n    _onClose() {\n        // Clean up and close widget.\n        this.props.onClose();\n    }\n    _onReplaceToggled() {\n        // Deactivate invalid replace filters\n        if (!this.props.replaceEntryVisible) {\n            for (const key in this.props.filtersDefinition) {\n                const filter = this.props.filtersDefinition[key];\n                if (!filter.supportReplace) {\n                    this.props.onFilterChanged(key, false).catch(reason => {\n                        console.error(`Fail to update filter value for ${filter.title}:\\n${reason}`);\n                    });\n                }\n            }\n        }\n        this.props.onReplaceEntryShown(!this.props.replaceEntryVisible);\n    }\n    _toggleFiltersVisibility() {\n        this.props.onFiltersVisibilityChanged(!this.props.filtersVisible);\n    }\n    render() {\n        var _a, _b, _c;\n        const trans = this.translator.load('jupyterlab');\n        const showReplace = !this.props.isReadOnly && this.props.replaceEntryVisible;\n        const filters = this.props.filtersDefinition;\n        const hasFilters = Object.keys(filters).length > 0;\n        const filterToggle = hasFilters ? (react__WEBPACK_IMPORTED_MODULE_5__.createElement(FilterToggle, { visible: this.props.filtersVisible, anyEnabled: Object.keys(filters).some(name => {\n                var _a;\n                const filter = filters[name];\n                return (_a = this.props.filters[name]) !== null && _a !== void 0 ? _a : filter.default;\n            }), toggleVisible: () => this._toggleFiltersVisibility(), trans: trans })) : null;\n        const selectionBinding = (_a = this.props.keyBindings) === null || _a === void 0 ? void 0 : _a.toggleSearchInSelection;\n        const selectionKeys = selectionBinding\n            ? _lumino_commands__WEBPACK_IMPORTED_MODULE_3__.CommandRegistry.formatKeystroke(selectionBinding.keys)\n            : '';\n        const selectionKeyHint = selectionKeys ? ` (${selectionKeys})` : '';\n        const filter = hasFilters ? (react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"div\", { className: SEARCH_OPTIONS_CLASS }, Object.keys(filters).map(name => {\n            var _a, _b;\n            const filter = filters[name];\n            const isEnabled = !showReplace || filter.supportReplace;\n            // Show an alternate description, if one exists, when a filter is disabled in replace mode.\n            const description = isEnabled\n                ? filter.description\n                : (_a = filter.disabledDescription) !== null && _a !== void 0 ? _a : filter.description;\n            return (react__WEBPACK_IMPORTED_MODULE_5__.createElement(FilterSelection, { key: name, title: filter.title, description: description + (name == 'selection' ? selectionKeyHint : ''), isEnabled: isEnabled, onToggle: async () => {\n                    await this.props.onFilterChanged(name, !this.props.filters[name]);\n                }, value: (_b = this.props.filters[name]) !== null && _b !== void 0 ? _b : filter.default }));\n        }))) : null;\n        const icon = this.props.replaceEntryVisible\n            ? _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__.caretDownIcon\n            : _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__.caretRightIcon;\n        // TODO: Error messages from regex are not currently localizable.\n        return (react__WEBPACK_IMPORTED_MODULE_5__.createElement(react__WEBPACK_IMPORTED_MODULE_5__.Fragment, null,\n            react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"div\", { className: OVERLAY_ROW_CLASS },\n                this.props.isReadOnly ? (react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"div\", { className: TOGGLE_PLACEHOLDER })) : (react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"button\", { className: TOGGLE_WRAPPER, onClick: () => this._onReplaceToggled(), tabIndex: 0, title: showReplace\n                        ? trans.__('Hide Replace')\n                        : trans.__('Show Replace') },\n                    react__WEBPACK_IMPORTED_MODULE_5__.createElement(icon.react, { className: `${REPLACE_TOGGLE_CLASS} ${BUTTON_CONTENT_CLASS}`, tag: \"span\", elementPosition: \"center\", height: \"20px\", width: \"20px\" }))),\n                react__WEBPACK_IMPORTED_MODULE_5__.createElement(SearchEntry, { inputRef: this.props.searchInputRef, useRegex: this.props.useRegex, caseSensitive: this.props.caseSensitive, wholeWords: this.props.wholeWords, onCaseSensitiveToggled: this.props.onCaseSensitiveToggled, onRegexToggled: this.props.onRegexToggled, onWordToggled: this.props.onWordToggled, onKeydown: (e) => this._onSearchKeydown(e), onChange: (e) => this._onSearchChange(e), initialSearchText: this.props.initialSearchText, lastSearchText: this.props.lastSearchText, translator: this.translator }),\n                filterToggle,\n                react__WEBPACK_IMPORTED_MODULE_5__.createElement(SearchIndices, { currentIndex: this.props.currentIndex, totalMatches: (_b = this.props.totalMatches) !== null && _b !== void 0 ? _b : 0 }),\n                react__WEBPACK_IMPORTED_MODULE_5__.createElement(UpDownButtons, { onHighlightPrevious: () => {\n                        this.props.onHighlightPrevious();\n                    }, onHighlightNext: () => {\n                        this.props.onHighlightNext();\n                    }, trans: trans, keyBindings: this.props.keyBindings, isEnabled: !!((_c = this.props.searchInputRef.current) === null || _c === void 0 ? void 0 : _c.value) }),\n                react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => this._onClose(), tabIndex: 0, title: trans.__('Close Search Box') },\n                    react__WEBPACK_IMPORTED_MODULE_5__.createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__.closeIcon.react, { className: \"jp-icon-hover\", elementPosition: \"center\", height: \"16px\", width: \"16px\" }))),\n            react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"div\", { className: OVERLAY_ROW_CLASS }, showReplace ? (react__WEBPACK_IMPORTED_MODULE_5__.createElement(react__WEBPACK_IMPORTED_MODULE_5__.Fragment, null,\n                react__WEBPACK_IMPORTED_MODULE_5__.createElement(ReplaceEntry, { onPreserveCaseToggled: this.props.onPreserveCaseToggled, onReplaceKeydown: (e) => this._onReplaceKeydown(e), onChange: (e) => this.props.onReplaceChanged(e.target.value), onReplaceCurrent: () => this.props.onReplaceCurrent(), onReplaceAll: () => this.props.onReplaceAll(), replaceOptionsSupport: this.props.replaceOptionsSupport, replaceText: this.props.replaceText, preserveCase: this.props.preserveCase, translator: this.translator }),\n                react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"div\", { className: SPACER_CLASS }))) : null),\n            this.props.filtersVisible ? filter : null,\n            !!this.props.errorMessage && (react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"div\", { className: REGEX_ERROR_CLASS }, this.props.errorMessage))));\n    }\n}\n/**\n * Search document widget\n */\nclass SearchDocumentView extends _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__.VDomRenderer {\n    /**\n     * Search document widget constructor.\n     *\n     * @param model Search document model\n     * @param translator Application translator object\n     * @param keyBindings Search keybindings\n     *\n     */\n    constructor(model, translator, keyBindings) {\n        super(model);\n        this.translator = translator;\n        this._showReplace = false;\n        this._showFilters = false;\n        this._closed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__.Signal(this);\n        this.addClass(OVERLAY_CLASS);\n        this._searchInput = react__WEBPACK_IMPORTED_MODULE_5__.createRef();\n        this._keyBindings = keyBindings;\n    }\n    /**\n     * A signal emitted when the widget is closed.\n     *\n     * Closing the widget detached it from the DOM but does not dispose it.\n     */\n    get closed() {\n        return this._closed;\n    }\n    /**\n     * Focus search input.\n     */\n    focusSearchInput() {\n        var _a;\n        (_a = this._searchInput.current) === null || _a === void 0 ? void 0 : _a.select();\n    }\n    /**\n     * Set the initial search text.\n     */\n    setSearchText(search) {\n        this.model.initialQuery = search;\n        // Only set the new search text to search expression if there is any\n        // to avoid nullifying the one that was remembered from last time.\n        if (search) {\n            this.model.searchExpression = search;\n        }\n    }\n    /**\n     * Set the replace text\n     *\n     * It does not trigger a view update.\n     */\n    setReplaceText(replace) {\n        this.model.replaceText = replace;\n    }\n    /**\n     * Show the replacement input box.\n     */\n    showReplace() {\n        this.setReplaceInputVisibility(true);\n    }\n    /**\n     * A message handler invoked on a `'close-request'` message.\n     *\n     * #### Notes\n     * On top of the default implementation emit closed signal and end model query.\n     */\n    onCloseRequest(msg) {\n        super.onCloseRequest(msg);\n        this._closed.emit();\n        void this.model.endQuery();\n    }\n    setReplaceInputVisibility(v) {\n        if (this._showReplace !== v) {\n            this._showReplace = v;\n            this.update();\n        }\n    }\n    setFiltersVisibility(v) {\n        if (this._showFilters !== v) {\n            this._showFilters = v;\n            this.update();\n        }\n    }\n    render() {\n        return this.model.filtersDefinitionChanged ? (react__WEBPACK_IMPORTED_MODULE_5__.createElement(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_4__.UseSignal, { signal: this.model.filtersDefinitionChanged }, () => this._renderOverlay())) : (this._renderOverlay());\n    }\n    _renderOverlay() {\n        return (react__WEBPACK_IMPORTED_MODULE_5__.createElement(SearchOverlay, { caseSensitive: this.model.caseSensitive, currentIndex: this.model.currentIndex, isReadOnly: this.model.isReadOnly, errorMessage: this.model.parsingError, filters: this.model.filters, filtersDefinition: this.model.filtersDefinition, preserveCase: this.model.preserveCase, replaceEntryVisible: this._showReplace, filtersVisible: this._showFilters, replaceOptionsSupport: this.model.replaceOptionsSupport, replaceText: this.model.replaceText, initialSearchText: this.model.initialQuery, lastSearchText: this.model.searchExpression, searchInputRef: this._searchInput, totalMatches: this.model.totalMatches, translator: this.translator, useRegex: this.model.useRegex, wholeWords: this.model.wholeWords, onCaseSensitiveToggled: () => {\n                this.model.caseSensitive = !this.model.caseSensitive;\n            }, onRegexToggled: () => {\n                this.model.useRegex = !this.model.useRegex;\n            }, onWordToggled: () => {\n                this.model.wholeWords = !this.model.wholeWords;\n            }, onFilterChanged: async (name, value) => {\n                await this.model.setFilter(name, value);\n            }, onFiltersVisibilityChanged: (v) => {\n                this.setFiltersVisibility(v);\n            }, onHighlightNext: () => {\n                void this.model.highlightNext();\n            }, onHighlightPrevious: () => {\n                void this.model.highlightPrevious();\n            }, onPreserveCaseToggled: () => {\n                this.model.preserveCase = !this.model.preserveCase;\n            }, onSearchChanged: (q) => {\n                this.model.searchExpression = q;\n            }, onClose: () => {\n                this.close();\n            }, onReplaceEntryShown: (v) => {\n                this.setReplaceInputVisibility(v);\n            }, onReplaceChanged: (q) => {\n                this.model.replaceText = q;\n            }, onReplaceCurrent: () => {\n                void this.model.replaceCurrentMatch();\n            }, onReplaceAll: () => {\n                void this.model.replaceAllMatches();\n            }, keyBindings: this._keyBindings }));\n    }\n}\n//# sourceMappingURL=searchview.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/searchview.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/documentsearch/lib/tokens.js":
/*!****************************************************************!*\
  !*** ../node_modules/@jupyterlab/documentsearch/lib/tokens.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ISearchProviderRegistry: () => (/* binding */ ISearchProviderRegistry)\n/* harmony export */ });\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ \"webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\n/**\n * The search provider registry token.\n */\nconst ISearchProviderRegistry = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.Token('@jupyterlab/documentsearch:ISearchProviderRegistry', `A service for a registry of search\n  providers for the application. Plugins can register their UI elements with this registry\n  to provide find/replace support.`);\n//# sourceMappingURL=tokens.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/tokens.js?");

/***/ })

}]);