# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.


# Allow forward declaration of CalculationResultsApi type hints (also supports multiple type hints on single function)
from __future__ import annotations

# Include NumPy for custom extensions
import numpy as np

# Include Enum for array conversion helper functions
from enum import Enum

# Define static property getter - required to return SearchSettings and CacheSettings property instance from
# ResultsApi class that is used statically
class staticproperty(property):
  def __get__(self, owner_self, owner_cls):         
    return self.fget()

# Print status message if one has been set on the incoming object
def _print_status_message_if_available(obj):
  if (obj._has_status_message()):
    print(obj._get_last_status_message())



from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ResultsAPI_Python
else:
    import _ResultsAPI_Python

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ResultsAPI_Python.delete_SwigPyIterator

    def value(self):
        return _ResultsAPI_Python.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _ResultsAPI_Python.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _ResultsAPI_Python.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _ResultsAPI_Python.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _ResultsAPI_Python.SwigPyIterator_equal(self, x)

    def copy(self):
        return _ResultsAPI_Python.SwigPyIterator_copy(self)

    def next(self):
        return _ResultsAPI_Python.SwigPyIterator_next(self)

    def __next__(self):
        return _ResultsAPI_Python.SwigPyIterator___next__(self)

    def previous(self):
        return _ResultsAPI_Python.SwigPyIterator_previous(self)

    def advance(self, n):
        return _ResultsAPI_Python.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _ResultsAPI_Python.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _ResultsAPI_Python.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _ResultsAPI_Python.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _ResultsAPI_Python.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _ResultsAPI_Python.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _ResultsAPI_Python.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _ResultsAPI_Python:
_ResultsAPI_Python.SwigPyIterator_swigregister(SwigPyIterator)
SHARED_PTR_DISOWN = _ResultsAPI_Python.SHARED_PTR_DISOWN

class VectorType(Enum):
    SINGLE_PRECISION = 1
    DOUBLE_PRECISION = 2
    STRING = 3

# Converts a numeric ndarray or list to a wrapped vector
def convert_array_type_to_wrapped_vector(array_to_convert, target_type: VectorType) -> ArrayOfFloat | ArrayOfDouble | ArrayOfInt:
    converted = True
    try:
        if isinstance(array_to_convert, np.ndarray):
            if target_type == VectorType.SINGLE_PRECISION:
                native_array = ArrayOfFloat(array_to_convert.data)
            elif target_type == VectorType.DOUBLE_PRECISION:
                native_array = ArrayOfDouble(array_to_convert.data)
            elif target_type == VectorType.STRING:
                num_values = len(array_to_convert)
                native_array = ArrayOfString(num_values)
                for label_index in range(0, num_values, 1):
                    native_array[label_index] = array_to_convert[label_index]
            else:
                converted = False
        elif isinstance(array_to_convert, list):
            num_values = len(array_to_convert)
            if target_type == VectorType.SINGLE_PRECISION:
                native_array = ArrayOfFloat(num_values)
            elif target_type == VectorType.DOUBLE_PRECISION:
                native_array = ArrayOfDouble(num_values)
            elif target_type == VectorType.STRING:
                native_array = ArrayOfString(num_values)
            else:
                converted = False
            if converted:
                for label_index in range(0, num_values, 1):
                    native_array[label_index] = array_to_convert[label_index]

        if converted:
            return native_array
        else:
            raise TypeError("Array data type not convertible to wrapped vector:", type(array_to_convert))
    except RuntimeError as e:
        print(e)

DATA_TYPE_SPECIFIER_READ_AS_SERIALISED_TYPE = _ResultsAPI_Python.DataTypeSpecifier_ReadAsSerialisedType
r"""Read data as its actual type (recommended setting)."""
DATA_TYPE_SPECIFIER_READ_AS_FLOAT32 = _ResultsAPI_Python.DataTypeSpecifier_ReadAsFloat32
r"""Read data as single-precision floating-point regardless of its actual type."""
DATA_TYPE_SPECIFIER_READ_AS_FLOAT64 = _ResultsAPI_Python.DataTypeSpecifier_ReadAsFloat64
r"""Read data as double-precision floating-point regardless of its actual type."""
VARIABLE_DATA_TYPE_FLOAT32 = _ResultsAPI_Python.VariableDataType_Float32
r"""Single-precision floating-point (IEEE 754 4-byte format)."""
VARIABLE_DATA_TYPE_FLOAT64 = _ResultsAPI_Python.VariableDataType_Float64
r"""Double-precision floating-point (IEEE 754 8-byte format)."""
VARIABLE_DATA_TYPE_INT32 = _ResultsAPI_Python.VariableDataType_Int32
r"""Integer (4-byte signed)."""
VARIABLE_DATA_FORMAT_ASCII = _ResultsAPI_Python.VariableDataFormat_ASCII
r"""ASCII output format (human readable; slower to read/write)."""
VARIABLE_DATA_FORMAT_BINARY = _ResultsAPI_Python.VariableDataFormat_Binary
r"""Binary output format (not human readable; faster to read/write)."""
SEARCH_SCOPE_RECURSIVE_SEARCH = _ResultsAPI_Python.SearchScope_RecursiveSearch
r"""Search the directory tree recursively for runs, starting in the root directory."""
SEARCH_SCOPE_ROOT_DIRECTORY_ONLY = _ResultsAPI_Python.SearchScope_RootDirectoryOnly
r"""Search only in the root directory for runs."""
CASE_SENSITIVITY_IGNORE_CASE = _ResultsAPI_Python.CaseSensitivity_IgnoreCase
r"""
    Ignore the character case when matching regular expression pattern against discovered runs.

    With this setting, the regex pattern "powprod" will match runs named both "powprod" and "Powprod".
    """
CASE_SENSITIVITY_MATCH_CASE = _ResultsAPI_Python.CaseSensitivity_MatchCase
r"""
    Observe the character case when matching regular expression pattern against discovered runs.

    With this setting, the regex pattern "powprod" will match runs named "powprod" but not "Powprod".
    """
AXIS_TYPE_INTERVAL = _ResultsAPI_Python.AxisType_Interval
r"""An axis with fixed numeric intervals."""
AXIS_TYPE_LABELLED_VALUE = _ResultsAPI_Python.AxisType_LabelledValue
r"""An axis with variable numeric intervals."""
AXIS_TYPE_LABELLED_STRING = _ResultsAPI_Python.AxisType_LabelledString
r"""An axis with string intervals."""
OVERWRITE_BEHAVIOUR_OVERWRITE_EXISTING_OUTPUT = _ResultsAPI_Python.OverwriteBehaviour_OverwriteExistingOutput
r"""Overwrite existing output."""
OVERWRITE_BEHAVIOUR_DO_NOT_OVERWRITE_EXISTING_OUTPUT = _ResultsAPI_Python.OverwriteBehaviour_DoNotOverwriteExistingOutput
r"""Do not overwrite existing output."""
CALCULATION_TYPE_ALL_CALCULATION_TYPES = _ResultsAPI_Python.CalculationType_AllCalculationTypes
r"""Include runs of all calculation types in the results."""
CALCULATION_TYPE_ALL_TURBINE_SIMULATIONS = _ResultsAPI_Python.CalculationType_AllTurbineSimulations
r"""
    Include only turbine simulation runs in the results.

    A turbine simulation run may be one the following calculation types:

    - Power production simulation
    - Normal stop simulation
    - Emergency stop simulation
    - Start-up simulation
    - Idling simulation
    - Parked simulation
    - Steady parked loads
    - Steady operational loads
    """
CALCULATION_TYPE_ALL_SUPPORTING_CALCULATIONS = _ResultsAPI_Python.CalculationType_AllSupportingCalculations
r"""
    Include only supporting calculation runs in the results.

    A supporting calculation run may be one the following calculation types:

    - Aerodynamic information
    - Dynamic power curve
    - Electrical performance
    - Model linearisation
    - Performance coefficients
    - Steady power curve
    - Wind turbulence generation *
    - Earthquake generation *
    - Sea state *

    Note: * indicates calculation types excluded by default.

    Use `ResultsApi.SearchSettings` to include unsupported calculation types in the results.
    """
CALCULATION_TYPE_ALL_POST_PROCESSING_CALCULATIONS = _ResultsAPI_Python.CalculationType_AllPostProcessingCalculations
r"""
    Include only post-processing runs in the results.

    A post-processing calculation run may be one the following calculation types:

    - Annual energy yield analysis
    - Auto-spectral density analysis
    - Basic statistics
    - Channel combination
    - Cross-spectral density analysis
    - Extreme load extrapolation *
    - Extreme prediction analysis *
    - Fatigue analysis
    - Flicker analysis
    - Fourier harmonics analysis
    - Level crossing frequency analysis
    - Peak analysis
    - Periodic component analysis
    - Probability distribution analysis
    - Rainflow analysis
    - Ultimate loads analysis *
    - Ultimate load cases analysis

    Note: * indicates calculation types excluded by default.

    Use `ResultsApi.SearchSettings` to include unsupported calculation types in the results.
    """
CALCULATION_TYPE_UNKNOWN = _ResultsAPI_Python.CalculationType_Unknown
r"""Unknown calculation type"""
CALCULATION_TYPE_WIND_TURBULENCE = _ResultsAPI_Python.CalculationType_WindTurbulence
r"""Wind turbulence generation"""
CALCULATION_TYPE_AERODYNAMIC_INFORMATION = _ResultsAPI_Python.CalculationType_AerodynamicInformation
r"""Aerodynamic Information calculation"""
CALCULATION_TYPE_PERFORMANCE_COEFFICIENTS = _ResultsAPI_Python.CalculationType_PerformanceCoefficients
r"""Performance Coefficients calculation"""
CALCULATION_TYPE_STEADY_POWER_CURVE = _ResultsAPI_Python.CalculationType_SteadyPowerCurve
r"""Steady Power Curve calculation"""
CALCULATION_TYPE_STEADY_OPERATIONAL_LOADS = _ResultsAPI_Python.CalculationType_SteadyOperationalLoads
r"""Steady Operational Loads calculation"""
CALCULATION_TYPE_STEADY_PARKED_LOADS = _ResultsAPI_Python.CalculationType_SteadyParkedLoads
r"""Steady Parked Loads calculation"""
CALCULATION_TYPE_DYNAMIC_POWER_CURVE = _ResultsAPI_Python.CalculationType_DynamicPowerCurve
r"""Dynamic Power Curve calculation"""
CALCULATION_TYPE_POWER_PRODUCTION_SIMULATION = _ResultsAPI_Python.CalculationType_PowerProductionSimulation
r"""Power Production simulation"""
CALCULATION_TYPE_NORMAL_STOP_SIMULATION = _ResultsAPI_Python.CalculationType_NormalStopSimulation
r"""Normal Stop simulation"""
CALCULATION_TYPE_EMERGENCY_STOP_SIMULATION = _ResultsAPI_Python.CalculationType_EmergencyStopSimulation
r"""Emergency Stop simulation"""
CALCULATION_TYPE_START_UP_SIMULATION = _ResultsAPI_Python.CalculationType_StartUpSimulation
r"""Start-Up simulation"""
CALCULATION_TYPE_IDLING_SIMULATION = _ResultsAPI_Python.CalculationType_IdlingSimulation
r"""Idling simulation"""
CALCULATION_TYPE_PARKED_SIMULATION = _ResultsAPI_Python.CalculationType_ParkedSimulation
r"""Parked simulation"""
CALCULATION_TYPE_BASIC_STATISTICS = _ResultsAPI_Python.CalculationType_BasicStatistics
r"""Basic Statistics analysis"""
CALCULATION_TYPE_FOURIER_HARMONICS_ANALYSIS = _ResultsAPI_Python.CalculationType_FourierHarmonicsAnalysis
r"""Fourier Harmonics analysis"""
CALCULATION_TYPE_PERIODIC_COMPONENT_ANALYSIS = _ResultsAPI_Python.CalculationType_PeriodicComponentAnalysis
r"""Periodic Component analysis"""
CALCULATION_TYPE_EXTREME_PREDICTION_ANALYSIS = _ResultsAPI_Python.CalculationType_ExtremePredictionAnalysis
r"""Extreme Prediction analysis"""
CALCULATION_TYPE_AUTO_SPECTRAL_DENSITY_ANALYSIS = _ResultsAPI_Python.CalculationType_AutoSpectralDensityAnalysis
r"""Auto Spectral Density analysis"""
CALCULATION_TYPE_CROSS_SPECTRAL_DENSITY_ANALYSIS = _ResultsAPI_Python.CalculationType_CrossSpectralDensityAnalysis
r"""Cross Spectral Density analysis"""
CALCULATION_TYPE_PROBABILITY_DENSITY_ANALYSIS = _ResultsAPI_Python.CalculationType_ProbabilityDensityAnalysis
r"""Probability Density analysis"""
CALCULATION_TYPE_PEAK_ANALYSIS = _ResultsAPI_Python.CalculationType_PeakAnalysis
r"""Peak analysis"""
CALCULATION_TYPE_LEVEL_CROSSING_FREQUENCY_ANALYSIS = _ResultsAPI_Python.CalculationType_LevelCrossingFrequencyAnalysis
r"""Level Crossing Frequency analysis"""
CALCULATION_TYPE_RAINFLOW_CYCLE_ANALYSIS = _ResultsAPI_Python.CalculationType_RainflowCycleAnalysis
r"""Rainflow Cycle Counting analysis"""
CALCULATION_TYPE_FATIGUE_ANALYSIS = _ResultsAPI_Python.CalculationType_FatigueAnalysis
r"""Fatigue analysis"""
CALCULATION_TYPE_ANNUAL_ENERGY_YIELD_ANALYSIS = _ResultsAPI_Python.CalculationType_AnnualEnergyYieldAnalysis
r"""Annual Energy Yield analysis"""
CALCULATION_TYPE_CHANNEL_COMBINATION = _ResultsAPI_Python.CalculationType_ChannelCombination
r"""Channel Combination"""
CALCULATION_TYPE_ULTIMATE_LOADS_ANALYSIS = _ResultsAPI_Python.CalculationType_UltimateLoadsAnalysis
r"""Ultimate Loads analysis"""
CALCULATION_TYPE_ULTIMATE_LOAD_CASES_ANALYSIS = _ResultsAPI_Python.CalculationType_UltimateLoadCasesAnalysis
r"""Ultimate Load Cases analysis"""
CALCULATION_TYPE_FLICKER_ANALYSIS = _ResultsAPI_Python.CalculationType_FlickerAnalysis
r"""Flicker analysis"""
CALCULATION_TYPE_EARTHQUAKE_GENERATION = _ResultsAPI_Python.CalculationType_EarthquakeGeneration
r"""Earthquake generation"""
CALCULATION_TYPE_MODEL_LINEARISATION = _ResultsAPI_Python.CalculationType_ModelLinearisation
r"""Model Linearisation calculation"""
CALCULATION_TYPE_EXTREME_LOAD_EXTRAPOLATION = _ResultsAPI_Python.CalculationType_ExtremeLoadExtrapolation
r"""Extreme Load Extrapolation calculation"""
CALCULATION_TYPE_ELECTRICAL_PERFORMANCE = _ResultsAPI_Python.CalculationType_ElectricalPerformance
r"""Electrical Performance calculation"""
CALCULATION_TYPE_SEA_STATE = _ResultsAPI_Python.CalculationType_SeaState
r"""Sea state"""
CALCULATION_TYPE_MOORING_STIFFNESS = _ResultsAPI_Python.CalculationType_MooringStiffness
r"""Mooring Stiffness"""
CALCULATION_TYPE_USER_DEFINED = _ResultsAPI_Python.CalculationType_UserDefined
r"""User-defined output"""
COMPLETION_STATE_ALL_COMPLETION_STATES = _ResultsAPI_Python.CompletionState_AllCompletionStates
r"""Include all runs in the results regardless of completion state"""
COMPLETION_STATE_UNSUCCESSFUL_RUNS_ONLY = _ResultsAPI_Python.CompletionState_UnsuccessfulRunsOnly
r"""
    Include only unsuccessful runs the the results.

    An unsuccessful run has one of the following completion state values:

    - Terminated
    - Errored
    - Aborted
    """
COMPLETION_STATE_UNKNOWN = _ResultsAPI_Python.CompletionState_Unknown
r"""Run completion state unknown"""
COMPLETION_STATE_IN_PROGRESS = _ResultsAPI_Python.CompletionState_InProgress
r"""Run currently in progress"""
COMPLETION_STATE_COMPLETED_NORMALLY = _ResultsAPI_Python.CompletionState_CompletedNormally
r"""Run completed without error"""
COMPLETION_STATE_TERMINATED = _ResultsAPI_Python.CompletionState_Terminated
r"""Run terminated unexpectedly"""
COMPLETION_STATE_ERRORED = _ResultsAPI_Python.CompletionState_Errored
r"""Run terminated with an error"""
COMPLETION_STATE_ABORTED = _ResultsAPI_Python.CompletionState_Aborted
r"""Run was aborted by user"""
class _ResultsApi_CacheSettings(object):
    r"""Contains global settings for controlling how data is read and cached."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def _set_buffered_read_enabled(buffered_read_enabled):
        r"""
        Determines whether to buffer group data.

        Enabled by default.

        When enabled, the raw data buffer for each group is retained in memory in between requests for variables.

        Parameters
        ----------
        buffered_read_enabled : bool
            `True` to enable; `False` to disable.

        Notes
        -----
        - Applies to binary groups only.
        - Enabling buffered read makes successive requests for variables from the same group faster.
        - Disabling buffered read can be used to reduce memory consumption. However, it incurs a performance penalty when making successive requests for variables from the same group.
        - When buffered read is disabled, any existing data buffers are cleared.
        """
        return _ResultsAPI_Python._ResultsApi_CacheSettings__Settings_FUNCTIONFORPROPERTYPREFIX_set_buffered_read_enabled(buffered_read_enabled)

    @staticmethod
    def _get_buffered_read_enabled():
        r"""
        Indicates whether to buffer group data.

        Returns
        -------
        bool
            A boolean indicating whether data buffering is enabled (`True`) or disabled (`False`).
        """
        return _ResultsAPI_Python._ResultsApi_CacheSettings__get_buffered_read_enabled()

    @staticmethod
    def _set_run_caching_enabled(run_caching_enabled):
        r"""
        Determines whether to cache requested runs.

        Enabled by default.

        When enabled, `Run` objects are added to a cache. This makes subsequent requests for the same run faster.

        Parameters
        ----------
        run_caching_enabled : bool
            `True` to enable; `False` to disable.

        Notes
        -----
        - Disabling run caching read can be used to reduce memory consumption. However, it incurs a performance penalty when making successive requests for the same run.
        - When run caching is disabled, any cached `Run` objects are released.
        """
        return _ResultsAPI_Python._ResultsApi_CacheSettings__Settings_FUNCTIONFORPROPERTYPREFIX_set_run_caching_enabled(run_caching_enabled)

    @staticmethod
    def _get_run_caching_enabled():
        r"""
        Indicates whether to cache requested runs.

        Returns
        -------
        bool
            A boolean indicating whether run caching is enabled (`True`) or disabled (`False`).
        """
        return _ResultsAPI_Python._ResultsApi_CacheSettings__get_run_caching_enabled()

    @staticmethod
    def _set_data_type_for_reading(data_type_specifier):
        r"""
        Determines the data type to use when reading variables.

        Uses the serialised data type by default.

        Supports reading data as the serialised (i.e. actual) type, or as a different type determined by the
        `DATA_TYPE_SPECIFIER` value provided.

        Refer to notes for information about when this setting will not have an observable effect.

        Parameters
        ----------
        data_type_specifier : int
            An integer constant indicating the data type to use. Refer to individual `DATA_TYPE_SPECIFIER` constants for further information.

        Notes
        -----
        - Most Bladed results are written as single-precision (4 byte float).
        - Specifying single-precision to read data written as double-precision reduces memory consumption at the expense of precision.
        - Specifying double-precision to read data written as single-precision increases memory consumption but does not increase precision.
        - Calling this method does not affect the precision of data already cached. It only affects the precision used when reading variables from groups not yet read in the current session.
        - All variables belonging to the same group will be read with the same precision.
        - The precision used for reading a specific group is determined the first time a variable is read from the group.
        - The Software Performance group is written as integer (4 byte signed int).
        """
        return _ResultsAPI_Python._ResultsApi_CacheSettings__Settings_FUNCTIONFORPROPERTYPREFIX_set_data_type_for_reading(data_type_specifier)

    @staticmethod
    def _get_data_type_for_reading():
        r"""
        Gets the data type to use when reading variables.

        Returns
        -------
        int
            An integer constant indicating the data type setting. Refer to individual `DATA_TYPE_SPECIFIER` constants for further information.
        """
        return _ResultsAPI_Python._ResultsApi_CacheSettings__get_data_type_for_reading()

    @property
    def buffered_read_enabled(self) -> bool:
        r"""
        Determines whether to buffer group data.

        Enabled by default.

        When enabled, the raw data buffer for each group is retained in memory in between requests for variables.

        buffered_read_enabled: `True` to enable; `False` to disable.

        Notes
        -----
        - Applies to binary groups only.
        - Enabling buffered read makes successive requests for variables from the same group faster.
        - Disabling buffered read can be used to reduce memory consumption. However, it incurs a performance penalty when making successive requests for variables from the same group.
        - When buffered read is disabled, any existing data buffers are cleared.
        """
        return ResultsApi.CacheSettings._get_buffered_read_enabled()

    @buffered_read_enabled.setter
    def buffered_read_enabled(self, value: bool):
        ResultsApi.CacheSettings._set_buffered_read_enabled(value)


    @property
    def run_caching_enabled(self) -> bool:
        r"""
        Determines whether to cache requested runs.

        Enabled by default.

        When enabled, `Run` objects are added to a cache. This makes subsequent requests for the same run faster.

        run_caching_enabled: `True` to enable; `False` to disable.

        Notes
        -----
        - Disabling run caching read can be used to reduce memory consumption. However, it incurs a performance penalty when making successive requests for the same run.
        - When run caching is disabled, any cached `Run` objects are released.
        """
        return ResultsApi.CacheSettings._get_run_caching_enabled()

    @run_caching_enabled.setter
    def run_caching_enabled(self, value: bool):
        ResultsApi.CacheSettings._set_run_caching_enabled(value)


    @property
    def data_type_for_reading(self) -> int:
        r"""
        Determines the data type to use when reading variables.

        Uses the serialised data type by default.

        Supports reading data as the serialised (i.e. actual) type, or as a different type determined by the
        `DATA_TYPE_SPECIFIER` value provided.

        Refer to notes for information about when this setting will not have an observable effect.

        data_type_for_reading: An integer constant indicating the data type to use. Refer to individual `DATA_TYPE_SPECIFIER` constants for further information.

        Notes
        -----
        - Most Bladed results are written as single-precision (4 byte float).
        - Specifying single-precision to read data written as double-precision reduces memory consumption at the expense of precision.
        - Specifying double-precision to read data written as single-precision increases memory consumption but does not increase precision.
        - Calling this method does not affect the precision of data already cached. It only affects the precision used when reading variables from groups not yet read in the current session.
        - All variables belonging to the same group will be read with the same precision.
        - The precision used for reading a specific group is determined the first time a variable is read from the group.
        - The Software Performance group is written as integer (4 byte signed int).
        """
        return ResultsApi.CacheSettings._get_data_type_for_reading()

    @data_type_for_reading.setter
    def data_type_for_reading(self, value: int):
        ResultsApi.CacheSettings._set_data_type_for_reading(value)


    def __init__(self):
        r"""__init__(_ResultsApi_CacheSettings self) -> _ResultsApi_CacheSettings"""
        _ResultsAPI_Python._ResultsApi_CacheSettings_swiginit(self, _ResultsAPI_Python.new__ResultsApi_CacheSettings())
    __swig_destroy__ = _ResultsAPI_Python.delete__ResultsApi_CacheSettings

# Register _ResultsApi_CacheSettings in _ResultsAPI_Python:
_ResultsAPI_Python._ResultsApi_CacheSettings_swigregister(_ResultsApi_CacheSettings)
class _ResultsApi_SearchSettings(object):
    r"""Contains global settings for controlling how runs and variables are filtered in a request."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def _set_calculation_type_filter(calculation_type_filter):
        r"""
        Filters runs based on the calculation type.

        Includes all calculation types by default.

        A calculation type category may be specified, for example:

        - Turbine simulations
        - Supporting calculations
        - Post-processing calculations

        Alternatively, a specific calculation type may be specified, for example:

        - Power Production Loading
        - Steady Power Curve
        - Rainflow Cycle analysis

        Parameters
        ----------
        calculation_type_filter : int
            An integer constant indicating the calculation type to filter on. Refer to individual `CALCULATION_TYPE` constants for further information.

        Notes
        -----
        - The specific type of calculation may be requested from a `Run` object.
        - Setting only applies to requests for multiple runs; it does not apply when requesting an individual run.
        """
        return _ResultsAPI_Python._ResultsApi_SearchSettings__Settings_FUNCTIONFORPROPERTYPREFIX_set_calculation_type_filter(calculation_type_filter)

    @staticmethod
    def _get_calculation_type_filter():
        r"""
        Gets run calculation type filter.

        Returns
        -------
        int
            An integer constant indicating the calculation type filter. Refer to individual `CALCULATION_TYPE` constants for further information.
        """
        return _ResultsAPI_Python._ResultsApi_SearchSettings__get_calculation_type_filter()

    @staticmethod
    def _set_include_unsupported_calculations(include_unsupported_calculations):
        r"""
        Determines whether to include runs with an unsupported calculation type in the results.

        Enabled by default.

        Unsupported calculation types include:

        - Basic statstics
        - Ultimate loads analysis
        - Extreme load extrapolation
        - Wind turbulence
        - Earthquake generation
        - Sea state
        - Unknown (any calculation whose type was unrecognised or could not be established)

        Parameters
        ----------
        include_unsupported_calculations : bool
            `True` to include runs with an unsupported calculation type; `False` to exclude.

        Notes
        -----
        - An unsupported calculation type typically contains data in a format that is not currently readable by the Results API. Support for reading such formats may be added in a future release.
        - Excluding unsupported calculation types incurs a performance penalty.
        - Setting only applies to requests for multiple runs; it does not apply when requesting an individual run.
        """
        return _ResultsAPI_Python._ResultsApi_SearchSettings__Settings_FUNCTIONFORPROPERTYPREFIX_set_include_unsupported_calculations(include_unsupported_calculations)

    @staticmethod
    def _get_include_unsupported_calculations():
        r"""
        Indicates whether to include runs with an unsupported calculation type in the results.

        Returns
        -------
        bool
            A boolean indicating whether the unsupported calculations are included (`True`) or excluded (`False`).
        """
        return _ResultsAPI_Python._ResultsApi_SearchSettings__get_include_unsupported_calculations()

    @staticmethod
    def _set_completion_state_filter(completion_state_filter):
        r"""
        Filters runs based on the completion state.

        Includes all completion states by default.

        Parameters
        ----------
        completion_state_filter : int
            An integer constant indicating the completion state to filter on. Refer to individual `COMPLETION_STATE` constants for further information.

        Notes
        -----
        - The specific completion state may be requested from a `Run` object.
        - Setting only applies to requests for multiple runs; it does not apply when requesting an individual run.
        """
        return _ResultsAPI_Python._ResultsApi_SearchSettings__Settings_FUNCTIONFORPROPERTYPREFIX_set_completion_state_filter(completion_state_filter)

    @staticmethod
    def _get_completion_state_filter():
        r"""
        Gets run completion state filter.

        Returns
        -------
        int
            An integer constant indicating the run completion state filter. Refer to individual `COMPLETION_STATE` constants for further information.
        """
        return _ResultsAPI_Python._ResultsApi_SearchSettings__get_completion_state_filter()

    @staticmethod
    def _set_run_name_case_sensitivity(run_name_case_sensitivity):
        r"""
        Determines whether to observe or ignore the character case when matching run names.

        Character case is ignored by default (case-insensitive).

        Parameters
        ----------
        run_name_case_sensitivity : int
            An integer constant indicating the case sensitivity setting to use. Refer to individual `CASE_SENSITIVITY` constants for further information.
        """
        return _ResultsAPI_Python._ResultsApi_SearchSettings__Settings_FUNCTIONFORPROPERTYPREFIX_set_run_name_case_sensitivity(run_name_case_sensitivity)

    @staticmethod
    def _get_run_name_case_sensitivity():
        r"""
        Gets whether to observe or ignore the character case when matching run names.

        Returns
        -------
        int
            An integer constant indicating the run name case sensitivity setting. Refer to individual `CASE_SENSITIVITY` constants for further information.
        """
        return _ResultsAPI_Python._ResultsApi_SearchSettings__get_run_name_case_sensitivity()

    @staticmethod
    def _set_return_first_variable_match(return_first_variable_match):
        r"""
        Determines whether to return the first variable matched in a run containing multiple variables with the same name.

        Disabled by default.

        When enabled, the first variable matched will be returned and no exception raised.

        Parameters
        ----------
        return_first_variable_match : bool
            `True` to return the first variable found that matches the requested name; `False` to require disambiguation in the event of multiple matches.

        Notes
        -----
        - Some variable instances are written to more than one group in the run. Enabling this setting avoids the need for the user to pass a disambiguating group name to identify the specific variable instance to return.
        - When disabled, an exception is raised if a disambiguating group name was not supplied that allowed a duplicated variable to be identified uniquely.
        - Care should be taken when enabling this setting. Some runs, for example rainflow, have groups containing different variable instances with the same name.
        - Use `Run.get_variable_1d_from_specific_group` or `Run.get_variable_2d_from_specific_group` to limit the search scope to a specific group.
        """
        return _ResultsAPI_Python._ResultsApi_SearchSettings__Settings_FUNCTIONFORPROPERTYPREFIX_set_return_first_variable_match(return_first_variable_match)

    @staticmethod
    def _get_return_first_variable_match():
        r"""
        Indicates whether to return the first variable matched in a run containing multiple variables with the same name.

        Returns
        -------
        bool
            A boolean indicating whether to return the first matched variable (`True`) or find all matches (`False`).
        """
        return _ResultsAPI_Python._ResultsApi_SearchSettings__get_return_first_variable_match()

    @staticmethod
    def _set_retry_using_alternative_name(retry_using_alternative_name):
        r"""
        Determines whether the Results API should automatically retry failed requests for variables and groups using an alternative name, if one exists.

        Enabled by default.

        Parameters
        ----------
        retry_using_alternative_name : bool
            `True` to retry failed lookups using an alternative name; `False` to disable.

        Notes
        -----
        - The name of certain variables and groups may differ between Bladed releases. The Results API maintains a lookup table of equivalent names, allowing it to retry using an alternative name if the requested name could not be found. This improves the chance of finding the required data regardless of the Bladed version that created the outputs.
        """
        return _ResultsAPI_Python._ResultsApi_SearchSettings__Settings_FUNCTIONFORPROPERTYPREFIX_set_retry_using_alternative_name(retry_using_alternative_name)

    @staticmethod
    def _get_retry_using_alternative_name():
        r"""
        Indicates whether the Results API should automatically retry failed requests for variables and groups using an alternative name, if one exists.

        Returns
        -------
        bool
            A boolean indicating whether alternative name retry is enabled (`True`) or disabled (`False`).
        """
        return _ResultsAPI_Python._ResultsApi_SearchSettings__get_retry_using_alternative_name()

    @property
    def calculation_type_filter(self) -> int:
        r"""
        Filters runs based on the calculation type.

        Includes all calculation types by default.

        A calculation type category may be specified, for example:

        - Turbine simulations
        - Supporting calculations
        - Post-processing calculations

        Alternatively, a specific calculation type may be specified, for example:

        - Power Production Loading
        - Steady Power Curve
        - Rainflow Cycle analysis

        calculation_type_filter: An integer constant indicating the calculation type to filter on. Refer to individual `CALCULATION_TYPE` constants for further information.

        Notes
        -----
        - The specific type of calculation may be requested from a `Run` object.
        - Setting only applies to requests for multiple runs; it does not apply when requesting an individual run.
        """
        return ResultsApi.SearchSettings._get_calculation_type_filter()

    @calculation_type_filter.setter
    def calculation_type_filter(self, value: int):
        ResultsApi.SearchSettings._set_calculation_type_filter(value)


    @property
    def include_unsupported_calculations(self) -> bool:
        r"""
        Determines whether to include runs with an unsupported calculation type in the results.

        Enabled by default.

        Unsupported calculation types include:

        - Basic statstics
        - Ultimate loads analysis
        - Extreme load extrapolation
        - Wind turbulence
        - Earthquake generation
        - Sea state
        - Unknown (any calculation whose type was unrecognised or could not be established)

        include_unsupported_calculations: `True` to include runs with an unsupported calculation type; `False` to exclude.

        Notes
        -----
        - An unsupported calculation type typically contains data in a format that is not currently readable by the Results API. Support for reading such formats may be added in a future release.
        - Excluding unsupported calculation types incurs a performance penalty.
        - Setting only applies to requests for multiple runs; it does not apply when requesting an individual run.
        """
        return ResultsApi.SearchSettings._get_include_unsupported_calculations()

    @include_unsupported_calculations.setter
    def include_unsupported_calculations(self, value: bool):
        ResultsApi.SearchSettings._set_include_unsupported_calculations(value)


    @property
    def completion_state_filter(self) -> int:
        r"""
        Filters runs based on the completion state.

        Includes all completion states by default.

        completion_state_filter: An integer constant indicating the completion state to filter on. Refer to individual `COMPLETION_STATE` constants for further information.

        Notes
        -----
        - The specific completion state may be requested from a `Run` object.
        - Setting only applies to requests for multiple runs; it does not apply when requesting an individual run.
        """
        return ResultsApi.SearchSettings._get_completion_state_filter()

    @completion_state_filter.setter
    def completion_state_filter(self, value: int):
        ResultsApi.SearchSettings._set_completion_state_filter(value)


    @property
    def run_name_case_sensitivity(self) -> int:
        r"""
        Determines whether to observe or ignore the character case when matching run names.

        Character case is ignored by default (case-insensitive).

        run_name_case_sensitivity: An integer constant indicating the case sensitivity setting to use. Refer to individual `CASE_SENSITIVITY` constants for further information.
        """
        return ResultsApi.SearchSettings._get_run_name_case_sensitivity()

    @run_name_case_sensitivity.setter
    def run_name_case_sensitivity(self, value: int):
        ResultsApi.SearchSettings._set_run_name_case_sensitivity(value)


    @property
    def return_first_variable_match(self) -> bool:
        r"""
        Determines whether to return the first variable matched in a run containing multiple variables with the same name.

        Disabled by default.

        When enabled, the first variable matched will be returned and no exception raised.

        return_first_variable_match: `True` to return the first variable found that matches the requested name; `False` to require disambiguation in the event of multiple matches.

        Notes
        -----
        - Some variable instances are written to more than one group in the run. Enabling this setting avoids the need for the user to pass a disambiguating group name to identify the specific variable instance to return.
        - When disabled, an exception is raised if a disambiguating group name was not supplied that allowed a duplicated variable to be identified uniquely.
        - Care should be taken when enabling this setting. Some runs, for example rainflow, have groups containing different variable instances with the same name.
        - Use `Run.get_variable_1d_from_specific_group` or `Run.get_variable_2d_from_specific_group` to limit the search scope to a specific group.
        """
        return ResultsApi.SearchSettings._get_return_first_variable_match()

    @return_first_variable_match.setter
    def return_first_variable_match(self, value: bool):
        ResultsApi.SearchSettings._set_return_first_variable_match(value)


    @property
    def retry_using_alternative_name(self) -> bool:
        r"""
        Determines whether the Results API should automatically retry failed requests for variables and groups using an alternative name, if one exists.

        Enabled by default.

        retry_using_alternative_name: `True` to retry failed lookups using an alternative name; `False` to disable.

        Notes
        -----
        - The name of certain variables and groups may differ between Bladed releases. The Results API maintains a lookup table of equivalent names, allowing it to retry using an alternative name if the requested name could not be found. This improves the chance of finding the required data regardless of the Bladed version that created the outputs.
        """
        return ResultsApi.SearchSettings._get_retry_using_alternative_name()

    @retry_using_alternative_name.setter
    def retry_using_alternative_name(self, value: bool):
        ResultsApi.SearchSettings._set_retry_using_alternative_name(value)


    def __init__(self):
        r"""__init__(_ResultsApi_SearchSettings self) -> _ResultsApi_SearchSettings"""
        _ResultsAPI_Python._ResultsApi_SearchSettings_swiginit(self, _ResultsAPI_Python.new__ResultsApi_SearchSettings())
    __swig_destroy__ = _ResultsAPI_Python.delete__ResultsApi_SearchSettings

# Register _ResultsApi_SearchSettings in _ResultsAPI_Python:
_ResultsAPI_Python._ResultsApi_SearchSettings_swigregister(_ResultsApi_SearchSettings)
INDEPENDENT_VARIABLE_ID_PRIMARY = _ResultsAPI_Python.IndependentVariableId_Primary
r"""
    Applies to `Variable1D` and `Variable2D`.

    In the context of a time domain simulation, each discrete value of the primary independent variable
    represents a time value.
    """
INDEPENDENT_VARIABLE_ID_SECONDARY = _ResultsAPI_Python.IndependentVariableId_Secondary
r"""
    Applies to `Variable2D`.

    Each discrete value of the secondary independent variable represents an observation point,
    such as a blade station, or a tower member end in a multi-member tower.

    A full time series is associated with each observation point.
    """
class IndependentVariable(object):
    r"""Class representing an independent variable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def _get_name(self) -> str:
        r"""
        Gets the name of the independent variable.

        Returns
        -------
        str
            A string containing the name of the independent variable.

        Notes
        -----
        - The name of the independent variable is indicated by the AXISLAB field of the group header file.
        """
        return _ResultsAPI_Python.IndependentVariable__IndependentVariable_FUNCTIONFORPROPERTYPREFIX_get_name(self)

    def _get_si_unit(self) -> str:
        r"""
        Gets the SI unit of the independent variable.

        Returns
        -------
        str
            A string containing the SI unit of the independent variable.
        """
        return _ResultsAPI_Python.IndependentVariable__IndependentVariable_FUNCTIONFORPROPERTYPREFIX_get_si_unit(self)

    def _has_numeric_values(self):
        r"""
        Indicates whether the independent variable has numeric values.

        Returns
        -------
        bool
            A boolean indicating whether the independent variable has numeric values.

        Notes
        -----
        - If the axis is a labelled value or interval axis type, returns `True`.
        - If the axis is a labelled string axis type, returns `False`.
        """
        return _ResultsAPI_Python.IndependentVariable__IndependentVariable_FUNCTIONFORPROPERTYPREFIX_has_numeric_values(self)

    def _get_axis_type(self):
        r"""
        Gets the axis type of the independent variable.

        Returns
        -------
        int
            An integer constant indicating the axis type of the independent variable. Refer to individual `AXIS_TYPE` constants for further information.
        """
        return _ResultsAPI_Python.IndependentVariable__IndependentVariable_FUNCTIONFORPROPERTYPREFIX_get_axis_type(self)

    def _get_number_of_values(self):
        r"""
        Gets the number of discrete values of the independent variable.

        Returns
        -------
        int
            A positive integer indicating the number of discrete values of the independent variable.

        Notes
        -----
        - If the axis is a labelled axis type, returns the number of axis labels specified at creation time.
        - If the axis is an interval axis type, returns the number of data points, or 0 if the independent variable does not yet belong to an output group.
        - Use `IndependentVariable.axis_type` to enquire the axis type.
        """
        return _ResultsAPI_Python.IndependentVariable__IndependentVariable_FUNCTIONFORPROPERTYPREFIX_get_number_of_values(self)

    def _get_values_as_string_native_array(self) -> ArrayOfString:
        r"""
        Gets all values of the independent variable as string.

        Returns
        -------
        ArrayOfString
            A contiguous array of string values. Each value is the string representation of an axis value at the corresponding index.

        Notes
        -----
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.IndependentVariable__get_values_as_string_native_array(self)

    def _get_values_as_number_native_array(self) -> ArrayOfDouble:
        r"""
        Gets all values of the independent variable as double-precision number. Applies to:

        - numeric axis types
        - string axis types whose values are convertible to double-precision number.

        Returns
        -------
        ArrayOfDouble
            A contiguous array of numeric values. Each value is the double-precision representation of an axis value at the corresponding index.

        Notes
        -----
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.IndependentVariable__get_values_as_number_native_array(self)

    def __init__(self, *args):
        r"""
        **Function variant 1:**

        Creates a new `IndependentVariable` object that uses discrete numeric labels to delimit data points.

        Returns
        -------
        IndependentVariable
            A new `IndependentVariable` object.

        |

        **Function variant 2:**

        Creates a new `IndependentVariable` object that uses discrete string labels to delimit data points.

        Returns
        -------
        IndependentVariable
            A new `IndependentVariable` object.

        |

        **Function variant 3:**

        Creates a new `IndependentVariable` object that uses numeric values with a fixed interval to delimit data points.

        Returns
        -------
        IndependentVariable
            A new `IndependentVariable` object.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (str): The name of the independent variable.
              - arg2 (str): The SI unit of the independent variable.
              - arg3 (np.ndarray[np.float64]): The discrete numeric labels of the independent variable.

            **Function variant 2:**
              - arg1 (str): The name of the independent variable.
              - arg2 (str): The SI unit of the independent variable.
              - arg3 (np.ndarray[str]): The discrete string labels of the independent variable.

            **Function variant 3:**
              - arg1 (str): The name of the independent variable.
              - arg2 (str): The SI unit of the independent variable.
              - arg3 (float): The starting value.
              - arg4 (float): The interval step value.
        """

        # Class constructor: convert Numpy array of labels to native array
        converted = False
        if isinstance(args[2], np.ndarray):
            numpy_labels_array = args[2]
            if np.issubdtype(numpy_labels_array.dtype, np.number):
                native_labels_array = convert_array_type_to_wrapped_vector(numpy_labels_array, VectorType.DOUBLE_PRECISION)
            elif np.issubdtype(numpy_labels_array.dtype, np.str_) or np.issubdtype(numpy_labels_array.dtype, np.string_) or numpy_labels_array.dtype == object:
                native_labels_array = convert_array_type_to_wrapped_vector(numpy_labels_array, VectorType.STRING)
            else:
                raise TypeError("Numpy array data type not supported for independent variable labels: " + str(numpy_labels_array.dtype))
            converted = True
        elif isinstance(args[2], list):
            labels_list = args[2]
            num_values = len(labels_list)
            if (num_values > 0):
                if isinstance(labels_list[0], float) or isinstance(labels_list[0], int):
        # Python float is double precision
                    native_labels_array = convert_array_type_to_wrapped_vector(labels_list, VectorType.DOUBLE_PRECISION)
                elif isinstance(labels_list[0], str):
                    native_labels_array = convert_array_type_to_wrapped_vector(labels_list, VectorType.STRING)
                else:
                    raise TypeError("List data type not supported for independent variable labels: " + str(type(labels_list)))
                converted = True
            else:
        # List is empty - we can't know what the type is
                raise TypeError("List cannot be empty when setting independent variable labels")
        if converted:
        # args tuple is immutable - modify using a list
            args_list = list(args)
            args_list[2] = native_labels_array
            args = tuple(args_list)


        _ResultsAPI_Python.IndependentVariable_swiginit(self, _ResultsAPI_Python.new_IndependentVariable(*args))

    @property
    def name(self) -> str:
        r"""
        The name of the independent variable.

        Notes
        -----
        - The name of the independent variable is indicated by the AXISLAB field of the group header file.
        """
        return self._get_name()


    @property
    def si_unit(self) -> str:
        r"""
        The SI unit of the independent variable.
        """
        result = self._get_si_unit()
        return result.encode('utf-8', 'surrogateescape').decode('ISO-8859-1')


    @property
    def has_numeric_values(self) -> bool:
        r"""
        Whether the independent variable has numeric values.

        Notes
        -----
        - If the axis is a labelled value or interval axis type, returns `True`.
        - If the axis is a labelled string axis type, returns `False`.
        """
        return self._has_numeric_values()


    @property
    def axis_type(self) -> int:
        r"""
        The axis type of the independent variable.
        """
        return self._get_axis_type()


    @property
    def number_of_values(self) -> int:
        r"""
        The number of discrete values of the independent variable.

        Notes
        -----
        - If the axis is a labelled axis type, returns the number of axis labels specified at creation time.
        - If the axis is an interval axis type, returns the number of data points, or 0 if the independent variable does not yet belong to an output group.
        - Use `IndependentVariable.axis_type` to enquire the axis type.
        """
        return self._get_number_of_values()


    def _get_values_as_number_numpy_from_vector(self):
        r"""_get_values_as_number_numpy_from_vector(IndependentVariable self) -> PyObject *"""
        return _ResultsAPI_Python.IndependentVariable__get_values_as_number_numpy_from_vector(self)


      # Wrapped contiguous array of string to Numpy array conversion
      # Performs a copy - unavoidable as std::string is not supported using PyArray_SimpleNewFromData
    def get_values_as_string(self) -> np.ndarray[str]:
        r"""
        Gets all values of the independent variable as string.

        Returns
        -------
        np.ndarray[str]
            A NumPy `ndarray` of string values. Each value is the string representation of an axis value at the corresponding index.

        Notes
        -----
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_values_as_string_native_array` to avoid this penalty.
        """
        return np.asarray(self._get_values_as_string_native_array(), dtype=str)

    # Wrapped vector to Numpy array conversion without copy
    def get_values_as_number(self) -> np.ndarray[np.float64]:
        r"""
        Gets all values of the independent variable as double-precision number. Applies to:

        - numeric axis types
        - string axis types whose values are convertible to double-precision number.

        Returns
        -------
        np.ndarray[np.float64]
            A NumPy `ndarray` of numeric values. Each value is the double-precision representation of an axis value at the corresponding index.

        Notes
        -----
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_values_as_number_native_array` to avoid this penalty.
        """
        return self._get_values_as_number_numpy_from_vector()

    __swig_destroy__ = _ResultsAPI_Python.delete_IndependentVariable

# Register IndependentVariable in _ResultsAPI_Python:
_ResultsAPI_Python.IndependentVariable_swigregister(IndependentVariable)
class Variable(object):
    r"""
    Base class representing a dependent variable.

    Notes
    -----
    - Provides metadata common to one-dimensional (`Variable1D`) and two-dimensional (`Variable2D`) variable sub-types.
    - A `Variable` object may be converted to one of `Variable1D` or `Variable2D` (depending on its sub-type) using `Run.get_variable_1d` and `Run.get_variable_2d`.
    - Use `Variable1D` and `Variable2D` objects to access data.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def _get_name(self) -> str:
        r"""
        Gets the name of the variable.

        Returns
        -------
        str
            A string containing the name of the variable.
        """
        return _ResultsAPI_Python.Variable__Variable_FUNCTIONFORPROPERTYPREFIX_get_name(self)

    def _get_si_unit(self) -> str:
        r"""
        Gets the SI unit of the variable, e.g. m for metres.

        Returns
        -------
        str
            A string containing the SI unit of the variable.
        """
        return _ResultsAPI_Python.Variable__Variable_FUNCTIONFORPROPERTYPREFIX_get_si_unit(self)

    def _get_quantity_code(self) -> str:
        r"""
        Gets the quantity code of the variable, e.g. L for length.

        Returns
        -------
        str
            A string containing the quantity code of the variable.
        """
        return _ResultsAPI_Python.Variable__Variable_FUNCTIONFORPROPERTYPREFIX_get_quantity_code(self)

    def _get_number_of_independent_variables(self):
        r"""
        Gets the number of independent variables (1 or 2).

        Returns
        -------
        int
            A positive integer indicating the number of independent variables.

        Notes
        -----
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return _ResultsAPI_Python.Variable__Variable_FUNCTIONFORPROPERTYPREFIX_get_number_of_independent_variables(self)

    def _is_one_dimensional(self):
        r"""
        Indicates whether the variable is a one-dimensional dependent variable (`Variable1D`).

        Returns
        -------
        bool
            A boolean indicating whether the variable is a one-dimensional dependent variable.

        Notes
        -----
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        """
        return _ResultsAPI_Python.Variable__Variable_FUNCTIONFORPROPERTYPREFIX_is_one_dimensional(self)

    def _is_two_dimensional(self):
        r"""
        Indicates whether the variable is a two-dimensional dependent variable (`Variable2D`).

        Returns
        -------
        bool
            A boolean indicating whether the variable is a two-dimensional dependent variable.

        Notes
        -----
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return _ResultsAPI_Python.Variable__Variable_FUNCTIONFORPROPERTYPREFIX_is_two_dimensional(self)

    def _get_parent_group_name(self) -> str:
        r"""
        Gets the name of the parent group.

        Returns
        -------
        str
            A string containing the name of the parent group.

        Notes
        -----
        - The name of the parent group is indicated by the value of GENLAB label in the header file.
        """
        return _ResultsAPI_Python.Variable__Variable_FUNCTIONFORPROPERTYPREFIX_get_parent_group_name(self)

    def _get_parent_group_number(self):
        r"""
        Gets the number of the parent group.

        Returns
        -------
        int
            A positive integer indicating the number of the parent group.

        Notes
        -----
        - The group number is unique within a given run.
        - The group number is used in the file extension of the group.
        """
        return _ResultsAPI_Python.Variable__Variable_FUNCTIONFORPROPERTYPREFIX_get_parent_group_number(self)

    def _get_parent_group_header_file_full_path(self) -> str:
        r"""
        Gets the the full path to the parent group header file.

        Returns
        -------
        str
            A string containing the full path to the parent group header file.
        """
        return _ResultsAPI_Python.Variable__Variable_FUNCTIONFORPROPERTYPREFIX_get_parent_group_header_file_full_path(self)

    def _get_time_domain_simulation_length(self):
        r"""
        Gets the length in seconds of the time domain simulation.

        Returns
        -------
        float
            A double-precision floating-point value containing the simulation length in seconds.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - Use `Run.execution_duration_seconds` to get the wall-clock duration of a calculation.
        """
        return _ResultsAPI_Python.Variable__Variable_FUNCTIONFORPROPERTYPREFIX_get_time_domain_simulation_length(self)

    def _get_time_domain_simulation_output_timestep(self):
        r"""
        Gets the output timestep used in the time domain simulation.

        Returns
        -------
        float
            A double-precision floating-point value containing the output timestep.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - The output timestep is indicated by the STEP field of the parent group header file.
        """
        return _ResultsAPI_Python.Variable__Variable_FUNCTIONFORPROPERTYPREFIX_get_time_domain_simulation_output_timestep(self)

    def _get_time_domain_simulation_output_start_time(self):
        r"""
        Gets the output start time used in the time domain simulation. This is the first point in the simulation when outputs were written.

        Returns
        -------
        float
            A double-precision floating-point value containing the output start time.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - The output start time is indicated by the MIN field of the parent group header file.
        """
        return _ResultsAPI_Python.Variable__Variable_FUNCTIONFORPROPERTYPREFIX_get_time_domain_simulation_output_start_time(self)

    def _get_data_point_count(self):
        r"""
        Gets the number of data points recorded for the variable. In a time domain simulation, this is equivalent to the number of output timesteps.

        Returns
        -------
        int
            A positive integer indicating the number of data points recorded for the variable.

        Notes
        -----
        - For a `Variable1D`, returns the number of data points recorded.
        - For a `Variable2D`, returns the number of data points recorded for any given secondary independent variable (not the aggregate count of all secondary independent variables).
        """
        return _ResultsAPI_Python.Variable__Variable_FUNCTIONFORPROPERTYPREFIX_get_data_point_count(self)

    def _get_data_type(self):
        r"""
        Gets the data type of the variable.

        Returns
        -------
        int
            An integer constant indicating the data type of the variable. Refer to individual `VARIABLE_DATA_TYPE` constants for further information.

        Notes
        -----
        - Data type returned may differ from the serialised data type if client has specified a target data type.
        - Use `ResultsApi.CacheSettings` to set the data type to use globally.
        """
        return _ResultsAPI_Python.Variable__Variable_FUNCTIONFORPROPERTYPREFIX_get_data_type(self)

    def _get_data_format(self):
        r"""
        Gets the data format of the variable.

        Returns
        -------
        int
            An integer constant indicating the data format of the variable. Refer to individual `VARIABLE_DATA_FORMAT` constants for further information.
        """
        return _ResultsAPI_Python.Variable__Variable_FUNCTIONFORPROPERTYPREFIX_get_data_format(self)

    def _get_independent_variables_native_array(self) -> ArrayOfIndependentVariable:
        r"""
        Gets all independent variables that pertain to this dependent variable.

        Returns
        -------
        ArrayOfIndependentVariable
            A contiguous array of `IndependentVariable` objects.

        Notes
        -----
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Variable__get_independent_variables_native_array(self)

    def _get_last_status_message(self):
        r"""
        Gets the last status message for the variable.

        Returns
        -------
        str
            A string containing the last status message for the variable.

        Notes
        -----
        - The status message is used to relay information that a user may need to be aware of, but does not qualify as an error.
        """
        return _ResultsAPI_Python.Variable__get_last_status_message(self)

    def _has_status_message(self):
        r"""
        Indicates whether the variable has a status message.

        Returns
        -------
        bool
            A boolean indicating whether the variable has a status message.
        """
        return _ResultsAPI_Python.Variable__has_status_message(self)
    __swig_destroy__ = _ResultsAPI_Python.delete_Variable

    @property
    def name(self) -> str:
        r"""
        The name of the variable.
        """
        return self._get_name()


    @property
    def si_unit(self) -> str:
        r"""
        The SI unit of the variable, e.g. m for metres.
        """
        result = self._get_si_unit()
        return result.encode('utf-8', 'surrogateescape').decode('ISO-8859-1')


    @property
    def quantity_code(self) -> str:
        r"""
        The quantity code of the variable, e.g. L for length.
        """
        return self._get_quantity_code()


    @property
    def number_of_independent_variables(self) -> int:
        r"""
        The number of independent variables (1 or 2).

        Notes
        -----
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return self._get_number_of_independent_variables()


    @property
    def is_one_dimensional(self) -> bool:
        r"""
        Whether the variable is a one-dimensional dependent variable (`Variable1D`).

        Notes
        -----
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        """
        return self._is_one_dimensional()


    @property
    def is_two_dimensional(self) -> bool:
        r"""
        Whether the variable is a two-dimensional dependent variable (`Variable2D`).

        Notes
        -----
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return self._is_two_dimensional()


    @property
    def parent_group_name(self) -> str:
        r"""
        The name of the parent group.

        Notes
        -----
        - The name of the parent group is indicated by the value of GENLAB label in the header file.
        """
        return self._get_parent_group_name()


    @property
    def parent_group_number(self) -> int:
        r"""
        The number of the parent group.

        Notes
        -----
        - The group number is unique within a given run.
        - The group number is used in the file extension of the group.
        """
        return self._get_parent_group_number()


    @property
    def parent_group_header_file_full_path(self) -> str:
        r"""
        The the full path to the parent group header file.
        """
        return self._get_parent_group_header_file_full_path()


    @property
    def time_domain_simulation_length(self) -> float:
        r"""
        The length in seconds of the time domain simulation.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - Use `Run.execution_duration_seconds` to get the wall-clock duration of a calculation.
        """
        return self._get_time_domain_simulation_length()


    @property
    def time_domain_simulation_output_timestep(self) -> float:
        r"""
        The output timestep used in the time domain simulation.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - The output timestep is indicated by the STEP field of the parent group header file.
        """
        return self._get_time_domain_simulation_output_timestep()


    @property
    def time_domain_simulation_output_start_time(self) -> float:
        r"""
        The output start time used in the time domain simulation. This is the first point in the simulation when outputs were written.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - The output start time is indicated by the MIN field of the parent group header file.
        """
        return self._get_time_domain_simulation_output_start_time()


    @property
    def data_point_count(self) -> int:
        r"""
        The number of data points recorded for the variable. In a time domain simulation, this is equivalent to the number of output timesteps.

        Notes
        -----
        - For a `Variable1D`, returns the number of data points recorded.
        - For a `Variable2D`, returns the number of data points recorded for any given secondary independent variable (not the aggregate count of all secondary independent variables).
        """
        return self._get_data_point_count()


    @property
    def data_type(self) -> int:
        r"""
        The data type of the variable.

        Notes
        -----
        - Data type returned may differ from the serialised data type if client has specified a target data type.
        - Use `ResultsApi.CacheSettings` to set the data type to use globally.
        """
        return self._get_data_type()


    @property
    def data_format(self) -> int:
        r"""
        The data format of the variable.
        """
        return self._get_data_format()



      # Wrapped vector to Numpy array conversion
      # Performs a copy but should be inexpensive as the underlying container is of type shared_ptr<IndependentVariable>
    def get_independent_variables(self) -> np.ndarray[IndependentVariable]:
        r"""
        Gets all independent variables that pertain to this dependent variable.

        Returns
        -------
        np.ndarray[IndependentVariable]
            A NumPy `ndarray` of `IndependentVariable` objects.

        Notes
        -----
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_independent_variables_native_array` to avoid this penalty.
        """
        return np.asarray(self._get_independent_variables_native_array())


# Register Variable in _ResultsAPI_Python:
_ResultsAPI_Python.Variable_swigregister(Variable)
FILE_FORMAT_BLADED = _ResultsAPI_Python.FileFormat_Bladed
r"""Bladed file format"""
class IOutputSpecification(object):
    r"""
    Interface class for output specification.

    Notes
    -----
    - Declares methods that an output specification class must implement.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_path(self):
        r"""
        Gets the path to the output.

        Returns
        -------
        str
            A string containing the path to the output.
        """
        return _ResultsAPI_Python.IOutputSpecification_get_path(self)

    def get_name(self):
        r"""
        Gets the name of the data set.

        Returns
        -------
        str
            A string containing the name of the data set.
        """
        return _ResultsAPI_Python.IOutputSpecification_get_name(self)

    def get_file_format(self):
        r"""
        Gets the output file format.

        Returns
        -------
        int
            An integer constant indicating the file format the output specification pertains to. Refer to individual `FILE_FORMAT` constants for further information.
        """
        return _ResultsAPI_Python.IOutputSpecification_get_file_format(self)
    __swig_destroy__ = _ResultsAPI_Python.delete_IOutputSpecification

# Register IOutputSpecification in _ResultsAPI_Python:
_ResultsAPI_Python.IOutputSpecification_swigregister(IOutputSpecification)
class OutputGroup(IOutputSpecification):
    r"""Base class representing a Bladed group for writing."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def _get_path(self) -> str:
        r"""
        Gets the header file path of the output group.

        Returns
        -------
        str
            A string containing the path to the Bladed output group header file.
        """
        return _ResultsAPI_Python.OutputGroup__OutputGroup_FUNCTIONFORPROPERTYPREFIX_get_path(self)

    def _get_name(self) -> str:
        r"""
        Gets the name of the output group.

        Returns
        -------
        str
            A string containing the name of the output group.
        """
        return _ResultsAPI_Python.OutputGroup__OutputGroup_FUNCTIONFORPROPERTYPREFIX_get_name(self)

    def _get_file_format(self):
        r"""
        Gets the file format of the output group.

        Returns
        -------
        int
            An integer constant indicating the Bladed file format. Refer to individual `FILE_FORMAT` constants for further information.
        """
        return _ResultsAPI_Python.OutputGroup__OutputGroup_FUNCTIONFORPROPERTYPREFIX_get_file_format(self)

    def _get_data_source(self) -> str:
        r"""
        Gets the data source of the output group.

        Returns
        -------
        str
            A string containing the data source of the output group.
        """
        return _ResultsAPI_Python.OutputGroup__OutputGroup_FUNCTIONFORPROPERTYPREFIX_get_data_source(self)

    def _get_config(self) -> str:
        r"""
        Gets the data config value of the output group.

        Returns
        -------
        str
            A string containing the data config value of the output group.
        """
        return _ResultsAPI_Python.OutputGroup__OutputGroup_FUNCTIONFORPROPERTYPREFIX_get_config(self)

    def _get_variable_data_format(self):
        r"""
        Gets the data format of the output group.

        Returns
        -------
        int
            An integer constant indicating the format of the data. Refer to individual `VARIABLE_DATA_FORMAT` constants for further information.
        """
        return _ResultsAPI_Python.OutputGroup__OutputGroup_FUNCTIONFORPROPERTYPREFIX_get_variable_data_format(self)

    def _get_data_file_path(self) -> str:
        r"""
        Gets the data file path of the output group.

        Returns
        -------
        str
            A string containing the path to the Bladed output group data file.
        """
        return _ResultsAPI_Python.OutputGroup__OutputGroup_FUNCTIONFORPROPERTYPREFIX_get_data_file_path(self)

    def _get_number_of_variables(self):
        r"""
        Gets the number of dependent variables added to the output group.

        Returns
        -------
        int
            A positive integer indicating the number of dependent variables.
        """
        return _ResultsAPI_Python.OutputGroup__OutputGroup_FUNCTIONFORPROPERTYPREFIX_get_number_of_variables(self)

    def _set_tefile_creation_enabled(self, te_file_creation_enabled):
        r"""
        Determines whether to create a $TE file when writing the output group.

        $TE file creation is enabled by default.

        Parameters
        ----------
        te_file_creation_enabled : bool
            `True` to enable; `False` to disable.

        Notes
        -----
        - Creating a $TE file allows Bladed outputs to be consumed via the Results API and Bladed Results Viewer.
        - The $TE file has the same filename as the output group.
        """
        return _ResultsAPI_Python.OutputGroup__Settings_FUNCTIONFORPROPERTYPREFIX_set_tefile_creation_enabled(self, te_file_creation_enabled)

    def _get_tefile_creation_enabled(self):
        r"""
        Indicates whether to create a $TE file when writing the output group.

        Returns
        -------
        bool
            A boolean indicating whether to create a $TE file.
        """
        return _ResultsAPI_Python.OutputGroup__get_tefile_creation_enabled(self)

    def _set_header_file_stats_enabled(self, header_file_stats_enabled):
        r"""
        Determines whether to write variable stats to the output group header file.

        Header file stats are enabled by default.

        Parameters
        ----------
        header_file_stats_enabled : bool
            `True` to enable; `False` to disable.

        Notes
        -----
        - Stats should be written when analysis of ultimate values will be performed on the output.
        - The following stats are included:

          - Ultimate values (ULOADS)
          - Minimum value indices (MINTIME)
          - Maximum value indices (MAXTIME)
          - Mean values (MEAN).
        - Disabling header file stats may improve write performance and conserve disk space.
        """
        return _ResultsAPI_Python.OutputGroup__Settings_FUNCTIONFORPROPERTYPREFIX_set_header_file_stats_enabled(self, header_file_stats_enabled)

    def _get_header_file_stats_enabled(self):
        r"""
        Indicates whether to write variable stats to the output group header file.

        Returns
        -------
        bool
            A boolean indicating whether to write variable stats.
        """
        return _ResultsAPI_Python.OutputGroup__get_header_file_stats_enabled(self)

    @property
    def tefile_creation_enabled(self) -> bool:
        r"""
        Determines whether to create a $TE file when writing the output group.

        $TE file creation is enabled by default.

        tefile_creation_enabled: `True` to enable; `False` to disable.

        Notes
        -----
        - Creating a $TE file allows Bladed outputs to be consumed via the Results API and Bladed Results Viewer.
        - The $TE file has the same filename as the output group.
        """
        return self._get_tefile_creation_enabled()

    @tefile_creation_enabled.setter
    def tefile_creation_enabled(self, value: bool):
        self._set_tefile_creation_enabled(value)


    @property
    def header_file_stats_enabled(self) -> bool:
        r"""
        Determines whether to write variable stats to the output group header file.

        Header file stats are enabled by default.

        header_file_stats_enabled: `True` to enable; `False` to disable.

        Notes
        -----
        - Stats should be written when analysis of ultimate values will be performed on the output.
        - The following stats are included:

          - Ultimate values (ULOADS)
          - Minimum value indices (MINTIME)
          - Maximum value indices (MAXTIME)
          - Mean values (MEAN).
        - Disabling header file stats may improve write performance and conserve disk space.
        """
        return self._get_header_file_stats_enabled()

    @header_file_stats_enabled.setter
    def header_file_stats_enabled(self, value: bool):
        self._set_header_file_stats_enabled(value)


    @property
    def path(self) -> str:
        r"""
        The header file path of the output group.
        """
        return self._get_path()


    @property
    def name(self) -> str:
        r"""
        The name of the output group.
        """
        return self._get_name()


    @property
    def file_format(self) -> int:
        r"""
        The file format of the output group.
        """
        return self._get_file_format()


    @property
    def data_source(self) -> str:
        r"""
        The data source of the output group.
        """
        return self._get_data_source()


    @property
    def config(self) -> str:
        r"""
        The data config value of the output group.
        """
        return self._get_config()


    @property
    def variable_data_format(self) -> int:
        r"""
        The data format of the output group.
        """
        return self._get_variable_data_format()


    @property
    def data_file_path(self) -> str:
        r"""
        The data file path of the output group.
        """
        return self._get_data_file_path()


    @property
    def number_of_variables(self) -> int:
        r"""
        The number of dependent variables added to the output group.
        """
        return self._get_number_of_variables()

    __swig_destroy__ = _ResultsAPI_Python.delete_OutputGroup

# Register OutputGroup in _ResultsAPI_Python:
_ResultsAPI_Python.OutputGroup_swigregister(OutputGroup)
class Run(object):
    r"""
    Class representing a Bladed run.

    Notes
    -----
    - Provides access to `Variable` objects, where each variable represents an output channel.
    - Use `Run.get_groups` to obtain a contiguous array of `Group` objects describing the content of the run.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def _get_name(self) -> str:
        r"""
        Gets the name of the run.

        Returns
        -------
        str
            A string containing the name of the run.

        Notes
        -----
        - The name returned is the filesystem name, not the CONTENT field of the group header file.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONFORPROPERTYPREFIX_get_name(self)

    def _get_directory(self) -> str:
        r"""
        Gets the canonicalised run directory with trailing path separator.

        Returns
        -------
        str
            A string containing the run directory.

        Notes
        -----
        - A canonicalised directory refers to the shortest absolute path to a directory. Canonicalisation allows result directories to be identified uniquely.
        - The path separator is portable across platforms.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONFORPROPERTYPREFIX_get_directory(self)

    def _get_termination_file_path(self) -> str:
        r"""
        Gets the full path to the run termination ($TE) file.

        Returns
        -------
        str
            A string containing the full path to the run termination file.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONFORPROPERTYPREFIX_get_termination_file_path(self)

    def _get_termination_file_content(self) -> str:
        r"""
        Gets the content of the run termination ($TE) file.

        Returns
        -------
        str
            A string containing the full content of the run termination file.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONFORPROPERTYPREFIX_get_termination_file_content(self)

    def _get_message_file_content(self) -> str:
        r"""
        Gets the content of the run message ($ME) file.

        Returns
        -------
        str
            A string containing the full content of the run message file.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONFORPROPERTYPREFIX_get_message_file_content(self)

    def _get_verification_file_content(self) -> str:
        r"""
        Gets the content of the run verification ($VE) file.

        Returns
        -------
        str
            A string containing the full content of the run verification file.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONFORPROPERTYPREFIX_get_verification_file_content(self)

    def _get_timestamp(self) -> str:
        r"""
        Gets the run timestamp in ISO 8601 format (YYYY-MM-DD hh:mm:ss).

        Returns
        -------
        str
            A string containing the run timestamp.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONFORPROPERTYPREFIX_get_timestamp(self)

    def _get_execution_duration_seconds(self):
        r"""
        Gets the run execution duration in seconds.

        Returns
        -------
        float
            A double-precision floating-point value indicating the run execution duration.

        Notes
        -----
        - Run execution duration is calculated by comparing the modification time of the run termination ($TE) file against that of the run verification ($VE) file.
        - Raises an exception if the returned time is negative - this indicates the $VE file was modified after the run completed.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONFORPROPERTYPREFIX_get_execution_duration_seconds(self)

    def _get_completion_state(self):
        r"""
        Gets the completion state of the run.

        Returns
        -------
        int
            An integer constant indicating the run completion state. Refer to individual `COMPLETION_STATE` constants for further information.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONFORPROPERTYPREFIX_get_completion_state(self)

    def _has_finished(self):
        r"""
        Indicates whether the run has finished.

        Returns
        -------
        bool
            A boolean indicating whether the run has finished. Use `Run.was_successful` for an indication of run success, or `Run.completion_state` for more precise state information.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONFORPROPERTYPREFIX_has_finished(self)

    def _was_successful(self):
        r"""
        Indicates whether the run completed successfully.

        Returns
        -------
        bool
            A boolean indicating whether the run completed successfully.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONFORPROPERTYPREFIX_was_successful(self)

    def _was_unsuccessful(self):
        r"""
        Indicates whether the run failed to complete successfully.

        Returns
        -------
        bool
            A boolean indicating whether the run failed to complete successfully.

        Notes
        -----
        - An unsuccessful run has one of the following `COMPLETION_STATE` values:

          - Terminated
          - Errored
          - Aborted
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONFORPROPERTYPREFIX_was_unsuccessful(self)

    def _get_calculation_descriptive_name(self) -> str:
        r"""
        Gets the descriptive name of the calculation.

        For example, a power production run returns the descriptive name 'Power production simulation'.

        Returns
        -------
        str
            A string containing a descriptive form of the calculation name.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONFORPROPERTYPREFIX_get_calculation_descriptive_name(self)

    def _get_calculation_type(self):
        r"""
        Gets the type of the calculation.

        Returns
        -------
        int
            An integer constant indicating the calculation type. Refer to individual `CALCULATION_TYPE` constants for further information.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONFORPROPERTYPREFIX_get_calculation_type(self)

    def _is_turbine_simulation(self):
        r"""
        Indicates whether the run is a turbine simulation.

        Returns
        -------
        bool
            A boolean indicating whether the run is a turbine simulation.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONFORPROPERTYPREFIX_is_turbine_simulation(self)

    def _is_supporting_calculation(self):
        r"""
        Indicates whether the run is a supporting calculation.

        Returns
        -------
        bool
            A boolean indicating whether the run is a supporting calculation.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONFORPROPERTYPREFIX_is_supporting_calculation(self)

    def _is_post_processing_calculation(self):
        r"""
        Indicates whether the run is a post-processing calculation.

        Returns
        -------
        bool
            A boolean indicating whether the run is a post-processing calculation.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONFORPROPERTYPREFIX_is_post_processing_calculation(self)

    def _is_calculation_type_supported(self):
        r"""
        Indicates whether the run is a calculation type that is supported by the Results API.

        Returns
        -------
        bool
            A boolean indicating whether the run is a supported calculation type.

        Notes
        -----
        - An unsupported calculation type typically contains data in a format that is not currently readable by the Results API. Support for reading such formats may be added in a future release.
        - By default, runs with an unsupported calculation type are filtered from request results.
        - Use `ResultsApi.SearchSettings` to include unsupported calculation types in the results.
        - Runs with an unsupported calculation type provide only limited metadata.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONFORPROPERTYPREFIX_is_calculation_type_supported(self)

    def contains_variable_1d(self, variable_name):
        r"""
        Indicates whether the run contains the one-dimensional variable with the specified name.

        Parameters
        ----------
        variable_name : str
            The name of the variable to enquire.

        Returns
        -------
        bool
            A boolean indicating whether the run contains the one-dimensional variable with the specified name.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        """
        return _ResultsAPI_Python.Run_contains_variable_1d(self, variable_name)

    def contains_variable_2d(self, variable_name):
        r"""
        Indicates whether the run contains the two-dimensional variable with the specified name.

        Parameters
        ----------
        variable_name : str
            The name of the variable to enquire.

        Returns
        -------
        bool
            A boolean indicating whether the run contains the two-dimensional variable with the specified name.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return _ResultsAPI_Python.Run_contains_variable_2d(self, variable_name)

    def _get_variable(self, variable_name: str) -> Variable:
        r"""
        Gets a base variable with the specified name.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.

        Returns
        -------
        Variable
            A base `Variable` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - A `Variable` object is the base type of one-dimensional variable (`Variable1D`) and two-dimensional variable (`Variable2D`) objects. It may be used to request metadata common to both one-dimensional and two-dimensional variables.
        - Use `Run.get_variable_1d` or `Run.get_variable_2d` as appropriate to obtain a variable that provides access to data.
        - Use `Run.get_variable_from_specific_group` to limit the search scope to a specific group. This is necessary when a run contains two or more dependent variables with the same name.
        """
        return _ResultsAPI_Python.Run__get_variable(self, variable_name)

    def _get_variable_from_specific_group(self, variable_name: str, specific_group_name: str) -> Variable:
        r"""
        Gets a base variable with the specified name and from the specified group.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.
        specific_group_name : str
            The name of the group containing the variable.

        Returns
        -------
        Variable
            A base `Variable` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - Group name comparison is case-insensitive.
        - Improves lookup performance by targeting a single group expected to contain the variable, and skipping other groups.
        - A `Variable` object is the base type of one-dimensional variable (`Variable1D`) and two-dimensional variable (`Variable2D`) objects. It may be used to request metadata common to both one-dimensional and two-dimensional variables.
        - Use `Run.get_variable_1d` or `Run.get_variable_2d` as appropriate to obtain a variable that provides access to data.
        """
        return _ResultsAPI_Python.Run__get_variable_from_specific_group(self, variable_name, specific_group_name)

    def unload_variable(self, variable_name):
        r"""
        Unloads a cached variable with the specified name.

        Parameters
        ----------
        variable_name : str
            The name of the variable to unload.

        Returns
        -------
        bool
            A boolean indicating whether the request succeeded.

        Notes
        -----
        - Function may be used to reduce memory consumption when operating on large datasets.
        - Variable name comparison is case-insensitive.
        """
        return _ResultsAPI_Python.Run_unload_variable(self, variable_name)

    def unload_variable_from_specific_group(self, variable_name, specific_group_name):
        r"""
        Unloads a cached variable with the specified name and from the specified group.

        Parameters
        ----------
        variable_name : str
            The name of the variable to unload.
        specific_group_name : str
            The name of the group containing the variable.

        Returns
        -------
        bool
            A boolean indicating whether the request succeeded.

        Notes
        -----
        - Function may be used to reduce memory consumption when operating on large datasets.
        - Variable name comparison is case-insensitive.
        - Group name comparison is case-insensitive.
        - Improves lookup performance by targeting a single group expected to contain the variable, and skipping other groups.
        """
        return _ResultsAPI_Python.Run_unload_variable_from_specific_group(self, variable_name, specific_group_name)

    def _get_group(self, group_name: str) -> Group:
        r"""
        Gets a specific group in the run.

        Parameters
        ----------
        group_name : str
            The name of the group to return.

        Returns
        -------
        Group
            A `Group` object.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONPREFIX_get_group(self, group_name)

    def _get_groups_native_array(self) -> ArrayOfGroup:
        r"""
        Gets all groups belonging to the run.

        Returns
        -------
        ArrayOfGroup
            A contiguous array of `Group` objects.

        Notes
        -----
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Run__get_groups_native_array(self)

    def _get_group_names_native_array(self) -> ArrayOfString:
        r"""
        Gets the names of all groups belonging to the run.

        Returns
        -------
        ArrayOfString
            A contiguous array of string values, with each string containing the name of a group in the run.

        Notes
        -----
        - The name of the group is indicated by the GENLAB field of the group header file.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Run__get_group_names_native_array(self)

    def _get_variable_names_native_array(self, remove_duplicates: bool=False) -> ArrayOfString:
        r"""
        Gets the names of all dependent variables belonging to the run.

        Duplicate variable names are included by default.

        Parameters
        ----------
        remove_duplicates : bool, optional
            `True` to remove duplicate variable names; `False` to include duplicates.

        Returns
        -------
        ArrayOfString
            A contiguous array of string values, with each string containing the name of a dependent variable in the group.

        Notes
        -----
        - Dependent variable names are indicated by the VARIAB field of the group header file.
        - Some runs may contain dependent variables with the same name in different groups. Removing duplicate variable names incurs a performance penalty.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Run__get_variable_names_native_array(self, remove_duplicates)

    @property
    def name(self) -> str:
        r"""
        The name of the run.

        Notes
        -----
        - The name returned is the filesystem name, not the CONTENT field of the group header file.
        """
        return self._get_name()


    @property
    def directory(self) -> str:
        r"""
        The canonicalised run directory with trailing path separator.

        Notes
        -----
        - A canonicalised directory refers to the shortest absolute path to a directory. Canonicalisation allows result directories to be identified uniquely.
        - The path separator is portable across platforms.
        """
        return self._get_directory()


    @property
    def termination_file_path(self) -> str:
        r"""
        The full path to the run termination ($TE) file.
        """
        return self._get_termination_file_path()


    @property
    def termination_file_content(self) -> str:
        r"""
        The content of the run termination ($TE) file.
        """
        return self._get_termination_file_content()


    @property
    def message_file_content(self) -> str:
        r"""
        The content of the run message ($ME) file.
        """
        return self._get_message_file_content()


    @property
    def verification_file_content(self) -> str:
        r"""
        The content of the run verification ($VE) file.
        """
        return self._get_verification_file_content()


    @property
    def timestamp(self) -> str:
        r"""
        The run timestamp in ISO 8601 format (YYYY-MM-DD hh:mm:ss).
        """
        return self._get_timestamp()


    @property
    def execution_duration_seconds(self) -> float:
        r"""
        The run execution duration in seconds.

        Notes
        -----
        - Run execution duration is calculated by comparing the modification time of the run termination ($TE) file against that of the run verification ($VE) file.
        - Raises an exception if the returned time is negative - this indicates the $VE file was modified after the run completed.
        """
        return self._get_execution_duration_seconds()


    @property
    def completion_state(self) -> int:
        r"""
        The completion state of the run.
        """
        return self._get_completion_state()


    @property
    def has_finished(self) -> bool:
        r"""
        Whether the run has finished.
        """
        return self._has_finished()


    @property
    def was_successful(self) -> bool:
        r"""
        Whether the run completed successfully.
        """
        return self._was_successful()


    @property
    def was_unsuccessful(self) -> bool:
        r"""
        Whether the run failed to complete successfully.

        Notes
        -----
        - An unsuccessful run has one of the following `COMPLETION_STATE` values:

          - Terminated
          - Errored
          - Aborted
        """
        return self._was_unsuccessful()


    @property
    def calculation_descriptive_name(self) -> str:
        r"""
        The descriptive name of the calculation.

        For example, a power production run returns the descriptive name 'Power production simulation'.
        """
        return self._get_calculation_descriptive_name()


    @property
    def calculation_type(self) -> int:
        r"""
        The type of the calculation.
        """
        return self._get_calculation_type()


    @property
    def is_turbine_simulation(self) -> bool:
        r"""
        Whether the run is a turbine simulation.
        """
        return self._is_turbine_simulation()


    @property
    def is_supporting_calculation(self) -> bool:
        r"""
        Whether the run is a supporting calculation.
        """
        return self._is_supporting_calculation()


    @property
    def is_post_processing_calculation(self) -> bool:
        r"""
        Whether the run is a post-processing calculation.
        """
        return self._is_post_processing_calculation()


    @property
    def is_calculation_type_supported(self) -> bool:
        r"""
        Whether the run is a calculation type that is supported by the Results API.

        Notes
        -----
        - An unsupported calculation type typically contains data in a format that is not currently readable by the Results API. Support for reading such formats may be added in a future release.
        - By default, runs with an unsupported calculation type are filtered from request results.
        - Use `ResultsApi.SearchSettings` to include unsupported calculation types in the results.
        - Runs with an unsupported calculation type provide only limited metadata.
        """
        return self._is_calculation_type_supported()



      # Create type agnostic wrappers for Variable1D/2D getters (avoids the user needing to specify the type)
    def get_variable_1d(self, variable_name: str) -> Variable1D_Float32 | Variable1D_Float64 | Variable1D_Int32:
        r"""
        Gets a one-dimensional variable with the specified name.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.

        Returns
        -------
        Variable1D_Float32 | Variable1D_Float64 | Variable1D_Int32
            A `Variable1D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        - Use `Run.get_variable_1d_from_specific_group` to limit the search scope to a specific group. This is necessary when a run contains two or more dependent variables with the same name.
        """
        variable = self._get_variable(variable_name)
        _print_status_message_if_available(variable)
        data_type = variable._get_data_type()
        if (data_type == VARIABLE_DATA_TYPE_FLOAT32):
            return self._get_variable_1d_float32(variable_name)
        elif (data_type == VARIABLE_DATA_TYPE_FLOAT64):
            return self._get_variable_1d_float64(variable_name)
        elif (data_type == VARIABLE_DATA_TYPE_INT32):
            return self._get_variable_1d_int32(variable_name)
        else:
            raise TypeError("Variable1D data type not supported: " + str(data_type))

    def get_variable_1d_from_specific_group(self, variable_name: str, specific_group_name: str) -> Variable1D_Float32 | Variable1D_Float64 | Variable1D_Int32:
        r"""
        Gets a one-dimensional variable with the specified name and from the specified group.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.
        specific_group_name : str
            The name of the group containing the variable.

        Returns
        -------
        Variable1D_Float32 | Variable1D_Float64 | Variable1D_Int32
            A `Variable1D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - Group name comparison is case-insensitive.
        - Improves lookup performance by targeting a single group expected to contain the variable, and skipping other groups.
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        """
        variable = self._get_variable_from_specific_group(variable_name, specific_group_name)
        _print_status_message_if_available(variable)
        data_type = variable._get_data_type()
        if (data_type == VARIABLE_DATA_TYPE_FLOAT32):
            return self._get_variable_1d_from_specific_group_float32(variable_name, specific_group_name)
        elif (data_type == VARIABLE_DATA_TYPE_FLOAT64):
            return self._get_variable_1d_from_specific_group_float64(variable_name, specific_group_name)
        elif (data_type == VARIABLE_DATA_TYPE_INT32):
            return self._get_variable_1d_from_specific_group_int32(variable_name, specific_group_name)
        else:
            raise TypeError("Variable1D data type not supported: " + str(data_type))

    def get_variable_2d(self, variable_name: str) -> Variable2D_Float32 | Variable2D_Float64 | Variable2D_Int32:
        r"""
        Gets a two-dimensional variable with the specified name.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.

        Returns
        -------
        Variable2D_Float32 | Variable2D_Float64 | Variable2D_Int32
            A `Variable2D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - Group name comparison is case-insensitive.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        variable = self._get_variable(variable_name)
        _print_status_message_if_available(variable)
        data_type = variable._get_data_type()
        if (data_type == VARIABLE_DATA_TYPE_FLOAT32):
            return self._get_variable_2d_float32(variable_name)
        elif (data_type == VARIABLE_DATA_TYPE_FLOAT64):
            return self._get_variable_2d_float64(variable_name)
        elif (data_type == VARIABLE_DATA_TYPE_INT32):
            return self._get_variable_2d_int32(variable_name)
        else:
            raise TypeError("Variable2D data type not supported: " + str(data_type))

    def get_variable_2d_from_specific_group(self, variable_name: str, specific_group_name: str) -> Variable2D_Float32 | Variable2D_Float64 | Variable2D_Int32:
        r"""
        Gets a two-dimensional variable with the specified name and from the specified group.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.
        specific_group_name : str
            The name of the group containing the variable.

        Returns
        -------
        Variable2D_Float32 | Variable2D_Float64 | Variable2D_Int32
            A `Variable2D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - Group name comparison is case-insensitive.
        - Improves lookup performance by targeting a single group expected to contain the variable, and skipping other groups.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        variable = self._get_variable_from_specific_group(variable_name, specific_group_name)
        _print_status_message_if_available(variable)
        data_type = variable._get_data_type()
        if (data_type == VARIABLE_DATA_TYPE_FLOAT32):
            return self._get_variable_2d_from_specific_group_float32(variable_name, specific_group_name)
        elif (data_type == VARIABLE_DATA_TYPE_FLOAT64):
            return self._get_variable_2d_from_specific_group_float64(variable_name, specific_group_name)
        elif (data_type == VARIABLE_DATA_TYPE_INT32):
            return self._get_variable_2d_from_specific_group_int32(variable_name, specific_group_name)
        else:
            raise TypeError("Variable2D data type not supported: " + str(data_type))

    def get_group(self, group_name: str) -> Group:
        r"""
        Gets a specific group in the run.

        Parameters
        ----------
        group_name : str
            The name of the group to return.

        Returns
        -------
        Group
            A `Group` object.
        """
        group = self._get_group(group_name)
        _print_status_message_if_available(group)
        return group

    # Wrapped vector to Numpy array conversion
    # Performs a copy but should be inexpensive as the underlying container is of type shared_ptr<Group>
    def get_groups(self) -> np.ndarray[Group]:
        r"""
        Gets all groups belonging to the run.

        Returns
        -------
        np.ndarray[Group]
            A NumPy `ndarray` of `Group` objects.

        Notes
        -----
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_groups_native_array` to avoid this penalty.
        """
        return np.asarray(self._get_groups_native_array())

    # Wrapped vector to Numpy array conversion
    # Performs a copy - unavoidable as std::string is not supported using PyArray_SimpleNewFromData
    def get_group_names(self) -> np.ndarray[str]:
        r"""
        Gets the names of all groups belonging to the run.

        Returns
        -------
        np.ndarray[str]
            A NumPy `ndarray` of string values, with each string containing the name of a group in the run.

        Notes
        -----
        - The name of the group is indicated by the GENLAB field of the group header file.
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_group_names_native_array` to avoid this penalty.
        """
        return np.asarray(self._get_group_names_native_array())

    # Wrapped vector to Numpy array conversion
    # Performs a copy - unavoidable as std::string is not supported using PyArray_SimpleNewFromData
    def get_variable_names(self, remove_duplicates: bool=False) -> np.ndarray[str]:
        r"""
        Gets the names of all dependent variables belonging to the run.

        Duplicate variable names are included by default.

        Parameters
        ----------
        remove_duplicates : bool, optional
            `True` to remove duplicate variable names; `False` to include duplicates.

        Returns
        -------
        np.ndarray[str]
            A NumPy `ndarray` of string values, with each string containing the name of a dependent variable in the group.

        Notes
        -----
        - Dependent variable names are indicated by the VARIAB field of the group header file.
        - Some runs may contain dependent variables with the same name in different groups. Removing duplicate variable names incurs a performance penalty.
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_variable_names_native_array` to avoid this penalty.
        """
        return np.asarray(self._get_variable_names_native_array(remove_duplicates))


    def _get_variable_1d_float32(self, variable_name: str) -> Variable1D_Float32:
        r"""
        Gets a one-dimensional variable with the specified name.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.

        Returns
        -------
        Variable1D_Float32
            A `Variable1D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        - Use `Run.get_variable_1d_from_specific_group` to limit the search scope to a specific group. This is necessary when a run contains two or more dependent variables with the same name.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONPREFIX_get_variable_1d_float32(self, variable_name)

    def _get_variable_1d_float64(self, variable_name: str) -> Variable1D_Float64:
        r"""
        Gets a one-dimensional variable with the specified name.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.

        Returns
        -------
        Variable1D_Float64
            A `Variable1D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        - Use `Run.get_variable_1d_from_specific_group` to limit the search scope to a specific group. This is necessary when a run contains two or more dependent variables with the same name.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONPREFIX_get_variable_1d_float64(self, variable_name)

    def _get_variable_1d_int32(self, variable_name: str) -> Variable1D_Int32:
        r"""
        Gets a one-dimensional variable with the specified name.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.

        Returns
        -------
        Variable1D_Int32
            A `Variable1D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        - Use `Run.get_variable_1d_from_specific_group` to limit the search scope to a specific group. This is necessary when a run contains two or more dependent variables with the same name.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONPREFIX_get_variable_1d_int32(self, variable_name)

    def _get_variable_1d_from_specific_group_float32(self, variable_name: str, specific_group_name: str) -> Variable1D_Float32:
        r"""
        Gets a one-dimensional variable with the specified name and from the specified group.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.
        specific_group_name : str
            The name of the group containing the variable.

        Returns
        -------
        Variable1D_Float32
            A `Variable1D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - Group name comparison is case-insensitive.
        - Improves lookup performance by targeting a single group expected to contain the variable, and skipping other groups.
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONPREFIX_get_variable_1d_from_specific_group_float32(self, variable_name, specific_group_name)

    def _get_variable_1d_from_specific_group_float64(self, variable_name: str, specific_group_name: str) -> Variable1D_Float64:
        r"""
        Gets a one-dimensional variable with the specified name and from the specified group.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.
        specific_group_name : str
            The name of the group containing the variable.

        Returns
        -------
        Variable1D_Float64
            A `Variable1D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - Group name comparison is case-insensitive.
        - Improves lookup performance by targeting a single group expected to contain the variable, and skipping other groups.
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONPREFIX_get_variable_1d_from_specific_group_float64(self, variable_name, specific_group_name)

    def _get_variable_1d_from_specific_group_int32(self, variable_name: str, specific_group_name: str) -> Variable1D_Int32:
        r"""
        Gets a one-dimensional variable with the specified name and from the specified group.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.
        specific_group_name : str
            The name of the group containing the variable.

        Returns
        -------
        Variable1D_Int32
            A `Variable1D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - Group name comparison is case-insensitive.
        - Improves lookup performance by targeting a single group expected to contain the variable, and skipping other groups.
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONPREFIX_get_variable_1d_from_specific_group_int32(self, variable_name, specific_group_name)

    def _get_variable_2d_float32(self, variable_name: str) -> Variable2D_Float32:
        r"""
        Gets a two-dimensional variable with the specified name.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.

        Returns
        -------
        Variable2D_Float32
            A `Variable2D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - Group name comparison is case-insensitive.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONPREFIX_get_variable_2d_float32(self, variable_name)

    def _get_variable_2d_float64(self, variable_name: str) -> Variable2D_Float64:
        r"""
        Gets a two-dimensional variable with the specified name.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.

        Returns
        -------
        Variable2D_Float64
            A `Variable2D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - Group name comparison is case-insensitive.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONPREFIX_get_variable_2d_float64(self, variable_name)

    def _get_variable_2d_int32(self, variable_name: str) -> Variable2D_Int32:
        r"""
        Gets a two-dimensional variable with the specified name.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.

        Returns
        -------
        Variable2D_Int32
            A `Variable2D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - Group name comparison is case-insensitive.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONPREFIX_get_variable_2d_int32(self, variable_name)

    def _get_variable_2d_from_specific_group_float32(self, variable_name: str, specific_group_name: str) -> Variable2D_Float32:
        r"""
        Gets a two-dimensional variable with the specified name and from the specified group.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.
        specific_group_name : str
            The name of the group containing the variable.

        Returns
        -------
        Variable2D_Float32
            A `Variable2D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - Group name comparison is case-insensitive.
        - Improves lookup performance by targeting a single group expected to contain the variable, and skipping other groups.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONPREFIX_get_variable_2d_from_specific_group_float32(self, variable_name, specific_group_name)

    def _get_variable_2d_from_specific_group_float64(self, variable_name: str, specific_group_name: str) -> Variable2D_Float64:
        r"""
        Gets a two-dimensional variable with the specified name and from the specified group.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.
        specific_group_name : str
            The name of the group containing the variable.

        Returns
        -------
        Variable2D_Float64
            A `Variable2D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - Group name comparison is case-insensitive.
        - Improves lookup performance by targeting a single group expected to contain the variable, and skipping other groups.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONPREFIX_get_variable_2d_from_specific_group_float64(self, variable_name, specific_group_name)

    def _get_variable_2d_from_specific_group_int32(self, variable_name: str, specific_group_name: str) -> Variable2D_Int32:
        r"""
        Gets a two-dimensional variable with the specified name and from the specified group.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.
        specific_group_name : str
            The name of the group containing the variable.

        Returns
        -------
        Variable2D_Int32
            A `Variable2D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - Group name comparison is case-insensitive.
        - Improves lookup performance by targeting a single group expected to contain the variable, and skipping other groups.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return _ResultsAPI_Python.Run__Run_FUNCTIONPREFIX_get_variable_2d_from_specific_group_int32(self, variable_name, specific_group_name)
    __swig_destroy__ = _ResultsAPI_Python.delete_Run

# Register Run in _ResultsAPI_Python:
_ResultsAPI_Python.Run_swigregister(Run)
cvar = _ResultsAPI_Python.cvar
Run.termination_file_extension = _ResultsAPI_Python.cvar.Run_termination_file_extension
Run.verification_file_extension = _ResultsAPI_Python.cvar.Run_verification_file_extension
Run.message_file_extension = _ResultsAPI_Python.cvar.Run_message_file_extension

class Group(object):
    r"""
    Class representing a Bladed group.

    Notes
    -----
    - A group contains a set of related variables, grouped together for convenience. For example, the group 'Tower member loads - local coordinates' contains variables describing the components of load at selected member ends of a multi-member tower.
    - Provides access to dependent (`Variable`; `Variable1D`; `Variable2D`) and independent variable (`IndependentVariable`) objects.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def _get_name(self) -> str:
        r"""
        Gets the name of the group.

        Returns
        -------
        str
            A string containing the name of the group.

        Notes
        -----
        - The name of the group is indicated by the GENLAB field of the group header file.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONFORPROPERTYPREFIX_get_name(self)

    def _get_number(self):
        r"""
        Gets the number of the group.

        Returns
        -------
        int
            A positive integer indicating the number of the group.

        Notes
        -----
        - The group number is unique within a given run.
        - The group number is used in the group's file extension.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONFORPROPERTYPREFIX_get_number(self)

    def _get_header_file_path(self) -> str:
        r"""
        Gets the canonicalised group header file path.

        Returns
        -------
        str
            A string containing the group header file path.

        Notes
        -----
        - A canonicalised directory refers to the shortest absolute path to a directory. Canonicalisation allows result directories to be uniquely identified.
        - The path separator is portable across platforms.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONFORPROPERTYPREFIX_get_header_file_path(self)

    def _get_number_of_variables(self):
        r"""
        Gets the number of dependent variables.

        Returns
        -------
        int
            A positive integer indicating the number of dependent variables.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONFORPROPERTYPREFIX_get_number_of_variables(self)

    def _get_number_of_independent_variables(self):
        r"""
        Gets the number of independent variables (1 or 2).

        Returns
        -------
        int
            A positive integer indicating the number of independent variables.

        Notes
        -----
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONFORPROPERTYPREFIX_get_number_of_independent_variables(self)

    def _is_one_dimensional(self):
        r"""
        Indicates whether the group contains one-dimensional dependent variables.

        Returns
        -------
        bool
            A boolean indicating whether the group contains one-dimensional dependent variables.

        Notes
        -----
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        - A group many contain either one-dimensional or two-dimensional variables, but not both.
        - The number of dimensions is equivalent to the number of independent variables in the group. Bladed groups have a maximum of two dimensions.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONFORPROPERTYPREFIX_is_one_dimensional(self)

    def _is_two_dimensional(self):
        r"""
        Indicates whether the group contains two-dimensional dependent variables.

        Returns
        -------
        bool
            A boolean indicating whether the group contains two-dimensional dependent variables.

        Notes
        -----
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        - A group many contain either one-dimensional or two-dimensional variables, but not both.
        - The number of dimensions is equivalent to the number of independent variables in the group. Bladed groups have a maximum of two dimensions.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONFORPROPERTYPREFIX_is_two_dimensional(self)

    def _get_variable_names_native_array(self) -> ArrayOfString:
        r"""
        Gets the names of all dependent variables belonging to the group.

        Returns
        -------
        ArrayOfString
            A contiguous array of string values, with each string containing the name of a variable in the group.

        Notes
        -----
        - Dependent variable names are indicated by the VARIAB field of the group header file.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Group__get_variable_names_native_array(self)

    def contains_variable_1d(self, variable_name):
        r"""
        Indicates whether the group contains the one-dimensional variable with the specified name.

        Parameters
        ----------
        variable_name : str
            The name of the variable to enquire.

        Returns
        -------
        bool
            A boolean indicating whether the group contains the one-dimensional variable with the specified name.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        """
        return _ResultsAPI_Python.Group_contains_variable_1d(self, variable_name)

    def contains_variable_2d(self, variable_name):
        r"""
        Indicates whether the group contains the two-dimensional variable with the specified name.

        Parameters
        ----------
        variable_name : str
            The name of the variable to enquire.

        Returns
        -------
        bool
            A boolean indicating whether the group contains the two-dimensional variable with the specified name.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return _ResultsAPI_Python.Group_contains_variable_2d(self, variable_name)

    def get_independent_variable(self, *args) -> IndependentVariable:
        r"""
        **Function variant 1:**

        Gets the independent variable with the specified string name.

        Returns
        -------
        IndependentVariable
            An `IndependentVariable` object.

        Notes
        -----
        - The name of the independent variable is indicated by the AXISLAB field of the group header file.
        - In a time domain simulation, a two-dimensional variable object (`Variable2D`) contains two independent variables:

          - a primary independent variable: time
          - a secondary independent variable: typically a measurement location (e.g. distance along blade).

        - Independent variable name comparison is case-insensitive.

        |

        **Function variant 2:**

        Gets the independent variable with the specified key.

        Returns
        -------
        IndependentVariable
            An `IndependentVariable` object.

        Notes
        -----
        - The name of the independent variable is indicated by the AXISLAB field of the group header file.
        - In a time domain simulation, a two-dimensional variable object (`Variable2D`) contains two independent variables:

          - a primary independent variable: time
          - a secondary independent variable: typically a measurement location (e.g. distance along blade).


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (str): The name of the independent variable to return.

            **Function variant 2:**
              - arg1 (int): The `INDEPENDENT_VARIABLE_ID` key value identifying the independent variable to return.
        """
        return _ResultsAPI_Python.Group_get_independent_variable(self, *args)

    def _get_independent_variables_native_array(self) -> ArrayOfIndependentVariable:
        r"""
        Gets all independent variables belonging to the group.

        Returns
        -------
        ArrayOfIndependentVariable
            A contiguous array of `IndependentVariable` objects.

        Notes
        -----
        - An independent variable name is indicated by the AXISLAB field of the group header file.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Group__get_independent_variables_native_array(self)

    def _get_calculation_short_name(self) -> str:
        r"""
        Gets the short name of the calculation.

        Returns
        -------
        str
            A string containing the short name of the calculation.

        Notes
        -----
        - The calculation short name is indicated by the CONTENT field of the group header file.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONFORPROPERTYPREFIX_get_calculation_short_name(self)

    def _get_calculation_descriptive_name(self) -> str:
        r"""
        Gets the descriptive name of the calculation.

        For example, a group belonging to a power production run returns the descriptive name `Power production simulation`.

        Returns
        -------
        str
            A string containing the descriptive name of the calculation.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONFORPROPERTYPREFIX_get_calculation_descriptive_name(self)

    def _get_calculation_type(self):
        r"""
        Gets the type of the calculation.

        Returns
        -------
        int
            An integer constant indicating the calculation type. Refer to individual `CALCULATION_TYPE` constants for further information.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONFORPROPERTYPREFIX_get_calculation_type(self)

    def _get_time_domain_simulation_length(self):
        r"""
        Gets the length in seconds of the time domain simulation.

        Returns
        -------
        float
            A double-precision floating-point value containing the simulation length in seconds.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - Use `Run.execution_duration_seconds` to get the wall-clock duration of a calculation.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONFORPROPERTYPREFIX_get_time_domain_simulation_length(self)

    def _get_time_domain_simulation_output_timestep(self):
        r"""
        Gets the output timestep used in the time domain simulation.

        Returns
        -------
        float
            A double-precision floating-point value containing the output timestep.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - The output timestep is indicated by the STEP field of the group header file.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONFORPROPERTYPREFIX_get_time_domain_simulation_output_timestep(self)

    def _get_time_domain_simulation_output_start_time(self):
        r"""
        Gets the output start time used in the time domain simulation. This is the time at which outputs were initially written.

        Returns
        -------
        float
            A double-precision floating-point value containing the output start time.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - The output start time is indicated by the MIN field of the group header file.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONFORPROPERTYPREFIX_get_time_domain_simulation_output_start_time(self)

    def _get_data_point_count(self):
        r"""
        Gets the number of data points recorded per variable in the group. In a time domain simulation, this is equivalent to the number of output timesteps.

        Returns
        -------
        int
            A positive integer indicating the number of data points recorded.

        Notes
        -----
        - For a one-dimensional group (a group comprising one-dimensional dependent variables), returns the number of data points recorded for any given variable.
        - For a two-dimensional group (a group comprising two-dimensional dependent variables), returns the number of data points recorded for any given secondary independent variable (not the aggregate count of all secondary independent variables).
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONFORPROPERTYPREFIX_get_data_point_count(self)

    def _get_variable_data_type(self):
        r"""
        Gets the data type of the group. This matches the data type of all dependent variables in the group.

        Returns
        -------
        int
            An integer constant indicating the data type of the group. Refer to individual `VARIABLE_DATA_TYPE` constants for further information.

        Notes
        -----
        - Data type returned may differ from the serialised data type if client has specified a target data type.
        - Use `ResultsApi.CacheSettings` to set the data type to use globally.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONFORPROPERTYPREFIX_get_variable_data_type(self)

    def _get_variable_data_format(self):
        r"""
        Gets the data format of the group. This matches the data format of all dependent variables in the group.

        Returns
        -------
        int
            An integer constant indicating the data format of the group. Refer to individual `VARIABLE_DATA_FORMAT` constants for further information.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONFORPROPERTYPREFIX_get_variable_data_format(self)

    def _get_last_status_message(self):
        r"""
        Gets the last status message for the group.

        Returns
        -------
        str
            A string containing the last status message for the group.

        Notes
        -----
        - The status message is used to relay information that a user may need to be aware of, but does not qualify as an error.
        """
        return _ResultsAPI_Python.Group__get_last_status_message(self)

    def _has_status_message(self):
        r"""
        Indicates whether the group has a status message.

        Returns
        -------
        bool
            A boolean indicating whether the group has a status message.
        """
        return _ResultsAPI_Python.Group__has_status_message(self)

    @property
    def name(self) -> str:
        r"""
        The name of the group.

        Notes
        -----
        - The name of the group is indicated by the GENLAB field of the group header file.
        """
        return self._get_name()


    @property
    def number(self) -> int:
        r"""
        The number of the group.

        Notes
        -----
        - The group number is unique within a given run.
        - The group number is used in the group's file extension.
        """
        return self._get_number()


    @property
    def header_file_path(self) -> str:
        r"""
        The canonicalised group header file path.

        Notes
        -----
        - A canonicalised directory refers to the shortest absolute path to a directory. Canonicalisation allows result directories to be uniquely identified.
        - The path separator is portable across platforms.
        """
        return self._get_header_file_path()


    @property
    def number_of_variables(self) -> int:
        r"""
        The number of dependent variables.
        """
        return self._get_number_of_variables()


    @property
    def number_of_independent_variables(self) -> int:
        r"""
        The number of independent variables (1 or 2).

        Notes
        -----
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return self._get_number_of_independent_variables()


    @property
    def is_one_dimensional(self) -> bool:
        r"""
        Whether the group contains one-dimensional dependent variables.

        Notes
        -----
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        - A group many contain either one-dimensional or two-dimensional variables, but not both.
        - The number of dimensions is equivalent to the number of independent variables in the group. Bladed groups have a maximum of two dimensions.
        """
        return self._is_one_dimensional()


    @property
    def is_two_dimensional(self) -> bool:
        r"""
        Whether the group contains two-dimensional dependent variables.

        Notes
        -----
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        - A group many contain either one-dimensional or two-dimensional variables, but not both.
        - The number of dimensions is equivalent to the number of independent variables in the group. Bladed groups have a maximum of two dimensions.
        """
        return self._is_two_dimensional()


    @property
    def calculation_short_name(self) -> str:
        r"""
        The short name of the calculation.

        Notes
        -----
        - The calculation short name is indicated by the CONTENT field of the group header file.
        """
        return self._get_calculation_short_name()


    @property
    def calculation_descriptive_name(self) -> str:
        r"""
        The descriptive name of the calculation.

        For example, a group belonging to a power production run returns the descriptive name `Power production simulation`.
        """
        return self._get_calculation_descriptive_name()


    @property
    def calculation_type(self) -> int:
        r"""
        The type of the calculation.
        """
        return self._get_calculation_type()


    @property
    def time_domain_simulation_length(self) -> float:
        r"""
        The length in seconds of the time domain simulation.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - Use `Run.execution_duration_seconds` to get the wall-clock duration of a calculation.
        """
        return self._get_time_domain_simulation_length()


    @property
    def time_domain_simulation_output_timestep(self) -> float:
        r"""
        The output timestep used in the time domain simulation.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - The output timestep is indicated by the STEP field of the group header file.
        """
        return self._get_time_domain_simulation_output_timestep()


    @property
    def time_domain_simulation_output_start_time(self) -> float:
        r"""
        The output start time used in the time domain simulation. This is the time at which outputs were initially written.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - The output start time is indicated by the MIN field of the group header file.
        """
        return self._get_time_domain_simulation_output_start_time()


    @property
    def data_point_count(self) -> int:
        r"""
        The number of data points recorded per variable in the group. In a time domain simulation, this is equivalent to the number of output timesteps.

        Notes
        -----
        - For a one-dimensional group (a group comprising one-dimensional dependent variables), returns the number of data points recorded for any given variable.
        - For a two-dimensional group (a group comprising two-dimensional dependent variables), returns the number of data points recorded for any given secondary independent variable (not the aggregate count of all secondary independent variables).
        """
        return self._get_data_point_count()


    @property
    def variable_data_type(self) -> int:
        r"""
        The data type of the group. This matches the data type of all dependent variables in the group.

        Notes
        -----
        - Data type returned may differ from the serialised data type if client has specified a target data type.
        - Use `ResultsApi.CacheSettings` to set the data type to use globally.
        """
        return self._get_variable_data_type()


    @property
    def variable_data_format(self) -> int:
        r"""
        The data format of the group. This matches the data format of all dependent variables in the group.
        """
        return self._get_variable_data_format()



      # Create type agnostic wrappers for Variable1D/2D getters (avoids the user needing to specify the type)
    def get_variable_1d(self, variable_name: str) -> Variable1D_Float32 | Variable1D_Float64 | Variable1D_Int32:
        r"""
        Gets a one-dimensional variable with the specified name.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.

        Returns
        -------
        Variable1D_Float32 | Variable1D_Float64 | Variable1D_Int32
            A `Variable1D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        """
        data_type = self.variable_data_type
        if (data_type == VARIABLE_DATA_TYPE_FLOAT32):
            variable = self._get_variable_1d_float32(variable_name)
        elif (data_type == VARIABLE_DATA_TYPE_FLOAT64):
            variable = self._get_variable_1d_float64(variable_name)
        elif (data_type == VARIABLE_DATA_TYPE_INT32):
            variable = self._get_variable_1d_int32(variable_name)
        else:
            raise TypeError("Variable1D data type not supported: " + str(data_type))
        _print_status_message_if_available(variable)
        return variable

    # Native array, type agnostic
    def _get_variables_1d_native_array(self) -> ArrayOfVariable1D_Float32 | ArrayOfVariable1D_Float64 | ArrayOfVariable1D_Int32:
        r"""
        Gets all one-dimensional variables belonging to the group.

        Returns
        -------
        ArrayOfVariable1D_Float32 | ArrayOfVariable1D_Float64 | ArrayOfVariable1D_Int32
            A contiguous array of `Variable1D` objects.

        Notes
        -----
        - The group must be one-dimensional (containing dependent variables of subtype `Variable1D`) for the call to succeed.
        - Dependent variable names are indicated by the VARIAB field of the group header file.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        data_type = self.variable_data_type
        if (data_type == VARIABLE_DATA_TYPE_FLOAT32):
            return np.asarray(self._get_variables_1d_float32_native_array())
        elif (data_type == VARIABLE_DATA_TYPE_FLOAT64):
            return np.asarray(self._get_variables_1d_float64_native_array())
        elif (data_type == VARIABLE_DATA_TYPE_INT32):
            return np.asarray(self._get_variables_1d_int32_native_array())
        else:
            raise TypeError("Variable1D data type not supported: " + str(data_type))

    # Wrapped vector to Numpy array conversion
    # Performs a copy but should be inexpensive as the underlying container is of type shared_ptr<Variable1D>
    def get_variables_1d(self) -> np.ndarray[Variable1D_Float32] | np.ndarray[Variable1D_Float64] | np.ndarray[Variable1D_Int32]:
        r"""
        Gets all one-dimensional variables belonging to the group.

        Returns
        -------
        np.ndarray[Variable1D_Float32] | np.ndarray[Variable1D_Float64] | np.ndarray[Variable1D_Int32]
            A NumPy `ndarray` of `Variable1D` objects.

        Notes
        -----
        - The group must be one-dimensional (containing dependent variables of subtype `Variable1D`) for the call to succeed.
        - Dependent variable names are indicated by the VARIAB field of the group header file.
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_variables_1d_native_array` to avoid this penalty.
        """
        return np.asarray(self._get_variables_1d_native_array())

    def get_variable_2d(self, variable_name: str) -> Variable2D_Float32 | Variable2D_Float64 | Variable2D_Int32:
        r"""
        Gets a two-dimensional variable with the specified name.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.

        Returns
        -------
        Variable2D_Float32 | Variable2D_Float64 | Variable2D_Int32
            A `Variable2D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - Group name comparison is case-insensitive.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        data_type = self.variable_data_type
        if (data_type == VARIABLE_DATA_TYPE_FLOAT32):
            variable = self._get_variable_2d_float32(variable_name)
        elif (data_type == VARIABLE_DATA_TYPE_FLOAT64):
            variable = self._get_variable_2d_float64(variable_name)
        elif (data_type == VARIABLE_DATA_TYPE_INT32):
            variable = self._get_variable_2d_int32(variable_name)
        else:
            raise TypeError("Variable2D data type not supported: " + str(data_type))
        _print_status_message_if_available(variable)
        return variable

    # Native array, type agnostic
    def _get_variables_2d_native_array(self) -> ArrayOfVariable2D_Float32 | ArrayOfVariable2D_Float64 | ArrayOfVariable2D_Int32:
        r"""
        Gets all two-dimensional variables belonging to the group.

        Returns
        -------
        ArrayOfVariable2D_Float32 | ArrayOfVariable2D_Float64 | ArrayOfVariable2D_Int32
            A contiguous array of `Variable2D` objects.

        Notes
        -----
        - The group must be two-dimensional (containing dependent variables of subtype `Variable2D`) for the call to succeed.
        - Dependent variable names are indicated by the VARIAB field of the group header file.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        data_type = self.variable_data_type
        if (data_type == VARIABLE_DATA_TYPE_FLOAT32):
            return np.asarray(self._get_variables_2d_float32_native_array())
        elif (data_type == VARIABLE_DATA_TYPE_FLOAT64):
            return np.asarray(self._get_variables_2d_float64_native_array())
        elif (data_type == VARIABLE_DATA_TYPE_INT32):
            return np.asarray(self._get_variables_2d_int32_native_array())
        else:
            raise TypeError("Variable2D data type not supported: " + str(data_type))

    # Wrapped vector to Numpy array conversion
    # Performs a copy but should be inexpensive as the underlying container is of type shared_ptr<Variable2D>
    def get_variables_2d(self) -> np.ndarray[Variable2D_Float32] | np.ndarray[Variable2D_Float64] | np.ndarray[Variable2D_Int32]:
        r"""
        Gets all two-dimensional variables belonging to the group.

        Returns
        -------
        np.ndarray[Variable2D_Float32] | np.ndarray[Variable2D_Float64] | np.ndarray[Variable2D_Int32]
            A NumPy `ndarray` of `Variable2D` objects.

        Notes
        -----
        - The group must be two-dimensional (containing dependent variables of subtype `Variable2D`) for the call to succeed.
        - Dependent variable names are indicated by the VARIAB field of the group header file.
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_variables_2d_native_array` to avoid this penalty.
        """
        return np.asarray(self._get_variables_2d_native_array())

    # Wrapped vector to Numpy array conversion
    # Performs a copy - unavoidable as std::string is not supported using PyArray_SimpleNewFromData
    def get_variable_names(self) -> np.ndarray[str]:
        r"""
        Gets the names of all dependent variables belonging to the group.

        Returns
        -------
        np.ndarray[str]
            A NumPy `ndarray` of string values, with each string containing the name of a variable in the group.

        Notes
        -----
        - Dependent variable names are indicated by the VARIAB field of the group header file.
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_variable_names_native_array` to avoid this penalty.
        """
        return np.asarray(self._get_variable_names_native_array())

    # Wrapped vector to Numpy array conversion
    # Performs a copy but should be inexpensive as the underlying container is of type shared_ptr<IndependentVariable>
    def get_independent_variables(self) -> np.ndarray[IndependentVariable]:
        r"""
        Gets all independent variables belonging to the group.

        Returns
        -------
        np.ndarray[IndependentVariable]
            A NumPy `ndarray` of `IndependentVariable` objects.

        Notes
        -----
        - An independent variable name is indicated by the AXISLAB field of the group header file.
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_independent_variables_native_array` to avoid this penalty.
        """
        return np.asarray(self._get_independent_variables_native_array())


    def _get_variable_1d_float32(self, variable_name: str) -> Variable1D_Float32:
        r"""
        Gets a one-dimensional variable with the specified name.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.

        Returns
        -------
        Variable1D_Float32
            A `Variable1D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONPREFIX_get_variable_1d_float32(self, variable_name)

    def _get_variable_1d_float64(self, variable_name: str) -> Variable1D_Float64:
        r"""
        Gets a one-dimensional variable with the specified name.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.

        Returns
        -------
        Variable1D_Float64
            A `Variable1D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONPREFIX_get_variable_1d_float64(self, variable_name)

    def _get_variable_1d_int32(self, variable_name: str) -> Variable1D_Int32:
        r"""
        Gets a one-dimensional variable with the specified name.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.

        Returns
        -------
        Variable1D_Int32
            A `Variable1D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONPREFIX_get_variable_1d_int32(self, variable_name)

    def _get_variables_1d_float32_native_array(self) -> ArrayOfVariable1D_Float32:
        r"""
        Gets all one-dimensional variables belonging to the group.

        Returns
        -------
        ArrayOfVariable1D_Float32
            A contiguous array of `Variable1D` objects.

        Notes
        -----
        - The group must be one-dimensional (containing dependent variables of subtype `Variable1D`) for the call to succeed.
        - Dependent variable names are indicated by the VARIAB field of the group header file.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONPREFIX_get_variables_1d_float32_native_array(self)

    def _get_variables_1d_float64_native_array(self) -> ArrayOfVariable1D_Float64:
        r"""
        Gets all one-dimensional variables belonging to the group.

        Returns
        -------
        ArrayOfVariable1D_Float64
            A contiguous array of `Variable1D` objects.

        Notes
        -----
        - The group must be one-dimensional (containing dependent variables of subtype `Variable1D`) for the call to succeed.
        - Dependent variable names are indicated by the VARIAB field of the group header file.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONPREFIX_get_variables_1d_float64_native_array(self)

    def _get_variables_1d_int32_native_array(self) -> ArrayOfVariable1D_Int32:
        r"""
        Gets all one-dimensional variables belonging to the group.

        Returns
        -------
        ArrayOfVariable1D_Int32
            A contiguous array of `Variable1D` objects.

        Notes
        -----
        - The group must be one-dimensional (containing dependent variables of subtype `Variable1D`) for the call to succeed.
        - Dependent variable names are indicated by the VARIAB field of the group header file.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONPREFIX_get_variables_1d_int32_native_array(self)

    def _get_variable_2d_float32(self, variable_name: str) -> Variable2D_Float32:
        r"""
        Gets a two-dimensional variable with the specified name.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.

        Returns
        -------
        Variable2D_Float32
            A `Variable2D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - Group name comparison is case-insensitive.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONPREFIX_get_variable_2d_float32(self, variable_name)

    def _get_variable_2d_float64(self, variable_name: str) -> Variable2D_Float64:
        r"""
        Gets a two-dimensional variable with the specified name.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.

        Returns
        -------
        Variable2D_Float64
            A `Variable2D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - Group name comparison is case-insensitive.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONPREFIX_get_variable_2d_float64(self, variable_name)

    def _get_variable_2d_int32(self, variable_name: str) -> Variable2D_Int32:
        r"""
        Gets a two-dimensional variable with the specified name.

        Parameters
        ----------
        variable_name : str
            The name of the variable to get.

        Returns
        -------
        Variable2D_Int32
            A `Variable2D` object.

        Notes
        -----
        - Variable name comparison is case-insensitive.
        - Group name comparison is case-insensitive.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONPREFIX_get_variable_2d_int32(self, variable_name)

    def _get_variables_2d_float32_native_array(self) -> ArrayOfVariable2D_Float32:
        r"""
        Gets all two-dimensional variables belonging to the group.

        Returns
        -------
        ArrayOfVariable2D_Float32
            A contiguous array of `Variable2D` objects.

        Notes
        -----
        - The group must be two-dimensional (containing dependent variables of subtype `Variable2D`) for the call to succeed.
        - Dependent variable names are indicated by the VARIAB field of the group header file.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONPREFIX_get_variables_2d_float32_native_array(self)

    def _get_variables_2d_float64_native_array(self) -> ArrayOfVariable2D_Float64:
        r"""
        Gets all two-dimensional variables belonging to the group.

        Returns
        -------
        ArrayOfVariable2D_Float64
            A contiguous array of `Variable2D` objects.

        Notes
        -----
        - The group must be two-dimensional (containing dependent variables of subtype `Variable2D`) for the call to succeed.
        - Dependent variable names are indicated by the VARIAB field of the group header file.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONPREFIX_get_variables_2d_float64_native_array(self)

    def _get_variables_2d_int32_native_array(self) -> ArrayOfVariable2D_Int32:
        r"""
        Gets all two-dimensional variables belonging to the group.

        Returns
        -------
        ArrayOfVariable2D_Int32
            A contiguous array of `Variable2D` objects.

        Notes
        -----
        - The group must be two-dimensional (containing dependent variables of subtype `Variable2D`) for the call to succeed.
        - Dependent variable names are indicated by the VARIAB field of the group header file.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Group__Group_FUNCTIONPREFIX_get_variables_2d_int32_native_array(self)
    __swig_destroy__ = _ResultsAPI_Python.delete_Group

# Register Group in _ResultsAPI_Python:
_ResultsAPI_Python.Group_swigregister(Group)
class RunsIterator(object):
    r"""
    Class for discovering and returning the next run in a sequence. Supports asynchronous processing by clients.

    Provides features for searching a directory tree for Bladed runs, but instead of returning all runs
    in a single call as per `ResultsApi.get_runs`, each call to `RunsIterator.get_next_run` returns only
    the next run in the sequence.

    This allows clients to process returned runs asynchronously, without waiting for all runs that match the search
    criteria to be found.

    Multiple `RunsIterator` objects may be used at the same time to increase throughput.
    Each `RunsIterator` object should operate on a dedicated directory tree (avoiding overlap with the directories being
    processed by another `RunsIterator` object) to avoid returning duplicate runs.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        **Function variant 1:**

        Creates a new `RunsIterator` object to match runs sequentially with the specified name.

        Returns
        -------
        RunsIterator
            A new `RunsIterator` object.

        Notes
        -----
        - Use `ResultsApi.SearchSettings` to filter runs based on properties such as calculation type.
        - Run name comparison is case-insensitive by default. Use `ResultsApi.SearchSettings` to change the case sensitivity setting.

        |

        **Function variant 2:**

        Creates a new `RunsIterator` object to match all runs sequentially regardless of name.

        Returns
        -------
        RunsIterator
            A new `RunsIterator` object.

        Notes
        -----
        - Use `ResultsApi.SearchSettings` to filter runs based on properties such as calculation type.

        |

        **Function variant 3:**

        Creates a new `RunsIterator` object to match all runs sequentially regardless of name.

        Returns
        -------
        RunsIterator
            A new `RunsIterator` object.

        Notes
        -----
        - Use `ResultsApi.SearchSettings` to filter runs based on properties such as calculation type.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (str): The directory where the search will begin.
              - arg2 (str): The run name to match.
              - arg3 (int, optional): An integer constant indicating whether to recursively include subdirectories in the search. Default = `SEARCH_SCOPE_RECURSIVE_SEARCH`. Refer to individual `SEARCH_SCOPE` constants for further information.

            **Function variant 2:**
              - arg1 (str): The directory where the search will begin.
              - arg2 (int, optional): An integer constant indicating whether to recursively include subdirectories in the search. Default = `SEARCH_SCOPE_RECURSIVE_SEARCH`. Refer to individual `SEARCH_SCOPE` constants for further information.

            **Function variant 3:**
              - arg1 (str): The directory where the search will begin.
        """
        _ResultsAPI_Python.RunsIterator_swiginit(self, _ResultsAPI_Python.new_RunsIterator(*args))

    def get_next_run(self) -> Run:
        r"""
        Gets the next run in the sequence according to the search criteria.

        Returns
        -------
        Run
            The next `Run` object in the sequence, or null if there is no match.
        """
        return _ResultsAPI_Python.RunsIterator_get_next_run(self)
    __swig_destroy__ = _ResultsAPI_Python.delete_RunsIterator

# Register RunsIterator in _ResultsAPI_Python:
_ResultsAPI_Python.RunsIterator_swigregister(RunsIterator)
class RunsIteratorRegex(RunsIterator):
    r"""
    Class for discovering and returning the next run in a sequence using a regular expression to describe the run name.

    Supports asynchronous processing by clients. See `RunsIterator` documentation for detailed description.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Creates a new `RunsIteratorRegex` object to match runs sequentially with name matching the specified regular expression.

        Parameters
        ----------
        *args : tuple
            Variable length argument list.

            - **arg1**
              (str) : The directory where the search will begin.

            - **arg2**
              (str) : A regular expression describing the run name to match.

            - **arg3**
              (int, optional) : An integer constant indicating whether to recursively include subdirectories in the search. Default = `SEARCH_SCOPE_RECURSIVE_SEARCH`. Refer to individual `SEARCH_SCOPE` constants for further information.

        Returns
        -------
        RunsIteratorRegex
            A new `RunsIteratorRegex` object.

        Notes
        -----
        - Use `ResultsApi.SearchSettings` to filter runs based on properties such as calculation type.
        - Run name comparison is case-insensitive by default. Use `ResultsApi.SearchSettings` to change the case sensitivity setting.
        """
        _ResultsAPI_Python.RunsIteratorRegex_swiginit(self, _ResultsAPI_Python.new_RunsIteratorRegex(*args))
    __swig_destroy__ = _ResultsAPI_Python.delete_RunsIteratorRegex

# Register RunsIteratorRegex in _ResultsAPI_Python:
_ResultsAPI_Python.RunsIteratorRegex_swigregister(RunsIteratorRegex)
class ResultsApi(object):
    r"""
    Entry point to the Results API. The Results API provides features for:

    - Searching a directory tree for Bladed runs.
    - Finding variables in runs.
    - Getting data from variables.
    - Reporting run and variable metadata.
    - Writing user-defined output groups.

    Notes
    -----
    - Each Bladed run is represented by a `Run` object.

      - A `Run` object provides access to the dependent and independent variables within the run.
      - A `Run` object also provides information about the groups within the run.
    - Each variable is represented by a `Variable` object. A `Variable` may have either one or two dimensions, and is represented by the following sub-types:

      - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
      - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def get_run(directory: str, run_name: str) -> Run:
        r"""
        Gets a single run from the specified directory and with the specified name.

        Parameters
        ----------
        directory : str
            The directory to search.
        run_name : str
            The run name to match.

        Returns
        -------
        Run
            A `Run` object, if a match is found.

        Notes
        -----
        - Search is not recursive.
        - To get runs with a specific name in a directory tree, use `ResultsApi.get_runs_matching_name`.
        - Run name comparison is case-insensitive by default. Use `ResultsApi.SearchSettings` to change the case sensitivity setting.
        """
        return _ResultsAPI_Python.ResultsApi_get_run(directory, run_name)

    @staticmethod
    def _get_runs_native_array(*args) -> ArrayOfRun:
        r"""
        Gets all runs starting in the root directory.

        Searches subdirectories unless recursion is disabled.

        Parameters
        ----------
        *args : tuple
            Variable length argument list.

            - **arg1**
              (str) : The directory where the search will begin.

            - **arg2**
              (int, optional) : An integer constant indicating whether to recursively include subdirectories in the search. Default = `SEARCH_SCOPE_RECURSIVE_SEARCH`. Refer to individual `SEARCH_SCOPE` constants for further information.

        Returns
        -------
        ArrayOfRun
            A contiguous array of `Run` objects.

        Notes
        -----
        - Search may take a long time to complete depending on the number of runs, and on network performance if searching network shares.
        - Use `ResultsApi.SearchSettings` to filter runs based on properties such as calculation type.
        - To get runs with a specific name, use `ResultsApi.get_runs_matching_name` or `ResultsApi.get_runs_matching_name_regex`.
        - To find and asynchronously process runs, use `RunsIterator`. Methods in the `ResultsApi` class do not guarantee thread safety.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.ResultsApi__get_runs_native_array(*args)

    @staticmethod
    def _get_runs_matching_name_native_array(*args) -> ArrayOfRun:
        r"""
        Gets all runs with the specified name, starting in the root directory.

        Searches subdirectories unless recursion is disabled.

        Parameters
        ----------
        *args : tuple
            Variable length argument list.

            - **arg1**
              (str) : The directory where the search will begin.

            - **arg2**
              (str) : The run name to match.

            - **arg3**
              (int, optional) : An integer constant indicating whether to recursively include subdirectories in the search. Default = `SEARCH_SCOPE_RECURSIVE_SEARCH`. Refer to individual `SEARCH_SCOPE` constants for further information.

        Returns
        -------
        ArrayOfRun
            A contiguous array of `Run` objects.

        Notes
        -----
        - To get runs with name matching a regular expression in a directory tree, use `ResultsApi.get_runs_matching_name_regex`.
        - Use `ResultsApi.SearchSettings` to filter runs based on properties such as calculation type.
        - Run name comparison is case-insensitive by default. Use `ResultsApi.SearchSettings` to change the case sensitivity setting.
        - To find and asynchronously process runs with a specific name, use `RunsIterator`. Methods in the `ResultsApi` class do not guarantee thread safety.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.ResultsApi__get_runs_matching_name_native_array(*args)

    @staticmethod
    def _get_runs_matching_name_regex_native_array(*args) -> ArrayOfRun:
        r"""
        Gets all runs with name matching the specified regular expression, starting in the root directory.

        Searches subdirectories unless recursion is disabled.

        Parameters
        ----------
        *args : tuple
            Variable length argument list.

            - **arg1**
              (str) : The directory where the search will begin.

            - **arg2**
              (str) : A regular expression describing the run name to match.

            - **arg3**
              (int, optional) : An integer constant indicating whether to recursively include subdirectories in the search. Default = `SEARCH_SCOPE_RECURSIVE_SEARCH`. Refer to individual `SEARCH_SCOPE` constants for further information.

        Returns
        -------
        ArrayOfRun
            A contiguous array of `Run` objects.

        Notes
        -----
        - Use `ResultsApi.SearchSettings` to filter runs based on properties such as calculation type.
        - Run name comparison is case-insensitive by default. Use `ResultsApi.SearchSettings` to change the case sensitivity setting.
        - To find and asynchronously process runs with name matching a regular expression, use `RunsIteratorRegex`. Methods in the `ResultsApi` class do not guarantee thread safety.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.ResultsApi__get_runs_matching_name_regex_native_array(*args)

    @staticmethod
    def clear_runs():
        r"""
        Removes all runs from the cache.

        Notes
        -----
        - Use `ResultsApi.CacheSettings` to disable or enable caching.
        - `Run` objects returned by the `RunsIterator` are not added to the cache.
        - The memory is freed when the last reference to a `Run` goes out of scope.
        - Once removed from the cache, a `Run` remains in memory until it goes out of scope in calling code.
        """
        return _ResultsAPI_Python.ResultsApi_clear_runs()

    @staticmethod
    def write_output(*args):
        r"""
        Writes user-defined output.

        Parameters
        ----------
        *args : tuple
            Variable length argument list.

            - **arg1**
              (IOutputSpecification) : An output specification object (based on an `IOutputSpecification`) containing variables and their data.

            - **arg2**
              (int, optional) : An integer constant indicating whether to overwrite existing output with file path matching that defined by `outputSpec`. Default = `OVERWRITE_BEHAVIOUR_OVERWRITE_EXISTING_OUTPUT`. Refer to individual `OVERWRITE_BEHAVIOUR` constants for further information.

        Returns
        -------
        bool
            A boolean indicating whether the output was successfully written.

        Notes
        -----
        - If using `OVERWRITE_BEHAVIOUR_DO_NOT_OVERWRITE_EXISTING_OUTPUT` and existing output is present, the function returns `False`.
        """
        return _ResultsAPI_Python.ResultsApi_write_output(*args)

    @staticmethod
    def _get_search_settings():
        r"""_get_search_settings() -> _ResultsApi_SearchSettings"""
        return _ResultsAPI_Python.ResultsApi__get_search_settings()

    @staticmethod
    def _get_cache_settings():
        r"""_get_cache_settings() -> _ResultsApi_CacheSettings"""
        return _ResultsAPI_Python.ResultsApi__get_cache_settings()


      # Wrapped vector to Numpy array conversion
      # Performs a copy but should be inexpensive as the underlying container is of type shared_ptr<Run>
    @staticmethod
    def get_runs(root_directory: str, search_scope = SEARCH_SCOPE_RECURSIVE_SEARCH) -> np.ndarray[Run]:
        r"""
        Gets all runs starting in the root directory.

        Searches subdirectories unless recursion is disabled.

        Parameters
        ----------
        root_directory : str
            The directory where the search will begin.
        search_scope : int, optional
            An integer constant indicating whether to recursively include subdirectories in the search. Default = `SEARCH_SCOPE_RECURSIVE_SEARCH`. Refer to individual `SEARCH_SCOPE` constants for further information.

        Returns
        -------
        np.ndarray[Run]
            A NumPy `ndarray` of `Run` objects.

        Notes
        -----
        - Search may take a long time to complete depending on the number of runs, and on network performance if searching network shares.
        - Use `ResultsApi.SearchSettings` to filter runs based on properties such as calculation type.
        - To get runs with a specific name, use `ResultsApi.get_runs_matching_name` or `ResultsApi.get_runs_matching_name_regex`.
        - To find and asynchronously process runs, use `RunsIterator`. Methods in the `ResultsApi` class do not guarantee thread safety.
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_runs_native_array` to avoid this penalty.
        """
        return np.asarray(ResultsApi._get_runs_native_array(root_directory, search_scope))

    # Wrapped vector to Numpy array conversion
    # Performs a copy but should be inexpensive as the underlying container is of type shared_ptr<Run>
    @staticmethod
    def get_runs_matching_name(root_directory: str, run_name: str, search_scope = SEARCH_SCOPE_RECURSIVE_SEARCH) -> np.ndarray[Run]:
        r"""
        Gets all runs with the specified name, starting in the root directory.

        Searches subdirectories unless recursion is disabled.

        Parameters
        ----------
        root_directory : str
            The directory where the search will begin.
        run_name : str
            The run name to match.
        search_scope : int, optional
            An integer constant indicating whether to recursively include subdirectories in the search. Default = `SEARCH_SCOPE_RECURSIVE_SEARCH`. Refer to individual `SEARCH_SCOPE` constants for further information.

        Returns
        -------
        np.ndarray[Run]
            A NumPy `ndarray` of `Run` objects.

        Notes
        -----
        - To get runs with name matching a regular expression in a directory tree, use `ResultsApi.get_runs_matching_name_regex`.
        - Use `ResultsApi.SearchSettings` to filter runs based on properties such as calculation type.
        - Run name comparison is case-insensitive by default. Use `ResultsApi.SearchSettings` to change the case sensitivity setting.
        - To find and asynchronously process runs with a specific name, use `RunsIterator`. Methods in the `ResultsApi` class do not guarantee thread safety.
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_runs_matching_name_native_array` to avoid this penalty.
        """
        return np.asarray(ResultsApi._get_runs_matching_name_native_array(root_directory, run_name, search_scope))

    # Wrapped vector to Numpy array conversion
    # Performs a copy but should be inexpensive as the underlying container is of type shared_ptr<Run>
    @staticmethod
    def get_runs_matching_name_regex(root_directory: str, run_name_regex_pattern: str, search_scope = SEARCH_SCOPE_RECURSIVE_SEARCH) -> np.ndarray[Run]:
        r"""
        Gets all runs with name matching the specified regular expression, starting in the root directory.

        Searches subdirectories unless recursion is disabled.

        Parameters
        ----------
        root_directory : str
            The directory where the search will begin.
        run_name_regex_pattern : str
            A regular expression describing the run name to match.
        search_scope : int, optional
            An integer constant indicating whether to recursively include subdirectories in the search. Default = `SEARCH_SCOPE_RECURSIVE_SEARCH`. Refer to individual `SEARCH_SCOPE` constants for further information.

        Returns
        -------
        np.ndarray[Run]
            A NumPy `ndarray` of `Run` objects.

        Notes
        -----
        - Use `ResultsApi.SearchSettings` to filter runs based on properties such as calculation type.
        - Run name comparison is case-insensitive by default. Use `ResultsApi.SearchSettings` to change the case sensitivity setting.
        - To find and asynchronously process runs with name matching a regular expression, use `RunsIteratorRegex`. Methods in the `ResultsApi` class do not guarantee thread safety.
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_runs_matching_name_regex_native_array` to avoid this penalty.
        """
        return np.asarray(ResultsApi._get_runs_matching_name_regex_native_array(root_directory, run_name_regex_pattern, search_scope))

    # Property getters for cache and search settings (property is readonly - intentionally no setters)
    @staticproperty
    def SearchSettings() -> _ResultsApi_SearchSettings:
        r"""Contains global settings for controlling how runs are filtered in a request."""
        return ResultsApi._get_search_settings()

    @staticproperty
    def CacheSettings() -> _ResultsApi_CacheSettings:
        r"""Contains global settings for controlling how data is read and cached."""
        return ResultsApi._get_cache_settings()

    __swig_destroy__ = _ResultsAPI_Python.delete_ResultsApi

# Register ResultsApi in _ResultsAPI_Python:
_ResultsAPI_Python.ResultsApi_swigregister(ResultsApi)
class ArrayOfFloat(object):
    r"""Proxy of C++ std::vector< float > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(ArrayOfFloat self) -> SwigPyIterator"""

        return _ResultsAPI_Python.ArrayOfFloat_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(ArrayOfFloat self) -> bool"""
        return _ResultsAPI_Python.ArrayOfFloat___nonzero__(self)

    def __bool__(self):
        r"""__bool__(ArrayOfFloat self) -> bool"""
        return _ResultsAPI_Python.ArrayOfFloat___bool__(self)

    def __len__(self):
        r"""__len__(ArrayOfFloat self) -> std::vector< float >::size_type"""
        return _ResultsAPI_Python.ArrayOfFloat___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(ArrayOfFloat self, std::vector< float >::difference_type i, std::vector< float >::difference_type j) -> ArrayOfFloat"""
        return _ResultsAPI_Python.ArrayOfFloat___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(ArrayOfFloat self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)
        __setslice__(ArrayOfFloat self, std::vector< float >::difference_type i, std::vector< float >::difference_type j, ArrayOfFloat v)
        """
        return _ResultsAPI_Python.ArrayOfFloat___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(ArrayOfFloat self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)"""
        return _ResultsAPI_Python.ArrayOfFloat___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(ArrayOfFloat self, std::vector< float >::difference_type i)
        __delitem__(ArrayOfFloat self, SWIGPY_SLICEOBJECT * slice)
        """
        return _ResultsAPI_Python.ArrayOfFloat___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(ArrayOfFloat self, SWIGPY_SLICEOBJECT * slice) -> ArrayOfFloat
        __getitem__(ArrayOfFloat self, std::vector< float >::difference_type i) -> std::vector< float >::value_type const &
        """
        return _ResultsAPI_Python.ArrayOfFloat___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(ArrayOfFloat self, SWIGPY_SLICEOBJECT * slice, ArrayOfFloat v)
        __setitem__(ArrayOfFloat self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(ArrayOfFloat self, std::vector< float >::difference_type i, std::vector< float >::value_type const & x)
        """
        return _ResultsAPI_Python.ArrayOfFloat___setitem__(self, *args)

    def __init__(self, *args):
        r"""
        __init__(ArrayOfFloat self) -> ArrayOfFloat
        __init__(ArrayOfFloat self, ArrayOfFloat other) -> ArrayOfFloat
        __init__(ArrayOfFloat self, std::vector< float >::size_type size) -> ArrayOfFloat
        __init__(ArrayOfFloat self, std::vector< float >::size_type size, std::vector< float >::value_type const & value) -> ArrayOfFloat
        """
        _ResultsAPI_Python.ArrayOfFloat_swiginit(self, _ResultsAPI_Python.new_ArrayOfFloat(*args))
    __swig_destroy__ = _ResultsAPI_Python.delete_ArrayOfFloat

# Register ArrayOfFloat in _ResultsAPI_Python:
_ResultsAPI_Python.ArrayOfFloat_swigregister(ArrayOfFloat)
class ArrayOfDouble(object):
    r"""Proxy of C++ std::vector< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(ArrayOfDouble self) -> SwigPyIterator"""

        return _ResultsAPI_Python.ArrayOfDouble_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(ArrayOfDouble self) -> bool"""
        return _ResultsAPI_Python.ArrayOfDouble___nonzero__(self)

    def __bool__(self):
        r"""__bool__(ArrayOfDouble self) -> bool"""
        return _ResultsAPI_Python.ArrayOfDouble___bool__(self)

    def __len__(self):
        r"""__len__(ArrayOfDouble self) -> std::vector< double >::size_type"""
        return _ResultsAPI_Python.ArrayOfDouble___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(ArrayOfDouble self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> ArrayOfDouble"""
        return _ResultsAPI_Python.ArrayOfDouble___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(ArrayOfDouble self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        __setslice__(ArrayOfDouble self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, ArrayOfDouble v)
        """
        return _ResultsAPI_Python.ArrayOfDouble___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(ArrayOfDouble self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _ResultsAPI_Python.ArrayOfDouble___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(ArrayOfDouble self, std::vector< double >::difference_type i)
        __delitem__(ArrayOfDouble self, SWIGPY_SLICEOBJECT * slice)
        """
        return _ResultsAPI_Python.ArrayOfDouble___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(ArrayOfDouble self, SWIGPY_SLICEOBJECT * slice) -> ArrayOfDouble
        __getitem__(ArrayOfDouble self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _ResultsAPI_Python.ArrayOfDouble___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(ArrayOfDouble self, SWIGPY_SLICEOBJECT * slice, ArrayOfDouble v)
        __setitem__(ArrayOfDouble self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(ArrayOfDouble self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _ResultsAPI_Python.ArrayOfDouble___setitem__(self, *args)

    def __init__(self, *args):
        r"""
        __init__(ArrayOfDouble self) -> ArrayOfDouble
        __init__(ArrayOfDouble self, ArrayOfDouble other) -> ArrayOfDouble
        __init__(ArrayOfDouble self, std::vector< double >::size_type size) -> ArrayOfDouble
        __init__(ArrayOfDouble self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> ArrayOfDouble
        """
        _ResultsAPI_Python.ArrayOfDouble_swiginit(self, _ResultsAPI_Python.new_ArrayOfDouble(*args))
    __swig_destroy__ = _ResultsAPI_Python.delete_ArrayOfDouble

# Register ArrayOfDouble in _ResultsAPI_Python:
_ResultsAPI_Python.ArrayOfDouble_swigregister(ArrayOfDouble)
class ArrayOfInt(object):
    r"""Proxy of C++ std::vector< int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(ArrayOfInt self) -> SwigPyIterator"""

        return _ResultsAPI_Python.ArrayOfInt_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(ArrayOfInt self) -> bool"""
        return _ResultsAPI_Python.ArrayOfInt___nonzero__(self)

    def __bool__(self):
        r"""__bool__(ArrayOfInt self) -> bool"""
        return _ResultsAPI_Python.ArrayOfInt___bool__(self)

    def __len__(self):
        r"""__len__(ArrayOfInt self) -> std::vector< int >::size_type"""
        return _ResultsAPI_Python.ArrayOfInt___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(ArrayOfInt self, std::vector< int >::difference_type i, std::vector< int >::difference_type j) -> ArrayOfInt"""
        return _ResultsAPI_Python.ArrayOfInt___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(ArrayOfInt self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)
        __setslice__(ArrayOfInt self, std::vector< int >::difference_type i, std::vector< int >::difference_type j, ArrayOfInt v)
        """
        return _ResultsAPI_Python.ArrayOfInt___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(ArrayOfInt self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)"""
        return _ResultsAPI_Python.ArrayOfInt___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(ArrayOfInt self, std::vector< int >::difference_type i)
        __delitem__(ArrayOfInt self, SWIGPY_SLICEOBJECT * slice)
        """
        return _ResultsAPI_Python.ArrayOfInt___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(ArrayOfInt self, SWIGPY_SLICEOBJECT * slice) -> ArrayOfInt
        __getitem__(ArrayOfInt self, std::vector< int >::difference_type i) -> std::vector< int >::value_type const &
        """
        return _ResultsAPI_Python.ArrayOfInt___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(ArrayOfInt self, SWIGPY_SLICEOBJECT * slice, ArrayOfInt v)
        __setitem__(ArrayOfInt self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(ArrayOfInt self, std::vector< int >::difference_type i, std::vector< int >::value_type const & x)
        """
        return _ResultsAPI_Python.ArrayOfInt___setitem__(self, *args)

    def __init__(self, *args):
        r"""
        __init__(ArrayOfInt self) -> ArrayOfInt
        __init__(ArrayOfInt self, ArrayOfInt other) -> ArrayOfInt
        __init__(ArrayOfInt self, std::vector< int >::size_type size) -> ArrayOfInt
        __init__(ArrayOfInt self, std::vector< int >::size_type size, std::vector< int >::value_type const & value) -> ArrayOfInt
        """
        _ResultsAPI_Python.ArrayOfInt_swiginit(self, _ResultsAPI_Python.new_ArrayOfInt(*args))
    __swig_destroy__ = _ResultsAPI_Python.delete_ArrayOfInt

# Register ArrayOfInt in _ResultsAPI_Python:
_ResultsAPI_Python.ArrayOfInt_swigregister(ArrayOfInt)
class ArrayOfArrayOfFloat(object):
    r"""Proxy of C++ std::vector< std::vector< float > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(ArrayOfArrayOfFloat self) -> SwigPyIterator"""

        return _ResultsAPI_Python.ArrayOfArrayOfFloat_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(ArrayOfArrayOfFloat self) -> bool"""
        return _ResultsAPI_Python.ArrayOfArrayOfFloat___nonzero__(self)

    def __bool__(self):
        r"""__bool__(ArrayOfArrayOfFloat self) -> bool"""
        return _ResultsAPI_Python.ArrayOfArrayOfFloat___bool__(self)

    def __len__(self):
        r"""__len__(ArrayOfArrayOfFloat self) -> std::vector< std::vector< float > >::size_type"""
        return _ResultsAPI_Python.ArrayOfArrayOfFloat___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(ArrayOfArrayOfFloat self, std::vector< std::vector< float > >::difference_type i, std::vector< std::vector< float > >::difference_type j) -> ArrayOfArrayOfFloat"""
        return _ResultsAPI_Python.ArrayOfArrayOfFloat___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(ArrayOfArrayOfFloat self, std::vector< std::vector< float > >::difference_type i, std::vector< std::vector< float > >::difference_type j)
        __setslice__(ArrayOfArrayOfFloat self, std::vector< std::vector< float > >::difference_type i, std::vector< std::vector< float > >::difference_type j, ArrayOfArrayOfFloat v)
        """
        return _ResultsAPI_Python.ArrayOfArrayOfFloat___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(ArrayOfArrayOfFloat self, std::vector< std::vector< float > >::difference_type i, std::vector< std::vector< float > >::difference_type j)"""
        return _ResultsAPI_Python.ArrayOfArrayOfFloat___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(ArrayOfArrayOfFloat self, std::vector< std::vector< float > >::difference_type i)
        __delitem__(ArrayOfArrayOfFloat self, SWIGPY_SLICEOBJECT * slice)
        """
        return _ResultsAPI_Python.ArrayOfArrayOfFloat___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(ArrayOfArrayOfFloat self, SWIGPY_SLICEOBJECT * slice) -> ArrayOfArrayOfFloat
        __getitem__(ArrayOfArrayOfFloat self, std::vector< std::vector< float > >::difference_type i) -> ArrayOfFloat
        """
        return _ResultsAPI_Python.ArrayOfArrayOfFloat___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(ArrayOfArrayOfFloat self, SWIGPY_SLICEOBJECT * slice, ArrayOfArrayOfFloat v)
        __setitem__(ArrayOfArrayOfFloat self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(ArrayOfArrayOfFloat self, std::vector< std::vector< float > >::difference_type i, ArrayOfFloat x)
        """
        return _ResultsAPI_Python.ArrayOfArrayOfFloat___setitem__(self, *args)

    def __init__(self, *args):
        r"""
        __init__(ArrayOfArrayOfFloat self) -> ArrayOfArrayOfFloat
        __init__(ArrayOfArrayOfFloat self, ArrayOfArrayOfFloat other) -> ArrayOfArrayOfFloat
        __init__(ArrayOfArrayOfFloat self, std::vector< std::vector< float > >::size_type size) -> ArrayOfArrayOfFloat
        __init__(ArrayOfArrayOfFloat self, std::vector< std::vector< float > >::size_type size, ArrayOfFloat value) -> ArrayOfArrayOfFloat
        """
        _ResultsAPI_Python.ArrayOfArrayOfFloat_swiginit(self, _ResultsAPI_Python.new_ArrayOfArrayOfFloat(*args))
    __swig_destroy__ = _ResultsAPI_Python.delete_ArrayOfArrayOfFloat

# Register ArrayOfArrayOfFloat in _ResultsAPI_Python:
_ResultsAPI_Python.ArrayOfArrayOfFloat_swigregister(ArrayOfArrayOfFloat)
class ArrayOfArrayOfDouble(object):
    r"""Proxy of C++ std::vector< std::vector< double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(ArrayOfArrayOfDouble self) -> SwigPyIterator"""

        return _ResultsAPI_Python.ArrayOfArrayOfDouble_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(ArrayOfArrayOfDouble self) -> bool"""
        return _ResultsAPI_Python.ArrayOfArrayOfDouble___nonzero__(self)

    def __bool__(self):
        r"""__bool__(ArrayOfArrayOfDouble self) -> bool"""
        return _ResultsAPI_Python.ArrayOfArrayOfDouble___bool__(self)

    def __len__(self):
        r"""__len__(ArrayOfArrayOfDouble self) -> std::vector< std::vector< double > >::size_type"""
        return _ResultsAPI_Python.ArrayOfArrayOfDouble___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(ArrayOfArrayOfDouble self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j) -> ArrayOfArrayOfDouble"""
        return _ResultsAPI_Python.ArrayOfArrayOfDouble___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(ArrayOfArrayOfDouble self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)
        __setslice__(ArrayOfArrayOfDouble self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j, ArrayOfArrayOfDouble v)
        """
        return _ResultsAPI_Python.ArrayOfArrayOfDouble___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(ArrayOfArrayOfDouble self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)"""
        return _ResultsAPI_Python.ArrayOfArrayOfDouble___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(ArrayOfArrayOfDouble self, std::vector< std::vector< double > >::difference_type i)
        __delitem__(ArrayOfArrayOfDouble self, SWIGPY_SLICEOBJECT * slice)
        """
        return _ResultsAPI_Python.ArrayOfArrayOfDouble___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(ArrayOfArrayOfDouble self, SWIGPY_SLICEOBJECT * slice) -> ArrayOfArrayOfDouble
        __getitem__(ArrayOfArrayOfDouble self, std::vector< std::vector< double > >::difference_type i) -> ArrayOfDouble
        """
        return _ResultsAPI_Python.ArrayOfArrayOfDouble___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(ArrayOfArrayOfDouble self, SWIGPY_SLICEOBJECT * slice, ArrayOfArrayOfDouble v)
        __setitem__(ArrayOfArrayOfDouble self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(ArrayOfArrayOfDouble self, std::vector< std::vector< double > >::difference_type i, ArrayOfDouble x)
        """
        return _ResultsAPI_Python.ArrayOfArrayOfDouble___setitem__(self, *args)

    def __init__(self, *args):
        r"""
        __init__(ArrayOfArrayOfDouble self) -> ArrayOfArrayOfDouble
        __init__(ArrayOfArrayOfDouble self, ArrayOfArrayOfDouble other) -> ArrayOfArrayOfDouble
        __init__(ArrayOfArrayOfDouble self, std::vector< std::vector< double > >::size_type size) -> ArrayOfArrayOfDouble
        __init__(ArrayOfArrayOfDouble self, std::vector< std::vector< double > >::size_type size, ArrayOfDouble value) -> ArrayOfArrayOfDouble
        """
        _ResultsAPI_Python.ArrayOfArrayOfDouble_swiginit(self, _ResultsAPI_Python.new_ArrayOfArrayOfDouble(*args))
    __swig_destroy__ = _ResultsAPI_Python.delete_ArrayOfArrayOfDouble

# Register ArrayOfArrayOfDouble in _ResultsAPI_Python:
_ResultsAPI_Python.ArrayOfArrayOfDouble_swigregister(ArrayOfArrayOfDouble)
class ArrayOfArrayOfInt(object):
    r"""Proxy of C++ std::vector< std::vector< int > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(ArrayOfArrayOfInt self) -> SwigPyIterator"""

        return _ResultsAPI_Python.ArrayOfArrayOfInt_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(ArrayOfArrayOfInt self) -> bool"""
        return _ResultsAPI_Python.ArrayOfArrayOfInt___nonzero__(self)

    def __bool__(self):
        r"""__bool__(ArrayOfArrayOfInt self) -> bool"""
        return _ResultsAPI_Python.ArrayOfArrayOfInt___bool__(self)

    def __len__(self):
        r"""__len__(ArrayOfArrayOfInt self) -> std::vector< std::vector< int > >::size_type"""
        return _ResultsAPI_Python.ArrayOfArrayOfInt___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(ArrayOfArrayOfInt self, std::vector< std::vector< int > >::difference_type i, std::vector< std::vector< int > >::difference_type j) -> ArrayOfArrayOfInt"""
        return _ResultsAPI_Python.ArrayOfArrayOfInt___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(ArrayOfArrayOfInt self, std::vector< std::vector< int > >::difference_type i, std::vector< std::vector< int > >::difference_type j)
        __setslice__(ArrayOfArrayOfInt self, std::vector< std::vector< int > >::difference_type i, std::vector< std::vector< int > >::difference_type j, ArrayOfArrayOfInt v)
        """
        return _ResultsAPI_Python.ArrayOfArrayOfInt___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(ArrayOfArrayOfInt self, std::vector< std::vector< int > >::difference_type i, std::vector< std::vector< int > >::difference_type j)"""
        return _ResultsAPI_Python.ArrayOfArrayOfInt___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(ArrayOfArrayOfInt self, std::vector< std::vector< int > >::difference_type i)
        __delitem__(ArrayOfArrayOfInt self, SWIGPY_SLICEOBJECT * slice)
        """
        return _ResultsAPI_Python.ArrayOfArrayOfInt___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(ArrayOfArrayOfInt self, SWIGPY_SLICEOBJECT * slice) -> ArrayOfArrayOfInt
        __getitem__(ArrayOfArrayOfInt self, std::vector< std::vector< int > >::difference_type i) -> ArrayOfInt
        """
        return _ResultsAPI_Python.ArrayOfArrayOfInt___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(ArrayOfArrayOfInt self, SWIGPY_SLICEOBJECT * slice, ArrayOfArrayOfInt v)
        __setitem__(ArrayOfArrayOfInt self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(ArrayOfArrayOfInt self, std::vector< std::vector< int > >::difference_type i, ArrayOfInt x)
        """
        return _ResultsAPI_Python.ArrayOfArrayOfInt___setitem__(self, *args)

    def __init__(self, *args):
        r"""
        __init__(ArrayOfArrayOfInt self) -> ArrayOfArrayOfInt
        __init__(ArrayOfArrayOfInt self, ArrayOfArrayOfInt other) -> ArrayOfArrayOfInt
        __init__(ArrayOfArrayOfInt self, std::vector< std::vector< int > >::size_type size) -> ArrayOfArrayOfInt
        __init__(ArrayOfArrayOfInt self, std::vector< std::vector< int > >::size_type size, ArrayOfInt value) -> ArrayOfArrayOfInt
        """
        _ResultsAPI_Python.ArrayOfArrayOfInt_swiginit(self, _ResultsAPI_Python.new_ArrayOfArrayOfInt(*args))
    __swig_destroy__ = _ResultsAPI_Python.delete_ArrayOfArrayOfInt

# Register ArrayOfArrayOfInt in _ResultsAPI_Python:
_ResultsAPI_Python.ArrayOfArrayOfInt_swigregister(ArrayOfArrayOfInt)
class ArrayOfString(object):
    r"""Proxy of C++ std::vector< std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(ArrayOfString self) -> SwigPyIterator"""

        return _ResultsAPI_Python.ArrayOfString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(ArrayOfString self) -> bool"""
        return _ResultsAPI_Python.ArrayOfString___nonzero__(self)

    def __bool__(self):
        r"""__bool__(ArrayOfString self) -> bool"""
        return _ResultsAPI_Python.ArrayOfString___bool__(self)

    def __len__(self):
        r"""__len__(ArrayOfString self) -> std::vector< std::string >::size_type"""
        return _ResultsAPI_Python.ArrayOfString___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(ArrayOfString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> ArrayOfString"""
        return _ResultsAPI_Python.ArrayOfString___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(ArrayOfString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)
        __setslice__(ArrayOfString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, ArrayOfString v)
        """
        return _ResultsAPI_Python.ArrayOfString___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(ArrayOfString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)"""
        return _ResultsAPI_Python.ArrayOfString___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(ArrayOfString self, std::vector< std::string >::difference_type i)
        __delitem__(ArrayOfString self, SWIGPY_SLICEOBJECT * slice)
        """
        return _ResultsAPI_Python.ArrayOfString___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(ArrayOfString self, SWIGPY_SLICEOBJECT * slice) -> ArrayOfString
        __getitem__(ArrayOfString self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &
        """
        return _ResultsAPI_Python.ArrayOfString___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(ArrayOfString self, SWIGPY_SLICEOBJECT * slice, ArrayOfString v)
        __setitem__(ArrayOfString self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(ArrayOfString self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)
        """
        return _ResultsAPI_Python.ArrayOfString___setitem__(self, *args)

    def __init__(self, *args):
        r"""
        __init__(ArrayOfString self) -> ArrayOfString
        __init__(ArrayOfString self, ArrayOfString other) -> ArrayOfString
        __init__(ArrayOfString self, std::vector< std::string >::size_type size) -> ArrayOfString
        __init__(ArrayOfString self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> ArrayOfString
        """
        _ResultsAPI_Python.ArrayOfString_swiginit(self, _ResultsAPI_Python.new_ArrayOfString(*args))
    __swig_destroy__ = _ResultsAPI_Python.delete_ArrayOfString

# Register ArrayOfString in _ResultsAPI_Python:
_ResultsAPI_Python.ArrayOfString_swigregister(ArrayOfString)
class ArrayOfArrayOfString(object):
    r"""Proxy of C++ std::vector< std::vector< std::string > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(ArrayOfArrayOfString self) -> SwigPyIterator"""

        return _ResultsAPI_Python.ArrayOfArrayOfString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(ArrayOfArrayOfString self) -> bool"""
        return _ResultsAPI_Python.ArrayOfArrayOfString___nonzero__(self)

    def __bool__(self):
        r"""__bool__(ArrayOfArrayOfString self) -> bool"""
        return _ResultsAPI_Python.ArrayOfArrayOfString___bool__(self)

    def __len__(self):
        r"""__len__(ArrayOfArrayOfString self) -> std::vector< std::vector< std::string > >::size_type"""
        return _ResultsAPI_Python.ArrayOfArrayOfString___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(ArrayOfArrayOfString self, std::vector< std::vector< std::string > >::difference_type i, std::vector< std::vector< std::string > >::difference_type j) -> ArrayOfArrayOfString"""
        return _ResultsAPI_Python.ArrayOfArrayOfString___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(ArrayOfArrayOfString self, std::vector< std::vector< std::string > >::difference_type i, std::vector< std::vector< std::string > >::difference_type j)
        __setslice__(ArrayOfArrayOfString self, std::vector< std::vector< std::string > >::difference_type i, std::vector< std::vector< std::string > >::difference_type j, ArrayOfArrayOfString v)
        """
        return _ResultsAPI_Python.ArrayOfArrayOfString___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(ArrayOfArrayOfString self, std::vector< std::vector< std::string > >::difference_type i, std::vector< std::vector< std::string > >::difference_type j)"""
        return _ResultsAPI_Python.ArrayOfArrayOfString___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(ArrayOfArrayOfString self, std::vector< std::vector< std::string > >::difference_type i)
        __delitem__(ArrayOfArrayOfString self, SWIGPY_SLICEOBJECT * slice)
        """
        return _ResultsAPI_Python.ArrayOfArrayOfString___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(ArrayOfArrayOfString self, SWIGPY_SLICEOBJECT * slice) -> ArrayOfArrayOfString
        __getitem__(ArrayOfArrayOfString self, std::vector< std::vector< std::string > >::difference_type i) -> ArrayOfString
        """
        return _ResultsAPI_Python.ArrayOfArrayOfString___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(ArrayOfArrayOfString self, SWIGPY_SLICEOBJECT * slice, ArrayOfArrayOfString v)
        __setitem__(ArrayOfArrayOfString self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(ArrayOfArrayOfString self, std::vector< std::vector< std::string > >::difference_type i, ArrayOfString x)
        """
        return _ResultsAPI_Python.ArrayOfArrayOfString___setitem__(self, *args)

    def __init__(self, *args):
        r"""
        __init__(ArrayOfArrayOfString self) -> ArrayOfArrayOfString
        __init__(ArrayOfArrayOfString self, ArrayOfArrayOfString other) -> ArrayOfArrayOfString
        __init__(ArrayOfArrayOfString self, std::vector< std::vector< std::string > >::size_type size) -> ArrayOfArrayOfString
        __init__(ArrayOfArrayOfString self, std::vector< std::vector< std::string > >::size_type size, ArrayOfString value) -> ArrayOfArrayOfString
        """
        _ResultsAPI_Python.ArrayOfArrayOfString_swiginit(self, _ResultsAPI_Python.new_ArrayOfArrayOfString(*args))
    __swig_destroy__ = _ResultsAPI_Python.delete_ArrayOfArrayOfString

# Register ArrayOfArrayOfString in _ResultsAPI_Python:
_ResultsAPI_Python.ArrayOfArrayOfString_swigregister(ArrayOfArrayOfString)
class ArrayOfVariable(object):
    r"""Proxy of C++ std::vector< std::shared_ptr< CalculationResultsApi::Variable > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(ArrayOfVariable self) -> SwigPyIterator"""

        return _ResultsAPI_Python.ArrayOfVariable_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(ArrayOfVariable self) -> bool"""
        return _ResultsAPI_Python.ArrayOfVariable___nonzero__(self)

    def __bool__(self):
        r"""__bool__(ArrayOfVariable self) -> bool"""
        return _ResultsAPI_Python.ArrayOfVariable___bool__(self)

    def __len__(self):
        r"""__len__(ArrayOfVariable self) -> std::vector< std::shared_ptr< CalculationResultsApi::Variable > >::size_type"""
        return _ResultsAPI_Python.ArrayOfVariable___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(ArrayOfVariable self, std::vector< std::shared_ptr< CalculationResultsApi::Variable > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable > >::difference_type j) -> ArrayOfVariable"""
        return _ResultsAPI_Python.ArrayOfVariable___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(ArrayOfVariable self, std::vector< std::shared_ptr< CalculationResultsApi::Variable > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable > >::difference_type j)
        __setslice__(ArrayOfVariable self, std::vector< std::shared_ptr< CalculationResultsApi::Variable > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable > >::difference_type j, ArrayOfVariable v)
        """
        return _ResultsAPI_Python.ArrayOfVariable___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(ArrayOfVariable self, std::vector< std::shared_ptr< CalculationResultsApi::Variable > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable > >::difference_type j)"""
        return _ResultsAPI_Python.ArrayOfVariable___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(ArrayOfVariable self, std::vector< std::shared_ptr< CalculationResultsApi::Variable > >::difference_type i)
        __delitem__(ArrayOfVariable self, SWIGPY_SLICEOBJECT * slice)
        """
        return _ResultsAPI_Python.ArrayOfVariable___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(ArrayOfVariable self, SWIGPY_SLICEOBJECT * slice) -> ArrayOfVariable
        __getitem__(ArrayOfVariable self, std::vector< std::shared_ptr< CalculationResultsApi::Variable > >::difference_type i) -> std::vector< std::shared_ptr< CalculationResultsApi::Variable > >::value_type const &
        """
        return _ResultsAPI_Python.ArrayOfVariable___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(ArrayOfVariable self, SWIGPY_SLICEOBJECT * slice, ArrayOfVariable v)
        __setitem__(ArrayOfVariable self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(ArrayOfVariable self, std::vector< std::shared_ptr< CalculationResultsApi::Variable > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable > >::value_type const & x)
        """
        return _ResultsAPI_Python.ArrayOfVariable___setitem__(self, *args)

    def __init__(self, *args):
        r"""
        __init__(ArrayOfVariable self) -> ArrayOfVariable
        __init__(ArrayOfVariable self, ArrayOfVariable other) -> ArrayOfVariable
        __init__(ArrayOfVariable self, std::vector< std::shared_ptr< CalculationResultsApi::Variable > >::size_type size) -> ArrayOfVariable
        __init__(ArrayOfVariable self, std::vector< std::shared_ptr< CalculationResultsApi::Variable > >::size_type size, std::vector< std::shared_ptr< CalculationResultsApi::Variable > >::value_type const & value) -> ArrayOfVariable
        """
        _ResultsAPI_Python.ArrayOfVariable_swiginit(self, _ResultsAPI_Python.new_ArrayOfVariable(*args))
    __swig_destroy__ = _ResultsAPI_Python.delete_ArrayOfVariable

# Register ArrayOfVariable in _ResultsAPI_Python:
_ResultsAPI_Python.ArrayOfVariable_swigregister(ArrayOfVariable)
class ArrayOfVariable1D_Float32(object):
    r"""Proxy of C++ std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< float > > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(ArrayOfVariable1D_Float32 self) -> SwigPyIterator"""

        return _ResultsAPI_Python.ArrayOfVariable1D_Float32_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(ArrayOfVariable1D_Float32 self) -> bool"""
        return _ResultsAPI_Python.ArrayOfVariable1D_Float32___nonzero__(self)

    def __bool__(self):
        r"""__bool__(ArrayOfVariable1D_Float32 self) -> bool"""
        return _ResultsAPI_Python.ArrayOfVariable1D_Float32___bool__(self)

    def __len__(self):
        r"""__len__(ArrayOfVariable1D_Float32 self) -> std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< float > > >::size_type"""
        return _ResultsAPI_Python.ArrayOfVariable1D_Float32___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(ArrayOfVariable1D_Float32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< float > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< float > > >::difference_type j) -> ArrayOfVariable1D_Float32"""
        return _ResultsAPI_Python.ArrayOfVariable1D_Float32___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(ArrayOfVariable1D_Float32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< float > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< float > > >::difference_type j)
        __setslice__(ArrayOfVariable1D_Float32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< float > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< float > > >::difference_type j, ArrayOfVariable1D_Float32 v)
        """
        return _ResultsAPI_Python.ArrayOfVariable1D_Float32___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(ArrayOfVariable1D_Float32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< float > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< float > > >::difference_type j)"""
        return _ResultsAPI_Python.ArrayOfVariable1D_Float32___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(ArrayOfVariable1D_Float32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< float > > >::difference_type i)
        __delitem__(ArrayOfVariable1D_Float32 self, SWIGPY_SLICEOBJECT * slice)
        """
        return _ResultsAPI_Python.ArrayOfVariable1D_Float32___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(ArrayOfVariable1D_Float32 self, SWIGPY_SLICEOBJECT * slice) -> ArrayOfVariable1D_Float32
        __getitem__(ArrayOfVariable1D_Float32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< float > > >::difference_type i) -> std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< float > > >::value_type const &
        """
        return _ResultsAPI_Python.ArrayOfVariable1D_Float32___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(ArrayOfVariable1D_Float32 self, SWIGPY_SLICEOBJECT * slice, ArrayOfVariable1D_Float32 v)
        __setitem__(ArrayOfVariable1D_Float32 self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(ArrayOfVariable1D_Float32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< float > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< float > > >::value_type const & x)
        """
        return _ResultsAPI_Python.ArrayOfVariable1D_Float32___setitem__(self, *args)

    def __init__(self, *args):
        r"""
        __init__(ArrayOfVariable1D_Float32 self) -> ArrayOfVariable1D_Float32
        __init__(ArrayOfVariable1D_Float32 self, ArrayOfVariable1D_Float32 other) -> ArrayOfVariable1D_Float32
        __init__(ArrayOfVariable1D_Float32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< float > > >::size_type size) -> ArrayOfVariable1D_Float32
        __init__(ArrayOfVariable1D_Float32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< float > > >::size_type size, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< float > > >::value_type const & value) -> ArrayOfVariable1D_Float32
        """
        _ResultsAPI_Python.ArrayOfVariable1D_Float32_swiginit(self, _ResultsAPI_Python.new_ArrayOfVariable1D_Float32(*args))
    __swig_destroy__ = _ResultsAPI_Python.delete_ArrayOfVariable1D_Float32

# Register ArrayOfVariable1D_Float32 in _ResultsAPI_Python:
_ResultsAPI_Python.ArrayOfVariable1D_Float32_swigregister(ArrayOfVariable1D_Float32)
class ArrayOfVariable1D_Float64(object):
    r"""Proxy of C++ std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< double > > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(ArrayOfVariable1D_Float64 self) -> SwigPyIterator"""

        return _ResultsAPI_Python.ArrayOfVariable1D_Float64_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(ArrayOfVariable1D_Float64 self) -> bool"""
        return _ResultsAPI_Python.ArrayOfVariable1D_Float64___nonzero__(self)

    def __bool__(self):
        r"""__bool__(ArrayOfVariable1D_Float64 self) -> bool"""
        return _ResultsAPI_Python.ArrayOfVariable1D_Float64___bool__(self)

    def __len__(self):
        r"""__len__(ArrayOfVariable1D_Float64 self) -> std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< double > > >::size_type"""
        return _ResultsAPI_Python.ArrayOfVariable1D_Float64___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(ArrayOfVariable1D_Float64 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< double > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< double > > >::difference_type j) -> ArrayOfVariable1D_Float64"""
        return _ResultsAPI_Python.ArrayOfVariable1D_Float64___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(ArrayOfVariable1D_Float64 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< double > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< double > > >::difference_type j)
        __setslice__(ArrayOfVariable1D_Float64 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< double > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< double > > >::difference_type j, ArrayOfVariable1D_Float64 v)
        """
        return _ResultsAPI_Python.ArrayOfVariable1D_Float64___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(ArrayOfVariable1D_Float64 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< double > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< double > > >::difference_type j)"""
        return _ResultsAPI_Python.ArrayOfVariable1D_Float64___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(ArrayOfVariable1D_Float64 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< double > > >::difference_type i)
        __delitem__(ArrayOfVariable1D_Float64 self, SWIGPY_SLICEOBJECT * slice)
        """
        return _ResultsAPI_Python.ArrayOfVariable1D_Float64___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(ArrayOfVariable1D_Float64 self, SWIGPY_SLICEOBJECT * slice) -> ArrayOfVariable1D_Float64
        __getitem__(ArrayOfVariable1D_Float64 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< double > > >::difference_type i) -> std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< double > > >::value_type const &
        """
        return _ResultsAPI_Python.ArrayOfVariable1D_Float64___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(ArrayOfVariable1D_Float64 self, SWIGPY_SLICEOBJECT * slice, ArrayOfVariable1D_Float64 v)
        __setitem__(ArrayOfVariable1D_Float64 self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(ArrayOfVariable1D_Float64 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< double > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< double > > >::value_type const & x)
        """
        return _ResultsAPI_Python.ArrayOfVariable1D_Float64___setitem__(self, *args)

    def __init__(self, *args):
        r"""
        __init__(ArrayOfVariable1D_Float64 self) -> ArrayOfVariable1D_Float64
        __init__(ArrayOfVariable1D_Float64 self, ArrayOfVariable1D_Float64 other) -> ArrayOfVariable1D_Float64
        __init__(ArrayOfVariable1D_Float64 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< double > > >::size_type size) -> ArrayOfVariable1D_Float64
        __init__(ArrayOfVariable1D_Float64 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< double > > >::size_type size, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< double > > >::value_type const & value) -> ArrayOfVariable1D_Float64
        """
        _ResultsAPI_Python.ArrayOfVariable1D_Float64_swiginit(self, _ResultsAPI_Python.new_ArrayOfVariable1D_Float64(*args))
    __swig_destroy__ = _ResultsAPI_Python.delete_ArrayOfVariable1D_Float64

# Register ArrayOfVariable1D_Float64 in _ResultsAPI_Python:
_ResultsAPI_Python.ArrayOfVariable1D_Float64_swigregister(ArrayOfVariable1D_Float64)
class ArrayOfVariable1D_Int32(object):
    r"""Proxy of C++ std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< int > > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(ArrayOfVariable1D_Int32 self) -> SwigPyIterator"""

        return _ResultsAPI_Python.ArrayOfVariable1D_Int32_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(ArrayOfVariable1D_Int32 self) -> bool"""
        return _ResultsAPI_Python.ArrayOfVariable1D_Int32___nonzero__(self)

    def __bool__(self):
        r"""__bool__(ArrayOfVariable1D_Int32 self) -> bool"""
        return _ResultsAPI_Python.ArrayOfVariable1D_Int32___bool__(self)

    def __len__(self):
        r"""__len__(ArrayOfVariable1D_Int32 self) -> std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< int > > >::size_type"""
        return _ResultsAPI_Python.ArrayOfVariable1D_Int32___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(ArrayOfVariable1D_Int32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< int > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< int > > >::difference_type j) -> ArrayOfVariable1D_Int32"""
        return _ResultsAPI_Python.ArrayOfVariable1D_Int32___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(ArrayOfVariable1D_Int32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< int > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< int > > >::difference_type j)
        __setslice__(ArrayOfVariable1D_Int32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< int > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< int > > >::difference_type j, ArrayOfVariable1D_Int32 v)
        """
        return _ResultsAPI_Python.ArrayOfVariable1D_Int32___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(ArrayOfVariable1D_Int32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< int > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< int > > >::difference_type j)"""
        return _ResultsAPI_Python.ArrayOfVariable1D_Int32___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(ArrayOfVariable1D_Int32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< int > > >::difference_type i)
        __delitem__(ArrayOfVariable1D_Int32 self, SWIGPY_SLICEOBJECT * slice)
        """
        return _ResultsAPI_Python.ArrayOfVariable1D_Int32___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(ArrayOfVariable1D_Int32 self, SWIGPY_SLICEOBJECT * slice) -> ArrayOfVariable1D_Int32
        __getitem__(ArrayOfVariable1D_Int32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< int > > >::difference_type i) -> std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< int > > >::value_type const &
        """
        return _ResultsAPI_Python.ArrayOfVariable1D_Int32___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(ArrayOfVariable1D_Int32 self, SWIGPY_SLICEOBJECT * slice, ArrayOfVariable1D_Int32 v)
        __setitem__(ArrayOfVariable1D_Int32 self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(ArrayOfVariable1D_Int32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< int > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< int > > >::value_type const & x)
        """
        return _ResultsAPI_Python.ArrayOfVariable1D_Int32___setitem__(self, *args)

    def __init__(self, *args):
        r"""
        __init__(ArrayOfVariable1D_Int32 self) -> ArrayOfVariable1D_Int32
        __init__(ArrayOfVariable1D_Int32 self, ArrayOfVariable1D_Int32 other) -> ArrayOfVariable1D_Int32
        __init__(ArrayOfVariable1D_Int32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< int > > >::size_type size) -> ArrayOfVariable1D_Int32
        __init__(ArrayOfVariable1D_Int32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< int > > >::size_type size, std::vector< std::shared_ptr< CalculationResultsApi::Variable1D< int > > >::value_type const & value) -> ArrayOfVariable1D_Int32
        """
        _ResultsAPI_Python.ArrayOfVariable1D_Int32_swiginit(self, _ResultsAPI_Python.new_ArrayOfVariable1D_Int32(*args))
    __swig_destroy__ = _ResultsAPI_Python.delete_ArrayOfVariable1D_Int32

# Register ArrayOfVariable1D_Int32 in _ResultsAPI_Python:
_ResultsAPI_Python.ArrayOfVariable1D_Int32_swigregister(ArrayOfVariable1D_Int32)
class ArrayOfVariable2D_Float32(object):
    r"""Proxy of C++ std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< float > > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(ArrayOfVariable2D_Float32 self) -> SwigPyIterator"""

        return _ResultsAPI_Python.ArrayOfVariable2D_Float32_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(ArrayOfVariable2D_Float32 self) -> bool"""
        return _ResultsAPI_Python.ArrayOfVariable2D_Float32___nonzero__(self)

    def __bool__(self):
        r"""__bool__(ArrayOfVariable2D_Float32 self) -> bool"""
        return _ResultsAPI_Python.ArrayOfVariable2D_Float32___bool__(self)

    def __len__(self):
        r"""__len__(ArrayOfVariable2D_Float32 self) -> std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< float > > >::size_type"""
        return _ResultsAPI_Python.ArrayOfVariable2D_Float32___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(ArrayOfVariable2D_Float32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< float > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< float > > >::difference_type j) -> ArrayOfVariable2D_Float32"""
        return _ResultsAPI_Python.ArrayOfVariable2D_Float32___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(ArrayOfVariable2D_Float32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< float > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< float > > >::difference_type j)
        __setslice__(ArrayOfVariable2D_Float32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< float > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< float > > >::difference_type j, ArrayOfVariable2D_Float32 v)
        """
        return _ResultsAPI_Python.ArrayOfVariable2D_Float32___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(ArrayOfVariable2D_Float32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< float > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< float > > >::difference_type j)"""
        return _ResultsAPI_Python.ArrayOfVariable2D_Float32___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(ArrayOfVariable2D_Float32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< float > > >::difference_type i)
        __delitem__(ArrayOfVariable2D_Float32 self, SWIGPY_SLICEOBJECT * slice)
        """
        return _ResultsAPI_Python.ArrayOfVariable2D_Float32___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(ArrayOfVariable2D_Float32 self, SWIGPY_SLICEOBJECT * slice) -> ArrayOfVariable2D_Float32
        __getitem__(ArrayOfVariable2D_Float32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< float > > >::difference_type i) -> std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< float > > >::value_type const &
        """
        return _ResultsAPI_Python.ArrayOfVariable2D_Float32___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(ArrayOfVariable2D_Float32 self, SWIGPY_SLICEOBJECT * slice, ArrayOfVariable2D_Float32 v)
        __setitem__(ArrayOfVariable2D_Float32 self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(ArrayOfVariable2D_Float32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< float > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< float > > >::value_type const & x)
        """
        return _ResultsAPI_Python.ArrayOfVariable2D_Float32___setitem__(self, *args)

    def __init__(self, *args):
        r"""
        __init__(ArrayOfVariable2D_Float32 self) -> ArrayOfVariable2D_Float32
        __init__(ArrayOfVariable2D_Float32 self, ArrayOfVariable2D_Float32 other) -> ArrayOfVariable2D_Float32
        __init__(ArrayOfVariable2D_Float32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< float > > >::size_type size) -> ArrayOfVariable2D_Float32
        __init__(ArrayOfVariable2D_Float32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< float > > >::size_type size, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< float > > >::value_type const & value) -> ArrayOfVariable2D_Float32
        """
        _ResultsAPI_Python.ArrayOfVariable2D_Float32_swiginit(self, _ResultsAPI_Python.new_ArrayOfVariable2D_Float32(*args))
    __swig_destroy__ = _ResultsAPI_Python.delete_ArrayOfVariable2D_Float32

# Register ArrayOfVariable2D_Float32 in _ResultsAPI_Python:
_ResultsAPI_Python.ArrayOfVariable2D_Float32_swigregister(ArrayOfVariable2D_Float32)
class ArrayOfVariable2D_Float64(object):
    r"""Proxy of C++ std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< double > > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(ArrayOfVariable2D_Float64 self) -> SwigPyIterator"""

        return _ResultsAPI_Python.ArrayOfVariable2D_Float64_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(ArrayOfVariable2D_Float64 self) -> bool"""
        return _ResultsAPI_Python.ArrayOfVariable2D_Float64___nonzero__(self)

    def __bool__(self):
        r"""__bool__(ArrayOfVariable2D_Float64 self) -> bool"""
        return _ResultsAPI_Python.ArrayOfVariable2D_Float64___bool__(self)

    def __len__(self):
        r"""__len__(ArrayOfVariable2D_Float64 self) -> std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< double > > >::size_type"""
        return _ResultsAPI_Python.ArrayOfVariable2D_Float64___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(ArrayOfVariable2D_Float64 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< double > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< double > > >::difference_type j) -> ArrayOfVariable2D_Float64"""
        return _ResultsAPI_Python.ArrayOfVariable2D_Float64___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(ArrayOfVariable2D_Float64 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< double > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< double > > >::difference_type j)
        __setslice__(ArrayOfVariable2D_Float64 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< double > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< double > > >::difference_type j, ArrayOfVariable2D_Float64 v)
        """
        return _ResultsAPI_Python.ArrayOfVariable2D_Float64___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(ArrayOfVariable2D_Float64 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< double > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< double > > >::difference_type j)"""
        return _ResultsAPI_Python.ArrayOfVariable2D_Float64___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(ArrayOfVariable2D_Float64 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< double > > >::difference_type i)
        __delitem__(ArrayOfVariable2D_Float64 self, SWIGPY_SLICEOBJECT * slice)
        """
        return _ResultsAPI_Python.ArrayOfVariable2D_Float64___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(ArrayOfVariable2D_Float64 self, SWIGPY_SLICEOBJECT * slice) -> ArrayOfVariable2D_Float64
        __getitem__(ArrayOfVariable2D_Float64 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< double > > >::difference_type i) -> std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< double > > >::value_type const &
        """
        return _ResultsAPI_Python.ArrayOfVariable2D_Float64___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(ArrayOfVariable2D_Float64 self, SWIGPY_SLICEOBJECT * slice, ArrayOfVariable2D_Float64 v)
        __setitem__(ArrayOfVariable2D_Float64 self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(ArrayOfVariable2D_Float64 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< double > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< double > > >::value_type const & x)
        """
        return _ResultsAPI_Python.ArrayOfVariable2D_Float64___setitem__(self, *args)

    def __init__(self, *args):
        r"""
        __init__(ArrayOfVariable2D_Float64 self) -> ArrayOfVariable2D_Float64
        __init__(ArrayOfVariable2D_Float64 self, ArrayOfVariable2D_Float64 other) -> ArrayOfVariable2D_Float64
        __init__(ArrayOfVariable2D_Float64 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< double > > >::size_type size) -> ArrayOfVariable2D_Float64
        __init__(ArrayOfVariable2D_Float64 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< double > > >::size_type size, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< double > > >::value_type const & value) -> ArrayOfVariable2D_Float64
        """
        _ResultsAPI_Python.ArrayOfVariable2D_Float64_swiginit(self, _ResultsAPI_Python.new_ArrayOfVariable2D_Float64(*args))
    __swig_destroy__ = _ResultsAPI_Python.delete_ArrayOfVariable2D_Float64

# Register ArrayOfVariable2D_Float64 in _ResultsAPI_Python:
_ResultsAPI_Python.ArrayOfVariable2D_Float64_swigregister(ArrayOfVariable2D_Float64)
class ArrayOfVariable2D_Int32(object):
    r"""Proxy of C++ std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< int > > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(ArrayOfVariable2D_Int32 self) -> SwigPyIterator"""

        return _ResultsAPI_Python.ArrayOfVariable2D_Int32_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(ArrayOfVariable2D_Int32 self) -> bool"""
        return _ResultsAPI_Python.ArrayOfVariable2D_Int32___nonzero__(self)

    def __bool__(self):
        r"""__bool__(ArrayOfVariable2D_Int32 self) -> bool"""
        return _ResultsAPI_Python.ArrayOfVariable2D_Int32___bool__(self)

    def __len__(self):
        r"""__len__(ArrayOfVariable2D_Int32 self) -> std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< int > > >::size_type"""
        return _ResultsAPI_Python.ArrayOfVariable2D_Int32___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(ArrayOfVariable2D_Int32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< int > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< int > > >::difference_type j) -> ArrayOfVariable2D_Int32"""
        return _ResultsAPI_Python.ArrayOfVariable2D_Int32___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(ArrayOfVariable2D_Int32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< int > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< int > > >::difference_type j)
        __setslice__(ArrayOfVariable2D_Int32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< int > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< int > > >::difference_type j, ArrayOfVariable2D_Int32 v)
        """
        return _ResultsAPI_Python.ArrayOfVariable2D_Int32___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(ArrayOfVariable2D_Int32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< int > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< int > > >::difference_type j)"""
        return _ResultsAPI_Python.ArrayOfVariable2D_Int32___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(ArrayOfVariable2D_Int32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< int > > >::difference_type i)
        __delitem__(ArrayOfVariable2D_Int32 self, SWIGPY_SLICEOBJECT * slice)
        """
        return _ResultsAPI_Python.ArrayOfVariable2D_Int32___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(ArrayOfVariable2D_Int32 self, SWIGPY_SLICEOBJECT * slice) -> ArrayOfVariable2D_Int32
        __getitem__(ArrayOfVariable2D_Int32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< int > > >::difference_type i) -> std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< int > > >::value_type const &
        """
        return _ResultsAPI_Python.ArrayOfVariable2D_Int32___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(ArrayOfVariable2D_Int32 self, SWIGPY_SLICEOBJECT * slice, ArrayOfVariable2D_Int32 v)
        __setitem__(ArrayOfVariable2D_Int32 self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(ArrayOfVariable2D_Int32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< int > > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< int > > >::value_type const & x)
        """
        return _ResultsAPI_Python.ArrayOfVariable2D_Int32___setitem__(self, *args)

    def __init__(self, *args):
        r"""
        __init__(ArrayOfVariable2D_Int32 self) -> ArrayOfVariable2D_Int32
        __init__(ArrayOfVariable2D_Int32 self, ArrayOfVariable2D_Int32 other) -> ArrayOfVariable2D_Int32
        __init__(ArrayOfVariable2D_Int32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< int > > >::size_type size) -> ArrayOfVariable2D_Int32
        __init__(ArrayOfVariable2D_Int32 self, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< int > > >::size_type size, std::vector< std::shared_ptr< CalculationResultsApi::Variable2D< int > > >::value_type const & value) -> ArrayOfVariable2D_Int32
        """
        _ResultsAPI_Python.ArrayOfVariable2D_Int32_swiginit(self, _ResultsAPI_Python.new_ArrayOfVariable2D_Int32(*args))
    __swig_destroy__ = _ResultsAPI_Python.delete_ArrayOfVariable2D_Int32

# Register ArrayOfVariable2D_Int32 in _ResultsAPI_Python:
_ResultsAPI_Python.ArrayOfVariable2D_Int32_swigregister(ArrayOfVariable2D_Int32)
class ArrayOfIndependentVariable(object):
    r"""Proxy of C++ std::vector< std::shared_ptr< CalculationResultsApi::IndependentVariable > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(ArrayOfIndependentVariable self) -> SwigPyIterator"""

        return _ResultsAPI_Python.ArrayOfIndependentVariable_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(ArrayOfIndependentVariable self) -> bool"""
        return _ResultsAPI_Python.ArrayOfIndependentVariable___nonzero__(self)

    def __bool__(self):
        r"""__bool__(ArrayOfIndependentVariable self) -> bool"""
        return _ResultsAPI_Python.ArrayOfIndependentVariable___bool__(self)

    def __len__(self):
        r"""__len__(ArrayOfIndependentVariable self) -> std::vector< std::shared_ptr< CalculationResultsApi::IndependentVariable > >::size_type"""
        return _ResultsAPI_Python.ArrayOfIndependentVariable___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(ArrayOfIndependentVariable self, std::vector< std::shared_ptr< CalculationResultsApi::IndependentVariable > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::IndependentVariable > >::difference_type j) -> ArrayOfIndependentVariable"""
        return _ResultsAPI_Python.ArrayOfIndependentVariable___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(ArrayOfIndependentVariable self, std::vector< std::shared_ptr< CalculationResultsApi::IndependentVariable > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::IndependentVariable > >::difference_type j)
        __setslice__(ArrayOfIndependentVariable self, std::vector< std::shared_ptr< CalculationResultsApi::IndependentVariable > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::IndependentVariable > >::difference_type j, ArrayOfIndependentVariable v)
        """
        return _ResultsAPI_Python.ArrayOfIndependentVariable___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(ArrayOfIndependentVariable self, std::vector< std::shared_ptr< CalculationResultsApi::IndependentVariable > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::IndependentVariable > >::difference_type j)"""
        return _ResultsAPI_Python.ArrayOfIndependentVariable___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(ArrayOfIndependentVariable self, std::vector< std::shared_ptr< CalculationResultsApi::IndependentVariable > >::difference_type i)
        __delitem__(ArrayOfIndependentVariable self, SWIGPY_SLICEOBJECT * slice)
        """
        return _ResultsAPI_Python.ArrayOfIndependentVariable___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(ArrayOfIndependentVariable self, SWIGPY_SLICEOBJECT * slice) -> ArrayOfIndependentVariable
        __getitem__(ArrayOfIndependentVariable self, std::vector< std::shared_ptr< CalculationResultsApi::IndependentVariable > >::difference_type i) -> std::vector< std::shared_ptr< CalculationResultsApi::IndependentVariable > >::value_type const &
        """
        return _ResultsAPI_Python.ArrayOfIndependentVariable___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(ArrayOfIndependentVariable self, SWIGPY_SLICEOBJECT * slice, ArrayOfIndependentVariable v)
        __setitem__(ArrayOfIndependentVariable self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(ArrayOfIndependentVariable self, std::vector< std::shared_ptr< CalculationResultsApi::IndependentVariable > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::IndependentVariable > >::value_type const & x)
        """
        return _ResultsAPI_Python.ArrayOfIndependentVariable___setitem__(self, *args)

    def __init__(self, *args):
        r"""
        __init__(ArrayOfIndependentVariable self) -> ArrayOfIndependentVariable
        __init__(ArrayOfIndependentVariable self, ArrayOfIndependentVariable other) -> ArrayOfIndependentVariable
        __init__(ArrayOfIndependentVariable self, std::vector< std::shared_ptr< CalculationResultsApi::IndependentVariable > >::size_type size) -> ArrayOfIndependentVariable
        __init__(ArrayOfIndependentVariable self, std::vector< std::shared_ptr< CalculationResultsApi::IndependentVariable > >::size_type size, std::vector< std::shared_ptr< CalculationResultsApi::IndependentVariable > >::value_type const & value) -> ArrayOfIndependentVariable
        """
        _ResultsAPI_Python.ArrayOfIndependentVariable_swiginit(self, _ResultsAPI_Python.new_ArrayOfIndependentVariable(*args))
    __swig_destroy__ = _ResultsAPI_Python.delete_ArrayOfIndependentVariable

# Register ArrayOfIndependentVariable in _ResultsAPI_Python:
_ResultsAPI_Python.ArrayOfIndependentVariable_swigregister(ArrayOfIndependentVariable)
class ArrayOfGroup(object):
    r"""Proxy of C++ std::vector< std::shared_ptr< CalculationResultsApi::Group > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(ArrayOfGroup self) -> SwigPyIterator"""

        return _ResultsAPI_Python.ArrayOfGroup_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(ArrayOfGroup self) -> bool"""
        return _ResultsAPI_Python.ArrayOfGroup___nonzero__(self)

    def __bool__(self):
        r"""__bool__(ArrayOfGroup self) -> bool"""
        return _ResultsAPI_Python.ArrayOfGroup___bool__(self)

    def __len__(self):
        r"""__len__(ArrayOfGroup self) -> std::vector< std::shared_ptr< CalculationResultsApi::Group > >::size_type"""
        return _ResultsAPI_Python.ArrayOfGroup___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(ArrayOfGroup self, std::vector< std::shared_ptr< CalculationResultsApi::Group > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Group > >::difference_type j) -> ArrayOfGroup"""
        return _ResultsAPI_Python.ArrayOfGroup___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(ArrayOfGroup self, std::vector< std::shared_ptr< CalculationResultsApi::Group > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Group > >::difference_type j)
        __setslice__(ArrayOfGroup self, std::vector< std::shared_ptr< CalculationResultsApi::Group > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Group > >::difference_type j, ArrayOfGroup v)
        """
        return _ResultsAPI_Python.ArrayOfGroup___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(ArrayOfGroup self, std::vector< std::shared_ptr< CalculationResultsApi::Group > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Group > >::difference_type j)"""
        return _ResultsAPI_Python.ArrayOfGroup___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(ArrayOfGroup self, std::vector< std::shared_ptr< CalculationResultsApi::Group > >::difference_type i)
        __delitem__(ArrayOfGroup self, SWIGPY_SLICEOBJECT * slice)
        """
        return _ResultsAPI_Python.ArrayOfGroup___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(ArrayOfGroup self, SWIGPY_SLICEOBJECT * slice) -> ArrayOfGroup
        __getitem__(ArrayOfGroup self, std::vector< std::shared_ptr< CalculationResultsApi::Group > >::difference_type i) -> std::vector< std::shared_ptr< CalculationResultsApi::Group > >::value_type const &
        """
        return _ResultsAPI_Python.ArrayOfGroup___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(ArrayOfGroup self, SWIGPY_SLICEOBJECT * slice, ArrayOfGroup v)
        __setitem__(ArrayOfGroup self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(ArrayOfGroup self, std::vector< std::shared_ptr< CalculationResultsApi::Group > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Group > >::value_type const & x)
        """
        return _ResultsAPI_Python.ArrayOfGroup___setitem__(self, *args)

    def __init__(self, *args):
        r"""
        __init__(ArrayOfGroup self) -> ArrayOfGroup
        __init__(ArrayOfGroup self, ArrayOfGroup other) -> ArrayOfGroup
        __init__(ArrayOfGroup self, std::vector< std::shared_ptr< CalculationResultsApi::Group > >::size_type size) -> ArrayOfGroup
        __init__(ArrayOfGroup self, std::vector< std::shared_ptr< CalculationResultsApi::Group > >::size_type size, std::vector< std::shared_ptr< CalculationResultsApi::Group > >::value_type const & value) -> ArrayOfGroup
        """
        _ResultsAPI_Python.ArrayOfGroup_swiginit(self, _ResultsAPI_Python.new_ArrayOfGroup(*args))
    __swig_destroy__ = _ResultsAPI_Python.delete_ArrayOfGroup

# Register ArrayOfGroup in _ResultsAPI_Python:
_ResultsAPI_Python.ArrayOfGroup_swigregister(ArrayOfGroup)
class ArrayOfRun(object):
    r"""Proxy of C++ std::vector< std::shared_ptr< CalculationResultsApi::Run > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(ArrayOfRun self) -> SwigPyIterator"""

        return _ResultsAPI_Python.ArrayOfRun_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(ArrayOfRun self) -> bool"""
        return _ResultsAPI_Python.ArrayOfRun___nonzero__(self)

    def __bool__(self):
        r"""__bool__(ArrayOfRun self) -> bool"""
        return _ResultsAPI_Python.ArrayOfRun___bool__(self)

    def __len__(self):
        r"""__len__(ArrayOfRun self) -> std::vector< std::shared_ptr< CalculationResultsApi::Run > >::size_type"""
        return _ResultsAPI_Python.ArrayOfRun___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(ArrayOfRun self, std::vector< std::shared_ptr< CalculationResultsApi::Run > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Run > >::difference_type j) -> ArrayOfRun"""
        return _ResultsAPI_Python.ArrayOfRun___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(ArrayOfRun self, std::vector< std::shared_ptr< CalculationResultsApi::Run > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Run > >::difference_type j)
        __setslice__(ArrayOfRun self, std::vector< std::shared_ptr< CalculationResultsApi::Run > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Run > >::difference_type j, ArrayOfRun v)
        """
        return _ResultsAPI_Python.ArrayOfRun___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(ArrayOfRun self, std::vector< std::shared_ptr< CalculationResultsApi::Run > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Run > >::difference_type j)"""
        return _ResultsAPI_Python.ArrayOfRun___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(ArrayOfRun self, std::vector< std::shared_ptr< CalculationResultsApi::Run > >::difference_type i)
        __delitem__(ArrayOfRun self, SWIGPY_SLICEOBJECT * slice)
        """
        return _ResultsAPI_Python.ArrayOfRun___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(ArrayOfRun self, SWIGPY_SLICEOBJECT * slice) -> ArrayOfRun
        __getitem__(ArrayOfRun self, std::vector< std::shared_ptr< CalculationResultsApi::Run > >::difference_type i) -> std::vector< std::shared_ptr< CalculationResultsApi::Run > >::value_type const &
        """
        return _ResultsAPI_Python.ArrayOfRun___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(ArrayOfRun self, SWIGPY_SLICEOBJECT * slice, ArrayOfRun v)
        __setitem__(ArrayOfRun self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(ArrayOfRun self, std::vector< std::shared_ptr< CalculationResultsApi::Run > >::difference_type i, std::vector< std::shared_ptr< CalculationResultsApi::Run > >::value_type const & x)
        """
        return _ResultsAPI_Python.ArrayOfRun___setitem__(self, *args)

    def __init__(self, *args):
        r"""
        __init__(ArrayOfRun self) -> ArrayOfRun
        __init__(ArrayOfRun self, ArrayOfRun other) -> ArrayOfRun
        __init__(ArrayOfRun self, std::vector< std::shared_ptr< CalculationResultsApi::Run > >::size_type size) -> ArrayOfRun
        __init__(ArrayOfRun self, std::vector< std::shared_ptr< CalculationResultsApi::Run > >::size_type size, std::vector< std::shared_ptr< CalculationResultsApi::Run > >::value_type const & value) -> ArrayOfRun
        """
        _ResultsAPI_Python.ArrayOfRun_swiginit(self, _ResultsAPI_Python.new_ArrayOfRun(*args))
    __swig_destroy__ = _ResultsAPI_Python.delete_ArrayOfRun

# Register ArrayOfRun in _ResultsAPI_Python:
_ResultsAPI_Python.ArrayOfRun_swigregister(ArrayOfRun)
class Variable1D_Float32(Variable):
    r"""
    Class representing a one-dimensional dependent variable.

    Notes
    -----
    - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
    - The data is stored in a one-dimensional data array - essentially a flat list of values.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def _get_data_native_array(self) -> ArrayOfFloat:
        r"""
        Gets data for the variable.

        Returns
        -------
        ArrayOfFloat
            A contiguous array of data points.

        Notes
        -----
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Variable1D_Float32__get_data_native_array(self)

    def get_independent_variable(self) -> IndependentVariable:
        r"""
        Gets the independent variable.

        Returns
        -------
        IndependentVariable
            An `IndependentVariable` object.

        Notes
        -----
        - In a time domain simulation, a one-dimensional `Variable1D` object contains just one independent variable: time.
        """
        return _ResultsAPI_Python.Variable1D_Float32_get_independent_variable(self)

    def independent_variable_has_numeric_values(self):
        r"""
        Indicates whether the independent variable has numeric values.

        Returns
        -------
        bool
            A boolean indicating whether the independent variable has numeric values.

        Notes
        -----
        - If the axis is a labelled value or interval axis type, returns `True`.
        - If the axis is a labelled string axis type, returns `False`.
        """
        return _ResultsAPI_Python.Variable1D_Float32_independent_variable_has_numeric_values(self)

    def get_mean(self):
        r"""
        Gets the mean value of the data.

        Returns
        -------
        float
            A double-precision floating-point value containing the mean.
        """
        return _ResultsAPI_Python.Variable1D_Float32_get_mean(self)

    def get_maximum(self):
        r"""
        Gets the maximum value of the data.

        Returns
        -------
        float
            The maximum value, taking the same type as the underlying data.

        Notes
        -----
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        """
        return _ResultsAPI_Python.Variable1D_Float32_get_maximum(self)

    def get_minimum(self):
        r"""
        Gets the minimum value of the data.

        Returns
        -------
        float
            The minimum value, taking the same type as the underlying data.

        Notes
        -----
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        """
        return _ResultsAPI_Python.Variable1D_Float32_get_minimum(self)

    def get_minimum_contemporaneous(self, contemporaneous_variable_name):
        r"""
        Gets the minimum contemporaneous value for the specified one-dimensional variable.

        Parameters
        ----------
        contemporaneous_variable_name : str
            The name of the variable whose contemporaneous value will be sought.

        Returns
        -------
        float
            The minimum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - The minimum contemporaneous value refers to the value of the specified `Variable1D` that occurred when the current `Variable1D` reported its minimum value.
        - Variable name comparison is case-insensitive.
        """
        return _ResultsAPI_Python.Variable1D_Float32_get_minimum_contemporaneous(self, contemporaneous_variable_name)

    def get_maximum_contemporaneous(self, contemporaneous_variable_name):
        r"""
        Gets the maximum contemporaneous value for the specified one-dimensional variable.

        Parameters
        ----------
        contemporaneous_variable_name : str
            The name of the variable whose contemporaneous value will be sought.

        Returns
        -------
        float
            The maximum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - The maximum contemporaneous value refers to the value of the specified `Variable1D` that occurred when the current `Variable1D` reported its maximum value.
        - Variable name comparison is case-insensitive.
        """
        return _ResultsAPI_Python.Variable1D_Float32_get_maximum_contemporaneous(self, contemporaneous_variable_name)
    __swig_destroy__ = _ResultsAPI_Python.delete_Variable1D_Float32

    @property
    def name(self) -> str:
        r"""
        The name of the variable.
        """
        return self._get_name()


    @property
    def si_unit(self) -> str:
        r"""
        The SI unit of the variable, e.g. m for metres.
        """
        result = self._get_si_unit()
        return result.encode('utf-8', 'surrogateescape').decode('ISO-8859-1')


    @property
    def quantity_code(self) -> str:
        r"""
        The quantity code of the variable, e.g. L for length.
        """
        return self._get_quantity_code()


    @property
    def number_of_independent_variables(self) -> int:
        r"""
        The number of independent variables (1 or 2).

        Notes
        -----
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return self._get_number_of_independent_variables()


    @property
    def is_one_dimensional(self) -> bool:
        r"""
        Whether the variable is a one-dimensional dependent variable (`Variable1D`).

        Notes
        -----
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        """
        return self._is_one_dimensional()


    @property
    def is_two_dimensional(self) -> bool:
        r"""
        Whether the variable is a two-dimensional dependent variable (`Variable2D`).

        Notes
        -----
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return self._is_two_dimensional()


    @property
    def parent_group_name(self) -> str:
        r"""
        The name of the parent group.

        Notes
        -----
        - The name of the parent group is indicated by the value of GENLAB label in the header file.
        """
        return self._get_parent_group_name()


    @property
    def parent_group_number(self) -> int:
        r"""
        The number of the parent group.

        Notes
        -----
        - The group number is unique within a given run.
        - The group number is used in the file extension of the group.
        """
        return self._get_parent_group_number()


    @property
    def parent_group_header_file_full_path(self) -> str:
        r"""
        The the full path to the parent group header file.
        """
        return self._get_parent_group_header_file_full_path()


    @property
    def time_domain_simulation_length(self) -> float:
        r"""
        The length in seconds of the time domain simulation.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - Use `Run.execution_duration_seconds` to get the wall-clock duration of a calculation.
        """
        return self._get_time_domain_simulation_length()


    @property
    def time_domain_simulation_output_timestep(self) -> float:
        r"""
        The output timestep used in the time domain simulation.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - The output timestep is indicated by the STEP field of the parent group header file.
        """
        return self._get_time_domain_simulation_output_timestep()


    @property
    def time_domain_simulation_output_start_time(self) -> float:
        r"""
        The output start time used in the time domain simulation. This is the first point in the simulation when outputs were written.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - The output start time is indicated by the MIN field of the parent group header file.
        """
        return self._get_time_domain_simulation_output_start_time()


    @property
    def data_point_count(self) -> int:
        r"""
        The number of data points recorded for the variable. In a time domain simulation, this is equivalent to the number of output timesteps.

        Notes
        -----
        - For a `Variable1D`, returns the number of data points recorded.
        - For a `Variable2D`, returns the number of data points recorded for any given secondary independent variable (not the aggregate count of all secondary independent variables).
        """
        return self._get_data_point_count()


    @property
    def data_type(self) -> int:
        r"""
        The data type of the variable.

        Notes
        -----
        - Data type returned may differ from the serialised data type if client has specified a target data type.
        - Use `ResultsApi.CacheSettings` to set the data type to use globally.
        """
        return self._get_data_type()


    @property
    def data_format(self) -> int:
        r"""
        The data format of the variable.
        """
        return self._get_data_format()


    def _get_data_numpy_from_vector(self):
        r"""_get_data_numpy_from_vector(Variable1D_Float32 self) -> PyObject *"""
        return _ResultsAPI_Python.Variable1D_Float32__get_data_numpy_from_vector(self)


    #Wrapped vector to Numpy array conversion without copy
    def get_data(self) -> np.ndarray[np.float32]:
        r"""
        Gets data for the variable.

        Returns
        -------
        np.ndarray[np.float32]
            A NumPy `ndarray` of data points.

        Notes
        -----
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_data_native_array` to avoid this penalty.
        """
        return self._get_data_numpy_from_vector()


# Register Variable1D_Float32 in _ResultsAPI_Python:
_ResultsAPI_Python.Variable1D_Float32_swigregister(Variable1D_Float32)
class Variable1D_Float64(Variable):
    r"""
    Class representing a one-dimensional dependent variable.

    Notes
    -----
    - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
    - The data is stored in a one-dimensional data array - essentially a flat list of values.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def _get_data_native_array(self) -> ArrayOfDouble:
        r"""
        Gets data for the variable.

        Returns
        -------
        ArrayOfDouble
            A contiguous array of data points.

        Notes
        -----
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Variable1D_Float64__get_data_native_array(self)

    def get_independent_variable(self) -> IndependentVariable:
        r"""
        Gets the independent variable.

        Returns
        -------
        IndependentVariable
            An `IndependentVariable` object.

        Notes
        -----
        - In a time domain simulation, a one-dimensional `Variable1D` object contains just one independent variable: time.
        """
        return _ResultsAPI_Python.Variable1D_Float64_get_independent_variable(self)

    def independent_variable_has_numeric_values(self):
        r"""
        Indicates whether the independent variable has numeric values.

        Returns
        -------
        bool
            A boolean indicating whether the independent variable has numeric values.

        Notes
        -----
        - If the axis is a labelled value or interval axis type, returns `True`.
        - If the axis is a labelled string axis type, returns `False`.
        """
        return _ResultsAPI_Python.Variable1D_Float64_independent_variable_has_numeric_values(self)

    def get_mean(self):
        r"""
        Gets the mean value of the data.

        Returns
        -------
        float
            A double-precision floating-point value containing the mean.
        """
        return _ResultsAPI_Python.Variable1D_Float64_get_mean(self)

    def get_maximum(self):
        r"""
        Gets the maximum value of the data.

        Returns
        -------
        float
            The maximum value, taking the same type as the underlying data.

        Notes
        -----
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        """
        return _ResultsAPI_Python.Variable1D_Float64_get_maximum(self)

    def get_minimum(self):
        r"""
        Gets the minimum value of the data.

        Returns
        -------
        float
            The minimum value, taking the same type as the underlying data.

        Notes
        -----
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        """
        return _ResultsAPI_Python.Variable1D_Float64_get_minimum(self)

    def get_minimum_contemporaneous(self, contemporaneous_variable_name):
        r"""
        Gets the minimum contemporaneous value for the specified one-dimensional variable.

        Parameters
        ----------
        contemporaneous_variable_name : str
            The name of the variable whose contemporaneous value will be sought.

        Returns
        -------
        float
            The minimum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - The minimum contemporaneous value refers to the value of the specified `Variable1D` that occurred when the current `Variable1D` reported its minimum value.
        - Variable name comparison is case-insensitive.
        """
        return _ResultsAPI_Python.Variable1D_Float64_get_minimum_contemporaneous(self, contemporaneous_variable_name)

    def get_maximum_contemporaneous(self, contemporaneous_variable_name):
        r"""
        Gets the maximum contemporaneous value for the specified one-dimensional variable.

        Parameters
        ----------
        contemporaneous_variable_name : str
            The name of the variable whose contemporaneous value will be sought.

        Returns
        -------
        float
            The maximum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - The maximum contemporaneous value refers to the value of the specified `Variable1D` that occurred when the current `Variable1D` reported its maximum value.
        - Variable name comparison is case-insensitive.
        """
        return _ResultsAPI_Python.Variable1D_Float64_get_maximum_contemporaneous(self, contemporaneous_variable_name)
    __swig_destroy__ = _ResultsAPI_Python.delete_Variable1D_Float64

    @property
    def name(self) -> str:
        r"""
        The name of the variable.
        """
        return self._get_name()


    @property
    def si_unit(self) -> str:
        r"""
        The SI unit of the variable, e.g. m for metres.
        """
        result = self._get_si_unit()
        return result.encode('utf-8', 'surrogateescape').decode('ISO-8859-1')


    @property
    def quantity_code(self) -> str:
        r"""
        The quantity code of the variable, e.g. L for length.
        """
        return self._get_quantity_code()


    @property
    def number_of_independent_variables(self) -> int:
        r"""
        The number of independent variables (1 or 2).

        Notes
        -----
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return self._get_number_of_independent_variables()


    @property
    def is_one_dimensional(self) -> bool:
        r"""
        Whether the variable is a one-dimensional dependent variable (`Variable1D`).

        Notes
        -----
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        """
        return self._is_one_dimensional()


    @property
    def is_two_dimensional(self) -> bool:
        r"""
        Whether the variable is a two-dimensional dependent variable (`Variable2D`).

        Notes
        -----
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return self._is_two_dimensional()


    @property
    def parent_group_name(self) -> str:
        r"""
        The name of the parent group.

        Notes
        -----
        - The name of the parent group is indicated by the value of GENLAB label in the header file.
        """
        return self._get_parent_group_name()


    @property
    def parent_group_number(self) -> int:
        r"""
        The number of the parent group.

        Notes
        -----
        - The group number is unique within a given run.
        - The group number is used in the file extension of the group.
        """
        return self._get_parent_group_number()


    @property
    def parent_group_header_file_full_path(self) -> str:
        r"""
        The the full path to the parent group header file.
        """
        return self._get_parent_group_header_file_full_path()


    @property
    def time_domain_simulation_length(self) -> float:
        r"""
        The length in seconds of the time domain simulation.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - Use `Run.execution_duration_seconds` to get the wall-clock duration of a calculation.
        """
        return self._get_time_domain_simulation_length()


    @property
    def time_domain_simulation_output_timestep(self) -> float:
        r"""
        The output timestep used in the time domain simulation.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - The output timestep is indicated by the STEP field of the parent group header file.
        """
        return self._get_time_domain_simulation_output_timestep()


    @property
    def time_domain_simulation_output_start_time(self) -> float:
        r"""
        The output start time used in the time domain simulation. This is the first point in the simulation when outputs were written.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - The output start time is indicated by the MIN field of the parent group header file.
        """
        return self._get_time_domain_simulation_output_start_time()


    @property
    def data_point_count(self) -> int:
        r"""
        The number of data points recorded for the variable. In a time domain simulation, this is equivalent to the number of output timesteps.

        Notes
        -----
        - For a `Variable1D`, returns the number of data points recorded.
        - For a `Variable2D`, returns the number of data points recorded for any given secondary independent variable (not the aggregate count of all secondary independent variables).
        """
        return self._get_data_point_count()


    @property
    def data_type(self) -> int:
        r"""
        The data type of the variable.

        Notes
        -----
        - Data type returned may differ from the serialised data type if client has specified a target data type.
        - Use `ResultsApi.CacheSettings` to set the data type to use globally.
        """
        return self._get_data_type()


    @property
    def data_format(self) -> int:
        r"""
        The data format of the variable.
        """
        return self._get_data_format()


    def _get_data_numpy_from_vector(self):
        r"""_get_data_numpy_from_vector(Variable1D_Float64 self) -> PyObject *"""
        return _ResultsAPI_Python.Variable1D_Float64__get_data_numpy_from_vector(self)


    #Wrapped vector to Numpy array conversion without copy
    def get_data(self) -> np.ndarray[np.float64]:
        r"""
        Gets data for the variable.

        Returns
        -------
        np.ndarray[np.float64]
            A NumPy `ndarray` of data points.

        Notes
        -----
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_data_native_array` to avoid this penalty.
        """
        return self._get_data_numpy_from_vector()


# Register Variable1D_Float64 in _ResultsAPI_Python:
_ResultsAPI_Python.Variable1D_Float64_swigregister(Variable1D_Float64)
class Variable1D_Int32(Variable):
    r"""
    Class representing a one-dimensional dependent variable.

    Notes
    -----
    - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
    - The data is stored in a one-dimensional data array - essentially a flat list of values.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def _get_data_native_array(self) -> ArrayOfInt:
        r"""
        Gets data for the variable.

        Returns
        -------
        ArrayOfInt
            A contiguous array of data points.

        Notes
        -----
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Variable1D_Int32__get_data_native_array(self)

    def get_independent_variable(self) -> IndependentVariable:
        r"""
        Gets the independent variable.

        Returns
        -------
        IndependentVariable
            An `IndependentVariable` object.

        Notes
        -----
        - In a time domain simulation, a one-dimensional `Variable1D` object contains just one independent variable: time.
        """
        return _ResultsAPI_Python.Variable1D_Int32_get_independent_variable(self)

    def independent_variable_has_numeric_values(self):
        r"""
        Indicates whether the independent variable has numeric values.

        Returns
        -------
        bool
            A boolean indicating whether the independent variable has numeric values.

        Notes
        -----
        - If the axis is a labelled value or interval axis type, returns `True`.
        - If the axis is a labelled string axis type, returns `False`.
        """
        return _ResultsAPI_Python.Variable1D_Int32_independent_variable_has_numeric_values(self)

    def get_mean(self):
        r"""
        Gets the mean value of the data.

        Returns
        -------
        float
            A double-precision floating-point value containing the mean.
        """
        return _ResultsAPI_Python.Variable1D_Int32_get_mean(self)

    def get_maximum(self):
        r"""
        Gets the maximum value of the data.

        Returns
        -------
        int
            The maximum value, taking the same type as the underlying data.

        Notes
        -----
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        """
        return _ResultsAPI_Python.Variable1D_Int32_get_maximum(self)

    def get_minimum(self):
        r"""
        Gets the minimum value of the data.

        Returns
        -------
        int
            The minimum value, taking the same type as the underlying data.

        Notes
        -----
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        """
        return _ResultsAPI_Python.Variable1D_Int32_get_minimum(self)

    def get_minimum_contemporaneous(self, contemporaneous_variable_name):
        r"""
        Gets the minimum contemporaneous value for the specified one-dimensional variable.

        Parameters
        ----------
        contemporaneous_variable_name : str
            The name of the variable whose contemporaneous value will be sought.

        Returns
        -------
        int
            The minimum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - The minimum contemporaneous value refers to the value of the specified `Variable1D` that occurred when the current `Variable1D` reported its minimum value.
        - Variable name comparison is case-insensitive.
        """
        return _ResultsAPI_Python.Variable1D_Int32_get_minimum_contemporaneous(self, contemporaneous_variable_name)

    def get_maximum_contemporaneous(self, contemporaneous_variable_name):
        r"""
        Gets the maximum contemporaneous value for the specified one-dimensional variable.

        Parameters
        ----------
        contemporaneous_variable_name : str
            The name of the variable whose contemporaneous value will be sought.

        Returns
        -------
        int
            The maximum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - The maximum contemporaneous value refers to the value of the specified `Variable1D` that occurred when the current `Variable1D` reported its maximum value.
        - Variable name comparison is case-insensitive.
        """
        return _ResultsAPI_Python.Variable1D_Int32_get_maximum_contemporaneous(self, contemporaneous_variable_name)
    __swig_destroy__ = _ResultsAPI_Python.delete_Variable1D_Int32

    @property
    def name(self) -> str:
        r"""
        The name of the variable.
        """
        return self._get_name()


    @property
    def si_unit(self) -> str:
        r"""
        The SI unit of the variable, e.g. m for metres.
        """
        result = self._get_si_unit()
        return result.encode('utf-8', 'surrogateescape').decode('ISO-8859-1')


    @property
    def quantity_code(self) -> str:
        r"""
        The quantity code of the variable, e.g. L for length.
        """
        return self._get_quantity_code()


    @property
    def number_of_independent_variables(self) -> int:
        r"""
        The number of independent variables (1 or 2).

        Notes
        -----
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return self._get_number_of_independent_variables()


    @property
    def is_one_dimensional(self) -> bool:
        r"""
        Whether the variable is a one-dimensional dependent variable (`Variable1D`).

        Notes
        -----
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        """
        return self._is_one_dimensional()


    @property
    def is_two_dimensional(self) -> bool:
        r"""
        Whether the variable is a two-dimensional dependent variable (`Variable2D`).

        Notes
        -----
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return self._is_two_dimensional()


    @property
    def parent_group_name(self) -> str:
        r"""
        The name of the parent group.

        Notes
        -----
        - The name of the parent group is indicated by the value of GENLAB label in the header file.
        """
        return self._get_parent_group_name()


    @property
    def parent_group_number(self) -> int:
        r"""
        The number of the parent group.

        Notes
        -----
        - The group number is unique within a given run.
        - The group number is used in the file extension of the group.
        """
        return self._get_parent_group_number()


    @property
    def parent_group_header_file_full_path(self) -> str:
        r"""
        The the full path to the parent group header file.
        """
        return self._get_parent_group_header_file_full_path()


    @property
    def time_domain_simulation_length(self) -> float:
        r"""
        The length in seconds of the time domain simulation.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - Use `Run.execution_duration_seconds` to get the wall-clock duration of a calculation.
        """
        return self._get_time_domain_simulation_length()


    @property
    def time_domain_simulation_output_timestep(self) -> float:
        r"""
        The output timestep used in the time domain simulation.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - The output timestep is indicated by the STEP field of the parent group header file.
        """
        return self._get_time_domain_simulation_output_timestep()


    @property
    def time_domain_simulation_output_start_time(self) -> float:
        r"""
        The output start time used in the time domain simulation. This is the first point in the simulation when outputs were written.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - The output start time is indicated by the MIN field of the parent group header file.
        """
        return self._get_time_domain_simulation_output_start_time()


    @property
    def data_point_count(self) -> int:
        r"""
        The number of data points recorded for the variable. In a time domain simulation, this is equivalent to the number of output timesteps.

        Notes
        -----
        - For a `Variable1D`, returns the number of data points recorded.
        - For a `Variable2D`, returns the number of data points recorded for any given secondary independent variable (not the aggregate count of all secondary independent variables).
        """
        return self._get_data_point_count()


    @property
    def data_type(self) -> int:
        r"""
        The data type of the variable.

        Notes
        -----
        - Data type returned may differ from the serialised data type if client has specified a target data type.
        - Use `ResultsApi.CacheSettings` to set the data type to use globally.
        """
        return self._get_data_type()


    @property
    def data_format(self) -> int:
        r"""
        The data format of the variable.
        """
        return self._get_data_format()


    def _get_data_numpy_from_vector(self):
        r"""_get_data_numpy_from_vector(Variable1D_Int32 self) -> PyObject *"""
        return _ResultsAPI_Python.Variable1D_Int32__get_data_numpy_from_vector(self)


    #Wrapped vector to Numpy array conversion without copy
    def get_data(self) -> np.ndarray[np.int32]:
        r"""
        Gets data for the variable.

        Returns
        -------
        np.ndarray[np.int32]
            A NumPy `ndarray` of data points.

        Notes
        -----
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_data_native_array` to avoid this penalty.
        """
        return self._get_data_numpy_from_vector()


# Register Variable1D_Int32 in _ResultsAPI_Python:
_ResultsAPI_Python.Variable1D_Int32_swigregister(Variable1D_Int32)
class Variable2D_Float32(Variable):
    r"""
    Class representing a two-dimensional dependent variable.

    Notes
    -----
    - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
    - The data is stored in a two-dimensional data array - essentially a table of values arranged in rows x columns.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def _get_data_at_value_native_array(self, *args) -> ArrayOfFloat:
        r"""
        **Function variant 1:**

        Gets data for the specified numeric value of the secondary independent variable.

        Returns
        -------
        ArrayOfFloat
            A contiguous array of data points.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified value.
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.

        |

        **Function variant 2:**

        Gets data for the specified string value of the secondary independent variable.

        Returns
        -------
        ArrayOfFloat
            A contiguous array of data points.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified string, or its numeric equivalent.
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (float): The secondary independent variable numeric value to return data for.

            **Function variant 2:**
              - arg1 (str): The secondary independent variable string value to return data for.
        """
        return _ResultsAPI_Python.Variable2D_Float32__get_data_at_value_native_array(self, *args)

    def _get_data_at_index_native_array(self, secondary_independent_variable_index: int) -> ArrayOfFloat:
        r"""
        Gets data for the specified index of the secondary independent variable.

        Parameters
        ----------
        secondary_independent_variable_index : int
            The zero-based index of the secondary independent variable to return data for.

        Returns
        -------
        ArrayOfFloat
            A contiguous array of data points.

        Notes
        -----
        - This function should be used when a string or numeric value key is not sufficient to uniquely identify the data. This can occur when:

          - The secondary independent variable contains duplicate values.
          - Floating-point artefacts are present (e.g. the value 5.0 written to file as 5.0000001, common in results generated with Bladed 4.7 and earlier).
        - Indices start at 0.
        - Data is returned only if the secondary axis contains an index matching the value specified.
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Variable2D_Float32__get_data_at_index_native_array(self, secondary_independent_variable_index)

    def _get_data_for_all_independent_variable_values_native_array(self) -> ArrayOfArrayOfFloat:
        r"""
        IMPORTANT: This function is deprecated and will be removed in a future release; use `Variable2D.get_data` instead.

        Gets complete data for the variable (i.e. data for each value of the secondary independent variable).
        This function can impact performance with large datasets - see notes for details.

        Returns
        -------
        ArrayOfArrayOfFloat
            A two-dimensional contiguous array of data points.

        Notes
        -----
        - Unless the full dataset is needed, consider using `Variable2D.get_data_at_index` or `Variable2D.get_data_at_value`, which return a subset of the data and help to reduce memory consumption.
        - The returned container is indexed as [secondary][primary]. The outer index corresponds to the secondary independent variable (e.g. measurement location), and the inner index corresponds to the primary independent variable (e.g. time in a time-domain simulation).
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Variable2D_Float32__get_data_for_all_independent_variable_values_native_array(self)

    def _get_data_native_array(self) -> ArrayOfArrayOfFloat:
        r"""
        Gets complete data for the variable (i.e. data for each value of the secondary independent variable).
        This function can impact performance with large datasets - see notes for details.

        Returns
        -------
        ArrayOfArrayOfFloat
            A two-dimensional contiguous array of data points.

        Notes
        -----
        - Unless the full dataset is needed, consider using `Variable2D.get_data_at_index` or `Variable2D.get_data_at_value`, which return a subset of the data and help to reduce memory consumption.
        - The returned container is indexed as [secondary][primary]. The outer index corresponds to the secondary independent variable (e.g. measurement location), and the inner index corresponds to the primary independent variable (e.g. time in a time-domain simulation).
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Variable2D_Float32__get_data_native_array(self)

    def get_mean_at_value(self, *args):
        r"""
        **Function variant 1:**

        Gets the mean value of the data for the specified numeric value of the secondary independent variable.

        Returns
        -------
        float
            A double-precision floating-point value containing the mean.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified value.

        |

        **Function variant 2:**

        Gets the mean value of the data for the specified string value of the secondary independent variable.

        Returns
        -------
        float
            A double-precision floating-point value containing the mean.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified string, or its numeric equivalent.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (float): The secondary independent variable numeric value to return the mean value for.

            **Function variant 2:**
              - arg1 (str): The secondary independent variable string value to return the mean value for.
        """
        return _ResultsAPI_Python.Variable2D_Float32_get_mean_at_value(self, *args)

    def get_mean_at_index(self, secondary_independent_variable_index):
        r"""
        Gets the mean value of the data for the specified index of the secondary independent variable.

        Parameters
        ----------
        secondary_independent_variable_index : int
            The zero-based index of the secondary independent variable to return the mean value for.

        Returns
        -------
        float
            A double-precision floating-point value containing the mean.

        Notes
        -----
        - This function should be used when a string or numeric value key is not sufficient to uniquely identify the data. This can occur when:

          - The secondary independent variable contains duplicate values.
          - Floating-point artefacts are present (e.g. the value 5.0 written to file as 5.0000001, common in results generated with Bladed 4.7 and earlier).
        - Indices start at 0.
        - Data is returned only if the secondary axis contains an index matching the value specified.
        """
        return _ResultsAPI_Python.Variable2D_Float32_get_mean_at_index(self, secondary_independent_variable_index)

    def get_maximum_at_value(self, *args):
        r"""
        **Function variant 1:**

        Gets the maximum value of the data for the specified numeric value of the secondary independent variable.

        Returns
        -------
        float
            The maximum value, taking the same type as the underlying data.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified value.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.

        |

        **Function variant 2:**

        Gets the maximum value of the data for the specified string value of the secondary independent variable.

        Returns
        -------
        float
            The maximum value, taking the same type as the underlying data.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified string, or its numeric equivalent.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (float): The secondary independent variable numeric value to return the maximum value for.

            **Function variant 2:**
              - arg1 (str): The secondary independent variable string value to return the maximum value for.
        """
        return _ResultsAPI_Python.Variable2D_Float32_get_maximum_at_value(self, *args)

    def get_maximum_at_index(self, secondary_independent_variable_index):
        r"""
        Gets the maximum value of the data for the specified index of the secondary independent variable.

        Parameters
        ----------
        secondary_independent_variable_index : int
            The zero-based index of the secondary independent variable to return the mean value for.

        Returns
        -------
        float
            The maximum value, taking the same type as the underlying data.

        Notes
        -----
        - This function should be used when a string or numeric value key is not sufficient to uniquely identify the data. This can occur when:

          - The secondary independent variable contains duplicate values.
          - Floating-point artefacts are present (e.g. the value 5.0 written to file as 5.0000001, common in results generated with Bladed 4.7 and earlier).
        - Indices start at 0.
        - Data is returned only if the secondary axis contains an index matching the value specified.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        """
        return _ResultsAPI_Python.Variable2D_Float32_get_maximum_at_index(self, secondary_independent_variable_index)

    def get_minimum_at_value(self, *args):
        r"""
        **Function variant 1:**

        Gets the minimum value of the data for the specified numeric value of the secondary independent variable.

        Returns
        -------
        float
            The minimum value, taking the same type as the underlying data.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified value.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.

        |

        **Function variant 2:**

        Gets the minimum value of the data for the specified string value of the secondary independent variable.

        Returns
        -------
        float
            The minimum value, taking the same type as the underlying data.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified string, or its numeric equivalent.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (float): The secondary independent variable numeric value to return the minimum value for.

            **Function variant 2:**
              - arg1 (str): The secondary independent variable string value to return the minimum value for.
        """
        return _ResultsAPI_Python.Variable2D_Float32_get_minimum_at_value(self, *args)

    def get_minimum_at_index(self, secondary_independent_variable_index):
        r"""
        Gets the minimum value of the data for the specified index of the secondary independent variable.

        Parameters
        ----------
        secondary_independent_variable_index : int
            The zero-based index of the secondary independent variable to return the mean value for.

        Returns
        -------
        float
            The minimum value, taking the same type as the underlying data.

        Notes
        -----
        - This function should be used when a string or numeric value key is not sufficient to uniquely identify the data. This can occur when:

          - The secondary independent variable contains duplicate values.
          - Floating-point artefacts are present (e.g. the value 5.0 written to file as 5.0000001, common in results generated with Bladed 4.7 and earlier).
        - Indices start at 0.
        - Data is returned only if the secondary axis contains an index matching the value specified.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        """
        return _ResultsAPI_Python.Variable2D_Float32_get_minimum_at_index(self, secondary_independent_variable_index)

    def get_independent_variable(self, *args) -> IndependentVariable:
        r"""
        **Function variant 1:**

        Gets the independent variable for the specified string name.

        Returns
        -------
        IndependentVariable
            An `IndependentVariable` object.

        Notes
        -----
        - The name of the independent variable is indicated by the AXISLAB field of the group header file.
        - In a time domain simulation, a two-dimensional `Variable2D` object contains two independent variables:

          - a primary independent variable: time
          - a secondary independent variable: typically a measurement location (e.g. distance along blade).
        - Independent variable name comparison is case-insensitive.

        |

        **Function variant 2:**

        Gets the independent variable for the specified `INDEPENDENT_VARIABLE_ID` key.

        Returns
        -------
        IndependentVariable
            An `IndependentVariable` object.

        Notes
        -----
        - The name of the independent variable is indicated by the AXISLAB field of the group header file.
        - In a time domain simulation, a two-dimensional `Variable2D` object contains two independent variables:

          - a primary independent variable: time
          - a secondary independent variable: typically a measurement location (e.g. distance along blade).


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (str): The name of the independent variable to return.

            **Function variant 2:**
              - arg1 (int): The `INDEPENDENT_VARIABLE_ID` key value identifying the independent variable to return.
        """
        return _ResultsAPI_Python.Variable2D_Float32_get_independent_variable(self, *args)

    def independent_variable_has_numeric_values(self, independent_variable_id):
        r"""
        Indicates whether the independent variable with the specified `INDEPENDENT_VARIABLE_ID` key has numeric values.

        Parameters
        ----------
        independent_variable_id : int
            The `INDEPENDENT_VARIABLE_ID` key value identifying the independent variable to check.

        Returns
        -------
        bool
            A boolean indicating whether the independent variable has numeric values.

        Notes
        -----
        - If the axis is a labelled value or interval axis type, returns `True`.
        - If the axis is a labelled string axis type, returns `False`.
        """
        return _ResultsAPI_Python.Variable2D_Float32_independent_variable_has_numeric_values(self, independent_variable_id)

    def get_minimum_contemporaneous_at_value(self, *args):
        r"""
        **Function variant 1:**

        Gets the minimum contemporaneous value for the specified `Variable2D` string name and string value of the secondary independent variable.

        Returns
        -------
        float
            The minimum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - The minimum contemporaneous value refers to the value of the specified `Variable2D` and secondary independent variable that occurred when the current `Variable2D` reported its minimum value.
        - Variable name comparison is case-insensitive.

        |

        **Function variant 2:**

        Gets the minimum contemporaneous value for the specified `Variable2D` string name and numeric value of the secondary independent variable.

        Returns
        -------
        float
            The minimum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - The minimum contemporaneous value refers to the value of the specified `Variable2D` and secondary independent variable that occurred when the current `Variable2D` reported its minimum value.
        - Variable name comparison is case-insensitive.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (str): The name of the variable whose contemporaneous value will be sought.
              - arg2 (str): The secondary independent variable string value whose contemporaneous value will be sought.

            **Function variant 2:**
              - arg1 (str): The name of the variable whose contemporaneous value will be sought.
              - arg2 (float): The secondary independent variable numeric value whose contemporaneous value will be sought.
        """
        return _ResultsAPI_Python.Variable2D_Float32_get_minimum_contemporaneous_at_value(self, *args)

    def get_minimum_contemporaneous_at_index(self, contemporaneous_variable_name, secondary_independent_variable_index):
        r"""
        Gets the minimum contemporaneous value for the specified `Variable2D` string name and index of the secondary independent variable.

        Parameters
        ----------
        contemporaneous_variable_name : str
            The name of the variable whose contemporaneous value will be sought.
        secondary_independent_variable_index : int
            The zero-based index of the secondary independent variable to return the minimum contemporaneous value for.

        Returns
        -------
        float
            The minimum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - This function should be used when a string or numeric value key is not sufficient to uniquely identify the data. This can occur when:

          - The secondary independent variable contains duplicate values.
          - Floating-point artefacts are present (e.g. the value 5.0 written to file as 5.0000001, common in results generated with Bladed 4.7 and earlier).
        - Indices start at 0.
        - Data is returned only if the secondary axis contains an index matching the value specified.
        - The minimum contemporaneous value refers to the value of the specified `Variable2D` and secondary independent variable that occurred when the current `Variable2D` reported its minimum value.
        - Variable name comparison is case-insensitive.
        """
        return _ResultsAPI_Python.Variable2D_Float32_get_minimum_contemporaneous_at_index(self, contemporaneous_variable_name, secondary_independent_variable_index)

    def get_maximum_contemporaneous_at_value(self, *args):
        r"""
        **Function variant 1:**

        Gets the maximum contemporaneous value for the specified `Variable2D` string name and string value of the secondary independent variable.

        Returns
        -------
        float
            The maximum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - The maximum contemporaneous value refers to the value of the specified `Variable2D` and secondary independent variable that occurred when the current `Variable2D` reported its maximum value.
        - Variable name comparison is case-insensitive.

        |

        **Function variant 2:**

        Gets the maximum contemporaneous value for the specified `Variable2D` string name and numeric value of the secondary independent variable.

        Returns
        -------
        float
            The maximum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - The maximum contemporaneous value refers to the value of the specified `Variable2D` and secondary independent variable that occurred when the current `Variable2D` reported its maximum value.
        - Variable name comparison is case-insensitive.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (str): The name of the variable whose contemporaneous value will be sought.
              - arg2 (str): The secondary independent variable string value whose contemporaneous value will be sought.

            **Function variant 2:**
              - arg1 (str): The name of the variable whose contemporaneous value will be sought.
              - arg2 (float): The secondary independent variable numeric value whose contemporaneous value will be sought.
        """
        return _ResultsAPI_Python.Variable2D_Float32_get_maximum_contemporaneous_at_value(self, *args)

    def get_maximum_contemporaneous_at_index(self, contemporaneous_variable_name, secondary_independent_variable_index):
        r"""
        Gets the maximum contemporaneous value for the specified `Variable2D` string name and index of the secondary independent variable.

        Parameters
        ----------
        contemporaneous_variable_name : str
            The name of the variable whose contemporaneous value will be sought.
        secondary_independent_variable_index : int
            The zero-based index of the secondary independent variable to return the maximum contemporaneous value for.

        Returns
        -------
        float
            The maximum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - This function should be used when a string or numeric value key is not sufficient to uniquely identify the data. This can occur when:

          - The secondary independent variable contains duplicate values.
          - Floating-point artefacts are present (e.g. the value 5.0 written to file as 5.0000001, common in results generated with Bladed 4.7 and earlier).
        - Indices start at 0.
        - Data is returned only if the secondary axis contains an index matching the value specified.
        - The maximum contemporaneous value refers to the value of the specified `Variable2D` and secondary independent variable that occurred when the current `Variable2D` reported its maximum value.
        - Variable name comparison is case-insensitive.
        """
        return _ResultsAPI_Python.Variable2D_Float32_get_maximum_contemporaneous_at_index(self, contemporaneous_variable_name, secondary_independent_variable_index)
    __swig_destroy__ = _ResultsAPI_Python.delete_Variable2D_Float32

    @property
    def name(self) -> str:
        r"""
        The name of the variable.
        """
        return self._get_name()


    @property
    def si_unit(self) -> str:
        r"""
        The SI unit of the variable, e.g. m for metres.
        """
        result = self._get_si_unit()
        return result.encode('utf-8', 'surrogateescape').decode('ISO-8859-1')


    @property
    def quantity_code(self) -> str:
        r"""
        The quantity code of the variable, e.g. L for length.
        """
        return self._get_quantity_code()


    @property
    def number_of_independent_variables(self) -> int:
        r"""
        The number of independent variables (1 or 2).

        Notes
        -----
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return self._get_number_of_independent_variables()


    @property
    def is_one_dimensional(self) -> bool:
        r"""
        Whether the variable is a one-dimensional dependent variable (`Variable1D`).

        Notes
        -----
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        """
        return self._is_one_dimensional()


    @property
    def is_two_dimensional(self) -> bool:
        r"""
        Whether the variable is a two-dimensional dependent variable (`Variable2D`).

        Notes
        -----
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return self._is_two_dimensional()


    @property
    def parent_group_name(self) -> str:
        r"""
        The name of the parent group.

        Notes
        -----
        - The name of the parent group is indicated by the value of GENLAB label in the header file.
        """
        return self._get_parent_group_name()


    @property
    def parent_group_number(self) -> int:
        r"""
        The number of the parent group.

        Notes
        -----
        - The group number is unique within a given run.
        - The group number is used in the file extension of the group.
        """
        return self._get_parent_group_number()


    @property
    def parent_group_header_file_full_path(self) -> str:
        r"""
        The the full path to the parent group header file.
        """
        return self._get_parent_group_header_file_full_path()


    @property
    def time_domain_simulation_length(self) -> float:
        r"""
        The length in seconds of the time domain simulation.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - Use `Run.execution_duration_seconds` to get the wall-clock duration of a calculation.
        """
        return self._get_time_domain_simulation_length()


    @property
    def time_domain_simulation_output_timestep(self) -> float:
        r"""
        The output timestep used in the time domain simulation.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - The output timestep is indicated by the STEP field of the parent group header file.
        """
        return self._get_time_domain_simulation_output_timestep()


    @property
    def time_domain_simulation_output_start_time(self) -> float:
        r"""
        The output start time used in the time domain simulation. This is the first point in the simulation when outputs were written.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - The output start time is indicated by the MIN field of the parent group header file.
        """
        return self._get_time_domain_simulation_output_start_time()


    @property
    def data_point_count(self) -> int:
        r"""
        The number of data points recorded for the variable. In a time domain simulation, this is equivalent to the number of output timesteps.

        Notes
        -----
        - For a `Variable1D`, returns the number of data points recorded.
        - For a `Variable2D`, returns the number of data points recorded for any given secondary independent variable (not the aggregate count of all secondary independent variables).
        """
        return self._get_data_point_count()


    @property
    def data_type(self) -> int:
        r"""
        The data type of the variable.

        Notes
        -----
        - Data type returned may differ from the serialised data type if client has specified a target data type.
        - Use `ResultsApi.CacheSettings` to set the data type to use globally.
        """
        return self._get_data_type()


    @property
    def data_format(self) -> int:
        r"""
        The data format of the variable.
        """
        return self._get_data_format()


    def _get_data_at_value_numpy_from_vector(self, *args):
        r"""
        _get_data_at_value_numpy_from_vector(Variable2D_Float32 self, std::string const & value) -> PyObject
        _get_data_at_value_numpy_from_vector(Variable2D_Float32 self, double const value) -> PyObject *
        """
        return _ResultsAPI_Python.Variable2D_Float32__get_data_at_value_numpy_from_vector(self, *args)

    def _get_data_at_index_numpy_from_vector(self, value):
        r"""_get_data_at_index_numpy_from_vector(Variable2D_Float32 self, size_t const value) -> PyObject *"""
        return _ResultsAPI_Python.Variable2D_Float32__get_data_at_index_numpy_from_vector(self, value)


    #Wrapped 2D vector to Numpy array conversion
    def get_data(self) -> np.ndarray[np.float32]:
        r"""
        Gets complete data for the variable (i.e. data for each value of the secondary independent variable).
        This function can impact performance with large datasets - see notes for details.

        Returns
        -------
        np.ndarray[np.float32]
            A two-dimensional NumPy `ndarray` of data points.

        Notes
        -----
        - Unless the full dataset is needed, consider using `Variable2D.get_data_at_index` or `Variable2D.get_data_at_value`, which return a subset of the data and help to reduce memory consumption.
        - The returned container is indexed as [secondary][primary]. The outer index corresponds to the secondary independent variable (e.g. measurement location), and the inner index corresponds to the primary independent variable (e.g. time in a time-domain simulation).
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_data_native_array` to avoid this penalty.
        """
        return np.asarray(self._get_data_native_array(), dtype=np.float32)

#Wrapped 2D vector to Numpy array conversion
    def get_data_for_all_independent_variable_values(self) -> np.ndarray[np.float32]:
        r"""
        IMPORTANT: This function is deprecated and will be removed in a future release; use `Variable2D.get_data` instead.

        Gets complete data for the variable (i.e. data for each value of the secondary independent variable).
        This function can impact performance with large datasets - see notes for details.

        Returns
        -------
        np.ndarray[np.float32]
            A two-dimensional NumPy `ndarray` of data points.

        Notes
        -----
        - Unless the full dataset is needed, consider using `Variable2D.get_data_at_index` or `Variable2D.get_data_at_value`, which return a subset of the data and help to reduce memory consumption.
        - The returned container is indexed as [secondary][primary]. The outer index corresponds to the secondary independent variable (e.g. measurement location), and the inner index corresponds to the primary independent variable (e.g. time in a time-domain simulation).
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_data_for_all_independent_variable_values_native_array` to avoid this penalty.
        """
        return np.asarray(self._get_data_for_all_independent_variable_values_native_array(), dtype=np.float32)

#Wrapped vector to Numpy array conversion without copy
    def get_data_at_value(self, *args) -> np.ndarray[np.float32]:
        r"""
        **Function variant 1:**

        Gets data for the specified numeric value of the secondary independent variable.

        Returns
        -------
        np.ndarray[np.float32]
            A NumPy `ndarray` of data points.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified value.
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_data_at_value_native_array` to avoid this penalty.

        |

        **Function variant 2:**

        Gets data for the specified string value of the secondary independent variable.

        Returns
        -------
        np.ndarray[np.float32]
            A NumPy `ndarray` of data points.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified string, or its numeric equivalent.
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_data_at_value_native_array` to avoid this penalty.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (float): The secondary independent variable numeric value to return data for.

            **Function variant 2:**
              - arg1 (str): The secondary independent variable string value to return data for.
        """
        return self._get_data_at_value_numpy_from_vector(args[0])

#Wrapped vector to Numpy array conversion without copy
    def get_data_at_index(self, secondary_independent_variable_index: int) -> np.ndarray[np.float32]:
        r"""
        Gets data for the specified index of the secondary independent variable.

        Parameters
        ----------
        secondary_independent_variable_index : int
            The zero-based index of the secondary independent variable to return data for.

        Returns
        -------
        np.ndarray[np.float32]
            A NumPy `ndarray` of data points.

        Notes
        -----
        - This function should be used when a string or numeric value key is not sufficient to uniquely identify the data. This can occur when:

          - The secondary independent variable contains duplicate values.
          - Floating-point artefacts are present (e.g. the value 5.0 written to file as 5.0000001, common in results generated with Bladed 4.7 and earlier).
        - Indices start at 0.
        - Data is returned only if the secondary axis contains an index matching the value specified.
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_data_at_index_native_array` to avoid this penalty.
        """
        return self._get_data_at_index_numpy_from_vector(secondary_independent_variable_index)


# Register Variable2D_Float32 in _ResultsAPI_Python:
_ResultsAPI_Python.Variable2D_Float32_swigregister(Variable2D_Float32)
class Variable2D_Float64(Variable):
    r"""
    Class representing a two-dimensional dependent variable.

    Notes
    -----
    - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
    - The data is stored in a two-dimensional data array - essentially a table of values arranged in rows x columns.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def _get_data_at_value_native_array(self, *args) -> ArrayOfDouble:
        r"""
        **Function variant 1:**

        Gets data for the specified numeric value of the secondary independent variable.

        Returns
        -------
        ArrayOfDouble
            A contiguous array of data points.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified value.
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.

        |

        **Function variant 2:**

        Gets data for the specified string value of the secondary independent variable.

        Returns
        -------
        ArrayOfDouble
            A contiguous array of data points.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified string, or its numeric equivalent.
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (float): The secondary independent variable numeric value to return data for.

            **Function variant 2:**
              - arg1 (str): The secondary independent variable string value to return data for.
        """
        return _ResultsAPI_Python.Variable2D_Float64__get_data_at_value_native_array(self, *args)

    def _get_data_at_index_native_array(self, secondary_independent_variable_index: int) -> ArrayOfDouble:
        r"""
        Gets data for the specified index of the secondary independent variable.

        Parameters
        ----------
        secondary_independent_variable_index : int
            The zero-based index of the secondary independent variable to return data for.

        Returns
        -------
        ArrayOfDouble
            A contiguous array of data points.

        Notes
        -----
        - This function should be used when a string or numeric value key is not sufficient to uniquely identify the data. This can occur when:

          - The secondary independent variable contains duplicate values.
          - Floating-point artefacts are present (e.g. the value 5.0 written to file as 5.0000001, common in results generated with Bladed 4.7 and earlier).
        - Indices start at 0.
        - Data is returned only if the secondary axis contains an index matching the value specified.
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Variable2D_Float64__get_data_at_index_native_array(self, secondary_independent_variable_index)

    def _get_data_for_all_independent_variable_values_native_array(self) -> ArrayOfArrayOfDouble:
        r"""
        IMPORTANT: This function is deprecated and will be removed in a future release; use `Variable2D.get_data` instead.

        Gets complete data for the variable (i.e. data for each value of the secondary independent variable).
        This function can impact performance with large datasets - see notes for details.

        Returns
        -------
        ArrayOfArrayOfDouble
            A two-dimensional contiguous array of data points.

        Notes
        -----
        - Unless the full dataset is needed, consider using `Variable2D.get_data_at_index` or `Variable2D.get_data_at_value`, which return a subset of the data and help to reduce memory consumption.
        - The returned container is indexed as [secondary][primary]. The outer index corresponds to the secondary independent variable (e.g. measurement location), and the inner index corresponds to the primary independent variable (e.g. time in a time-domain simulation).
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Variable2D_Float64__get_data_for_all_independent_variable_values_native_array(self)

    def _get_data_native_array(self) -> ArrayOfArrayOfDouble:
        r"""
        Gets complete data for the variable (i.e. data for each value of the secondary independent variable).
        This function can impact performance with large datasets - see notes for details.

        Returns
        -------
        ArrayOfArrayOfDouble
            A two-dimensional contiguous array of data points.

        Notes
        -----
        - Unless the full dataset is needed, consider using `Variable2D.get_data_at_index` or `Variable2D.get_data_at_value`, which return a subset of the data and help to reduce memory consumption.
        - The returned container is indexed as [secondary][primary]. The outer index corresponds to the secondary independent variable (e.g. measurement location), and the inner index corresponds to the primary independent variable (e.g. time in a time-domain simulation).
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Variable2D_Float64__get_data_native_array(self)

    def get_mean_at_value(self, *args):
        r"""
        **Function variant 1:**

        Gets the mean value of the data for the specified numeric value of the secondary independent variable.

        Returns
        -------
        float
            A double-precision floating-point value containing the mean.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified value.

        |

        **Function variant 2:**

        Gets the mean value of the data for the specified string value of the secondary independent variable.

        Returns
        -------
        float
            A double-precision floating-point value containing the mean.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified string, or its numeric equivalent.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (float): The secondary independent variable numeric value to return the mean value for.

            **Function variant 2:**
              - arg1 (str): The secondary independent variable string value to return the mean value for.
        """
        return _ResultsAPI_Python.Variable2D_Float64_get_mean_at_value(self, *args)

    def get_mean_at_index(self, secondary_independent_variable_index):
        r"""
        Gets the mean value of the data for the specified index of the secondary independent variable.

        Parameters
        ----------
        secondary_independent_variable_index : int
            The zero-based index of the secondary independent variable to return the mean value for.

        Returns
        -------
        float
            A double-precision floating-point value containing the mean.

        Notes
        -----
        - This function should be used when a string or numeric value key is not sufficient to uniquely identify the data. This can occur when:

          - The secondary independent variable contains duplicate values.
          - Floating-point artefacts are present (e.g. the value 5.0 written to file as 5.0000001, common in results generated with Bladed 4.7 and earlier).
        - Indices start at 0.
        - Data is returned only if the secondary axis contains an index matching the value specified.
        """
        return _ResultsAPI_Python.Variable2D_Float64_get_mean_at_index(self, secondary_independent_variable_index)

    def get_maximum_at_value(self, *args):
        r"""
        **Function variant 1:**

        Gets the maximum value of the data for the specified numeric value of the secondary independent variable.

        Returns
        -------
        float
            The maximum value, taking the same type as the underlying data.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified value.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.

        |

        **Function variant 2:**

        Gets the maximum value of the data for the specified string value of the secondary independent variable.

        Returns
        -------
        float
            The maximum value, taking the same type as the underlying data.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified string, or its numeric equivalent.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (float): The secondary independent variable numeric value to return the maximum value for.

            **Function variant 2:**
              - arg1 (str): The secondary independent variable string value to return the maximum value for.
        """
        return _ResultsAPI_Python.Variable2D_Float64_get_maximum_at_value(self, *args)

    def get_maximum_at_index(self, secondary_independent_variable_index):
        r"""
        Gets the maximum value of the data for the specified index of the secondary independent variable.

        Parameters
        ----------
        secondary_independent_variable_index : int
            The zero-based index of the secondary independent variable to return the mean value for.

        Returns
        -------
        float
            The maximum value, taking the same type as the underlying data.

        Notes
        -----
        - This function should be used when a string or numeric value key is not sufficient to uniquely identify the data. This can occur when:

          - The secondary independent variable contains duplicate values.
          - Floating-point artefacts are present (e.g. the value 5.0 written to file as 5.0000001, common in results generated with Bladed 4.7 and earlier).
        - Indices start at 0.
        - Data is returned only if the secondary axis contains an index matching the value specified.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        """
        return _ResultsAPI_Python.Variable2D_Float64_get_maximum_at_index(self, secondary_independent_variable_index)

    def get_minimum_at_value(self, *args):
        r"""
        **Function variant 1:**

        Gets the minimum value of the data for the specified numeric value of the secondary independent variable.

        Returns
        -------
        float
            The minimum value, taking the same type as the underlying data.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified value.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.

        |

        **Function variant 2:**

        Gets the minimum value of the data for the specified string value of the secondary independent variable.

        Returns
        -------
        float
            The minimum value, taking the same type as the underlying data.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified string, or its numeric equivalent.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (float): The secondary independent variable numeric value to return the minimum value for.

            **Function variant 2:**
              - arg1 (str): The secondary independent variable string value to return the minimum value for.
        """
        return _ResultsAPI_Python.Variable2D_Float64_get_minimum_at_value(self, *args)

    def get_minimum_at_index(self, secondary_independent_variable_index):
        r"""
        Gets the minimum value of the data for the specified index of the secondary independent variable.

        Parameters
        ----------
        secondary_independent_variable_index : int
            The zero-based index of the secondary independent variable to return the mean value for.

        Returns
        -------
        float
            The minimum value, taking the same type as the underlying data.

        Notes
        -----
        - This function should be used when a string or numeric value key is not sufficient to uniquely identify the data. This can occur when:

          - The secondary independent variable contains duplicate values.
          - Floating-point artefacts are present (e.g. the value 5.0 written to file as 5.0000001, common in results generated with Bladed 4.7 and earlier).
        - Indices start at 0.
        - Data is returned only if the secondary axis contains an index matching the value specified.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        """
        return _ResultsAPI_Python.Variable2D_Float64_get_minimum_at_index(self, secondary_independent_variable_index)

    def get_independent_variable(self, *args) -> IndependentVariable:
        r"""
        **Function variant 1:**

        Gets the independent variable for the specified string name.

        Returns
        -------
        IndependentVariable
            An `IndependentVariable` object.

        Notes
        -----
        - The name of the independent variable is indicated by the AXISLAB field of the group header file.
        - In a time domain simulation, a two-dimensional `Variable2D` object contains two independent variables:

          - a primary independent variable: time
          - a secondary independent variable: typically a measurement location (e.g. distance along blade).
        - Independent variable name comparison is case-insensitive.

        |

        **Function variant 2:**

        Gets the independent variable for the specified `INDEPENDENT_VARIABLE_ID` key.

        Returns
        -------
        IndependentVariable
            An `IndependentVariable` object.

        Notes
        -----
        - The name of the independent variable is indicated by the AXISLAB field of the group header file.
        - In a time domain simulation, a two-dimensional `Variable2D` object contains two independent variables:

          - a primary independent variable: time
          - a secondary independent variable: typically a measurement location (e.g. distance along blade).


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (str): The name of the independent variable to return.

            **Function variant 2:**
              - arg1 (int): The `INDEPENDENT_VARIABLE_ID` key value identifying the independent variable to return.
        """
        return _ResultsAPI_Python.Variable2D_Float64_get_independent_variable(self, *args)

    def independent_variable_has_numeric_values(self, independent_variable_id):
        r"""
        Indicates whether the independent variable with the specified `INDEPENDENT_VARIABLE_ID` key has numeric values.

        Parameters
        ----------
        independent_variable_id : int
            The `INDEPENDENT_VARIABLE_ID` key value identifying the independent variable to check.

        Returns
        -------
        bool
            A boolean indicating whether the independent variable has numeric values.

        Notes
        -----
        - If the axis is a labelled value or interval axis type, returns `True`.
        - If the axis is a labelled string axis type, returns `False`.
        """
        return _ResultsAPI_Python.Variable2D_Float64_independent_variable_has_numeric_values(self, independent_variable_id)

    def get_minimum_contemporaneous_at_value(self, *args):
        r"""
        **Function variant 1:**

        Gets the minimum contemporaneous value for the specified `Variable2D` string name and string value of the secondary independent variable.

        Returns
        -------
        float
            The minimum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - The minimum contemporaneous value refers to the value of the specified `Variable2D` and secondary independent variable that occurred when the current `Variable2D` reported its minimum value.
        - Variable name comparison is case-insensitive.

        |

        **Function variant 2:**

        Gets the minimum contemporaneous value for the specified `Variable2D` string name and numeric value of the secondary independent variable.

        Returns
        -------
        float
            The minimum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - The minimum contemporaneous value refers to the value of the specified `Variable2D` and secondary independent variable that occurred when the current `Variable2D` reported its minimum value.
        - Variable name comparison is case-insensitive.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (str): The name of the variable whose contemporaneous value will be sought.
              - arg2 (str): The secondary independent variable string value whose contemporaneous value will be sought.

            **Function variant 2:**
              - arg1 (str): The name of the variable whose contemporaneous value will be sought.
              - arg2 (float): The secondary independent variable numeric value whose contemporaneous value will be sought.
        """
        return _ResultsAPI_Python.Variable2D_Float64_get_minimum_contemporaneous_at_value(self, *args)

    def get_minimum_contemporaneous_at_index(self, contemporaneous_variable_name, secondary_independent_variable_index):
        r"""
        Gets the minimum contemporaneous value for the specified `Variable2D` string name and index of the secondary independent variable.

        Parameters
        ----------
        contemporaneous_variable_name : str
            The name of the variable whose contemporaneous value will be sought.
        secondary_independent_variable_index : int
            The zero-based index of the secondary independent variable to return the minimum contemporaneous value for.

        Returns
        -------
        float
            The minimum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - This function should be used when a string or numeric value key is not sufficient to uniquely identify the data. This can occur when:

          - The secondary independent variable contains duplicate values.
          - Floating-point artefacts are present (e.g. the value 5.0 written to file as 5.0000001, common in results generated with Bladed 4.7 and earlier).
        - Indices start at 0.
        - Data is returned only if the secondary axis contains an index matching the value specified.
        - The minimum contemporaneous value refers to the value of the specified `Variable2D` and secondary independent variable that occurred when the current `Variable2D` reported its minimum value.
        - Variable name comparison is case-insensitive.
        """
        return _ResultsAPI_Python.Variable2D_Float64_get_minimum_contemporaneous_at_index(self, contemporaneous_variable_name, secondary_independent_variable_index)

    def get_maximum_contemporaneous_at_value(self, *args):
        r"""
        **Function variant 1:**

        Gets the maximum contemporaneous value for the specified `Variable2D` string name and string value of the secondary independent variable.

        Returns
        -------
        float
            The maximum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - The maximum contemporaneous value refers to the value of the specified `Variable2D` and secondary independent variable that occurred when the current `Variable2D` reported its maximum value.
        - Variable name comparison is case-insensitive.

        |

        **Function variant 2:**

        Gets the maximum contemporaneous value for the specified `Variable2D` string name and numeric value of the secondary independent variable.

        Returns
        -------
        float
            The maximum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - The maximum contemporaneous value refers to the value of the specified `Variable2D` and secondary independent variable that occurred when the current `Variable2D` reported its maximum value.
        - Variable name comparison is case-insensitive.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (str): The name of the variable whose contemporaneous value will be sought.
              - arg2 (str): The secondary independent variable string value whose contemporaneous value will be sought.

            **Function variant 2:**
              - arg1 (str): The name of the variable whose contemporaneous value will be sought.
              - arg2 (float): The secondary independent variable numeric value whose contemporaneous value will be sought.
        """
        return _ResultsAPI_Python.Variable2D_Float64_get_maximum_contemporaneous_at_value(self, *args)

    def get_maximum_contemporaneous_at_index(self, contemporaneous_variable_name, secondary_independent_variable_index):
        r"""
        Gets the maximum contemporaneous value for the specified `Variable2D` string name and index of the secondary independent variable.

        Parameters
        ----------
        contemporaneous_variable_name : str
            The name of the variable whose contemporaneous value will be sought.
        secondary_independent_variable_index : int
            The zero-based index of the secondary independent variable to return the maximum contemporaneous value for.

        Returns
        -------
        float
            The maximum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - This function should be used when a string or numeric value key is not sufficient to uniquely identify the data. This can occur when:

          - The secondary independent variable contains duplicate values.
          - Floating-point artefacts are present (e.g. the value 5.0 written to file as 5.0000001, common in results generated with Bladed 4.7 and earlier).
        - Indices start at 0.
        - Data is returned only if the secondary axis contains an index matching the value specified.
        - The maximum contemporaneous value refers to the value of the specified `Variable2D` and secondary independent variable that occurred when the current `Variable2D` reported its maximum value.
        - Variable name comparison is case-insensitive.
        """
        return _ResultsAPI_Python.Variable2D_Float64_get_maximum_contemporaneous_at_index(self, contemporaneous_variable_name, secondary_independent_variable_index)
    __swig_destroy__ = _ResultsAPI_Python.delete_Variable2D_Float64

    @property
    def name(self) -> str:
        r"""
        The name of the variable.
        """
        return self._get_name()


    @property
    def si_unit(self) -> str:
        r"""
        The SI unit of the variable, e.g. m for metres.
        """
        result = self._get_si_unit()
        return result.encode('utf-8', 'surrogateescape').decode('ISO-8859-1')


    @property
    def quantity_code(self) -> str:
        r"""
        The quantity code of the variable, e.g. L for length.
        """
        return self._get_quantity_code()


    @property
    def number_of_independent_variables(self) -> int:
        r"""
        The number of independent variables (1 or 2).

        Notes
        -----
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return self._get_number_of_independent_variables()


    @property
    def is_one_dimensional(self) -> bool:
        r"""
        Whether the variable is a one-dimensional dependent variable (`Variable1D`).

        Notes
        -----
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        """
        return self._is_one_dimensional()


    @property
    def is_two_dimensional(self) -> bool:
        r"""
        Whether the variable is a two-dimensional dependent variable (`Variable2D`).

        Notes
        -----
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return self._is_two_dimensional()


    @property
    def parent_group_name(self) -> str:
        r"""
        The name of the parent group.

        Notes
        -----
        - The name of the parent group is indicated by the value of GENLAB label in the header file.
        """
        return self._get_parent_group_name()


    @property
    def parent_group_number(self) -> int:
        r"""
        The number of the parent group.

        Notes
        -----
        - The group number is unique within a given run.
        - The group number is used in the file extension of the group.
        """
        return self._get_parent_group_number()


    @property
    def parent_group_header_file_full_path(self) -> str:
        r"""
        The the full path to the parent group header file.
        """
        return self._get_parent_group_header_file_full_path()


    @property
    def time_domain_simulation_length(self) -> float:
        r"""
        The length in seconds of the time domain simulation.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - Use `Run.execution_duration_seconds` to get the wall-clock duration of a calculation.
        """
        return self._get_time_domain_simulation_length()


    @property
    def time_domain_simulation_output_timestep(self) -> float:
        r"""
        The output timestep used in the time domain simulation.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - The output timestep is indicated by the STEP field of the parent group header file.
        """
        return self._get_time_domain_simulation_output_timestep()


    @property
    def time_domain_simulation_output_start_time(self) -> float:
        r"""
        The output start time used in the time domain simulation. This is the first point in the simulation when outputs were written.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - The output start time is indicated by the MIN field of the parent group header file.
        """
        return self._get_time_domain_simulation_output_start_time()


    @property
    def data_point_count(self) -> int:
        r"""
        The number of data points recorded for the variable. In a time domain simulation, this is equivalent to the number of output timesteps.

        Notes
        -----
        - For a `Variable1D`, returns the number of data points recorded.
        - For a `Variable2D`, returns the number of data points recorded for any given secondary independent variable (not the aggregate count of all secondary independent variables).
        """
        return self._get_data_point_count()


    @property
    def data_type(self) -> int:
        r"""
        The data type of the variable.

        Notes
        -----
        - Data type returned may differ from the serialised data type if client has specified a target data type.
        - Use `ResultsApi.CacheSettings` to set the data type to use globally.
        """
        return self._get_data_type()


    @property
    def data_format(self) -> int:
        r"""
        The data format of the variable.
        """
        return self._get_data_format()


    def _get_data_at_value_numpy_from_vector(self, *args):
        r"""
        _get_data_at_value_numpy_from_vector(Variable2D_Float64 self, std::string const & value) -> PyObject
        _get_data_at_value_numpy_from_vector(Variable2D_Float64 self, double const value) -> PyObject *
        """
        return _ResultsAPI_Python.Variable2D_Float64__get_data_at_value_numpy_from_vector(self, *args)

    def _get_data_at_index_numpy_from_vector(self, value):
        r"""_get_data_at_index_numpy_from_vector(Variable2D_Float64 self, size_t const value) -> PyObject *"""
        return _ResultsAPI_Python.Variable2D_Float64__get_data_at_index_numpy_from_vector(self, value)


    #Wrapped 2D vector to Numpy array conversion
    def get_data(self) -> np.ndarray[np.float64]:
        r"""
        Gets complete data for the variable (i.e. data for each value of the secondary independent variable).
        This function can impact performance with large datasets - see notes for details.

        Returns
        -------
        np.ndarray[np.float64]
            A two-dimensional NumPy `ndarray` of data points.

        Notes
        -----
        - Unless the full dataset is needed, consider using `Variable2D.get_data_at_index` or `Variable2D.get_data_at_value`, which return a subset of the data and help to reduce memory consumption.
        - The returned container is indexed as [secondary][primary]. The outer index corresponds to the secondary independent variable (e.g. measurement location), and the inner index corresponds to the primary independent variable (e.g. time in a time-domain simulation).
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_data_native_array` to avoid this penalty.
        """
        return np.asarray(self._get_data_native_array(), dtype=np.float64)

#Wrapped 2D vector to Numpy array conversion
    def get_data_for_all_independent_variable_values(self) -> np.ndarray[np.float64]:
        r"""
        IMPORTANT: This function is deprecated and will be removed in a future release; use `Variable2D.get_data` instead.

        Gets complete data for the variable (i.e. data for each value of the secondary independent variable).
        This function can impact performance with large datasets - see notes for details.

        Returns
        -------
        np.ndarray[np.float64]
            A two-dimensional NumPy `ndarray` of data points.

        Notes
        -----
        - Unless the full dataset is needed, consider using `Variable2D.get_data_at_index` or `Variable2D.get_data_at_value`, which return a subset of the data and help to reduce memory consumption.
        - The returned container is indexed as [secondary][primary]. The outer index corresponds to the secondary independent variable (e.g. measurement location), and the inner index corresponds to the primary independent variable (e.g. time in a time-domain simulation).
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_data_for_all_independent_variable_values_native_array` to avoid this penalty.
        """
        return np.asarray(self._get_data_for_all_independent_variable_values_native_array(), dtype=np.float64)

#Wrapped vector to Numpy array conversion without copy
    def get_data_at_value(self, *args) -> np.ndarray[np.float64]:
        r"""
        **Function variant 1:**

        Gets data for the specified numeric value of the secondary independent variable.

        Returns
        -------
        np.ndarray[np.float64]
            A NumPy `ndarray` of data points.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified value.
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_data_at_value_native_array` to avoid this penalty.

        |

        **Function variant 2:**

        Gets data for the specified string value of the secondary independent variable.

        Returns
        -------
        np.ndarray[np.float64]
            A NumPy `ndarray` of data points.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified string, or its numeric equivalent.
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_data_at_value_native_array` to avoid this penalty.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (float): The secondary independent variable numeric value to return data for.

            **Function variant 2:**
              - arg1 (str): The secondary independent variable string value to return data for.
        """
        return self._get_data_at_value_numpy_from_vector(args[0])

#Wrapped vector to Numpy array conversion without copy
    def get_data_at_index(self, secondary_independent_variable_index: int) -> np.ndarray[np.float64]:
        r"""
        Gets data for the specified index of the secondary independent variable.

        Parameters
        ----------
        secondary_independent_variable_index : int
            The zero-based index of the secondary independent variable to return data for.

        Returns
        -------
        np.ndarray[np.float64]
            A NumPy `ndarray` of data points.

        Notes
        -----
        - This function should be used when a string or numeric value key is not sufficient to uniquely identify the data. This can occur when:

          - The secondary independent variable contains duplicate values.
          - Floating-point artefacts are present (e.g. the value 5.0 written to file as 5.0000001, common in results generated with Bladed 4.7 and earlier).
        - Indices start at 0.
        - Data is returned only if the secondary axis contains an index matching the value specified.
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_data_at_index_native_array` to avoid this penalty.
        """
        return self._get_data_at_index_numpy_from_vector(secondary_independent_variable_index)


# Register Variable2D_Float64 in _ResultsAPI_Python:
_ResultsAPI_Python.Variable2D_Float64_swigregister(Variable2D_Float64)
class Variable2D_Int32(Variable):
    r"""
    Class representing a two-dimensional dependent variable.

    Notes
    -----
    - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
    - The data is stored in a two-dimensional data array - essentially a table of values arranged in rows x columns.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def _get_data_at_value_native_array(self, *args) -> ArrayOfInt:
        r"""
        **Function variant 1:**

        Gets data for the specified numeric value of the secondary independent variable.

        Returns
        -------
        ArrayOfInt
            A contiguous array of data points.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified value.
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.

        |

        **Function variant 2:**

        Gets data for the specified string value of the secondary independent variable.

        Returns
        -------
        ArrayOfInt
            A contiguous array of data points.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified string, or its numeric equivalent.
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (float): The secondary independent variable numeric value to return data for.

            **Function variant 2:**
              - arg1 (str): The secondary independent variable string value to return data for.
        """
        return _ResultsAPI_Python.Variable2D_Int32__get_data_at_value_native_array(self, *args)

    def _get_data_at_index_native_array(self, secondary_independent_variable_index: int) -> ArrayOfInt:
        r"""
        Gets data for the specified index of the secondary independent variable.

        Parameters
        ----------
        secondary_independent_variable_index : int
            The zero-based index of the secondary independent variable to return data for.

        Returns
        -------
        ArrayOfInt
            A contiguous array of data points.

        Notes
        -----
        - This function should be used when a string or numeric value key is not sufficient to uniquely identify the data. This can occur when:

          - The secondary independent variable contains duplicate values.
          - Floating-point artefacts are present (e.g. the value 5.0 written to file as 5.0000001, common in results generated with Bladed 4.7 and earlier).
        - Indices start at 0.
        - Data is returned only if the secondary axis contains an index matching the value specified.
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Variable2D_Int32__get_data_at_index_native_array(self, secondary_independent_variable_index)

    def _get_data_for_all_independent_variable_values_native_array(self) -> ArrayOfArrayOfInt:
        r"""
        IMPORTANT: This function is deprecated and will be removed in a future release; use `Variable2D.get_data` instead.

        Gets complete data for the variable (i.e. data for each value of the secondary independent variable).
        This function can impact performance with large datasets - see notes for details.

        Returns
        -------
        ArrayOfArrayOfInt
            A two-dimensional contiguous array of data points.

        Notes
        -----
        - Unless the full dataset is needed, consider using `Variable2D.get_data_at_index` or `Variable2D.get_data_at_value`, which return a subset of the data and help to reduce memory consumption.
        - The returned container is indexed as [secondary][primary]. The outer index corresponds to the secondary independent variable (e.g. measurement location), and the inner index corresponds to the primary independent variable (e.g. time in a time-domain simulation).
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Variable2D_Int32__get_data_for_all_independent_variable_values_native_array(self)

    def _get_data_native_array(self) -> ArrayOfArrayOfInt:
        r"""
        Gets complete data for the variable (i.e. data for each value of the secondary independent variable).
        This function can impact performance with large datasets - see notes for details.

        Returns
        -------
        ArrayOfArrayOfInt
            A two-dimensional contiguous array of data points.

        Notes
        -----
        - Unless the full dataset is needed, consider using `Variable2D.get_data_at_index` or `Variable2D.get_data_at_value`, which return a subset of the data and help to reduce memory consumption.
        - The returned container is indexed as [secondary][primary]. The outer index corresponds to the secondary independent variable (e.g. measurement location), and the inner index corresponds to the primary independent variable (e.g. time in a time-domain simulation).
        - Access array elements using subscript operator (`[]`). Arrays are base 0.
        - Enquire the length of the array using Python's built-in `len()` function.
        """
        return _ResultsAPI_Python.Variable2D_Int32__get_data_native_array(self)

    def get_mean_at_value(self, *args):
        r"""
        **Function variant 1:**

        Gets the mean value of the data for the specified numeric value of the secondary independent variable.

        Returns
        -------
        float
            A double-precision floating-point value containing the mean.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified value.

        |

        **Function variant 2:**

        Gets the mean value of the data for the specified string value of the secondary independent variable.

        Returns
        -------
        float
            A double-precision floating-point value containing the mean.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified string, or its numeric equivalent.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (float): The secondary independent variable numeric value to return the mean value for.

            **Function variant 2:**
              - arg1 (str): The secondary independent variable string value to return the mean value for.
        """
        return _ResultsAPI_Python.Variable2D_Int32_get_mean_at_value(self, *args)

    def get_mean_at_index(self, secondary_independent_variable_index):
        r"""
        Gets the mean value of the data for the specified index of the secondary independent variable.

        Parameters
        ----------
        secondary_independent_variable_index : int
            The zero-based index of the secondary independent variable to return the mean value for.

        Returns
        -------
        float
            A double-precision floating-point value containing the mean.

        Notes
        -----
        - This function should be used when a string or numeric value key is not sufficient to uniquely identify the data. This can occur when:

          - The secondary independent variable contains duplicate values.
          - Floating-point artefacts are present (e.g. the value 5.0 written to file as 5.0000001, common in results generated with Bladed 4.7 and earlier).
        - Indices start at 0.
        - Data is returned only if the secondary axis contains an index matching the value specified.
        """
        return _ResultsAPI_Python.Variable2D_Int32_get_mean_at_index(self, secondary_independent_variable_index)

    def get_maximum_at_value(self, *args):
        r"""
        **Function variant 1:**

        Gets the maximum value of the data for the specified numeric value of the secondary independent variable.

        Returns
        -------
        int
            The maximum value, taking the same type as the underlying data.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified value.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.

        |

        **Function variant 2:**

        Gets the maximum value of the data for the specified string value of the secondary independent variable.

        Returns
        -------
        int
            The maximum value, taking the same type as the underlying data.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified string, or its numeric equivalent.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (float): The secondary independent variable numeric value to return the maximum value for.

            **Function variant 2:**
              - arg1 (str): The secondary independent variable string value to return the maximum value for.
        """
        return _ResultsAPI_Python.Variable2D_Int32_get_maximum_at_value(self, *args)

    def get_maximum_at_index(self, secondary_independent_variable_index):
        r"""
        Gets the maximum value of the data for the specified index of the secondary independent variable.

        Parameters
        ----------
        secondary_independent_variable_index : int
            The zero-based index of the secondary independent variable to return the mean value for.

        Returns
        -------
        int
            The maximum value, taking the same type as the underlying data.

        Notes
        -----
        - This function should be used when a string or numeric value key is not sufficient to uniquely identify the data. This can occur when:

          - The secondary independent variable contains duplicate values.
          - Floating-point artefacts are present (e.g. the value 5.0 written to file as 5.0000001, common in results generated with Bladed 4.7 and earlier).
        - Indices start at 0.
        - Data is returned only if the secondary axis contains an index matching the value specified.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        """
        return _ResultsAPI_Python.Variable2D_Int32_get_maximum_at_index(self, secondary_independent_variable_index)

    def get_minimum_at_value(self, *args):
        r"""
        **Function variant 1:**

        Gets the minimum value of the data for the specified numeric value of the secondary independent variable.

        Returns
        -------
        int
            The minimum value, taking the same type as the underlying data.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified value.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.

        |

        **Function variant 2:**

        Gets the minimum value of the data for the specified string value of the secondary independent variable.

        Returns
        -------
        int
            The minimum value, taking the same type as the underlying data.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified string, or its numeric equivalent.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (float): The secondary independent variable numeric value to return the minimum value for.

            **Function variant 2:**
              - arg1 (str): The secondary independent variable string value to return the minimum value for.
        """
        return _ResultsAPI_Python.Variable2D_Int32_get_minimum_at_value(self, *args)

    def get_minimum_at_index(self, secondary_independent_variable_index):
        r"""
        Gets the minimum value of the data for the specified index of the secondary independent variable.

        Parameters
        ----------
        secondary_independent_variable_index : int
            The zero-based index of the secondary independent variable to return the mean value for.

        Returns
        -------
        int
            The minimum value, taking the same type as the underlying data.

        Notes
        -----
        - This function should be used when a string or numeric value key is not sufficient to uniquely identify the data. This can occur when:

          - The secondary independent variable contains duplicate values.
          - Floating-point artefacts are present (e.g. the value 5.0 written to file as 5.0000001, common in results generated with Bladed 4.7 and earlier).
        - Indices start at 0.
        - Data is returned only if the secondary axis contains an index matching the value specified.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        """
        return _ResultsAPI_Python.Variable2D_Int32_get_minimum_at_index(self, secondary_independent_variable_index)

    def get_independent_variable(self, *args) -> IndependentVariable:
        r"""
        **Function variant 1:**

        Gets the independent variable for the specified string name.

        Returns
        -------
        IndependentVariable
            An `IndependentVariable` object.

        Notes
        -----
        - The name of the independent variable is indicated by the AXISLAB field of the group header file.
        - In a time domain simulation, a two-dimensional `Variable2D` object contains two independent variables:

          - a primary independent variable: time
          - a secondary independent variable: typically a measurement location (e.g. distance along blade).
        - Independent variable name comparison is case-insensitive.

        |

        **Function variant 2:**

        Gets the independent variable for the specified `INDEPENDENT_VARIABLE_ID` key.

        Returns
        -------
        IndependentVariable
            An `IndependentVariable` object.

        Notes
        -----
        - The name of the independent variable is indicated by the AXISLAB field of the group header file.
        - In a time domain simulation, a two-dimensional `Variable2D` object contains two independent variables:

          - a primary independent variable: time
          - a secondary independent variable: typically a measurement location (e.g. distance along blade).


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (str): The name of the independent variable to return.

            **Function variant 2:**
              - arg1 (int): The `INDEPENDENT_VARIABLE_ID` key value identifying the independent variable to return.
        """
        return _ResultsAPI_Python.Variable2D_Int32_get_independent_variable(self, *args)

    def independent_variable_has_numeric_values(self, independent_variable_id):
        r"""
        Indicates whether the independent variable with the specified `INDEPENDENT_VARIABLE_ID` key has numeric values.

        Parameters
        ----------
        independent_variable_id : int
            The `INDEPENDENT_VARIABLE_ID` key value identifying the independent variable to check.

        Returns
        -------
        bool
            A boolean indicating whether the independent variable has numeric values.

        Notes
        -----
        - If the axis is a labelled value or interval axis type, returns `True`.
        - If the axis is a labelled string axis type, returns `False`.
        """
        return _ResultsAPI_Python.Variable2D_Int32_independent_variable_has_numeric_values(self, independent_variable_id)

    def get_minimum_contemporaneous_at_value(self, *args):
        r"""
        **Function variant 1:**

        Gets the minimum contemporaneous value for the specified `Variable2D` string name and string value of the secondary independent variable.

        Returns
        -------
        int
            The minimum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - The minimum contemporaneous value refers to the value of the specified `Variable2D` and secondary independent variable that occurred when the current `Variable2D` reported its minimum value.
        - Variable name comparison is case-insensitive.

        |

        **Function variant 2:**

        Gets the minimum contemporaneous value for the specified `Variable2D` string name and numeric value of the secondary independent variable.

        Returns
        -------
        int
            The minimum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - The minimum contemporaneous value refers to the value of the specified `Variable2D` and secondary independent variable that occurred when the current `Variable2D` reported its minimum value.
        - Variable name comparison is case-insensitive.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (str): The name of the variable whose contemporaneous value will be sought.
              - arg2 (str): The secondary independent variable string value whose contemporaneous value will be sought.

            **Function variant 2:**
              - arg1 (str): The name of the variable whose contemporaneous value will be sought.
              - arg2 (float): The secondary independent variable numeric value whose contemporaneous value will be sought.
        """
        return _ResultsAPI_Python.Variable2D_Int32_get_minimum_contemporaneous_at_value(self, *args)

    def get_minimum_contemporaneous_at_index(self, contemporaneous_variable_name, secondary_independent_variable_index):
        r"""
        Gets the minimum contemporaneous value for the specified `Variable2D` string name and index of the secondary independent variable.

        Parameters
        ----------
        contemporaneous_variable_name : str
            The name of the variable whose contemporaneous value will be sought.
        secondary_independent_variable_index : int
            The zero-based index of the secondary independent variable to return the minimum contemporaneous value for.

        Returns
        -------
        int
            The minimum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - This function should be used when a string or numeric value key is not sufficient to uniquely identify the data. This can occur when:

          - The secondary independent variable contains duplicate values.
          - Floating-point artefacts are present (e.g. the value 5.0 written to file as 5.0000001, common in results generated with Bladed 4.7 and earlier).
        - Indices start at 0.
        - Data is returned only if the secondary axis contains an index matching the value specified.
        - The minimum contemporaneous value refers to the value of the specified `Variable2D` and secondary independent variable that occurred when the current `Variable2D` reported its minimum value.
        - Variable name comparison is case-insensitive.
        """
        return _ResultsAPI_Python.Variable2D_Int32_get_minimum_contemporaneous_at_index(self, contemporaneous_variable_name, secondary_independent_variable_index)

    def get_maximum_contemporaneous_at_value(self, *args):
        r"""
        **Function variant 1:**

        Gets the maximum contemporaneous value for the specified `Variable2D` string name and string value of the secondary independent variable.

        Returns
        -------
        int
            The maximum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - The maximum contemporaneous value refers to the value of the specified `Variable2D` and secondary independent variable that occurred when the current `Variable2D` reported its maximum value.
        - Variable name comparison is case-insensitive.

        |

        **Function variant 2:**

        Gets the maximum contemporaneous value for the specified `Variable2D` string name and numeric value of the secondary independent variable.

        Returns
        -------
        int
            The maximum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - The maximum contemporaneous value refers to the value of the specified `Variable2D` and secondary independent variable that occurred when the current `Variable2D` reported its maximum value.
        - Variable name comparison is case-insensitive.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (str): The name of the variable whose contemporaneous value will be sought.
              - arg2 (str): The secondary independent variable string value whose contemporaneous value will be sought.

            **Function variant 2:**
              - arg1 (str): The name of the variable whose contemporaneous value will be sought.
              - arg2 (float): The secondary independent variable numeric value whose contemporaneous value will be sought.
        """
        return _ResultsAPI_Python.Variable2D_Int32_get_maximum_contemporaneous_at_value(self, *args)

    def get_maximum_contemporaneous_at_index(self, contemporaneous_variable_name, secondary_independent_variable_index):
        r"""
        Gets the maximum contemporaneous value for the specified `Variable2D` string name and index of the secondary independent variable.

        Parameters
        ----------
        contemporaneous_variable_name : str
            The name of the variable whose contemporaneous value will be sought.
        secondary_independent_variable_index : int
            The zero-based index of the secondary independent variable to return the maximum contemporaneous value for.

        Returns
        -------
        int
            The maximum contemporaneous value, taking the same type as the underlying data.

        Notes
        -----
        - This function should be used when a string or numeric value key is not sufficient to uniquely identify the data. This can occur when:

          - The secondary independent variable contains duplicate values.
          - Floating-point artefacts are present (e.g. the value 5.0 written to file as 5.0000001, common in results generated with Bladed 4.7 and earlier).
        - Indices start at 0.
        - Data is returned only if the secondary axis contains an index matching the value specified.
        - The maximum contemporaneous value refers to the value of the specified `Variable2D` and secondary independent variable that occurred when the current `Variable2D` reported its maximum value.
        - Variable name comparison is case-insensitive.
        """
        return _ResultsAPI_Python.Variable2D_Int32_get_maximum_contemporaneous_at_index(self, contemporaneous_variable_name, secondary_independent_variable_index)
    __swig_destroy__ = _ResultsAPI_Python.delete_Variable2D_Int32

    @property
    def name(self) -> str:
        r"""
        The name of the variable.
        """
        return self._get_name()


    @property
    def si_unit(self) -> str:
        r"""
        The SI unit of the variable, e.g. m for metres.
        """
        result = self._get_si_unit()
        return result.encode('utf-8', 'surrogateescape').decode('ISO-8859-1')


    @property
    def quantity_code(self) -> str:
        r"""
        The quantity code of the variable, e.g. L for length.
        """
        return self._get_quantity_code()


    @property
    def number_of_independent_variables(self) -> int:
        r"""
        The number of independent variables (1 or 2).

        Notes
        -----
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return self._get_number_of_independent_variables()


    @property
    def is_one_dimensional(self) -> bool:
        r"""
        Whether the variable is a one-dimensional dependent variable (`Variable1D`).

        Notes
        -----
        - A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
        """
        return self._is_one_dimensional()


    @property
    def is_two_dimensional(self) -> bool:
        r"""
        Whether the variable is a two-dimensional dependent variable (`Variable2D`).

        Notes
        -----
        - A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
        """
        return self._is_two_dimensional()


    @property
    def parent_group_name(self) -> str:
        r"""
        The name of the parent group.

        Notes
        -----
        - The name of the parent group is indicated by the value of GENLAB label in the header file.
        """
        return self._get_parent_group_name()


    @property
    def parent_group_number(self) -> int:
        r"""
        The number of the parent group.

        Notes
        -----
        - The group number is unique within a given run.
        - The group number is used in the file extension of the group.
        """
        return self._get_parent_group_number()


    @property
    def parent_group_header_file_full_path(self) -> str:
        r"""
        The the full path to the parent group header file.
        """
        return self._get_parent_group_header_file_full_path()


    @property
    def time_domain_simulation_length(self) -> float:
        r"""
        The length in seconds of the time domain simulation.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - Use `Run.execution_duration_seconds` to get the wall-clock duration of a calculation.
        """
        return self._get_time_domain_simulation_length()


    @property
    def time_domain_simulation_output_timestep(self) -> float:
        r"""
        The output timestep used in the time domain simulation.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - The output timestep is indicated by the STEP field of the parent group header file.
        """
        return self._get_time_domain_simulation_output_timestep()


    @property
    def time_domain_simulation_output_start_time(self) -> float:
        r"""
        The output start time used in the time domain simulation. This is the first point in the simulation when outputs were written.

        Notes
        -----
        - Applies only to time domain simulations; raises an exception if requested for a non-time domain calculation.
        - The output start time is indicated by the MIN field of the parent group header file.
        """
        return self._get_time_domain_simulation_output_start_time()


    @property
    def data_point_count(self) -> int:
        r"""
        The number of data points recorded for the variable. In a time domain simulation, this is equivalent to the number of output timesteps.

        Notes
        -----
        - For a `Variable1D`, returns the number of data points recorded.
        - For a `Variable2D`, returns the number of data points recorded for any given secondary independent variable (not the aggregate count of all secondary independent variables).
        """
        return self._get_data_point_count()


    @property
    def data_type(self) -> int:
        r"""
        The data type of the variable.

        Notes
        -----
        - Data type returned may differ from the serialised data type if client has specified a target data type.
        - Use `ResultsApi.CacheSettings` to set the data type to use globally.
        """
        return self._get_data_type()


    @property
    def data_format(self) -> int:
        r"""
        The data format of the variable.
        """
        return self._get_data_format()


    def _get_data_at_value_numpy_from_vector(self, *args):
        r"""
        _get_data_at_value_numpy_from_vector(Variable2D_Int32 self, std::string const & value) -> PyObject
        _get_data_at_value_numpy_from_vector(Variable2D_Int32 self, double const value) -> PyObject *
        """
        return _ResultsAPI_Python.Variable2D_Int32__get_data_at_value_numpy_from_vector(self, *args)

    def _get_data_at_index_numpy_from_vector(self, value):
        r"""_get_data_at_index_numpy_from_vector(Variable2D_Int32 self, size_t const value) -> PyObject *"""
        return _ResultsAPI_Python.Variable2D_Int32__get_data_at_index_numpy_from_vector(self, value)


    #Wrapped 2D vector to Numpy array conversion
    def get_data(self) -> np.ndarray[np.int32]:
        r"""
        Gets complete data for the variable (i.e. data for each value of the secondary independent variable).
        This function can impact performance with large datasets - see notes for details.

        Returns
        -------
        np.ndarray[np.int32]
            A two-dimensional NumPy `ndarray` of data points.

        Notes
        -----
        - Unless the full dataset is needed, consider using `Variable2D.get_data_at_index` or `Variable2D.get_data_at_value`, which return a subset of the data and help to reduce memory consumption.
        - The returned container is indexed as [secondary][primary]. The outer index corresponds to the secondary independent variable (e.g. measurement location), and the inner index corresponds to the primary independent variable (e.g. time in a time-domain simulation).
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_data_native_array` to avoid this penalty.
        """
        return np.asarray(self._get_data_native_array(), dtype=np.int32)

#Wrapped 2D vector to Numpy array conversion
    def get_data_for_all_independent_variable_values(self) -> np.ndarray[np.int32]:
        r"""
        IMPORTANT: This function is deprecated and will be removed in a future release; use `Variable2D.get_data` instead.

        Gets complete data for the variable (i.e. data for each value of the secondary independent variable).
        This function can impact performance with large datasets - see notes for details.

        Returns
        -------
        np.ndarray[np.int32]
            A two-dimensional NumPy `ndarray` of data points.

        Notes
        -----
        - Unless the full dataset is needed, consider using `Variable2D.get_data_at_index` or `Variable2D.get_data_at_value`, which return a subset of the data and help to reduce memory consumption.
        - The returned container is indexed as [secondary][primary]. The outer index corresponds to the secondary independent variable (e.g. measurement location), and the inner index corresponds to the primary independent variable (e.g. time in a time-domain simulation).
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_data_for_all_independent_variable_values_native_array` to avoid this penalty.
        """
        return np.asarray(self._get_data_for_all_independent_variable_values_native_array(), dtype=np.int32)

#Wrapped vector to Numpy array conversion without copy
    def get_data_at_value(self, *args) -> np.ndarray[np.int32]:
        r"""
        **Function variant 1:**

        Gets data for the specified numeric value of the secondary independent variable.

        Returns
        -------
        np.ndarray[np.int32]
            A NumPy `ndarray` of data points.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified value.
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_data_at_value_native_array` to avoid this penalty.

        |

        **Function variant 2:**

        Gets data for the specified string value of the secondary independent variable.

        Returns
        -------
        np.ndarray[np.int32]
            A NumPy `ndarray` of data points.

        Notes
        -----
        - Data is returned only if the secondary axis contains the specified string, or its numeric equivalent.
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_data_at_value_native_array` to avoid this penalty.


        Parameters
        ----------
        *args : tuple
            Variable length argument list. Arguments can take one of the following forms:

            **Function variant 1:**
              - arg1 (float): The secondary independent variable numeric value to return data for.

            **Function variant 2:**
              - arg1 (str): The secondary independent variable string value to return data for.
        """
        return self._get_data_at_value_numpy_from_vector(args[0])

#Wrapped vector to Numpy array conversion without copy
    def get_data_at_index(self, secondary_independent_variable_index: int) -> np.ndarray[np.int32]:
        r"""
        Gets data for the specified index of the secondary independent variable.

        Parameters
        ----------
        secondary_independent_variable_index : int
            The zero-based index of the secondary independent variable to return data for.

        Returns
        -------
        np.ndarray[np.int32]
            A NumPy `ndarray` of data points.

        Notes
        -----
        - This function should be used when a string or numeric value key is not sufficient to uniquely identify the data. This can occur when:

          - The secondary independent variable contains duplicate values.
          - Floating-point artefacts are present (e.g. the value 5.0 written to file as 5.0000001, common in results generated with Bladed 4.7 and earlier).
        - Indices start at 0.
        - Data is returned only if the secondary axis contains an index matching the value specified.
        - In a time domain simulation, each point represents the value of the variable at an output timestep.
        - The order of elements in the returned container matches the order in which they were written.
        - The type (and hence precision) of the data may be enquired using `Variable.data_type`.
        - Requesting a NumPy array incurs a performance penalty which will not be noticeable in most cases. In highly performance-sensitive code, use native array returned by function `_get_data_at_index_native_array` to avoid this penalty.
        """
        return self._get_data_at_index_numpy_from_vector(secondary_independent_variable_index)


# Register Variable2D_Int32 in _ResultsAPI_Python:
_ResultsAPI_Python.Variable2D_Int32_swigregister(Variable2D_Int32)
class OutputGroup1D_Float32(OutputGroup):
    r"""
    Class representing a one-dimensional Bladed group for writing.

    A one-dimensional output group contains data for dependent variables with respect to one independent variable, such as time.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Constructor for a one-dimensional Bladed output group object.

        Parameters
        ----------
        *args : tuple
            Variable length argument list.

            - **arg1**
              (str) : The path to the output group header file.

            - **arg2**
              (str) : The output group name. Provides a description of the data contained in the group.

            - **arg3**
              (str) : The output group data source, indicated by the CONTENT field of the header file. Enter 'UserDefined' for the group to have a calculation type equal to `CALCULATION_TYPE_USER_DEFINED`. This allows filtering on outputs with type `CALCULATION_TYPE_USER_DEFINED` when seeking runs, to distinguish them from runs created by Bladed. The value passed must correspond to a supported calculation type, such as 'POWPROD' or 'UserDefined', otherwise the output group will not be readable by the Results API.

            - **arg4**
              (str) : The output group config value, indicated by the CONFIG field of the header file. Typically one of `TRANSIENT`, `STATIONARY`, `LIST`, or `TABLE`.

            - **arg5**
              (IndependentVariable) : The `IndependentVariable` object for the output group. Delimits data points belonging to variables added to the group.

            - **arg6**
              (int, optional) : An integer constant indicating the data format to use. Default = `VARIABLE_DATA_FORMAT_BINARY`. Refer to individual `VARIABLE_DATA_FORMAT` constants for further information.

        Returns
        -------
        OutputGroup1D
            An `OutputGroup1D` object.

        Notes
        -----
        - An `OutputGroup1D` object is used to write one-dimensional variables to disk using the Bladed file format.
        - The `dataSource` parameter value must correspond to a supported calculation type, such as 'POWPROD' or 'UserDefined'. If not, the output group will not be readable by the Results API.
        """
        _ResultsAPI_Python.OutputGroup1D_Float32_swiginit(self, _ResultsAPI_Python.new_OutputGroup1D_Float32(*args))

    def add_variable(self, variable_name, si_unit):
        r"""
        Adds a one-dimensional variable to the output group.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        si_unit : str
            The SI unit of the variable.

        Notes
        -----
        - To add a variable and its data in the same call, use `OutputGroup1D.add_variable_with_data`.
        - To append data to an existing variable, use `OutputGroup1D.append_data`.
        - The SI unit will be converted to a Bladed quantity code if such a conversion exists; otherwise the unit string will be written as supplied.
        """
        return _ResultsAPI_Python.OutputGroup1D_Float32_add_variable(self, variable_name, si_unit)

    def _add_variable_with_data_native_array(self, variable_name, si_unit, data):
        r"""
        Adds a one-dimensional variable to the output group, including data.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        si_unit : str
            The SI unit of the variable.
        data : ArrayOfFloat
            A one-dimensional contiguous array of data points.

        Notes
        -----
        - To append further data to an existing variable, use `OutputGroup1D.append_data`.
        - The SI unit will be converted to a Bladed quantity code if such a conversion exists; otherwise the unit string will be written as supplied.
        """
        return _ResultsAPI_Python.OutputGroup1D_Float32__add_variable_with_data_native_array(self, variable_name, si_unit, data)

    def _append_data_native_array(self, variable_name, data):
        r"""
        Appends data to an existing one-dimensional variable.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        data : ArrayOfFloat
            A one-dimensional contiguous array of data points to append.

        Notes
        -----
        - The variable must exist before data may be appended. To add a variable, use `OutputGroup1D.add_variable` or `OutputGroup1D.add_variable_with_data`.
        """
        return _ResultsAPI_Python.OutputGroup1D_Float32__append_data_native_array(self, variable_name, data)


    def add_variable_with_data(self, variable_name: str, si_unit: str, data: np.ndarray[np.float32]):
        r"""
        Adds a one-dimensional variable to the output group, including data.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        si_unit : str
            The SI unit of the variable.
        data : np.ndarray[np.float32]
            A one-dimensional NumPy `ndarray` of data points.

        Notes
        -----
        - To append further data to an existing variable, use `OutputGroup1D.append_data`.
        - The SI unit will be converted to a Bladed quantity code if such a conversion exists; otherwise the unit string will be written as supplied.
        """
        native_array = ArrayOfFloat(data.data)
        self._add_variable_with_data_native_array(variable_name, si_unit, native_array)

    def append_data(self, variable_name: str, data: np.ndarray[np.float32]):
        r"""
        Appends data to an existing one-dimensional variable.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        data : np.ndarray[np.float32]
            A one-dimensional NumPy `ndarray` of data points to append.

        Notes
        -----
        - The variable must exist before data may be appended. To add a variable, use `OutputGroup1D.add_variable` or `OutputGroup1D.add_variable_with_data`.
        """
        native_array = ArrayOfFloat(data.data)
        self._append_data_native_array(variable_name, native_array)

    __swig_destroy__ = _ResultsAPI_Python.delete_OutputGroup1D_Float32

# Register OutputGroup1D_Float32 in _ResultsAPI_Python:
_ResultsAPI_Python.OutputGroup1D_Float32_swigregister(OutputGroup1D_Float32)
class OutputGroup1D_Float64(OutputGroup):
    r"""
    Class representing a one-dimensional Bladed group for writing.

    A one-dimensional output group contains data for dependent variables with respect to one independent variable, such as time.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Constructor for a one-dimensional Bladed output group object.

        Parameters
        ----------
        *args : tuple
            Variable length argument list.

            - **arg1**
              (str) : The path to the output group header file.

            - **arg2**
              (str) : The output group name. Provides a description of the data contained in the group.

            - **arg3**
              (str) : The output group data source, indicated by the CONTENT field of the header file. Enter 'UserDefined' for the group to have a calculation type equal to `CALCULATION_TYPE_USER_DEFINED`. This allows filtering on outputs with type `CALCULATION_TYPE_USER_DEFINED` when seeking runs, to distinguish them from runs created by Bladed. The value passed must correspond to a supported calculation type, such as 'POWPROD' or 'UserDefined', otherwise the output group will not be readable by the Results API.

            - **arg4**
              (str) : The output group config value, indicated by the CONFIG field of the header file. Typically one of `TRANSIENT`, `STATIONARY`, `LIST`, or `TABLE`.

            - **arg5**
              (IndependentVariable) : The `IndependentVariable` object for the output group. Delimits data points belonging to variables added to the group.

            - **arg6**
              (int, optional) : An integer constant indicating the data format to use. Default = `VARIABLE_DATA_FORMAT_BINARY`. Refer to individual `VARIABLE_DATA_FORMAT` constants for further information.

        Returns
        -------
        OutputGroup1D
            An `OutputGroup1D` object.

        Notes
        -----
        - An `OutputGroup1D` object is used to write one-dimensional variables to disk using the Bladed file format.
        - The `dataSource` parameter value must correspond to a supported calculation type, such as 'POWPROD' or 'UserDefined'. If not, the output group will not be readable by the Results API.
        """
        _ResultsAPI_Python.OutputGroup1D_Float64_swiginit(self, _ResultsAPI_Python.new_OutputGroup1D_Float64(*args))

    def add_variable(self, variable_name, si_unit):
        r"""
        Adds a one-dimensional variable to the output group.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        si_unit : str
            The SI unit of the variable.

        Notes
        -----
        - To add a variable and its data in the same call, use `OutputGroup1D.add_variable_with_data`.
        - To append data to an existing variable, use `OutputGroup1D.append_data`.
        - The SI unit will be converted to a Bladed quantity code if such a conversion exists; otherwise the unit string will be written as supplied.
        """
        return _ResultsAPI_Python.OutputGroup1D_Float64_add_variable(self, variable_name, si_unit)

    def _add_variable_with_data_native_array(self, variable_name, si_unit, data):
        r"""
        Adds a one-dimensional variable to the output group, including data.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        si_unit : str
            The SI unit of the variable.
        data : ArrayOfDouble
            A one-dimensional contiguous array of data points.

        Notes
        -----
        - To append further data to an existing variable, use `OutputGroup1D.append_data`.
        - The SI unit will be converted to a Bladed quantity code if such a conversion exists; otherwise the unit string will be written as supplied.
        """
        return _ResultsAPI_Python.OutputGroup1D_Float64__add_variable_with_data_native_array(self, variable_name, si_unit, data)

    def _append_data_native_array(self, variable_name, data):
        r"""
        Appends data to an existing one-dimensional variable.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        data : ArrayOfDouble
            A one-dimensional contiguous array of data points to append.

        Notes
        -----
        - The variable must exist before data may be appended. To add a variable, use `OutputGroup1D.add_variable` or `OutputGroup1D.add_variable_with_data`.
        """
        return _ResultsAPI_Python.OutputGroup1D_Float64__append_data_native_array(self, variable_name, data)


    def add_variable_with_data(self, variable_name: str, si_unit: str, data: np.ndarray[np.float64]):
        r"""
        Adds a one-dimensional variable to the output group, including data.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        si_unit : str
            The SI unit of the variable.
        data : np.ndarray[np.float64]
            A one-dimensional NumPy `ndarray` of data points.

        Notes
        -----
        - To append further data to an existing variable, use `OutputGroup1D.append_data`.
        - The SI unit will be converted to a Bladed quantity code if such a conversion exists; otherwise the unit string will be written as supplied.
        """
        native_array = ArrayOfDouble(data.data)
        self._add_variable_with_data_native_array(variable_name, si_unit, native_array)

    def append_data(self, variable_name: str, data: np.ndarray[np.float64]):
        r"""
        Appends data to an existing one-dimensional variable.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        data : np.ndarray[np.float64]
            A one-dimensional NumPy `ndarray` of data points to append.

        Notes
        -----
        - The variable must exist before data may be appended. To add a variable, use `OutputGroup1D.add_variable` or `OutputGroup1D.add_variable_with_data`.
        """
        native_array = ArrayOfDouble(data.data)
        self._append_data_native_array(variable_name, native_array)

    __swig_destroy__ = _ResultsAPI_Python.delete_OutputGroup1D_Float64

# Register OutputGroup1D_Float64 in _ResultsAPI_Python:
_ResultsAPI_Python.OutputGroup1D_Float64_swigregister(OutputGroup1D_Float64)
class OutputGroup1D_Int32(OutputGroup):
    r"""
    Class representing a one-dimensional Bladed group for writing.

    A one-dimensional output group contains data for dependent variables with respect to one independent variable, such as time.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Constructor for a one-dimensional Bladed output group object.

        Parameters
        ----------
        *args : tuple
            Variable length argument list.

            - **arg1**
              (str) : The path to the output group header file.

            - **arg2**
              (str) : The output group name. Provides a description of the data contained in the group.

            - **arg3**
              (str) : The output group data source, indicated by the CONTENT field of the header file. Enter 'UserDefined' for the group to have a calculation type equal to `CALCULATION_TYPE_USER_DEFINED`. This allows filtering on outputs with type `CALCULATION_TYPE_USER_DEFINED` when seeking runs, to distinguish them from runs created by Bladed. The value passed must correspond to a supported calculation type, such as 'POWPROD' or 'UserDefined', otherwise the output group will not be readable by the Results API.

            - **arg4**
              (str) : The output group config value, indicated by the CONFIG field of the header file. Typically one of `TRANSIENT`, `STATIONARY`, `LIST`, or `TABLE`.

            - **arg5**
              (IndependentVariable) : The `IndependentVariable` object for the output group. Delimits data points belonging to variables added to the group.

            - **arg6**
              (int, optional) : An integer constant indicating the data format to use. Default = `VARIABLE_DATA_FORMAT_BINARY`. Refer to individual `VARIABLE_DATA_FORMAT` constants for further information.

        Returns
        -------
        OutputGroup1D
            An `OutputGroup1D` object.

        Notes
        -----
        - An `OutputGroup1D` object is used to write one-dimensional variables to disk using the Bladed file format.
        - The `dataSource` parameter value must correspond to a supported calculation type, such as 'POWPROD' or 'UserDefined'. If not, the output group will not be readable by the Results API.
        """
        _ResultsAPI_Python.OutputGroup1D_Int32_swiginit(self, _ResultsAPI_Python.new_OutputGroup1D_Int32(*args))

    def add_variable(self, variable_name, si_unit):
        r"""
        Adds a one-dimensional variable to the output group.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        si_unit : str
            The SI unit of the variable.

        Notes
        -----
        - To add a variable and its data in the same call, use `OutputGroup1D.add_variable_with_data`.
        - To append data to an existing variable, use `OutputGroup1D.append_data`.
        - The SI unit will be converted to a Bladed quantity code if such a conversion exists; otherwise the unit string will be written as supplied.
        """
        return _ResultsAPI_Python.OutputGroup1D_Int32_add_variable(self, variable_name, si_unit)

    def _add_variable_with_data_native_array(self, variable_name, si_unit, data):
        r"""
        Adds a one-dimensional variable to the output group, including data.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        si_unit : str
            The SI unit of the variable.
        data : ArrayOfInt
            A one-dimensional contiguous array of data points.

        Notes
        -----
        - To append further data to an existing variable, use `OutputGroup1D.append_data`.
        - The SI unit will be converted to a Bladed quantity code if such a conversion exists; otherwise the unit string will be written as supplied.
        """
        return _ResultsAPI_Python.OutputGroup1D_Int32__add_variable_with_data_native_array(self, variable_name, si_unit, data)

    def _append_data_native_array(self, variable_name, data):
        r"""
        Appends data to an existing one-dimensional variable.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        data : ArrayOfInt
            A one-dimensional contiguous array of data points to append.

        Notes
        -----
        - The variable must exist before data may be appended. To add a variable, use `OutputGroup1D.add_variable` or `OutputGroup1D.add_variable_with_data`.
        """
        return _ResultsAPI_Python.OutputGroup1D_Int32__append_data_native_array(self, variable_name, data)


    def add_variable_with_data(self, variable_name: str, si_unit: str, data: np.ndarray[np.int32]):
        r"""
        Adds a one-dimensional variable to the output group, including data.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        si_unit : str
            The SI unit of the variable.
        data : np.ndarray[np.int32]
            A one-dimensional NumPy `ndarray` of data points.

        Notes
        -----
        - To append further data to an existing variable, use `OutputGroup1D.append_data`.
        - The SI unit will be converted to a Bladed quantity code if such a conversion exists; otherwise the unit string will be written as supplied.
        """
        native_array = ArrayOfInt(data.data)
        self._add_variable_with_data_native_array(variable_name, si_unit, native_array)

    def append_data(self, variable_name: str, data: np.ndarray[np.int32]):
        r"""
        Appends data to an existing one-dimensional variable.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        data : np.ndarray[np.int32]
            A one-dimensional NumPy `ndarray` of data points to append.

        Notes
        -----
        - The variable must exist before data may be appended. To add a variable, use `OutputGroup1D.add_variable` or `OutputGroup1D.add_variable_with_data`.
        """
        native_array = ArrayOfInt(data.data)
        self._append_data_native_array(variable_name, native_array)

    __swig_destroy__ = _ResultsAPI_Python.delete_OutputGroup1D_Int32

# Register OutputGroup1D_Int32 in _ResultsAPI_Python:
_ResultsAPI_Python.OutputGroup1D_Int32_swigregister(OutputGroup1D_Int32)
class OutputGroup2D_Float32(OutputGroup):
    r"""
    Class representing a two-dimensional Bladed group for writing.

    A two-dimensional output group contains data for dependent variables with respect to two independent variables, such as time, and measurement location (e.g. distance along blade).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Constructor for a two-dimensional Bladed output group object.

        Parameters
        ----------
        *args : tuple
            Variable length argument list.

            - **arg1**
              (str) : The path to the output group header file.

            - **arg2**
              (str) : The output group name. Provides a description of the data contained in the group.

            - **arg3**
              (str) : The output group data source, indicated by the CONTENT field of the header file. Enter 'UserDefined' for the group to have a calculation type equal to `CALCULATION_TYPE_USER_DEFINED`. This allows filtering on outputs with type `CALCULATION_TYPE_USER_DEFINED` when seeking runs, to distinguish them from runs created by Bladed. The value passed must correspond to a supported calculation type, such as 'POWPROD' or 'UserDefined', otherwise the output group will not be readable by the Results API.

            - **arg4**
              (str) : The output group config value, indicated by the CONFIG field of the header file. Typically one of `TRANSIENT`, `STATIONARY`, `LIST`, or `TABLE`.

            - **arg5**
              (IndependentVariable) : The primary `IndependentVariable` object for the output group. Delimits data points belonging to variables added to the group.

            - **arg6**
              (IndependentVariable) : The `IndependentVariable` object for the output group. Delimits contiguous arrays of data points belonging to variables added to the group.

            - **arg7**
              (int, optional) : An integer constant indicating the data format to use. Default = `VARIABLE_DATA_FORMAT_BINARY`. Refer to individual `VARIABLE_DATA_FORMAT` constants for further information.

        Returns
        -------
        OutputGroup2D
            An `OutputGroup2D` object.

        Notes
        -----
        - An `OutputGroup2D` object is used to write two-dimensional variables to disk using the Bladed file format.
        - The `dataSource` parameter value must correspond to a supported calculation type, such as 'POWPROD' or 'UserDefined'. If not, the output group will not be readable by the Results API.
        """
        _ResultsAPI_Python.OutputGroup2D_Float32_swiginit(self, _ResultsAPI_Python.new_OutputGroup2D_Float32(*args))

    def add_variable(self, variable_name, si_unit):
        r"""
        Adds a two-dimensional variable to the output group.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        si_unit : str
            The SI unit of the variable.

        Notes
        -----
        - To add a variable and its data in the same call, use `OutputGroup2D.add_variable_with_data`.
        - To append data to an existing variable, use `OutputGroup2D.append_data`.
        - The SI unit will be converted to a Bladed quantity code if such a conversion exists; otherwise the unit string will be written as supplied.
        """
        return _ResultsAPI_Python.OutputGroup2D_Float32_add_variable(self, variable_name, si_unit)

    def _add_variable_with_data_native_array(self, variable_name, si_unit, data):
        r"""
        Adds a two-dimensional variable to the output group, including data.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        si_unit : str
            The SI unit of the variable.
        data : ArrayOfFloat
            A two-dimensional contiguous array of data points. Each one-dimensional (inner) vector maps to a discrete value of the secondary independent variable.

        Notes
        -----
        - To append further data to an existing variable, use `OutputGroup2D.append_data`.
        - If the secondary independent variable uses string or numeric labels, the indexing order of the one-dimensional vectors must match the indexing order of the labels.
        - The SI unit will be converted to a Bladed quantity code if such a conversion exists; otherwise the unit string will be written as supplied.
        """
        return _ResultsAPI_Python.OutputGroup2D_Float32__add_variable_with_data_native_array(self, variable_name, si_unit, data)

    def _append_data_native_array(self, variable_name, data):
        r"""
        Appends data to an existing two-dimensional variable.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        data : ArrayOfFloat
            A two-dimensional contiguous array of data points to append. Each one-dimensional (inner) vector maps to a discrete value of the secondary independent variable.

        Notes
        -----
        - The variable must exist before data may be appended. To add a variable, use `OutputGroup2D.add_variable` or `OutputGroup2D.add_variable_with_data`.
        - If the secondary independent variable uses string or numeric labels, the indexing order of the one-dimensional vectors must match the indexing order of the labels.
        """
        return _ResultsAPI_Python.OutputGroup2D_Float32__append_data_native_array(self, variable_name, data)


    def add_variable_with_data(self, variable_name: str, si_unit: str, data: np.ndarray[np.float32]):
        r"""
        Adds a two-dimensional variable to the output group, including data.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        si_unit : str
            The SI unit of the variable.
        data : np.ndarray[np.float32]
            A two-dimensional NumPy `ndarray` of data points. Each one-dimensional (inner) vector maps to a discrete value of the secondary independent variable.

        Notes
        -----
        - To append further data to an existing variable, use `OutputGroup2D.append_data`.
        - If the secondary independent variable uses string or numeric labels, the indexing order of the one-dimensional vectors must match the indexing order of the labels.
        - The SI unit will be converted to a Bladed quantity code if such a conversion exists; otherwise the unit string will be written as supplied.
        """
        num_secondary_axis_vals = data.shape[0]
        native_array = ArrayOfArrayOfFloat(num_secondary_axis_vals)

        for i in range(0, num_secondary_axis_vals, 1):
            native_array[i] = data[i].data

        self._add_variable_with_data_native_array(variable_name, si_unit, native_array)

    def append_data(self, variable_name: str, data: np.ndarray[np.float32]):
        r"""
        Appends data to an existing two-dimensional variable.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        data : np.ndarray[np.float32]
            A two-dimensional NumPy `ndarray` of data points to append. Each one-dimensional (inner) vector maps to a discrete value of the secondary independent variable.

        Notes
        -----
        - The variable must exist before data may be appended. To add a variable, use `OutputGroup2D.add_variable` or `OutputGroup2D.add_variable_with_data`.
        - If the secondary independent variable uses string or numeric labels, the indexing order of the one-dimensional vectors must match the indexing order of the labels.
        """
        num_secondary_axis_vals = data.shape[0]
        native_array = ArrayOfArrayOfFloat(num_secondary_axis_vals)

        for i in range(0, num_secondary_axis_vals, 1):
            native_array[i] = data[i].data

        self._append_data_native_array(variable_name, native_array)

    __swig_destroy__ = _ResultsAPI_Python.delete_OutputGroup2D_Float32

# Register OutputGroup2D_Float32 in _ResultsAPI_Python:
_ResultsAPI_Python.OutputGroup2D_Float32_swigregister(OutputGroup2D_Float32)
class OutputGroup2D_Float64(OutputGroup):
    r"""
    Class representing a two-dimensional Bladed group for writing.

    A two-dimensional output group contains data for dependent variables with respect to two independent variables, such as time, and measurement location (e.g. distance along blade).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Constructor for a two-dimensional Bladed output group object.

        Parameters
        ----------
        *args : tuple
            Variable length argument list.

            - **arg1**
              (str) : The path to the output group header file.

            - **arg2**
              (str) : The output group name. Provides a description of the data contained in the group.

            - **arg3**
              (str) : The output group data source, indicated by the CONTENT field of the header file. Enter 'UserDefined' for the group to have a calculation type equal to `CALCULATION_TYPE_USER_DEFINED`. This allows filtering on outputs with type `CALCULATION_TYPE_USER_DEFINED` when seeking runs, to distinguish them from runs created by Bladed. The value passed must correspond to a supported calculation type, such as 'POWPROD' or 'UserDefined', otherwise the output group will not be readable by the Results API.

            - **arg4**
              (str) : The output group config value, indicated by the CONFIG field of the header file. Typically one of `TRANSIENT`, `STATIONARY`, `LIST`, or `TABLE`.

            - **arg5**
              (IndependentVariable) : The primary `IndependentVariable` object for the output group. Delimits data points belonging to variables added to the group.

            - **arg6**
              (IndependentVariable) : The `IndependentVariable` object for the output group. Delimits contiguous arrays of data points belonging to variables added to the group.

            - **arg7**
              (int, optional) : An integer constant indicating the data format to use. Default = `VARIABLE_DATA_FORMAT_BINARY`. Refer to individual `VARIABLE_DATA_FORMAT` constants for further information.

        Returns
        -------
        OutputGroup2D
            An `OutputGroup2D` object.

        Notes
        -----
        - An `OutputGroup2D` object is used to write two-dimensional variables to disk using the Bladed file format.
        - The `dataSource` parameter value must correspond to a supported calculation type, such as 'POWPROD' or 'UserDefined'. If not, the output group will not be readable by the Results API.
        """
        _ResultsAPI_Python.OutputGroup2D_Float64_swiginit(self, _ResultsAPI_Python.new_OutputGroup2D_Float64(*args))

    def add_variable(self, variable_name, si_unit):
        r"""
        Adds a two-dimensional variable to the output group.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        si_unit : str
            The SI unit of the variable.

        Notes
        -----
        - To add a variable and its data in the same call, use `OutputGroup2D.add_variable_with_data`.
        - To append data to an existing variable, use `OutputGroup2D.append_data`.
        - The SI unit will be converted to a Bladed quantity code if such a conversion exists; otherwise the unit string will be written as supplied.
        """
        return _ResultsAPI_Python.OutputGroup2D_Float64_add_variable(self, variable_name, si_unit)

    def _add_variable_with_data_native_array(self, variable_name, si_unit, data):
        r"""
        Adds a two-dimensional variable to the output group, including data.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        si_unit : str
            The SI unit of the variable.
        data : ArrayOfDouble
            A two-dimensional contiguous array of data points. Each one-dimensional (inner) vector maps to a discrete value of the secondary independent variable.

        Notes
        -----
        - To append further data to an existing variable, use `OutputGroup2D.append_data`.
        - If the secondary independent variable uses string or numeric labels, the indexing order of the one-dimensional vectors must match the indexing order of the labels.
        - The SI unit will be converted to a Bladed quantity code if such a conversion exists; otherwise the unit string will be written as supplied.
        """
        return _ResultsAPI_Python.OutputGroup2D_Float64__add_variable_with_data_native_array(self, variable_name, si_unit, data)

    def _append_data_native_array(self, variable_name, data):
        r"""
        Appends data to an existing two-dimensional variable.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        data : ArrayOfDouble
            A two-dimensional contiguous array of data points to append. Each one-dimensional (inner) vector maps to a discrete value of the secondary independent variable.

        Notes
        -----
        - The variable must exist before data may be appended. To add a variable, use `OutputGroup2D.add_variable` or `OutputGroup2D.add_variable_with_data`.
        - If the secondary independent variable uses string or numeric labels, the indexing order of the one-dimensional vectors must match the indexing order of the labels.
        """
        return _ResultsAPI_Python.OutputGroup2D_Float64__append_data_native_array(self, variable_name, data)


    def add_variable_with_data(self, variable_name: str, si_unit: str, data: np.ndarray[np.float64]):
        r"""
        Adds a two-dimensional variable to the output group, including data.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        si_unit : str
            The SI unit of the variable.
        data : np.ndarray[np.float64]
            A two-dimensional NumPy `ndarray` of data points. Each one-dimensional (inner) vector maps to a discrete value of the secondary independent variable.

        Notes
        -----
        - To append further data to an existing variable, use `OutputGroup2D.append_data`.
        - If the secondary independent variable uses string or numeric labels, the indexing order of the one-dimensional vectors must match the indexing order of the labels.
        - The SI unit will be converted to a Bladed quantity code if such a conversion exists; otherwise the unit string will be written as supplied.
        """
        num_secondary_axis_vals = data.shape[0]
        native_array = ArrayOfArrayOfDouble(num_secondary_axis_vals)

        for i in range(0, num_secondary_axis_vals, 1):
            native_array[i] = data[i].data

        self._add_variable_with_data_native_array(variable_name, si_unit, native_array)

    def append_data(self, variable_name: str, data: np.ndarray[np.float64]):
        r"""
        Appends data to an existing two-dimensional variable.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        data : np.ndarray[np.float64]
            A two-dimensional NumPy `ndarray` of data points to append. Each one-dimensional (inner) vector maps to a discrete value of the secondary independent variable.

        Notes
        -----
        - The variable must exist before data may be appended. To add a variable, use `OutputGroup2D.add_variable` or `OutputGroup2D.add_variable_with_data`.
        - If the secondary independent variable uses string or numeric labels, the indexing order of the one-dimensional vectors must match the indexing order of the labels.
        """
        num_secondary_axis_vals = data.shape[0]
        native_array = ArrayOfArrayOfDouble(num_secondary_axis_vals)

        for i in range(0, num_secondary_axis_vals, 1):
            native_array[i] = data[i].data

        self._append_data_native_array(variable_name, native_array)

    __swig_destroy__ = _ResultsAPI_Python.delete_OutputGroup2D_Float64

# Register OutputGroup2D_Float64 in _ResultsAPI_Python:
_ResultsAPI_Python.OutputGroup2D_Float64_swigregister(OutputGroup2D_Float64)
class OutputGroup2D_Int32(OutputGroup):
    r"""
    Class representing a two-dimensional Bladed group for writing.

    A two-dimensional output group contains data for dependent variables with respect to two independent variables, such as time, and measurement location (e.g. distance along blade).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Constructor for a two-dimensional Bladed output group object.

        Parameters
        ----------
        *args : tuple
            Variable length argument list.

            - **arg1**
              (str) : The path to the output group header file.

            - **arg2**
              (str) : The output group name. Provides a description of the data contained in the group.

            - **arg3**
              (str) : The output group data source, indicated by the CONTENT field of the header file. Enter 'UserDefined' for the group to have a calculation type equal to `CALCULATION_TYPE_USER_DEFINED`. This allows filtering on outputs with type `CALCULATION_TYPE_USER_DEFINED` when seeking runs, to distinguish them from runs created by Bladed. The value passed must correspond to a supported calculation type, such as 'POWPROD' or 'UserDefined', otherwise the output group will not be readable by the Results API.

            - **arg4**
              (str) : The output group config value, indicated by the CONFIG field of the header file. Typically one of `TRANSIENT`, `STATIONARY`, `LIST`, or `TABLE`.

            - **arg5**
              (IndependentVariable) : The primary `IndependentVariable` object for the output group. Delimits data points belonging to variables added to the group.

            - **arg6**
              (IndependentVariable) : The `IndependentVariable` object for the output group. Delimits contiguous arrays of data points belonging to variables added to the group.

            - **arg7**
              (int, optional) : An integer constant indicating the data format to use. Default = `VARIABLE_DATA_FORMAT_BINARY`. Refer to individual `VARIABLE_DATA_FORMAT` constants for further information.

        Returns
        -------
        OutputGroup2D
            An `OutputGroup2D` object.

        Notes
        -----
        - An `OutputGroup2D` object is used to write two-dimensional variables to disk using the Bladed file format.
        - The `dataSource` parameter value must correspond to a supported calculation type, such as 'POWPROD' or 'UserDefined'. If not, the output group will not be readable by the Results API.
        """
        _ResultsAPI_Python.OutputGroup2D_Int32_swiginit(self, _ResultsAPI_Python.new_OutputGroup2D_Int32(*args))

    def add_variable(self, variable_name, si_unit):
        r"""
        Adds a two-dimensional variable to the output group.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        si_unit : str
            The SI unit of the variable.

        Notes
        -----
        - To add a variable and its data in the same call, use `OutputGroup2D.add_variable_with_data`.
        - To append data to an existing variable, use `OutputGroup2D.append_data`.
        - The SI unit will be converted to a Bladed quantity code if such a conversion exists; otherwise the unit string will be written as supplied.
        """
        return _ResultsAPI_Python.OutputGroup2D_Int32_add_variable(self, variable_name, si_unit)

    def _add_variable_with_data_native_array(self, variable_name, si_unit, data):
        r"""
        Adds a two-dimensional variable to the output group, including data.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        si_unit : str
            The SI unit of the variable.
        data : ArrayOfInt
            A two-dimensional contiguous array of data points. Each one-dimensional (inner) vector maps to a discrete value of the secondary independent variable.

        Notes
        -----
        - To append further data to an existing variable, use `OutputGroup2D.append_data`.
        - If the secondary independent variable uses string or numeric labels, the indexing order of the one-dimensional vectors must match the indexing order of the labels.
        - The SI unit will be converted to a Bladed quantity code if such a conversion exists; otherwise the unit string will be written as supplied.
        """
        return _ResultsAPI_Python.OutputGroup2D_Int32__add_variable_with_data_native_array(self, variable_name, si_unit, data)

    def _append_data_native_array(self, variable_name, data):
        r"""
        Appends data to an existing two-dimensional variable.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        data : ArrayOfInt
            A two-dimensional contiguous array of data points to append. Each one-dimensional (inner) vector maps to a discrete value of the secondary independent variable.

        Notes
        -----
        - The variable must exist before data may be appended. To add a variable, use `OutputGroup2D.add_variable` or `OutputGroup2D.add_variable_with_data`.
        - If the secondary independent variable uses string or numeric labels, the indexing order of the one-dimensional vectors must match the indexing order of the labels.
        """
        return _ResultsAPI_Python.OutputGroup2D_Int32__append_data_native_array(self, variable_name, data)


    def add_variable_with_data(self, variable_name: str, si_unit: str, data: np.ndarray[np.int32]):
        r"""
        Adds a two-dimensional variable to the output group, including data.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        si_unit : str
            The SI unit of the variable.
        data : np.ndarray[np.int32]
            A two-dimensional NumPy `ndarray` of data points. Each one-dimensional (inner) vector maps to a discrete value of the secondary independent variable.

        Notes
        -----
        - To append further data to an existing variable, use `OutputGroup2D.append_data`.
        - If the secondary independent variable uses string or numeric labels, the indexing order of the one-dimensional vectors must match the indexing order of the labels.
        - The SI unit will be converted to a Bladed quantity code if such a conversion exists; otherwise the unit string will be written as supplied.
        """
        num_secondary_axis_vals = data.shape[0]
        native_array = ArrayOfArrayOfInt(num_secondary_axis_vals)

        for i in range(0, num_secondary_axis_vals, 1):
            native_array[i] = data[i].data

        self._add_variable_with_data_native_array(variable_name, si_unit, native_array)

    def append_data(self, variable_name: str, data: np.ndarray[np.int32]):
        r"""
        Appends data to an existing two-dimensional variable.

        Parameters
        ----------
        variable_name : str
            The name of the variable.
        data : np.ndarray[np.int32]
            A two-dimensional NumPy `ndarray` of data points to append. Each one-dimensional (inner) vector maps to a discrete value of the secondary independent variable.

        Notes
        -----
        - The variable must exist before data may be appended. To add a variable, use `OutputGroup2D.add_variable` or `OutputGroup2D.add_variable_with_data`.
        - If the secondary independent variable uses string or numeric labels, the indexing order of the one-dimensional vectors must match the indexing order of the labels.
        """
        num_secondary_axis_vals = data.shape[0]
        native_array = ArrayOfArrayOfInt(num_secondary_axis_vals)

        for i in range(0, num_secondary_axis_vals, 1):
            native_array[i] = data[i].data

        self._append_data_native_array(variable_name, native_array)

    __swig_destroy__ = _ResultsAPI_Python.delete_OutputGroup2D_Int32

# Register OutputGroup2D_Int32 in _ResultsAPI_Python:
_ResultsAPI_Python.OutputGroup2D_Int32_swigregister(OutputGroup2D_Int32)

from typing import Union
Variable1D = Union[Variable1D_Float32, Variable1D_Float64, Variable1D_Int32] 
"""
Type alias for 1D variables of any type: single precision (float32), double precision (float64) and integer (int32).

- A `Variable1D` represents a dependent variable (e.g. `Rotor speed`) with respect to a single independent variable, such as time.
- The data is stored in a one-dimensional data array - essentially a flat list of values.
""" 

Variable2D = Union[Variable2D_Float32, Variable2D_Float64, Variable2D_Int32] 
"""
Type alias for 2D variables of any type: single precision (float32), double precision (float64) and integer (int32).

- A `Variable2D` represents a dependent variable (e.g. `Blade 1 Mx`) with respect to two independent variables, such as time and measurement location (e.g. distance along blade).
- The data is stored in a two-dimensional data array - essentially a table of values arranged in rows x columns.
""" 

