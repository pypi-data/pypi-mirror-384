# coding: utf-8

"""
    ICAT+ API

    ICAT+ RESTful API with Swagger

    The version of the OpenAPI document: 1.0.0
    Contact: demariaa@esrf.fr
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from icat_plus_client.models.dataacquisition_api_key_base64_post_request import DataacquisitionApiKeyBase64PostRequest
from icat_plus_client.models.event import Event
from icat_plus_client.models.logbook_investigation_stat import LogbookInvestigationStat
from icat_plus_client.models.logbook_investigation_stat_count import LogbookInvestigationStatCount
from icat_plus_client.models.logbook_session_id_event_createfrombase64_post_request import LogbookSessionIdEventCreatefrombase64PostRequest
from icat_plus_client.models.logbook_session_id_event_put_request import LogbookSessionIdEventPutRequest
from icat_plus_client.models.logbook_session_id_events_patch_request import LogbookSessionIdEventsPatchRequest
from icat_plus_client.models.meta import Meta
from icat_plus_client.models.tag import Tag

from icat_plus_client.api_client import ApiClient, RequestSerialized
from icat_plus_client.api_response import ApiResponse
from icat_plus_client.rest import RESTResponseType


class LogbookApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def logbook_api_key_investigation_name_investigation_name_instrument_name_instrument_name_event_createfrombase64_post(
        self,
        investigation_name: Annotated[StrictStr, Field(description="the name of the investigation")],
        instrument_name: Annotated[StrictStr, Field(description="the name of the beamline")],
        api_key: Annotated[StrictStr, Field(description="API key is a simple encrypted string that identifies an application without any principal.")],
        dataacquisition_api_key_base64_post_request: Annotated[DataacquisitionApiKeyBase64PostRequest, Field(description="Encoded image")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Event:
        """Create an event given a base64 string. It requires the API token. This is used on the spec beamlines from the metadata manager


        :param investigation_name: the name of the investigation (required)
        :type investigation_name: str
        :param instrument_name: the name of the beamline (required)
        :type instrument_name: str
        :param api_key: API key is a simple encrypted string that identifies an application without any principal. (required)
        :type api_key: str
        :param dataacquisition_api_key_base64_post_request: Encoded image (required)
        :type dataacquisition_api_key_base64_post_request: DataacquisitionApiKeyBase64PostRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_api_key_investigation_name_investigation_name_instrument_name_instrument_name_event_createfrombase64_post_serialize(
            investigation_name=investigation_name,
            instrument_name=instrument_name,
            api_key=api_key,
            dataacquisition_api_key_base64_post_request=dataacquisition_api_key_base64_post_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Event",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def logbook_api_key_investigation_name_investigation_name_instrument_name_instrument_name_event_createfrombase64_post_with_http_info(
        self,
        investigation_name: Annotated[StrictStr, Field(description="the name of the investigation")],
        instrument_name: Annotated[StrictStr, Field(description="the name of the beamline")],
        api_key: Annotated[StrictStr, Field(description="API key is a simple encrypted string that identifies an application without any principal.")],
        dataacquisition_api_key_base64_post_request: Annotated[DataacquisitionApiKeyBase64PostRequest, Field(description="Encoded image")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Event]:
        """Create an event given a base64 string. It requires the API token. This is used on the spec beamlines from the metadata manager


        :param investigation_name: the name of the investigation (required)
        :type investigation_name: str
        :param instrument_name: the name of the beamline (required)
        :type instrument_name: str
        :param api_key: API key is a simple encrypted string that identifies an application without any principal. (required)
        :type api_key: str
        :param dataacquisition_api_key_base64_post_request: Encoded image (required)
        :type dataacquisition_api_key_base64_post_request: DataacquisitionApiKeyBase64PostRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_api_key_investigation_name_investigation_name_instrument_name_instrument_name_event_createfrombase64_post_serialize(
            investigation_name=investigation_name,
            instrument_name=instrument_name,
            api_key=api_key,
            dataacquisition_api_key_base64_post_request=dataacquisition_api_key_base64_post_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Event",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def logbook_api_key_investigation_name_investigation_name_instrument_name_instrument_name_event_createfrombase64_post_without_preload_content(
        self,
        investigation_name: Annotated[StrictStr, Field(description="the name of the investigation")],
        instrument_name: Annotated[StrictStr, Field(description="the name of the beamline")],
        api_key: Annotated[StrictStr, Field(description="API key is a simple encrypted string that identifies an application without any principal.")],
        dataacquisition_api_key_base64_post_request: Annotated[DataacquisitionApiKeyBase64PostRequest, Field(description="Encoded image")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create an event given a base64 string. It requires the API token. This is used on the spec beamlines from the metadata manager


        :param investigation_name: the name of the investigation (required)
        :type investigation_name: str
        :param instrument_name: the name of the beamline (required)
        :type instrument_name: str
        :param api_key: API key is a simple encrypted string that identifies an application without any principal. (required)
        :type api_key: str
        :param dataacquisition_api_key_base64_post_request: Encoded image (required)
        :type dataacquisition_api_key_base64_post_request: DataacquisitionApiKeyBase64PostRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_api_key_investigation_name_investigation_name_instrument_name_instrument_name_event_createfrombase64_post_serialize(
            investigation_name=investigation_name,
            instrument_name=instrument_name,
            api_key=api_key,
            dataacquisition_api_key_base64_post_request=dataacquisition_api_key_base64_post_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Event",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _logbook_api_key_investigation_name_investigation_name_instrument_name_instrument_name_event_createfrombase64_post_serialize(
        self,
        investigation_name,
        instrument_name,
        api_key,
        dataacquisition_api_key_base64_post_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if investigation_name is not None:
            _path_params['investigationName'] = investigation_name
        if instrument_name is not None:
            _path_params['instrumentName'] = instrument_name
        if api_key is not None:
            _path_params['apiKey'] = api_key
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if dataacquisition_api_key_base64_post_request is not None:
            _body_params = dataacquisition_api_key_base64_post_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/logbook/{apiKey}/investigation/name/{investigationName}/instrument/name/{instrumentName}/event/createfrombase64',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def logbook_api_key_investigation_name_investigation_name_instrument_name_instrument_name_event_post(
        self,
        investigation_name: Annotated[StrictStr, Field(description="the name of the investigation")],
        instrument_name: Annotated[StrictStr, Field(description="the name of the beamline")],
        api_key: Annotated[StrictStr, Field(description="API key is a simple encrypted string that identifies an application without any principal.")],
        event: Annotated[Optional[Event], Field(description="New event to create")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Event:
        """This is used on the spec beamlines from the metadata manager


        :param investigation_name: the name of the investigation (required)
        :type investigation_name: str
        :param instrument_name: the name of the beamline (required)
        :type instrument_name: str
        :param api_key: API key is a simple encrypted string that identifies an application without any principal. (required)
        :type api_key: str
        :param event: New event to create
        :type event: Event
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_api_key_investigation_name_investigation_name_instrument_name_instrument_name_event_post_serialize(
            investigation_name=investigation_name,
            instrument_name=instrument_name,
            api_key=api_key,
            event=event,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Event",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def logbook_api_key_investigation_name_investigation_name_instrument_name_instrument_name_event_post_with_http_info(
        self,
        investigation_name: Annotated[StrictStr, Field(description="the name of the investigation")],
        instrument_name: Annotated[StrictStr, Field(description="the name of the beamline")],
        api_key: Annotated[StrictStr, Field(description="API key is a simple encrypted string that identifies an application without any principal.")],
        event: Annotated[Optional[Event], Field(description="New event to create")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Event]:
        """This is used on the spec beamlines from the metadata manager


        :param investigation_name: the name of the investigation (required)
        :type investigation_name: str
        :param instrument_name: the name of the beamline (required)
        :type instrument_name: str
        :param api_key: API key is a simple encrypted string that identifies an application without any principal. (required)
        :type api_key: str
        :param event: New event to create
        :type event: Event
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_api_key_investigation_name_investigation_name_instrument_name_instrument_name_event_post_serialize(
            investigation_name=investigation_name,
            instrument_name=instrument_name,
            api_key=api_key,
            event=event,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Event",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def logbook_api_key_investigation_name_investigation_name_instrument_name_instrument_name_event_post_without_preload_content(
        self,
        investigation_name: Annotated[StrictStr, Field(description="the name of the investigation")],
        instrument_name: Annotated[StrictStr, Field(description="the name of the beamline")],
        api_key: Annotated[StrictStr, Field(description="API key is a simple encrypted string that identifies an application without any principal.")],
        event: Annotated[Optional[Event], Field(description="New event to create")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """This is used on the spec beamlines from the metadata manager


        :param investigation_name: the name of the investigation (required)
        :type investigation_name: str
        :param instrument_name: the name of the beamline (required)
        :type instrument_name: str
        :param api_key: API key is a simple encrypted string that identifies an application without any principal. (required)
        :type api_key: str
        :param event: New event to create
        :type event: Event
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_api_key_investigation_name_investigation_name_instrument_name_instrument_name_event_post_serialize(
            investigation_name=investigation_name,
            instrument_name=instrument_name,
            api_key=api_key,
            event=event,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Event",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _logbook_api_key_investigation_name_investigation_name_instrument_name_instrument_name_event_post_serialize(
        self,
        investigation_name,
        instrument_name,
        api_key,
        event,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if investigation_name is not None:
            _path_params['investigationName'] = investigation_name
        if instrument_name is not None:
            _path_params['instrumentName'] = instrument_name
        if api_key is not None:
            _path_params['apiKey'] = api_key
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if event is not None:
            _body_params = event


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/logbook/{apiKey}/investigation/name/{investigationName}/instrument/name/{instrumentName}/event',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def logbook_session_id_event_count_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        types: Annotated[Optional[StrictStr], Field(description="comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO")] = None,
        filter_investigation: Annotated[Optional[StrictBool], Field(description="If true the logs with investigationId will not be retrieved")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        var_date: Annotated[Optional[StrictStr], Field(description="filter events on a specific date - format YYYY-MM-DD")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (all match). Example system,calibration")] = None,
        or_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (any match). Example system,calibration")] = None,
        not_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (must not match). Example system,calibration")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="items after start time - format YYYY-MM-DDTHH:mm:ss")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="items before end time - format YYYY-MM-DDTHH:mm:ss")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> float:
        """Count events


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param types: comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO
        :type types: str
        :param filter_investigation: If true the logs with investigationId will not be retrieved
        :type filter_investigation: bool
        :param search: text to be used for filtering the entities
        :type search: str
        :param var_date: filter events on a specific date - format YYYY-MM-DD
        :type var_date: str
        :param tags: comma-separated list of tag names (all match). Example system,calibration
        :type tags: str
        :param or_tags: comma-separated list of tag names (any match). Example system,calibration
        :type or_tags: str
        :param not_tags: comma-separated list of tag names (must not match). Example system,calibration
        :type not_tags: str
        :param start_time: items after start time - format YYYY-MM-DDTHH:mm:ss
        :type start_time: str
        :param end_time: items before end time - format YYYY-MM-DDTHH:mm:ss
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_count_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            types=types,
            filter_investigation=filter_investigation,
            search=search,
            var_date=var_date,
            tags=tags,
            or_tags=or_tags,
            not_tags=not_tags,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "float",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def logbook_session_id_event_count_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        types: Annotated[Optional[StrictStr], Field(description="comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO")] = None,
        filter_investigation: Annotated[Optional[StrictBool], Field(description="If true the logs with investigationId will not be retrieved")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        var_date: Annotated[Optional[StrictStr], Field(description="filter events on a specific date - format YYYY-MM-DD")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (all match). Example system,calibration")] = None,
        or_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (any match). Example system,calibration")] = None,
        not_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (must not match). Example system,calibration")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="items after start time - format YYYY-MM-DDTHH:mm:ss")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="items before end time - format YYYY-MM-DDTHH:mm:ss")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[float]:
        """Count events


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param types: comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO
        :type types: str
        :param filter_investigation: If true the logs with investigationId will not be retrieved
        :type filter_investigation: bool
        :param search: text to be used for filtering the entities
        :type search: str
        :param var_date: filter events on a specific date - format YYYY-MM-DD
        :type var_date: str
        :param tags: comma-separated list of tag names (all match). Example system,calibration
        :type tags: str
        :param or_tags: comma-separated list of tag names (any match). Example system,calibration
        :type or_tags: str
        :param not_tags: comma-separated list of tag names (must not match). Example system,calibration
        :type not_tags: str
        :param start_time: items after start time - format YYYY-MM-DDTHH:mm:ss
        :type start_time: str
        :param end_time: items before end time - format YYYY-MM-DDTHH:mm:ss
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_count_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            types=types,
            filter_investigation=filter_investigation,
            search=search,
            var_date=var_date,
            tags=tags,
            or_tags=or_tags,
            not_tags=not_tags,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "float",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def logbook_session_id_event_count_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        types: Annotated[Optional[StrictStr], Field(description="comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO")] = None,
        filter_investigation: Annotated[Optional[StrictBool], Field(description="If true the logs with investigationId will not be retrieved")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        var_date: Annotated[Optional[StrictStr], Field(description="filter events on a specific date - format YYYY-MM-DD")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (all match). Example system,calibration")] = None,
        or_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (any match). Example system,calibration")] = None,
        not_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (must not match). Example system,calibration")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="items after start time - format YYYY-MM-DDTHH:mm:ss")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="items before end time - format YYYY-MM-DDTHH:mm:ss")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Count events


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param types: comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO
        :type types: str
        :param filter_investigation: If true the logs with investigationId will not be retrieved
        :type filter_investigation: bool
        :param search: text to be used for filtering the entities
        :type search: str
        :param var_date: filter events on a specific date - format YYYY-MM-DD
        :type var_date: str
        :param tags: comma-separated list of tag names (all match). Example system,calibration
        :type tags: str
        :param or_tags: comma-separated list of tag names (any match). Example system,calibration
        :type or_tags: str
        :param not_tags: comma-separated list of tag names (must not match). Example system,calibration
        :type not_tags: str
        :param start_time: items after start time - format YYYY-MM-DDTHH:mm:ss
        :type start_time: str
        :param end_time: items before end time - format YYYY-MM-DDTHH:mm:ss
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_count_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            types=types,
            filter_investigation=filter_investigation,
            search=search,
            var_date=var_date,
            tags=tags,
            or_tags=or_tags,
            not_tags=not_tags,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "float",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _logbook_session_id_event_count_get_serialize(
        self,
        session_id,
        investigation_id,
        instrument_name,
        types,
        filter_investigation,
        search,
        var_date,
        tags,
        or_tags,
        not_tags,
        start_time,
        end_time,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if investigation_id is not None:
            
            _query_params.append(('investigationId', investigation_id))
            
        if instrument_name is not None:
            
            _query_params.append(('instrumentName', instrument_name))
            
        if types is not None:
            
            _query_params.append(('types', types))
            
        if filter_investigation is not None:
            
            _query_params.append(('filterInvestigation', filter_investigation))
            
        if search is not None:
            
            _query_params.append(('search', search))
            
        if var_date is not None:
            
            _query_params.append(('date', var_date))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if or_tags is not None:
            
            _query_params.append(('orTags', or_tags))
            
        if not_tags is not None:
            
            _query_params.append(('notTags', not_tags))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/logbook/{sessionId}/event/count',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def logbook_session_id_event_createfrombase64_post(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        logbook_session_id_event_createfrombase64_post_request: Annotated[Optional[LogbookSessionIdEventCreatefrombase64PostRequest], Field(description="Encoded image")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Event:
        """Create an event given a base64 string

        this is used mainly when uploading a photo from the mobile device. It will create a new event (in an investigation or in a beamline logbook) that will contain the image.

        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param logbook_session_id_event_createfrombase64_post_request: Encoded image
        :type logbook_session_id_event_createfrombase64_post_request: LogbookSessionIdEventCreatefrombase64PostRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_createfrombase64_post_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            logbook_session_id_event_createfrombase64_post_request=logbook_session_id_event_createfrombase64_post_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Event",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def logbook_session_id_event_createfrombase64_post_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        logbook_session_id_event_createfrombase64_post_request: Annotated[Optional[LogbookSessionIdEventCreatefrombase64PostRequest], Field(description="Encoded image")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Event]:
        """Create an event given a base64 string

        this is used mainly when uploading a photo from the mobile device. It will create a new event (in an investigation or in a beamline logbook) that will contain the image.

        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param logbook_session_id_event_createfrombase64_post_request: Encoded image
        :type logbook_session_id_event_createfrombase64_post_request: LogbookSessionIdEventCreatefrombase64PostRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_createfrombase64_post_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            logbook_session_id_event_createfrombase64_post_request=logbook_session_id_event_createfrombase64_post_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Event",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def logbook_session_id_event_createfrombase64_post_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        logbook_session_id_event_createfrombase64_post_request: Annotated[Optional[LogbookSessionIdEventCreatefrombase64PostRequest], Field(description="Encoded image")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create an event given a base64 string

        this is used mainly when uploading a photo from the mobile device. It will create a new event (in an investigation or in a beamline logbook) that will contain the image.

        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param logbook_session_id_event_createfrombase64_post_request: Encoded image
        :type logbook_session_id_event_createfrombase64_post_request: LogbookSessionIdEventCreatefrombase64PostRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_createfrombase64_post_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            logbook_session_id_event_createfrombase64_post_request=logbook_session_id_event_createfrombase64_post_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Event",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _logbook_session_id_event_createfrombase64_post_serialize(
        self,
        session_id,
        investigation_id,
        instrument_name,
        logbook_session_id_event_createfrombase64_post_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if investigation_id is not None:
            
            _query_params.append(('investigationId', investigation_id))
            
        if instrument_name is not None:
            
            _query_params.append(('instrumentName', instrument_name))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if logbook_session_id_event_createfrombase64_post_request is not None:
            _body_params = logbook_session_id_event_createfrombase64_post_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/logbook/{sessionId}/event/createfrombase64',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def logbook_session_id_event_dates_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        types: Annotated[Optional[StrictStr], Field(description="comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO")] = None,
        filter_investigation: Annotated[Optional[StrictBool], Field(description="If true the logs with investigationId will not be retrieved")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (all match). Example system,calibration")] = None,
        or_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (any match). Example system,calibration")] = None,
        not_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (must not match). Example system,calibration")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[str]:
        """Lists events dates


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param types: comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO
        :type types: str
        :param filter_investigation: If true the logs with investigationId will not be retrieved
        :type filter_investigation: bool
        :param search: text to be used for filtering the entities
        :type search: str
        :param tags: comma-separated list of tag names (all match). Example system,calibration
        :type tags: str
        :param or_tags: comma-separated list of tag names (any match). Example system,calibration
        :type or_tags: str
        :param not_tags: comma-separated list of tag names (must not match). Example system,calibration
        :type not_tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_dates_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            types=types,
            filter_investigation=filter_investigation,
            search=search,
            tags=tags,
            or_tags=or_tags,
            not_tags=not_tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def logbook_session_id_event_dates_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        types: Annotated[Optional[StrictStr], Field(description="comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO")] = None,
        filter_investigation: Annotated[Optional[StrictBool], Field(description="If true the logs with investigationId will not be retrieved")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (all match). Example system,calibration")] = None,
        or_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (any match). Example system,calibration")] = None,
        not_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (must not match). Example system,calibration")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[str]]:
        """Lists events dates


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param types: comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO
        :type types: str
        :param filter_investigation: If true the logs with investigationId will not be retrieved
        :type filter_investigation: bool
        :param search: text to be used for filtering the entities
        :type search: str
        :param tags: comma-separated list of tag names (all match). Example system,calibration
        :type tags: str
        :param or_tags: comma-separated list of tag names (any match). Example system,calibration
        :type or_tags: str
        :param not_tags: comma-separated list of tag names (must not match). Example system,calibration
        :type not_tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_dates_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            types=types,
            filter_investigation=filter_investigation,
            search=search,
            tags=tags,
            or_tags=or_tags,
            not_tags=not_tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def logbook_session_id_event_dates_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        types: Annotated[Optional[StrictStr], Field(description="comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO")] = None,
        filter_investigation: Annotated[Optional[StrictBool], Field(description="If true the logs with investigationId will not be retrieved")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (all match). Example system,calibration")] = None,
        or_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (any match). Example system,calibration")] = None,
        not_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (must not match). Example system,calibration")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Lists events dates


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param types: comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO
        :type types: str
        :param filter_investigation: If true the logs with investigationId will not be retrieved
        :type filter_investigation: bool
        :param search: text to be used for filtering the entities
        :type search: str
        :param tags: comma-separated list of tag names (all match). Example system,calibration
        :type tags: str
        :param or_tags: comma-separated list of tag names (any match). Example system,calibration
        :type or_tags: str
        :param not_tags: comma-separated list of tag names (must not match). Example system,calibration
        :type not_tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_dates_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            types=types,
            filter_investigation=filter_investigation,
            search=search,
            tags=tags,
            or_tags=or_tags,
            not_tags=not_tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _logbook_session_id_event_dates_get_serialize(
        self,
        session_id,
        investigation_id,
        instrument_name,
        types,
        filter_investigation,
        search,
        tags,
        or_tags,
        not_tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if investigation_id is not None:
            
            _query_params.append(('investigationId', investigation_id))
            
        if instrument_name is not None:
            
            _query_params.append(('instrumentName', instrument_name))
            
        if types is not None:
            
            _query_params.append(('types', types))
            
        if filter_investigation is not None:
            
            _query_params.append(('filterInvestigation', filter_investigation))
            
        if search is not None:
            
            _query_params.append(('search', search))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if or_tags is not None:
            
            _query_params.append(('orTags', or_tags))
            
        if not_tags is not None:
            
            _query_params.append(('notTags', not_tags))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/logbook/{sessionId}/event/dates',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def logbook_session_id_event_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="order applied to the sorting (-1 or 1) (ascending or descending)")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        types: Annotated[Optional[StrictStr], Field(description="comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO")] = None,
        filter_investigation: Annotated[Optional[StrictBool], Field(description="If true the logs with investigationId will not be retrieved")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        format: Annotated[Optional[StrictStr], Field(description="format of the returned events, json by default")] = None,
        var_date: Annotated[Optional[StrictStr], Field(description="filter events on a specific date - format YYYY-MM-DD")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (all match). Example system,calibration")] = None,
        or_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (any match). Example system,calibration")] = None,
        not_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (must not match). Example system,calibration")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="items after start time - format YYYY-MM-DDTHH:mm:ss")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="items before end time - format YYYY-MM-DDTHH:mm:ss")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Event]:
        """Lists events


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param sort_order: order applied to the sorting (-1 or 1) (ascending or descending)
        :type sort_order: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param types: comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO
        :type types: str
        :param filter_investigation: If true the logs with investigationId will not be retrieved
        :type filter_investigation: bool
        :param search: text to be used for filtering the entities
        :type search: str
        :param format: format of the returned events, json by default
        :type format: str
        :param var_date: filter events on a specific date - format YYYY-MM-DD
        :type var_date: str
        :param tags: comma-separated list of tag names (all match). Example system,calibration
        :type tags: str
        :param or_tags: comma-separated list of tag names (any match). Example system,calibration
        :type or_tags: str
        :param not_tags: comma-separated list of tag names (must not match). Example system,calibration
        :type not_tags: str
        :param start_time: items after start time - format YYYY-MM-DDTHH:mm:ss
        :type start_time: str
        :param end_time: items before end time - format YYYY-MM-DDTHH:mm:ss
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            sort_by=sort_by,
            sort_order=sort_order,
            skip=skip,
            limit=limit,
            types=types,
            filter_investigation=filter_investigation,
            search=search,
            format=format,
            var_date=var_date,
            tags=tags,
            or_tags=or_tags,
            not_tags=not_tags,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Event]",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def logbook_session_id_event_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="order applied to the sorting (-1 or 1) (ascending or descending)")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        types: Annotated[Optional[StrictStr], Field(description="comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO")] = None,
        filter_investigation: Annotated[Optional[StrictBool], Field(description="If true the logs with investigationId will not be retrieved")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        format: Annotated[Optional[StrictStr], Field(description="format of the returned events, json by default")] = None,
        var_date: Annotated[Optional[StrictStr], Field(description="filter events on a specific date - format YYYY-MM-DD")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (all match). Example system,calibration")] = None,
        or_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (any match). Example system,calibration")] = None,
        not_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (must not match). Example system,calibration")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="items after start time - format YYYY-MM-DDTHH:mm:ss")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="items before end time - format YYYY-MM-DDTHH:mm:ss")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Event]]:
        """Lists events


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param sort_order: order applied to the sorting (-1 or 1) (ascending or descending)
        :type sort_order: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param types: comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO
        :type types: str
        :param filter_investigation: If true the logs with investigationId will not be retrieved
        :type filter_investigation: bool
        :param search: text to be used for filtering the entities
        :type search: str
        :param format: format of the returned events, json by default
        :type format: str
        :param var_date: filter events on a specific date - format YYYY-MM-DD
        :type var_date: str
        :param tags: comma-separated list of tag names (all match). Example system,calibration
        :type tags: str
        :param or_tags: comma-separated list of tag names (any match). Example system,calibration
        :type or_tags: str
        :param not_tags: comma-separated list of tag names (must not match). Example system,calibration
        :type not_tags: str
        :param start_time: items after start time - format YYYY-MM-DDTHH:mm:ss
        :type start_time: str
        :param end_time: items before end time - format YYYY-MM-DDTHH:mm:ss
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            sort_by=sort_by,
            sort_order=sort_order,
            skip=skip,
            limit=limit,
            types=types,
            filter_investigation=filter_investigation,
            search=search,
            format=format,
            var_date=var_date,
            tags=tags,
            or_tags=or_tags,
            not_tags=not_tags,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Event]",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def logbook_session_id_event_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="order applied to the sorting (-1 or 1) (ascending or descending)")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        types: Annotated[Optional[StrictStr], Field(description="comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO")] = None,
        filter_investigation: Annotated[Optional[StrictBool], Field(description="If true the logs with investigationId will not be retrieved")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        format: Annotated[Optional[StrictStr], Field(description="format of the returned events, json by default")] = None,
        var_date: Annotated[Optional[StrictStr], Field(description="filter events on a specific date - format YYYY-MM-DD")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (all match). Example system,calibration")] = None,
        or_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (any match). Example system,calibration")] = None,
        not_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (must not match). Example system,calibration")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="items after start time - format YYYY-MM-DDTHH:mm:ss")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="items before end time - format YYYY-MM-DDTHH:mm:ss")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Lists events


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param sort_order: order applied to the sorting (-1 or 1) (ascending or descending)
        :type sort_order: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param types: comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO
        :type types: str
        :param filter_investigation: If true the logs with investigationId will not be retrieved
        :type filter_investigation: bool
        :param search: text to be used for filtering the entities
        :type search: str
        :param format: format of the returned events, json by default
        :type format: str
        :param var_date: filter events on a specific date - format YYYY-MM-DD
        :type var_date: str
        :param tags: comma-separated list of tag names (all match). Example system,calibration
        :type tags: str
        :param or_tags: comma-separated list of tag names (any match). Example system,calibration
        :type or_tags: str
        :param not_tags: comma-separated list of tag names (must not match). Example system,calibration
        :type not_tags: str
        :param start_time: items after start time - format YYYY-MM-DDTHH:mm:ss
        :type start_time: str
        :param end_time: items before end time - format YYYY-MM-DDTHH:mm:ss
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            sort_by=sort_by,
            sort_order=sort_order,
            skip=skip,
            limit=limit,
            types=types,
            filter_investigation=filter_investigation,
            search=search,
            format=format,
            var_date=var_date,
            tags=tags,
            or_tags=or_tags,
            not_tags=not_tags,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Event]",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _logbook_session_id_event_get_serialize(
        self,
        session_id,
        investigation_id,
        instrument_name,
        sort_by,
        sort_order,
        skip,
        limit,
        types,
        filter_investigation,
        search,
        format,
        var_date,
        tags,
        or_tags,
        not_tags,
        start_time,
        end_time,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if investigation_id is not None:
            
            _query_params.append(('investigationId', investigation_id))
            
        if instrument_name is not None:
            
            _query_params.append(('instrumentName', instrument_name))
            
        if sort_by is not None:
            
            _query_params.append(('sortBy', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sortOrder', sort_order))
            
        if skip is not None:
            
            _query_params.append(('skip', skip))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if types is not None:
            
            _query_params.append(('types', types))
            
        if filter_investigation is not None:
            
            _query_params.append(('filterInvestigation', filter_investigation))
            
        if search is not None:
            
            _query_params.append(('search', search))
            
        if format is not None:
            
            _query_params.append(('format', format))
            
        if var_date is not None:
            
            _query_params.append(('date', var_date))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if or_tags is not None:
            
            _query_params.append(('orTags', or_tags))
            
        if not_tags is not None:
            
            _query_params.append(('notTags', not_tags))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/logbook/{sessionId}/event',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def logbook_session_id_event_page_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        id: Annotated[Optional[StrictStr], Field(description="event identifier")] = None,
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="order applied to the sorting (-1 or 1) (ascending or descending)")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        types: Annotated[Optional[StrictStr], Field(description="comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO")] = None,
        filter_investigation: Annotated[Optional[StrictBool], Field(description="If true the logs with investigationId will not be retrieved")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        var_date: Annotated[Optional[StrictStr], Field(description="filter events on a specific date - format YYYY-MM-DD")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (all match). Example system,calibration")] = None,
        or_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (any match). Example system,calibration")] = None,
        not_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (must not match). Example system,calibration")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="items after start time - format YYYY-MM-DDTHH:mm:ss")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="items before end time - format YYYY-MM-DDTHH:mm:ss")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Meta:
        """Gets the number of page where the event is


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param id: event identifier
        :type id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param sort_order: order applied to the sorting (-1 or 1) (ascending or descending)
        :type sort_order: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param types: comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO
        :type types: str
        :param filter_investigation: If true the logs with investigationId will not be retrieved
        :type filter_investigation: bool
        :param search: text to be used for filtering the entities
        :type search: str
        :param var_date: filter events on a specific date - format YYYY-MM-DD
        :type var_date: str
        :param tags: comma-separated list of tag names (all match). Example system,calibration
        :type tags: str
        :param or_tags: comma-separated list of tag names (any match). Example system,calibration
        :type or_tags: str
        :param not_tags: comma-separated list of tag names (must not match). Example system,calibration
        :type not_tags: str
        :param start_time: items after start time - format YYYY-MM-DDTHH:mm:ss
        :type start_time: str
        :param end_time: items before end time - format YYYY-MM-DDTHH:mm:ss
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_page_get_serialize(
            session_id=session_id,
            id=id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            sort_order=sort_order,
            skip=skip,
            limit=limit,
            types=types,
            filter_investigation=filter_investigation,
            search=search,
            var_date=var_date,
            tags=tags,
            or_tags=or_tags,
            not_tags=not_tags,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Meta",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def logbook_session_id_event_page_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        id: Annotated[Optional[StrictStr], Field(description="event identifier")] = None,
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="order applied to the sorting (-1 or 1) (ascending or descending)")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        types: Annotated[Optional[StrictStr], Field(description="comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO")] = None,
        filter_investigation: Annotated[Optional[StrictBool], Field(description="If true the logs with investigationId will not be retrieved")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        var_date: Annotated[Optional[StrictStr], Field(description="filter events on a specific date - format YYYY-MM-DD")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (all match). Example system,calibration")] = None,
        or_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (any match). Example system,calibration")] = None,
        not_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (must not match). Example system,calibration")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="items after start time - format YYYY-MM-DDTHH:mm:ss")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="items before end time - format YYYY-MM-DDTHH:mm:ss")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Meta]:
        """Gets the number of page where the event is


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param id: event identifier
        :type id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param sort_order: order applied to the sorting (-1 or 1) (ascending or descending)
        :type sort_order: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param types: comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO
        :type types: str
        :param filter_investigation: If true the logs with investigationId will not be retrieved
        :type filter_investigation: bool
        :param search: text to be used for filtering the entities
        :type search: str
        :param var_date: filter events on a specific date - format YYYY-MM-DD
        :type var_date: str
        :param tags: comma-separated list of tag names (all match). Example system,calibration
        :type tags: str
        :param or_tags: comma-separated list of tag names (any match). Example system,calibration
        :type or_tags: str
        :param not_tags: comma-separated list of tag names (must not match). Example system,calibration
        :type not_tags: str
        :param start_time: items after start time - format YYYY-MM-DDTHH:mm:ss
        :type start_time: str
        :param end_time: items before end time - format YYYY-MM-DDTHH:mm:ss
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_page_get_serialize(
            session_id=session_id,
            id=id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            sort_order=sort_order,
            skip=skip,
            limit=limit,
            types=types,
            filter_investigation=filter_investigation,
            search=search,
            var_date=var_date,
            tags=tags,
            or_tags=or_tags,
            not_tags=not_tags,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Meta",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def logbook_session_id_event_page_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        id: Annotated[Optional[StrictStr], Field(description="event identifier")] = None,
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="order applied to the sorting (-1 or 1) (ascending or descending)")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        types: Annotated[Optional[StrictStr], Field(description="comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO")] = None,
        filter_investigation: Annotated[Optional[StrictBool], Field(description="If true the logs with investigationId will not be retrieved")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        var_date: Annotated[Optional[StrictStr], Field(description="filter events on a specific date - format YYYY-MM-DD")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (all match). Example system,calibration")] = None,
        or_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (any match). Example system,calibration")] = None,
        not_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (must not match). Example system,calibration")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="items after start time - format YYYY-MM-DDTHH:mm:ss")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="items before end time - format YYYY-MM-DDTHH:mm:ss")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets the number of page where the event is


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param id: event identifier
        :type id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param sort_order: order applied to the sorting (-1 or 1) (ascending or descending)
        :type sort_order: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param types: comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO
        :type types: str
        :param filter_investigation: If true the logs with investigationId will not be retrieved
        :type filter_investigation: bool
        :param search: text to be used for filtering the entities
        :type search: str
        :param var_date: filter events on a specific date - format YYYY-MM-DD
        :type var_date: str
        :param tags: comma-separated list of tag names (all match). Example system,calibration
        :type tags: str
        :param or_tags: comma-separated list of tag names (any match). Example system,calibration
        :type or_tags: str
        :param not_tags: comma-separated list of tag names (must not match). Example system,calibration
        :type not_tags: str
        :param start_time: items after start time - format YYYY-MM-DDTHH:mm:ss
        :type start_time: str
        :param end_time: items before end time - format YYYY-MM-DDTHH:mm:ss
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_page_get_serialize(
            session_id=session_id,
            id=id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            sort_order=sort_order,
            skip=skip,
            limit=limit,
            types=types,
            filter_investigation=filter_investigation,
            search=search,
            var_date=var_date,
            tags=tags,
            or_tags=or_tags,
            not_tags=not_tags,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Meta",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _logbook_session_id_event_page_get_serialize(
        self,
        session_id,
        id,
        investigation_id,
        instrument_name,
        sort_order,
        skip,
        limit,
        types,
        filter_investigation,
        search,
        var_date,
        tags,
        or_tags,
        not_tags,
        start_time,
        end_time,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if id is not None:
            
            _query_params.append(('_id', id))
            
        if investigation_id is not None:
            
            _query_params.append(('investigationId', investigation_id))
            
        if instrument_name is not None:
            
            _query_params.append(('instrumentName', instrument_name))
            
        if sort_order is not None:
            
            _query_params.append(('sortOrder', sort_order))
            
        if skip is not None:
            
            _query_params.append(('skip', skip))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if types is not None:
            
            _query_params.append(('types', types))
            
        if filter_investigation is not None:
            
            _query_params.append(('filterInvestigation', filter_investigation))
            
        if search is not None:
            
            _query_params.append(('search', search))
            
        if var_date is not None:
            
            _query_params.append(('date', var_date))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if or_tags is not None:
            
            _query_params.append(('orTags', or_tags))
            
        if not_tags is not None:
            
            _query_params.append(('notTags', not_tags))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/logbook/{sessionId}/event/page',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def logbook_session_id_event_post(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        event: Annotated[Optional[Event], Field(description="New event to create")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Event:
        """Creates an event


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param event: New event to create
        :type event: Event
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_post_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            event=event,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Event",
            '400': "str",
            '401': "str",
            '403': "str",
            '422': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def logbook_session_id_event_post_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        event: Annotated[Optional[Event], Field(description="New event to create")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Event]:
        """Creates an event


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param event: New event to create
        :type event: Event
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_post_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            event=event,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Event",
            '400': "str",
            '401': "str",
            '403': "str",
            '422': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def logbook_session_id_event_post_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        event: Annotated[Optional[Event], Field(description="New event to create")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creates an event


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param event: New event to create
        :type event: Event
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_post_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            event=event,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Event",
            '400': "str",
            '401': "str",
            '403': "str",
            '422': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _logbook_session_id_event_post_serialize(
        self,
        session_id,
        investigation_id,
        event,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if investigation_id is not None:
            
            _query_params.append(('investigationId', investigation_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if event is not None:
            _body_params = event


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/logbook/{sessionId}/event',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def logbook_session_id_event_put(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        logbook_session_id_event_put_request: Annotated[Optional[LogbookSessionIdEventPutRequest], Field(description="Updated event attributes to use to update the event with the corresponding eventId")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Event:
        """Updates an event


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param logbook_session_id_event_put_request: Updated event attributes to use to update the event with the corresponding eventId
        :type logbook_session_id_event_put_request: LogbookSessionIdEventPutRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_put_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            logbook_session_id_event_put_request=logbook_session_id_event_put_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Event",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def logbook_session_id_event_put_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        logbook_session_id_event_put_request: Annotated[Optional[LogbookSessionIdEventPutRequest], Field(description="Updated event attributes to use to update the event with the corresponding eventId")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Event]:
        """Updates an event


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param logbook_session_id_event_put_request: Updated event attributes to use to update the event with the corresponding eventId
        :type logbook_session_id_event_put_request: LogbookSessionIdEventPutRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_put_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            logbook_session_id_event_put_request=logbook_session_id_event_put_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Event",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def logbook_session_id_event_put_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        logbook_session_id_event_put_request: Annotated[Optional[LogbookSessionIdEventPutRequest], Field(description="Updated event attributes to use to update the event with the corresponding eventId")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Updates an event


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param logbook_session_id_event_put_request: Updated event attributes to use to update the event with the corresponding eventId
        :type logbook_session_id_event_put_request: LogbookSessionIdEventPutRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_put_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            logbook_session_id_event_put_request=logbook_session_id_event_put_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Event",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _logbook_session_id_event_put_serialize(
        self,
        session_id,
        investigation_id,
        logbook_session_id_event_put_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if investigation_id is not None:
            
            _query_params.append(('investigationId', investigation_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if logbook_session_id_event_put_request is not None:
            _body_params = logbook_session_id_event_put_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/logbook/{sessionId}/event',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def logbook_session_id_event_remove_put(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        types: Annotated[Optional[StrictStr], Field(description="comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO")] = None,
        filter_investigation: Annotated[Optional[StrictBool], Field(description="If true the logs with investigationId will not be retrieved")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        var_date: Annotated[Optional[StrictStr], Field(description="filter events on a specific date - format YYYY-MM-DD")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (all match). Example system,calibration")] = None,
        or_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (any match). Example system,calibration")] = None,
        not_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (must not match). Example system,calibration")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="items after start time - format YYYY-MM-DDTHH:mm:ss")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="items before end time - format YYYY-MM-DDTHH:mm:ss")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Event]:
        """Flag events as removed


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param types: comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO
        :type types: str
        :param filter_investigation: If true the logs with investigationId will not be retrieved
        :type filter_investigation: bool
        :param search: text to be used for filtering the entities
        :type search: str
        :param var_date: filter events on a specific date - format YYYY-MM-DD
        :type var_date: str
        :param tags: comma-separated list of tag names (all match). Example system,calibration
        :type tags: str
        :param or_tags: comma-separated list of tag names (any match). Example system,calibration
        :type or_tags: str
        :param not_tags: comma-separated list of tag names (must not match). Example system,calibration
        :type not_tags: str
        :param start_time: items after start time - format YYYY-MM-DDTHH:mm:ss
        :type start_time: str
        :param end_time: items before end time - format YYYY-MM-DDTHH:mm:ss
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_remove_put_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            sort_by=sort_by,
            skip=skip,
            limit=limit,
            types=types,
            filter_investigation=filter_investigation,
            search=search,
            var_date=var_date,
            tags=tags,
            or_tags=or_tags,
            not_tags=not_tags,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Event]",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def logbook_session_id_event_remove_put_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        types: Annotated[Optional[StrictStr], Field(description="comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO")] = None,
        filter_investigation: Annotated[Optional[StrictBool], Field(description="If true the logs with investigationId will not be retrieved")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        var_date: Annotated[Optional[StrictStr], Field(description="filter events on a specific date - format YYYY-MM-DD")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (all match). Example system,calibration")] = None,
        or_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (any match). Example system,calibration")] = None,
        not_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (must not match). Example system,calibration")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="items after start time - format YYYY-MM-DDTHH:mm:ss")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="items before end time - format YYYY-MM-DDTHH:mm:ss")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Event]]:
        """Flag events as removed


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param types: comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO
        :type types: str
        :param filter_investigation: If true the logs with investigationId will not be retrieved
        :type filter_investigation: bool
        :param search: text to be used for filtering the entities
        :type search: str
        :param var_date: filter events on a specific date - format YYYY-MM-DD
        :type var_date: str
        :param tags: comma-separated list of tag names (all match). Example system,calibration
        :type tags: str
        :param or_tags: comma-separated list of tag names (any match). Example system,calibration
        :type or_tags: str
        :param not_tags: comma-separated list of tag names (must not match). Example system,calibration
        :type not_tags: str
        :param start_time: items after start time - format YYYY-MM-DDTHH:mm:ss
        :type start_time: str
        :param end_time: items before end time - format YYYY-MM-DDTHH:mm:ss
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_remove_put_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            sort_by=sort_by,
            skip=skip,
            limit=limit,
            types=types,
            filter_investigation=filter_investigation,
            search=search,
            var_date=var_date,
            tags=tags,
            or_tags=or_tags,
            not_tags=not_tags,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Event]",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def logbook_session_id_event_remove_put_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        types: Annotated[Optional[StrictStr], Field(description="comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO")] = None,
        filter_investigation: Annotated[Optional[StrictBool], Field(description="If true the logs with investigationId will not be retrieved")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        var_date: Annotated[Optional[StrictStr], Field(description="filter events on a specific date - format YYYY-MM-DD")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (all match). Example system,calibration")] = None,
        or_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (any match). Example system,calibration")] = None,
        not_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (must not match). Example system,calibration")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="items after start time - format YYYY-MM-DDTHH:mm:ss")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="items before end time - format YYYY-MM-DDTHH:mm:ss")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Flag events as removed


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param types: comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO
        :type types: str
        :param filter_investigation: If true the logs with investigationId will not be retrieved
        :type filter_investigation: bool
        :param search: text to be used for filtering the entities
        :type search: str
        :param var_date: filter events on a specific date - format YYYY-MM-DD
        :type var_date: str
        :param tags: comma-separated list of tag names (all match). Example system,calibration
        :type tags: str
        :param or_tags: comma-separated list of tag names (any match). Example system,calibration
        :type or_tags: str
        :param not_tags: comma-separated list of tag names (must not match). Example system,calibration
        :type not_tags: str
        :param start_time: items after start time - format YYYY-MM-DDTHH:mm:ss
        :type start_time: str
        :param end_time: items before end time - format YYYY-MM-DDTHH:mm:ss
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_remove_put_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            sort_by=sort_by,
            skip=skip,
            limit=limit,
            types=types,
            filter_investigation=filter_investigation,
            search=search,
            var_date=var_date,
            tags=tags,
            or_tags=or_tags,
            not_tags=not_tags,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Event]",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _logbook_session_id_event_remove_put_serialize(
        self,
        session_id,
        investigation_id,
        instrument_name,
        sort_by,
        skip,
        limit,
        types,
        filter_investigation,
        search,
        var_date,
        tags,
        or_tags,
        not_tags,
        start_time,
        end_time,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if investigation_id is not None:
            
            _query_params.append(('investigationId', investigation_id))
            
        if instrument_name is not None:
            
            _query_params.append(('instrumentName', instrument_name))
            
        if sort_by is not None:
            
            _query_params.append(('sortBy', sort_by))
            
        if skip is not None:
            
            _query_params.append(('skip', skip))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if types is not None:
            
            _query_params.append(('types', types))
            
        if filter_investigation is not None:
            
            _query_params.append(('filterInvestigation', filter_investigation))
            
        if search is not None:
            
            _query_params.append(('search', search))
            
        if var_date is not None:
            
            _query_params.append(('date', var_date))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if or_tags is not None:
            
            _query_params.append(('orTags', or_tags))
            
        if not_tags is not None:
            
            _query_params.append(('notTags', not_tags))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/logbook/{sessionId}/event/remove',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def logbook_session_id_event_restore_put(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        types: Annotated[Optional[StrictStr], Field(description="comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO")] = None,
        filter_investigation: Annotated[Optional[StrictBool], Field(description="If true the logs with investigationId will not be retrieved")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        var_date: Annotated[Optional[StrictStr], Field(description="filter events on a specific date - format YYYY-MM-DD")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (all match). Example system,calibration")] = None,
        or_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (any match). Example system,calibration")] = None,
        not_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (must not match). Example system,calibration")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="items after start time - format YYYY-MM-DDTHH:mm:ss")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="items before end time - format YYYY-MM-DDTHH:mm:ss")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Event]:
        """Flag events as restored by setting removed = false for each event. InvestigationId is mandatory


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param types: comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO
        :type types: str
        :param filter_investigation: If true the logs with investigationId will not be retrieved
        :type filter_investigation: bool
        :param search: text to be used for filtering the entities
        :type search: str
        :param var_date: filter events on a specific date - format YYYY-MM-DD
        :type var_date: str
        :param tags: comma-separated list of tag names (all match). Example system,calibration
        :type tags: str
        :param or_tags: comma-separated list of tag names (any match). Example system,calibration
        :type or_tags: str
        :param not_tags: comma-separated list of tag names (must not match). Example system,calibration
        :type not_tags: str
        :param start_time: items after start time - format YYYY-MM-DDTHH:mm:ss
        :type start_time: str
        :param end_time: items before end time - format YYYY-MM-DDTHH:mm:ss
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_restore_put_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            sort_by=sort_by,
            skip=skip,
            limit=limit,
            types=types,
            filter_investigation=filter_investigation,
            search=search,
            var_date=var_date,
            tags=tags,
            or_tags=or_tags,
            not_tags=not_tags,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Event]",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def logbook_session_id_event_restore_put_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        types: Annotated[Optional[StrictStr], Field(description="comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO")] = None,
        filter_investigation: Annotated[Optional[StrictBool], Field(description="If true the logs with investigationId will not be retrieved")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        var_date: Annotated[Optional[StrictStr], Field(description="filter events on a specific date - format YYYY-MM-DD")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (all match). Example system,calibration")] = None,
        or_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (any match). Example system,calibration")] = None,
        not_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (must not match). Example system,calibration")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="items after start time - format YYYY-MM-DDTHH:mm:ss")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="items before end time - format YYYY-MM-DDTHH:mm:ss")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Event]]:
        """Flag events as restored by setting removed = false for each event. InvestigationId is mandatory


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param types: comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO
        :type types: str
        :param filter_investigation: If true the logs with investigationId will not be retrieved
        :type filter_investigation: bool
        :param search: text to be used for filtering the entities
        :type search: str
        :param var_date: filter events on a specific date - format YYYY-MM-DD
        :type var_date: str
        :param tags: comma-separated list of tag names (all match). Example system,calibration
        :type tags: str
        :param or_tags: comma-separated list of tag names (any match). Example system,calibration
        :type or_tags: str
        :param not_tags: comma-separated list of tag names (must not match). Example system,calibration
        :type not_tags: str
        :param start_time: items after start time - format YYYY-MM-DDTHH:mm:ss
        :type start_time: str
        :param end_time: items before end time - format YYYY-MM-DDTHH:mm:ss
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_restore_put_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            sort_by=sort_by,
            skip=skip,
            limit=limit,
            types=types,
            filter_investigation=filter_investigation,
            search=search,
            var_date=var_date,
            tags=tags,
            or_tags=or_tags,
            not_tags=not_tags,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Event]",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def logbook_session_id_event_restore_put_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        types: Annotated[Optional[StrictStr], Field(description="comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO")] = None,
        filter_investigation: Annotated[Optional[StrictBool], Field(description="If true the logs with investigationId will not be retrieved")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        var_date: Annotated[Optional[StrictStr], Field(description="filter events on a specific date - format YYYY-MM-DD")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (all match). Example system,calibration")] = None,
        or_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (any match). Example system,calibration")] = None,
        not_tags: Annotated[Optional[StrictStr], Field(description="comma-separated list of tag names (must not match). Example system,calibration")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="items after start time - format YYYY-MM-DDTHH:mm:ss")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="items before end time - format YYYY-MM-DDTHH:mm:ss")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Flag events as restored by setting removed = false for each event. InvestigationId is mandatory


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param types: comma separated list of type-category events. Example NOTIFICATION-ERROR, NOTIFICATION-INFO
        :type types: str
        :param filter_investigation: If true the logs with investigationId will not be retrieved
        :type filter_investigation: bool
        :param search: text to be used for filtering the entities
        :type search: str
        :param var_date: filter events on a specific date - format YYYY-MM-DD
        :type var_date: str
        :param tags: comma-separated list of tag names (all match). Example system,calibration
        :type tags: str
        :param or_tags: comma-separated list of tag names (any match). Example system,calibration
        :type or_tags: str
        :param not_tags: comma-separated list of tag names (must not match). Example system,calibration
        :type not_tags: str
        :param start_time: items after start time - format YYYY-MM-DDTHH:mm:ss
        :type start_time: str
        :param end_time: items before end time - format YYYY-MM-DDTHH:mm:ss
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_event_restore_put_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            sort_by=sort_by,
            skip=skip,
            limit=limit,
            types=types,
            filter_investigation=filter_investigation,
            search=search,
            var_date=var_date,
            tags=tags,
            or_tags=or_tags,
            not_tags=not_tags,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Event]",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _logbook_session_id_event_restore_put_serialize(
        self,
        session_id,
        investigation_id,
        instrument_name,
        sort_by,
        skip,
        limit,
        types,
        filter_investigation,
        search,
        var_date,
        tags,
        or_tags,
        not_tags,
        start_time,
        end_time,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if investigation_id is not None:
            
            _query_params.append(('investigationId', investigation_id))
            
        if instrument_name is not None:
            
            _query_params.append(('instrumentName', instrument_name))
            
        if sort_by is not None:
            
            _query_params.append(('sortBy', sort_by))
            
        if skip is not None:
            
            _query_params.append(('skip', skip))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if types is not None:
            
            _query_params.append(('types', types))
            
        if filter_investigation is not None:
            
            _query_params.append(('filterInvestigation', filter_investigation))
            
        if search is not None:
            
            _query_params.append(('search', search))
            
        if var_date is not None:
            
            _query_params.append(('date', var_date))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if or_tags is not None:
            
            _query_params.append(('orTags', or_tags))
            
        if not_tags is not None:
            
            _query_params.append(('notTags', not_tags))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/logbook/{sessionId}/event/restore',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def logbook_session_id_events_patch(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="the name of the instrument or instrument (comma separated)")] = None,
        logbook_session_id_events_patch_request: Annotated[Optional[LogbookSessionIdEventsPatchRequest], Field(description="Object to update tags of multiple events")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Event]:
        """Updates the tags of a list of events


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier
        :type investigation_id: str
        :param instrument_name: the name of the instrument or instrument (comma separated)
        :type instrument_name: str
        :param logbook_session_id_events_patch_request: Object to update tags of multiple events
        :type logbook_session_id_events_patch_request: LogbookSessionIdEventsPatchRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_events_patch_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            logbook_session_id_events_patch_request=logbook_session_id_events_patch_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Event]",
            '400': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def logbook_session_id_events_patch_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="the name of the instrument or instrument (comma separated)")] = None,
        logbook_session_id_events_patch_request: Annotated[Optional[LogbookSessionIdEventsPatchRequest], Field(description="Object to update tags of multiple events")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Event]]:
        """Updates the tags of a list of events


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier
        :type investigation_id: str
        :param instrument_name: the name of the instrument or instrument (comma separated)
        :type instrument_name: str
        :param logbook_session_id_events_patch_request: Object to update tags of multiple events
        :type logbook_session_id_events_patch_request: LogbookSessionIdEventsPatchRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_events_patch_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            logbook_session_id_events_patch_request=logbook_session_id_events_patch_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Event]",
            '400': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def logbook_session_id_events_patch_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="the name of the instrument or instrument (comma separated)")] = None,
        logbook_session_id_events_patch_request: Annotated[Optional[LogbookSessionIdEventsPatchRequest], Field(description="Object to update tags of multiple events")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Updates the tags of a list of events


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier
        :type investigation_id: str
        :param instrument_name: the name of the instrument or instrument (comma separated)
        :type instrument_name: str
        :param logbook_session_id_events_patch_request: Object to update tags of multiple events
        :type logbook_session_id_events_patch_request: LogbookSessionIdEventsPatchRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_events_patch_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            logbook_session_id_events_patch_request=logbook_session_id_events_patch_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Event]",
            '400': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _logbook_session_id_events_patch_serialize(
        self,
        session_id,
        investigation_id,
        instrument_name,
        logbook_session_id_events_patch_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if investigation_id is not None:
            
            _query_params.append(('investigationId', investigation_id))
            
        if instrument_name is not None:
            
            _query_params.append(('instrumentName', instrument_name))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if logbook_session_id_events_patch_request is not None:
            _body_params = logbook_session_id_events_patch_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/logbook/{sessionId}/events',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def logbook_session_id_stats_count_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        start_date: Annotated[Optional[StrictStr], Field(description="start date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="end date")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[LogbookInvestigationStatCount]:
        """Counts number of event for date range


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param start_date: start date
        :type start_date: str
        :param end_date: end date
        :type end_date: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_stats_count_get_serialize(
            session_id=session_id,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LogbookInvestigationStatCount]",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def logbook_session_id_stats_count_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        start_date: Annotated[Optional[StrictStr], Field(description="start date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="end date")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[LogbookInvestigationStatCount]]:
        """Counts number of event for date range


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param start_date: start date
        :type start_date: str
        :param end_date: end date
        :type end_date: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_stats_count_get_serialize(
            session_id=session_id,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LogbookInvestigationStatCount]",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def logbook_session_id_stats_count_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        start_date: Annotated[Optional[StrictStr], Field(description="start date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="end date")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Counts number of event for date range


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param start_date: start date
        :type start_date: str
        :param end_date: end date
        :type end_date: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_stats_count_get_serialize(
            session_id=session_id,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LogbookInvestigationStatCount]",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _logbook_session_id_stats_count_get_serialize(
        self,
        session_id,
        start_date,
        end_date,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('endDate', end_date))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/logbook/{sessionId}/stats/count',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def logbook_session_id_stats_investigation_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        start_date: Annotated[Optional[StrictStr], Field(description="start date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="end date")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[LogbookInvestigationStat]:
        """Lists statistics on events for each investigation that are allocated in the date range


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param start_date: start date
        :type start_date: str
        :param end_date: end date
        :type end_date: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_stats_investigation_get_serialize(
            session_id=session_id,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LogbookInvestigationStat]",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def logbook_session_id_stats_investigation_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        start_date: Annotated[Optional[StrictStr], Field(description="start date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="end date")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[LogbookInvestigationStat]]:
        """Lists statistics on events for each investigation that are allocated in the date range


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param start_date: start date
        :type start_date: str
        :param end_date: end date
        :type end_date: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_stats_investigation_get_serialize(
            session_id=session_id,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LogbookInvestigationStat]",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def logbook_session_id_stats_investigation_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        start_date: Annotated[Optional[StrictStr], Field(description="start date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="end date")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Lists statistics on events for each investigation that are allocated in the date range


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param start_date: start date
        :type start_date: str
        :param end_date: end date
        :type end_date: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_stats_investigation_get_serialize(
            session_id=session_id,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LogbookInvestigationStat]",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _logbook_session_id_stats_investigation_get_serialize(
        self,
        session_id,
        start_date,
        end_date,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('endDate', end_date))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/logbook/{sessionId}/stats/investigation',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def logbook_session_id_tag_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Tag]:
        """GET all tags available, (ie used in the investigation or not) for a given logbook including global, beamline specific and investigation specific tags. Tags available but not used are also retrieved.


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_tag_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Tag]",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def logbook_session_id_tag_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Tag]]:
        """GET all tags available, (ie used in the investigation or not) for a given logbook including global, beamline specific and investigation specific tags. Tags available but not used are also retrieved.


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_tag_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Tag]",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def logbook_session_id_tag_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """GET all tags available, (ie used in the investigation or not) for a given logbook including global, beamline specific and investigation specific tags. Tags available but not used are also retrieved.


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_tag_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Tag]",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _logbook_session_id_tag_get_serialize(
        self,
        session_id,
        investigation_id,
        instrument_name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if investigation_id is not None:
            
            _query_params.append(('investigationId', investigation_id))
            
        if instrument_name is not None:
            
            _query_params.append(('instrumentName', instrument_name))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/logbook/{sessionId}/tag',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def logbook_session_id_tag_post(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        tag: Annotated[Optional[Tag], Field(description="tag to be created")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Tag:
        """Create an investigation tag for a given investigationId


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param tag: tag to be created
        :type tag: Tag
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_tag_post_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Tag",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def logbook_session_id_tag_post_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        tag: Annotated[Optional[Tag], Field(description="tag to be created")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Tag]:
        """Create an investigation tag for a given investigationId


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param tag: tag to be created
        :type tag: Tag
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_tag_post_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Tag",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def logbook_session_id_tag_post_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="identifier of the investigation")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the instrument")] = None,
        tag: Annotated[Optional[Tag], Field(description="tag to be created")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create an investigation tag for a given investigationId


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: identifier of the investigation
        :type investigation_id: str
        :param instrument_name: name of the instrument
        :type instrument_name: str
        :param tag: tag to be created
        :type tag: Tag
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_tag_post_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Tag",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _logbook_session_id_tag_post_serialize(
        self,
        session_id,
        investigation_id,
        instrument_name,
        tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if investigation_id is not None:
            
            _query_params.append(('investigationId', investigation_id))
            
        if instrument_name is not None:
            
            _query_params.append(('instrumentName', instrument_name))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tag is not None:
            _body_params = tag


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/logbook/{sessionId}/tag',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def logbook_session_id_tag_put(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        tag_id: Annotated[StrictStr, Field(description="logbook tag identifier")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier")] = None,
        tag: Annotated[Optional[Tag], Field(description="updated tag")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Tag:
        """Update an investigation tag


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param tag_id: logbook tag identifier (required)
        :type tag_id: str
        :param investigation_id: Metadata catalogue investigation identifier
        :type investigation_id: str
        :param tag: updated tag
        :type tag: Tag
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_tag_put_serialize(
            session_id=session_id,
            tag_id=tag_id,
            investigation_id=investigation_id,
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Tag",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def logbook_session_id_tag_put_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        tag_id: Annotated[StrictStr, Field(description="logbook tag identifier")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier")] = None,
        tag: Annotated[Optional[Tag], Field(description="updated tag")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Tag]:
        """Update an investigation tag


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param tag_id: logbook tag identifier (required)
        :type tag_id: str
        :param investigation_id: Metadata catalogue investigation identifier
        :type investigation_id: str
        :param tag: updated tag
        :type tag: Tag
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_tag_put_serialize(
            session_id=session_id,
            tag_id=tag_id,
            investigation_id=investigation_id,
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Tag",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def logbook_session_id_tag_put_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        tag_id: Annotated[StrictStr, Field(description="logbook tag identifier")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier")] = None,
        tag: Annotated[Optional[Tag], Field(description="updated tag")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update an investigation tag


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param tag_id: logbook tag identifier (required)
        :type tag_id: str
        :param investigation_id: Metadata catalogue investigation identifier
        :type investigation_id: str
        :param tag: updated tag
        :type tag: Tag
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logbook_session_id_tag_put_serialize(
            session_id=session_id,
            tag_id=tag_id,
            investigation_id=investigation_id,
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Tag",
            '400': "str",
            '401': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _logbook_session_id_tag_put_serialize(
        self,
        session_id,
        tag_id,
        investigation_id,
        tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if investigation_id is not None:
            
            _query_params.append(('investigationId', investigation_id))
            
        if tag_id is not None:
            
            _query_params.append(('tagId', tag_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tag is not None:
            _body_params = tag


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/logbook/{sessionId}/tag',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


