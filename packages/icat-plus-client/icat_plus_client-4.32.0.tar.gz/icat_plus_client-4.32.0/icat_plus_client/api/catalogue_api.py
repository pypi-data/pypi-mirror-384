# coding: utf-8

"""
    ICAT+ API

    ICAT+ RESTful API with Swagger

    The version of the OpenAPI document: 1.0.0
    Contact: demariaa@esrf.fr
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from icat_plus_client.models.catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request import CatalogueSessionIdInvestigationIdInvestigationIdInvestigationusersPostRequest
from icat_plus_client.models.datacollection import Datacollection
from icat_plus_client.models.datafile import Datafile
from icat_plus_client.models.dataset import Dataset
from icat_plus_client.models.dataset_document import DatasetDocument
from icat_plus_client.models.datasetparameter import Datasetparameter
from icat_plus_client.models.instrument import Instrument
from icat_plus_client.models.investigation import Investigation
from icat_plus_client.models.investigationusers import Investigationusers
from icat_plus_client.models.meta import Meta
from icat_plus_client.models.parameter import Parameter
from icat_plus_client.models.sample import Sample
from icat_plus_client.models.sampleinformation import Sampleinformation
from icat_plus_client.models.technique import Technique
from icat_plus_client.models.timeline import Timeline
from icat_plus_client.models.user import User

from icat_plus_client.api_client import ApiClient, RequestSerialized
from icat_plus_client.api_response import ApiResponse
from icat_plus_client.rest import RESTResponseType


class CatalogueApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def catalogue_instruments_get(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Instrument]:
        """Returns all instruments

        Return a list of instruments that are registered in ICAT

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_instruments_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Instrument]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_instruments_get_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Instrument]]:
        """Returns all instruments

        Return a list of instruments that are registered in ICAT

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_instruments_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Instrument]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_instruments_get_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns all instruments

        Return a list of instruments that are registered in ICAT

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_instruments_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Instrument]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_instruments_get_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/instruments',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_investigation_name_investigation_name_normalize_get(
        self,
        investigation_name: Annotated[StrictStr, Field(description="name of the investigation to normalize")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Most of users don't write their proposal names using the same convention so it might happen that a given proposal can be written in many different ways. This method will homogenize such name.  Example IH-LS-0001, ihls0001, ih-LS-0001 are normalized like IH-LS-0001.


        :param investigation_name: name of the investigation to normalize (required)
        :type investigation_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_investigation_name_investigation_name_normalize_get_serialize(
            investigation_name=investigation_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_investigation_name_investigation_name_normalize_get_with_http_info(
        self,
        investigation_name: Annotated[StrictStr, Field(description="name of the investigation to normalize")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Most of users don't write their proposal names using the same convention so it might happen that a given proposal can be written in many different ways. This method will homogenize such name.  Example IH-LS-0001, ihls0001, ih-LS-0001 are normalized like IH-LS-0001.


        :param investigation_name: name of the investigation to normalize (required)
        :type investigation_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_investigation_name_investigation_name_normalize_get_serialize(
            investigation_name=investigation_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_investigation_name_investigation_name_normalize_get_without_preload_content(
        self,
        investigation_name: Annotated[StrictStr, Field(description="name of the investigation to normalize")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Most of users don't write their proposal names using the same convention so it might happen that a given proposal can be written in many different ways. This method will homogenize such name.  Example IH-LS-0001, ihls0001, ih-LS-0001 are normalized like IH-LS-0001.


        :param investigation_name: name of the investigation to normalize (required)
        :type investigation_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_investigation_name_investigation_name_normalize_get_serialize(
            investigation_name=investigation_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_investigation_name_investigation_name_normalize_get_serialize(
        self,
        investigation_name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if investigation_name is not None:
            _path_params['investigationName'] = investigation_name
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/investigation/name/{investigationName}/normalize',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_parameters_get(
        self,
        parameter_type_id: Optional[StrictInt] = None,
        name: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Parameter]:
        """Returns all parameters

        Return a list of parameters that are registered in ICAT

        :param parameter_type_id:
        :type parameter_type_id: int
        :param name:
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_parameters_get_serialize(
            parameter_type_id=parameter_type_id,
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Parameter]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_parameters_get_with_http_info(
        self,
        parameter_type_id: Optional[StrictInt] = None,
        name: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Parameter]]:
        """Returns all parameters

        Return a list of parameters that are registered in ICAT

        :param parameter_type_id:
        :type parameter_type_id: int
        :param name:
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_parameters_get_serialize(
            parameter_type_id=parameter_type_id,
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Parameter]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_parameters_get_without_preload_content(
        self,
        parameter_type_id: Optional[StrictInt] = None,
        name: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns all parameters

        Return a list of parameters that are registered in ICAT

        :param parameter_type_id:
        :type parameter_type_id: int
        :param name:
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_parameters_get_serialize(
            parameter_type_id=parameter_type_id,
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Parameter]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_parameters_get_serialize(
        self,
        parameter_type_id,
        name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if parameter_type_id is not None:
            
            _query_params.append(('parameterTypeId', parameter_type_id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/parameters',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_datacollection_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        dataset_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue dataset identifier")] = None,
        type: Annotated[Optional[StrictStr], Field(description="type of the data collection")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="order applied to the sorting (-1 or 1) (ascending or descending)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Datacollection:
        """Gets all datacollection or for a given datasetId


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param dataset_id: Metadata catalogue dataset identifier
        :type dataset_id: str
        :param type: type of the data collection
        :type type: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param search: text to be used for filtering the entities
        :type search: str
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param sort_order: order applied to the sorting (-1 or 1) (ascending or descending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_datacollection_get_serialize(
            session_id=session_id,
            dataset_id=dataset_id,
            type=type,
            skip=skip,
            limit=limit,
            search=search,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Datacollection",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_datacollection_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        dataset_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue dataset identifier")] = None,
        type: Annotated[Optional[StrictStr], Field(description="type of the data collection")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="order applied to the sorting (-1 or 1) (ascending or descending)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Datacollection]:
        """Gets all datacollection or for a given datasetId


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param dataset_id: Metadata catalogue dataset identifier
        :type dataset_id: str
        :param type: type of the data collection
        :type type: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param search: text to be used for filtering the entities
        :type search: str
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param sort_order: order applied to the sorting (-1 or 1) (ascending or descending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_datacollection_get_serialize(
            session_id=session_id,
            dataset_id=dataset_id,
            type=type,
            skip=skip,
            limit=limit,
            search=search,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Datacollection",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_datacollection_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        dataset_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue dataset identifier")] = None,
        type: Annotated[Optional[StrictStr], Field(description="type of the data collection")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="order applied to the sorting (-1 or 1) (ascending or descending)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets all datacollection or for a given datasetId


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param dataset_id: Metadata catalogue dataset identifier
        :type dataset_id: str
        :param type: type of the data collection
        :type type: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param search: text to be used for filtering the entities
        :type search: str
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param sort_order: order applied to the sorting (-1 or 1) (ascending or descending)
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_datacollection_get_serialize(
            session_id=session_id,
            dataset_id=dataset_id,
            type=type,
            skip=skip,
            limit=limit,
            search=search,
            sort_by=sort_by,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Datacollection",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_datacollection_get_serialize(
        self,
        session_id,
        dataset_id,
        type,
        skip,
        limit,
        search,
        sort_by,
        sort_order,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if dataset_id is not None:
            
            _query_params.append(('datasetId', dataset_id))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if skip is not None:
            
            _query_params.append(('skip', skip))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if search is not None:
            
            _query_params.append(('search', search))
            
        if sort_by is not None:
            
            _query_params.append(('sortBy', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sortOrder', sort_order))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/datacollection',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_datafile_download_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        filepath: Annotated[StrictStr, Field(description="File path")],
        dataset_id: Annotated[StrictStr, Field(description="Metadata catalogue dataset identifier")],
        investigation_id: Annotated[StrictStr, Field(description="Metadata catalogue investigation identifier")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Downloads a file given its filepath.


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param filepath: File path (required)
        :type filepath: str
        :param dataset_id: Metadata catalogue dataset identifier (required)
        :type dataset_id: str
        :param investigation_id: Metadata catalogue investigation identifier (required)
        :type investigation_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_datafile_download_get_serialize(
            session_id=session_id,
            filepath=filepath,
            dataset_id=dataset_id,
            investigation_id=investigation_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "str",
            '404': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_datafile_download_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        filepath: Annotated[StrictStr, Field(description="File path")],
        dataset_id: Annotated[StrictStr, Field(description="Metadata catalogue dataset identifier")],
        investigation_id: Annotated[StrictStr, Field(description="Metadata catalogue investigation identifier")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Downloads a file given its filepath.


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param filepath: File path (required)
        :type filepath: str
        :param dataset_id: Metadata catalogue dataset identifier (required)
        :type dataset_id: str
        :param investigation_id: Metadata catalogue investigation identifier (required)
        :type investigation_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_datafile_download_get_serialize(
            session_id=session_id,
            filepath=filepath,
            dataset_id=dataset_id,
            investigation_id=investigation_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "str",
            '404': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_datafile_download_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        filepath: Annotated[StrictStr, Field(description="File path")],
        dataset_id: Annotated[StrictStr, Field(description="Metadata catalogue dataset identifier")],
        investigation_id: Annotated[StrictStr, Field(description="Metadata catalogue investigation identifier")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Downloads a file given its filepath.


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param filepath: File path (required)
        :type filepath: str
        :param dataset_id: Metadata catalogue dataset identifier (required)
        :type dataset_id: str
        :param investigation_id: Metadata catalogue investigation identifier (required)
        :type investigation_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_datafile_download_get_serialize(
            session_id=session_id,
            filepath=filepath,
            dataset_id=dataset_id,
            investigation_id=investigation_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "str",
            '404': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_datafile_download_get_serialize(
        self,
        session_id,
        filepath,
        dataset_id,
        investigation_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if filepath is not None:
            
            _query_params.append(('filepath', filepath))
            
        if dataset_id is not None:
            
            _query_params.append(('datasetId', dataset_id))
            
        if investigation_id is not None:
            
            _query_params.append(('investigationId', investigation_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/datafile/download',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_datafile_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        dataset_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue dataset identifier")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Datafile]:
        """Get datafiles for a given dataset id.


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param dataset_id: Metadata catalogue dataset identifier
        :type dataset_id: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param search: text to be used for filtering the entities
        :type search: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_datafile_get_serialize(
            session_id=session_id,
            dataset_id=dataset_id,
            limit=limit,
            skip=skip,
            search=search,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Datafile]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_datafile_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        dataset_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue dataset identifier")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Datafile]]:
        """Get datafiles for a given dataset id.


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param dataset_id: Metadata catalogue dataset identifier
        :type dataset_id: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param search: text to be used for filtering the entities
        :type search: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_datafile_get_serialize(
            session_id=session_id,
            dataset_id=dataset_id,
            limit=limit,
            skip=skip,
            search=search,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Datafile]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_datafile_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        dataset_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue dataset identifier")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get datafiles for a given dataset id.


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param dataset_id: Metadata catalogue dataset identifier
        :type dataset_id: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param search: text to be used for filtering the entities
        :type search: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_datafile_get_serialize(
            session_id=session_id,
            dataset_id=dataset_id,
            limit=limit,
            skip=skip,
            search=search,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Datafile]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_datafile_get_serialize(
        self,
        session_id,
        dataset_id,
        limit,
        skip,
        search,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if dataset_id is not None:
            
            _query_params.append(('datasetId', dataset_id))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if skip is not None:
            
            _query_params.append(('skip', skip))
            
        if search is not None:
            
            _query_params.append(('search', search))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/datafile',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_dataset_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_ids: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier list (comma separated)")] = None,
        dataset_ids: Annotated[Optional[StrictStr], Field(description="Metadata catalogue dataset identifier list (comma separated)")] = None,
        sample_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue sample identifier")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the beamline or the instrument")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        dataset_type: Annotated[Optional[StrictStr], Field(description="type of the dataset")] = None,
        nested: Annotated[Optional[StrictBool], Field(description="true if processed datasets will be populated")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="order applied to the sorting (-1 or 1) (ascending or descending)")] = None,
        parameters: Annotated[Optional[StrictStr], Field(description="dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Dataset]:
        """Gets datasets for a given investigationId or for a given datasetIds of for a sampleId or for a beamline


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_ids: Metadata catalogue investigation identifier list (comma separated)
        :type investigation_ids: str
        :param dataset_ids: Metadata catalogue dataset identifier list (comma separated)
        :type dataset_ids: str
        :param sample_id: Metadata catalogue sample identifier
        :type sample_id: str
        :param instrument_name: name of the beamline or the instrument
        :type instrument_name: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param search: text to be used for filtering the entities
        :type search: str
        :param dataset_type: type of the dataset
        :type dataset_type: str
        :param nested: true if processed datasets will be populated
        :type nested: bool
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param sort_order: order applied to the sorting (-1 or 1) (ascending or descending)
        :type sort_order: str
        :param parameters: dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details
        :type parameters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_dataset_get_serialize(
            session_id=session_id,
            investigation_ids=investigation_ids,
            dataset_ids=dataset_ids,
            sample_id=sample_id,
            instrument_name=instrument_name,
            limit=limit,
            skip=skip,
            search=search,
            dataset_type=dataset_type,
            nested=nested,
            sort_by=sort_by,
            sort_order=sort_order,
            parameters=parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Dataset]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_dataset_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_ids: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier list (comma separated)")] = None,
        dataset_ids: Annotated[Optional[StrictStr], Field(description="Metadata catalogue dataset identifier list (comma separated)")] = None,
        sample_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue sample identifier")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the beamline or the instrument")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        dataset_type: Annotated[Optional[StrictStr], Field(description="type of the dataset")] = None,
        nested: Annotated[Optional[StrictBool], Field(description="true if processed datasets will be populated")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="order applied to the sorting (-1 or 1) (ascending or descending)")] = None,
        parameters: Annotated[Optional[StrictStr], Field(description="dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Dataset]]:
        """Gets datasets for a given investigationId or for a given datasetIds of for a sampleId or for a beamline


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_ids: Metadata catalogue investigation identifier list (comma separated)
        :type investigation_ids: str
        :param dataset_ids: Metadata catalogue dataset identifier list (comma separated)
        :type dataset_ids: str
        :param sample_id: Metadata catalogue sample identifier
        :type sample_id: str
        :param instrument_name: name of the beamline or the instrument
        :type instrument_name: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param search: text to be used for filtering the entities
        :type search: str
        :param dataset_type: type of the dataset
        :type dataset_type: str
        :param nested: true if processed datasets will be populated
        :type nested: bool
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param sort_order: order applied to the sorting (-1 or 1) (ascending or descending)
        :type sort_order: str
        :param parameters: dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details
        :type parameters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_dataset_get_serialize(
            session_id=session_id,
            investigation_ids=investigation_ids,
            dataset_ids=dataset_ids,
            sample_id=sample_id,
            instrument_name=instrument_name,
            limit=limit,
            skip=skip,
            search=search,
            dataset_type=dataset_type,
            nested=nested,
            sort_by=sort_by,
            sort_order=sort_order,
            parameters=parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Dataset]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_dataset_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_ids: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier list (comma separated)")] = None,
        dataset_ids: Annotated[Optional[StrictStr], Field(description="Metadata catalogue dataset identifier list (comma separated)")] = None,
        sample_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue sample identifier")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="name of the beamline or the instrument")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        dataset_type: Annotated[Optional[StrictStr], Field(description="type of the dataset")] = None,
        nested: Annotated[Optional[StrictBool], Field(description="true if processed datasets will be populated")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="order applied to the sorting (-1 or 1) (ascending or descending)")] = None,
        parameters: Annotated[Optional[StrictStr], Field(description="dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets datasets for a given investigationId or for a given datasetIds of for a sampleId or for a beamline


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_ids: Metadata catalogue investigation identifier list (comma separated)
        :type investigation_ids: str
        :param dataset_ids: Metadata catalogue dataset identifier list (comma separated)
        :type dataset_ids: str
        :param sample_id: Metadata catalogue sample identifier
        :type sample_id: str
        :param instrument_name: name of the beamline or the instrument
        :type instrument_name: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param search: text to be used for filtering the entities
        :type search: str
        :param dataset_type: type of the dataset
        :type dataset_type: str
        :param nested: true if processed datasets will be populated
        :type nested: bool
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param sort_order: order applied to the sorting (-1 or 1) (ascending or descending)
        :type sort_order: str
        :param parameters: dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details
        :type parameters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_dataset_get_serialize(
            session_id=session_id,
            investigation_ids=investigation_ids,
            dataset_ids=dataset_ids,
            sample_id=sample_id,
            instrument_name=instrument_name,
            limit=limit,
            skip=skip,
            search=search,
            dataset_type=dataset_type,
            nested=nested,
            sort_by=sort_by,
            sort_order=sort_order,
            parameters=parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Dataset]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_dataset_get_serialize(
        self,
        session_id,
        investigation_ids,
        dataset_ids,
        sample_id,
        instrument_name,
        limit,
        skip,
        search,
        dataset_type,
        nested,
        sort_by,
        sort_order,
        parameters,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if investigation_ids is not None:
            
            _query_params.append(('investigationIds', investigation_ids))
            
        if dataset_ids is not None:
            
            _query_params.append(('datasetIds', dataset_ids))
            
        if sample_id is not None:
            
            _query_params.append(('sampleId', sample_id))
            
        if instrument_name is not None:
            
            _query_params.append(('instrumentName', instrument_name))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if skip is not None:
            
            _query_params.append(('skip', skip))
            
        if search is not None:
            
            _query_params.append(('search', search))
            
        if dataset_type is not None:
            
            _query_params.append(('datasetType', dataset_type))
            
        if nested is not None:
            
            _query_params.append(('nested', nested))
            
        if sort_by is not None:
            
            _query_params.append(('sortBy', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sortOrder', sort_order))
            
        if parameters is not None:
            
            _query_params.append(('parameters', parameters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/dataset',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_dataset_id_dataset_id_datacollection_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        dataset_id: Annotated[StrictStr, Field(description="Metadata catalogue dataset identifier")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Datacollection]:
        """(Deprecated) Returns datacollections related to a given dataset along with a datasetId


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param dataset_id: Metadata catalogue dataset identifier (required)
        :type dataset_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /catalogue/{sessionId}/dataset/id/{datasetId}/datacollection is deprecated.", DeprecationWarning)

        _param = self._catalogue_session_id_dataset_id_dataset_id_datacollection_get_serialize(
            session_id=session_id,
            dataset_id=dataset_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Datacollection]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_dataset_id_dataset_id_datacollection_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        dataset_id: Annotated[StrictStr, Field(description="Metadata catalogue dataset identifier")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Datacollection]]:
        """(Deprecated) Returns datacollections related to a given dataset along with a datasetId


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param dataset_id: Metadata catalogue dataset identifier (required)
        :type dataset_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /catalogue/{sessionId}/dataset/id/{datasetId}/datacollection is deprecated.", DeprecationWarning)

        _param = self._catalogue_session_id_dataset_id_dataset_id_datacollection_get_serialize(
            session_id=session_id,
            dataset_id=dataset_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Datacollection]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_dataset_id_dataset_id_datacollection_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        dataset_id: Annotated[StrictStr, Field(description="Metadata catalogue dataset identifier")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Returns datacollections related to a given dataset along with a datasetId


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param dataset_id: Metadata catalogue dataset identifier (required)
        :type dataset_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /catalogue/{sessionId}/dataset/id/{datasetId}/datacollection is deprecated.", DeprecationWarning)

        _param = self._catalogue_session_id_dataset_id_dataset_id_datacollection_get_serialize(
            session_id=session_id,
            dataset_id=dataset_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Datacollection]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_dataset_id_dataset_id_datacollection_get_serialize(
        self,
        session_id,
        dataset_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        if dataset_id is not None:
            _path_params['datasetId'] = dataset_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/dataset/id/{datasetId}/datacollection',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_dataset_id_dataset_id_datafile_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        dataset_id: Annotated[StrictStr, Field(description="Metadata catalogue dataset identifier")],
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Datafile]:
        """(Deprecated) Get datafiles for a given dataset id. Method replaced by /catalogue/{sessionId}/datafile


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param dataset_id: Metadata catalogue dataset identifier (required)
        :type dataset_id: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param search: text to be used for filtering the entities
        :type search: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /catalogue/{sessionId}/dataset/id/{datasetId}/datafile is deprecated.", DeprecationWarning)

        _param = self._catalogue_session_id_dataset_id_dataset_id_datafile_get_serialize(
            session_id=session_id,
            dataset_id=dataset_id,
            limit=limit,
            skip=skip,
            search=search,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Datafile]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_dataset_id_dataset_id_datafile_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        dataset_id: Annotated[StrictStr, Field(description="Metadata catalogue dataset identifier")],
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Datafile]]:
        """(Deprecated) Get datafiles for a given dataset id. Method replaced by /catalogue/{sessionId}/datafile


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param dataset_id: Metadata catalogue dataset identifier (required)
        :type dataset_id: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param search: text to be used for filtering the entities
        :type search: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /catalogue/{sessionId}/dataset/id/{datasetId}/datafile is deprecated.", DeprecationWarning)

        _param = self._catalogue_session_id_dataset_id_dataset_id_datafile_get_serialize(
            session_id=session_id,
            dataset_id=dataset_id,
            limit=limit,
            skip=skip,
            search=search,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Datafile]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_dataset_id_dataset_id_datafile_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        dataset_id: Annotated[StrictStr, Field(description="Metadata catalogue dataset identifier")],
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Get datafiles for a given dataset id. Method replaced by /catalogue/{sessionId}/datafile


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param dataset_id: Metadata catalogue dataset identifier (required)
        :type dataset_id: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param search: text to be used for filtering the entities
        :type search: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /catalogue/{sessionId}/dataset/id/{datasetId}/datafile is deprecated.", DeprecationWarning)

        _param = self._catalogue_session_id_dataset_id_dataset_id_datafile_get_serialize(
            session_id=session_id,
            dataset_id=dataset_id,
            limit=limit,
            skip=skip,
            search=search,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Datafile]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_dataset_id_dataset_id_datafile_get_serialize(
        self,
        session_id,
        dataset_id,
        limit,
        skip,
        search,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        if dataset_id is not None:
            _path_params['datasetId'] = dataset_id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if skip is not None:
            
            _query_params.append(('skip', skip))
            
        if search is not None:
            
            _query_params.append(('search', search))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/dataset/id/{datasetId}/datafile',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_dataset_id_dataset_ids_dataset_document_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        dataset_ids: Annotated[StrictStr, Field(description="Metadata catalogue dataset identifier list (comma separated)")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[DatasetDocument]:
        """Get a list of dataset documents from a datasetId list. A dataset document is used for indexing a dataset in elastic search. It unflatters dataset's parameters.


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param dataset_ids: Metadata catalogue dataset identifier list (comma separated) (required)
        :type dataset_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_dataset_id_dataset_ids_dataset_document_get_serialize(
            session_id=session_id,
            dataset_ids=dataset_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DatasetDocument]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_dataset_id_dataset_ids_dataset_document_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        dataset_ids: Annotated[StrictStr, Field(description="Metadata catalogue dataset identifier list (comma separated)")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[DatasetDocument]]:
        """Get a list of dataset documents from a datasetId list. A dataset document is used for indexing a dataset in elastic search. It unflatters dataset's parameters.


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param dataset_ids: Metadata catalogue dataset identifier list (comma separated) (required)
        :type dataset_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_dataset_id_dataset_ids_dataset_document_get_serialize(
            session_id=session_id,
            dataset_ids=dataset_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DatasetDocument]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_dataset_id_dataset_ids_dataset_document_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        dataset_ids: Annotated[StrictStr, Field(description="Metadata catalogue dataset identifier list (comma separated)")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a list of dataset documents from a datasetId list. A dataset document is used for indexing a dataset in elastic search. It unflatters dataset's parameters.


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param dataset_ids: Metadata catalogue dataset identifier list (comma separated) (required)
        :type dataset_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_dataset_id_dataset_ids_dataset_document_get_serialize(
            session_id=session_id,
            dataset_ids=dataset_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DatasetDocument]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_dataset_id_dataset_ids_dataset_document_get_serialize(
        self,
        session_id,
        dataset_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        if dataset_ids is not None:
            _path_params['datasetIds'] = dataset_ids
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/dataset/id/{datasetIds}/dataset_document',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_dataset_id_dataset_ids_dataset_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        dataset_ids: Annotated[StrictStr, Field(description="Metadata catalogue dataset identifier list (comma separated)")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Dataset]:
        """(Deprecated) Get a list of dataset from a datasetId list


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param dataset_ids: Metadata catalogue dataset identifier list (comma separated) (required)
        :type dataset_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /catalogue/{sessionId}/dataset/id/{datasetIds}/dataset is deprecated.", DeprecationWarning)

        _param = self._catalogue_session_id_dataset_id_dataset_ids_dataset_get_serialize(
            session_id=session_id,
            dataset_ids=dataset_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Dataset]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_dataset_id_dataset_ids_dataset_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        dataset_ids: Annotated[StrictStr, Field(description="Metadata catalogue dataset identifier list (comma separated)")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Dataset]]:
        """(Deprecated) Get a list of dataset from a datasetId list


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param dataset_ids: Metadata catalogue dataset identifier list (comma separated) (required)
        :type dataset_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /catalogue/{sessionId}/dataset/id/{datasetIds}/dataset is deprecated.", DeprecationWarning)

        _param = self._catalogue_session_id_dataset_id_dataset_ids_dataset_get_serialize(
            session_id=session_id,
            dataset_ids=dataset_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Dataset]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_dataset_id_dataset_ids_dataset_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        dataset_ids: Annotated[StrictStr, Field(description="Metadata catalogue dataset identifier list (comma separated)")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Get a list of dataset from a datasetId list


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param dataset_ids: Metadata catalogue dataset identifier list (comma separated) (required)
        :type dataset_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /catalogue/{sessionId}/dataset/id/{datasetIds}/dataset is deprecated.", DeprecationWarning)

        _param = self._catalogue_session_id_dataset_id_dataset_ids_dataset_get_serialize(
            session_id=session_id,
            dataset_ids=dataset_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Dataset]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_dataset_id_dataset_ids_dataset_get_serialize(
        self,
        session_id,
        dataset_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        if dataset_ids is not None:
            _path_params['datasetIds'] = dataset_ids
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/dataset/id/{datasetIds}/dataset',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_dataset_startdate_start_date_enddate_end_date_dataset_document_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        start_date: Annotated[StrictStr, Field(description="start date")],
        end_date: Annotated[StrictStr, Field(description="start date")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[DatasetDocument]:
        """Get a list of dataset documents by date range. A dataset document is used for indexing a dataset in elastic search. It unflatters dataset's parameters.


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param start_date: start date (required)
        :type start_date: str
        :param end_date: start date (required)
        :type end_date: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_dataset_startdate_start_date_enddate_end_date_dataset_document_get_serialize(
            session_id=session_id,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DatasetDocument]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_dataset_startdate_start_date_enddate_end_date_dataset_document_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        start_date: Annotated[StrictStr, Field(description="start date")],
        end_date: Annotated[StrictStr, Field(description="start date")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[DatasetDocument]]:
        """Get a list of dataset documents by date range. A dataset document is used for indexing a dataset in elastic search. It unflatters dataset's parameters.


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param start_date: start date (required)
        :type start_date: str
        :param end_date: start date (required)
        :type end_date: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_dataset_startdate_start_date_enddate_end_date_dataset_document_get_serialize(
            session_id=session_id,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DatasetDocument]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_dataset_startdate_start_date_enddate_end_date_dataset_document_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        start_date: Annotated[StrictStr, Field(description="start date")],
        end_date: Annotated[StrictStr, Field(description="start date")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a list of dataset documents by date range. A dataset document is used for indexing a dataset in elastic search. It unflatters dataset's parameters.


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param start_date: start date (required)
        :type start_date: str
        :param end_date: start date (required)
        :type end_date: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_dataset_startdate_start_date_enddate_end_date_dataset_document_get_serialize(
            session_id=session_id,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DatasetDocument]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_dataset_startdate_start_date_enddate_end_date_dataset_document_get_serialize(
        self,
        session_id,
        start_date,
        end_date,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        if start_date is not None:
            _path_params['startDate'] = start_date
        if end_date is not None:
            _path_params['endDate'] = end_date
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/dataset/startdate/{startDate}/enddate/{endDate}/dataset_document',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_dataset_timeline_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier")] = None,
        sample_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue sample identifier")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Timeline]:
        """Gets datasets timeline for a given investigationId or sampleId


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier
        :type investigation_id: str
        :param sample_id: Metadata catalogue sample identifier
        :type sample_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_dataset_timeline_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            sample_id=sample_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Timeline]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_dataset_timeline_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier")] = None,
        sample_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue sample identifier")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Timeline]]:
        """Gets datasets timeline for a given investigationId or sampleId


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier
        :type investigation_id: str
        :param sample_id: Metadata catalogue sample identifier
        :type sample_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_dataset_timeline_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            sample_id=sample_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Timeline]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_dataset_timeline_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier")] = None,
        sample_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue sample identifier")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets datasets timeline for a given investigationId or sampleId


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier
        :type investigation_id: str
        :param sample_id: Metadata catalogue sample identifier
        :type sample_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_dataset_timeline_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            sample_id=sample_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Timeline]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_dataset_timeline_get_serialize(
        self,
        session_id,
        investigation_id,
        sample_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if investigation_id is not None:
            
            _query_params.append(('investigationId', investigation_id))
            
        if sample_id is not None:
            
            _query_params.append(('sampleId', sample_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/dataset/timeline',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_datasetparameter_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier list (comma separated)")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="the name of the instrument or instrument (comma separated)")] = None,
        sample_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue sample identifier")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="start date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="end date")] = None,
        name: Annotated[Optional[StrictStr], Field(description="the name of the parameter type to filter by. It must be only one parameter for json, and a comma-separated list for csv (2 values min.)")] = None,
        dataset_type: Annotated[Optional[StrictStr], Field(description="the type of dataset to filter by")] = None,
        format: Annotated[Optional[StrictStr], Field(description="format of the returned data. json is the default format")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Datasetparameter]:
        """Returns the parameters


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier list (comma separated)
        :type investigation_id: str
        :param instrument_name: the name of the instrument or instrument (comma separated)
        :type instrument_name: str
        :param sample_id: Metadata catalogue sample identifier
        :type sample_id: str
        :param start_date: start date
        :type start_date: str
        :param end_date: end date
        :type end_date: str
        :param name: the name of the parameter type to filter by. It must be only one parameter for json, and a comma-separated list for csv (2 values min.)
        :type name: str
        :param dataset_type: the type of dataset to filter by
        :type dataset_type: str
        :param format: format of the returned data. json is the default format
        :type format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_datasetparameter_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            sample_id=sample_id,
            start_date=start_date,
            end_date=end_date,
            name=name,
            dataset_type=dataset_type,
            format=format,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Datasetparameter]",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_datasetparameter_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier list (comma separated)")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="the name of the instrument or instrument (comma separated)")] = None,
        sample_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue sample identifier")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="start date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="end date")] = None,
        name: Annotated[Optional[StrictStr], Field(description="the name of the parameter type to filter by. It must be only one parameter for json, and a comma-separated list for csv (2 values min.)")] = None,
        dataset_type: Annotated[Optional[StrictStr], Field(description="the type of dataset to filter by")] = None,
        format: Annotated[Optional[StrictStr], Field(description="format of the returned data. json is the default format")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Datasetparameter]]:
        """Returns the parameters


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier list (comma separated)
        :type investigation_id: str
        :param instrument_name: the name of the instrument or instrument (comma separated)
        :type instrument_name: str
        :param sample_id: Metadata catalogue sample identifier
        :type sample_id: str
        :param start_date: start date
        :type start_date: str
        :param end_date: end date
        :type end_date: str
        :param name: the name of the parameter type to filter by. It must be only one parameter for json, and a comma-separated list for csv (2 values min.)
        :type name: str
        :param dataset_type: the type of dataset to filter by
        :type dataset_type: str
        :param format: format of the returned data. json is the default format
        :type format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_datasetparameter_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            sample_id=sample_id,
            start_date=start_date,
            end_date=end_date,
            name=name,
            dataset_type=dataset_type,
            format=format,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Datasetparameter]",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_datasetparameter_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier list (comma separated)")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="the name of the instrument or instrument (comma separated)")] = None,
        sample_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue sample identifier")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="start date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="end date")] = None,
        name: Annotated[Optional[StrictStr], Field(description="the name of the parameter type to filter by. It must be only one parameter for json, and a comma-separated list for csv (2 values min.)")] = None,
        dataset_type: Annotated[Optional[StrictStr], Field(description="the type of dataset to filter by")] = None,
        format: Annotated[Optional[StrictStr], Field(description="format of the returned data. json is the default format")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns the parameters


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier list (comma separated)
        :type investigation_id: str
        :param instrument_name: the name of the instrument or instrument (comma separated)
        :type instrument_name: str
        :param sample_id: Metadata catalogue sample identifier
        :type sample_id: str
        :param start_date: start date
        :type start_date: str
        :param end_date: end date
        :type end_date: str
        :param name: the name of the parameter type to filter by. It must be only one parameter for json, and a comma-separated list for csv (2 values min.)
        :type name: str
        :param dataset_type: the type of dataset to filter by
        :type dataset_type: str
        :param format: format of the returned data. json is the default format
        :type format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_datasetparameter_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            sample_id=sample_id,
            start_date=start_date,
            end_date=end_date,
            name=name,
            dataset_type=dataset_type,
            format=format,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Datasetparameter]",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_datasetparameter_get_serialize(
        self,
        session_id,
        investigation_id,
        instrument_name,
        sample_id,
        start_date,
        end_date,
        name,
        dataset_type,
        format,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if investigation_id is not None:
            
            _query_params.append(('investigationId', investigation_id))
            
        if instrument_name is not None:
            
            _query_params.append(('instrumentName', instrument_name))
            
        if sample_id is not None:
            
            _query_params.append(('sampleId', sample_id))
            
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('endDate', end_date))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if dataset_type is not None:
            
            _query_params.append(('datasetType', dataset_type))
            
        if format is not None:
            
            _query_params.append(('format', format))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/datasetparameter',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_datasetparameter_put(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        parameter_id: Annotated[Optional[StrictStr], Field(description="identifier of the parameter")] = None,
        parameter: Annotated[Optional[Parameter], Field(description="parameter to update")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Update a value of a dataset parameter


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param parameter_id: identifier of the parameter
        :type parameter_id: str
        :param parameter: parameter to update
        :type parameter: Parameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_datasetparameter_put_serialize(
            session_id=session_id,
            parameter_id=parameter_id,
            parameter=parameter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_datasetparameter_put_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        parameter_id: Annotated[Optional[StrictStr], Field(description="identifier of the parameter")] = None,
        parameter: Annotated[Optional[Parameter], Field(description="parameter to update")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Update a value of a dataset parameter


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param parameter_id: identifier of the parameter
        :type parameter_id: str
        :param parameter: parameter to update
        :type parameter: Parameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_datasetparameter_put_serialize(
            session_id=session_id,
            parameter_id=parameter_id,
            parameter=parameter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_datasetparameter_put_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        parameter_id: Annotated[Optional[StrictStr], Field(description="identifier of the parameter")] = None,
        parameter: Annotated[Optional[Parameter], Field(description="parameter to update")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update a value of a dataset parameter


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param parameter_id: identifier of the parameter
        :type parameter_id: str
        :param parameter: parameter to update
        :type parameter: Parameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_datasetparameter_put_serialize(
            session_id=session_id,
            parameter_id=parameter_id,
            parameter=parameter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_datasetparameter_put_serialize(
        self,
        session_id,
        parameter_id,
        parameter,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if parameter_id is not None:
            
            _query_params.append(('parameterId', parameter_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if parameter is not None:
            _body_params = parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/catalogue/{sessionId}/datasetparameter',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_datasetparameter_values_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier list (comma separated)")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="the name of the instrument or instrument (comma separated)")] = None,
        sample_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue sample identifier")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="start date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="end date")] = None,
        name: Annotated[Optional[StrictStr], Field(description="the name of the parameter type to filter by")] = None,
        dataset_type: Annotated[Optional[StrictStr], Field(description="the type of dataset to filter by")] = None,
        parameters: Annotated[Optional[StrictStr], Field(description="dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Datasetparameter]:
        """Returns the values of the parameters


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier list (comma separated)
        :type investigation_id: str
        :param instrument_name: the name of the instrument or instrument (comma separated)
        :type instrument_name: str
        :param sample_id: Metadata catalogue sample identifier
        :type sample_id: str
        :param start_date: start date
        :type start_date: str
        :param end_date: end date
        :type end_date: str
        :param name: the name of the parameter type to filter by
        :type name: str
        :param dataset_type: the type of dataset to filter by
        :type dataset_type: str
        :param parameters: dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details
        :type parameters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_datasetparameter_values_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            sample_id=sample_id,
            start_date=start_date,
            end_date=end_date,
            name=name,
            dataset_type=dataset_type,
            parameters=parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Datasetparameter]",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_datasetparameter_values_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier list (comma separated)")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="the name of the instrument or instrument (comma separated)")] = None,
        sample_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue sample identifier")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="start date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="end date")] = None,
        name: Annotated[Optional[StrictStr], Field(description="the name of the parameter type to filter by")] = None,
        dataset_type: Annotated[Optional[StrictStr], Field(description="the type of dataset to filter by")] = None,
        parameters: Annotated[Optional[StrictStr], Field(description="dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Datasetparameter]]:
        """Returns the values of the parameters


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier list (comma separated)
        :type investigation_id: str
        :param instrument_name: the name of the instrument or instrument (comma separated)
        :type instrument_name: str
        :param sample_id: Metadata catalogue sample identifier
        :type sample_id: str
        :param start_date: start date
        :type start_date: str
        :param end_date: end date
        :type end_date: str
        :param name: the name of the parameter type to filter by
        :type name: str
        :param dataset_type: the type of dataset to filter by
        :type dataset_type: str
        :param parameters: dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details
        :type parameters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_datasetparameter_values_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            sample_id=sample_id,
            start_date=start_date,
            end_date=end_date,
            name=name,
            dataset_type=dataset_type,
            parameters=parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Datasetparameter]",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_datasetparameter_values_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier list (comma separated)")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="the name of the instrument or instrument (comma separated)")] = None,
        sample_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue sample identifier")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="start date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="end date")] = None,
        name: Annotated[Optional[StrictStr], Field(description="the name of the parameter type to filter by")] = None,
        dataset_type: Annotated[Optional[StrictStr], Field(description="the type of dataset to filter by")] = None,
        parameters: Annotated[Optional[StrictStr], Field(description="dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns the values of the parameters


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier list (comma separated)
        :type investigation_id: str
        :param instrument_name: the name of the instrument or instrument (comma separated)
        :type instrument_name: str
        :param sample_id: Metadata catalogue sample identifier
        :type sample_id: str
        :param start_date: start date
        :type start_date: str
        :param end_date: end date
        :type end_date: str
        :param name: the name of the parameter type to filter by
        :type name: str
        :param dataset_type: the type of dataset to filter by
        :type dataset_type: str
        :param parameters: dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details
        :type parameters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_datasetparameter_values_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            sample_id=sample_id,
            start_date=start_date,
            end_date=end_date,
            name=name,
            dataset_type=dataset_type,
            parameters=parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Datasetparameter]",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_datasetparameter_values_get_serialize(
        self,
        session_id,
        investigation_id,
        instrument_name,
        sample_id,
        start_date,
        end_date,
        name,
        dataset_type,
        parameters,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if investigation_id is not None:
            
            _query_params.append(('investigationId', investigation_id))
            
        if instrument_name is not None:
            
            _query_params.append(('instrumentName', instrument_name))
            
        if sample_id is not None:
            
            _query_params.append(('sampleId', sample_id))
            
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('endDate', end_date))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if dataset_type is not None:
            
            _query_params.append(('datasetType', dataset_type))
            
        if parameters is not None:
            
            _query_params.append(('parameters', parameters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/datasetparameter/values',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_files_download_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        sample_id: Annotated[StrictStr, Field(description="Metadata catalogue sample identifier")],
        resource_id: Annotated[StrictStr, Field(description="file resourceId")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Download the file associated to a sample

        Returns the file indentified by the resourceId

        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param sample_id: Metadata catalogue sample identifier (required)
        :type sample_id: str
        :param resource_id: file resourceId (required)
        :type resource_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_files_download_get_serialize(
            session_id=session_id,
            sample_id=sample_id,
            resource_id=resource_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_files_download_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        sample_id: Annotated[StrictStr, Field(description="Metadata catalogue sample identifier")],
        resource_id: Annotated[StrictStr, Field(description="file resourceId")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Download the file associated to a sample

        Returns the file indentified by the resourceId

        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param sample_id: Metadata catalogue sample identifier (required)
        :type sample_id: str
        :param resource_id: file resourceId (required)
        :type resource_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_files_download_get_serialize(
            session_id=session_id,
            sample_id=sample_id,
            resource_id=resource_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_files_download_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        sample_id: Annotated[StrictStr, Field(description="Metadata catalogue sample identifier")],
        resource_id: Annotated[StrictStr, Field(description="file resourceId")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Download the file associated to a sample

        Returns the file indentified by the resourceId

        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param sample_id: Metadata catalogue sample identifier (required)
        :type sample_id: str
        :param resource_id: file resourceId (required)
        :type resource_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_files_download_get_serialize(
            session_id=session_id,
            sample_id=sample_id,
            resource_id=resource_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_files_download_get_serialize(
        self,
        session_id,
        sample_id,
        resource_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if sample_id is not None:
            
            _query_params.append(('sampleId', sample_id))
            
        if resource_id is not None:
            
            _query_params.append(('resourceId', resource_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/files/download',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_files_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        sample_id: Annotated[StrictStr, Field(description="Metadata catalogue sample identifier")],
        group_name: Annotated[Optional[StrictStr], Field(description="groupName filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Sampleinformation:
        """Get the list of the files linked to a sample

        Returns the list of files and associated metadata linked to a sample

        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param sample_id: Metadata catalogue sample identifier (required)
        :type sample_id: str
        :param group_name: groupName filter
        :type group_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_files_get_serialize(
            session_id=session_id,
            sample_id=sample_id,
            group_name=group_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Sampleinformation",
            '400': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_files_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        sample_id: Annotated[StrictStr, Field(description="Metadata catalogue sample identifier")],
        group_name: Annotated[Optional[StrictStr], Field(description="groupName filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Sampleinformation]:
        """Get the list of the files linked to a sample

        Returns the list of files and associated metadata linked to a sample

        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param sample_id: Metadata catalogue sample identifier (required)
        :type sample_id: str
        :param group_name: groupName filter
        :type group_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_files_get_serialize(
            session_id=session_id,
            sample_id=sample_id,
            group_name=group_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Sampleinformation",
            '400': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_files_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        sample_id: Annotated[StrictStr, Field(description="Metadata catalogue sample identifier")],
        group_name: Annotated[Optional[StrictStr], Field(description="groupName filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the list of the files linked to a sample

        Returns the list of files and associated metadata linked to a sample

        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param sample_id: Metadata catalogue sample identifier (required)
        :type sample_id: str
        :param group_name: groupName filter
        :type group_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_files_get_serialize(
            session_id=session_id,
            sample_id=sample_id,
            group_name=group_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Sampleinformation",
            '400': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_files_get_serialize(
        self,
        session_id,
        sample_id,
        group_name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if sample_id is not None:
            
            _query_params.append(('sampleId', sample_id))
            
        if group_name is not None:
            
            _query_params.append(('groupName', group_name))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/files',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_files_upload_post(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        sample_id: Annotated[StrictStr, Field(description="Metadata catalogue sample identifier")],
        file: Union[StrictBytes, StrictStr],
        file_type: StrictStr,
        group_name: Optional[StrictStr] = None,
        multiplicity: Optional[Union[StrictFloat, StrictInt]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Sampleinformation:
        """Upload a file and information linked to a sample

        upload a file (like .pdb) and information (filetype, groupName, etc.) and link it to a sample

        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param sample_id: Metadata catalogue sample identifier (required)
        :type sample_id: str
        :param file: (required)
        :type file: bytearray
        :param file_type: (required)
        :type file_type: str
        :param group_name:
        :type group_name: str
        :param multiplicity:
        :type multiplicity: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_files_upload_post_serialize(
            session_id=session_id,
            sample_id=sample_id,
            file=file,
            file_type=file_type,
            group_name=group_name,
            multiplicity=multiplicity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Sampleinformation",
            '400': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_files_upload_post_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        sample_id: Annotated[StrictStr, Field(description="Metadata catalogue sample identifier")],
        file: Union[StrictBytes, StrictStr],
        file_type: StrictStr,
        group_name: Optional[StrictStr] = None,
        multiplicity: Optional[Union[StrictFloat, StrictInt]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Sampleinformation]:
        """Upload a file and information linked to a sample

        upload a file (like .pdb) and information (filetype, groupName, etc.) and link it to a sample

        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param sample_id: Metadata catalogue sample identifier (required)
        :type sample_id: str
        :param file: (required)
        :type file: bytearray
        :param file_type: (required)
        :type file_type: str
        :param group_name:
        :type group_name: str
        :param multiplicity:
        :type multiplicity: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_files_upload_post_serialize(
            session_id=session_id,
            sample_id=sample_id,
            file=file,
            file_type=file_type,
            group_name=group_name,
            multiplicity=multiplicity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Sampleinformation",
            '400': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_files_upload_post_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        sample_id: Annotated[StrictStr, Field(description="Metadata catalogue sample identifier")],
        file: Union[StrictBytes, StrictStr],
        file_type: StrictStr,
        group_name: Optional[StrictStr] = None,
        multiplicity: Optional[Union[StrictFloat, StrictInt]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Upload a file and information linked to a sample

        upload a file (like .pdb) and information (filetype, groupName, etc.) and link it to a sample

        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param sample_id: Metadata catalogue sample identifier (required)
        :type sample_id: str
        :param file: (required)
        :type file: bytearray
        :param file_type: (required)
        :type file_type: str
        :param group_name:
        :type group_name: str
        :param multiplicity:
        :type multiplicity: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_files_upload_post_serialize(
            session_id=session_id,
            sample_id=sample_id,
            file=file,
            file_type=file_type,
            group_name=group_name,
            multiplicity=multiplicity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Sampleinformation",
            '400': "str",
            '403': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_files_upload_post_serialize(
        self,
        session_id,
        sample_id,
        file,
        file_type,
        group_name,
        multiplicity,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if sample_id is not None:
            
            _query_params.append(('sampleId', sample_id))
            
        # process the header parameters
        # process the form parameters
        if file is not None:
            _files['file'] = file
        if file_type is not None:
            _form_params.append(('fileType', file_type))
        if group_name is not None:
            _form_params.append(('groupName', group_name))
        if multiplicity is not None:
            _form_params.append(('multiplicity', multiplicity))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/catalogue/{sessionId}/files/upload',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_instruments_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        filter: Annotated[Optional[StrictStr], Field(description="Filters the investigations attached to an user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Instrument]:
        """Returns all instruments linked to the user

        Returns instruments linked to the user, with instruments linked to the scientist if the user is beamline responsible, all instruments if administrator  if the filter is participant, it returns only the instruments linked to the user if the filter is instrumentscientist, it returns only the instruments linked to the scientist if the user is beamline responsible 

        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param filter: Filters the investigations attached to an user
        :type filter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_instruments_get_serialize(
            session_id=session_id,
            filter=filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Instrument]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_instruments_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        filter: Annotated[Optional[StrictStr], Field(description="Filters the investigations attached to an user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Instrument]]:
        """Returns all instruments linked to the user

        Returns instruments linked to the user, with instruments linked to the scientist if the user is beamline responsible, all instruments if administrator  if the filter is participant, it returns only the instruments linked to the user if the filter is instrumentscientist, it returns only the instruments linked to the scientist if the user is beamline responsible 

        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param filter: Filters the investigations attached to an user
        :type filter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_instruments_get_serialize(
            session_id=session_id,
            filter=filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Instrument]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_instruments_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        filter: Annotated[Optional[StrictStr], Field(description="Filters the investigations attached to an user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns all instruments linked to the user

        Returns instruments linked to the user, with instruments linked to the scientist if the user is beamline responsible, all instruments if administrator  if the filter is participant, it returns only the instruments linked to the user if the filter is instrumentscientist, it returns only the instruments linked to the scientist if the user is beamline responsible 

        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param filter: Filters the investigations attached to an user
        :type filter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_instruments_get_serialize(
            session_id=session_id,
            filter=filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Instrument]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_instruments_get_serialize(
        self,
        session_id,
        filter,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/instruments',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_investigation_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        instrument_name: Annotated[Optional[StrictStr], Field(description="the name of the instrument or instrument (comma separated)")] = None,
        investigation_name: Annotated[Optional[StrictStr], Field(description="It is the name of the proposal or investigation")] = None,
        ids: Annotated[Optional[StrictStr], Field(description="Comma separated investigation identifiers list")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Filters the investigations attached to an user")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="It filters the investigations for which startDate or endDate is after this startDate - not combined with ids")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="It filters the investigations for which startDate is lower than this endDate - not combined with ids")] = None,
        username: Annotated[Optional[StrictStr], Field(description="It filters the investigations for which the user is a participant (user.name prefix)")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="order applied to the sorting (-1 or 1) (ascending or descending)")] = None,
        with_has_access: Annotated[Optional[StrictBool], Field(description="flag to load information about access to the experiments' datasets")] = None,
        parameters: Annotated[Optional[StrictStr], Field(description="dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Investigation]:
        """Get investigations by sessionId

        If ids, it returns the investigations corresponding to these ids.  If filter is embargoed, it returns all investigations which are under embargoed, ie. with releaseDate is after today. If filter is released, it returns all investigations which are open, ie. with releaseDate is before today and with a DOI. If filter is instrumentscientist, it returns all investigations where user is instrumentScientitst. If filter is partipant, it returns all investigations where user has reading permissions. If no filter, it returns all user's investigations.  Instrument allows to filter investigations by instrument name.  StartDate and EndDate allows to filter investigations which occur during this period. 

        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param instrument_name: the name of the instrument or instrument (comma separated)
        :type instrument_name: str
        :param investigation_name: It is the name of the proposal or investigation
        :type investigation_name: str
        :param ids: Comma separated investigation identifiers list
        :type ids: str
        :param filter: Filters the investigations attached to an user
        :type filter: str
        :param start_date: It filters the investigations for which startDate or endDate is after this startDate - not combined with ids
        :type start_date: str
        :param end_date: It filters the investigations for which startDate is lower than this endDate - not combined with ids
        :type end_date: str
        :param username: It filters the investigations for which the user is a participant (user.name prefix)
        :type username: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param search: text to be used for filtering the entities
        :type search: str
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param sort_order: order applied to the sorting (-1 or 1) (ascending or descending)
        :type sort_order: str
        :param with_has_access: flag to load information about access to the experiments' datasets
        :type with_has_access: bool
        :param parameters: dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details
        :type parameters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_investigation_get_serialize(
            session_id=session_id,
            instrument_name=instrument_name,
            investigation_name=investigation_name,
            ids=ids,
            filter=filter,
            start_date=start_date,
            end_date=end_date,
            username=username,
            limit=limit,
            skip=skip,
            search=search,
            sort_by=sort_by,
            sort_order=sort_order,
            with_has_access=with_has_access,
            parameters=parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Investigation]",
            '400': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_investigation_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        instrument_name: Annotated[Optional[StrictStr], Field(description="the name of the instrument or instrument (comma separated)")] = None,
        investigation_name: Annotated[Optional[StrictStr], Field(description="It is the name of the proposal or investigation")] = None,
        ids: Annotated[Optional[StrictStr], Field(description="Comma separated investigation identifiers list")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Filters the investigations attached to an user")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="It filters the investigations for which startDate or endDate is after this startDate - not combined with ids")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="It filters the investigations for which startDate is lower than this endDate - not combined with ids")] = None,
        username: Annotated[Optional[StrictStr], Field(description="It filters the investigations for which the user is a participant (user.name prefix)")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="order applied to the sorting (-1 or 1) (ascending or descending)")] = None,
        with_has_access: Annotated[Optional[StrictBool], Field(description="flag to load information about access to the experiments' datasets")] = None,
        parameters: Annotated[Optional[StrictStr], Field(description="dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Investigation]]:
        """Get investigations by sessionId

        If ids, it returns the investigations corresponding to these ids.  If filter is embargoed, it returns all investigations which are under embargoed, ie. with releaseDate is after today. If filter is released, it returns all investigations which are open, ie. with releaseDate is before today and with a DOI. If filter is instrumentscientist, it returns all investigations where user is instrumentScientitst. If filter is partipant, it returns all investigations where user has reading permissions. If no filter, it returns all user's investigations.  Instrument allows to filter investigations by instrument name.  StartDate and EndDate allows to filter investigations which occur during this period. 

        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param instrument_name: the name of the instrument or instrument (comma separated)
        :type instrument_name: str
        :param investigation_name: It is the name of the proposal or investigation
        :type investigation_name: str
        :param ids: Comma separated investigation identifiers list
        :type ids: str
        :param filter: Filters the investigations attached to an user
        :type filter: str
        :param start_date: It filters the investigations for which startDate or endDate is after this startDate - not combined with ids
        :type start_date: str
        :param end_date: It filters the investigations for which startDate is lower than this endDate - not combined with ids
        :type end_date: str
        :param username: It filters the investigations for which the user is a participant (user.name prefix)
        :type username: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param search: text to be used for filtering the entities
        :type search: str
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param sort_order: order applied to the sorting (-1 or 1) (ascending or descending)
        :type sort_order: str
        :param with_has_access: flag to load information about access to the experiments' datasets
        :type with_has_access: bool
        :param parameters: dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details
        :type parameters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_investigation_get_serialize(
            session_id=session_id,
            instrument_name=instrument_name,
            investigation_name=investigation_name,
            ids=ids,
            filter=filter,
            start_date=start_date,
            end_date=end_date,
            username=username,
            limit=limit,
            skip=skip,
            search=search,
            sort_by=sort_by,
            sort_order=sort_order,
            with_has_access=with_has_access,
            parameters=parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Investigation]",
            '400': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_investigation_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        instrument_name: Annotated[Optional[StrictStr], Field(description="the name of the instrument or instrument (comma separated)")] = None,
        investigation_name: Annotated[Optional[StrictStr], Field(description="It is the name of the proposal or investigation")] = None,
        ids: Annotated[Optional[StrictStr], Field(description="Comma separated investigation identifiers list")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Filters the investigations attached to an user")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="It filters the investigations for which startDate or endDate is after this startDate - not combined with ids")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="It filters the investigations for which startDate is lower than this endDate - not combined with ids")] = None,
        username: Annotated[Optional[StrictStr], Field(description="It filters the investigations for which the user is a participant (user.name prefix)")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="order applied to the sorting (-1 or 1) (ascending or descending)")] = None,
        with_has_access: Annotated[Optional[StrictBool], Field(description="flag to load information about access to the experiments' datasets")] = None,
        parameters: Annotated[Optional[StrictStr], Field(description="dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get investigations by sessionId

        If ids, it returns the investigations corresponding to these ids.  If filter is embargoed, it returns all investigations which are under embargoed, ie. with releaseDate is after today. If filter is released, it returns all investigations which are open, ie. with releaseDate is before today and with a DOI. If filter is instrumentscientist, it returns all investigations where user is instrumentScientitst. If filter is partipant, it returns all investigations where user has reading permissions. If no filter, it returns all user's investigations.  Instrument allows to filter investigations by instrument name.  StartDate and EndDate allows to filter investigations which occur during this period. 

        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param instrument_name: the name of the instrument or instrument (comma separated)
        :type instrument_name: str
        :param investigation_name: It is the name of the proposal or investigation
        :type investigation_name: str
        :param ids: Comma separated investigation identifiers list
        :type ids: str
        :param filter: Filters the investigations attached to an user
        :type filter: str
        :param start_date: It filters the investigations for which startDate or endDate is after this startDate - not combined with ids
        :type start_date: str
        :param end_date: It filters the investigations for which startDate is lower than this endDate - not combined with ids
        :type end_date: str
        :param username: It filters the investigations for which the user is a participant (user.name prefix)
        :type username: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param search: text to be used for filtering the entities
        :type search: str
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param sort_order: order applied to the sorting (-1 or 1) (ascending or descending)
        :type sort_order: str
        :param with_has_access: flag to load information about access to the experiments' datasets
        :type with_has_access: bool
        :param parameters: dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details
        :type parameters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_investigation_get_serialize(
            session_id=session_id,
            instrument_name=instrument_name,
            investigation_name=investigation_name,
            ids=ids,
            filter=filter,
            start_date=start_date,
            end_date=end_date,
            username=username,
            limit=limit,
            skip=skip,
            search=search,
            sort_by=sort_by,
            sort_order=sort_order,
            with_has_access=with_has_access,
            parameters=parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Investigation]",
            '400': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_investigation_get_serialize(
        self,
        session_id,
        instrument_name,
        investigation_name,
        ids,
        filter,
        start_date,
        end_date,
        username,
        limit,
        skip,
        search,
        sort_by,
        sort_order,
        with_has_access,
        parameters,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if instrument_name is not None:
            
            _query_params.append(('instrumentName', instrument_name))
            
        if investigation_name is not None:
            
            _query_params.append(('investigationName', investigation_name))
            
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('endDate', end_date))
            
        if username is not None:
            
            _query_params.append(('username', username))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if skip is not None:
            
            _query_params.append(('skip', skip))
            
        if search is not None:
            
            _query_params.append(('search', search))
            
        if sort_by is not None:
            
            _query_params.append(('sortBy', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sortOrder', sort_order))
            
        if with_has_access is not None:
            
            _query_params.append(('withHasAccess', with_has_access))
            
        if parameters is not None:
            
            _query_params.append(('parameters', parameters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/investigation',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_investigation_id_investigation_id_investigationusers_delete(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[StrictInt, Field(description="Metadata Catalogue investigation identifier")],
        catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request: Annotated[CatalogueSessionIdInvestigationIdInvestigationIdInvestigationusersPostRequest, Field(description="Username")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Investigationusers]:
        """Deletes a user from an investigation. Only allowed to PI, LocalContact and Beamline staff


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata Catalogue investigation identifier (required)
        :type investigation_id: int
        :param catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request: Username (required)
        :type catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request: CatalogueSessionIdInvestigationIdInvestigationIdInvestigationusersPostRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_investigation_id_investigation_id_investigationusers_delete_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request=catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Investigationusers]",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_investigation_id_investigation_id_investigationusers_delete_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[StrictInt, Field(description="Metadata Catalogue investigation identifier")],
        catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request: Annotated[CatalogueSessionIdInvestigationIdInvestigationIdInvestigationusersPostRequest, Field(description="Username")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Investigationusers]]:
        """Deletes a user from an investigation. Only allowed to PI, LocalContact and Beamline staff


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata Catalogue investigation identifier (required)
        :type investigation_id: int
        :param catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request: Username (required)
        :type catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request: CatalogueSessionIdInvestigationIdInvestigationIdInvestigationusersPostRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_investigation_id_investigation_id_investigationusers_delete_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request=catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Investigationusers]",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_investigation_id_investigation_id_investigationusers_delete_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[StrictInt, Field(description="Metadata Catalogue investigation identifier")],
        catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request: Annotated[CatalogueSessionIdInvestigationIdInvestigationIdInvestigationusersPostRequest, Field(description="Username")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Deletes a user from an investigation. Only allowed to PI, LocalContact and Beamline staff


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata Catalogue investigation identifier (required)
        :type investigation_id: int
        :param catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request: Username (required)
        :type catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request: CatalogueSessionIdInvestigationIdInvestigationIdInvestigationusersPostRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_investigation_id_investigation_id_investigationusers_delete_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request=catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Investigationusers]",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_investigation_id_investigation_id_investigationusers_delete_serialize(
        self,
        session_id,
        investigation_id,
        catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        if investigation_id is not None:
            _path_params['investigationId'] = investigation_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request is not None:
            _body_params = catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/catalogue/{sessionId}/investigation/id/{investigationId}/investigationusers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_investigation_id_investigation_id_investigationusers_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[StrictInt, Field(description="Metadata Catalogue investigation identifier")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Investigationusers:
        """Gets users involved in a investigation


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata Catalogue investigation identifier (required)
        :type investigation_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_investigation_id_investigation_id_investigationusers_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Investigationusers",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_investigation_id_investigation_id_investigationusers_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[StrictInt, Field(description="Metadata Catalogue investigation identifier")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Investigationusers]:
        """Gets users involved in a investigation


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata Catalogue investigation identifier (required)
        :type investigation_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_investigation_id_investigation_id_investigationusers_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Investigationusers",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_investigation_id_investigation_id_investigationusers_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[StrictInt, Field(description="Metadata Catalogue investigation identifier")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets users involved in a investigation


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata Catalogue investigation identifier (required)
        :type investigation_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_investigation_id_investigation_id_investigationusers_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Investigationusers",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_investigation_id_investigation_id_investigationusers_get_serialize(
        self,
        session_id,
        investigation_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        if investigation_id is not None:
            _path_params['investigationId'] = investigation_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/investigation/id/{investigationId}/investigationusers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_investigation_id_investigation_id_investigationusers_post(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[StrictInt, Field(description="Metadata Catalogue investigation identifier")],
        catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request: Annotated[Optional[CatalogueSessionIdInvestigationIdInvestigationIdInvestigationusersPostRequest], Field(description="User name")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Investigationusers]:
        """Add users to an investigation. Only allowed to PI, LocalContact and Beamline staff


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata Catalogue investigation identifier (required)
        :type investigation_id: int
        :param catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request: User name
        :type catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request: CatalogueSessionIdInvestigationIdInvestigationIdInvestigationusersPostRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_investigation_id_investigation_id_investigationusers_post_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request=catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Investigationusers]",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_investigation_id_investigation_id_investigationusers_post_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[StrictInt, Field(description="Metadata Catalogue investigation identifier")],
        catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request: Annotated[Optional[CatalogueSessionIdInvestigationIdInvestigationIdInvestigationusersPostRequest], Field(description="User name")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Investigationusers]]:
        """Add users to an investigation. Only allowed to PI, LocalContact and Beamline staff


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata Catalogue investigation identifier (required)
        :type investigation_id: int
        :param catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request: User name
        :type catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request: CatalogueSessionIdInvestigationIdInvestigationIdInvestigationusersPostRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_investigation_id_investigation_id_investigationusers_post_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request=catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Investigationusers]",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_investigation_id_investigation_id_investigationusers_post_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[StrictInt, Field(description="Metadata Catalogue investigation identifier")],
        catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request: Annotated[Optional[CatalogueSessionIdInvestigationIdInvestigationIdInvestigationusersPostRequest], Field(description="User name")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Add users to an investigation. Only allowed to PI, LocalContact and Beamline staff


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata Catalogue investigation identifier (required)
        :type investigation_id: int
        :param catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request: User name
        :type catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request: CatalogueSessionIdInvestigationIdInvestigationIdInvestigationusersPostRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_investigation_id_investigation_id_investigationusers_post_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request=catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Investigationusers]",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_investigation_id_investigation_id_investigationusers_post_serialize(
        self,
        session_id,
        investigation_id,
        catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        if investigation_id is not None:
            _path_params['investigationId'] = investigation_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request is not None:
            _body_params = catalogue_session_id_investigation_id_investigation_id_investigationusers_post_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/catalogue/{sessionId}/investigation/id/{investigationId}/investigationusers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_investigation_id_investigation_id_sample_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[StrictStr, Field(description="Metadata catalogue investigation identifier")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Dataset]:
        """(Deprecated) Gets samples for a given investigationId


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier (required)
        :type investigation_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /catalogue/{sessionId}/investigation/id/{investigationId}/sample is deprecated.", DeprecationWarning)

        _param = self._catalogue_session_id_investigation_id_investigation_id_sample_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Dataset]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_investigation_id_investigation_id_sample_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[StrictStr, Field(description="Metadata catalogue investigation identifier")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Dataset]]:
        """(Deprecated) Gets samples for a given investigationId


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier (required)
        :type investigation_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /catalogue/{sessionId}/investigation/id/{investigationId}/sample is deprecated.", DeprecationWarning)

        _param = self._catalogue_session_id_investigation_id_investigation_id_sample_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Dataset]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_investigation_id_investigation_id_sample_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[StrictStr, Field(description="Metadata catalogue investigation identifier")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Gets samples for a given investigationId


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier (required)
        :type investigation_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /catalogue/{sessionId}/investigation/id/{investigationId}/sample is deprecated.", DeprecationWarning)

        _param = self._catalogue_session_id_investigation_id_investigation_id_sample_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Dataset]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_investigation_id_investigation_id_sample_get_serialize(
        self,
        session_id,
        investigation_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        if investigation_id is not None:
            _path_params['investigationId'] = investigation_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/investigation/id/{investigationId}/sample',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_investigation_investigation_id_user_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[StrictStr, Field(description="Metadata catalogue investigation identifier")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[User]:
        """Get user list of ICAT if the user if PI or LocalContact of the investigation, or InstrumentScientist or Administrator


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier (required)
        :type investigation_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_investigation_investigation_id_user_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[User]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_investigation_investigation_id_user_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[StrictStr, Field(description="Metadata catalogue investigation identifier")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[User]]:
        """Get user list of ICAT if the user if PI or LocalContact of the investigation, or InstrumentScientist or Administrator


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier (required)
        :type investigation_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_investigation_investigation_id_user_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[User]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_investigation_investigation_id_user_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[StrictStr, Field(description="Metadata catalogue investigation identifier")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get user list of ICAT if the user if PI or LocalContact of the investigation, or InstrumentScientist or Administrator


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier (required)
        :type investigation_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_investigation_investigation_id_user_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[User]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_investigation_investigation_id_user_get_serialize(
        self,
        session_id,
        investigation_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        if investigation_id is not None:
            _path_params['investigationId'] = investigation_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/investigation/{investigationId}/user',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_investigation_timeline_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        instrument: Annotated[StrictStr, Field(description="the name of the beamline")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Timeline]:
        """Gets investigation timeline for a given instrumentname


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param instrument: the name of the beamline (required)
        :type instrument: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_investigation_timeline_get_serialize(
            session_id=session_id,
            instrument=instrument,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Timeline]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_investigation_timeline_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        instrument: Annotated[StrictStr, Field(description="the name of the beamline")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Timeline]]:
        """Gets investigation timeline for a given instrumentname


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param instrument: the name of the beamline (required)
        :type instrument: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_investigation_timeline_get_serialize(
            session_id=session_id,
            instrument=instrument,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Timeline]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_investigation_timeline_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        instrument: Annotated[StrictStr, Field(description="the name of the beamline")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets investigation timeline for a given instrumentname


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param instrument: the name of the beamline (required)
        :type instrument: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_investigation_timeline_get_serialize(
            session_id=session_id,
            instrument=instrument,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Timeline]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_investigation_timeline_get_serialize(
        self,
        session_id,
        instrument,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if instrument is not None:
            
            _query_params.append(('instrument', instrument))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/investigation/timeline',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_sample_parameters_id_put(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        id: Annotated[StrictInt, Field(description="Metadata Catalogue parameter identifier")],
        investigation_id: Annotated[StrictStr, Field(description="identifier of the investigation")],
        parameter: Annotated[Optional[Parameter], Field(description="parameter to update")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Update sample parameter (description only if it is an editable sample or only sample comment)


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param id: Metadata Catalogue parameter identifier (required)
        :type id: int
        :param investigation_id: identifier of the investigation (required)
        :type investigation_id: str
        :param parameter: parameter to update
        :type parameter: Parameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_sample_parameters_id_put_serialize(
            session_id=session_id,
            id=id,
            investigation_id=investigation_id,
            parameter=parameter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_sample_parameters_id_put_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        id: Annotated[StrictInt, Field(description="Metadata Catalogue parameter identifier")],
        investigation_id: Annotated[StrictStr, Field(description="identifier of the investigation")],
        parameter: Annotated[Optional[Parameter], Field(description="parameter to update")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Update sample parameter (description only if it is an editable sample or only sample comment)


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param id: Metadata Catalogue parameter identifier (required)
        :type id: int
        :param investigation_id: identifier of the investigation (required)
        :type investigation_id: str
        :param parameter: parameter to update
        :type parameter: Parameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_sample_parameters_id_put_serialize(
            session_id=session_id,
            id=id,
            investigation_id=investigation_id,
            parameter=parameter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_sample_parameters_id_put_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        id: Annotated[StrictInt, Field(description="Metadata Catalogue parameter identifier")],
        investigation_id: Annotated[StrictStr, Field(description="identifier of the investigation")],
        parameter: Annotated[Optional[Parameter], Field(description="parameter to update")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update sample parameter (description only if it is an editable sample or only sample comment)


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param id: Metadata Catalogue parameter identifier (required)
        :type id: int
        :param investigation_id: identifier of the investigation (required)
        :type investigation_id: str
        :param parameter: parameter to update
        :type parameter: Parameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_sample_parameters_id_put_serialize(
            session_id=session_id,
            id=id,
            investigation_id=investigation_id,
            parameter=parameter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_sample_parameters_id_put_serialize(
        self,
        session_id,
        id,
        investigation_id,
        parameter,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if investigation_id is not None:
            
            _query_params.append(('investigationId', investigation_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if parameter is not None:
            _body_params = parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/catalogue/{sessionId}/sampleParameters/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_samples_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="the name of the instrument or instrument (comma separated)")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        sample_ids: Annotated[Optional[StrictStr], Field(description="Metadata catalogue sample identifiers")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="start date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="end date")] = None,
        dataset_type: Annotated[Optional[StrictStr], Field(description="type of the dataset")] = None,
        having_acquisition_datasets: Annotated[Optional[StrictBool], Field(description="filter on samples having acquisition datasets (false by default)")] = None,
        include_datasets: Annotated[Optional[StrictBool], Field(description="true if the datasets are also loaded (false by default)")] = None,
        nested: Annotated[Optional[StrictBool], Field(description="true if processed datasets will be populated")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="order applied to the sorting (-1 or 1) (ascending or descending)")] = None,
        parameters: Annotated[Optional[StrictStr], Field(description="dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Sample]:
        """Gets samples


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier
        :type investigation_id: str
        :param instrument_name: the name of the instrument or instrument (comma separated)
        :type instrument_name: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param search: text to be used for filtering the entities
        :type search: str
        :param sample_ids: Metadata catalogue sample identifiers
        :type sample_ids: str
        :param start_date: start date
        :type start_date: str
        :param end_date: end date
        :type end_date: str
        :param dataset_type: type of the dataset
        :type dataset_type: str
        :param having_acquisition_datasets: filter on samples having acquisition datasets (false by default)
        :type having_acquisition_datasets: bool
        :param include_datasets: true if the datasets are also loaded (false by default)
        :type include_datasets: bool
        :param nested: true if processed datasets will be populated
        :type nested: bool
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param sort_order: order applied to the sorting (-1 or 1) (ascending or descending)
        :type sort_order: str
        :param parameters: dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details
        :type parameters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_samples_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            limit=limit,
            skip=skip,
            search=search,
            sample_ids=sample_ids,
            start_date=start_date,
            end_date=end_date,
            dataset_type=dataset_type,
            having_acquisition_datasets=having_acquisition_datasets,
            include_datasets=include_datasets,
            nested=nested,
            sort_by=sort_by,
            sort_order=sort_order,
            parameters=parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Sample]",
            '400': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_samples_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="the name of the instrument or instrument (comma separated)")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        sample_ids: Annotated[Optional[StrictStr], Field(description="Metadata catalogue sample identifiers")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="start date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="end date")] = None,
        dataset_type: Annotated[Optional[StrictStr], Field(description="type of the dataset")] = None,
        having_acquisition_datasets: Annotated[Optional[StrictBool], Field(description="filter on samples having acquisition datasets (false by default)")] = None,
        include_datasets: Annotated[Optional[StrictBool], Field(description="true if the datasets are also loaded (false by default)")] = None,
        nested: Annotated[Optional[StrictBool], Field(description="true if processed datasets will be populated")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="order applied to the sorting (-1 or 1) (ascending or descending)")] = None,
        parameters: Annotated[Optional[StrictStr], Field(description="dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Sample]]:
        """Gets samples


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier
        :type investigation_id: str
        :param instrument_name: the name of the instrument or instrument (comma separated)
        :type instrument_name: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param search: text to be used for filtering the entities
        :type search: str
        :param sample_ids: Metadata catalogue sample identifiers
        :type sample_ids: str
        :param start_date: start date
        :type start_date: str
        :param end_date: end date
        :type end_date: str
        :param dataset_type: type of the dataset
        :type dataset_type: str
        :param having_acquisition_datasets: filter on samples having acquisition datasets (false by default)
        :type having_acquisition_datasets: bool
        :param include_datasets: true if the datasets are also loaded (false by default)
        :type include_datasets: bool
        :param nested: true if processed datasets will be populated
        :type nested: bool
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param sort_order: order applied to the sorting (-1 or 1) (ascending or descending)
        :type sort_order: str
        :param parameters: dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details
        :type parameters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_samples_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            limit=limit,
            skip=skip,
            search=search,
            sample_ids=sample_ids,
            start_date=start_date,
            end_date=end_date,
            dataset_type=dataset_type,
            having_acquisition_datasets=having_acquisition_datasets,
            include_datasets=include_datasets,
            nested=nested,
            sort_by=sort_by,
            sort_order=sort_order,
            parameters=parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Sample]",
            '400': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_samples_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="the name of the instrument or instrument (comma separated)")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        sample_ids: Annotated[Optional[StrictStr], Field(description="Metadata catalogue sample identifiers")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="start date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="end date")] = None,
        dataset_type: Annotated[Optional[StrictStr], Field(description="type of the dataset")] = None,
        having_acquisition_datasets: Annotated[Optional[StrictBool], Field(description="filter on samples having acquisition datasets (false by default)")] = None,
        include_datasets: Annotated[Optional[StrictBool], Field(description="true if the datasets are also loaded (false by default)")] = None,
        nested: Annotated[Optional[StrictBool], Field(description="true if processed datasets will be populated")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="order applied to the sorting (-1 or 1) (ascending or descending)")] = None,
        parameters: Annotated[Optional[StrictStr], Field(description="dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets samples


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param investigation_id: Metadata catalogue investigation identifier
        :type investigation_id: str
        :param instrument_name: the name of the instrument or instrument (comma separated)
        :type instrument_name: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param search: text to be used for filtering the entities
        :type search: str
        :param sample_ids: Metadata catalogue sample identifiers
        :type sample_ids: str
        :param start_date: start date
        :type start_date: str
        :param end_date: end date
        :type end_date: str
        :param dataset_type: type of the dataset
        :type dataset_type: str
        :param having_acquisition_datasets: filter on samples having acquisition datasets (false by default)
        :type having_acquisition_datasets: bool
        :param include_datasets: true if the datasets are also loaded (false by default)
        :type include_datasets: bool
        :param nested: true if processed datasets will be populated
        :type nested: bool
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param sort_order: order applied to the sorting (-1 or 1) (ascending or descending)
        :type sort_order: str
        :param parameters: dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details
        :type parameters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_samples_get_serialize(
            session_id=session_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            limit=limit,
            skip=skip,
            search=search,
            sample_ids=sample_ids,
            start_date=start_date,
            end_date=end_date,
            dataset_type=dataset_type,
            having_acquisition_datasets=having_acquisition_datasets,
            include_datasets=include_datasets,
            nested=nested,
            sort_by=sort_by,
            sort_order=sort_order,
            parameters=parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Sample]",
            '400': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_samples_get_serialize(
        self,
        session_id,
        investigation_id,
        instrument_name,
        limit,
        skip,
        search,
        sample_ids,
        start_date,
        end_date,
        dataset_type,
        having_acquisition_datasets,
        include_datasets,
        nested,
        sort_by,
        sort_order,
        parameters,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if investigation_id is not None:
            
            _query_params.append(('investigationId', investigation_id))
            
        if instrument_name is not None:
            
            _query_params.append(('instrumentName', instrument_name))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if skip is not None:
            
            _query_params.append(('skip', skip))
            
        if search is not None:
            
            _query_params.append(('search', search))
            
        if sample_ids is not None:
            
            _query_params.append(('sampleIds', sample_ids))
            
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('endDate', end_date))
            
        if dataset_type is not None:
            
            _query_params.append(('datasetType', dataset_type))
            
        if having_acquisition_datasets is not None:
            
            _query_params.append(('havingAcquisitionDatasets', having_acquisition_datasets))
            
        if include_datasets is not None:
            
            _query_params.append(('includeDatasets', include_datasets))
            
        if nested is not None:
            
            _query_params.append(('nested', nested))
            
        if sort_by is not None:
            
            _query_params.append(('sortBy', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sortOrder', sort_order))
            
        if parameters is not None:
            
            _query_params.append(('parameters', parameters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/samples',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_samples_sample_id_page_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        sample_id: Annotated[StrictStr, Field(description="Metadata catalogue sample identifier")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="the name of the instrument or instrument (comma separated)")] = None,
        sample_ids: Annotated[Optional[StrictStr], Field(description="Metadata catalogue sample identifiers")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="start date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="end date")] = None,
        having_acquisition_datasets: Annotated[Optional[StrictBool], Field(description="filter on samples having acquisition datasets (false by default)")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="order applied to the sorting (-1 or 1) (ascending or descending)")] = None,
        parameters: Annotated[Optional[StrictStr], Field(description="dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Meta:
        """Gets sample page for a given sample


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param sample_id: Metadata catalogue sample identifier (required)
        :type sample_id: str
        :param investigation_id: Metadata catalogue investigation identifier
        :type investigation_id: str
        :param instrument_name: the name of the instrument or instrument (comma separated)
        :type instrument_name: str
        :param sample_ids: Metadata catalogue sample identifiers
        :type sample_ids: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param search: text to be used for filtering the entities
        :type search: str
        :param start_date: start date
        :type start_date: str
        :param end_date: end date
        :type end_date: str
        :param having_acquisition_datasets: filter on samples having acquisition datasets (false by default)
        :type having_acquisition_datasets: bool
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param sort_order: order applied to the sorting (-1 or 1) (ascending or descending)
        :type sort_order: str
        :param parameters: dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details
        :type parameters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_samples_sample_id_page_get_serialize(
            session_id=session_id,
            sample_id=sample_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            sample_ids=sample_ids,
            limit=limit,
            skip=skip,
            search=search,
            start_date=start_date,
            end_date=end_date,
            having_acquisition_datasets=having_acquisition_datasets,
            sort_by=sort_by,
            sort_order=sort_order,
            parameters=parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Meta",
            '400': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_samples_sample_id_page_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        sample_id: Annotated[StrictStr, Field(description="Metadata catalogue sample identifier")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="the name of the instrument or instrument (comma separated)")] = None,
        sample_ids: Annotated[Optional[StrictStr], Field(description="Metadata catalogue sample identifiers")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="start date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="end date")] = None,
        having_acquisition_datasets: Annotated[Optional[StrictBool], Field(description="filter on samples having acquisition datasets (false by default)")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="order applied to the sorting (-1 or 1) (ascending or descending)")] = None,
        parameters: Annotated[Optional[StrictStr], Field(description="dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Meta]:
        """Gets sample page for a given sample


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param sample_id: Metadata catalogue sample identifier (required)
        :type sample_id: str
        :param investigation_id: Metadata catalogue investigation identifier
        :type investigation_id: str
        :param instrument_name: the name of the instrument or instrument (comma separated)
        :type instrument_name: str
        :param sample_ids: Metadata catalogue sample identifiers
        :type sample_ids: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param search: text to be used for filtering the entities
        :type search: str
        :param start_date: start date
        :type start_date: str
        :param end_date: end date
        :type end_date: str
        :param having_acquisition_datasets: filter on samples having acquisition datasets (false by default)
        :type having_acquisition_datasets: bool
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param sort_order: order applied to the sorting (-1 or 1) (ascending or descending)
        :type sort_order: str
        :param parameters: dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details
        :type parameters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_samples_sample_id_page_get_serialize(
            session_id=session_id,
            sample_id=sample_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            sample_ids=sample_ids,
            limit=limit,
            skip=skip,
            search=search,
            start_date=start_date,
            end_date=end_date,
            having_acquisition_datasets=having_acquisition_datasets,
            sort_by=sort_by,
            sort_order=sort_order,
            parameters=parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Meta",
            '400': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_samples_sample_id_page_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        sample_id: Annotated[StrictStr, Field(description="Metadata catalogue sample identifier")],
        investigation_id: Annotated[Optional[StrictStr], Field(description="Metadata catalogue investigation identifier")] = None,
        instrument_name: Annotated[Optional[StrictStr], Field(description="the name of the instrument or instrument (comma separated)")] = None,
        sample_ids: Annotated[Optional[StrictStr], Field(description="Metadata catalogue sample identifiers")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="limit the number of entities retrieved")] = None,
        skip: Annotated[Optional[StrictStr], Field(description="the number of entities that will be skipped")] = None,
        search: Annotated[Optional[StrictStr], Field(description="text to be used for filtering the entities")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="start date")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="end date")] = None,
        having_acquisition_datasets: Annotated[Optional[StrictBool], Field(description="filter on samples having acquisition datasets (false by default)")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="field to be sorted by")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="order applied to the sorting (-1 or 1) (ascending or descending)")] = None,
        parameters: Annotated[Optional[StrictStr], Field(description="dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets sample page for a given sample


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param sample_id: Metadata catalogue sample identifier (required)
        :type sample_id: str
        :param investigation_id: Metadata catalogue investigation identifier
        :type investigation_id: str
        :param instrument_name: the name of the instrument or instrument (comma separated)
        :type instrument_name: str
        :param sample_ids: Metadata catalogue sample identifiers
        :type sample_ids: str
        :param limit: limit the number of entities retrieved
        :type limit: str
        :param skip: the number of entities that will be skipped
        :type skip: str
        :param search: text to be used for filtering the entities
        :type search: str
        :param start_date: start date
        :type start_date: str
        :param end_date: end date
        :type end_date: str
        :param having_acquisition_datasets: filter on samples having acquisition datasets (false by default)
        :type having_acquisition_datasets: bool
        :param sort_by: field to be sorted by
        :type sort_by: str
        :param sort_order: order applied to the sorting (-1 or 1) (ascending or descending)
        :type sort_order: str
        :param parameters: dataset or investigation parameters filter list, separated by comma. A filter is composed by the parameter's name, and optionally an operator and a value, separated by ~. The accepted list of operators is [eq, like, gt, gteq, lt, lteq, in]. See icat+ documentation for more details
        :type parameters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_samples_sample_id_page_get_serialize(
            session_id=session_id,
            sample_id=sample_id,
            investigation_id=investigation_id,
            instrument_name=instrument_name,
            sample_ids=sample_ids,
            limit=limit,
            skip=skip,
            search=search,
            start_date=start_date,
            end_date=end_date,
            having_acquisition_datasets=having_acquisition_datasets,
            sort_by=sort_by,
            sort_order=sort_order,
            parameters=parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Meta",
            '400': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_samples_sample_id_page_get_serialize(
        self,
        session_id,
        sample_id,
        investigation_id,
        instrument_name,
        sample_ids,
        limit,
        skip,
        search,
        start_date,
        end_date,
        having_acquisition_datasets,
        sort_by,
        sort_order,
        parameters,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        if sample_id is not None:
            _path_params['sampleId'] = sample_id
        # process the query parameters
        if investigation_id is not None:
            
            _query_params.append(('investigationId', investigation_id))
            
        if instrument_name is not None:
            
            _query_params.append(('instrumentName', instrument_name))
            
        if sample_ids is not None:
            
            _query_params.append(('sampleIds', sample_ids))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if skip is not None:
            
            _query_params.append(('skip', skip))
            
        if search is not None:
            
            _query_params.append(('search', search))
            
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('endDate', end_date))
            
        if having_acquisition_datasets is not None:
            
            _query_params.append(('havingAcquisitionDatasets', having_acquisition_datasets))
            
        if sort_by is not None:
            
            _query_params.append(('sortBy', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sortOrder', sort_order))
            
        if parameters is not None:
            
            _query_params.append(('parameters', parameters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/samples/{sampleId}/page',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_samples_sample_id_sample_parameters_post(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        sample_id: Annotated[StrictStr, Field(description="Metadata catalogue sample identifier")],
        investigation_id: Annotated[StrictStr, Field(description="identifier of the investigation")],
        parameter: Annotated[Optional[Parameter], Field(description="parameter to update")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Create sample parameter (description only if it is an editable sample, or sample comment only)


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param sample_id: Metadata catalogue sample identifier (required)
        :type sample_id: str
        :param investigation_id: identifier of the investigation (required)
        :type investigation_id: str
        :param parameter: parameter to update
        :type parameter: Parameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_samples_sample_id_sample_parameters_post_serialize(
            session_id=session_id,
            sample_id=sample_id,
            investigation_id=investigation_id,
            parameter=parameter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_samples_sample_id_sample_parameters_post_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        sample_id: Annotated[StrictStr, Field(description="Metadata catalogue sample identifier")],
        investigation_id: Annotated[StrictStr, Field(description="identifier of the investigation")],
        parameter: Annotated[Optional[Parameter], Field(description="parameter to update")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Create sample parameter (description only if it is an editable sample, or sample comment only)


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param sample_id: Metadata catalogue sample identifier (required)
        :type sample_id: str
        :param investigation_id: identifier of the investigation (required)
        :type investigation_id: str
        :param parameter: parameter to update
        :type parameter: Parameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_samples_sample_id_sample_parameters_post_serialize(
            session_id=session_id,
            sample_id=sample_id,
            investigation_id=investigation_id,
            parameter=parameter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_samples_sample_id_sample_parameters_post_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        sample_id: Annotated[StrictStr, Field(description="Metadata catalogue sample identifier")],
        investigation_id: Annotated[StrictStr, Field(description="identifier of the investigation")],
        parameter: Annotated[Optional[Parameter], Field(description="parameter to update")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create sample parameter (description only if it is an editable sample, or sample comment only)


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param sample_id: Metadata catalogue sample identifier (required)
        :type sample_id: str
        :param investigation_id: identifier of the investigation (required)
        :type investigation_id: str
        :param parameter: parameter to update
        :type parameter: Parameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_samples_sample_id_sample_parameters_post_serialize(
            session_id=session_id,
            sample_id=sample_id,
            investigation_id=investigation_id,
            parameter=parameter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': "str",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_samples_sample_id_sample_parameters_post_serialize(
        self,
        session_id,
        sample_id,
        investigation_id,
        parameter,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        if sample_id is not None:
            _path_params['sampleId'] = sample_id
        # process the query parameters
        if investigation_id is not None:
            
            _query_params.append(('investigationId', investigation_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if parameter is not None:
            _body_params = parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/catalogue/{sessionId}/samples/{sampleId}/sampleParameters',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_session_id_user_get(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[User]:
        """Get user list of ICAT (Restricted to administrators)


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_user_get_serialize(
            session_id=session_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[User]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_session_id_user_get_with_http_info(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[User]]:
        """Get user list of ICAT (Restricted to administrators)


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_user_get_serialize(
            session_id=session_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[User]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_session_id_user_get_without_preload_content(
        self,
        session_id: Annotated[StrictStr, Field(description="session identifier provided by the metadata catalogue")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get user list of ICAT (Restricted to administrators)


        :param session_id: session identifier provided by the metadata catalogue (required)
        :type session_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_session_id_user_get_serialize(
            session_id=session_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[User]",
            '401': "str",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_session_id_user_get_serialize(
        self,
        session_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/{sessionId}/user',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def catalogue_techniques_get(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Technique]:
        """Returns all techniques

        Return a list of techniques that are registered in ICAT

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_techniques_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Technique]",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def catalogue_techniques_get_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Technique]]:
        """Returns all techniques

        Return a list of techniques that are registered in ICAT

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_techniques_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Technique]",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def catalogue_techniques_get_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns all techniques

        Return a list of techniques that are registered in ICAT

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._catalogue_techniques_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Technique]",
            '500': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _catalogue_techniques_get_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/catalogue/techniques',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


