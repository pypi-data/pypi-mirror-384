# vector.pyi - Type stub file
from __future__ import annotations
import numpy as np
from typing import (
    List,
    Tuple,
    Union,
    Iterator,
    Iterable,
    TypeVar,
    Generic,
    Any,
    TYPE_CHECKING,
    Type,
    overload,
    Sequence,
)
from abc import ABC

if TYPE_CHECKING:
    from .matrix import Matrix

T = TypeVar("T", bound="Vector")
NumT = TypeVar("NumT", int, float)  # Numeric type variable
Number = Union[int, float]

class Vector(Generic[T], Sequence[float], ABC):
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __iter__(self) -> Iterator[float]: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> float: ...
    def __contains__(self, item) -> bool: ...
    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, ...]: ...
    def to_numpy(self) -> np.ndarray: ...
    def to_bytes(self) -> bytes: ...
    @classmethod
    def from_numpy(cls: Type[T], array: np.ndarray) -> T: ...
    @property
    def magnitude(self) -> float: ...
    def normalize(self: T) -> T: ...
    @property
    def normalized(self: T) -> T: ...
    def distance_to(self, other: T) -> float: ...
    def dot(self, other: T) -> float: ...
    def reverse(self: T) -> T: ...
    @property
    def reversed(self: T) -> T: ...

# Generic base that both Vector2 and IVector2 can use
class Vector2(Vector):
    _numeric_type: Type[float]

    # Constructors
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, value: Number) -> None: ...
    @overload
    def __init__(self, x: Number, y: Number) -> None: ...
    @overload
    def __init__(self, vec: Union[Vector2, Vector3, Vector4]) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[Number]) -> None: ...
    @overload
    def __init__(
        self, vec: Union[Vector2, Vector3, Vector4], *rest: Number
    ) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[Number], *rest: Number) -> None: ...
    def __init__(self, *args) -> None: ...

    # Properties
    @property
    def x(self) -> float: ...
    @property
    def y(self) -> float: ...
    @property
    def xy(self) -> Vector2: ...
    @x.setter
    def x(self, value: float) -> None: ...
    @y.setter
    def y(self, value: float) -> None: ...
    @xy.setter
    def xy(self, values: Iterable[Number]) -> None: ...

    # Attribute overrides
    def __getattr__(
        self, name: str
    ) -> Union[float, Vector2, Vector3, Vector4, Tuple[float, ...]]: ...
    def __setattr__(self, name: str, value: float) -> None: ...

    # Iteration & indexing
    def __iter__(self) -> Iterator[float]: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: float) -> None: ...

    # Arithmetic
    def __add__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __radd__(self, other: Number) -> Vector2: ...
    def __sub__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __rsub__(self, other: Number) -> Vector2: ...
    def __mul__(self, other: Union[Vector2, Number, Matrix]) -> Union[Vector2, Any]: ...
    def __rmul__(self, other: Number) -> Vector2: ...
    def __truediv__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __rtruediv__(self, other: Number) -> Vector2: ...
    def __floordiv__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __rfloordiv__(self, other: Number) -> Vector2: ...
    def __mod__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __rmod__(self, other: Number) -> Vector2: ...
    def __pow__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __rpow__(self, other: Number) -> Vector2: ...

    # In-place arithmetic
    def __iadd__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __isub__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __imul__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __itruediv__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __ifloordiv__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __imod__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __ipow__(self, other: Union[Vector2, Number]) -> Vector2: ...

    # Comparisons
    def __eq__(self, other: Any) -> bool: ...
    def __lt__(self, other: Union[Vector2, Number]) -> bool: ...
    def __gt__(self, other: Union[Vector2, Number]) -> bool: ...
    def __le__(self, other: Union[Vector2, Number]) -> bool: ...
    def __ge__(self, other: Union[Vector2, Number]) -> bool: ...
    def __hash__(self) -> int: ...

class IVector2(Vector2):
    _numeric_type: Type[int]

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, value: Number) -> None: ...
    @overload
    def __init__(self, x: Number, y: Number) -> None: ...
    @overload
    def __init__(
        self, vec: Union[IVector2, IVector3, IVector4, Vector2, Vector3, Vector4]
    ) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[Number]) -> None: ...
    @overload
    def __init__(
        self,
        vec: Union[IVector2, IVector3, IVector4, Vector2, Vector3, Vector4],
        *rest: Number,
    ) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[Number], *rest: Number) -> None: ...
    def __init__(self, *args) -> None: ...
    @property
    def x(self) -> int: ...
    @x.setter
    def x(self, value: int) -> None: ...
    @property
    def y(self) -> int: ...
    @y.setter
    def y(self, value: int) -> None: ...
    @property
    def xy(self) -> IVector2: ...
    @xy.setter
    def xy(self, values: Iterable[Number]) -> None: ...
    def __getattr__(
        self, name: str
    ) -> Union[int, IVector2, IVector3, IVector4, Tuple[int, ...]]: ...
    def __getitem__(self, index: int) -> int: ...
    def __iter__(self) -> Iterator[int]: ...

    # Arithmetic returns IVector2
    def __add__(self, other: Union[IVector2, Number]) -> IVector2: ...
    def __radd__(self, other: Number) -> IVector2: ...
    def __sub__(self, other: Union[IVector2, Number]) -> IVector2: ...
    def __rsub__(self, other: Number) -> IVector2: ...
    def __mul__(
        self, other: Union[IVector2, Number, Matrix]
    ) -> Union[IVector2, Any]: ...
    def __rmul__(self, other: Number) -> IVector2: ...
    def __truediv__(self, other: Union[IVector2, Number]) -> IVector2: ...
    def __rtruediv__(self, other: Number) -> IVector2: ...
    def __floordiv__(self, other: Union[IVector2, Number]) -> IVector2: ...
    def __rfloordiv__(self, other: Number) -> IVector2: ...
    def __mod__(self, other: Union[IVector2, Number]) -> IVector2: ...
    def __rmod__(self, other: Number) -> IVector2: ...
    def __pow__(self, other: Union[IVector2, Number]) -> IVector2: ...
    def __rpow__(self, other: Number) -> IVector2: ...
    def __iadd__(self, other: Union[IVector2, Number]) -> IVector2: ...
    def __isub__(self, other: Union[IVector2, Number]) -> IVector2: ...
    def __imul__(self, other: Union[IVector2, Number]) -> IVector2: ...
    def __itruediv__(self, other: Union[IVector2, Number]) -> IVector2: ...
    def __ifloordiv__(self, other: Union[IVector2, Number]) -> IVector2: ...
    def __imod__(self, other: Union[IVector2, Number]) -> IVector2: ...
    def __ipow__(self, other: Union[IVector2, Number]) -> IVector2: ...

class Vector3(Vector["Vector3"]):
    _numeric_type: Type[float]

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, value: Number) -> None: ...
    @overload
    def __init__(self, x: Number, y: Number, z: Number) -> None: ...
    @overload
    def __init__(self, vec: Union[Vector2, Vector3, Vector4]) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[Number]) -> None: ...
    @overload
    def __init__(
        self, vec: Union[Vector2, Vector3, Vector4], *rest: Number
    ) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[Number], *rest: Number) -> None: ...
    @overload
    def __init__(
        self,
        vec1: Union[Vector2, Vector3, Vector4],
        vec2: Union[Vector2, Vector3, Vector4],
        *rest: Number,
    ) -> None: ...
    def __init__(self, *args) -> None: ...
    @property
    def x(self) -> float: ...
    @property
    def y(self) -> float: ...
    @property
    def z(self) -> float: ...
    @property
    def xyz(self) -> Vector3: ...
    @x.setter
    def x(self, value: float) -> None: ...
    @y.setter
    def y(self, value: float) -> None: ...
    @z.setter
    def z(self, value: float) -> None: ...
    @xyz.setter
    def xyz(self, values: Iterable) -> None: ...
    def __getattr__(
        self, name: str
    ) -> Union[float, Vector2, Vector3, Vector4, Tuple[float, ...]]: ...
    def __setattr__(self, name: str, value: float) -> None: ...
    def __iter__(self) -> Iterator[float]: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: float) -> None: ...

    # Arithmetic operations
    def __add__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __radd__(self, other: Number) -> Vector3: ...
    def __sub__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __rsub__(self, other: Number) -> Vector3: ...
    def __mul__(self, other: Union[Vector3, Number, Matrix]) -> Union[Vector3, Any]: ...
    def __rmul__(self, other: Number) -> Vector3: ...
    def __truediv__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __rtruediv__(self, other: Number) -> Vector3: ...
    def __floordiv__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __rfloordiv__(self, other: Number) -> Vector3: ...
    def __mod__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __rmod__(self, other: Number) -> Vector3: ...
    def __pow__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __rpow__(self, other: Number) -> Vector3: ...

    # In-place operations
    def __iadd__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __isub__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __imul__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __itruediv__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __ifloordiv__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __imod__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __ipow__(self, other: Union[Vector3, Number]) -> Vector3: ...

    # Comparison
    def __eq__(self, other: Any) -> bool: ...
    def __lt__(self, other: Union[Vector3, Number]) -> bool: ...
    def __gt__(self, other: Union[Vector3, Number]) -> bool: ...
    def __le__(self, other: Union[Vector3, Number]) -> bool: ...
    def __ge__(self, other: Union[Vector3, Number]) -> bool: ...
    def __hash__(self) -> int: ...
    def cross(self, other: Vector3) -> Vector3: ...

class IVector3(Vector3):
    _numeric_type: Type[int]

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, value: Number) -> None: ...
    @overload
    def __init__(self, x: Number, y: Number, z: Number) -> None: ...
    @overload
    def __init__(
        self, vec: Union[IVector2, IVector3, IVector4, Vector2, Vector3, Vector4]
    ) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[Number]) -> None: ...
    @overload
    def __init__(
        self,
        vec: Union[IVector2, IVector3, IVector4, Vector2, Vector3, Vector4],
        *rest: Number,
    ) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[Number], *rest: Number) -> None: ...
    @overload
    def __init__(
        self,
        vec1: Union[IVector2, IVector3, IVector4, Vector2, Vector3, Vector4],
        vec2: Union[IVector2, IVector3, IVector4, Vector2, Vector3, Vector4],
        *rest: Number,
    ) -> None: ...
    @property
    def x(self) -> int: ...
    @x.setter
    def x(self, value: int) -> None: ...
    @property
    def y(self) -> int: ...
    @y.setter
    def y(self, value: int) -> None: ...
    @property
    def z(self) -> int: ...
    @z.setter
    def z(self, value: int) -> None: ...
    @property
    def xyz(self) -> IVector3: ...
    @xyz.setter
    def xyz(self, values: Iterable[Number]) -> None: ...
    def __getattr__(
        self, name: str
    ) -> Union[int, IVector2, IVector3, IVector4, Tuple[int, ...]]: ...
    def __getitem__(self, index: int) -> int: ...
    def __iter__(self) -> Iterator[int]: ...
    def __add__(self, other: Union[IVector3, Number]) -> IVector3: ...
    def __radd__(self, other: Number) -> IVector3: ...
    def __sub__(self, other: Union[IVector3, Number]) -> IVector3: ...
    def __rsub__(self, other: Number) -> IVector3: ...
    def __mul__(
        self, other: Union[IVector3, Number, Matrix]
    ) -> Union[IVector3, Any]: ...
    def __rmul__(self, other: Number) -> IVector3: ...
    def __truediv__(self, other: Union[IVector3, Number]) -> IVector3: ...
    def __rtruediv__(self, other: Number) -> IVector3: ...
    def __floordiv__(self, other: Union[IVector3, Number]) -> IVector3: ...
    def __rfloordiv__(self, other: Number) -> IVector3: ...
    def __mod__(self, other: Union[IVector3, Number]) -> IVector3: ...
    def __rmod__(self, other: Number) -> IVector3: ...
    def __pow__(self, other: Union[IVector3, Number]) -> IVector3: ...
    def __rpow__(self, other: Number) -> IVector3: ...
    def __iadd__(self, other: Union[IVector3, Number]) -> IVector3: ...
    def __isub__(self, other: Union[IVector3, Number]) -> IVector3: ...
    def __imul__(self, other: Union[IVector3, Number]) -> IVector3: ...
    def __itruediv__(self, other: Union[IVector3, Number]) -> IVector3: ...
    def __ifloordiv__(self, other: Union[IVector3, Number]) -> IVector3: ...
    def __imod__(self, other: Union[IVector3, Number]) -> IVector3: ...
    def __ipow__(self, other: Union[IVector3, Number]) -> IVector3: ...
    def cross(self, other: IVector3) -> IVector3: ...

class Vector4(Vector["Vector4"]):
    _numeric_type: Type[float]

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, value: Number) -> None: ...
    @overload
    def __init__(self, x: Number, y: Number, z: Number, w: Number) -> None: ...
    @overload
    def __init__(self, vec: Union[Vector2, Vector3, Vector4]) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[Number]) -> None: ...
    @overload
    def __init__(
        self, vec: Union[Vector2, Vector3, Vector4], *rest: Number
    ) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[Number], *rest: Number) -> None: ...
    @overload
    def __init__(
        self,
        vec1: Union[Vector2, Vector3, Vector4],
        vec2: Union[Vector2, Vector3, Vector4],
        *rest: Number,
    ) -> None: ...
    def __init__(self, *args) -> None: ...
    @property
    def x(self) -> float: ...
    @property
    def y(self) -> float: ...
    @property
    def z(self) -> float: ...
    @property
    def w(self) -> float: ...
    @property
    def xyzw(self) -> Vector4: ...
    @x.setter
    def x(self, value: float) -> None: ...
    @y.setter
    def y(self, value: float) -> None: ...
    @z.setter
    def z(self, value: float) -> None: ...
    @w.setter
    def w(self, value: float) -> None: ...
    @xyzw.setter
    def xyzw(self, values: Iterable) -> None: ...
    def __getattr__(
        self, name: str
    ) -> Union[float, Vector2, Vector3, Vector4, Tuple[float, ...]]: ...
    def __setattr__(self, name: str, value: float) -> None: ...
    def __iter__(self) -> Iterator[float]: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: float) -> None: ...

    # Arithmetic operations
    def __add__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __radd__(self, other: Number) -> Vector4: ...
    def __sub__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __rsub__(self, other: Number) -> Vector4: ...
    def __mul__(self, other: Union[Vector4, Number, Matrix]) -> Union[Vector4, Any]: ...
    def __rmul__(self, other: Number) -> Vector4: ...
    def __truediv__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __rtruediv__(self, other: Number) -> Vector4: ...
    def __floordiv__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __rfloordiv__(self, other: Number) -> Vector4: ...
    def __mod__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __rmod__(self, other: Number) -> Vector4: ...
    def __pow__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __rpow__(self, other: Number) -> Vector4: ...

    # In-place operations
    def __iadd__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __isub__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __imul__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __itruediv__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __ifloordiv__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __imod__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __ipow__(self, other: Union[Vector4, Number]) -> Vector4: ...

    # Comparison
    def __eq__(self, other: Any) -> bool: ...
    def __lt__(self, other: Union[Vector4, Number]) -> bool: ...
    def __gt__(self, other: Union[Vector4, Number]) -> bool: ...
    def __le__(self, other: Union[Vector4, Number]) -> bool: ...
    def __ge__(self, other: Union[Vector4, Number]) -> bool: ...
    def __hash__(self) -> int: ...

class IVector4(Vector4):
    _numeric_type: Type[int]

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, value: Number) -> None: ...
    @overload
    def __init__(self, x: Number, y: Number, z: Number, w: Number) -> None: ...
    @overload
    def __init__(
        self, vec: Union[IVector2, IVector3, IVector4, Vector2, Vector3, Vector4]
    ) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[Number]) -> None: ...
    @overload
    def __init__(
        self,
        vec: Union[IVector2, IVector3, IVector4, Vector2, Vector3, Vector4],
        *rest: Number,
    ) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[Number], *rest: Number) -> None: ...
    @overload
    def __init__(
        self,
        vec1: Union[IVector2, IVector3, IVector4, Vector2, Vector3, Vector4],
        vec2: Union[IVector2, IVector3, IVector4, Vector2, Vector3, Vector4],
        *rest: Number,
    ) -> None: ...
    @property
    def x(self) -> int: ...
    @x.setter
    def x(self, value: int) -> None: ...
    @property
    def y(self) -> int: ...
    @y.setter
    def y(self, value: int) -> None: ...
    @property
    def z(self) -> int: ...
    @z.setter
    def z(self, value: int) -> None: ...
    @property
    def w(self) -> int: ...
    @w.setter
    def w(self, value: int) -> None: ...
    @property
    def xyzw(self) -> IVector4: ...
    @xyzw.setter
    def xyzw(self, values: Iterable[Number]) -> None: ...
    def __getattr__(
        self, name: str
    ) -> Union[int, IVector2, IVector3, IVector4, Tuple[int, ...]]: ...
    def __getitem__(self, index: int) -> int: ...
    def __iter__(self) -> Iterator[int]: ...
    def __add__(self, other: Union[IVector4, Number]) -> IVector4: ...
    def __radd__(self, other: Number) -> IVector4: ...
    def __sub__(self, other: Union[IVector4, Number]) -> IVector4: ...
    def __rsub__(self, other: Number) -> IVector4: ...
    def __mul__(
        self, other: Union[IVector4, Number, Matrix]
    ) -> Union[IVector4, Any]: ...
    def __rmul__(self, other: Number) -> IVector4: ...
    def __truediv__(self, other: Union[IVector4, Number]) -> IVector4: ...
    def __rtruediv__(self, other: Number) -> IVector4: ...
    def __floordiv__(self, other: Union[IVector4, Number]) -> IVector4: ...
    def __rfloordiv__(self, other: Number) -> IVector4: ...
    def __mod__(self, other: Union[IVector4, Number]) -> IVector4: ...
    def __rmod__(self, other: Number) -> IVector4: ...
    def __pow__(self, other: Union[IVector4, Number]) -> IVector4: ...
    def __rpow__(self, other: Number) -> IVector4: ...
    def __iadd__(self, other: Union[IVector4, Number]) -> IVector4: ...
    def __isub__(self, other: Union[IVector4, Number]) -> IVector4: ...
    def __imul__(self, other: Union[IVector4, Number]) -> IVector4: ...
    def __itruediv__(self, other: Union[IVector4, Number]) -> IVector4: ...
    def __ifloordiv__(self, other: Union[IVector4, Number]) -> IVector4: ...
    def __imod__(self, other: Union[IVector4, Number]) -> IVector4: ...
    def __ipow__(self, other: Union[IVector4, Number]) -> IVector4: ...

# Aliases
Vec2 = Vector2
vec2 = Vector2
Vec3 = Vector3
vec3 = Vector3
Vec4 = Vector4
vec4 = Vector4

IVec2 = IVector2
ivec2 = IVector2
IVec3 = IVector3
ivec3 = IVector3
IVec4 = IVector4
ivec4 = IVector4
