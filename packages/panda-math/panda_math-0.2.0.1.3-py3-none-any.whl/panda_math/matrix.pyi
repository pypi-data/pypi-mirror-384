from typing import (
    List,
    Union,
    Optional,
    Any,
    Iterator,
    TypeVar,
    Tuple,
    Callable,
    overload,
    Sequence,
    TYPE_CHECKING,
)
import numpy as np

Number = Union[int, float]
M = TypeVar("M", bound="Matrix")

if TYPE_CHECKING:
    from .vector import Vector2, Vector3, Vector4

class Matrix:
    def __init__(
        self,
        data: Union[np.ndarray, Sequence[Sequence[Number]], None] = None,
        rows: int = 2,
        cols: int = 2,
    ) -> None: ...
    data : List[List[float]]
    rows : int
    cols : int
    
    
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    
    @overload
    def __getitem__(self, key: int) -> Sequence[Number]: ...
    @overload
    def __getitem__(self, key: Tuple[int, int]) -> Number: ...
    def __getitem__(self, key): ...

    @overload
    def __setitem__(self, key: int, value: Sequence[Number]): ...
    @overload
    def __setitem__(self, key: Tuple[int, int], value: Number): ...
    def __setitem__(self, key, value): ...
    
    def __iter__(self) -> Iterator[List[Number]]: ...
    def __len__(self) -> int: ...
    def __add__(self, other: Union["Matrix", Number]) -> "Matrix": ...
    def __radd__(self, other: Number) -> "Matrix": ...
    def __sub__(self, other: Union["Matrix", Number]) -> "Matrix": ...
    def __rsub__(self, other: Number) -> "Matrix": ...
    
    @overload
    def __mul__(self, other: "Matrix") -> "Matrix": ...
    @overload
    def __mul__(self, other: "Vector2") -> "Vector2": ...
    @overload
    def __mul__(self, other: "Vector3") -> "Vector3": ...
    @overload
    def __mul__(self, other: "Vector4") -> "Vector4": ...
    @overload
    def __mul__(self, other: Number) -> "Matrix": ...
    def __mul__(self, other): ...
    
    def __rmul__(self, other: Number) -> "Matrix": ...
    def __truediv__(self, other: Number) -> "Matrix": ...
    def __eq__(self, other: Any) -> bool: ...
    def transpose(self) -> "Matrix": ...
    def determinant(self) -> float: ...
    def cofactor(self, row: int, col: int) -> float: ...
    def minor(self, row: int, col: int) -> "Matrix": ...
    def adjugate(self) -> "Matrix": ...
    def inverse(self) -> "Matrix": ...
    def is_singular(self) -> bool: ...
    def is_symmetric(self) -> bool: ...
    def is_orthogonal(self) -> bool: ...
    def trace(self) -> float: ...
    def row(self, i: int) -> Union[List[Number], "Vector2", "Vector3", "Vector4"]: ...
    def col(self, j: int) -> Union[List[Number], "Vector2", "Vector3", "Vector4"]: ...
    def to_numpy(self) -> np.ndarray: ...
    def to_bytes(self, format: str = "float32", order: str = "column"): ...
    @classmethod
    def from_numpy(cls, array: np.ndarray) -> "Matrix": ...
    @classmethod
    def identity(cls, size: int) -> "Matrix": ...
    @classmethod
    def from_rows(cls, *rows: Sequence[Number]) -> "Matrix": ...
    @classmethod
    def from_cols(cls, *cols: Sequence[Number]) -> "Matrix": ...
    def apply(self, func: Callable[[float], float]) -> "Matrix": ...
    def row_echelon_form(self) -> "Matrix": ...
    def reduced_row_echelon_form(self) -> "Matrix": ...
    def rank(self) -> int: ...
    def lu_decomposition(self) -> Tuple["Matrix", "Matrix"]: ...
    def eigenvectors(
        self, max_iterations: int = 100, tolerance: float = 1e-10
    ) -> Tuple[List[float], List["Matrix"]]: ...

# ---------------- 2x2, 3x3, 4x4 factory functions ----------------
def mat2(*args: Number) -> Matrix: ...
def mat3(*args: Number) -> Matrix: ...
def mat4(*args: Number) -> Matrix: ...

# ---------------- 2D transforms ----------------
def rotation_matrix_2d(angle_radians: float) -> Matrix: ...
def scaling_matrix_2d(sx: float, sy: Optional[float] = None) -> Matrix: ...
def translation_vector_2d(tx: float, ty: float) -> "Vector2": ...
def transform_point_2d(
    point: Union[List[float], "Vector2"],
    matrix: Matrix,
    translation: Optional["Vector2"] = None,
) -> Union[List[float], "Vector2"]: ...
def shear_matrix_2d(shx: float = 0.0, shy: float = 0.0) -> Matrix: ...
def reflection_matrix_2d(axis: str = "x") -> Matrix: ...

# ---------------- 3D transforms ----------------
def rotation_matrix_3d_x(angle_radians: float) -> Matrix: ...
def rotation_matrix_3d_y(angle_radians: float) -> Matrix: ...
def rotation_matrix_3d_z(angle_radians: float) -> Matrix: ...
def rotation_matrix_3d(axis: str, angle_radians: float) -> Matrix: ...
def rotation_matrix_3d_arbitrary(
    axis: Union[List[float], "Vector3"], angle_radians: float
) -> Matrix: ...
def scaling_matrix_3d(
    sx: float, sy: Optional[float] = None, sz: Optional[float] = None
) -> Matrix: ...
def translation_vector_3d(tx: float, ty: float, tz: float) -> "Vector3": ...
def transform_point_3d(
    point: Union[List[float], "Vector3"],
    matrix: Matrix,
    translation: Optional["Vector3"] = None,
) -> Union[List[float], "Vector3"]: ...
def shear_matrix_3d(
    xy: float = 0.0,
    xz: float = 0.0,
    yx: float = 0.0,
    yz: float = 0.0,
    zx: float = 0.0,
    zy: float = 0.0,
) -> Matrix: ...
def reflection_matrix_3d(plane: str = "xy") -> Matrix: ...

# ---------------- 4D / homogeneous transforms ----------------
def translation_matrix_4d(tx: float, ty: float, tz: float) -> Matrix: ...
def scaling_matrix_4d(
    sx: float, sy: Optional[float] = None, sz: Optional[float] = None
) -> Matrix: ...
def rotation_matrix_4d_x(angle_radians: float) -> Matrix: ...
def rotation_matrix_4d_y(angle_radians: float) -> Matrix: ...
def rotation_matrix_4d_z(angle_radians: float) -> Matrix: ...
def transform_point_homogeneous(
    point: Union[List[float], "Vector4"], transform_matrix: Matrix
) -> Union[List[float], "Vector4"]: ...
def perspective_projection_matrix(
    fov: float, aspect: float, near: float, far: float
) -> Matrix: ...
def orthographic_projection_matrix(
    left: float, right: float, bottom: float, top: float, near: float, far: float
) -> Matrix: ...
def look_at_matrix(
    eye: Union[List[float], "Vector3"],
    target: Union[List[float], "Vector3"],
    up: Union[List[float], "Vector3"],
) -> Matrix: ...
def interpolate_matrices(matrix_a: Matrix, matrix_b: Matrix, t: float) -> Matrix: ...

IDENTITY_2D : Matrix
IDENTITY_3D : Matrix
IDENTITY_4D : Matrix