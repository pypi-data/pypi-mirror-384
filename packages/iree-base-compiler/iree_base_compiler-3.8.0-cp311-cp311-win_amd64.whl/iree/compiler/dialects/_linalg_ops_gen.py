
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "linalg"

@_ods_cext.register_operation(_Dialect)
class AbsOp(_ods_ir.OpView):
  r"""
  No numeric casting is performed on the input operand.
  """

  OPERATION_NAME = "linalg.abs"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def abs(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, AbsOp]:
  op = AbsOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class AddOp(_ods_ir.OpView):
  r"""
  The shapes and element types must be identical. The appropriate casts,
  broadcasts and reductions should be done previously to calling this op.
  
  This means reduction/broadcast/element cast semantics is explicit. Further
  passes can take that into account when lowering this code. For example,
  a `linalg.broadcast` + `linalg.add` sequence can be lowered to a
  `linalg.generic` with different affine maps for the two operands.
  """

  OPERATION_NAME = "linalg.add"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def add(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, AddOp]:
  op = AddOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class BatchMatmulOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
      them to the same data type as the accumulator/output.
  
      Broadcast and Transpose semantics can be appiled by specifying the explicit attribute
      'indexing_maps' as shown below. This is a list attribute, so must include maps for all
      arguments if specified.
  
      Example Transpose:
      ```mlir
      linalg.batch_matmul
          indexing_maps = [affine_map<(batch, m, n, k) -> (batch, k, m)>, // transpose
                           affine_map<(batch, m, n, k) -> (batch, k, n)>,
                           affine_map<(batch, m, n, k) -> (batch, m, n)>]
          ins(%arg0, %arg1 : memref<2x5x3xf32>,memref<2x5x7xf32>)
          outs(%arg2: memref<2x3x7xf32>)
      ```
  
      Example Broadcast:
      ```mlir
      linalg.batch_matmul
          indexing_maps = [affine_map<(batch, m, n, k) -> (k)>,           // broadcast
                           affine_map<(batch, m, n, k) -> (batch, k, n)>,
                           affine_map<(batch, m, n, k) -> (batch, m, n)>]
          ins(%arg0, %arg1 : memref<5xf32>, memref<2x5x7xf32>)
          outs(%arg2: memref<2x3x7xf32>)
      ```
  
      Example Broadcast and Transpose:
      ```mlir
      linalg.batch_matmul
          indexing_maps = [affine_map<(batch, m, n, k) -> (m, k)>,        // broadcast
                           affine_map<(batch, m, n, k) -> (batch, n, k)>, // transpose
                           affine_map<(batch, m, n, k) -> (batch, m, n)>]
          ins(%arg0, %arg1 : memref<3x5xf32>, memref<2x7x5xf32>)
          outs(%arg2: memref<2x3x7xf32>)
      ```
  """

  OPERATION_NAME = "linalg.batch_matmul"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, indexing_maps=None, cast=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if indexing_maps is not None: attributes["indexing_maps"] = (indexing_maps if (
        isinstance(indexing_maps, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AffineMapArrayAttr')) else
          _ods_ir.AttrBuilder.get('AffineMapArrayAttr')(indexing_maps, context=_ods_context))
    if cast is not None: attributes["cast"] = (cast if (
        isinstance(cast, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TypeFnAttr')) else
          _ods_ir.AttrBuilder.get('TypeFnAttr')(cast, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def indexing_maps(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "indexing_maps" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexing_maps"]

  @indexing_maps.setter
  def indexing_maps(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["indexing_maps"] = value
    elif "indexing_maps" in self.operation.attributes:
      del self.operation.attributes["indexing_maps"]

  @indexing_maps.deleter
  def indexing_maps(self):
    del self.operation.attributes["indexing_maps"]

  @builtins.property
  def cast(self) -> _Optional[_ods_ir.Attribute]:
    if "cast" not in self.operation.attributes:
      return None
    return self.operation.attributes["cast"]

  @cast.setter
  def cast(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["cast"] = value
    elif "cast" in self.operation.attributes:
      del self.operation.attributes["cast"]

  @cast.deleter
  def cast(self):
    del self.operation.attributes["cast"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def batch_matmul(result_tensors, inputs, outputs, *, indexing_maps=None, cast=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, BatchMatmulOp]:
  op = BatchMatmulOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, indexing_maps=indexing_maps, cast=cast, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class BatchMatvecOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.batch_matvec"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def batch_matvec(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, BatchMatvecOp]:
  op = BatchMatvecOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class BatchMmt4DOp(_ods_ir.OpView):
  r"""
  Besides the outermost batch dimension has the same semantic as
  linalg.batch_matmul, the differences from linalg.batch_matmul in the
  non-batch dimensions are the same as linalg.mmt4d vs. linalg.matmul. See the
  description of lingalg.mmt4d.
  """

  OPERATION_NAME = "linalg.batch_mmt4d"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def batch_mmt4d(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, BatchMmt4DOp]:
  op = BatchMmt4DOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class BatchReduceMatmulOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply,
  promoting them to the same data type as the accumulator/output.
  
  Broadcast and Transpose semantics can be applied by specifying the explicit attribute
  'indexing_maps' as shown below. This is a list attribute, so must include maps for all
  arguments if specified.
  
  Example Transpose:
  ```mlir
  linalg.batch_reduce_matmul
      indexing_maps = [affine_map<(batch, m, n, k) -> (batch, k, m)>, // transpose
                       affine_map<(batch, m, n, k) -> (batch, k, n)>,
                       affine_map<(batch, m, n, k) -> (m, n)>]
      ins(%arg0, %arg1 : memref<2x5x3xf32>,memref<2x5x7xf32>)
      outs(%arg2: memref<3x7xf32>)
  ```
  
  Example Broadcast:
  ```mlir
  linalg.batch_reduce_matmul
      indexing_maps = [affine_map<(batch, m, n, k) -> (k)>,         // broadcast
                       affine_map<(batch, m, n, k) -> (batch, k, n)>,
                       affine_map<(batch, m, n, k) -> (m, n)>]
      ins(%arg0, %arg1 : memref<5xf32>, memref<2x5x7xf32>)
      outs(%arg2: memref<3x7xf32>)
  ```
  
  Example Broadcast and Transpose:
  ```mlir
  linalg.batch_reduce_matmul
      indexing_maps = [affine_map<(batch, m, n, k) -> (m, k)>,        // broadcast
                       affine_map<(batch, m, n, k) -> (batch, n, k)>, // transpose
                       affine_map<(batch, m, n, k) -> (m, n)>]
      ins(%arg0, %arg1 : memref<3x5xf32>, memref<2x7x5xf32>)
      outs(%arg2: memref<3x7xf32>)
  ```
  """

  OPERATION_NAME = "linalg.batch_reduce_matmul"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, indexing_maps=None, cast=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if indexing_maps is not None: attributes["indexing_maps"] = (indexing_maps if (
        isinstance(indexing_maps, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AffineMapArrayAttr')) else
          _ods_ir.AttrBuilder.get('AffineMapArrayAttr')(indexing_maps, context=_ods_context))
    if cast is not None: attributes["cast"] = (cast if (
        isinstance(cast, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TypeFnAttr')) else
          _ods_ir.AttrBuilder.get('TypeFnAttr')(cast, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def indexing_maps(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "indexing_maps" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexing_maps"]

  @indexing_maps.setter
  def indexing_maps(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["indexing_maps"] = value
    elif "indexing_maps" in self.operation.attributes:
      del self.operation.attributes["indexing_maps"]

  @indexing_maps.deleter
  def indexing_maps(self):
    del self.operation.attributes["indexing_maps"]

  @builtins.property
  def cast(self) -> _Optional[_ods_ir.Attribute]:
    if "cast" not in self.operation.attributes:
      return None
    return self.operation.attributes["cast"]

  @cast.setter
  def cast(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["cast"] = value
    elif "cast" in self.operation.attributes:
      del self.operation.attributes["cast"]

  @cast.deleter
  def cast(self):
    del self.operation.attributes["cast"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def batch_reduce_matmul(result_tensors, inputs, outputs, *, indexing_maps=None, cast=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, BatchReduceMatmulOp]:
  op = BatchReduceMatmulOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, indexing_maps=indexing_maps, cast=cast, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class BatchVecmatOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.batch_vecmat"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def batch_vecmat(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, BatchVecmatOp]:
  op = BatchVecmatOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class BroadcastOp(_ods_ir.OpView):
  r"""
  Broadcast the input into the given shape by adding `dimensions`.
  
  Example:
  ```mlir
    %bcast = linalg.broadcast
        ins(%input:tensor<16xf32>)
        outs(%init:tensor<16x64xf32>)
        dimensions = [1]
  ```
  """

  OPERATION_NAME = "linalg.broadcast"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, input, init, dimensions, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(init)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimensions"] = (dimensions if (
    isinstance(dimensions, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(dimensions, context=_ods_context))
    results = []
    results.extend(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def init(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def dimensions(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["dimensions"]

  @dimensions.setter
  def dimensions(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimensions"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def broadcast(result, input, init, dimensions, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, BroadcastOp]:
  op = BroadcastOp(result=result, input=input, init=init, dimensions=dimensions, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class CeilOp(_ods_ir.OpView):
  r"""
  No numeric casting is performed on the input operand.
  """

  OPERATION_NAME = "linalg.ceil"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def ceil(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, CeilOp]:
  op = CeilOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ContractOp(_ods_ir.OpView):
  r"""
  The semantics of contracting inputs `A` and `B` on top of `C` to produce
  output `D` is given by
  
    `D[H] = (SUM_{(I ∪ J) \ H} A[I] * B[J]) + C[H]`
  
  where `I`, `J`, and `H` are tuples of (pairwise distinct) dimension
  identifiers - meant to range over valid indices - corresponding to the
  results of the mandatory (projected permutation) `indexing_maps` for `A`,
  `B` and `C`. `SUM_{dims}` means reduce over all valid indices for the
  dimensions in the set `dims` (with `I`, `J`, and `K` treated as _sets_ of
  dim identifiers).
  
  The iteration space consists of all dimensions in `I`, `J` and `H`, i.e. the
  domain of each of the `affine_map`s. Like for einsums, the iteration type of
  each dim is inferred and is either:
  
  - reduction: the dim is used to index into `A` and `B` but not `C`. Per the
    above semantics, these dims will be contracted, i.e. reduced over.
  
  - parallel: the dim is used to index into `C` and at least one of `A` and
    `B`, and - deriving from matmul terminology - is either an "M-like" dim
    (if used on `A` and `C`), an "N-like" dim (if used on `B` and `C`) or a
    "batch"-dim (if used to index into `A`, `B`, and `C`).
  
  For example, batch-matmul is given by `I = ⟨ b, m, k ⟩`, `J = ⟨ b, k, n ⟩`,
  `H = ⟨ b, m, n ⟩` (with `k` as a contracting reduction-dimension while `m`,
  `n` and `b` have parallel iteration-type) and gets represented as:
  
  ```mlir
  %D = linalg.contract
      indexing_maps = [affine_map<(batch, m, n, k) -> (batch, m, k)>,
                       affine_map<(batch, m, n, k) -> (batch, k, n)>,
                       affine_map<(batch, m, n, k) -> (batch, m, n)>]
      ins(%A, %B: tensor<?x?x?xf32>, tensor<?x?x?xf32>)
      outs(%C: tensor<?x?x?xf32>) -> tensor<?x?x?xf32>
  ```
  
  Note that by permuting dims in the `affine_map`s' results, accesses to
  to the inputs and output can be arbitrarily transposed. Similarly, arbitrary
  broadcasts can be achieved through leaving out dims on either input operand.
  For example, the following is a variant of batch-matmul with a transposition
  applied to `A` while `B`'s 2D-matrix gets broadcasted along the batch dim:
  
  ```mlir
  linalg.contract
      indexing_maps = [affine_map<(batch, m, n, k) -> (batch, k, m)>,
                       affine_map<(batch, m, n, k) -> (k, n)>,
                       affine_map<(batch, m, n, k) -> (batch, m, n)>]
      ins(%A, %B: memref<?x?x?xf32>, memref<?x?xf32>)
      outs(%C: memref<?x?x?xf32>)
  ```
  
  Numeric casting is performed on the operands to the inner multiplication,
  promoting/truncating them to the same data type as the accumulator/output.
  
  TODO: Allow control over the combining/accumulating op and possibly the
        multiplication op.
  """

  OPERATION_NAME = "linalg.contract"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, indexing_maps, *, cast=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["indexing_maps"] = (indexing_maps if (
    isinstance(indexing_maps, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapArrayAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapArrayAttr')(indexing_maps, context=_ods_context))
    if cast is not None: attributes["cast"] = (cast if (
        isinstance(cast, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TypeFnAttr')) else
          _ods_ir.AttrBuilder.get('TypeFnAttr')(cast, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def indexing_maps(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["indexing_maps"]

  @indexing_maps.setter
  def indexing_maps(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["indexing_maps"] = value

  @builtins.property
  def cast(self) -> _Optional[_ods_ir.Attribute]:
    if "cast" not in self.operation.attributes:
      return None
    return self.operation.attributes["cast"]

  @cast.setter
  def cast(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["cast"] = value
    elif "cast" in self.operation.attributes:
      del self.operation.attributes["cast"]

  @cast.deleter
  def cast(self):
    del self.operation.attributes["cast"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def combiner(self) -> _ods_ir.Region:
    return self.regions[0]

def contract(result_tensors, inputs, outputs, indexing_maps, *, cast=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ContractOp]:
  op = ContractOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, indexing_maps=indexing_maps, cast=cast, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class Conv1DNcwFcwOp(_ods_ir.OpView):
  r"""
  Layout:
    * Input: NCW.
    * Kernel: FCW.
  
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.conv_1d_ncw_fcw"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def conv_1d_ncw_fcw(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, Conv1DNcwFcwOp]:
  op = Conv1DNcwFcwOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class Conv1DNwcWcfOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.conv_1d_nwc_wcf"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def conv_1d_nwc_wcf(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, Conv1DNwcWcfOp]:
  op = Conv1DNwcWcfOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class Conv1DOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.conv_1d"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def conv_1d(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, Conv1DOp]:
  op = Conv1DOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class Conv2DNchwFchwOp(_ods_ir.OpView):
  r"""
  Layout:
    * Input: NCHW.
    * Kernel: FCHW.
  
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.conv_2d_nchw_fchw"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def conv_2d_nchw_fchw(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, Conv2DNchwFchwOp]:
  op = Conv2DNchwFchwOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class Conv2DNchwFchwQOp(_ods_ir.OpView):
  r"""
  Layout:
    * Input: NCHW.
    * Kernel: FCHW.
  
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output. This includes the zero
  point offsets common to quantized operations.
  """

  OPERATION_NAME = "linalg.conv_2d_nchw_fchw_q"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def conv_2d_nchw_fchw_q(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, Conv2DNchwFchwQOp]:
  op = Conv2DNchwFchwQOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class Conv2DNgchwFgchwOp(_ods_ir.OpView):
  r"""
  Layout:
    * Input: NGCHW.
    * Kernel: FGCHW.
  
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.conv_2d_ngchw_fgchw"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def conv_2d_ngchw_fgchw(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, Conv2DNgchwFgchwOp]:
  op = Conv2DNgchwFgchwOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class Conv2DNgchwGfchwOp(_ods_ir.OpView):
  r"""
  Layout:
    * Input: NGCHW.
    * Kernel: GFCHW.
  
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.conv_2d_ngchw_gfchw"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def conv_2d_ngchw_gfchw(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, Conv2DNgchwGfchwOp]:
  op = Conv2DNgchwGfchwOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class Conv2DNgchwGfchwQOp(_ods_ir.OpView):
  r"""
  Layout:
    * Input: NGCHW.
    * Kernel: GFCHW.
  
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output. This includes the zero
  point offsets common to quantized operations.
  """

  OPERATION_NAME = "linalg.conv_2d_ngchw_gfchw_q"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def conv_2d_ngchw_gfchw_q(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, Conv2DNgchwGfchwQOp]:
  op = Conv2DNgchwGfchwQOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class Conv2DNhwcFhwcOp(_ods_ir.OpView):
  r"""
  Layout:
    * Input: NHWC.
    * Kernel: FHWC.
  
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.conv_2d_nhwc_fhwc"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def conv_2d_nhwc_fhwc(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, Conv2DNhwcFhwcOp]:
  op = Conv2DNhwcFhwcOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class Conv2DNhwcFhwcQOp(_ods_ir.OpView):
  r"""
  Layout:
    * Input: NHWC.
    * Kernel: FHWC.
  
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output. This includes the zero
  point offsets common to quantized operations.
  """

  OPERATION_NAME = "linalg.conv_2d_nhwc_fhwc_q"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def conv_2d_nhwc_fhwc_q(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, Conv2DNhwcFhwcQOp]:
  op = Conv2DNhwcFhwcQOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class Conv2DNhwcHwcfOp(_ods_ir.OpView):
  r"""
  Layout:
    * Input: NHWC.
    * Kernel: HWCF.
  
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.conv_2d_nhwc_hwcf"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def conv_2d_nhwc_hwcf(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, Conv2DNhwcHwcfOp]:
  op = Conv2DNhwcHwcfOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class Conv2DNhwcHwcfQOp(_ods_ir.OpView):
  r"""
  Layout:
    * Input: NHWC.
    * Kernel: HWCF.
  
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output. This includes the zero
  point offsets common to quantized operations.
  """

  OPERATION_NAME = "linalg.conv_2d_nhwc_hwcf_q"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def conv_2d_nhwc_hwcf_q(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, Conv2DNhwcHwcfQOp]:
  op = Conv2DNhwcHwcfQOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class Conv2DNhwgcGfhwcOp(_ods_ir.OpView):
  r"""
  Layout:
    * Input: NHWGC.
    * Kernel: GFHWC.
  
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.conv_2d_nhwgc_gfhwc"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def conv_2d_nhwgc_gfhwc(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, Conv2DNhwgcGfhwcOp]:
  op = Conv2DNhwgcGfhwcOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class Conv2DNhwgcGfhwcQOp(_ods_ir.OpView):
  r"""
  Layout:
    * Input: NHWGC.
    * Kernel: GFHWC.
  
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output. This includes the zero
  point offsets common to quantized operations.
  """

  OPERATION_NAME = "linalg.conv_2d_nhwgc_gfhwc_q"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def conv_2d_nhwgc_gfhwc_q(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, Conv2DNhwgcGfhwcQOp]:
  op = Conv2DNhwgcGfhwcQOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class Conv2DOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.conv_2d"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def conv_2d(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, Conv2DOp]:
  op = Conv2DOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class Conv3DNcdhwFcdhwOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.conv_3d_ncdhw_fcdhw"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_818')) else
          _ods_ir.AttrBuilder.get('anonymous_818')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_818')) else
          _ods_ir.AttrBuilder.get('anonymous_818')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def conv_3d_ncdhw_fcdhw(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, Conv3DNcdhwFcdhwOp]:
  op = Conv3DNcdhwFcdhwOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class Conv3DNdhwcDhwcfOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.conv_3d_ndhwc_dhwcf"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_818')) else
          _ods_ir.AttrBuilder.get('anonymous_818')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_818')) else
          _ods_ir.AttrBuilder.get('anonymous_818')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def conv_3d_ndhwc_dhwcf(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, Conv3DNdhwcDhwcfOp]:
  op = Conv3DNdhwcDhwcfOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class Conv3DNdhwcDhwcfQOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output. This includes the zero
  point offsets common to quantized operations.
  """

  OPERATION_NAME = "linalg.conv_3d_ndhwc_dhwcf_q"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_818')) else
          _ods_ir.AttrBuilder.get('anonymous_818')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_818')) else
          _ods_ir.AttrBuilder.get('anonymous_818')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def conv_3d_ndhwc_dhwcf_q(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, Conv3DNdhwcDhwcfQOp]:
  op = Conv3DNdhwcDhwcfQOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class Conv3DOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.conv_3d"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def conv_3d(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, Conv3DOp]:
  op = Conv3DOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class CopyOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the input operand, promoting it to the same
  data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.copy"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, cast=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if cast is not None: attributes["cast"] = (cast if (
        isinstance(cast, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TypeFnAttr')) else
          _ods_ir.AttrBuilder.get('TypeFnAttr')(cast, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def cast(self) -> _Optional[_ods_ir.Attribute]:
    if "cast" not in self.operation.attributes:
      return None
    return self.operation.attributes["cast"]

  @cast.setter
  def cast(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["cast"] = value
    elif "cast" in self.operation.attributes:
      del self.operation.attributes["cast"]

  @cast.deleter
  def cast(self):
    del self.operation.attributes["cast"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def copy(result_tensors, inputs, outputs, *, cast=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, CopyOp]:
  op = CopyOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, cast=cast, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DepthwiseConv1DNcwCwOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output. Multiplier is set to 1
  which is a special case for most depthwise convolutions.
  """

  OPERATION_NAME = "linalg.depthwise_conv_1d_ncw_cw"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def depthwise_conv_1d_ncw_cw(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, DepthwiseConv1DNcwCwOp]:
  op = DepthwiseConv1DNcwCwOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DepthwiseConv1DNwcWcOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output. Multiplier is set to 1
  which is a special case for most depthwise convolutions.
  """

  OPERATION_NAME = "linalg.depthwise_conv_1d_nwc_wc"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def depthwise_conv_1d_nwc_wc(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, DepthwiseConv1DNwcWcOp]:
  op = DepthwiseConv1DNwcWcOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DepthwiseConv1DNwcWcmOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.depthwise_conv_1d_nwc_wcm"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def depthwise_conv_1d_nwc_wcm(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, DepthwiseConv1DNwcWcmOp]:
  op = DepthwiseConv1DNwcWcmOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DepthwiseConv2DNchwChwOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output. Multiplier is set to 1
  which is a special case for most depthwise convolutions.
  """

  OPERATION_NAME = "linalg.depthwise_conv_2d_nchw_chw"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def depthwise_conv_2d_nchw_chw(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, DepthwiseConv2DNchwChwOp]:
  op = DepthwiseConv2DNchwChwOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DepthwiseConv2DNhwcHwcOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output. Multiplier is set to 1
  which is a special case for most depthwise convolutions.
  """

  OPERATION_NAME = "linalg.depthwise_conv_2d_nhwc_hwc"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def depthwise_conv_2d_nhwc_hwc(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, DepthwiseConv2DNhwcHwcOp]:
  op = DepthwiseConv2DNhwcHwcOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DepthwiseConv2DNhwcHwcQOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.depthwise_conv_2d_nhwc_hwc_q"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def depthwise_conv_2d_nhwc_hwc_q(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, DepthwiseConv2DNhwcHwcQOp]:
  op = DepthwiseConv2DNhwcHwcQOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DepthwiseConv2DNhwcHwcmOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.depthwise_conv_2d_nhwc_hwcm"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def depthwise_conv_2d_nhwc_hwcm(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, DepthwiseConv2DNhwcHwcmOp]:
  op = DepthwiseConv2DNhwcHwcmOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DepthwiseConv2DNhwcHwcmQOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.depthwise_conv_2d_nhwc_hwcm_q"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def depthwise_conv_2d_nhwc_hwcm_q(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, DepthwiseConv2DNhwcHwcmQOp]:
  op = DepthwiseConv2DNhwcHwcmQOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DepthwiseConv3DNcdhwCdhwOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output. Multiplier is set to 1
  which is a special case for most depthwise convolutions.
  """

  OPERATION_NAME = "linalg.depthwise_conv_3d_ncdhw_cdhw"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_818')) else
          _ods_ir.AttrBuilder.get('anonymous_818')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_818')) else
          _ods_ir.AttrBuilder.get('anonymous_818')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def depthwise_conv_3d_ncdhw_cdhw(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, DepthwiseConv3DNcdhwCdhwOp]:
  op = DepthwiseConv3DNcdhwCdhwOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DepthwiseConv3DNdhwcDhwcOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output. Multiplier is set to 1
  which is a special case for most depthwise convolutions.
  """

  OPERATION_NAME = "linalg.depthwise_conv_3d_ndhwc_dhwc"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_818')) else
          _ods_ir.AttrBuilder.get('anonymous_818')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_818')) else
          _ods_ir.AttrBuilder.get('anonymous_818')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def depthwise_conv_3d_ndhwc_dhwc(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, DepthwiseConv3DNdhwcDhwcOp]:
  op = DepthwiseConv3DNdhwcDhwcOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DepthwiseConv3DNdhwcDhwcmOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.depthwise_conv_3d_ndhwc_dhwcm"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_818')) else
          _ods_ir.AttrBuilder.get('anonymous_818')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_818')) else
          _ods_ir.AttrBuilder.get('anonymous_818')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def depthwise_conv_3d_ndhwc_dhwcm(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, DepthwiseConv3DNdhwcDhwcmOp]:
  op = DepthwiseConv3DNdhwcDhwcmOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DivOp(_ods_ir.OpView):
  r"""
  The shapes and element types must be identical. The appropriate casts,
  broadcasts and reductions should be done previously to calling this op.
  
  This means reduction/broadcast/element cast semantics is explicit. Further
  passes can take that into account when lowering this code. For example,
  a `linalg.broadcast` + `linalg.div` sequence can be lowered to a
  `linalg.generic` with different affine maps for the two operands.
  """

  OPERATION_NAME = "linalg.div"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def div(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, DivOp]:
  op = DivOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DivUnsignedOp(_ods_ir.OpView):
  r"""
  The shapes and element types must be identical. The appropriate casts,
  broadcasts and reductions should be done previously to calling this op.
  
  This means reduction/broadcast/element cast semantics is explicit. Further
  passes can take that into account when lowering this code. For example,
  a `linalg.broadcast` + `linalg.div` sequence can be lowered to a
  `linalg.generic` with different affine maps for the two operands.
  """

  OPERATION_NAME = "linalg.div_unsigned"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def div_unsigned(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, DivUnsignedOp]:
  op = DivUnsignedOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DotOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.dot"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def dot(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, DotOp]:
  op = DotOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ElementwiseOp(_ods_ir.OpView):
  r"""
  The attribute `kind` describes arithmetic operation to perform. The
  operation kind can be unary (e.g. max), binary (e.g. add) or ternary
  (e.g. select).
  
  By default, all indexing maps are identities. In the case of default
  indexing map, all input and output shapes must match. The number of dims in
  each of the identity maps is equal to the rank of the output type.
  
  Affine-maps for operands and result are required to be provided by the user
  when a transpose and/or broadcast is needed on any operand. When a map is not
  provided, default identity maps are inferred for each operand.
  
  Iterator-types are always all `parallel`.
  Iterator-types are needed for constructing the underlying structured op.
  
  The number of dims of the iterator-types are inferred from the rank of
  the result type.
  
  Example:
  
  Defining a unary linalg.elementwise with default indexing-map:
  ```mlir
  %exp = linalg.elementwise
      kind=#linalg.elementwise_kind<exp>
      ins(%x : tensor<4x16x8xf32>)
      outs(%y: tensor<4x16x8xf32>) -> tensor<4x16x8xf32>
  ```
  
  Defining a binary linalg.elementwise with user-defined indexing-map:
  ```mlir
  %add = linalg.elementwise
      kind=#linalg.elementwise_kind<add>
      indexing_maps = [#transpose, #broadcast, #identity]
      ins(%exp, %arg1 : tensor<4x16x8xf32>, tensor<4x16xf32>)
      outs(%arg2: tensor<4x8x16xf32>) -> tensor<4x8x16xf32>
  ```
  """

  OPERATION_NAME = "linalg.elementwise"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, kind, *, indexing_maps=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kind"] = (kind if (
    isinstance(kind, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ElementwiseKindAttr')) else
      _ods_ir.AttrBuilder.get('ElementwiseKindAttr')(kind, context=_ods_context))
    if indexing_maps is not None: attributes["indexing_maps"] = (indexing_maps if (
        isinstance(indexing_maps, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AffineMapArrayAttr')) else
          _ods_ir.AttrBuilder.get('AffineMapArrayAttr')(indexing_maps, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def kind(self) -> _ods_ir.Attribute:
    return self.operation.attributes["kind"]

  @kind.setter
  def kind(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kind"] = value

  @builtins.property
  def indexing_maps(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "indexing_maps" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexing_maps"]

  @indexing_maps.setter
  def indexing_maps(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["indexing_maps"] = value
    elif "indexing_maps" in self.operation.attributes:
      del self.operation.attributes["indexing_maps"]

  @indexing_maps.deleter
  def indexing_maps(self):
    del self.operation.attributes["indexing_maps"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def elementwise(result_tensors, inputs, outputs, kind, *, indexing_maps=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ElementwiseOp]:
  op = ElementwiseOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, kind=kind, indexing_maps=indexing_maps, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ErfOp(_ods_ir.OpView):
  r"""
  No numeric casting is performed on the input operand.
  """

  OPERATION_NAME = "linalg.erf"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def erf(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ErfOp]:
  op = ErfOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ExpOp(_ods_ir.OpView):
  r"""
  No numeric casting is performed on the input operand.
  """

  OPERATION_NAME = "linalg.exp"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def exp(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ExpOp]:
  op = ExpOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class FillOp(_ods_ir.OpView):
  r"""
  Works for arbitrary ranked output tensors since the operation performs scalar
  accesses only and is thus rank polymorphic. Numeric casting is performed on
  the value operand, promoting it to the same data type as the output.
  """

  OPERATION_NAME = "linalg.fill"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def fill(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, FillOp]:
  op = FillOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class FillRng2DOp(_ods_ir.OpView):
  r"""
  The operation generations pseudo random numbers using a linear congruential
  generator. It provides no guarantees regarding the distribution of the
  generated random numbers. Instead of generating the random numbers
  sequentially, it instantiates one random number generator per data element
  and runs them in parallel. The seed operand and the indices of the data
  element seed the random number generation. The min and max operands limit
  the range of the generated random numbers.
  """

  OPERATION_NAME = "linalg.fill_rng_2d"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def fill_rng_2d(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, FillRng2DOp]:
  op = FillRng2DOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class FloorOp(_ods_ir.OpView):
  r"""
  No numeric casting is performed on the input operand.
  """

  OPERATION_NAME = "linalg.floor"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def floor(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, FloorOp]:
  op = FloorOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class GenericOp(_ods_ir.OpView):
  r"""
  Generic Linalg op form where the key properties of the computation are
  specified as attributes. In pretty form, a `linalg.generic` op is written
  as:
  
    ```mlir
    linalg.generic #trait_attribute
        ins(%A, %B : memref<?x?xf32, stride_specification>,
                     memref<?x?xf32, stride_specification>)
        outs(%C : memref<?x?xf32, stride_specification>)
        attrs = {other-optional-attributes}
        {region}
    ```
  
  Where #trait_attributes is an alias of a dictionary attribute containing:
    - doc [optional]: a documentation string
    - indexing_maps: a list of AffineMapAttr, one AffineMapAttr per each input
      and output view. Such AffineMapAttr specifies the mapping between the
      loops and the indexing within each view.
    - library_call [optional]: a StringAttr containing the name of an
      external library function that the linalg.generic operation maps to.
      The external library is assumed to be dynamically linked and no strong
      compile-time guarantees are provided. In the absence of such a library
      call, linalg.generic will always lower to loops.
    - iterator_types: an ArrayAttr specifying the type of the enclosing loops.
      Each element of the list represents and iterator of one of the following
      types:
        parallel, reduction, window
  
  Example:
  Defining a #matmul_trait attribute in MLIR can be done as follows:
    ```mlir
    #matmul_accesses = [
      (m, n, k) -> (m, k),
      (m, n, k) -> (k, n),
      (m, n, k) -> (m, n)
    ]
    #matmul_trait = {
      doc = "C(m, n) += A(m, k) * B(k, n)",
      indexing_maps = #matmul_accesses,
      library_call = "linalg_matmul",
      iterator_types = ["parallel", "parallel", "reduction"]
    }
    ```
  
  And can be reused in multiple places as:
    ```mlir
    linalg.generic #matmul_trait
      ins(%A, %B : memref<?x?xf32, stride_specification>,
                   memref<?x?xf32, stride_specification>)
      outs(%C : memref<?x?xf32, stride_specification>)
      {other-optional-attributes} {
      ^bb0(%a: f32, %b: f32, %c: f32) :
        %d = arith.mulf %a, %b: f32
        %e = arith.addf %c, %d: f32
        linalg.yield %e : f32
    }
    ```
  
  This may lower to either:
    ```mlir
    call @linalg_matmul(%A, %B, %C) :
      (memref<?x?xf32, stride_specification>,
       memref<?x?xf32, stride_specification>,
       memref<?x?xf32, stride_specification>)
      -> ()
    ```
  
  or IR resembling:
  ```mlir
  scf.for %m = %c0 to %M step %c1 {
    scf.for %n = %c0 to %N step %c1 {
      scf.for %k = %c0 to %K step %c1 {
        %a = load %A[%m, %k] : memref<?x?xf32, stride_specification>
        %b = load %B[%k, %n] : memref<?x?xf32, stride_specification>
        %c = load %C[%m, %n] : memref<?x?xf32, stride_specification>
        %d = arith.mulf %a, %b: f32
        %e = arith.addf %c, %d: f32
        store %e, %C[%m, %n] : memref<?x?x?xf32, stride_specification>
      }
    }
  }
  ```
  """

  OPERATION_NAME = "linalg.generic"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, indexing_maps, iterator_types, *, doc=None, library_call=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["indexing_maps"] = (indexing_maps if (
    isinstance(indexing_maps, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapArrayAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapArrayAttr')(indexing_maps, context=_ods_context))
    attributes["iterator_types"] = (iterator_types if (
    isinstance(iterator_types, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IteratorTypeArrayAttr')) else
      _ods_ir.AttrBuilder.get('IteratorTypeArrayAttr')(iterator_types, context=_ods_context))
    if doc is not None: attributes["doc"] = (doc if (
        isinstance(doc, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(doc, context=_ods_context))
    if library_call is not None: attributes["library_call"] = (library_call if (
        isinstance(library_call, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(library_call, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def indexing_maps(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["indexing_maps"]

  @indexing_maps.setter
  def indexing_maps(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["indexing_maps"] = value

  @builtins.property
  def iterator_types(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["iterator_types"]

  @iterator_types.setter
  def iterator_types(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["iterator_types"] = value

  @builtins.property
  def doc(self) -> _Optional[_ods_ir.StringAttr]:
    if "doc" not in self.operation.attributes:
      return None
    return self.operation.attributes["doc"]

  @doc.setter
  def doc(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["doc"] = value
    elif "doc" in self.operation.attributes:
      del self.operation.attributes["doc"]

  @doc.deleter
  def doc(self):
    del self.operation.attributes["doc"]

  @builtins.property
  def library_call(self) -> _Optional[_ods_ir.StringAttr]:
    if "library_call" not in self.operation.attributes:
      return None
    return self.operation.attributes["library_call"]

  @library_call.setter
  def library_call(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["library_call"] = value
    elif "library_call" in self.operation.attributes:
      del self.operation.attributes["library_call"]

  @library_call.deleter
  def library_call(self):
    del self.operation.attributes["library_call"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def generic(result_tensors, inputs, outputs, indexing_maps, iterator_types, *, doc=None, library_call=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, GenericOp]:
  op = GenericOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, indexing_maps=indexing_maps, iterator_types=iterator_types, doc=doc, library_call=library_call, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class IndexOp(_ods_ir.OpView):
  r"""
  The `linalg.index` operation returns the iteration index of the immediately
  enclosing linalg structured operation for the iteration dimension `dim`. The
  `dim` attribute specifies the position of the accessed dimension in the
  indexing map domain.
  
  Example:
  
  ```mlir
  #map = affine_map<(i, j) -> (i, j)>
  linalg.generic {indexing_maps = [#map, #map],
                  iterator_types = ["parallel", "parallel"]}
    outs(%I, %J : memref<?x?xindex>, memref<?x?xindex>) {
    ^bb0(%arg0 : index, %arg1 : index):
    // Access the outer iteration dimension i
    %i = linalg.index 0 : index
    // Access the inner iteration dimension j
    %j = linalg.index 1 : index
    linalg.yield %i, %j : index, index
  }
  ```
  
  This may lower to IR resembling:
  
  ```mlir
  %0 = dim %I, %c0 : memref<?x?xindex>
  %1 = dim %I, %c1 : memref<?x?xindex>
  scf.for %i = %c0 to %0 step %c1 {
    scf.for %j = %c0 to %1 step %c1 {
      store %i, %I[%i, %j] : memref<?x?xindex>
      store %j, %J[%i, %j] : memref<?x?xindex>
    }
  }
  ```
  """

  OPERATION_NAME = "linalg.index"

  _ODS_REGIONS = (0, True)

  def __init__(self, dim, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dim"] = (dim if (
    isinstance(dim, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dim, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dim(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dim"]

  @dim.setter
  def dim(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def index(dim, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IndexOp(dim=dim, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PackOp(_ods_ir.OpView):
  r"""
  The "pack" operation converts a source tensor of rank `n` into a result
  tensor of rank `n + k` with a tiled and packed layout (maybe with padding)
  and optionally transposes the tiled source tensor dimensions.
  
  `inner_tiles` (mandatory) specifies `k` tile sizes. These tile sizes
  correspond to the least significant ("inner") result tensor dimension sizes,
  in the same order. Tile sizes can be static or dynamic.
  
  `inner_dims_pos` (mandatory) specifies `k` source tensor dimensions that are
  being tiled, where `0 <= k <= n`.
   - `inner_dims_pos[i]` specifies the source tensor dimension tiled by
  `inner_tiles[i]` where `0 <= i < k`. All the values in `inner_dims_pos` are
  within [0, n).
   - The tiled dimensions (of size `inner_tiles`) are added to the end of the
   result tensor in the order in which they appear, i.e.
   `shape(result)[rank(result) + i] = inner_tiles[i]` for `0 <= i < k`.
   - The following relationship for the tiled dimensions holds:
   `shape(result)[inner_dims_pos[i]] = shape(source)[inner_dims_pos[i]] / inner_tiles[i]`,
   where (⌈/⌉ indicates CeilDiv).
  
  
  Example: If `inner_tiles = [16, 32]`, the result tensor has a shape of
  `...x16x32`. If `inner_dims_pos = [0, 1]`, the 0th source dimension is tiled
  by 16 and the 1st source dimension is tiled by 32. Other source dimensions
  (if any) are not tiled. If `inner_dims_pos = [1, 0]`, the 1st dimension is
  tiled by 16 and the 0th dimension is tiled by 32.
  
  Example:
  ```mlir
  // NC to NCnc
  %0 = linalg.pack %source inner_dims_pos = [0, 1] inner_tiles = [8, 32]
      into %dest : tensor<128x256xf32> -> tensor<16x8 x 8x32 xf32>
  //                                             \  /   \  /
  //                                 Outer Dims: 16x8   Inner Dims: 8x32
  
  // CHW to CHWhw
  %0 = linalg.pack %source inner_dims_pos = [2, 1] inner_tiles = [4, 2]
      into %dest : tensor<3x20x24xf32> -> tensor<3x10x6 x 4x2 xf32>
  //                                              \  /    \ /
  //                                 Outer Dims: 3x10x6  Inner Dims: 4x2
  
  // HCW to HCWhw
  %0 = linalg.pack %source inner_dims_pos = [2, 0] inner_tiles = [4, 2]
      into %dest : tensor<18x3x32xf32> -> tensor<9x3x8 x 4x2 xf32>
  //                                              \  /   \ /
  //                                 Outer Dims: 9x3x8  Inner Dims: 4x2
  ```
  
  `outer_dims_perm` (optional) specifies a permutation for the outer
  dimensions. If specified, it must have `n` elements.
  
  Example:
  ```mlir
  // CK to KCck
  %0 = linalg.pack %source outer_dims_perm = [1, 0] inner_dims_pos = [0, 1]
      inner_tiles = [8, 32] into %dest
      : tensor<128x256xf32> -> tensor<8x16 x 8x32 xf32>
  //                                  \  /
  //            compare with "NC to NCnc": outer dims are transposed
  ```
  
  `padding_value` specifies a padding value at the boundary on non-perfectly
  divisible dimensions. Padding is optional:
  - If absent, it is assumed that for all inner tiles,
    `shape(source)[inner_dims_pos[i]] % inner_tiles[i] == 0`, i.e. all inner
    tiles divide perfectly the corresponding outer dimension in the result
    tensor. It is UB if the tile does not perfectly divide the dimension.
  - If present, it will pad along high dimensions (high-padding) to make the
    tile complete. Note that it is not allowed to have artificial padding that
    is not strictly required by linalg.pack (i.e., padding past what is needed
    to complete the last tile along each packed dimension). It is UB if extra
    padding is requested.
  It is not possible to verify the requirements statically with dynamic
  shapes, so they are treated as UB.
  
  Example:
  ```mlir
  %0 = linalg.pack %arg0 padding_value(%pad : f32) outer_dims_perm = [2, 1, 0]
      inner_dims_pos = [1] inner_tiles = [2] into %arg1
      : tensor<200x127x256xf32> -> tensor<256x64x200x2xf32>
  //                 \
  //                padded and tiled dim
  //
  // Source dimension 1 is tiled. 64 does not divide 127 evenly, so 1 padded
  // element is added at the end.
  //
  // Note: Only tiled dimensions can be padded.
  ```
  
  Invalid example that has artificial padding:
  ```mlir
  %0 = linalg.pack %src padding_value(%cst : f32) inner_dims_pos = [0]
      inner_tiles = [8] into %dest
      : tensor<9xf32> -> tensor<3x8xf32>
  //                             \
  //            expect tensor<2x8xf32> because CeilDiv(9, 8) = 2
  ```
  """

  OPERATION_NAME = "linalg.pack"

  _ODS_OPERAND_SEGMENTS = [1,1,0,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, source, dest, inner_dims_pos, inner_tiles, static_inner_tiles, *, padding_value=None, outer_dims_perm=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(dest)
    operands.append(padding_value)
    operands.append(_get_op_results_or_values(inner_tiles))
    _ods_context = _ods_get_default_loc_context(loc)
    if outer_dims_perm is not None: attributes["outer_dims_perm"] = (outer_dims_perm if (
        isinstance(outer_dims_perm, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(outer_dims_perm, context=_ods_context))
    attributes["inner_dims_pos"] = (inner_dims_pos if (
    isinstance(inner_dims_pos, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(inner_dims_pos, context=_ods_context))
    attributes["static_inner_tiles"] = (static_inner_tiles if (
    isinstance(static_inner_tiles, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(static_inner_tiles, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def dest(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def padding_value(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def inner_tiles(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def outer_dims_perm(self) -> _Optional[_ods_ir.DenseI64ArrayAttr]:
    if "outer_dims_perm" not in self.operation.attributes:
      return None
    return self.operation.attributes["outer_dims_perm"]

  @outer_dims_perm.setter
  def outer_dims_perm(self, value: _Optional[_ods_ir.DenseI64ArrayAttr]):
    if value is not None:
      self.operation.attributes["outer_dims_perm"] = value
    elif "outer_dims_perm" in self.operation.attributes:
      del self.operation.attributes["outer_dims_perm"]

  @outer_dims_perm.deleter
  def outer_dims_perm(self):
    del self.operation.attributes["outer_dims_perm"]

  @builtins.property
  def inner_dims_pos(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["inner_dims_pos"]

  @inner_dims_pos.setter
  def inner_dims_pos(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inner_dims_pos"] = value

  @builtins.property
  def static_inner_tiles(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["static_inner_tiles"]

  @static_inner_tiles.setter
  def static_inner_tiles(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["static_inner_tiles"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def pack(source, dest, inner_dims_pos, inner_tiles, static_inner_tiles, *, padding_value=None, outer_dims_perm=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return PackOp(source=source, dest=dest, inner_dims_pos=inner_dims_pos, inner_tiles=inner_tiles, static_inner_tiles=static_inner_tiles, padding_value=padding_value, outer_dims_perm=outer_dims_perm, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SoftmaxOp(_ods_ir.OpView):
  r"""
  linalg.softmax computes a numerically stable version of softmax.
  
  For a given input tensor and a specified dimension `d`, compute:
    1. the max `m` along that dimension `d`
    2. f(x) = exp(x - m)
    3. sum f(x) along dimension d to get l(x).
    4. compute the final result f(x) / l(x).
  
  This is an aggregate linalg operation that further reduces to a small DAG of
  structured operations.
  
  Warning: Regarding the tiling capabilities, the implementation doesn't
  check that the provided dimensions make sense. This is the responsability
  of the transformation calling the tiling to ensure that the provided
  sizes for each dimension make sense with respect to the semantic of
  softmax.
  """

  OPERATION_NAME = "linalg.softmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, output, dimension, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(output)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dimension, context=_ods_context))
    results = []
    results.extend(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def dimension(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def softmax(result, input, output, dimension, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, SoftmaxOp]:
  op = SoftmaxOp(result=result, input=input, output=output, dimension=dimension, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class UnPackOp(_ods_ir.OpView):
  r"""
  The "unpack" operation converts a source tensor of rank `n` with a tiled and
  packed layout to a result tensor of rank `n - k`.
  
  `inner_tiles` (mandatory) specifies `k` tile sizes. These tile sizes
  correspond to the least significant ("inner") source tensor dimension sizes.
  The behavior of this op is undefined if:
  - `inner_tiles` do not exactly match with the corresponding source tensor
    dimension sizes.
  - Or, `inner_tiles[i]` does not divide the size of dimension
    `inner_dims_pos[i]` (assuming that `outer_dims_perm` is not specified)
    evenly.
  
  `inner_dims_pos` (mandatory) specifies `k` result tensor (i.e. unpacked
  tensor) dimensions that were tiled with the `inner_tiles` to create the
  packed source tensor. The source tensor (i.e. packed tensor) dimensions can
  be unpacked given `inner_dims_pos` as follows.
  - For `0 <= i < k` the following relationship holds:
  `shape(result)[inner_dims_pos[i]] <= shape(source)[n-k+i] * shape(source)[inner_dims_pos[i]]`.
  - For `0 <= j < n-k` and `j` not in `inner_dims_pos` the following relationship holds:
  `shape(result)[j] = shape(source)[j]`.
  
  `outer_dims_perm` (optional) specifies a permutation for the outer
  dimensions. If specified, it must have `n - k` elements. If specified, this
  permutation is applied before combining any dimensions.
  
  Note, the unpack operation may drop any padding introduced by the pack
  operation and hence the following holds
  `NumElementsOf(source) >= NumElementsOf(result)`.
  
  Examples:
  
  ```mlir
  // NCnc to NC:
  %0 = linalg.unpack %source inner_dims_pos = [0, 1] inner_tiles = [8, 32]
      into %dest : tensor<16x8 x 8x32 xf32> -> tensor<128x256xf32>
  //                      \  /   \  /
  //          Outer Dims: 16x8  Inner Dims: 8x32
  
  // CK to KCck:
  %0 = linalg.unpack %source outer_dims_perm = [1, 0] inner_dims_pos = [0, 1]
      inner_tiles = [8, 32]
      into %dest : tensor<8x16 x 8x32 xf32> -> tensor<128x256xf32>
  //                      \  /   \  /
  //          Outer Dims: 8x16  Inner Dims: 8x32
  
  // CHW to CHWhw:
  %0 = linalg.unpack %source inner_dims_pos = [2, 1] inner_tiles = [4, 2]
      into %dest : tensor<3x10x6 x 4x2 xf32> -> tensor<3x20x24xf32>
  //                       \  /    \ /
  //          Outer Dims: 3x10x6  Inner Dims: 4x2
  
  // HCW to HCWhw
  %0 = linalg.unpack %source inner_dims_pos = [2, 0] inner_tiles = [4, 2]
      into %dest : tensor<9x3x8 x 4x2 xf32> -> tensor<18x3x32xf32>
  //                       \  /   \ /
  //          Outer Dims: 9x3x8   Inner Dims: 4x2
  ```
  """

  OPERATION_NAME = "linalg.unpack"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, dest, inner_dims_pos, inner_tiles, static_inner_tiles, *, outer_dims_perm=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(dest)
    operands.extend(_get_op_results_or_values(inner_tiles))
    _ods_context = _ods_get_default_loc_context(loc)
    if outer_dims_perm is not None: attributes["outer_dims_perm"] = (outer_dims_perm if (
        isinstance(outer_dims_perm, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(outer_dims_perm, context=_ods_context))
    attributes["inner_dims_pos"] = (inner_dims_pos if (
    isinstance(inner_dims_pos, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(inner_dims_pos, context=_ods_context))
    attributes["static_inner_tiles"] = (static_inner_tiles if (
    isinstance(static_inner_tiles, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(static_inner_tiles, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def dest(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def inner_tiles(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def outer_dims_perm(self) -> _Optional[_ods_ir.DenseI64ArrayAttr]:
    if "outer_dims_perm" not in self.operation.attributes:
      return None
    return self.operation.attributes["outer_dims_perm"]

  @outer_dims_perm.setter
  def outer_dims_perm(self, value: _Optional[_ods_ir.DenseI64ArrayAttr]):
    if value is not None:
      self.operation.attributes["outer_dims_perm"] = value
    elif "outer_dims_perm" in self.operation.attributes:
      del self.operation.attributes["outer_dims_perm"]

  @outer_dims_perm.deleter
  def outer_dims_perm(self):
    del self.operation.attributes["outer_dims_perm"]

  @builtins.property
  def inner_dims_pos(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["inner_dims_pos"]

  @inner_dims_pos.setter
  def inner_dims_pos(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inner_dims_pos"] = value

  @builtins.property
  def static_inner_tiles(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["static_inner_tiles"]

  @static_inner_tiles.setter
  def static_inner_tiles(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["static_inner_tiles"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def unpack(source, dest, inner_dims_pos, inner_tiles, static_inner_tiles, *, outer_dims_perm=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return UnPackOp(source=source, dest=dest, inner_dims_pos=inner_dims_pos, inner_tiles=inner_tiles, static_inner_tiles=static_inner_tiles, outer_dims_perm=outer_dims_perm, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class WinogradFilterTransformOp(_ods_ir.OpView):
  r"""
  Winograd Conv2D algorithm will convert linalg Conv2D operator into batched
  matrix multiply. Before the matrix multiply, it will convert filter and
  input into a format suitable for batched matrix multiply. After the matrix
  multiply, it will convert output to the final result tensor.
  
  The algorithm F(m x m, r x r) is
  
  Y = A^T x [(G x g x G^T) @ (B^T x d x B)] x A
  
  The size of output Y is m x m. The size of filter g is r x r. The size of
  input d is (m + r - 1) x (m + r - 1). A^T, A, G^T, G, B^T, and B are
  transformation matrices.
  
  This operator is defined to represent the high level concept of filter
  transformation (G x g x G^T) in the Winograd Conv2D algorithm.
  """

  OPERATION_NAME = "linalg.winograd_filter_transform"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, filter, output, fmr, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(filter)
    operands.append(output)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["fmr"] = (fmr if (
    isinstance(fmr, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('WinogradConv2DFmr')) else
      _ods_ir.AttrBuilder.get('WinogradConv2DFmr')(fmr, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def filter(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def fmr(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fmr"]

  @fmr.setter
  def fmr(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fmr"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def winograd_filter_transform(result, filter, output, fmr, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return WinogradFilterTransformOp(result=result, filter=filter, output=output, fmr=fmr, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class WinogradInputTransformOp(_ods_ir.OpView):
  r"""
  Winograd Conv2D algorithm will convert linalg Conv2D operator into batched
  matrix multiply. Before the matrix multiply, it will convert filter and
  input into a format suitable for batched matrix multiply. After the matrix
  multiply, it will convert output to the final result tensor.
  
  The algorithm F(m x m, r x r) is
  
  Y = A^T x [(G x g x G^T) @ (B^T x d x B)] x A
  
  The size of output Y is m x m. The size of filter g is r x r. The size of
  input d is (m + r - 1) x (m + r - 1). A^T, A, G^T, G, B^T, and B are
  transformation matrices.
  
  This operator is defined to represent the high level concept of input
  transformation (B^T x d x B) in the Winograd Conv2D algorithm.
  """

  OPERATION_NAME = "linalg.winograd_input_transform"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, output, fmr, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(output)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["fmr"] = (fmr if (
    isinstance(fmr, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('WinogradConv2DFmr')) else
      _ods_ir.AttrBuilder.get('WinogradConv2DFmr')(fmr, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def fmr(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fmr"]

  @fmr.setter
  def fmr(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fmr"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def winograd_input_transform(result, input, output, fmr, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return WinogradInputTransformOp(result=result, input=input, output=output, fmr=fmr, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class WinogradOutputTransformOp(_ods_ir.OpView):
  r"""
  Winograd Conv2D algorithm will convert linalg Conv2D operator into batched
  matrix multiply. Before the matrix multiply, it will convert filter and
  input into a format suitable for batched matrix multiply. After the matrix
  multiply, it will convert output to the final result tensor.
  
  The algorithm F(m x m, r x r) is
  
  Y = A^T x [(G x g x G^T) @ (B^T x d x B)] x A
  
  The size of output Y is m x m. The size of filter g is r x r. The size of
  input d is (m + r - 1) x (m + r - 1). A^T, A, G^T, G, B^T, and B are
  transformation matrices.
  
  This operator is defined to represent the high level concept of output
  transformation (A^T x y x A) in the Winograd Conv2D algorithm.
  """

  OPERATION_NAME = "linalg.winograd_output_transform"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, output, fmr, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(output)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["fmr"] = (fmr if (
    isinstance(fmr, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('WinogradConv2DFmr')) else
      _ods_ir.AttrBuilder.get('WinogradConv2DFmr')(fmr, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def fmr(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fmr"]

  @fmr.setter
  def fmr(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fmr"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def winograd_output_transform(result, value, output, fmr, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return WinogradOutputTransformOp(result=result, value=value, output=output, fmr=fmr, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  r"""
  `linalg.yield` is a special terminator operation for blocks inside regions
  in `linalg` generic ops. It returns values to the immediately enclosing
  `linalg` generic op.
  
  Example:
  
  ```mlir
  linalg.yield %f0, %f1 : f32, f32
  ```
  """

  OPERATION_NAME = "linalg.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(values))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def values(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def yield_(values, *, loc=None, ip=None) -> YieldOp:
  return YieldOp(values=values, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class LogOp(_ods_ir.OpView):
  r"""
  No numeric casting is performed on the input operand.
  """

  OPERATION_NAME = "linalg.log"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def log(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, LogOp]:
  op = LogOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class MapOp(_ods_ir.OpView):
  r"""
  Models elementwise operations on tensors in terms of arithmetic operations
  on the corresponding elements.
  
  Example:
  ```mlir
    %add = linalg.map
        ins(%lhs, %rhs : tensor<64xf32>, tensor<64xf32>)
        outs(%init: tensor<64xf32>)
        (%lhs_elem: f32, %rhs_elem: f32) {
          %0 = arith.addf %lhs_elem, %rhs_elem: f32
          linalg.yield %0: f32
        }
  ```
  
  Shortened print form is available for simple maps where the body contains exactly
  two operations (the payload operation and a yield), the payload operation has
  the same number of operands as block arguments with operands matching block
  arguments in order, and the yield operand is the result of the payload operation.
  
  The example above will be printed using the shortened form as:
  ```mlir
    %add = linalg.map { arith.addf }
        ins(%lhs, %rhs : tensor<64xf32>, tensor<64xf32>)
        outs(%init: tensor<64xf32>)
  ```
  """

  OPERATION_NAME = "linalg.map"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, inputs, init, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    operands.append(init)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def init(self) -> _ods_ir.Value:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1 + _ods_variadic_group_length - 1]

  @builtins.property
  def result(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def mapper(self) -> _ods_ir.Region:
    return self.regions[0]

def map(result, inputs, init, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, MapOp]:
  op = MapOp(result=result, inputs=inputs, init=init, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class MatmulOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply,
  promoting them to the same data type as the accumulator/output.
  
  Broadcast and Transpose semantics can be appiled by specifying the explicit attribute
  'indexing_maps' as shown below.This is a list attribute, so the list must include all
  the maps if specified.
  
  Example Transpose:
  ```mlir
  linalg.matmul
      indexing_maps = [affine_map<(m, n, k) -> (k, m)>, // transpose
                       affine_map<(m, n, k) -> (k, n)>,
                       affine_map<(m, n, k) -> (m, n)>]
      ins(%arg0, %arg1 : memref<5x3xf32>,memref<5x7xf32>)
      outs(%arg2: memref<3x7xf32>)
   ```
  
  Example Broadcast:
   ```mlir
  linalg.matmul
      indexing_maps = [affine_map<(m, n, k) -> (k)>,     // broadcast
                       affine_map<(m, n, k) -> (k, n)>,
                       affine_map<(m, n, k) -> (m, n)>]
      ins(%arg0, %arg1 : memref<3xf32>, memref<5x7xf32>)
      outs(%arg2: memref<3x7xf32>)
  ```
  
  Example Broadcast and transpose:
  ```mlir
  linalg.matmul
      indexing_maps = [affine_map<(m, n, k) -> (k, m)>, // transpose
                       affine_map<(m, n, k) -> (k)>,    // broadcast
                       affine_map<(m, n, k) -> (m, n)>]
      ins(%arg0, %arg1 : memref<5x3xf32>, memref<7xf32>)
      outs(%arg2: memref<3x7xf32>)
  ```
  """

  OPERATION_NAME = "linalg.matmul"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, indexing_maps=None, cast=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if indexing_maps is not None: attributes["indexing_maps"] = (indexing_maps if (
        isinstance(indexing_maps, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AffineMapArrayAttr')) else
          _ods_ir.AttrBuilder.get('AffineMapArrayAttr')(indexing_maps, context=_ods_context))
    if cast is not None: attributes["cast"] = (cast if (
        isinstance(cast, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TypeFnAttr')) else
          _ods_ir.AttrBuilder.get('TypeFnAttr')(cast, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def indexing_maps(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "indexing_maps" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexing_maps"]

  @indexing_maps.setter
  def indexing_maps(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["indexing_maps"] = value
    elif "indexing_maps" in self.operation.attributes:
      del self.operation.attributes["indexing_maps"]

  @indexing_maps.deleter
  def indexing_maps(self):
    del self.operation.attributes["indexing_maps"]

  @builtins.property
  def cast(self) -> _Optional[_ods_ir.Attribute]:
    if "cast" not in self.operation.attributes:
      return None
    return self.operation.attributes["cast"]

  @cast.setter
  def cast(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["cast"] = value
    elif "cast" in self.operation.attributes:
      del self.operation.attributes["cast"]

  @cast.deleter
  def cast(self):
    del self.operation.attributes["cast"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def matmul(result_tensors, inputs, outputs, *, indexing_maps=None, cast=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, MatmulOp]:
  op = MatmulOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, indexing_maps=indexing_maps, cast=cast, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class MatvecOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.matvec"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def matvec(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, MatvecOp]:
  op = MatvecOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class MaxOp(_ods_ir.OpView):
  r"""
  The shapes and element types must be identical. The appropriate casts,
  broadcasts and reductions should be done previously to calling this op.
  
  This means reduction/broadcast/element cast semantics is explicit. Further
  passes can take that into account when lowering this code. For example,
  a `linalg.broadcast` + `linalg.max` sequence can be lowered to a
  `linalg.generic` with different affine maps for the two operands.
  """

  OPERATION_NAME = "linalg.max"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def max(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, MaxOp]:
  op = MaxOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class MinOp(_ods_ir.OpView):
  r"""
  The shapes and element types must be identical. The appropriate casts,
  broadcasts and reductions should be done previously to calling this op.
  
  This means reduction/broadcast/element cast semantics is explicit. Further
  passes can take that into account when lowering this code. For example,
  a `linalg.broadcast` + `linalg.min` sequence can be lowered to a
  `linalg.generic` with different affine maps for the two operands.
  """

  OPERATION_NAME = "linalg.min"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def min(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, MinOp]:
  op = MinOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class Mmt4DOp(_ods_ir.OpView):
  r"""
  Differences from linalg.matmul:
  * The right hand side is transposed, whence the 't' in 'mmt'.
  * The input and output tensors have a 4D shape instead of a 2D shape. They
    are interpreted as 2D matrices with one level of 2D tile subdivision,
    whence the 2+2=4 dimensions. The inner tile dimensions are identified with
    '0' suffixes below, for instance the LHS matrix shape (M, K, M0, K0) reads
    as: MxK tiles, each of shape M0xK0.
  """

  OPERATION_NAME = "linalg.mmt4d"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def mmt4d(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, Mmt4DOp]:
  op = Mmt4DOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class MulOp(_ods_ir.OpView):
  r"""
  The shapes and element types must be identical. The appropriate casts,
  broadcasts and reductions should be done previously to calling this op.
  
  This means reduction/broadcast/element cast semantics is explicit. Further
  passes can take that into account when lowering this code. For example,
  a `linalg.broadcast` + `linalg.mul` sequence can be lowered to a
  `linalg.generic` with different affine maps for the two operands.
  """

  OPERATION_NAME = "linalg.mul"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def mul(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, MulOp]:
  op = MulOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class NegFOp(_ods_ir.OpView):
  r"""
  No numeric casting is performed on the input operand.
  """

  OPERATION_NAME = "linalg.negf"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def negf(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, NegFOp]:
  op = NegFOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PoolingNchwMaxOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the input operand, promoting it to the same
  data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.pooling_nchw_max"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def pooling_nchw_max(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PoolingNchwMaxOp]:
  op = PoolingNchwMaxOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PoolingNchwSumOp(_ods_ir.OpView):
  r"""
  Layout:
    * Input: NCHW.
    * Kernel: HW.
  
  Numeric casting is performed on the input operand, promoting it to the same
  data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.pooling_nchw_sum"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def pooling_nchw_sum(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PoolingNchwSumOp]:
  op = PoolingNchwSumOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PoolingNcwMaxOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the input operand, promoting it to the same
  data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.pooling_ncw_max"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def pooling_ncw_max(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PoolingNcwMaxOp]:
  op = PoolingNcwMaxOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PoolingNcwSumOp(_ods_ir.OpView):
  r"""
  Layout:
    * Input: NCW.
    * Kernel: W.
  
  Numeric casting is performed on the input operand, promoting it to the same
  data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.pooling_ncw_sum"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def pooling_ncw_sum(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PoolingNcwSumOp]:
  op = PoolingNcwSumOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PoolingNdhwcMaxOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the input operand, promoting it to the same
  data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.pooling_ndhwc_max"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_818')) else
          _ods_ir.AttrBuilder.get('anonymous_818')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_818')) else
          _ods_ir.AttrBuilder.get('anonymous_818')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def pooling_ndhwc_max(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PoolingNdhwcMaxOp]:
  op = PoolingNdhwcMaxOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PoolingNdhwcMinOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the input operand, promoting it to the same
  data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.pooling_ndhwc_min"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_818')) else
          _ods_ir.AttrBuilder.get('anonymous_818')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_818')) else
          _ods_ir.AttrBuilder.get('anonymous_818')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def pooling_ndhwc_min(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PoolingNdhwcMinOp]:
  op = PoolingNdhwcMinOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PoolingNdhwcSumOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the input operand, promoting it to the same
  data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.pooling_ndhwc_sum"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_818')) else
          _ods_ir.AttrBuilder.get('anonymous_818')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_818')) else
          _ods_ir.AttrBuilder.get('anonymous_818')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def pooling_ndhwc_sum(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PoolingNdhwcSumOp]:
  op = PoolingNdhwcSumOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PoolingNhwcMaxOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the input operand, promoting it to the same
  data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.pooling_nhwc_max"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def pooling_nhwc_max(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PoolingNhwcMaxOp]:
  op = PoolingNhwcMaxOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PoolingNhwcMaxUnsignedOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the input operand, promoting it to the same
  data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.pooling_nhwc_max_unsigned"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def pooling_nhwc_max_unsigned(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PoolingNhwcMaxUnsignedOp]:
  op = PoolingNhwcMaxUnsignedOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PoolingNhwcMinOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the input operand, promoting it to the same
  data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.pooling_nhwc_min"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def pooling_nhwc_min(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PoolingNhwcMinOp]:
  op = PoolingNhwcMinOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PoolingNhwcMinUnsignedOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the input operand, promoting it to the same
  data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.pooling_nhwc_min_unsigned"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def pooling_nhwc_min_unsigned(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PoolingNhwcMinUnsignedOp]:
  op = PoolingNhwcMinUnsignedOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PoolingNhwcSumOp(_ods_ir.OpView):
  r"""
  Layout:
    * Input: NHWC.
    * Kernel: HW.
  
  Numeric casting is performed on the input operand, promoting it to the same
  data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.pooling_nhwc_sum"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_781')) else
          _ods_ir.AttrBuilder.get('anonymous_781')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def pooling_nhwc_sum(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PoolingNhwcSumOp]:
  op = PoolingNhwcSumOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PoolingNwcMaxOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the input operand, promoting it to the same
  data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.pooling_nwc_max"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def pooling_nwc_max(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PoolingNwcMaxOp]:
  op = PoolingNwcMaxOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PoolingNwcMaxUnsignedOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the input operand, promoting it to the same
  data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.pooling_nwc_max_unsigned"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def pooling_nwc_max_unsigned(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PoolingNwcMaxUnsignedOp]:
  op = PoolingNwcMaxUnsignedOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PoolingNwcMinOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the input operand, promoting it to the same
  data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.pooling_nwc_min"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def pooling_nwc_min(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PoolingNwcMinOp]:
  op = PoolingNwcMinOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PoolingNwcMinUnsignedOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the input operand, promoting it to the same
  data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.pooling_nwc_min_unsigned"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def pooling_nwc_min_unsigned(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PoolingNwcMinUnsignedOp]:
  op = PoolingNwcMinUnsignedOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PoolingNwcSumOp(_ods_ir.OpView):
  r"""
  Layout:
    * Input: NWC.
    * Kernel: W.
  
  Numeric casting is performed on the input operand, promoting it to the same
  data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.pooling_nwc_sum"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if strides is not None: attributes["strides"] = (strides if (
        isinstance(strides, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(strides, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        isinstance(dilations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_771')) else
          _ods_ir.AttrBuilder.get('anonymous_771')(dilations, context=_ods_context))
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def strides(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "strides" not in self.operation.attributes:
      return None
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["strides"] = value
    elif "strides" in self.operation.attributes:
      del self.operation.attributes["strides"]

  @strides.deleter
  def strides(self):
    del self.operation.attributes["strides"]

  @builtins.property
  def dilations(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def pooling_nwc_sum(result_tensors, inputs, outputs, *, strides=None, dilations=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PoolingNwcSumOp]:
  op = PoolingNwcSumOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, strides=strides, dilations=dilations, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PowFOp(_ods_ir.OpView):
  r"""
  Only applies to floating point values.
  
  The shapes and element types must be identical. The appropriate casts,
  broadcasts and reductions should be done previously to calling this op.
  
  This means reduction/broadcast/element cast semantics is explicit. Further
  passes can take that into account when lowering this code. For example,
  a `linalg.broadcast` + `linalg.powf` sequence can be lowered to a
  `linalg.generic` with different affine maps for the two operands.
  """

  OPERATION_NAME = "linalg.powf"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def powf(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PowFOp]:
  op = PowFOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class QuantizedBatchMatmulOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output. The quantized variant
  includes zero-point adjustments for the left and right operands of the
  matmul.
  """

  OPERATION_NAME = "linalg.quantized_batch_matmul"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def quantized_batch_matmul(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, QuantizedBatchMatmulOp]:
  op = QuantizedBatchMatmulOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class QuantizedMatmulOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output. The quantized variant
  includes zero-point adjustments for the left and right operands of the
  matmul.
  """

  OPERATION_NAME = "linalg.quantized_matmul"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def quantized_matmul(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, QuantizedMatmulOp]:
  op = QuantizedMatmulOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ReciprocalOp(_ods_ir.OpView):
  r"""
  No numeric casting is performed on the input operand.
  """

  OPERATION_NAME = "linalg.reciprocal"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def reciprocal(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ReciprocalOp]:
  op = ReciprocalOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ReduceOp(_ods_ir.OpView):
  r"""
  Executes `combiner` on the `dimensions` of `inputs` and returns the
  reduced result. The `dimensions` attribute needs to list the reduction
  dimensions in increasing order.
  
  Example:
  ```mlir
    %reduce = linalg.reduce
        ins(%input:tensor<16x32x64xf32>)
        outs(%init:tensor<16x64xf32>)
        dimensions = [1]
        (%in: f32, %out: f32) {
          %0 = arith.addf %out, %in: f32
          linalg.yield %0: f32
        }
  ```
  
  Shortened print form is available for simple reduces where the body contains exactly
  two operations (the payload operation and a yield), the payload operation has the
  same number of operands as block arguments, the first block argument (init) is the
  last operand of the payload operation with remaining operands matching remaining
  block arguments in order, and the yield operand is the result of the payload operation.
  
  The example above will be printed using the shortened form as:
  ```mlir
    %reduce = linalg.reduce { arith.addf }
        ins(%input:tensor<16x32x64xf32>)
        outs(%init:tensor<16x64xf32>)
        dimensions = [1]
  ```
  """

  OPERATION_NAME = "linalg.reduce"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, inputs, inits, dimensions, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    operands.extend(_get_op_results_or_values(inits))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimensions"] = (dimensions if (
    isinstance(dimensions, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(dimensions, context=_ods_context))
    results = []
    results.extend(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 0, 2, 0, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def inits(self) -> _ods_ir.OpOperandList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 0, 2, 0, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def dimensions(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["dimensions"]

  @dimensions.setter
  def dimensions(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimensions"] = value

  @builtins.property
  def combiner(self) -> _ods_ir.Region:
    return self.regions[0]

def reduce(result, inputs, inits, dimensions, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ReduceOp]:
  op = ReduceOp(result=result, inputs=inputs, inits=inits, dimensions=dimensions, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class RoundOp(_ods_ir.OpView):
  r"""
  No numeric casting is performed on the input operand.
  """

  OPERATION_NAME = "linalg.round"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def round(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, RoundOp]:
  op = RoundOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class RsqrtOp(_ods_ir.OpView):
  r"""
  No numeric casting is performed on the input operand.
  """

  OPERATION_NAME = "linalg.rsqrt"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def rsqrt(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, RsqrtOp]:
  op = RsqrtOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class SelectOp(_ods_ir.OpView):
  r"""
  The shapes and element types must be identical. The appropriate casts,
  broadcasts and reductions should be done previously to calling this op.
  
  This means reduction/broadcast/element cast semantics is explicit. Further
  passes can take that into account when lowering this code. For example,
  a `linalg.broadcast` + `linalg.select` sequence can be lowered to a
  `linalg.generic` with different affine maps for the two operands.
  """

  OPERATION_NAME = "linalg.select"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def select(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, SelectOp]:
  op = SelectOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class SqrtOp(_ods_ir.OpView):
  r"""
  No numeric casting is performed on the input operand.
  """

  OPERATION_NAME = "linalg.sqrt"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def sqrt(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, SqrtOp]:
  op = SqrtOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class SquareOp(_ods_ir.OpView):
  r"""
  No numeric casting is performed on the input operand.
  """

  OPERATION_NAME = "linalg.square"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def square(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, SquareOp]:
  op = SquareOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class SubOp(_ods_ir.OpView):
  r"""
  The shapes and element types must be identical. The appropriate casts,
  broadcasts and reductions should be done previously to calling this op.
  
  This means reduction/broadcast/element cast semantics is explicit. Further
  passes can take that into account when lowering this code. For example,
  a `linalg.broadcast` + `linalg.sub` sequence can be lowered to a
  `linalg.generic` with different affine maps for the two operands.
  """

  OPERATION_NAME = "linalg.sub"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def sub(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, SubOp]:
  op = SubOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class TanhOp(_ods_ir.OpView):
  r"""
  No numeric casting is performed on the input operand.
  """

  OPERATION_NAME = "linalg.tanh"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def tanh(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, TanhOp]:
  op = TanhOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class TransposeOp(_ods_ir.OpView):
  r"""
  Permutes the dimensions of `input` according to the given `permutation`.
    `dim(result, i) = dim(input, permutation[i])`
  
  This op actually moves data, unlike `memref.transpose` which is a metadata
  operation only that produces a transposed "view".
  
  Example:
  ```mlir
    %transpose = linalg.transpose
        ins(%input:tensor<16x64xf32>)
        outs(%init:tensor<64x16xf32>)
        permutation = [1, 0]
  ```
  """

  OPERATION_NAME = "linalg.transpose"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, input, init, permutation, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(init)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["permutation"] = (permutation if (
    isinstance(permutation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(permutation, context=_ods_context))
    results = []
    results.extend(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def init(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def permutation(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["permutation"]

  @permutation.setter
  def permutation(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["permutation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def transpose(result, input, init, permutation, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, TransposeOp]:
  op = TransposeOp(result=result, input=input, init=init, permutation=permutation, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class VecmatOp(_ods_ir.OpView):
  r"""
  Numeric casting is performed on the operands to the inner multiply, promoting
  them to the same data type as the accumulator/output.
  """

  OPERATION_NAME = "linalg.vecmat"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_tensors, inputs, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result_tensors)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_tensors(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def vecmat(result_tensors, inputs, outputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, VecmatOp]:
  op = VecmatOp(result_tensors=result_tensors, inputs=inputs, outputs=outputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)
