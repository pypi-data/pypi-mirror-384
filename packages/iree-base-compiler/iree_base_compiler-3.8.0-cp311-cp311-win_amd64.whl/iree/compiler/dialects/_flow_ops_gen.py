
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "flow"

@_ods_cext.register_operation(_Dialect)
class CallOp(_ods_ir.OpView):
  r"""
  Calls a function taking/returning tensor values with stream semantics.
  Tensors have their shapes captured and may be tied to denote in-place
  operations. Asynchronous calls must have no side-effects.
  
  Note that returned tensors must have their shapes declared prior to the call
  as this is what allows the call to be made on the stream. If external host
  logic is required to compute the shape (avoid at all costs!) a separate
  func.call can be used outside of the stream to do so. If shapes are
  unknowable until the operation is performed it should be made as a normal
  asynchronous host call with 'coarse-fences' instead.
  """

  OPERATION_NAME = "flow.call"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, callee, arguments, argument_dims, result_dims, *, tied_operands=None, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(arguments))
    operands.append(_get_op_results_or_values(argument_dims))
    operands.append(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(callee, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def arguments(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def argument_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def callee(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

  @builtins.property
  def tied_operands(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def call(results_, callee, arguments, argument_dims, result_dims, *, tied_operands=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, CallOp]:
  op = CallOp(results_=results_, callee=callee, arguments=arguments, argument_dims=argument_dims, result_dims=result_dims, tied_operands=tied_operands, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ChannelCountOp(_ods_ir.OpView):
  r"""
  Returns the total participant count in the collective communicator group.
  """

  OPERATION_NAME = "flow.channel.count"

  _ODS_REGIONS = (0, True)

  def __init__(self, channel, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(channel)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def channel(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def channel_count(channel, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ChannelCountOp(channel=channel, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ChannelDefaultOp(_ods_ir.OpView):
  r"""
  Returns a channel initialized using the runtime environment.
  """

  OPERATION_NAME = "flow.channel.default"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, group=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if group is not None: attributes["group"] = (group if (
        isinstance(group, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(group, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def group(self) -> _Optional[_ods_ir.StringAttr]:
    if "group" not in self.operation.attributes:
      return None
    return self.operation.attributes["group"]

  @group.setter
  def group(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["group"] = value
    elif "group" in self.operation.attributes:
      del self.operation.attributes["group"]

  @group.deleter
  def group(self):
    del self.operation.attributes["group"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def channel_default(*, group=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ChannelDefaultOp(group=group, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ChannelRankOp(_ods_ir.OpView):
  r"""
  Returns the rank the channel represents as a participant in a collective
  group in `[0, count)`.
  """

  OPERATION_NAME = "flow.channel.rank"

  _ODS_REGIONS = (0, True)

  def __init__(self, channel, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(channel)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def channel(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def channel_rank(channel, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ChannelRankOp(channel=channel, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ChannelSplitOp(_ods_ir.OpView):
  r"""
  Partitions the group associated with the given channel into disjoint
  subgroups for each unique value of color. Each new subgroup contains all
  participants of the same color and within each subgroup the key argument
  is used to define the rank order. When multiple participants in a group
  use the same key the tie will be broken using their rank in the parent
  group.
  """

  OPERATION_NAME = "flow.channel.split"

  _ODS_REGIONS = (0, True)

  def __init__(self, channel, color, key, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(channel)
    operands.append(color)
    operands.append(key)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def channel(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def color(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def key(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def channel_split(channel, color, key, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ChannelSplitOp(channel=channel, color=color, key=key, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CollectiveAllGatherOp(_ods_ir.OpView):
  r"""
  Gathers data from all ranks and concatenates them on the 0-th dimension.
  """

  OPERATION_NAME = "flow.collective.all_gather"

  _ODS_REGIONS = (0, True)

  def __init__(self, element_type, target, target_dims, source, channel, *, tied_operands=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.extend(_get_op_results_or_values(target_dims))
    operands.append(source)
    operands.append(channel)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["element_type"] = (element_type if (
    isinstance(element_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FLOW_CollectiveElementTypeAttr')) else
      _ods_ir.AttrBuilder.get('FLOW_CollectiveElementTypeAttr')(element_type, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_dims(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def source(self) -> _ods_ir.Value:
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def channel(self) -> _ods_ir.Value:
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[3 + _ods_variadic_group_length - 1]

  @builtins.property
  def element_type(self) -> _ods_ir.Attribute:
    return self.operation.attributes["element_type"]

  @element_type.setter
  def element_type(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["element_type"] = value

  @builtins.property
  def tied_operands(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def collective_all_gather(element_type, target, target_dims, source, channel, *, tied_operands=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CollectiveAllGatherOp(element_type=element_type, target=target, target_dims=target_dims, source=source, channel=channel, tied_operands=tied_operands, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CollectiveAllReduceOp(_ods_ir.OpView):
  r"""
  Reduces data across all the ranks in the channel.
  """

  OPERATION_NAME = "flow.collective.all_reduce"

  _ODS_REGIONS = (0, True)

  def __init__(self, reduction_op, element_type, target, target_dims, source, channel, *, tied_operands=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.extend(_get_op_results_or_values(target_dims))
    operands.append(source)
    operands.append(channel)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["reduction_op"] = (reduction_op if (
    isinstance(reduction_op, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FLOW_CollectiveReductionOpAttr')) else
      _ods_ir.AttrBuilder.get('FLOW_CollectiveReductionOpAttr')(reduction_op, context=_ods_context))
    attributes["element_type"] = (element_type if (
    isinstance(element_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FLOW_CollectiveElementTypeAttr')) else
      _ods_ir.AttrBuilder.get('FLOW_CollectiveElementTypeAttr')(element_type, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_dims(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def source(self) -> _ods_ir.Value:
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def channel(self) -> _ods_ir.Value:
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[3 + _ods_variadic_group_length - 1]

  @builtins.property
  def reduction_op(self) -> _ods_ir.Attribute:
    return self.operation.attributes["reduction_op"]

  @reduction_op.setter
  def reduction_op(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reduction_op"] = value

  @builtins.property
  def element_type(self) -> _ods_ir.Attribute:
    return self.operation.attributes["element_type"]

  @element_type.setter
  def element_type(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["element_type"] = value

  @builtins.property
  def tied_operands(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def collective_all_reduce(reduction_op, element_type, target, target_dims, source, channel, *, tied_operands=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CollectiveAllReduceOp(reduction_op=reduction_op, element_type=element_type, target=target, target_dims=target_dims, source=source, channel=channel, tied_operands=tied_operands, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CollectiveAllToAllOp(_ods_ir.OpView):
  r"""
  This operation mutually exchanges data acrosss all of the ranks in the channel.
  """

  OPERATION_NAME = "flow.collective.all_to_all"

  _ODS_REGIONS = (0, True)

  def __init__(self, element_type, target, target_dims, source, channel, *, tied_operands=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.extend(_get_op_results_or_values(target_dims))
    operands.append(source)
    operands.append(channel)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["element_type"] = (element_type if (
    isinstance(element_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FLOW_CollectiveElementTypeAttr')) else
      _ods_ir.AttrBuilder.get('FLOW_CollectiveElementTypeAttr')(element_type, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_dims(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def source(self) -> _ods_ir.Value:
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def channel(self) -> _ods_ir.Value:
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[3 + _ods_variadic_group_length - 1]

  @builtins.property
  def element_type(self) -> _ods_ir.Attribute:
    return self.operation.attributes["element_type"]

  @element_type.setter
  def element_type(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["element_type"] = value

  @builtins.property
  def tied_operands(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def collective_all_to_all(element_type, target, target_dims, source, channel, *, tied_operands=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CollectiveAllToAllOp(element_type=element_type, target=target, target_dims=target_dims, source=source, channel=channel, tied_operands=tied_operands, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CollectiveReduceScatterOp(_ods_ir.OpView):
  r"""
  The operation reduces data across all the ranks in the channel and
      scatters the result to each rank.
  """

  OPERATION_NAME = "flow.collective.reduce_scatter"

  _ODS_REGIONS = (0, True)

  def __init__(self, reduction_op, element_type, target, target_dims, source, channel, *, tied_operands=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.extend(_get_op_results_or_values(target_dims))
    operands.append(source)
    operands.append(channel)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["reduction_op"] = (reduction_op if (
    isinstance(reduction_op, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FLOW_CollectiveReductionOpAttr')) else
      _ods_ir.AttrBuilder.get('FLOW_CollectiveReductionOpAttr')(reduction_op, context=_ods_context))
    attributes["element_type"] = (element_type if (
    isinstance(element_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FLOW_CollectiveElementTypeAttr')) else
      _ods_ir.AttrBuilder.get('FLOW_CollectiveElementTypeAttr')(element_type, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_dims(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def source(self) -> _ods_ir.Value:
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def channel(self) -> _ods_ir.Value:
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[3 + _ods_variadic_group_length - 1]

  @builtins.property
  def reduction_op(self) -> _ods_ir.Attribute:
    return self.operation.attributes["reduction_op"]

  @reduction_op.setter
  def reduction_op(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reduction_op"] = value

  @builtins.property
  def element_type(self) -> _ods_ir.Attribute:
    return self.operation.attributes["element_type"]

  @element_type.setter
  def element_type(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["element_type"] = value

  @builtins.property
  def tied_operands(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def collective_reduce_scatter(reduction_op, element_type, target, target_dims, source, channel, *, tied_operands=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CollectiveReduceScatterOp(reduction_op=reduction_op, element_type=element_type, target=target, target_dims=target_dims, source=source, channel=channel, tied_operands=tied_operands, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CollectiveSendRecvOp(_ods_ir.OpView):
  r"""
  The operation sends data to the rank specificied by send
      and receives data from the rank specified by recv. If send is -1, this rank
      will not send any data. If recv is -1, this rank will not receive any data
      and the output will be all zeros.
  """

  OPERATION_NAME = "flow.collective.send_recv"

  _ODS_REGIONS = (0, True)

  def __init__(self, element_type, target, target_dims, source, channel, send, recv, *, tied_operands=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.extend(_get_op_results_or_values(target_dims))
    operands.append(source)
    operands.append(channel)
    operands.append(send)
    operands.append(recv)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["element_type"] = (element_type if (
    isinstance(element_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FLOW_CollectiveElementTypeAttr')) else
      _ods_ir.AttrBuilder.get('FLOW_CollectiveElementTypeAttr')(element_type, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target_dims(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 6 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def source(self) -> _ods_ir.Value:
    _ods_variadic_group_length = len(self.operation.operands) - 6 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def channel(self) -> _ods_ir.Value:
    _ods_variadic_group_length = len(self.operation.operands) - 6 + 1
    return self.operation.operands[3 + _ods_variadic_group_length - 1]

  @builtins.property
  def send(self) -> _ods_ir.Value:
    _ods_variadic_group_length = len(self.operation.operands) - 6 + 1
    return self.operation.operands[4 + _ods_variadic_group_length - 1]

  @builtins.property
  def recv(self) -> _ods_ir.Value:
    _ods_variadic_group_length = len(self.operation.operands) - 6 + 1
    return self.operation.operands[5 + _ods_variadic_group_length - 1]

  @builtins.property
  def element_type(self) -> _ods_ir.Attribute:
    return self.operation.attributes["element_type"]

  @element_type.setter
  def element_type(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["element_type"] = value

  @builtins.property
  def tied_operands(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def collective_send_recv(element_type, target, target_dims, source, channel, send, recv, *, tied_operands=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CollectiveSendRecvOp(element_type=element_type, target=target, target_dims=target_dims, source=source, channel=channel, send=send, recv=recv, tied_operands=tied_operands, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DispatchOp(_ods_ir.OpView):
  r"""
  Dispatches workgroups across an grid defined by the captured workload
  parameters carrying the information required to compute the workgroup count
  at runtime. The function for converting the workload into a 3D workgroup
  count is attached to the dispatch entry point and may contain
  arbitrary host logic.
  """

  OPERATION_NAME = "flow.dispatch"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, workload, entry_points, arguments, argument_dims, result_dims, *, tied_operands=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(workload))
    operands.append(_get_op_results_or_values(arguments))
    operands.append(_get_op_results_or_values(argument_dims))
    operands.append(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["entry_points"] = (entry_points if (
    isinstance(entry_points, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(entry_points, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def workload(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def arguments(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def argument_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def result_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def entry_points(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["entry_points"]

  @entry_points.setter
  def entry_points(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["entry_points"] = value

  @builtins.property
  def tied_operands(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def dispatch(results_, workload, entry_points, arguments, argument_dims, result_dims, *, tied_operands=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, DispatchOp]:
  op = DispatchOp(results_=results_, workload=workload, entry_points=entry_points, arguments=arguments, argument_dims=argument_dims, result_dims=result_dims, tied_operands=tied_operands, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DispatchRegionOp(_ods_ir.OpView):
  r"""
  This op is a container/grouping of ops. It represents a fusion group before
  being lowered to a dispatch region. Ops are collected inside of the region
  body of the op. Values from parent regions can be captured. Results are
  yielded with a `return` terminator and returned from this op.
  
  `dispatch.region` ops are lowered to `dispatch.workgroups` ops. Workgroups
  isolated from above. `dispatch.region` ops are a more lightweight
  abstraction for implementing fusion heuristics, i.e., the process of
  deciding which ops should form a dispatch region.
  
  This op also has a second region: `workload_count`. The arguments to the
  region represent the workload for the dispatch, and returns the number of
  workgroups for the dispatch. The region is lowered directly to
  `workload_count` region of `dispatch.workgroups`.
  """

  OPERATION_NAME = "flow.dispatch.region"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (2, True)

  def __init__(self, result, result_dims, workload, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(result_dims))
    operands.append(_get_op_results_or_values(workload))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def workload(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def workgroup_count(self) -> _ods_ir.Region:
    return self.regions[1]

def dispatch_region(result, result_dims, workload, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, DispatchRegionOp]:
  op = DispatchRegionOp(result=result, result_dims=result_dims, workload=workload, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DispatchTieShapeOp(_ods_ir.OpView):
  r"""
  Metadata op used to tie a runtime-computed shape with dynamic dimensions to
  a dispatch input/output argument. All uses of the argument should use the
  pass-through result of this op to allow for SSA-based shape resolution.
  """

  OPERATION_NAME = "flow.dispatch.tie_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, dynamic_dims, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.extend(_get_op_results_or_values(dynamic_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def dynamic_dims(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def dispatch_tie_shape(operand, dynamic_dims, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DispatchTieShapeOp(operand=operand, dynamic_dims=dynamic_dims, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DispatchWorkgroupCountOp(_ods_ir.OpView):
  r"""
  The total number of workgroups along each dimension in the dispatch grid.
  
  Represented as a 3D grid classically written as XYZ.
  Corresponds to the `NumWorkgroups` SPIR-V built-in and the `gridDim` CUDA
  built-in variable.
  
  ```mlir
  %x = flow.dispatch.workgroup.count[0] : index
  %y = flow.dispatch.workgroup.count[1] : index
  %z = flow.dispatch.workgroup.count[2] : index
  ```
  """

  OPERATION_NAME = "flow.dispatch.workgroup.count"

  _ODS_REGIONS = (0, True)

  def __init__(self, dimension, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(dimension, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dimension(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def dispatch_workgroup_count(dimension, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DispatchWorkgroupCountOp(dimension=dimension, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DispatchWorkgroupIDOp(_ods_ir.OpView):
  r"""
  The global workgroup ID of the current workgroup in the range of
  `[0, flow.dispatch.workgroup.count)` along each dimension.
  
  Represented as a 3D grid classically written as XYZ.
  Corresponds to the `WorkgroupId` SPIR-V built-in and the `blockIdx` CUDA
  built-in variable.
  
  ```mlir
  %x = flow.dispatch.workgroup.id[0] : index
  %y = flow.dispatch.workgroup.id[1] : index
  %z = flow.dispatch.workgroup.id[2] : index
  ```
  """

  OPERATION_NAME = "flow.dispatch.workgroup.id"

  _ODS_REGIONS = (0, True)

  def __init__(self, dimension, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(dimension, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dimension(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def dispatch_workgroup_id(dimension, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DispatchWorkgroupIDOp(dimension=dimension, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DispatchWorkgroupSizeOp(_ods_ir.OpView):
  r"""
  The number of local invocations within the current workgroup along each
  dimension. Depending on backend this may map to the SIMT thread count or
  inner loop nest parameters.
  
  Workgroup sizes are not determined at the flow dialect level as they are
  dependent on the target backend determined when lowering into the HAL. It's
  still possible to use the symbolic workgroup size inside of dispatch
  executables as a placeholder for the resolved value once in the HAL.
  
  Represented as a 3D grid classically written as XYZ.
  Corresponds to the `WorkgroupSize` SPIR-V built-in and the `blockDim` CUDA
  built-in variable.
  
  ```mlir
  %x = flow.dispatch.workgroup.size[0] : index
  %y = flow.dispatch.workgroup.size[1] : index
  %z = flow.dispatch.workgroup.size[2] : index
  ```
  """

  OPERATION_NAME = "flow.dispatch.workgroup.size"

  _ODS_REGIONS = (0, True)

  def __init__(self, dimension, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(dimension, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dimension(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def dispatch_workgroup_size(dimension, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DispatchWorkgroupSizeOp(dimension=dimension, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DispatchWorkgroupsOp(_ods_ir.OpView):
  r"""
  Dispatches some number of workgroups across a 3-dimensional grid. The
  body region will be invoked for each workgroup with a unique
  `flow.dispatch.workgroup.id` in the range of
  `[0, flow.dispatch.workgroup.count)` (along each dimension XYZ).
  
  From the outside the dispatch operation has value semantics: some tensors
  (and optionally other primitive types) are consumed and one or more new
  result tensors are produced. Inside each workgroup, however, the input and
  output tensors are available for arbitrary loads and stores. In many cases
  each workgroup will load some particular tile(s) from the input tensors and
  store some particular tile(s) to the output tensors unique to that
  workgroup. Though it's possible for multiple workgroups to load the same
  regions of the input tensors behavior is undefined if multiple workgroups
  store to the same regions of the output tensors.
  
  Though the representation is similar to the GPU-style grid dispatch model
  here we still have not yet allocated buffers, determined the target device
  for execution, or even completed fully resolving shapes/types/etc. Because
  of this it's important that the workgroup body use the
  `flow.dispatch.workgroup.*` ops to query the workgroup ID/count/size instead
  of hardcoding them to a particular set of values. Assume that any workgroup
  dispatch may end up being specialized for several different target devices
  and even several different variants for a particular target device
  (differing workgroup sizes, etc).
  
  Because at this point in the layering devices have not yet been selected the
  workgroup count cannot be fully evaluated. Instead workload parameters are
  captured that are then passed to a function that when later evaluated
  computes the actual workgroup count based on target information. The
  workload is not limited to the 3D XYZ grid dispatch of the workgroup count
  and can contain any number of parameters used to compute it.
  
  ```mlir
  %r = flow.dispatch.workgroups[%c5, %c5](%0, %1)
      : (tensor<5x5xf32>, tensor<5xf32>) -> tensor<5x5xf32> =
            (%arg0: !iree_tensor_ext.dispatch.tensor<readonly:tensor<5x5xf32>>,
             %arg1: !iree_tensor_ext.dispatch.tensor<readonly:tensor<5xf32>>,
             %arg2: !iree_tensor_ext.dispatch.tensor<writeonly:tensor<5x5xf32>>) {
    ...
  }
  ```
  
  The number of results of the operation is equal to the number of results
  in the type signature (`(tensor<5x5xf32>, tensor<5xf32>) -> tensor<5x5xf32>`).
  Each tensor argument and result in the type signature has a corresponding
  block argument of type `!iree_tensor_ext.dispatch.tensor`. Furthermore, each argument
  has a corresponding `arguments` operand.
  
  There are no `arguments` operands for results, but a result can be tied an
  argument by writing the argument operand's SSA value instead of its type:
  E.g., in the above example, `-> %0` would tie the first argument to the
  result. In that case, there would be no separate block argument for the
  result.
  """

  OPERATION_NAME = "flow.dispatch.workgroups"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,]

  _ODS_REGIONS = (2, True)

  def __init__(self, results_, workload, arguments, argument_dims, result_dims, *, tied_operands=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(workload))
    operands.append(_get_op_results_or_values(arguments))
    operands.append(_get_op_results_or_values(argument_dims))
    operands.append(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def workload(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def arguments(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def argument_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def result_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def tied_operands(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def workgroup_body(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def workgroup_count(self) -> _ods_ir.Region:
    return self.regions[1]

def dispatch_workgroups(results_, workload, arguments, argument_dims, result_dims, *, tied_operands=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, DispatchWorkgroupsOp]:
  op = DispatchWorkgroupsOp(results_=results_, workload=workload, arguments=arguments, argument_dims=argument_dims, result_dims=result_dims, tied_operands=tied_operands, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ExecutableEndOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.executable_end"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def executable_end(*, loc=None, ip=None) -> ExecutableEndOp:
  return ExecutableEndOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableExportOp(_ods_ir.OpView):
  r"""
  Specifies an exported function with an externally-visible alias. Multiple
  exports can reference the same internal function.
  
  Each entry point can have a unique workgroup count calculation region.
  This region takes the workload parameters passed to each flow.dispatch and
  produces an XYZ workgroup count for the 3D grid dispatch.
  """

  OPERATION_NAME = "flow.executable.export"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_ref, *, sym_visibility=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_ref"] = (function_ref if (
    isinstance(function_ref, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(function_ref, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_ref(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["function_ref"]

  @function_ref.setter
  def function_ref(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_ref"] = value

  @builtins.property
  def workgroup_count(self) -> _ods_ir.Region:
    return self.regions[0]

def executable_export(sym_name, function_ref, *, sym_visibility=None, loc=None, ip=None) -> ExecutableExportOp:
  return ExecutableExportOp(sym_name=sym_name, function_ref=function_ref, sym_visibility=sym_visibility, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableOp(_ods_ir.OpView):
  r"""
  An executable module containing one or more public functions. The contents
  of the functions are safe to dispatch and can be lowered further to
  target-specific backend IR representations.
  """

  OPERATION_NAME = "flow.executable"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, *, sym_visibility=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def executable(sym_name, *, sym_visibility=None, loc=None, ip=None) -> ExecutableOp:
  return ExecutableOp(sym_name=sym_name, sym_visibility=sym_visibility, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FuncOp(_ods_ir.OpView):
  r"""
  Declares a function that can be called as an asynchronous streaming
  operation via `flow.call`. Today only external functions are allowed.
  """

  OPERATION_NAME = "flow.func"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_type, *, tied_operands=None, sym_visibility=None, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_659')) else
      _ods_ir.AttrBuilder.get('anonymous_659')(function_type, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def tied_operands(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def func(sym_name, function_type, *, tied_operands=None, sym_visibility=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> FuncOp:
  return FuncOp(sym_name=sym_name, function_type=function_type, tied_operands=tied_operands, sym_visibility=sym_visibility, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ReturnOp(_ods_ir.OpView):
  r"""
  Returns the given values from the region and back to the host code.
  """

  OPERATION_NAME = "flow.return"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def return_(operands_, *, loc=None, ip=None) -> ReturnOp:
  return ReturnOp(operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TensorAllocaOp(_ods_ir.OpView):
  r"""
  Returns a new transient tensor allocation with undefined contents.
  Subsequent writes must populate any ranges of the tensor that are later
  read. The resulting tensor may be long-lived and allocated as part of a
  dedicated allocation. Prefer using `flow.tensor.empty` whenever possible as
  this op disables nearly all allocation-related optimizations performed by
  the compiler. The presence of this op is often an indication of an improper
  lowering.
  """

  OPERATION_NAME = "flow.tensor.alloca"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, result_dims, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result_dims(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_alloca(result, result_dims, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorAllocaOp(result=result, result_dims=result_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorBarrierOp(_ods_ir.OpView):
  r"""
  Prevents fusion and scheduling of a value across an affinity boundary.
  May introduce copy-on-write behavior if the operand value is used as well as
  the result and users should try to keep the operand to a single use by this
  op.
  """

  OPERATION_NAME = "flow.tensor.barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, operand_dims, target, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.extend(_get_op_results_or_values(operand_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["target"] = (target if (
    isinstance(target, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AnyAttr')) else
      _ods_ir.AttrBuilder.get('AnyAttr')(target, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand_dims(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def target(self) -> _ods_ir.Attribute:
    return self.operation.attributes["target"]

  @target.setter
  def target(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_barrier(operand, operand_dims, target, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorBarrierOp(operand=operand, operand_dims=operand_dims, target=target, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorBitCastOp(_ods_ir.OpView):
  r"""
  Bitcasts a tensor |source| to the shape implied by this operations result
  type interleaved with |result_dims|, potentially with a different element
  type. For example,
  
  ```
  result_dims = {%0, %1}
  result_type = tensor<1x?x2x?x3 x!eltype>
  ```
  
  produces a tensor of shape [1, %0, 2, %1, 3] and element type `!eltype`.
  Note that the source and result tensors must serialized to the same size.
  """

  OPERATION_NAME = "flow.tensor.bitcast"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_dims, result_dims, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(_get_op_results_or_values(source_dims))
    operands.append(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_bitcast(result, source, source_dims, result_dims, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorBitCastOp(result=result, source=source, source_dims=source_dims, result_dims=result_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorCloneOp(_ods_ir.OpView):
  r"""
  Clones the input tensor into an identical output tensor.
  """

  OPERATION_NAME = "flow.tensor.clone"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, operand_dims, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.extend(_get_op_results_or_values(operand_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand_dims(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_clone(operand, operand_dims, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorCloneOp(operand=operand, operand_dims=operand_dims, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorConstantOp(_ods_ir.OpView):
  r"""
  Allows specifying a tensor constant of IREE-specific types/attributes.
  
  ```mlir
  %cst = flow.tensor.constant #something_tensor_like : tensor<2x2xf32>
  %res = math.absf %cst : tensor<2x2xf32>
  ```
  """

  OPERATION_NAME = "flow.tensor.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypedAttrInterface')) else
      _ods_ir.AttrBuilder.get('TypedAttrInterface')(value, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_constant(value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorConstantOp(value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorDynamicConstantOp(_ods_ir.OpView):
  r"""
  Allows specifying a tensor constant of IREE-specific types/attributes with
  a dynamic shape that approximates a value as passed from the user. This
  disables many optimizations and should only be used when testing or
  benchmarking and wanting to ensure that dynamic dimension behavior is
  preserved.
  
  ```mlir
  %cst = flow.tensor.dynamic_constant #something_tensor_like : tensor<2x2xf32> -> tensor<?x2xf32>
  %res = math.absf %cst : tensor<?x2xf32>
  ```
  """

  OPERATION_NAME = "flow.tensor.dynamic_constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypedAttrInterface')) else
      _ods_ir.AttrBuilder.get('TypedAttrInterface')(value, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_dynamic_constant(result, value, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorDynamicConstantOp(result=result, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorEmptyOp(_ods_ir.OpView):
  r"""
  Returns a tensor with undefined contents. Subsequent writes must populate
  any ranges of the tensor that are later read.
  """

  OPERATION_NAME = "flow.tensor.empty"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, result_dims, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result_dims(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_empty(result, result_dims, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorEmptyOp(result=result, result_dims=result_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorEncodeOp(_ods_ir.OpView):
  r"""
  Encode the input tensor into an encoded output tensor.
  """

  OPERATION_NAME = "flow.tensor.encode"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, operand_dims, result_dims, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(_get_op_results_or_values(operand_dims))
    operands.append(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def operand_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_encode(result, operand, operand_dims, result_dims, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorEncodeOp(result=result, operand=operand, operand_dims=operand_dims, result_dims=result_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorLoadOp(_ods_ir.OpView):
  r"""
  Returns the element at the given location from within the tensor.
  """

  OPERATION_NAME = "flow.tensor.load"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_dims, indices, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(_get_op_results_or_values(source_dims))
    operands.append(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def indices(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_load(source, source_dims, indices, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorLoadOp(source=source, source_dims=source_dims, indices=indices, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorReshapeOp(_ods_ir.OpView):
  r"""
  Reshapes a tensor |source| to the shape implied by this operations result
  type interleaved with |result_dims|. For example,
  
  ```
  result_dims = {%0, %1}
  result_type = tensor<1x?x2x?x3>
  ```
  
  produces a tensor of shape [1, %0, 2, %1, 3] and the same element type.
  """

  OPERATION_NAME = "flow.tensor.reshape"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_dims, result_dims, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(_get_op_results_or_values(source_dims))
    operands.append(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_reshape(result, source, source_dims, result_dims, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorReshapeOp(result=result, source=source, source_dims=source_dims, result_dims=result_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorSliceOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.tensor.slice"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_dims, start_indices, lengths, result_dims, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(_get_op_results_or_values(source_dims))
    operands.append(_get_op_results_or_values(start_indices))
    operands.append(_get_op_results_or_values(lengths))
    operands.append(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def start_indices(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def lengths(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def result_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_slice(result, source, source_dims, start_indices, lengths, result_dims, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorSliceOp(result=result, source=source, source_dims=source_dims, start_indices=start_indices, lengths=lengths, result_dims=result_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorSplatOp(_ods_ir.OpView):
  r"""
  Returns a tensor initialized to the given primitive value.
  """

  OPERATION_NAME = "flow.tensor.splat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, result_dims, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.extend(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result_dims(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_splat(result, value, result_dims, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorSplatOp(result=result, value=value, result_dims=result_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorStoreOp(_ods_ir.OpView):
  r"""
  Returns a tensor with the element at the given index set to the given value.
  """

  OPERATION_NAME = "flow.tensor.store"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, target, target_dims, indices, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(target)
    operands.append(_get_op_results_or_values(target_dims))
    operands.append(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def target(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def target_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def indices(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_store(value, target, target_dims, indices, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorStoreOp(value=value, target=target, target_dims=target_dims, indices=indices, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorTieShapeOp(_ods_ir.OpView):
  r"""
  Metadata op used to tie tensors with their runtime-computed dynamic
  dimensions. This only exists transiently in the IR as a witness to shape
  calculations and is removed during lowering.
  """

  OPERATION_NAME = "flow.tensor.tie_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, dynamic_dims, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.extend(_get_op_results_or_values(dynamic_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def dynamic_dims(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_tie_shape(operand, dynamic_dims, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorTieShapeOp(operand=operand, dynamic_dims=dynamic_dims, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorTraceOp(_ods_ir.OpView):
  r"""
  Traces out to a runtime trace sink (console, log file, etc) the given
  tensors. The key is arbitrary and can be used for identifying the set of
  values being traced.
  """

  OPERATION_NAME = "flow.tensor.trace"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, key, values, value_dims, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(values))
    operands.append(_get_op_results_or_values(value_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["key"] = (key if (
    isinstance(key, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(key, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def values(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def value_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def key(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["key"]

  @key.setter
  def key(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["key"] = value

def tensor_trace(key, values, value_dims, *, loc=None, ip=None) -> TensorTraceOp:
  return TensorTraceOp(key=key, values=values, value_dims=value_dims, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TensorTransferOp(_ods_ir.OpView):
  r"""
  Transfers the tensor from whichever context it may be in to the specified
  target context. If the contexts are compatible and can access each others
  memory the operation may be elided and otherwise will become one or more
  copies to transfer the tensor in cases where staging through an intermediate
  context is required.
  """

  OPERATION_NAME = "flow.tensor.transfer"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, operand_dims, target, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.extend(_get_op_results_or_values(operand_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["target"] = (target if (
    isinstance(target, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AnyAttr')) else
      _ods_ir.AttrBuilder.get('AnyAttr')(target, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand_dims(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def target(self) -> _ods_ir.Attribute:
    return self.operation.attributes["target"]

  @target.setter
  def target(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_transfer(operand, operand_dims, target, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorTransferOp(operand=operand, operand_dims=operand_dims, target=target, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorUpdateOp(_ods_ir.OpView):
  r"""
  Updates the target tensor with the contents of the update tensor at the
  given offset indices.
  """

  OPERATION_NAME = "flow.tensor.update"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_dims, start_indices, update, update_dims, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(_get_op_results_or_values(target_dims))
    operands.append(_get_op_results_or_values(start_indices))
    operands.append(update)
    operands.append(_get_op_results_or_values(update_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def target_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def start_indices(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def update(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0]

  @builtins.property
  def update_dims(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor_update(target, target_dims, start_indices, update, update_dims, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorUpdateOp(target=target, target_dims=target_dims, start_indices=start_indices, update=update, update_dims=update_dims, results=results, loc=loc, ip=ip).result
