
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "rocdl"

@_ods_cext.register_operation(_Dialect)
class BallotOp(_ods_ir.OpView):
  r"""
  Ballot provides a bit mask containing the 1-bit predicate value from each lane.
  The nth bit of the result contains the 1 bit contributed by the nth warp lane.
  """

  OPERATION_NAME = "rocdl.ballot"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, pred, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pred)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pred(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ballot(res, pred, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BallotOp(res=res, pred=pred, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BarrierOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def barrier(*, loc=None, ip=None) -> BarrierOp:
  return BarrierOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BarrierSignalOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.s.barrier.signal"

  _ODS_REGIONS = (0, True)

  def __init__(self, id, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["id"] = (id if (
    isinstance(id, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(id, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def id(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["id"]

  @id.setter
  def id(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["id"] = value

def s_barrier_signal(id, *, loc=None, ip=None) -> BarrierSignalOp:
  return BarrierSignalOp(id=id, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BarrierWaitOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.s.barrier.wait"

  _ODS_REGIONS = (0, True)

  def __init__(self, id, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["id"] = (id if (
    isinstance(id, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I16Attr')) else
      _ods_ir.AttrBuilder.get('I16Attr')(id, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def id(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["id"]

  @id.setter
  def id(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["id"] = value

def s_barrier_wait(id, *, loc=None, ip=None) -> BarrierWaitOp:
  return BarrierWaitOp(id=id, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BlockDimXOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.workgroup.dim.x"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def workgroup_dim_x(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BlockDimXOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BlockDimYOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.workgroup.dim.y"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def workgroup_dim_y(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BlockDimYOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BlockDimZOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.workgroup.dim.z"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def workgroup_dim_z(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BlockDimZOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BlockIdXOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.workgroup.id.x"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def workgroup_id_x(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BlockIdXOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BlockIdYOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.workgroup.id.y"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def workgroup_id_y(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BlockIdYOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BlockIdZOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.workgroup.id.z"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def workgroup_id_z(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BlockIdZOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtF32Bf8Op(_ods_ir.OpView):
  r"""
  Convert 8-bit bf8 value from the `byteSel`th bit of `srcA` to fp32.
  """

  OPERATION_NAME = "rocdl.cvt.f32.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, srcA, byteSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(srcA)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["byteSel"] = (byteSel if (
    isinstance(byteSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(byteSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def srcA(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def byteSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["byteSel"]

  @byteSel.setter
  def byteSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["byteSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_f32_bf8(res, src_a, byte_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtF32Bf8Op(res=res, srcA=src_a, byteSel=byte_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtF32Fp8Op(_ods_ir.OpView):
  r"""
  Convert 8-bit fp8 value from the `byteSel`th bit of `srcA` to fp32.
  """

  OPERATION_NAME = "rocdl.cvt.f32.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, srcA, byteSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(srcA)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["byteSel"] = (byteSel if (
    isinstance(byteSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(byteSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def srcA(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def byteSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["byteSel"]

  @byteSel.setter
  def byteSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["byteSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_f32_fp8(res, src_a, byte_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtF32Fp8Op(res=res, srcA=src_a, byteSel=byte_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkBf8F32Op(_ods_ir.OpView):
  r"""
  Convert `srcA` and `srcB` to bf8 and store into the low/high word of
  `old`, preserving the other word.
  """

  OPERATION_NAME = "rocdl.cvt.pk.bf8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, srcA, srcB, old, wordSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(srcA)
    operands.append(srcB)
    operands.append(old)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["wordSel"] = (wordSel if (
    isinstance(wordSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(wordSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def srcA(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def srcB(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def old(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def wordSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["wordSel"]

  @wordSel.setter
  def wordSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["wordSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_pk_bf8_f32(res, src_a, src_b, old, word_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkBf8F32Op(res=res, srcA=src_a, srcB=src_b, old=old, wordSel=word_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkF32Bf8Op(_ods_ir.OpView):
  r"""
  Convert `src` based on $wordSel to packed fp32,
  """

  OPERATION_NAME = "rocdl.cvt.pk.f32.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, wordSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["wordSel"] = (wordSel if (
    isinstance(wordSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(wordSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def wordSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["wordSel"]

  @wordSel.setter
  def wordSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["wordSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_pk_f32_bf8(res, src, word_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkF32Bf8Op(res=res, src=src, wordSel=word_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkF32Fp8Op(_ods_ir.OpView):
  r"""
  Convert `src` based on $wordSel to packed fp32.
  """

  OPERATION_NAME = "rocdl.cvt.pk.f32.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, wordSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["wordSel"] = (wordSel if (
    isinstance(wordSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(wordSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def wordSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["wordSel"]

  @wordSel.setter
  def wordSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["wordSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_pk_f32_fp8(res, src, word_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkF32Fp8Op(res=res, src=src, wordSel=word_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkFp8F32Op(_ods_ir.OpView):
  r"""
  Convert `srcA` and `srcB` to fp8 and store into the low/high word of
  `old`, preserving the other word.
  """

  OPERATION_NAME = "rocdl.cvt.pk.fp8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, srcA, srcB, old, wordSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(srcA)
    operands.append(srcB)
    operands.append(old)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["wordSel"] = (wordSel if (
    isinstance(wordSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(wordSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def srcA(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def srcB(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def old(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def wordSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["wordSel"]

  @wordSel.setter
  def wordSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["wordSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_pk_fp8_f32(res, src_a, src_b, old, word_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkFp8F32Op(res=res, srcA=src_a, srcB=src_b, old=old, wordSel=word_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkRtz(_ods_ir.OpView):
  r"""
  Convert two f32 values into a packed vector<2xf16>.
  """

  OPERATION_NAME = "rocdl.cvt.pkrtz"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, srcA, srcB, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(srcA)
    operands.append(srcB)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def srcA(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def srcB(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_pkrtz(res, src_a, src_b, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkRtz(res=res, srcA=src_a, srcB=src_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk8Bf16Bf8Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk8.bf16.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scale_pk8_bf16_bf8(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk8Bf16Bf8Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk8Bf16Fp4Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk8.bf16.fp4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scale_pk8_bf16_fp4(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk8Bf16Fp4Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk8Bf16Fp8Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk8.bf16.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scale_pk8_bf16_fp8(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk8Bf16Fp8Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk8F16Bf8Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk8.f16.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scale_pk8_f16_bf8(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk8F16Bf8Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk8F16Fp4Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk8.f16.fp4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scale_pk8_f16_fp4(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk8F16Fp4Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk8F16Fp8Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk8.f16.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scale_pk8_f16_fp8(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk8F16Fp8Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk8F32Bf8Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk8.f32.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scale_pk8_f32_bf8(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk8F32Bf8Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk8F32Fp4Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk8.f32.fp4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scale_pk8_f32_fp4(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk8F32Fp4Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk8F32Fp8Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk8.f32.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scale_pk8_f32_fp8(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk8F32Fp8Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk16Bf16Bf6Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk16.bf16.bf6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scale_pk16_bf16_bf6(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk16Bf16Bf6Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk16Bf16Fp6Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk16.bf16.fp6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scale_pk16_bf16_fp6(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk16Bf16Fp6Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk16F16Bf6Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk16.f16.bf6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scale_pk16_f16_bf6(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk16F16Bf6Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk16F16Fp6Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk16.f16.fp6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scale_pk16_f16_fp6(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk16F16Fp6Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk16F32Bf6Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk16.f32.bf6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scale_pk16_f32_bf6(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk16F32Bf6Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtPkScalePk16F32Fp6Op(_ods_ir.OpView):
  r"""
  Available on gfx1250+.
  """

  OPERATION_NAME = "rocdl.cvt.scale.pk16.f32.fp6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, scaleSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scaleSel"] = (scaleSel if (
    isinstance(scaleSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(scaleSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scaleSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["scaleSel"]

  @scaleSel.setter
  def scaleSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scaleSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scale_pk16_f32_fp6(res, src, scale, scale_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtPkScalePk16F32Fp6Op(res=res, src=src, scale=scale, scaleSel=scale_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32F16Bf8Op(_ods_ir.OpView):
  r"""
  Convert a bf8 byte from `src`, selected by
  `srcSelIndex`, to f16 while multiplying it by the expontent of `scale`,
  and place it into the `dstLoHiSel`th bit
  of `oldVdst` preserving the other element of that vector in
  the return value.
  
  The bytes are stored as an `i32` and not a `<4 x i8>`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.f16.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src, scale, srcSelIndex, dstLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcSelIndex"] = (srcSelIndex if (
    isinstance(srcSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(srcSelIndex, context=_ods_context))
    attributes["dstLoHiSel"] = (dstLoHiSel if (
    isinstance(dstLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(dstLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def srcSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["srcSelIndex"]

  @srcSelIndex.setter
  def srcSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcSelIndex"] = value

  @builtins.property
  def dstLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["dstLoHiSel"]

  @dstLoHiSel.setter
  def dstLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_f16_bf8(res, old_vdst, src, scale, src_sel_index, dst_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32F16Bf8Op(res=res, oldVdst=old_vdst, src=src, scale=scale, srcSelIndex=src_sel_index, dstLoHiSel=dst_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32F16Fp8Op(_ods_ir.OpView):
  r"""
  Convert a fp8 byte from `src`, selected by
  `srcSelIndex`, to f16 while multiplying it by the expontent of `scale`,
  and place it into the `dstLoHiSel`th bit
  of `oldVdst` preserving the other element of that vector in
  the return value.
  
  The bytes are stored as an `i32` and not a `<4 x i8>`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.f16.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src, scale, srcSelIndex, dstLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcSelIndex"] = (srcSelIndex if (
    isinstance(srcSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(srcSelIndex, context=_ods_context))
    attributes["dstLoHiSel"] = (dstLoHiSel if (
    isinstance(dstLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(dstLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def srcSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["srcSelIndex"]

  @srcSelIndex.setter
  def srcSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcSelIndex"] = value

  @builtins.property
  def dstLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["dstLoHiSel"]

  @dstLoHiSel.setter
  def dstLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_f16_fp8(res, old_vdst, src, scale, src_sel_index, dst_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32F16Fp8Op(res=res, oldVdst=old_vdst, src=src, scale=scale, srcSelIndex=src_sel_index, dstLoHiSel=dst_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32F32Bf8Op(_ods_ir.OpView):
  r"""
  Convert a bf8 byte from `src`, selected by
  `srcSelIndex`, to f32, multiplying it by the exponent of `scale`.
  
  The bytes are stored in an `i32`, not a `<4 x i8>`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.f32.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, srcSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcSelIndex"] = (srcSelIndex if (
    isinstance(srcSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(srcSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def srcSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["srcSelIndex"]

  @srcSelIndex.setter
  def srcSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_f32_bf8(res, src, scale, src_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32F32Bf8Op(res=res, src=src, scale=scale, srcSelIndex=src_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32F32Fp8Op(_ods_ir.OpView):
  r"""
  Convert a fp8 byte from `src`, selected by
  `srcSelIndex`, to f32, multiplying it by the exponent of `scale`.
  
  The bytes are stored in an `i32`, not a `<4 x i8>`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.f32.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, srcSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcSelIndex"] = (srcSelIndex if (
    isinstance(srcSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(srcSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def srcSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["srcSelIndex"]

  @srcSelIndex.setter
  def srcSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_f32_fp8(res, src, scale, src_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32F32Fp8Op(res=res, src=src, scale=scale, srcSelIndex=src_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk8Bf8Bf16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed bf16 values to packed bf8, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk8.bf8.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk8_bf8_bf16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk8Bf8Bf16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk8Bf8F16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f16 values to packed bf8, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk8.bf8.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk8_bf8_f16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk8Bf8F16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk8Bf8F32Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f32 values to packed bf8, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk8.bf8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk8_bf8_f32(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk8Bf8F32Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk8Fp4Bf16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed bf16 values to packed fp4, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk8.fp4.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk8_fp4_bf16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk8Fp4Bf16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk8Fp4F16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f16 values to packed fp4, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk8.fp4.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk8_fp4_f16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk8Fp4F16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk8Fp4F32Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f32 values to packed fp4, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk8.fp4.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk8_fp4_f32(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk8Fp4F32Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk8Fp8Bf16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed bf16 values to packed fp8, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk8.fp8.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk8_fp8_bf16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk8Fp8Bf16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk8Fp8F16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f16 values to packed fp8, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk8.fp8.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk8_fp8_f16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk8Fp8F16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk8Fp8F32Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f32 values to packed fp8, multiplying by the exponent part of `scale`
  before doing so. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk8.fp8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk8_fp8_f32(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk8Fp8F32Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk32Bf6Bf16Op(_ods_ir.OpView):
  r"""
  Convert 32 packed bf16 values to packed bf6, dividing by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk32.bf6.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk32_bf6_bf16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk32Bf6Bf16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk32Bf6F16Op(_ods_ir.OpView):
  r"""
  Convert 32 packed f16 values to packed bf6, dividing by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk32.bf6.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk32_bf6_f16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk32Bf6F16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk32Bf16Bf6Op(_ods_ir.OpView):
  r"""
  Convert 32 packed bf6 values to packed bf16, multiplying by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk32.bf16.bf6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk32_bf16_bf6(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk32Bf16Bf6Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk32Bf16Fp6Op(_ods_ir.OpView):
  r"""
  Convert 32 packed fp6 values to packed bf16, multiplying by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk32.bf16.fp6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk32_bf16_fp6(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk32Bf16Fp6Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk32F16Bf6Op(_ods_ir.OpView):
  r"""
  Convert 32 packed bf6 values to packed f16, multiplying by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk32.f16.bf6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk32_f16_bf6(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk32F16Bf6Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk32F16Fp6Op(_ods_ir.OpView):
  r"""
  Convert 32 packed fp6 values to packed f16, multiplying by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk32.f16.fp6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk32_f16_fp6(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk32F16Fp6Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk32F32Bf6Op(_ods_ir.OpView):
  r"""
  Convert 32 packed bf6 values to packed f32, multiplying by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk32.f32.bf6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk32_f32_bf6(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk32F32Bf6Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk32F32Fp6Op(_ods_ir.OpView):
  r"""
  Convert 32 packed fp6 values to packed f32, multiplying by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk32.f32.fp6"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk32_f32_fp6(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk32F32Fp6Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk32Fp6Bf16Op(_ods_ir.OpView):
  r"""
  Convert 32 packed bf16 values to packed fp6, dividing by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk32.fp6.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk32_fp6_bf16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk32Fp6Bf16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32Pk32Fp6F16Op(_ods_ir.OpView):
  r"""
  Convert 32 packed f16 values to packed fp6, dividing by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk32.fp6.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk32_fp6_f16(res, src, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32Pk32Fp6F16Op(res=res, src=src, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkBf8Bf16Op(_ods_ir.OpView):
  r"""
  Convert two bf16 values in `src0` to two bf8 bytes, dividing by the exponent in `scale`. The bytes are
  packed into a 16-bit value which is inserted into `oldVdst` at the
  `dstLoHiSel` position, with the entire updated vector being returned.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.bf8.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, scale, dstLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstLoHiSel"] = (dstLoHiSel if (
    isinstance(dstLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(dstLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def dstLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["dstLoHiSel"]

  @dstLoHiSel.setter
  def dstLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk_bf8_bf16(res, old_vdst, src0, scale, dst_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkBf8Bf16Op(res=res, oldVdst=old_vdst, src0=src0, scale=scale, dstLoHiSel=dst_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkBf8F16Op(_ods_ir.OpView):
  r"""
  Convert two f16 values in `src0` to two bf8 bytes, dividing by the exponent in `scale`. The bytes are
  packed into a 16-bit value which is inserted into `oldVdst` at the
  `dstLoHiSel` position, with the entire updated vector being returned.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.bf8.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, scale, dstLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstLoHiSel"] = (dstLoHiSel if (
    isinstance(dstLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(dstLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def dstLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["dstLoHiSel"]

  @dstLoHiSel.setter
  def dstLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk_bf8_f16(res, old_vdst, src0, scale, dst_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkBf8F16Op(res=res, oldVdst=old_vdst, src0=src0, scale=scale, dstLoHiSel=dst_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkBf8F32Op(_ods_ir.OpView):
  r"""
  Convert two f32 values in `src0` and `src1` to two bf8 bytes,
  dividing by the exponent in `scale`. The bytes are packed into
  a 16-bit value which is inserted into `oldVdst` at the `dstLoHiSel`
  position, with the entire updated vector being returned.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.bf8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, src1, scale, dstLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(src1)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstLoHiSel"] = (dstLoHiSel if (
    isinstance(dstLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(dstLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def src1(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def dstLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["dstLoHiSel"]

  @dstLoHiSel.setter
  def dstLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk_bf8_f32(res, old_vdst, src0, src1, scale, dst_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkBf8F32Op(res=res, oldVdst=old_vdst, src0=src0, src1=src1, scale=scale, dstLoHiSel=dst_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkBf16Bf8Op(_ods_ir.OpView):
  r"""
  Convert two packed bf8 values in `src0` to two bf16 values, multiplying by the exponent in `scale`.
  The two values to be converted are selected from the low or high half
  of `src` (a packed vector represented as an `i32`)
  on the basis of `srcLoHiSel`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.bf16.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, srcLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcLoHiSel"] = (srcLoHiSel if (
    isinstance(srcLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(srcLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def srcLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["srcLoHiSel"]

  @srcLoHiSel.setter
  def srcLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk_bf16_bf8(res, src, scale, src_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkBf16Bf8Op(res=res, src=src, scale=scale, srcLoHiSel=src_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkBf16Fp4Op(_ods_ir.OpView):
  r"""
  Convert two packed fp4 (f4E2M1) values  stored as one byte of a 32-bit integer
  to packed bf16, multiplying by the exponent part of `scale`
  before doing so.
  
  The byte to convert is chosen by `srcSelIndex`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.bf16.fp4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, srcSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcSelIndex"] = (srcSelIndex if (
    isinstance(srcSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(srcSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def srcSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["srcSelIndex"]

  @srcSelIndex.setter
  def srcSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk_bf16_fp4(res, src, scale, src_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkBf16Fp4Op(res=res, src=src, scale=scale, srcSelIndex=src_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkBf16Fp8Op(_ods_ir.OpView):
  r"""
  Convert two packed fp8 values in `src0` to two bf16 values, multiplying by the exponent in `scale`.
  The two values to be converted are selected from the low or high half
  of `src` (a packed vector represented as an `i32`)
  on the basis of `srcLoHiSel`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.bf16.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, srcLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcLoHiSel"] = (srcLoHiSel if (
    isinstance(srcLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(srcLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def srcLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["srcLoHiSel"]

  @srcLoHiSel.setter
  def srcLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk_bf16_fp8(res, src, scale, src_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkBf16Fp8Op(res=res, src=src, scale=scale, srcLoHiSel=src_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkF16Bf8Op(_ods_ir.OpView):
  r"""
  Convert two packed bf8 values in `src0` to two f16 values, multiplying by the exponent in `scale`.
  The two values to be converted are selected from the low or high half
  of `src` (a packed vector represented as an `i32`)
  on the basis of `srcLoHiSel`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.f16.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, srcLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcLoHiSel"] = (srcLoHiSel if (
    isinstance(srcLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(srcLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def srcLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["srcLoHiSel"]

  @srcLoHiSel.setter
  def srcLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk_f16_bf8(res, src, scale, src_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkF16Bf8Op(res=res, src=src, scale=scale, srcLoHiSel=src_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkF16Fp4Op(_ods_ir.OpView):
  r"""
  Convert two packed fp4 (f4E2M1) values  stored as one byte of a 32-bit integer
  to packed f16, multiplying by the exponent part of `scale`
  before doing so.
  
  The byte to convert is chosen by `srcSelIndex`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.f16.fp4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, srcSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcSelIndex"] = (srcSelIndex if (
    isinstance(srcSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(srcSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def srcSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["srcSelIndex"]

  @srcSelIndex.setter
  def srcSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk_f16_fp4(res, src, scale, src_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkF16Fp4Op(res=res, src=src, scale=scale, srcSelIndex=src_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkF16Fp8Op(_ods_ir.OpView):
  r"""
  Convert two packed fp8 values in `src0` to two f16 values, multiplying by the exponent in `scale`.
  The two values to be converted are selected from the low or high half
  of `src` (a packed vector represented as an `i32`)
  on the basis of `srcLoHiSel`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.f16.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, srcLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcLoHiSel"] = (srcLoHiSel if (
    isinstance(srcLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(srcLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def srcLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["srcLoHiSel"]

  @srcLoHiSel.setter
  def srcLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk_f16_fp8(res, src, scale, src_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkF16Fp8Op(res=res, src=src, scale=scale, srcLoHiSel=src_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkF32Bf8Op(_ods_ir.OpView):
  r"""
  Convert two packed bf8 values in `src0` to two f32 values, multiplying by the exponent in `scale`.
  The two values to be converted are selected from the low or high half
  of `src` (a packed vector represented as an `i32`)
  on the basis of `srcLoHiSel`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.f32.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, srcLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcLoHiSel"] = (srcLoHiSel if (
    isinstance(srcLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(srcLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def srcLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["srcLoHiSel"]

  @srcLoHiSel.setter
  def srcLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk_f32_bf8(res, src, scale, src_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkF32Bf8Op(res=res, src=src, scale=scale, srcLoHiSel=src_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkF32Fp4Op(_ods_ir.OpView):
  r"""
  Convert two packed fp4 (f4E2M1) values  stored as one byte of a 32-bit integer
  to packed f32, multiplying by the exponent part of `scale`
  before doing so.
  
  The byte to convert is chosen by `srcSelIndex`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.f32.fp4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, srcSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcSelIndex"] = (srcSelIndex if (
    isinstance(srcSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(srcSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def srcSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["srcSelIndex"]

  @srcSelIndex.setter
  def srcSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk_f32_fp4(res, src, scale, src_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkF32Fp4Op(res=res, src=src, scale=scale, srcSelIndex=src_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkF32Fp8Op(_ods_ir.OpView):
  r"""
  Convert two packed fp8 values in `src0` to two f32 values, multiplying by the exponent in `scale`.
  The two values to be converted are selected from the low or high half
  of `src` (a packed vector represented as an `i32`)
  on the basis of `srcLoHiSel`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.f32.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, scale, srcLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["srcLoHiSel"] = (srcLoHiSel if (
    isinstance(srcLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(srcLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def srcLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["srcLoHiSel"]

  @srcLoHiSel.setter
  def srcLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["srcLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk_f32_fp8(res, src, scale, src_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkF32Fp8Op(res=res, src=src, scale=scale, srcLoHiSel=src_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkFp4Bf16Op(_ods_ir.OpView):
  r"""
  Convert two packed bf16 values to packed
  fp4, dividing by the exponent part of `scale`
  before doing so.
  
  The two scaled values are packed  into a byte.
  That byte is used to update the `dstSelIndex`th
  byte of `oldVdst`, which is returned in its entirity.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.fp4.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk_fp4_bf16(res, old_vdst, src, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkFp4Bf16Op(res=res, oldVdst=old_vdst, src=src, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkFp4F16Op(_ods_ir.OpView):
  r"""
  Convert two packed f16 values to packed
  fp4, dividing by the exponent part of `scale`
  before doing so.
  
  The two scaled values are packed  into a byte.
  That byte is used to update the `dstSelIndex`th
  byte of `oldVdst`, which is returned in its entirity.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.fp4.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk_fp4_f16(res, old_vdst, src, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkFp4F16Op(res=res, oldVdst=old_vdst, src=src, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkFp4F32Op(_ods_ir.OpView):
  r"""
  Convert two single-precision float values, passed in `src0` and `src1`
  into two fp4 values, dividing them by the expontent part of `scale`
  before doing so.
  
  The two scaled values are packed  into a byte.
  That byte is used to update the `dstSelIndex`th
  byte of `oldVdst`, which is returned in its entirity.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.fp4.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, src1, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(src1)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def src1(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk_fp4_f32(res, old_vdst, src0, src1, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkFp4F32Op(res=res, oldVdst=old_vdst, src0=src0, src1=src1, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkFp8Bf16Op(_ods_ir.OpView):
  r"""
  Convert two bf16 values in `src0` to two fp8 bytes, dividing by the exponent in `scale`. The bytes are
  packed into a 16-bit value which is inserted into `oldVdst` at the
  `dstLoHiSel` position, with the entire updated vector being returned.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.fp8.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, scale, dstLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstLoHiSel"] = (dstLoHiSel if (
    isinstance(dstLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(dstLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def dstLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["dstLoHiSel"]

  @dstLoHiSel.setter
  def dstLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk_fp8_bf16(res, old_vdst, src0, scale, dst_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkFp8Bf16Op(res=res, oldVdst=old_vdst, src0=src0, scale=scale, dstLoHiSel=dst_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkFp8F16Op(_ods_ir.OpView):
  r"""
  Convert two f16 values in `src0` to two fp8 bytes, dividing by the exponent in `scale`. The bytes are
  packed into a 16-bit value which is inserted into `oldVdst` at the
  `dstLoHiSel` position, with the entire updated vector being returned.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.fp8.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, scale, dstLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstLoHiSel"] = (dstLoHiSel if (
    isinstance(dstLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(dstLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def dstLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["dstLoHiSel"]

  @dstLoHiSel.setter
  def dstLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk_fp8_f16(res, old_vdst, src0, scale, dst_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkFp8F16Op(res=res, oldVdst=old_vdst, src0=src0, scale=scale, dstLoHiSel=dst_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32PkFp8F32Op(_ods_ir.OpView):
  r"""
  Convert two f32 values in `src0` and `src1` to two fp8 bytes,
  dividing by the exponent in `scale`. The bytes are packed into
  a 16-bit value which is inserted into `oldVdst` at the `dstLoHiSel`
  position, with the entire updated vector being returned.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.pk.fp8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, src1, scale, dstLoHiSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(src1)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstLoHiSel"] = (dstLoHiSel if (
    isinstance(dstLoHiSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(dstLoHiSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def src1(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def dstLoHiSel(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["dstLoHiSel"]

  @dstLoHiSel.setter
  def dstLoHiSel(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstLoHiSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_pk_fp8_f32(res, old_vdst, src0, src1, scale, dst_lo_hi_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32PkFp8F32Op(res=res, oldVdst=old_vdst, src0=src0, src1=src1, scale=scale, dstLoHiSel=dst_lo_hi_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrBf8BF16Op(_ods_ir.OpView):
  r"""
  Convert a bf16 value in `src0` to a bf8 bytes, dividing by the exponent in `scale` and using `seed`
  for stochiastic rounding. Place the resulting byte in the
  `dstSelIndex`th bit of `oldVdst` and return the entire packed vector,
  which is stored as an `i32`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.bf8.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, seed, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_bf8_bf16(res, old_vdst, src0, seed, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrBf8BF16Op(res=res, oldVdst=old_vdst, src0=src0, seed=seed, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrBf8F16Op(_ods_ir.OpView):
  r"""
  Convert a f16 value in `src0` to a bf8 bytes, dividing by the exponent in `scale` and using `seed`
  for stochiastic rounding. Place the resulting byte in the
  `dstSelIndex`th bit of `oldVdst` and return the entire packed vector,
  which is stored as an `i32`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.bf8.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, seed, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_bf8_f16(res, old_vdst, src0, seed, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrBf8F16Op(res=res, oldVdst=old_vdst, src0=src0, seed=seed, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrBf8F32Op(_ods_ir.OpView):
  r"""
  Convert a f32 value in `src0` to a bf8 bytes, dividing by the exponent in `scale` and using `seed`
  for stochiastic rounding. Place the resulting byte in the
  `dstSelIndex`th bit of `oldVdst` and return the entire packed vector,
  which is stored as an `i32`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.bf8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, seed, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_bf8_f32(res, old_vdst, src0, seed, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrBf8F32Op(res=res, oldVdst=old_vdst, src0=src0, seed=seed, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrFp8BF16Op(_ods_ir.OpView):
  r"""
  Convert a bf16 value in `src0` to a fp8 bytes, dividing by the exponent in `scale` and using `seed`
  for stochiastic rounding. Place the resulting byte in the
  `dstSelIndex`th bit of `oldVdst` and return the entire packed vector,
  which is stored as an `i32`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.fp8.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, seed, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_fp8_bf16(res, old_vdst, src0, seed, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrFp8BF16Op(res=res, oldVdst=old_vdst, src0=src0, seed=seed, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrFp8F16Op(_ods_ir.OpView):
  r"""
  Convert a f16 value in `src0` to a fp8 bytes, dividing by the exponent in `scale` and using `seed`
  for stochiastic rounding. Place the resulting byte in the
  `dstSelIndex`th bit of `oldVdst` and return the entire packed vector,
  which is stored as an `i32`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.fp8.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, seed, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_fp8_f16(res, old_vdst, src0, seed, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrFp8F16Op(res=res, oldVdst=old_vdst, src0=src0, seed=seed, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrFp8F32Op(_ods_ir.OpView):
  r"""
  Convert a f32 value in `src0` to a fp8 bytes, dividing by the exponent in `scale` and using `seed`
  for stochiastic rounding. Place the resulting byte in the
  `dstSelIndex`th bit of `oldVdst` and return the entire packed vector,
  which is stored as an `i32`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.fp8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src0, seed, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src0)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_fp8_f32(res, old_vdst, src0, seed, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrFp8F32Op(res=res, oldVdst=old_vdst, src0=src0, seed=seed, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk8Bf8Bf16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed bf16 values to packed bf8, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk8.bf8.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_pk8_bf8_bf16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk8Bf8Bf16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk8Bf8F16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f16 values to packed bf8, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk8.bf8.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_pk8_bf8_f16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk8Bf8F16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk8Bf8F32Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f32 values to packed bf8, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk8.bf8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_pk8_bf8_f32(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk8Bf8F32Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk8Fp4Bf16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed bf16 values to packed fp4, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk8.fp4.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_pk8_fp4_bf16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk8Fp4Bf16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk8Fp4F16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f16 values to packed fp4, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk8.fp4.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_pk8_fp4_f16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk8Fp4F16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk8Fp4F32Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f32 values to packed fp4, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk8.fp4.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_pk8_fp4_f32(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk8Fp4F32Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk8Fp8Bf16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed bf16 values to packed fp8, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk8.fp8.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_pk8_fp8_bf16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk8Fp8Bf16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk8Fp8F16Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f16 values to packed fp8, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk8.fp8.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_pk8_fp8_f16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk8Fp8F16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk8Fp8F32Op(_ods_ir.OpView):
  r"""
  Convert 8 packed f32 values to packed fp8, multiplying by the exponent part of `scale`
  before doing so and apply stochastic rounding. This op is for gfx1250+ arch.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk8.fp8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_pk8_fp8_f32(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk8Fp8F32Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk32Bf6Bf16Op(_ods_ir.OpView):
  r"""
  Convert 32 packed bf16 values to packed bf6, dividing by the exponent part of `scale`
  before doing so and applying random rounding derived from
  `seed`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk32.bf6.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_pk32_bf6_bf16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk32Bf6Bf16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk32Bf6F16Op(_ods_ir.OpView):
  r"""
  Convert 32 packed f16 values to packed bf6, dividing by the exponent part of `scale`
  before doing so and applying random rounding derived from
  `seed`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk32.bf6.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_pk32_bf6_f16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk32Bf6F16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk32Bf6F32Op(_ods_ir.OpView):
  r"""
  Convert 32 packed f32 values to packed bf6, dividing by the exponent part of `scale`
  before doing so and applying random rounding derived from
  `seed`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk32.bf6.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_pk32_bf6_f32(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk32Bf6F32Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk32Fp6Bf16Op(_ods_ir.OpView):
  r"""
  Convert 32 packed bf16 values to packed fp6, dividing by the exponent part of `scale`
  before doing so and applying random rounding derived from
  `seed`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk32.fp6.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_pk32_fp6_bf16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk32Fp6Bf16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk32Fp6F16Op(_ods_ir.OpView):
  r"""
  Convert 32 packed f16 values to packed fp6, dividing by the exponent part of `scale`
  before doing so and applying random rounding derived from
  `seed`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk32.fp6.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_pk32_fp6_f16(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk32Fp6F16Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPk32Fp6F32Op(_ods_ir.OpView):
  r"""
  Convert 32 packed f32 values to packed fp6, dividing by the exponent part of `scale`
  before doing so and applying random rounding derived from
  `seed`.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk32.fp6.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, seed, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_pk32_fp6_f32(res, src, seed, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPk32Fp6F32Op(res=res, src=src, seed=seed, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPkFp4Bf16Op(_ods_ir.OpView):
  r"""
  Convert two packed bf16 values to packed
  fp4, dividing by the exponent part of `scale`
  before doing so and using `seed` as the random seed for
  stochiastic rounding.
  
  The two scaled values are packed (little-endian)
  into a byte. That byte is used to update the `dstSelIndex`th
  byte of `oldVdst`, which is returned in its entirity.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk.fp4.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src, seed, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_pk_fp4_bf16(res, old_vdst, src, seed, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPkFp4Bf16Op(res=res, oldVdst=old_vdst, src=src, seed=seed, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPkFp4F16Op(_ods_ir.OpView):
  r"""
  Convert two packed f16 values to packed
  fp4, dividing by the exponent part of `scale`
  before doing so and using `seed` as the random seed for
  stochiastic rounding.
  
  The two scaled values are packed (little-endian)
  into a byte. That byte is used to update the `dstSelIndex`th
  byte of `oldVdst`, which is returned in its entirity.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk.fp4.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src, seed, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_pk_fp4_f16(res, old_vdst, src, seed, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPkFp4F16Op(res=res, oldVdst=old_vdst, src=src, seed=seed, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF32SrPkFp4F32Op(_ods_ir.OpView):
  r"""
  Convert two packed f32 values to packed
  fp4, dividing by the exponent part of `scale`
  before doing so and using `seed` as the random seed for
  stochiastic rounding.
  
  The two scaled values are packed (little-endian)
  into a byte. That byte is used to update the `dstSelIndex`th
  byte of `oldVdst`, which is returned in its entirity.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.sr.pk.fp4.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, oldVdst, src, seed, scale, dstSelIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(oldVdst)
    operands.append(src)
    operands.append(seed)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dstSelIndex"] = (dstSelIndex if (
    isinstance(dstSelIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dstSelIndex, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def oldVdst(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def dstSelIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dstSelIndex"]

  @dstSelIndex.setter
  def dstSelIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dstSelIndex"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_sr_pk_fp4_f32(res, old_vdst, src, seed, scale, dst_sel_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF32SrPkFp4F32Op(res=res, oldVdst=old_vdst, src=src, seed=seed, scale=scale, dstSelIndex=dst_sel_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF322xPk16Bf6F32Op(_ods_ir.OpView):
  r"""
  Convert 32 single-precision float values, packed into two length-16
  vectors that will be logically concanenated, to packed bf6, dividing by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.2xpk16.bf6.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src0, src1, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src0)
    operands.append(src1)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src1(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_2xpk16_bf6_f32(res, src0, src1, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF322xPk16Bf6F32Op(res=res, src0=src0, src1=src1, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtScaleF322xPk16Fp6F32Op(_ods_ir.OpView):
  r"""
  Convert 32 single-precision float values, packed into two length-16
  vectors that will be logically concanenated, to packed fp6, dividing by the exponent part of `scale`
  before doing so.
  """

  OPERATION_NAME = "rocdl.cvt.scalef32.2xpk16.fp6.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src0, src1, scale, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src0)
    operands.append(src1)
    operands.append(scale)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src1(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_scalef32_2xpk16_fp6_f32(res, src0, src1, scale, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtScaleF322xPk16Fp6F32Op(res=res, src0=src0, src1=src1, scale=scale, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtSrBf8F32Op(_ods_ir.OpView):
  r"""
  Convert `srcA` to bf8, adding the rounding factor from `srcB`,
  and store into the `byteSel`th byte of `old`, preserving the others.
  """

  OPERATION_NAME = "rocdl.cvt.sr.bf8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, srcA, srcB, old, byteSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(srcA)
    operands.append(srcB)
    operands.append(old)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["byteSel"] = (byteSel if (
    isinstance(byteSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(byteSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def srcA(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def srcB(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def old(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def byteSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["byteSel"]

  @byteSel.setter
  def byteSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["byteSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_sr_bf8_f32(res, src_a, src_b, old, byte_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtSrBf8F32Op(res=res, srcA=src_a, srcB=src_b, old=old, byteSel=byte_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CvtSrFp8F32Op(_ods_ir.OpView):
  r"""
  Convert `srcA` to fp8, adding the rounding factor from `srcB`,
  and store into the `byteSel`th byte of `old`, preserving the others.
  """

  OPERATION_NAME = "rocdl.cvt.sr.fp8.f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, srcA, srcB, old, byteSel, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(srcA)
    operands.append(srcB)
    operands.append(old)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["byteSel"] = (byteSel if (
    isinstance(byteSel, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(byteSel, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def srcA(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def srcB(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def old(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def byteSel(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["byteSel"]

  @byteSel.setter
  def byteSel(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["byteSel"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cvt_sr_fp8_f32(res, src_a, src_b, old, byte_sel, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CvtSrFp8F32Op(res=res, srcA=src_a, srcB=src_b, old=old, byteSel=byte_sel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DPPUpdateOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.update.dpp"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, old, src, dppCtrl, rowMask, bankMask, boundCtrl, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(old)
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dppCtrl"] = (dppCtrl if (
    isinstance(dppCtrl, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(dppCtrl, context=_ods_context))
    attributes["rowMask"] = (rowMask if (
    isinstance(rowMask, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(rowMask, context=_ods_context))
    attributes["bankMask"] = (bankMask if (
    isinstance(bankMask, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(bankMask, context=_ods_context))
    attributes["boundCtrl"] = (boundCtrl if (
    isinstance(boundCtrl, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(boundCtrl, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def old(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def dppCtrl(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["dppCtrl"]

  @dppCtrl.setter
  def dppCtrl(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dppCtrl"] = value

  @builtins.property
  def rowMask(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["rowMask"]

  @rowMask.setter
  def rowMask(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rowMask"] = value

  @builtins.property
  def bankMask(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["bankMask"]

  @bankMask.setter
  def bankMask(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bankMask"] = value

  @builtins.property
  def boundCtrl(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["boundCtrl"]

  @boundCtrl.setter
  def boundCtrl(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundCtrl"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def update_dpp(res, old, src, dpp_ctrl, row_mask, bank_mask, bound_ctrl, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return DPPUpdateOp(res=res, old=old, src=src, dppCtrl=dpp_ctrl, rowMask=row_mask, bankMask=bank_mask, boundCtrl=bound_ctrl, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DsBpermuteOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.ds_bpermute"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, index, src, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(index)
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def index(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ds_bpermute(res, index, src, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return DsBpermuteOp(res=res, index=index, src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DsSwizzleOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.ds_swizzle"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, offset, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(offset)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ds_swizzle(res, src, offset, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return DsSwizzleOp(res=res, src=src, offset=offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FMed3Op(_ods_ir.OpView):
  r"""
  Computes the median of three floating-point values using the AMDGPU fmed3 intrinsic.
  This operation is equivalent to `max(min(a, b), min(max(a, b), c))` but uses the
  hardware-accelerated V_MED3_F16/V_MED3_F32 instruction for better performance.
  
  The operation supports both scalar and vector floating-point types (f16, f32).
  
  Example:
  ```mlir
  // Scalar f32 median
  %result = rocdl.fmed3 %a, %b, %c : f32
  
  // Vector f16 median
  %result = rocdl.fmed3 %va, %vb, %vc : vector<4xf16>
  ```
  """

  OPERATION_NAME = "rocdl.fmed3"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src0, src1, src2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src0)
    operands.append(src1)
    operands.append(src2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src1(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def src2(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def fmed3(res, src0, src1, src2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return FMed3Op(res=res, src0=src0, src1=src1, src2=src2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalLoadLDSOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.global.load.lds"

  _ODS_REGIONS = (0, True)

  def __init__(self, globalPtr, ldsPtr, size, offset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(globalPtr)
    operands.append(ldsPtr)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["size"] = (size if (
    isinstance(size, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(size, context=_ods_context))
    attributes["offset"] = (offset if (
    isinstance(offset, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(offset, context=_ods_context))
    attributes["aux"] = (aux if (
    isinstance(aux, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(aux, context=_ods_context))
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def globalPtr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def ldsPtr(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def size(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["size"]

  @size.setter
  def size(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["size"] = value

  @builtins.property
  def offset(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def aux(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["aux"]

  @aux.setter
  def aux(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["aux"] = value

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def global_load_lds(global_ptr, lds_ptr, size, offset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> GlobalLoadLDSOp:
  return GlobalLoadLDSOp(globalPtr=global_ptr, ldsPtr=lds_ptr, size=size, offset=offset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GridDimXOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.grid.dim.x"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def grid_dim_x(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GridDimXOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GridDimYOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.grid.dim.y"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def grid_dim_y(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GridDimYOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GridDimZOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.grid.dim.z"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def grid_dim_z(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GridDimZOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IglpOpt(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.iglp.opt"

  _ODS_REGIONS = (0, True)

  def __init__(self, variant, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["variant"] = (variant if (
    isinstance(variant, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(variant, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def variant(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["variant"]

  @variant.setter
  def variant(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["variant"] = value

def iglp_opt(variant, *, loc=None, ip=None) -> IglpOpt:
  return IglpOpt(variant=variant, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class LoadToLDSOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.load.to.lds"

  _ODS_REGIONS = (0, True)

  def __init__(self, globalPtr, ldsPtr, size, offset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(globalPtr)
    operands.append(ldsPtr)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["size"] = (size if (
    isinstance(size, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(size, context=_ods_context))
    attributes["offset"] = (offset if (
    isinstance(offset, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(offset, context=_ods_context))
    attributes["aux"] = (aux if (
    isinstance(aux, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(aux, context=_ods_context))
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def globalPtr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def ldsPtr(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def size(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["size"]

  @size.setter
  def size(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["size"] = value

  @builtins.property
  def offset(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def aux(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["aux"]

  @aux.setter
  def aux(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["aux"] = value

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def load_to_lds(global_ptr, lds_ptr, size, offset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> LoadToLDSOp:
  return LoadToLDSOp(globalPtr=global_ptr, ldsPtr=lds_ptr, size=size, offset=offset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MakeBufferRsrcOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.make.buffer.rsrc"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, base, stride, numRecords, flags, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(base)
    operands.append(stride)
    operands.append(numRecords)
    operands.append(flags)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def base(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def stride(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def numRecords(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def flags(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def make_buffer_rsrc(res, base, stride, num_records, flags, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MakeBufferRsrcOp(res=res, base=base, stride=stride, numRecords=num_records, flags=flags, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MbcntHiOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mbcnt.hi"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, in0, in1, *, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(in0)
    operands.append(in1)
    _ods_context = _ods_get_default_loc_context(loc)
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def in0(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def in1(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mbcnt_hi(res, in0, in1, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MbcntHiOp(res=res, in0=in0, in1=in1, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MbcntLoOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mbcnt.lo"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, in0, in1, *, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(in0)
    operands.append(in1)
    _ods_context = _ods_get_default_loc_context(loc)
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def in0(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def in1(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mbcnt_lo(res, in0, in1, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MbcntLoOp(res=res, in0=in0, in1=in1, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Permlane16SwapOp(_ods_ir.OpView):
  r"""
  Performs a `permlane16.swap` operation with the given operands, applying the
  permutation specified by $fi to the provided inputs.
  """

  OPERATION_NAME = "rocdl.permlane16.swap"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, old, src, fi, boundControl, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(old)
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["fi"] = (fi if (
    isinstance(fi, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(fi, context=_ods_context))
    attributes["boundControl"] = (boundControl if (
    isinstance(boundControl, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(boundControl, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def old(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def fi(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["fi"]

  @fi.setter
  def fi(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fi"] = value

  @builtins.property
  def boundControl(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["boundControl"]

  @boundControl.setter
  def boundControl(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundControl"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def permlane16_swap(res, old, src, fi, bound_control, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return Permlane16SwapOp(res=res, old=old, src=src, fi=fi, boundControl=bound_control, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Permlane32SwapOp(_ods_ir.OpView):
  r"""
  Performs a `permlane32.swap` operation with the given operands, applying the
  permutation specified by $fi to the provided inputs.
  """

  OPERATION_NAME = "rocdl.permlane32.swap"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, old, src, fi, boundControl, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(old)
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["fi"] = (fi if (
    isinstance(fi, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(fi, context=_ods_context))
    attributes["boundControl"] = (boundControl if (
    isinstance(boundControl, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(boundControl, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def old(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def fi(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["fi"]

  @fi.setter
  def fi(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fi"] = value

  @builtins.property
  def boundControl(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["boundControl"]

  @boundControl.setter
  def boundControl(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundControl"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def permlane32_swap(res, old, src, fi, bound_control, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return Permlane32SwapOp(res=res, old=old, src=src, fi=fi, boundControl=bound_control, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PermlaneX16Op(_ods_ir.OpView):
  r"""
  Performs a `permlanex16` operation with the given operands, applying the
  permutation specified by $fi to the provided inputs.
  """

  OPERATION_NAME = "rocdl.permlanex16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, old, src0, src1, src2, fi, boundControl, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(old)
    operands.append(src0)
    operands.append(src1)
    operands.append(src2)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["fi"] = (fi if (
    isinstance(fi, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(fi, context=_ods_context))
    attributes["boundControl"] = (boundControl if (
    isinstance(boundControl, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(boundControl, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def old(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def src1(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def src2(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def fi(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["fi"]

  @fi.setter
  def fi(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fi"] = value

  @builtins.property
  def boundControl(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["boundControl"]

  @boundControl.setter
  def boundControl(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundControl"] = value

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def permlanex16(res, old, src0, src1, src2, fi, bound_control, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return PermlaneX16Op(res=res, old=old, src0=src0, src1=src1, src2=src2, fi=fi, boundControl=bound_control, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RawBufferAtomicCmpSwap(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.buffer.atomic.cmpswap"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, cmp, rsrc, offset, soffset, aux, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(cmp)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def cmp(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def soffset(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def aux(self) -> _ods_ir.Value:
    return self.operation.operands[5]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def raw_buffer_atomic_cmpswap(res, src, cmp, rsrc, offset, soffset, aux, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RawBufferAtomicCmpSwap(res=res, src=src, cmp=cmp, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RawBufferAtomicFAddOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.buffer.atomic.fadd"

  _ODS_REGIONS = (0, True)

  def __init__(self, vdata, rsrc, offset, soffset, aux, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vdata)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vdata(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def soffset(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def aux(self) -> _ods_ir.Value:
    return self.operation.operands[4]

def raw_buffer_atomic_fadd(vdata, rsrc, offset, soffset, aux, *, loc=None, ip=None) -> RawBufferAtomicFAddOp:
  return RawBufferAtomicFAddOp(vdata=vdata, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawBufferAtomicFMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.buffer.atomic.fmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, vdata, rsrc, offset, soffset, aux, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vdata)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vdata(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def soffset(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def aux(self) -> _ods_ir.Value:
    return self.operation.operands[4]

def raw_buffer_atomic_fmax(vdata, rsrc, offset, soffset, aux, *, loc=None, ip=None) -> RawBufferAtomicFMaxOp:
  return RawBufferAtomicFMaxOp(vdata=vdata, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawBufferAtomicSMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.buffer.atomic.smax"

  _ODS_REGIONS = (0, True)

  def __init__(self, vdata, rsrc, offset, soffset, aux, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vdata)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vdata(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def soffset(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def aux(self) -> _ods_ir.Value:
    return self.operation.operands[4]

def raw_buffer_atomic_smax(vdata, rsrc, offset, soffset, aux, *, loc=None, ip=None) -> RawBufferAtomicSMaxOp:
  return RawBufferAtomicSMaxOp(vdata=vdata, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawBufferAtomicUMinOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.buffer.atomic.umin"

  _ODS_REGIONS = (0, True)

  def __init__(self, vdata, rsrc, offset, soffset, aux, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vdata)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vdata(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def soffset(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def aux(self) -> _ods_ir.Value:
    return self.operation.operands[4]

def raw_buffer_atomic_umin(vdata, rsrc, offset, soffset, aux, *, loc=None, ip=None) -> RawBufferAtomicUMinOp:
  return RawBufferAtomicUMinOp(vdata=vdata, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawBufferLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.buffer.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, rsrc, offset, soffset, aux, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def soffset(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def aux(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def raw_buffer_load(res, rsrc, offset, soffset, aux, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RawBufferLoadOp(res=res, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RawBufferStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.buffer.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, vdata, rsrc, offset, soffset, aux, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vdata)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vdata(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def soffset(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def aux(self) -> _ods_ir.Value:
    return self.operation.operands[4]

def raw_buffer_store(vdata, rsrc, offset, soffset, aux, *, loc=None, ip=None) -> RawBufferStoreOp:
  return RawBufferStoreOp(vdata=vdata, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawPtrBufferAtomicCmpSwap(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.ptr.buffer.atomic.cmpswap"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, cmp, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(cmp)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def cmp(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def soffset(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def aux(self) -> _ods_ir.Value:
    return self.operation.operands[5]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def raw_ptr_buffer_atomic_cmpswap(res, src, cmp, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RawPtrBufferAtomicCmpSwap(res=res, src=src, cmp=cmp, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RawPtrBufferAtomicFaddOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.ptr.buffer.atomic.fadd"

  _ODS_REGIONS = (0, True)

  def __init__(self, vdata, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vdata)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vdata(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def soffset(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def aux(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def raw_ptr_buffer_atomic_fadd(vdata, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> RawPtrBufferAtomicFaddOp:
  return RawPtrBufferAtomicFaddOp(vdata=vdata, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawPtrBufferAtomicFmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.ptr.buffer.atomic.fmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, vdata, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vdata)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vdata(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def soffset(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def aux(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def raw_ptr_buffer_atomic_fmax(vdata, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> RawPtrBufferAtomicFmaxOp:
  return RawPtrBufferAtomicFmaxOp(vdata=vdata, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawPtrBufferAtomicSmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.ptr.buffer.atomic.smax"

  _ODS_REGIONS = (0, True)

  def __init__(self, vdata, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vdata)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vdata(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def soffset(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def aux(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def raw_ptr_buffer_atomic_smax(vdata, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> RawPtrBufferAtomicSmaxOp:
  return RawPtrBufferAtomicSmaxOp(vdata=vdata, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawPtrBufferAtomicUminOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.ptr.buffer.atomic.umin"

  _ODS_REGIONS = (0, True)

  def __init__(self, vdata, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vdata)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vdata(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def soffset(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def aux(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def raw_ptr_buffer_atomic_umin(vdata, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> RawPtrBufferAtomicUminOp:
  return RawPtrBufferAtomicUminOp(vdata=vdata, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawPtrBufferLoadLdsOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.ptr.buffer.load.lds"

  _ODS_REGIONS = (0, True)

  def __init__(self, rsrc, ldsPtr, size, voffset, soffset, offset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(rsrc)
    operands.append(ldsPtr)
    operands.append(size)
    operands.append(voffset)
    operands.append(soffset)
    operands.append(offset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def ldsPtr(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def size(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def voffset(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def soffset(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[5]

  @builtins.property
  def aux(self) -> _ods_ir.Value:
    return self.operation.operands[6]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def raw_ptr_buffer_load_lds(rsrc, lds_ptr, size, voffset, soffset, offset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> RawPtrBufferLoadLdsOp:
  return RawPtrBufferLoadLdsOp(rsrc=rsrc, ldsPtr=lds_ptr, size=size, voffset=voffset, soffset=soffset, offset=offset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RawPtrBufferLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.ptr.buffer.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def soffset(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def aux(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def raw_ptr_buffer_load(res, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RawPtrBufferLoadOp(res=res, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RawPtrBufferStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.raw.ptr.buffer.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, vdata, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vdata)
    operands.append(rsrc)
    operands.append(offset)
    operands.append(soffset)
    operands.append(aux)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vdata(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rsrc(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def soffset(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def aux(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

def raw_ptr_buffer_store(vdata, rsrc, offset, soffset, aux, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> RawPtrBufferStoreOp:
  return RawPtrBufferStoreOp(vdata=vdata, rsrc=rsrc, offset=offset, soffset=soffset, aux=aux, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ReadfirstlaneOp(_ods_ir.OpView):
  r"""
  Returns the value in the lowest active lane of the input operand.
  """

  OPERATION_NAME = "rocdl.readfirstlane"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def readfirstlane(res, src, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReadfirstlaneOp(res=res, src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReadlaneOp(_ods_ir.OpView):
  r"""
  Get the value in lane `src1` from input `src0`.
  """

  OPERATION_NAME = "rocdl.readlane"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, src0, src1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src0)
    operands.append(src1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src0(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src1(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def readlane(res, src0, src1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReadlaneOp(res=res, src0=src0, src1=src1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SBarrierOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.s.barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def s_barrier(*, loc=None, ip=None) -> SBarrierOp:
  return SBarrierOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SSleepOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.s.sleep"

  _ODS_REGIONS = (0, True)

  def __init__(self, count, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count"] = (count if (
    isinstance(count, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(count, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def count(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["count"]

  @count.setter
  def count(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count"] = value

def s_sleep(count, *, loc=None, ip=None) -> SSleepOp:
  return SSleepOp(count=count, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SWaitcntOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.s.waitcnt"

  _ODS_REGIONS = (0, True)

  def __init__(self, bitfield, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["bitfield"] = (bitfield if (
    isinstance(bitfield, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(bitfield, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def bitfield(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["bitfield"]

  @bitfield.setter
  def bitfield(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bitfield"] = value

def s_waitcnt(bitfield, *, loc=None, ip=None) -> SWaitcntOp:
  return SWaitcntOp(bitfield=bitfield, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SchedBarrier(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.sched.barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, mask, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mask"] = (mask if (
    isinstance(mask, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(mask, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def mask(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["mask"]

  @mask.setter
  def mask(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mask"] = value

def sched_barrier(mask, *, loc=None, ip=None) -> SchedBarrier:
  return SchedBarrier(mask=mask, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SchedGroupBarrier(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.sched.group.barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, mask, size, groupId, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mask"] = (mask if (
    isinstance(mask, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(mask, context=_ods_context))
    attributes["size"] = (size if (
    isinstance(size, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(size, context=_ods_context))
    attributes["groupId"] = (groupId if (
    isinstance(groupId, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(groupId, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def mask(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["mask"]

  @mask.setter
  def mask(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mask"] = value

  @builtins.property
  def size(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["size"]

  @size.setter
  def size(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["size"] = value

  @builtins.property
  def groupId(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["groupId"]

  @groupId.setter
  def groupId(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["groupId"] = value

def sched_group_barrier(mask, size, group_id, *, loc=None, ip=None) -> SchedGroupBarrier:
  return SchedGroupBarrier(mask=mask, size=size, groupId=group_id, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SetPrioOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.s.setprio"

  _ODS_REGIONS = (0, True)

  def __init__(self, priority, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["priority"] = (priority if (
    isinstance(priority, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I16Attr')) else
      _ods_ir.AttrBuilder.get('I16Attr')(priority, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def priority(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["priority"]

  @priority.setter
  def priority(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["priority"] = value

def s_setprio(priority, *, loc=None, ip=None) -> SetPrioOp:
  return SetPrioOp(priority=priority, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ThreadIdXOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.workitem.id.x"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def workitem_id_x(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ThreadIdXOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ThreadIdYOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.workitem.id.y"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def workitem_id_y(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ThreadIdYOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ThreadIdZOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.workitem.id.z"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def workitem_id_z(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ThreadIdZOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class WaitDscntOp(_ods_ir.OpView):
  r"""
  Wait for the counter specified to be less-than or equal-to the `count`
  before continuing.
  
  Available on gfx12+.
  """

  OPERATION_NAME = "rocdl.s.wait.dscnt"

  _ODS_REGIONS = (0, True)

  def __init__(self, count, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count"] = (count if (
    isinstance(count, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I16Attr')) else
      _ods_ir.AttrBuilder.get('I16Attr')(count, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def count(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["count"]

  @count.setter
  def count(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count"] = value

def s_wait_dscnt(count, *, loc=None, ip=None) -> WaitDscntOp:
  return WaitDscntOp(count=count, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class WaitExpcntOp(_ods_ir.OpView):
  r"""
  Wait for the counter specified to be less-than or equal-to the `count`
  before continuing.
  
  Available on gfx12+.
  """

  OPERATION_NAME = "rocdl.s.wait.expcnt"

  _ODS_REGIONS = (0, True)

  def __init__(self, count, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count"] = (count if (
    isinstance(count, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I16Attr')) else
      _ods_ir.AttrBuilder.get('I16Attr')(count, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def count(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["count"]

  @count.setter
  def count(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count"] = value

def s_wait_expcnt(count, *, loc=None, ip=None) -> WaitExpcntOp:
  return WaitExpcntOp(count=count, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class WaitLoadcntOp(_ods_ir.OpView):
  r"""
  Wait for the counter specified to be less-than or equal-to the `count`
  before continuing.
  
  Available on gfx12+.
  """

  OPERATION_NAME = "rocdl.s.wait.loadcnt"

  _ODS_REGIONS = (0, True)

  def __init__(self, count, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count"] = (count if (
    isinstance(count, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I16Attr')) else
      _ods_ir.AttrBuilder.get('I16Attr')(count, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def count(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["count"]

  @count.setter
  def count(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count"] = value

def s_wait_loadcnt(count, *, loc=None, ip=None) -> WaitLoadcntOp:
  return WaitLoadcntOp(count=count, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class WaitStorecntOp(_ods_ir.OpView):
  r"""
  Wait for the counter specified to be less-than or equal-to the `count`
  before continuing.
  
  Available on gfx12+.
  """

  OPERATION_NAME = "rocdl.s.wait.storecnt"

  _ODS_REGIONS = (0, True)

  def __init__(self, count, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count"] = (count if (
    isinstance(count, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I16Attr')) else
      _ods_ir.AttrBuilder.get('I16Attr')(count, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def count(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["count"]

  @count.setter
  def count(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count"] = value

def s_wait_storecnt(count, *, loc=None, ip=None) -> WaitStorecntOp:
  return WaitStorecntOp(count=count, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class WavefrontSizeOp(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wavefrontsize"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, *, range=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if range is not None: attributes["range"] = (range if (
        isinstance(range, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_ConstantRangeAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_ConstantRangeAttr')(range, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def range(self) -> _Optional[_ods_ir.Attribute]:
    if "range" not in self.operation.attributes:
      return None
    return self.operation.attributes["range"]

  @range.setter
  def range(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["range"] = value
    elif "range" in self.operation.attributes:
      del self.operation.attributes["range"]

  @range.deleter
  def range(self):
    del self.operation.attributes["range"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wavefrontsize(res, *, range=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return WavefrontSizeOp(res=res, range=range, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ds_read_tr4_b64(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.ds.read.tr4.b64"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ds_read_tr4_b64_(res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ds_read_tr4_b64(res=res, ptr=ptr, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ds_read_tr6_b96(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.ds.read.tr6.b96"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ds_read_tr6_b96_(res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ds_read_tr6_b96(res=res, ptr=ptr, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ds_read_tr8_b64(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.ds.read.tr8.b64"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ds_read_tr8_b64_(res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ds_read_tr8_b64(res=res, ptr=ptr, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ds_read_tr16_b64(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.ds.read.tr16.b64"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    if alias_scopes is not None: attributes["alias_scopes"] = (alias_scopes if (
        isinstance(alias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(alias_scopes, context=_ods_context))
    if noalias_scopes is not None: attributes["noalias_scopes"] = (noalias_scopes if (
        isinstance(noalias_scopes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_AliasScopeArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_AliasScopeArrayAttr')(noalias_scopes, context=_ods_context))
    if tbaa is not None: attributes["tbaa"] = (tbaa if (
        isinstance(tbaa, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LLVM_TBAATagArrayAttr')) else
          _ods_ir.AttrBuilder.get('LLVM_TBAATagArrayAttr')(tbaa, context=_ods_context))
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def alias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "alias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["alias_scopes"]

  @alias_scopes.setter
  def alias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["alias_scopes"] = value
    elif "alias_scopes" in self.operation.attributes:
      del self.operation.attributes["alias_scopes"]

  @alias_scopes.deleter
  def alias_scopes(self):
    del self.operation.attributes["alias_scopes"]

  @builtins.property
  def noalias_scopes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "noalias_scopes" not in self.operation.attributes:
      return None
    return self.operation.attributes["noalias_scopes"]

  @noalias_scopes.setter
  def noalias_scopes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["noalias_scopes"] = value
    elif "noalias_scopes" in self.operation.attributes:
      del self.operation.attributes["noalias_scopes"]

  @noalias_scopes.deleter
  def noalias_scopes(self):
    del self.operation.attributes["noalias_scopes"]

  @builtins.property
  def tbaa(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tbaa" not in self.operation.attributes:
      return None
    return self.operation.attributes["tbaa"]

  @tbaa.setter
  def tbaa(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tbaa"] = value
    elif "tbaa" in self.operation.attributes:
      del self.operation.attributes["tbaa"]

  @tbaa.deleter
  def tbaa(self):
    del self.operation.attributes["tbaa"]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ds_read_tr16_b64_(res, ptr, *, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ds_read_tr16_b64(res=res, ptr=ptr, alias_scopes=alias_scopes, noalias_scopes=noalias_scopes, tbaa=tbaa, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_4x4x1f32(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.4x4x1f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_4x4x1f32_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_4x4x1f32(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_4x4x2bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.4x4x2bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_4x4x2bf16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_4x4x2bf16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_4x4x4bf16_1k(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.4x4x4bf16.1k"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_4x4x4bf16_1k_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_4x4x4bf16_1k(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_4x4x4f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.4x4x4f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_4x4x4f16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_4x4x4f16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x1f32(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x1f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x1f32_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x1f32(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x2bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x2bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x2bf16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x2bf16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x4bf16_1k(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x4bf16.1k"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x4bf16_1k_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x4bf16_1k(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x4f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x4f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x4f16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x4f16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x4f32(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x4f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x4f32_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x4f32(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x8_xf32(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x8.xf32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x8_xf32_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x8_xf32(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x8bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x8bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x8bf16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x8bf16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x16bf16_1k(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x16bf16.1k"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x16bf16_1k_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x16bf16_1k(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x16f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x16f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x16f16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x16f16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x32_bf8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x32.bf8.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x32_bf8_bf8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x32_bf8_bf8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x32_bf8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x32.bf8.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x32_bf8_fp8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x32_bf8_fp8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x32_bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x32.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x32_bf16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x32_bf16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x32_f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x32.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x32_f16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x32_f16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x32_fp8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x32.fp8.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x32_fp8_bf8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x32_fp8_bf8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_16x16x32_fp8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.16x16x32.fp8.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_16x16x32_fp8_fp8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_16x16x32_fp8_fp8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x1f32(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x1f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x1f32_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x1f32(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x2bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x2bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x2bf16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x2bf16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x2f32(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x2f32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x2f32_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x2f32(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x4_xf32(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x4.xf32"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x4_xf32_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x4_xf32(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x4bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x4bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x4bf16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x4bf16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x4bf16_1k(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x4bf16.1k"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x4bf16_1k_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x4bf16_1k(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x4f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x4f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x4f16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x4f16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x8bf16_1k(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x8bf16.1k"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x8bf16_1k_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x8bf16_1k(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x8f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x8f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x8f16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x8f16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x16_bf8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x16.bf8.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x16_bf8_bf8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x16_bf8_bf8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x16_bf8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x16.bf8.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x16_bf8_fp8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x16_bf8_fp8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x16_bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x16.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x16_bf16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x16_bf16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x16_f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x16.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x16_f16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x16_f16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x16_fp8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x16.fp8.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x16_fp8_bf8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x16_fp8_bf8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f32_32x32x16_fp8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f32.32x32x16.fp8.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f32_32x32x16_fp8_fp8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f32_32x32x16_fp8_fp8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f64_4x4x4f64(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f64.4x4x4f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f64_4x4x4f64_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f64_4x4x4f64(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_f64_16x16x4f64(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.f64.16x16x4f64"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_f64_16x16x4f64_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_f64_16x16x4f64(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_i32_4x4x4i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.i32.4x4x4i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_i32_4x4x4i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_i32_4x4x4i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_i32_16x16x4i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.i32.16x16x4i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_i32_16x16x4i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_i32_16x16x4i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_i32_16x16x16i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.i32.16x16x16i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_i32_16x16x16i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_i32_16x16x16i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_i32_16x16x32_i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.i32.16x16x32.i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_i32_16x16x32_i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_i32_16x16x32_i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_i32_16x16x64_i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.i32.16x16x64.i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_i32_16x16x64_i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_i32_16x16x64_i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_i32_32x32x4i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.i32.32x32x4i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_i32_32x32x4i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_i32_32x32x4i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_i32_32x32x8i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.i32.32x32x8i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_i32_32x32x8i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_i32_32x32x8i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_i32_32x32x16_i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.i32.32x32x16.i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_i32_32x32x16_i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_i32_32x32x16_i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_i32_32x32x32_i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.i32.32x32x32.i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_i32_32x32x32_i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_i32_32x32x32_i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_scale_f32_16x16x128_f8f6f4(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.scale.f32.16x16x128.f8f6f4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_scale_f32_16x16x128_f8f6f4_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_scale_f32_16x16x128_f8f6f4(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class mfma_scale_f32_32x32x64_f8f6f4(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.mfma.scale.f32.32x32x64.f8f6f4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mfma_scale_f32_32x32x64_f8f6f4_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return mfma_scale_f32_32x32x64_f8f6f4(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_16x16x32_bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.16x16x32.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_16x16x32_bf16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_16x16x32_bf16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_16x16x32_f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.16x16x32.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_16x16x32_f16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_16x16x32_f16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_16x16x64_bf8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.16x16x64.bf8.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_16x16x64_bf8_bf8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_16x16x64_bf8_bf8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_16x16x64_bf8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.16x16x64.bf8.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_16x16x64_bf8_fp8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_16x16x64_bf8_fp8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_16x16x64_fp8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.16x16x64.fp8.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_16x16x64_fp8_bf8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_16x16x64_fp8_bf8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_16x16x64_fp8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.16x16x64.fp8.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_16x16x64_fp8_fp8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_16x16x64_fp8_fp8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_32x32x16_bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.32x32x16.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_32x32x16_bf16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_32x32x16_bf16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_32x32x16_f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.32x32x16.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_32x32x16_f16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_32x32x16_f16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_32x32x32_bf8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.32x32x32.bf8.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_32x32x32_bf8_bf8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_32x32x32_bf8_bf8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_32x32x32_bf8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.32x32x32.bf8.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_32x32x32_bf8_fp8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_32x32x32_bf8_fp8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_32x32x32_fp8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.32x32x32.fp8.bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_32x32x32_fp8_bf8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_32x32x32_fp8_bf8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_f32_32x32x32_fp8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.f32.32x32x32.fp8.fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_f32_32x32x32_fp8_fp8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_f32_32x32x32_fp8_fp8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_i32_16x16x64_i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.i32.16x16x64.i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_i32_16x16x64_i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_i32_16x16x64_i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class smfmac_i32_32x32x32_i8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.smfmac.i32.32x32x32.i8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def smfmac_i32_32x32x32_i8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return smfmac_i32_32x32x32_i8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_bf16_16x16x16_bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.bf16.16x16x16.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_bf16_16x16x16_bf16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_bf16_16x16x16_bf16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f16_16x16x16_f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f16.16x16x16.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f16_16x16x16_f16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f16_16x16x16_f16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x16_bf8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x16.bf8_bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x16_bf8_bf8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x16_bf8_bf8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x16_bf8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x16.bf8_fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x16_bf8_fp8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x16_bf8_fp8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x16_bf16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x16.bf16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x16_bf16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x16_bf16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x16_f16(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x16.f16"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x16_f16_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x16_f16(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x16_fp8_bf8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x16.fp8_bf8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x16_fp8_bf8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x16_fp8_bf8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_f32_16x16x16_fp8_fp8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.f32.16x16x16.fp8_fp8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_f32_16x16x16_fp8_fp8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_f32_16x16x16_fp8_fp8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_i32_16x16x16_iu4(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.i32.16x16x16.iu4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_i32_16x16x16_iu4_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_i32_16x16x16_iu4(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_i32_16x16x16_iu8(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.i32.16x16x16.iu8"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_i32_16x16x16_iu8_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_i32_16x16x16_iu8(res=res, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class wmma_i32_16x16x32_iu4(_ods_ir.OpView):
  OPERATION_NAME = "rocdl.wmma.i32.16x16x32.iu4"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(res)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def res(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wmma_i32_16x16x32_iu4_(res, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return wmma_i32_16x16x32_iu4(res=res, args=args, loc=loc, ip=ip).result
