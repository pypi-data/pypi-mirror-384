
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "affine"

@_ods_cext.register_operation(_Dialect)
class AffineApplyOp(_ods_ir.OpView):
  r"""
  The `affine.apply` operation applies an [affine mapping](#affine-maps)
  to a list of SSA values, yielding a single SSA value. The number of
  dimension and symbol operands to `affine.apply` must be equal to the
  respective number of dimensional and symbolic inputs to the affine mapping;
  the affine mapping has to be one-dimensional, and so the `affine.apply`
  operation always returns one value. The input operands and result must all
  have ‘index’ type.
  
  An operand that is a valid dimension as per the [rules on valid affine
  dimensions and symbols](#restrictions-on-dimensions-and-symbols)
  cannot be used as a symbolic operand.
  
  Example:
  
  ```mlir
  #map = affine_map<(d0, d1) -> (d0 floordiv 8 + d1 floordiv 128)>
  ...
  %1 = affine.apply #map (%s, %t)
  
  // Inline example.
  %2 = affine.apply affine_map<(i)[s0] -> (i + s0)> (%42)[%n]
  ```
  """

  OPERATION_NAME = "affine.apply"

  _ODS_REGIONS = (0, True)

  def __init__(self, map, mapOperands, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(mapOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["map"] = (map if (
    isinstance(map, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(map, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def mapOperands(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def map(self) -> _ods_ir.AffineMapAttr:
    return self.operation.attributes["map"]

  @map.setter
  def map(self, value: _ods_ir.AffineMapAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["map"] = value

def apply(map, map_operands, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AffineApplyOp(map=map, mapOperands=map_operands, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AffineDelinearizeIndexOp(_ods_ir.OpView):
  r"""
  The `affine.delinearize_index` operation takes a single index value and
  calculates the multi-index according to the given basis.
  
  Example:
  
  ```
  %indices:3 = affine.delinearize_index %linear_index into (%c16, %c224, %c224) : index, index, index
  ```
  
  In the above example, `%indices:3` conceptually holds the following:
  
  ```
  #map0 = affine_map<()[s0] -> (s0 floordiv 50176)>
  #map1 = affine_map<()[s0] -> ((s0 mod 50176) floordiv 224)>
  #map2 = affine_map<()[s0] -> (s0 mod 224)>
  %indices_0 = affine.apply #map0()[%linear_index]
  %indices_1 = affine.apply #map1()[%linear_index]
  %indices_2 = affine.apply #map2()[%linear_index]
  ```
  
  In other words, `%0:3 = affine.delinearize_index %x into (B, C)` produces
  `%0 = {%x / (B * C), (%x mod (B * C)) / C, %x mod C}`.
  
  The basis may either contain `N` or `N-1` elements, where `N` is the number of results.
  If there are N basis elements, the first one will not be used during computations,
  but may be used during analysis and canonicalization to eliminate terms from
  the `affine.delinearize_index` or to enable conclusions about the total size of
  `%linear_index`.
  
  If the basis is fully provided, the delinearize_index operation is said to "have
  an outer bound". The builders assume that an `affine.delinearize_index` has
  an outer bound by default, as this is how the operation was initially defined.
  
  That is, the example above could also have been written
  ```mlir
  %0:3 = affine.delinearize_index %linear_index into (244, 244) : index, index
  ```
  
  Note that, for symmetry with `getPaddedBasis()`, if `hasOuterBound` is `true`
  when one of the `OpFoldResult` builders is called but the first element of the
  basis is `nullptr`, that first element is ignored and the builder proceeds as if
  there was no outer bound.
  
  Due to the constraints of affine maps, all the basis elements must
  be strictly positive. A dynamic basis element being 0 or negative causes
  undefined behavior.
  
  As with other affine operations, lowerings of delinearize_index may assume
  that the underlying computations do not overflow the index type in a signed sense
  - that is, the product of all basis elements is positive as an `index` as well.
  """

  OPERATION_NAME = "affine.delinearize_index"

  _ODS_REGIONS = (0, True)

  def __init__(self, multi_index, linear_index, dynamic_basis, static_basis, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(linear_index)
    operands.extend(_get_op_results_or_values(dynamic_basis))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["static_basis"] = (static_basis if (
    isinstance(static_basis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(static_basis, context=_ods_context))
    results = []
    results.extend(multi_index)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def linear_index(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def dynamic_basis(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def static_basis(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["static_basis"]

  @static_basis.setter
  def static_basis(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["static_basis"] = value

  @builtins.property
  def multi_index(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def delinearize_index(multi_index, linear_index, dynamic_basis, static_basis, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, AffineDelinearizeIndexOp]:
  op = AffineDelinearizeIndexOp(multi_index=multi_index, linear_index=linear_index, dynamic_basis=dynamic_basis, static_basis=static_basis, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class AffineForOp(_ods_ir.OpView):
  r"""
  Syntax:
  
  ```
  operation   ::= `affine.for` ssa-id `=` lower-bound `to` upper-bound
                  (`step` integer-literal)? `{` op* `}`
  
  lower-bound ::= `max`? affine-map-attribute dim-and-symbol-use-list | shorthand-bound
  upper-bound ::= `min`? affine-map-attribute dim-and-symbol-use-list | shorthand-bound
  shorthand-bound ::= ssa-id | `-`? integer-literal
  ```
  
  The `affine.for` operation represents an affine loop nest. It has one region
  containing its body. This region must contain one block that terminates with
  [`affine.yield`](#affineyield-mliraffineyieldop). *Note:* when
  `affine.for` is printed in custom format, the terminator is omitted. The
  block has one argument of [`index`](Builtin.md/#indextype) type that
  represents the induction variable of the loop.
  
  The `affine.for` operation executes its body a number of times iterating
  from a lower bound to an upper bound by a stride. The stride, represented by
  `step`, is a positive constant integer which defaults to "1" if not present.
  The lower and upper bounds specify a half-open range: the range includes the
  lower bound but does not include the upper bound.
  
  The lower and upper bounds of a `affine.for` operation are represented as an
  application of an affine mapping to a list of SSA values passed to the map.
  The [same restrictions](#restrictions-on-dimensions-and-symbols) hold for
  these SSA values as for all bindings of SSA values to dimensions and
  symbols.
  
  The affine mappings for the bounds may return multiple results, in which
  case the `max`/`min` keywords are required (for the lower/upper bound
  respectively), and the bound is the maximum/minimum of the returned values.
  There is no semantic ambiguity, but MLIR syntax requires the use of these
  keywords to make things more obvious to human readers.
  
  Many upper and lower bounds are simple, so MLIR accepts two custom form
  syntaxes: the form that accepts a single 'ssa-id' (e.g. `%N`) is shorthand
  for applying that SSA value to a function that maps a single symbol to
  itself, e.g., `()[s]->(s)()[%N]`. The integer literal form (e.g. `-42`) is
  shorthand for a nullary mapping function that returns the constant value
  (e.g. `()->(-42)()`).
  
  Example showing reverse iteration of the inner loop:
  
  ```mlir
  #map57 = affine_map<(d0)[s0] -> (s0 - d0 - 1)>
  
  func.func @simple_example(%A: memref<?x?xf32>, %B: memref<?x?xf32>) {
    %N = dim %A, 0 : memref<?x?xf32>
    affine.for %i = 0 to %N step 1 {
      affine.for %j = 0 to %N {   // implicitly steps by 1
        %0 = affine.apply #map57(%j)[%N]
        %tmp = call @F1(%A, %i, %0) : (memref<?x?xf32>, index, index)->(f32)
        call @F2(%tmp, %B, %i, %0) : (f32, memref<?x?xf32>, index, index)->()
      }
    }
    return
  }
  ```
  `affine.for` can also operate on loop-carried variables (`iter_args`) and
  return the final values after loop termination. The initial values of the
  variables are passed as additional SSA operands to the `affine.for`
  following the operands for the loop's lower and upper bounds. The
  operation's region has equivalent arguments for each variable representing
  the value of the variable at the current iteration.
  
  The region must terminate with an `affine.yield` that passes all the current
  iteration variables to the next iteration, or to the `affine.for`'s results
  if at the last iteration. For `affine.for`'s that execute zero iterations, the
  initial values of the loop-carried variables (corresponding to the SSA
  operands) will be the op's results.
  
  For example, to sum-reduce a memref:
  
   ```mlir
  func.func @reduce(%buffer: memref<1024xf32>) -> (f32) {
    // Initial sum set to 0.
    %sum_0 = arith.constant 0.0 : f32
    // iter_args binds initial values to the loop's region arguments.
    %sum = affine.for %i = 0 to 10 step 2
        iter_args(%sum_iter = %sum_0) -> (f32) {
      %t = affine.load %buffer[%i] : memref<1024xf32>
      %sum_next = arith.addf %sum_iter, %t : f32
      // Yield current iteration sum to next iteration %sum_iter or to %sum
      // if final iteration.
      affine.yield %sum_next : f32
    }
    return %sum : f32
  }
  ```
  
  ```mlir
  %res:2 = affine.for %i = 0 to 128 iter_args(%arg0 = %init0, %arg1 = %init1)
             -> (index, index) {
    %y0 = arith.addi %arg0, %c1 : index
    %y1 = arith.addi %arg1, %c2 : index
    affine.yield %y0, %y1 : index, index
  }
  ```
  If the `affine.for` defines any values, a yield terminator must be
  explicitly present. The number and types of the "affine.for" results must
  match the initial values in the `iter_args` binding and the yield operands.
  """

  OPERATION_NAME = "affine.for"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, lowerBoundOperands, upperBoundOperands, inits, lowerBoundMap, upperBoundMap, step, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(lowerBoundOperands))
    operands.append(_get_op_results_or_values(upperBoundOperands))
    operands.append(_get_op_results_or_values(inits))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["lowerBoundMap"] = (lowerBoundMap if (
    isinstance(lowerBoundMap, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(lowerBoundMap, context=_ods_context))
    attributes["upperBoundMap"] = (upperBoundMap if (
    isinstance(upperBoundMap, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(upperBoundMap, context=_ods_context))
    attributes["step"] = (step if (
    isinstance(step, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(step, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lowerBoundOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def upperBoundOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def inits(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def lowerBoundMap(self) -> _ods_ir.AffineMapAttr:
    return self.operation.attributes["lowerBoundMap"]

  @lowerBoundMap.setter
  def lowerBoundMap(self, value: _ods_ir.AffineMapAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lowerBoundMap"] = value

  @builtins.property
  def upperBoundMap(self) -> _ods_ir.AffineMapAttr:
    return self.operation.attributes["upperBoundMap"]

  @upperBoundMap.setter
  def upperBoundMap(self, value: _ods_ir.AffineMapAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["upperBoundMap"] = value

  @builtins.property
  def step(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["step"]

  @step.setter
  def step(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["step"] = value

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def for_(results_, lower_bound_operands, upper_bound_operands, inits, lower_bound_map, upper_bound_map, step, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, AffineForOp]:
  op = AffineForOp(results_=results_, lowerBoundOperands=lower_bound_operands, upperBoundOperands=upper_bound_operands, inits=inits, lowerBoundMap=lower_bound_map, upperBoundMap=upper_bound_map, step=step, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class AffineIfOp(_ods_ir.OpView):
  r"""
  Syntax:
  
  ```
  operation  ::= `affine.if` if-op-cond `{` op* `}` (`else` `{` op* `}`)?
  if-op-cond ::= integer-set-attr dim-and-symbol-use-list
  ```
  
  The `affine.if` operation restricts execution to a subset of the loop
  iteration space defined by an integer set (a conjunction of affine
  constraints). A single `affine.if` may end with an optional `else` clause.
  
  The condition of the `affine.if` is represented by an
  [integer set](#integer-sets) (a conjunction of affine constraints),
  and the SSA values bound to the dimensions and symbols in the integer set.
  The [same restrictions](#restrictions-on-dimensions-and-symbols) hold for
  these SSA values as for all bindings of SSA values to dimensions and
  symbols.
  
  The `affine.if` operation contains two regions for the "then" and "else"
  clauses.  `affine.if` may return results that are defined in its regions.
  The values defined are determined by which execution path is taken.  Each
  region of the `affine.if` must contain a single block with no arguments,
  and be terminated by `affine.yield`.  If `affine.if` defines no values,
  the `affine.yield` can be left out, and will be inserted implicitly.
  Otherwise, it must be explicit.  If no values are defined, the else block
  may be empty (i.e. contain no blocks).
  
  Example:
  
  ```mlir
  #set = affine_set<(d0, d1)[s0]: (d0 - 10 >= 0, s0 - d0 - 9 >= 0,
                                   d1 - 10 >= 0, s0 - d1 - 9 >= 0)>
  func.func @reduced_domain_example(%A, %X, %N) : (memref<10xi32>, i32, i32) {
    affine.for %i = 0 to %N {
       affine.for %j = 0 to %N {
         %0 = affine.apply #map42(%j)
         %tmp = call @S1(%X, %i, %0)
         affine.if #set(%i, %j)[%N] {
            %1 = affine.apply #map43(%i, %j)
            call @S2(%tmp, %A, %i, %1)
         }
      }
    }
    return
  }
  ```
  
  Example with an explicit yield (initialization with edge padding):
  
  ```mlir
  #interior = affine_set<(i, j) : (i - 1 >= 0, j - 1 >= 0,  10 - i >= 0, 10 - j >= 0)> (%i, %j)
  func.func @pad_edges(%I : memref<10x10xf32>) -> (memref<12x12xf32) {
    %O = alloc memref<12x12xf32>
    affine.parallel (%i, %j) = (0, 0) to (12, 12) {
      %1 = affine.if #interior (%i, %j) {
        %2 = load %I[%i - 1, %j - 1] : memref<10x10xf32>
        affine.yield %2
      } else {
        %2 = arith.constant 0.0 : f32
        affine.yield %2 : f32
      }
      affine.store %1, %O[%i, %j] : memref<12x12xf32>
    }
    return %O
  }
  ```
  """

  OPERATION_NAME = "affine.if"

  _ODS_REGIONS = (2, True)

  def __init__(self, results_, _gen_arg_0, condition, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(_gen_arg_0))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["condition"] = (condition if (
    isinstance(condition, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IntegerSetAttr')) else
      _ods_ir.AttrBuilder.get('IntegerSetAttr')(condition, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self) -> _ods_ir.IntegerSetAttr:
    return self.operation.attributes["condition"]

  @condition.setter
  def condition(self, value: _ods_ir.IntegerSetAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["condition"] = value

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def thenRegion(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def elseRegion(self) -> _ods_ir.Region:
    return self.regions[1]

def if_(results_, _gen_arg_0, condition, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, AffineIfOp]:
  op = AffineIfOp(results_=results_, _gen_arg_0=_gen_arg_0, condition=condition, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class AffineLinearizeIndexOp(_ods_ir.OpView):
  r"""
  The `affine.linearize_index` operation takes a sequence of index values and a
  basis of the same length and linearizes the indices using that basis.
  
  That is, for indices `%idx_0` to `%idx_{N-1}` and basis elements `b_0`
  (or `b_1`) up to `b_{N-1}` it computes
  
  ```
  sum(i = 0 to N-1) %idx_i * product(j = i + 1 to N-1) B_j
  ```
  
  In other words, `%0 = affine.linearize_index [%z, %y, %x] by (Z, Y, X)`
  gives `%0 = %x + %y * X + %z * X * Y`, or `%0 = %x + X * (%y + Y * (%z))`.
  
  The basis may either have `N` or `N-1` elements, where `N` is the number of
  inputs to linearize_index. If `N` inputs are provided, the first one is not used
  in computation, but may be used during analysis or canonicalization as a bound
  on `%idx_0`.
  
  If all `N` basis elements are provided, the linearize_index operation is said to
  "have an outer bound".
  
  As a convenience, and for symmetry with `getPaddedBasis()`, ifg the first
  element of a set of `OpFoldResult`s passed to the builders of this operation is
  `nullptr`, that element is ignored.
  
  If the `disjoint` property is present, this is an optimization hint that,
  for all `i`, `0 <= %idx_i < B_i` - that is, no index affects any other index,
  except that `%idx_0` may be negative to make the index as a whole negative.
  In addition, `disjoint` is an assertion that all bases elements are non-negative.
  
  Note that the outputs of `affine.delinearize_index` are, by definition, `disjoint`.
  
  As with other affine ops, undefined behavior occurs if the linearization
  computation overflows in the signed sense.
  
  Example:
  
  ```mlir
  %linear_index = affine.linearize_index [%index_0, %index_1, %index_2] by (2, 3, 5) : index
  // Same effect
  %linear_index = affine.linearize_index [%index_0, %index_1, %index_2] by (3, 5) : index
  ```
  
  In the above example, `%linear_index` conceptually holds the following:
  
  ```mlir
  #map = affine_map<()[s0, s1, s2] -> (s0 * 15 + s1 * 5 + s2)>
  %linear_index = affine.apply #map()[%index_0, %index_1, %index_2]
  ```
  """

  OPERATION_NAME = "affine.linearize_index"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, multi_index, dynamic_basis, static_basis, disjoint, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(multi_index))
    operands.append(_get_op_results_or_values(dynamic_basis))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["static_basis"] = (static_basis if (
    isinstance(static_basis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(static_basis, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def multi_index(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def dynamic_basis(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def static_basis(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["static_basis"]

  @static_basis.setter
  def static_basis(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["static_basis"] = value

  @builtins.property
  def linear_index(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def linearize_index(multi_index, dynamic_basis, static_basis, disjoint, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AffineLinearizeIndexOp(multi_index=multi_index, dynamic_basis=dynamic_basis, static_basis=static_basis, disjoint=disjoint, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AffineLoadOp(_ods_ir.OpView):
  r"""
  Syntax:
  
  ```
  operation ::= ssa-id `=` `affine.load` ssa-use `[` multi-dim-affine-map-of-ssa-ids `]` `:` memref-type
  ```
  
  The `affine.load` op reads an element from a memref, where the index
  for each memref dimension is an affine expression of loop induction
  variables and symbols. The output of `affine.load` is a new value with the
  same type as the elements of the memref. An affine expression of loop IVs
  and symbols must be specified for each dimension of the memref. The keyword
  `symbol` can be used to indicate SSA identifiers which are symbolic.
  
  Example 1:
  
  ```mlir
  %1 = affine.load %0[%i0 + 3, %i1 + 7] : memref<100x100xf32>
  ```
  
  Example 2: Uses `symbol` keyword for symbols `%n` and `%m`.
  
  ```mlir
  %1 = affine.load %0[%i0 + symbol(%n), %i1 + symbol(%m)] : memref<100x100xf32>
  ```
  """

  OPERATION_NAME = "affine.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, memref, indices, map, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(memref)
    operands.extend(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["map"] = (map if (
    isinstance(map, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(map, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memref(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def indices(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def map(self) -> _ods_ir.AffineMapAttr:
    return self.operation.attributes["map"]

  @map.setter
  def map(self, value: _ods_ir.AffineMapAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["map"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def load(result, memref, indices, map, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AffineLoadOp(result=result, memref=memref, indices=indices, map=map, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AffineMaxOp(_ods_ir.OpView):
  r"""
  The `affine.max` operation computes the maximum value result from a multi-result
  affine map.
  
  Example:
  
  ```mlir
  %0 = affine.max (d0) -> (1000, d0 + 512) (%i0) : index
  ```
  """

  OPERATION_NAME = "affine.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, map, operands_, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["map"] = (map if (
    isinstance(map, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(map, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def map(self) -> _ods_ir.AffineMapAttr:
    return self.operation.attributes["map"]

  @map.setter
  def map(self, value: _ods_ir.AffineMapAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["map"] = value

def max(map, operands_, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AffineMaxOp(map=map, operands_=operands_, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AffineMinOp(_ods_ir.OpView):
  r"""
  Syntax:
  
  ```
  operation ::= ssa-id `=` `affine.min` affine-map-attribute dim-and-symbol-use-list
  ```
  
  The `affine.min` operation applies an [affine mapping](#affine-expressions)
  to a list of SSA values, and returns the minimum value of all result
  expressions. The number of dimension and symbol arguments to `affine.min`
  must be equal to the respective number of dimensional and symbolic inputs to
  the affine mapping; the `affine.min` operation always returns one value. The
  input operands and result must all have 'index' type.
  
  Example:
  
  ```mlir
  %0 = affine.min affine_map<(d0)[s0] -> (1000, d0 + 512, s0)> (%arg0)[%arg1]
  ```
  """

  OPERATION_NAME = "affine.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, map, operands_, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["map"] = (map if (
    isinstance(map, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(map, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def map(self) -> _ods_ir.AffineMapAttr:
    return self.operation.attributes["map"]

  @map.setter
  def map(self, value: _ods_ir.AffineMapAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["map"] = value

def min(map, operands_, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AffineMinOp(map=map, operands_=operands_, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AffineParallelOp(_ods_ir.OpView):
  r"""
  The `affine.parallel` operation represents a hyper-rectangular affine
  parallel band, defining zero or more SSA values for its induction variables.
  It has one region capturing the parallel band body. The induction variables
  are represented as arguments of this region. These SSA values always have
  type index, which is the size of the machine word. The strides, represented
  by steps, are positive constant integers which defaults to "1" if not
  present. The lower and upper bounds specify a half-open range: the range
  includes the lower bound but does not include the upper bound. The body
  region must contain exactly one block that terminates with `affine.yield`.
  
  The lower and upper bounds of a parallel operation are represented as an
  application of an affine mapping to a list of SSA values passed to the map.
  The same restrictions hold for these SSA values as for all bindings of SSA
  values to dimensions and symbols. The list of expressions in each map is
  interpreted according to the respective bounds group attribute. If a single
  expression belongs to the group, then the result of this expression is taken
  as a lower(upper) bound of the corresponding loop induction variable. If
  multiple expressions belong to the group, then the lower(upper) bound is the
  max(min) of these values obtained from these expressions. The loop band has
  as many loops as elements in the group bounds attributes.
  
  Each value yielded by `affine.yield` will be accumulated/reduced via one of
  the reduction methods defined in the AtomicRMWKind enum.  The order of
  reduction is unspecified, and lowering may produce any valid ordering.
  Loops with a 0 trip count will produce as a result the identity value
  associated with each reduction (i.e. 0.0 for addf, 1.0 for mulf).  Assign
  reductions for loops with a trip count != 1 produces undefined results.
  
  Note: Calling `AffineParallelOp::build` will create the required region and
  block, and insert the required terminator if it is trivial (i.e. no values
  are yielded).  Parsing will also create the required region, block, and
  terminator, even when they are missing from the textual representation.
  
  Example (3x3 valid convolution):
  
  ```mlir
  func.func @conv_2d(%D : memref<100x100xf32>, %K : memref<3x3xf32>) -> (memref<98x98xf32>) {
    %O = memref.alloc() : memref<98x98xf32>
    affine.parallel (%x, %y) = (0, 0) to (98, 98) {
      %0 = affine.parallel (%kx, %ky) = (0, 0) to (2, 2) reduce ("addf") -> f32 {
        %1 = affine.load %D[%x + %kx, %y + %ky] : memref<100x100xf32>
        %2 = affine.load %K[%kx, %ky] : memref<3x3xf32>
        %3 = arith.mulf %1, %2 : f32
        affine.yield %3 : f32
      }
      affine.store %0, %O[%x, %y] : memref<98x98xf32>
    }
    return %O : memref<98x98xf32>
  }
  ```
  
  Example (tiling by potentially imperfectly dividing sizes):
  
  ```mlir
  affine.parallel (%ii, %jj) = (0, 0) to (%N, %M) step (32, 32) {
    affine.parallel (%i, %j) = (%ii, %jj)
                            to (min(%ii + 32, %N), min(%jj + 32, %M)) {
      call @f(%i, %j) : (index, index) -> ()
    }
  }
  ```
  """

  OPERATION_NAME = "affine.parallel"

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, reductions, lowerBoundsMap, lowerBoundsGroups, upperBoundsMap, upperBoundsGroups, steps, mapOperands, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(mapOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["reductions"] = (reductions if (
    isinstance(reductions, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_496')) else
      _ods_ir.AttrBuilder.get('anonymous_496')(reductions, context=_ods_context))
    attributes["lowerBoundsMap"] = (lowerBoundsMap if (
    isinstance(lowerBoundsMap, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(lowerBoundsMap, context=_ods_context))
    attributes["lowerBoundsGroups"] = (lowerBoundsGroups if (
    isinstance(lowerBoundsGroups, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32ElementsAttr')) else
      _ods_ir.AttrBuilder.get('I32ElementsAttr')(lowerBoundsGroups, context=_ods_context))
    attributes["upperBoundsMap"] = (upperBoundsMap if (
    isinstance(upperBoundsMap, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(upperBoundsMap, context=_ods_context))
    attributes["upperBoundsGroups"] = (upperBoundsGroups if (
    isinstance(upperBoundsGroups, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32ElementsAttr')) else
      _ods_ir.AttrBuilder.get('I32ElementsAttr')(upperBoundsGroups, context=_ods_context))
    attributes["steps"] = (steps if (
    isinstance(steps, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64SmallVectorArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64SmallVectorArrayAttr')(steps, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def mapOperands(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def reductions(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["reductions"]

  @reductions.setter
  def reductions(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reductions"] = value

  @builtins.property
  def lowerBoundsMap(self) -> _ods_ir.AffineMapAttr:
    return self.operation.attributes["lowerBoundsMap"]

  @lowerBoundsMap.setter
  def lowerBoundsMap(self, value: _ods_ir.AffineMapAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lowerBoundsMap"] = value

  @builtins.property
  def lowerBoundsGroups(self) -> _ods_ir.DenseIntElementsAttr:
    return self.operation.attributes["lowerBoundsGroups"]

  @lowerBoundsGroups.setter
  def lowerBoundsGroups(self, value: _ods_ir.DenseIntElementsAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lowerBoundsGroups"] = value

  @builtins.property
  def upperBoundsMap(self) -> _ods_ir.AffineMapAttr:
    return self.operation.attributes["upperBoundsMap"]

  @upperBoundsMap.setter
  def upperBoundsMap(self, value: _ods_ir.AffineMapAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["upperBoundsMap"] = value

  @builtins.property
  def upperBoundsGroups(self) -> _ods_ir.DenseIntElementsAttr:
    return self.operation.attributes["upperBoundsGroups"]

  @upperBoundsGroups.setter
  def upperBoundsGroups(self, value: _ods_ir.DenseIntElementsAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["upperBoundsGroups"] = value

  @builtins.property
  def steps(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["steps"]

  @steps.setter
  def steps(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["steps"] = value

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def parallel(results_, reductions, lower_bounds_map, lower_bounds_groups, upper_bounds_map, upper_bounds_groups, steps, map_operands, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, AffineParallelOp]:
  op = AffineParallelOp(results_=results_, reductions=reductions, lowerBoundsMap=lower_bounds_map, lowerBoundsGroups=lower_bounds_groups, upperBoundsMap=upper_bounds_map, upperBoundsGroups=upper_bounds_groups, steps=steps, mapOperands=map_operands, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class AffinePrefetchOp(_ods_ir.OpView):
  r"""
  The `affine.prefetch` op prefetches data from a memref location described
  with an affine subscript similar to affine.load, and has three attributes:
  a read/write specifier, a locality hint, and a cache type specifier as shown
  below:
  
  ```mlir
  affine.prefetch %0[%i, %j + 5], read, locality<3>, data : memref<400x400xi32>
  ```
  
  The read/write specifier is either 'read' or 'write', the locality hint
  specifier ranges from locality<0> (no locality) to locality<3> (extremely
  local keep in cache). The cache type specifier is either 'data' or 'instr'
  and specifies whether the prefetch is performed on data cache or on
  instruction cache.
  """

  OPERATION_NAME = "affine.prefetch"

  _ODS_REGIONS = (0, True)

  def __init__(self, memref, indices, isWrite, localityHint, isDataCache, map, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(memref)
    operands.extend(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["isWrite"] = (isWrite if (
    isinstance(isWrite, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(isWrite, context=_ods_context))
    attributes["localityHint"] = (localityHint if (
    isinstance(localityHint, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(localityHint, context=_ods_context))
    attributes["isDataCache"] = (isDataCache if (
    isinstance(isDataCache, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(isDataCache, context=_ods_context))
    attributes["map"] = (map if (
    isinstance(map, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(map, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memref(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def indices(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def isWrite(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["isWrite"]

  @isWrite.setter
  def isWrite(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["isWrite"] = value

  @builtins.property
  def localityHint(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["localityHint"]

  @localityHint.setter
  def localityHint(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["localityHint"] = value

  @builtins.property
  def isDataCache(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["isDataCache"]

  @isDataCache.setter
  def isDataCache(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["isDataCache"] = value

  @builtins.property
  def map(self) -> _ods_ir.AffineMapAttr:
    return self.operation.attributes["map"]

  @map.setter
  def map(self, value: _ods_ir.AffineMapAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["map"] = value

def prefetch(memref, indices, is_write, locality_hint, is_data_cache, map, *, loc=None, ip=None) -> AffinePrefetchOp:
  return AffinePrefetchOp(memref=memref, indices=indices, isWrite=is_write, localityHint=locality_hint, isDataCache=is_data_cache, map=map, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AffineStoreOp(_ods_ir.OpView):
  r"""
  Syntax:
  
  ```
  operation ::= `affine.store` ssa-use, ssa-use `[` multi-dim-affine-map-of-ssa-ids `]` `:` memref-type
  ```
  
  The `affine.store` op writes an element to a memref, where the index
  for each memref dimension is an affine expression of loop induction
  variables and symbols. The `affine.store` op stores a new value which is the
  same type as the elements of the memref. An affine expression of loop IVs
  and symbols must be specified for each dimension of the memref. The keyword
  `symbol` can be used to indicate SSA identifiers which are symbolic.
  
  Example 1:
  
  ```mlir
  affine.store %v0, %0[%i0 + 3, %i1 + 7] : memref<100x100xf32>
  ```
  
  Example 2: Uses `symbol` keyword for symbols `%n` and `%m`.
  
  ```mlir
  affine.store %v0, %0[%i0 + symbol(%n), %i1 + symbol(%m)] : memref<100x100xf32>
  ```
  """

  OPERATION_NAME = "affine.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, memref, indices, map, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(memref)
    operands.extend(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["map"] = (map if (
    isinstance(map, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(map, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def memref(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def map(self) -> _ods_ir.AffineMapAttr:
    return self.operation.attributes["map"]

  @map.setter
  def map(self, value: _ods_ir.AffineMapAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["map"] = value

def store(value, memref, indices, map, *, loc=None, ip=None) -> AffineStoreOp:
  return AffineStoreOp(value=value, memref=memref, indices=indices, map=map, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AffineVectorLoadOp(_ods_ir.OpView):
  r"""
  The `affine.vector_load` is the vector counterpart of
  [affine.load](#affineload-mliraffineloadop). It reads a slice from a
  [MemRef](Builtin.md/#memreftype), supplied as its first operand,
  into a [vector](Builtin.md/#vectortype) of the same base elemental type.
  The index for each memref dimension is an affine expression of loop induction
  variables and symbols. These indices determine the start position of the read
  within the memref. The shape of the return vector type determines the shape of
  the slice read from the memref. This slice is contiguous along the respective
  dimensions of the shape. Strided vector loads will be supported in the future.
  An affine expression of loop IVs and symbols must be specified for each
  dimension of the memref. The keyword `symbol` can be used to indicate SSA
  identifiers which are symbolic.
  
  Example 1: 8-wide f32 vector load.
  
  ```mlir
  %1 = affine.vector_load %0[%i0 + 3, %i1 + 7] : memref<100x100xf32>, vector<8xf32>
  ```
  
  Example 2: 4-wide f32 vector load. Uses `symbol` keyword for symbols `%n` and `%m`.
  
  ```mlir
  %1 = affine.vector_load %0[%i0 + symbol(%n), %i1 + symbol(%m)] : memref<100x100xf32>, vector<4xf32>
  ```
  
  Example 3: 2-dim f32 vector load.
  
  ```mlir
  %1 = affine.vector_load %0[%i0, %i1] : memref<100x100xf32>, vector<2x8xf32>
  ```
  
  TODOs:
  * Add support for strided vector loads.
  * Consider adding a permutation map to permute the slice that is read from memory
  (see [vector.transfer_read](../Vector/#vectortransfer_read-mlirvectortransferreadop)).
  """

  OPERATION_NAME = "affine.vector_load"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, memref, indices, map, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(memref)
    operands.extend(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["map"] = (map if (
    isinstance(map, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(map, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memref(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def indices(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def map(self) -> _ods_ir.AffineMapAttr:
    return self.operation.attributes["map"]

  @map.setter
  def map(self, value: _ods_ir.AffineMapAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["map"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def vector_load(result, memref, indices, map, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AffineVectorLoadOp(result=result, memref=memref, indices=indices, map=map, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AffineVectorStoreOp(_ods_ir.OpView):
  r"""
  The `affine.vector_store` is the vector counterpart of
  [affine.store](#affinestore-mliraffinestoreop). It writes a
  [vector](Builtin.md/#vectortype), supplied as its first operand,
  into a slice within a [MemRef](Builtin.md/#memreftype) of the same base
  elemental type, supplied as its second operand.
  The index for each memref dimension is an affine expression of loop
  induction variables and symbols. These indices determine the start position
  of the write within the memref. The shape of th input vector determines the
  shape of the slice written to the memref. This slice is contiguous along the
  respective dimensions of the shape. Strided vector stores will be supported
  in the future.
  An affine expression of loop IVs and symbols must be specified for each
  dimension of the memref. The keyword `symbol` can be used to indicate SSA
  identifiers which are symbolic.
  
  Example 1: 8-wide f32 vector store.
  
  ```mlir
  affine.vector_store %v0, %0[%i0 + 3, %i1 + 7] : memref<100x100xf32>, vector<8xf32>
  ```
  
  Example 2: 4-wide f32 vector store. Uses `symbol` keyword for symbols `%n` and `%m`.
  
  ```mlir
  affine.vector_store %v0, %0[%i0 + symbol(%n), %i1 + symbol(%m)] : memref<100x100xf32>, vector<4xf32>
  ```
  
  Example 3: 2-dim f32 vector store.
  
  ```mlir
  affine.vector_store %v0, %0[%i0, %i1] : memref<100x100xf32>, vector<2x8xf32>
  ```
  
  TODOs:
  * Add support for strided vector stores.
  * Consider adding a permutation map to permute the slice that is written to memory
  (see [vector.transfer_write](../Vector/#vectortransfer_write-mlirvectortransferwriteop)).
  """

  OPERATION_NAME = "affine.vector_store"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, memref, indices, map, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(memref)
    operands.extend(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["map"] = (map if (
    isinstance(map, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AffineMapAttr')) else
      _ods_ir.AttrBuilder.get('AffineMapAttr')(map, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def memref(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def map(self) -> _ods_ir.AffineMapAttr:
    return self.operation.attributes["map"]

  @map.setter
  def map(self, value: _ods_ir.AffineMapAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["map"] = value

def vector_store(value, memref, indices, map, *, loc=None, ip=None) -> AffineVectorStoreOp:
  return AffineVectorStoreOp(value=value, memref=memref, indices=indices, map=map, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AffineYieldOp(_ods_ir.OpView):
  r"""
  The `affine.yield` yields zero or more SSA values from an affine op region and
  terminates the region. The semantics of how the values yielded are used
  is defined by the parent operation.
  If `affine.yield` has any operands, the operands must match the parent
  operation's results.
  If the parent operation defines no values, then the `affine.yield` may be
  left out in the custom syntax and the builders will insert one implicitly.
  Otherwise, it has to be present in the syntax to indicate which values are
  yielded.
  """

  OPERATION_NAME = "affine.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def yield_(operands_, *, loc=None, ip=None) -> AffineYieldOp:
  return AffineYieldOp(operands_=operands_, loc=loc, ip=ip)
