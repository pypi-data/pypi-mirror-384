
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


from ._transform_ops_gen import _Dialect

@_ods_cext.register_operation(_Dialect)
class EmitRemarkOp(_ods_ir.OpView):
  r"""
  Emits a diagnostic remark with the given message located at payload ops
  associated with the given handle. This can be used, e.g., for debugging.
  """

  OPERATION_NAME = "transform.iree.emit_remark"

  _ODS_REGIONS = (0, True)

  def __init__(self, handle, message, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(handle)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["message"] = (message if (
    isinstance(message, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def handle(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def message(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["message"] = value

def iree_emit_remark(handle, message, *, loc=None, ip=None) -> EmitRemarkOp:
  return EmitRemarkOp(handle=handle, message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MatchCallbackOp(_ods_ir.OpView):
  r"""
  Performs payload IR matching using a C++ callback registered beforehand.
  The callback is identified by name and is passed the current transform
  state and the list of handle operands, along with information necessary
  for error propagation. See `register_match_callbacks` for the description
  of the callback contract.
  
  If `failure_propagation_mode` is set to `suppress`, any silenceable errors
  in the callback (typically, "failure to match") will be ignored and the
  resulting handles will be associated with empty lists of payload
  operations. Otherwise, silenceable failures are propagated.
  """

  OPERATION_NAME = "transform.iree.match_callback"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, callback_name, failure_propagation_mode, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callback_name"] = (callback_name if (
    isinstance(callback_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(callback_name, context=_ods_context))
    attributes["failure_propagation_mode"] = (failure_propagation_mode if (
    isinstance(failure_propagation_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FailurePropagationMode')) else
      _ods_ir.AttrBuilder.get('FailurePropagationMode')(failure_propagation_mode, context=_ods_context))
    results = []
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def callback_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["callback_name"]

  @callback_name.setter
  def callback_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callback_name"] = value

  @builtins.property
  def failure_propagation_mode(self) -> _ods_ir.Attribute:
    return self.operation.attributes["failure_propagation_mode"]

  @failure_propagation_mode.setter
  def failure_propagation_mode(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["failure_propagation_mode"] = value

  @builtins.property
  def outputs(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def iree_match_callback(outputs, callback_name, failure_propagation_mode, inputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, MatchCallbackOp]:
  op = MatchCallbackOp(outputs=outputs, callback_name=callback_name, failure_propagation_mode=failure_propagation_mode, inputs=inputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class RegisterMatchCallbacksOp(_ods_ir.OpView):
  r"""
  Registers named structured op matcher callbacks specific for IREE to use
  with `transform.iree.match_callback`. This should be called before first
  `match_callback` may be executed following the transform dialect control
  flow.
  
  The callbacks must have a unique name and a signature compatible with
  `MatchCallbacksRegistry::MatchCallbackFn`, which currently means
  `DiagnosedSilenceableFailure(MatchCallbackResult &, Location,
   const TransformState &, ValueRange)`. The callback receives a "result",
   followed by a location at which errors should be reported, a transform
   state at the moment of the _match_ (not registration) and a list of
   handle values passed as operands to the `match_callback` operation.
   It is expected to populate the "result" object with lists of payload
   operations that will be bound to the handles produced by the
   `match_callback` operation. The callback may fail, at which point
   it should produce a silenceable error. The callback currently is not
   allowed to modify the payload IR (though this may be revised in the
   future for the purpose of communicating the properties of the IR
   captured by the match). Therefore, it should not have a reason to
   produce a definite error.
  """

  OPERATION_NAME = "transform.iree.register_match_callbacks"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def iree_register_match_callbacks(*, loc=None, ip=None) -> RegisterMatchCallbacksOp:
  return RegisterMatchCallbacksOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TakeFirstOp(_ods_ir.OpView):
  r"""
  Given an arbitrary list of handles associated with potentially empty lists
  of payload operations, produces two new handles:
  
    - a handle pointing to the same payload operations as the first operand
      handle with a non-empty list of payload operations;
    - a handle pointing to the concatenated list of payload operations
      associated with any other handle.
  
  Note that this does not perform any deduplication.
  
  This operation is useful to select a single target after some potentially
  unsuccessful matches.
  """

  OPERATION_NAME = "transform.iree.take_first"

  _ODS_REGIONS = (0, True)

  def __init__(self, first, rest, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(first)
    results.append(rest)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def first(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def rest(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def iree_take_first(first, rest, inputs, *, loc=None, ip=None) -> _ods_ir.OpResultList:
  return TakeFirstOp(first=first, rest=rest, inputs=inputs, loc=loc, ip=ip).results
