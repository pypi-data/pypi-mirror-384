
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "complex"

@_ods_cext.register_operation(_Dialect)
class AbsOp(_ods_ir.OpView):
  r"""
  The `abs` op takes a single complex number and computes its absolute value.
  
  Example:
  
  ```mlir
  %a = complex.abs %b : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.abs"

  _ODS_REGIONS = (0, True)

  def __init__(self, complex, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(complex)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def complex(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def abs(complex, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AbsOp(complex=complex, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AddOp(_ods_ir.OpView):
  r"""
  The `add` operation takes two complex numbers and returns their sum.
  
  Example:
  
  ```mlir
  %a = complex.add %b, %c : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def add(lhs, rhs, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AddOp(lhs=lhs, rhs=rhs, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AngleOp(_ods_ir.OpView):
  r"""
  The `angle` op takes a single complex number and computes its argument value with a branch cut along the negative real axis.
  
  Example:
  
  ```mlir
       %a = complex.angle %b : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.angle"

  _ODS_REGIONS = (0, True)

  def __init__(self, complex, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(complex)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def complex(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def angle(complex, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AngleOp(complex=complex, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Atan2Op(_ods_ir.OpView):
  r"""
  For complex numbers it is expressed using complex logarithm
  atan2(y, x) = -i * log((x + i * y) / sqrt(x**2 + y**2))
  
  Example:
  
  ```mlir
  %a = complex.atan2 %b, %c : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.atan2"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def atan2(lhs, rhs, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return Atan2Op(lhs=lhs, rhs=rhs, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitcastOp(_ods_ir.OpView):
  r"""
  Example:
  
  ```mlir
       %a = complex.bitcast %b : complex<f32> -> i64
  ```
  """

  OPERATION_NAME = "complex.bitcast"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bitcast(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BitcastOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConjOp(_ods_ir.OpView):
  r"""
  The `conj` op takes a single complex number and computes the
  complex conjugate.
  
  Example:
  
  ```mlir
  %a = complex.conj %b: complex<f32>
  ```
  """

  OPERATION_NAME = "complex.conj"

  _ODS_REGIONS = (0, True)

  def __init__(self, complex, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(complex)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def complex(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def conj(complex, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConjOp(complex=complex, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantOp(_ods_ir.OpView):
  r"""
  The `complex.constant` operation creates a constant complex number from an
  attribute containing the real and imaginary parts.
  
  Example:
  
  ```mlir
  %a = complex.constant [0.1, -1.0] : complex<f64>
  ```
  """

  OPERATION_NAME = "complex.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, complex, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(value, context=_ods_context))
    results = []
    results.append(complex)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def complex(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def constant(complex, value, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstantOp(complex=complex, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CosOp(_ods_ir.OpView):
  r"""
  The `cos` op takes a single complex number and computes the cosine of
  it, i.e. `cos(x)`, where `x` is the input value.
  
  Example:
  
  ```mlir
  %a = complex.cos %b : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.cos"

  _ODS_REGIONS = (0, True)

  def __init__(self, complex, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(complex)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def complex(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cos(complex, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CosOp(complex=complex, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CreateOp(_ods_ir.OpView):
  r"""
  The `complex.create` operation creates a complex number from two
  floating-point operands, the real and the imaginary part.
  
  Example:
  
  ```mlir
  %a = complex.create %b, %c : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, complex, real, imaginary, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(real)
    operands.append(imaginary)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(complex)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def real(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def imaginary(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def complex(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def create_(complex, real, imaginary, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CreateOp(complex=complex, real=real, imaginary=imaginary, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DivOp(_ods_ir.OpView):
  r"""
  The `div` operation takes two complex numbers and returns result of their
  division:
  
  ```mlir
  %a = complex.div %b, %c : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.div"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def div(lhs, rhs, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DivOp(lhs=lhs, rhs=rhs, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EqualOp(_ods_ir.OpView):
  r"""
  The `eq` op takes two complex numbers and returns whether they are equal.
  
  Example:
  
  ```mlir
  %a = complex.eq %b, %c : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.eq"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def eq(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return EqualOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExpOp(_ods_ir.OpView):
  r"""
  The `exp` op takes a single complex number and computes the exponential of
  it, i.e. `exp(x)` or `e^(x)`, where `x` is the input value.
  `e` denotes Euler's number and is approximately equal to 2.718281.
  
  Example:
  
  ```mlir
  %a = complex.exp %b : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.exp"

  _ODS_REGIONS = (0, True)

  def __init__(self, complex, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(complex)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def complex(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def exp(complex, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExpOp(complex=complex, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Expm1Op(_ods_ir.OpView):
  r"""
  complex.expm1(x) := complex.exp(x) - 1
  
  Example:
  
  ```mlir
  %a = complex.expm1 %b : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.expm1"

  _ODS_REGIONS = (0, True)

  def __init__(self, complex, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(complex)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def complex(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def expm1(complex, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return Expm1Op(complex=complex, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ImOp(_ods_ir.OpView):
  r"""
  The `im` op takes a single complex number and extracts the imaginary part.
  
  Example:
  
  ```mlir
  %a = complex.im %b : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.im"

  _ODS_REGIONS = (0, True)

  def __init__(self, complex, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(complex)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def complex(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def imaginary(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def im(complex, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ImOp(complex=complex, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Log1pOp(_ods_ir.OpView):
  r"""
  The `log` op takes a single complex number and computes the natural
  logarithm of one plus the given value, i.e. `log(1 + x)` or `log_e(1 + x)`,
  where `x` is the input value. `e` denotes Euler's number and is
  approximately equal to 2.718281.
  
  Example:
  
  ```mlir
  %a = complex.log1p %b : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.log1p"

  _ODS_REGIONS = (0, True)

  def __init__(self, complex, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(complex)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def complex(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def log1p(complex, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return Log1pOp(complex=complex, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogOp(_ods_ir.OpView):
  r"""
  The `log` op takes a single complex number and computes the natural
  logarithm of it, i.e. `log(x)` or `log_e(x)`, where `x` is the input value.
  `e` denotes Euler's number and is approximately equal to 2.718281.
  
  Example:
  
  ```mlir
  %a = complex.log %b : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.log"

  _ODS_REGIONS = (0, True)

  def __init__(self, complex, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(complex)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def complex(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def log(complex, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return LogOp(complex=complex, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MulOp(_ods_ir.OpView):
  r"""
  The `mul` operation takes two complex numbers and returns their product:
  
  ```mlir
  %a = complex.mul %b, %c : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mul(lhs, rhs, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MulOp(lhs=lhs, rhs=rhs, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NegOp(_ods_ir.OpView):
  r"""
  The `neg` op takes a single complex number `complex` and returns `-complex`.
  
  Example:
  
  ```mlir
  %a = complex.neg %b : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.neg"

  _ODS_REGIONS = (0, True)

  def __init__(self, complex, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(complex)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def complex(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def neg(complex, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return NegOp(complex=complex, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NotEqualOp(_ods_ir.OpView):
  r"""
  The `neq` op takes two complex numbers and returns whether they are not
  equal.
  
  Example:
  
  ```mlir
  %a = complex.neq %b, %c : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.neq"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def neq(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return NotEqualOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PowOp(_ods_ir.OpView):
  r"""
  The `pow` operation takes a complex number raises it to the given complex
  exponent.
  
  Example:
  
  ```mlir
  %a = complex.pow %b, %c : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.pow"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def pow(lhs, rhs, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return PowOp(lhs=lhs, rhs=rhs, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PowiOp(_ods_ir.OpView):
  r"""
  The `powi` operation takes a `base` operand of complex type and a `power`
  operand of signed integer type and returns one result of the same type
  as `base`. The result is `base` raised to the power of `power`.
  
  Example:
  
  ```mlir
  %a = complex.powi %b, %c : complex<f32>, i32
  ```
  """

  OPERATION_NAME = "complex.powi"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def fastmath(self) -> _Optional[_ods_ir.Attribute]:
    if "fastmath" not in self.operation.attributes:
      return None
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["fastmath"] = value
    elif "fastmath" in self.operation.attributes:
      del self.operation.attributes["fastmath"]

  @fastmath.deleter
  def fastmath(self):
    del self.operation.attributes["fastmath"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def powi(lhs, rhs, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return PowiOp(lhs=lhs, rhs=rhs, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReOp(_ods_ir.OpView):
  r"""
  The `re` op takes a single complex number and extracts the real part.
  
  Example:
  
  ```mlir
  %a = complex.re %b : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.re"

  _ODS_REGIONS = (0, True)

  def __init__(self, complex, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(complex)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def complex(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def real(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def re(complex, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReOp(complex=complex, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RsqrtOp(_ods_ir.OpView):
  r"""
  The `rsqrt` operation computes reciprocal of square root.
  
  Example:
  
  ```mlir
  %a = complex.rsqrt %b : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.rsqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, complex, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(complex)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def complex(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def rsqrt(complex, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RsqrtOp(complex=complex, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SignOp(_ods_ir.OpView):
  r"""
  The `sign` op takes a single complex number and computes the sign of
  it, i.e. `y = sign(x) = x / |x|` if `x != 0`, otherwise `y = 0`.
  
  Example:
  
  ```mlir
  %a = complex.sign %b : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.sign"

  _ODS_REGIONS = (0, True)

  def __init__(self, complex, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(complex)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def complex(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def sign(complex, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SignOp(complex=complex, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SinOp(_ods_ir.OpView):
  r"""
  The `sin` op takes a single complex number and computes the sine of
  it, i.e. `sin(x)`, where `x` is the input value.
  
  Example:
  
  ```mlir
  %a = complex.sin %b : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.sin"

  _ODS_REGIONS = (0, True)

  def __init__(self, complex, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(complex)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def complex(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def sin(complex, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SinOp(complex=complex, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SqrtOp(_ods_ir.OpView):
  r"""
  The `sqrt` operation takes a complex number and returns its square root.
  
  Example:
  
  ```mlir
  %a = complex.sqrt %b : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.sqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, complex, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(complex)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def complex(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def sqrt(complex, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SqrtOp(complex=complex, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SubOp(_ods_ir.OpView):
  r"""
  The `sub` operation takes two complex numbers and returns their difference.
  
  Example:
  
  ```mlir
  %a = complex.sub %b, %c : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.sub"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def sub(lhs, rhs, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SubOp(lhs=lhs, rhs=rhs, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TanOp(_ods_ir.OpView):
  r"""
  The `tan` op takes a single complex number and computes the tangent of
  it, i.e. `tan(x)`, where `x` is the input value.
  
  Example:
  
  ```mlir
  %a = complex.tan %b : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.tan"

  _ODS_REGIONS = (0, True)

  def __init__(self, complex, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(complex)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def complex(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tan(complex, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TanOp(complex=complex, fastmath=fastmath, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TanhOp(_ods_ir.OpView):
  r"""
  The `tanh` operation takes a complex number and returns its hyperbolic
  tangent.
  
  Example:
  
  ```mlir
  %a = complex.tanh %b : complex<f32>
  ```
  """

  OPERATION_NAME = "complex.tanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, complex, *, fastmath=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(complex)
    _ods_context = _ods_get_default_loc_context(loc)
    if fastmath is not None: attributes["fastmath"] = (fastmath if (
        isinstance(fastmath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Arith_FastMathAttr')) else
          _ods_ir.AttrBuilder.get('Arith_FastMathAttr')(fastmath, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def complex(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def fastmath(self) -> _ods_ir.Attribute:
    return self.operation.attributes["fastmath"]

  @fastmath.setter
  def fastmath(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fastmath"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tanh(complex, *, fastmath=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TanhOp(complex=complex, fastmath=fastmath, results=results, loc=loc, ip=ip).result
