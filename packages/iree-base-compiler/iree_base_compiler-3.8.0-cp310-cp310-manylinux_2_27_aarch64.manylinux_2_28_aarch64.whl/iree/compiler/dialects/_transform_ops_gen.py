
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "transform"

@_ods_cext.register_operation(_Dialect)
class AlternativesOp(_ods_ir.OpView):
  r"""
  This op may have an arbitrary number of regions, each of which represents a
  sequence of transform operations to be applied to the same payload IR. The
  regions are visited in order of appearance, and transforms in them are
  applied in their respective order of appearance. If one of these transforms
  fails to apply, the remaining ops in the same region are skipped an the next
  region is attempted. If all transformations in a region succeed, the
  remaining regions are skipped and the entire "alternatives" transformation
  succeeds. If all regions contained a failing transformation, the entire
  "alternatives" transformation fails.
  
  It is up to the nested operations to define which errors are "recoverable"
  (or "silenceable") and allow another alternatives to be attempted, and which
  errors should be propagated without attempting the other alternatives.
  
  The single operand of this operation is the scope in which the alternative
  transformation sequences are attempted, that is, an operation in the payload
  IR that contains all the other operations that may be modified by the
  transformations. The scope operation must be isolated from above. There is
  no check that the transforms are indeed scoped as their "apply" methods can
  be arbitrarily complex. Therefore it is the responsibility of the user to
  ensure that the transforms are scoped correctly, or to produce an
  irrecoverable error and thus abort the execution without attempting the
  remaining alternatives. Note that the payload IR outside of the given scope
  is not necessarily in the valid state, or even accessible to the
  transformation.
  
  The changes to the IR within the scope performed by transforms in the failed
  alternative region are reverted before attempting the next region.
  Practically, this is achieved by cloning the scope. Therefore it is advised
  to limit the scope as much as possible and place the most likely
  alternatives early in the region list. The operation is also isolated from
  above and requires rediscovering the operations within the given scope to
  avoid additional handle invalidation. The latter restriction may be lifted
  in the future.
  
  Each of the regions may yield transform IR handles. The handles of the first
  successful alternative region are returned as the results of the
  "alternatives" op. Therefore, each alternative region must yield the same
  number of results, which should also match the number and the types of the
  "alternatives" op results.
  
  Remark: this op allows one to implement a simple "try" construct as follows:
  
  ```mlir
  %result = transform.alternatives %scope {
  ^bb0(%arg0: !transform.any_op):
    // Try a fallible transformation.
    %0 = transform.fallible %arg0 // ...
    // If succeeded, yield the the result of the transformation.
    transform.yield %0 : !transform.any_op
  }, {
  ^bb0(%arg0: !transform.any_op):
    // Otherwise, the second alternative is tried and it always succeeds by
    // returning the original handle.
    transform.yield %arg0 : !transform.any_op
  }
  ```
  """

  OPERATION_NAME = "transform.alternatives"

  _ODS_REGIONS = (0, False)

  def __init__(self, results_, num_alternatives, *, scope=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    if scope is not None: operands.append(scope)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(results_)
    _ods_successors = None
    regions = 0 + num_alternatives
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def scope(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 1 else self.operation.operands[0]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def alternatives(self) -> _ods_ir.RegionSequence:
    return self.regions[0:]

def alternatives(results_, num_alternatives, *, scope=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, AlternativesOp]:
  op = AlternativesOp(results_=results_, num_alternatives=num_alternatives, scope=scope, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class AnnotateOp(_ods_ir.OpView):
  r"""
  Adds an attribute with the given `name` to the `target` operation. An
  optional `param` handle can be provided to give the attribute a specific
  value, else a UnitAttr is added. A single attribute will be broadcasted to
  all target operations, otherwise the attributes will be mapped 1:1 based on
  the order within the handles.
  
  Produces a silenceable failure if the length of the parameter payload does
  not match the length of the target payload. Does not consume the provided
  handles.
  """

  OPERATION_NAME = "transform.annotate"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, name, *, param=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    if param is not None: operands.append(param)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def param(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

def annotate(target, name, *, param=None, loc=None, ip=None) -> AnnotateOp:
  return AnnotateOp(target=target, name=name, param=param, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyCanonicalizationPatternsOp(_ods_ir.OpView):
  r"""
  This op populates all canonicalization patterns of all loaded dialects in
  an `apply_patterns` transform.
  """

  OPERATION_NAME = "transform.apply_patterns.canonicalization"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_canonicalization(*, loc=None, ip=None) -> ApplyCanonicalizationPatternsOp:
  return ApplyCanonicalizationPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyCommonSubexpressionEliminationOp(_ods_ir.OpView):
  r"""
  This transform applies common subexpression elimination (CSE) to the body
  of the targeted op.
  
  This transform reads the target handle and modifies the payload. Existing
  handles to operations inside of the targeted op are retained and updated if
  necessary. Note that this can lead to situations where a handle, that was
  previously mapped to multiple distinct (but equivalent) operations, is now
  mapped to the same operation multiple times.
  """

  OPERATION_NAME = "transform.apply_cse"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def apply_cse(target, *, loc=None, ip=None) -> ApplyCommonSubexpressionEliminationOp:
  return ApplyCommonSubexpressionEliminationOp(target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyConversionPatternsOp(_ods_ir.OpView):
  r"""
  This transform applies the specified conversion patterns to the targeted op
  and all nested ops. By default, this transform applies a "full" dialect
  conversion. If the `partial_conversion` unit attribute is present, this
  transform applies a partial dialect conversion.
  
  The patterns that should be applied are specified in the first graph region
  of this op. They must implement the
  `ConversionPatternDescriptorOpInterface`. The order in which patterns are
  applied is unspecified; i.e., the ordering of ops in the region of this op
  is irrelevant.
  
  The second, optional graph region contains exactly one op that specifies
  default type converter that should be used with this dialect conversion. If
  provided, this op must implement the `TypeConverterBuilderOpInterface`.
  Type converters are a property of conversion patterns: each conversion
  pattern stores the type converter that should be used in its C++ class. Each
  conversion pattern descriptor can optionally specify a type converter in its
  `getTypeConverter` interface method. If no type converter is specified in
  this method, the default type converter of the dialect conversion is used.
  Default type converters are useful if the same type converter should be used
  for multiple sets of conversion patterns. (Patterns that should not use this
  default type converter specify their own type converter.)
  
  The `legal_ops`, `illegal_ops`, `legal_dialects`, `illegal_dialects`
  attributes specify the conversion target.
  
  This transform modifies the payload. By default, it consumes the `target`
  handle. It does not produce any handles.
  
  If the `preserve_handles` attribute is set, this transform does not consume
  the `target` handle and instead updates handles based on notifications from
  a tracking listener that is attached to the dialect conversion, similar to
  `transform.apply_patterns`. Only replacements via `RewriterBase::replaceOp`
  or `replaceOpWithNewOp` are considered "payload op replacements". In
  contrast to `transform.apply_patterns`, we allow replacement ops even if the
  op name has changed. This is because conversion patterns are expected to
  lower ops to different ops (from a different dialect). More details can be
  found at the documentation site of `TrackingListener`.
  
  This transform produces a silenceable failure if the dialect conversion was
  unsuccessful or the tracking listener failed to find a replacement op.
  """

  OPERATION_NAME = "transform.apply_conversion_patterns"

  _ODS_REGIONS = (1, False)

  def __init__(self, target, num_default_type_converter_region, *, legal_ops=None, illegal_ops=None, legal_dialects=None, illegal_dialects=None, partial_conversion=None, preserve_handles=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if legal_ops is not None: attributes["legal_ops"] = (legal_ops if (
        isinstance(legal_ops, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
          _ods_ir.AttrBuilder.get('StrArrayAttr')(legal_ops, context=_ods_context))
    if illegal_ops is not None: attributes["illegal_ops"] = (illegal_ops if (
        isinstance(illegal_ops, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
          _ods_ir.AttrBuilder.get('StrArrayAttr')(illegal_ops, context=_ods_context))
    if legal_dialects is not None: attributes["legal_dialects"] = (legal_dialects if (
        isinstance(legal_dialects, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
          _ods_ir.AttrBuilder.get('StrArrayAttr')(legal_dialects, context=_ods_context))
    if illegal_dialects is not None: attributes["illegal_dialects"] = (illegal_dialects if (
        isinstance(illegal_dialects, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
          _ods_ir.AttrBuilder.get('StrArrayAttr')(illegal_dialects, context=_ods_context))
    if bool(partial_conversion): attributes["partial_conversion"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(preserve_handles): attributes["preserve_handles"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    _ods_successors = None
    regions = 1 + num_default_type_converter_region
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def legal_ops(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "legal_ops" not in self.operation.attributes:
      return None
    return self.operation.attributes["legal_ops"]

  @legal_ops.setter
  def legal_ops(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["legal_ops"] = value
    elif "legal_ops" in self.operation.attributes:
      del self.operation.attributes["legal_ops"]

  @legal_ops.deleter
  def legal_ops(self):
    del self.operation.attributes["legal_ops"]

  @builtins.property
  def illegal_ops(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "illegal_ops" not in self.operation.attributes:
      return None
    return self.operation.attributes["illegal_ops"]

  @illegal_ops.setter
  def illegal_ops(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["illegal_ops"] = value
    elif "illegal_ops" in self.operation.attributes:
      del self.operation.attributes["illegal_ops"]

  @illegal_ops.deleter
  def illegal_ops(self):
    del self.operation.attributes["illegal_ops"]

  @builtins.property
  def legal_dialects(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "legal_dialects" not in self.operation.attributes:
      return None
    return self.operation.attributes["legal_dialects"]

  @legal_dialects.setter
  def legal_dialects(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["legal_dialects"] = value
    elif "legal_dialects" in self.operation.attributes:
      del self.operation.attributes["legal_dialects"]

  @legal_dialects.deleter
  def legal_dialects(self):
    del self.operation.attributes["legal_dialects"]

  @builtins.property
  def illegal_dialects(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "illegal_dialects" not in self.operation.attributes:
      return None
    return self.operation.attributes["illegal_dialects"]

  @illegal_dialects.setter
  def illegal_dialects(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["illegal_dialects"] = value
    elif "illegal_dialects" in self.operation.attributes:
      del self.operation.attributes["illegal_dialects"]

  @illegal_dialects.deleter
  def illegal_dialects(self):
    del self.operation.attributes["illegal_dialects"]

  @builtins.property
  def partial_conversion(self) -> bool:
    return "partial_conversion" in self.operation.attributes

  @partial_conversion.setter
  def partial_conversion(self, value):
    if bool(value):
      self.operation.attributes["partial_conversion"] = _ods_ir.UnitAttr.get()
    elif "partial_conversion" in self.operation.attributes:
      del self.operation.attributes["partial_conversion"]

  @partial_conversion.deleter
  def partial_conversion(self):
    del self.operation.attributes["partial_conversion"]

  @builtins.property
  def preserve_handles(self) -> bool:
    return "preserve_handles" in self.operation.attributes

  @preserve_handles.setter
  def preserve_handles(self, value):
    if bool(value):
      self.operation.attributes["preserve_handles"] = _ods_ir.UnitAttr.get()
    elif "preserve_handles" in self.operation.attributes:
      del self.operation.attributes["preserve_handles"]

  @preserve_handles.deleter
  def preserve_handles(self):
    del self.operation.attributes["preserve_handles"]

  @builtins.property
  def patterns(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def default_type_converter_region(self) -> _ods_ir.RegionSequence:
    return self.regions[1:]

def apply_conversion_patterns(target, num_default_type_converter_region, *, legal_ops=None, illegal_ops=None, legal_dialects=None, illegal_dialects=None, partial_conversion=None, preserve_handles=None, loc=None, ip=None) -> ApplyConversionPatternsOp:
  return ApplyConversionPatternsOp(target=target, num_default_type_converter_region=num_default_type_converter_region, legal_ops=legal_ops, illegal_ops=illegal_ops, legal_dialects=legal_dialects, illegal_dialects=illegal_dialects, partial_conversion=partial_conversion, preserve_handles=preserve_handles, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyDeadCodeEliminationOp(_ods_ir.OpView):
  r"""
  This transform applies dead code elimination (DCE) to the body of the
  targeted op.
  
  Note: "transform.apply_patterns" with an empty region can also be used to
  remove dead ops. However, that op applies additional simplifications such as
  op folding and region simplification.
  
  This transform reads the target handle and modifies the payload. Note that
  this transform may silently remove payload ops from handles.
  """

  OPERATION_NAME = "transform.apply_dce"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def apply_dce(target, *, loc=None, ip=None) -> ApplyDeadCodeEliminationOp:
  return ApplyDeadCodeEliminationOp(target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyLoopInvariantCodeMotionOp(_ods_ir.OpView):
  r"""
  This transform moves side-effect free, loop invariant code out of the
  targeted loop-like op. The targeted op must implement the
  `LoopLikeOpInterface`.
  
  Note: To move invariant ops from a loop nest, this transform must be applied
  to each loop of the loop nest, starting with the inner-most loop.
  
  This transform reads the target handle and modifies the payload.
  """

  OPERATION_NAME = "transform.apply_licm"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def apply_licm(target, *, loc=None, ip=None) -> ApplyLoopInvariantCodeMotionOp:
  return ApplyLoopInvariantCodeMotionOp(target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyPatternsOp(_ods_ir.OpView):
  r"""
  This transform greedily applies the specified patterns to the body of the
  targeted op until a fixpoint was reached. Patterns are not applied to the
  targeted op itself.
  
  The patterns that should be applied are specified in the graph region of
  this op. They must implement the `PatternDescriptorOpInterface`. The order
  in which patterns are applied is unspecified; i.e., the ordering of ops in
  the region of this op is irrelevant.
  
  If `apple_cse` is set, the greedy pattern rewrite is interleaved with
  common subexpression elimination (CSE): both are repeated until a fixpoint
  is reached.
  
  This transform only reads the target handle and modifies the payload. If a
  pattern erases or replaces a tracked op, the mapping is updated accordingly.
  
  Only replacements via `RewriterBase::replaceOp` or `replaceOpWithNewOp` are
  considered "payload op replacements". Furthermore, only if the replacement
  values are defined by the same op and that op has the same type as the
  original op, the mapping is updated. Otherwise, this transform produces a
  silenceable failure. More details can be found at the documentation site of
  `TrackingListener`.
  
  This transform also produces a silenceable failure if the pattern
  application did not converge within the default number of
  iterations/rewrites of the greedy pattern rewrite driver.
  """

  OPERATION_NAME = "transform.apply_patterns"

  _ODS_REGIONS = (1, True)

  def __init__(self, target, *, apply_cse=None, max_iterations=None, max_num_rewrites=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(apply_cse): attributes["apply_cse"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if max_iterations is not None: attributes["max_iterations"] = (max_iterations if (
        isinstance(max_iterations, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(max_iterations, context=_ods_context))
    if max_num_rewrites is not None: attributes["max_num_rewrites"] = (max_num_rewrites if (
        isinstance(max_num_rewrites, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(max_num_rewrites, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def apply_cse(self) -> bool:
    return "apply_cse" in self.operation.attributes

  @apply_cse.setter
  def apply_cse(self, value):
    if bool(value):
      self.operation.attributes["apply_cse"] = _ods_ir.UnitAttr.get()
    elif "apply_cse" in self.operation.attributes:
      del self.operation.attributes["apply_cse"]

  @apply_cse.deleter
  def apply_cse(self):
    del self.operation.attributes["apply_cse"]

  @builtins.property
  def max_iterations(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["max_iterations"]

  @max_iterations.setter
  def max_iterations(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max_iterations"] = value

  @builtins.property
  def max_num_rewrites(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["max_num_rewrites"]

  @max_num_rewrites.setter
  def max_num_rewrites(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max_num_rewrites"] = value

  @builtins.property
  def patterns(self) -> _ods_ir.Region:
    return self.regions[0]

def apply_patterns(target, *, apply_cse=None, max_iterations=None, max_num_rewrites=None, loc=None, ip=None) -> ApplyPatternsOp:
  return ApplyPatternsOp(target=target, apply_cse=apply_cse, max_iterations=max_iterations, max_num_rewrites=max_num_rewrites, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyRegisteredPassOp(_ods_ir.OpView):
  r"""
  This transform applies the specified pass or pass pipeline to the targeted
  ops. The name of the pass/pipeline is specified as a string attribute, as
  set during pass/pipeline registration.
  
  Optionally, pass options may be specified via a DictionaryAttr. This
  dictionary is converted to a string -- formatted `key=value ...` -- which
  is expected to be in the exact format used by the pass on the commandline.
  Values are either attributes or (SSA-values of) Transform Dialect params.
  For example:
  
  ```mlir
  transform.apply_registered_pass "canonicalize"
      with options = { "top-down" = false,
                       "max-iterations" = %max_iter,
                       "test-convergence" = true,
                       "max-num-rewrites" = %max_rewrites }
      to %module
  : (!transform.any_param, !transform.any_param, !transform.any_op) -> !transform.any_op
  ```
  
  Options' values which are `ArrayAttr`s are converted to comma-separated
  lists of options. Likewise for params which associate multiple values.
  
  This op first looks for a pass pipeline with the specified name. If no such
  pipeline exists, it looks for a pass with the specified name. If no such
  pass exists either, this op fails definitely.
  
  This transform consumes the target handle and produces a new handle that is
  mapped to the same op. Passes are not allowed to remove/modify the operation
  that they operate on, so the target op is guaranteed to still exist. The
  target handle is invalidated because a pass may arbitrarily modify the body
  of targeted ops.
  """

  OPERATION_NAME = "transform.apply_registered_pass"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, target, pass_name, dynamic_options, *, options=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.extend(_get_op_results_or_values(dynamic_options))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pass_name"] = (pass_name if (
    isinstance(pass_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(pass_name, context=_ods_context))
    if options is not None: attributes["options"] = (options if (
        isinstance(options, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
          _ods_ir.AttrBuilder.get('DictionaryAttr')(options, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def dynamic_options(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def pass_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["pass_name"]

  @pass_name.setter
  def pass_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pass_name"] = value

  @builtins.property
  def options(self) -> _ods_ir.DictAttr:
    return self.operation.attributes["options"]

  @options.setter
  def options(self, value: _ods_ir.DictAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["options"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def apply_registered_pass(result, target, pass_name, dynamic_options, *, options=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ApplyRegisteredPassOp(result=result, target=target, pass_name=pass_name, dynamic_options=dynamic_options, options=options, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ApplyToLLVMConversionPatternsOp(_ods_ir.OpView):
  r"""
  Collects patterns that convert ops from the specified dialect to LLVM
  dialect ops. These patterns require an "LLVMTypeConverter".
  
  Note: Only dialects that implement the `ConvertToLLVMPatternInterface` are
  supported. Any conversion target modifications by interface implementations
  are currently ignored. The conversion target is fully specified by the
  enclosing "apply_conversion_patterns" op.
  """

  OPERATION_NAME = "transform.apply_conversion_patterns.dialect_to_llvm"

  _ODS_REGIONS = (0, True)

  def __init__(self, dialect_name, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dialect_name"] = (dialect_name if (
    isinstance(dialect_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(dialect_name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dialect_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["dialect_name"]

  @dialect_name.setter
  def dialect_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dialect_name"] = value

def apply_conversion_patterns_dialect_to_llvm(dialect_name, *, loc=None, ip=None) -> ApplyToLLVMConversionPatternsOp:
  return ApplyToLLVMConversionPatternsOp(dialect_name=dialect_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CastOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.cast"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cast(output, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CastOp(output=output, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CollectMatchingOp(_ods_ir.OpView):
  r"""
  Collects operations or other payload IR objects nested under `root`
  (inclusive) that match the given matcher expressed as a named sequence. The
  matcher sequence must accept exactly one argument that it is not allowed to
  modify. It must yield as many values as this op has results. Each of the
  yielded values must be associated with exactly one payload object. If any
  operation in the matcher sequence produces a silenceable failure, the
  matcher advances to the next payload operation in the walk order without
  finishing the sequence.
  
  The i-th result of this operation is constructed by concatenating the i-th
  yielded payload IR objects of all successful matcher sequence applications.
  All results are guaranteed to be mapped to the same number of payload IR
  objects.
  
  The operation succeeds unless the matcher sequence produced a definite
  failure for any invocation.
  """

  OPERATION_NAME = "transform.collect_matching"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, root, matcher, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(root)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["matcher"] = (matcher if (
    isinstance(matcher, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(matcher, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def root(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def matcher(self) -> _ods_ir.SymbolRefAttr:
    return self.operation.attributes["matcher"]

  @matcher.setter
  def matcher(self, value: _ods_ir.SymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["matcher"] = value

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def collect_matching(results_, root, matcher, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, CollectMatchingOp]:
  op = CollectMatchingOp(results_=results_, root=root, matcher=matcher, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ForeachMatchOp(_ods_ir.OpView):
  r"""
  Given a pair of co-indexed lists of transform dialect symbols (such as
  `transform.named_sequence`), walks the payload IR associated with the root
  handle and interprets the symbols as matcher/action pairs by applying the
  body of the corresponding symbol definition. The symbol from the first list
  is the matcher part: if it results in a silenceable error, the error is
  silenced and the next matcher is attempted. Definite failures from any
  matcher stop the application immediately and are propagated unconditionally.
  If none of the matchers succeeds, the next payload operation in walk order
  (post-order at the moment of writing, double check `Operation::walk`) is
  matched. If a matcher succeeds, the co-indexed action symbol is applied and
  the following matchers are not applied to the same payload operation. If the
  action succeeds, the next payload operation in walk order is matched. If it
  fails, both silenceable and definite errors are propagated as the result of
  this op; propagation of silenceable errors is postponed until the end of the
  walk.
  
  The matcher symbol must take at least one operand of a type that implements
  the same transform dialect interface as the `root` operand (a check is
  performed at application time to see if the associated payload satisfies the
  constraints of the actual type), and may take additional operands with a
  similar type requirement. It must not consume operands as multiple matchers
  may be applied. The matcher may produce any number of results. The action
  symbol paired with the matcher must take the same number of arguments as the
  matcher has results, and these arguments must implement the same transform
  dialect interfaces, but not necessarily have the exact same type (again, a
  check is performed at application time to see if the associated payload
  satisfies the constraints of actual types on both sides).
  
  The action symbol may have results that are accumulated from all actions and
  returned from the `foreach_match` operation on success. Unless the
  `flatten_results` attribute is present, each action result must be
  associated with exactly one payload entity. The actions are expected to only
  modify payload operations nested in the `root` payload operations associated
  with the operand of this transform operation. Furthermore, the actions may
  not modify operations outside of the currently matched payload operation,
  e.g., they may not modify sibling or parent operations. If such behavior is
  desired, the parent must be matched first and the nested operations obtained
  by traversing the IR from the parent. This is due to the matching being
  performed as a post-order IR walk.
  
  This operation consumes the operand and produces a new handle associated
  with the same payload. This is necessary to trigger invalidation of handles
  to any of the payload operations nested in the payload operations associated
  with the operand, as those are likely to be modified by actions.
  
  By default, the root payload operation associated with the operand is not
  matched. This is to support the conservative case where applied actions may
  invalidate the root payload operation. If the optional `restrict_root`
  attribute is set, the root operand is guaranteed to not be invalidated by any
  of the applied actions. In such cases, the root payload operation is also
  matched. This is useful because matching the root payload operation is a
  common idiom, when e.g. matching a func.func directly and operations nested
  under it.
  
  The operation succeeds if none of the matchers produced a definite failure
  during application and if all of the applied actions produced success. Note
  that it also succeeds if all the matchers failed on all payload operations,
  i.e. failure to apply is not an error. The operation produces a silenceable
  failure if any applied action produced a silenceable failure. In this case,
  the resulting handle is associated with an empty payload. The operation
  produces a definite failure if any of the applied matchers or actions
  produced a definite failure.
  """

  OPERATION_NAME = "transform.foreach_match"

  _ODS_REGIONS = (0, True)

  def __init__(self, updated, forwarded_outputs, root, forwarded_inputs, matchers, actions, *, restrict_root=None, flatten_results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(root)
    operands.extend(_get_op_results_or_values(forwarded_inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(restrict_root): attributes["restrict_root"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(flatten_results): attributes["flatten_results"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    attributes["matchers"] = (matchers if (
    isinstance(matchers, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(matchers, context=_ods_context))
    attributes["actions"] = (actions if (
    isinstance(actions, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(actions, context=_ods_context))
    results = []
    results.append(updated)
    results.extend(forwarded_outputs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def root(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def forwarded_inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def restrict_root(self) -> bool:
    return "restrict_root" in self.operation.attributes

  @restrict_root.setter
  def restrict_root(self, value):
    if bool(value):
      self.operation.attributes["restrict_root"] = _ods_ir.UnitAttr.get()
    elif "restrict_root" in self.operation.attributes:
      del self.operation.attributes["restrict_root"]

  @restrict_root.deleter
  def restrict_root(self):
    del self.operation.attributes["restrict_root"]

  @builtins.property
  def flatten_results(self) -> bool:
    return "flatten_results" in self.operation.attributes

  @flatten_results.setter
  def flatten_results(self, value):
    if bool(value):
      self.operation.attributes["flatten_results"] = _ods_ir.UnitAttr.get()
    elif "flatten_results" in self.operation.attributes:
      del self.operation.attributes["flatten_results"]

  @flatten_results.deleter
  def flatten_results(self):
    del self.operation.attributes["flatten_results"]

  @builtins.property
  def matchers(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["matchers"]

  @matchers.setter
  def matchers(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["matchers"] = value

  @builtins.property
  def actions(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["actions"]

  @actions.setter
  def actions(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["actions"] = value

  @builtins.property
  def updated(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def forwarded_outputs(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1:1 + _ods_variadic_group_length]

def foreach_match(updated, forwarded_outputs, root, forwarded_inputs, matchers, actions, *, restrict_root=None, flatten_results=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ForeachMatchOp]:
  op = ForeachMatchOp(updated=updated, forwarded_outputs=forwarded_outputs, root=root, forwarded_inputs=forwarded_inputs, matchers=matchers, actions=actions, restrict_root=restrict_root, flatten_results=flatten_results, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ForeachOp(_ods_ir.OpView):
  r"""
  Execute the op's body - its single region block - exactly once per
  element of the payload associated to a target handle. The body's
  transformations are applied in order of appearance until reaching the
  (implicit) YieldOp terminator.
  
  Each iteration gets executed by co-indexing the payloads of the arguments
  and mapping the body's arguments to these tuples, as though iterating over
  the zipped together `targets`. As such, in each iteration, the size of the
  payload of each of the body's block arguments is exactly one. The attribute
  `zip_shortest` can be used if the targets vary in their number of payloads;
  this will limit the iterations to only the number of payloads found in the
  shortest target.
  
  This op always reads the target handles. Furthermore, it consumes a handle
  if there is a transform op in the body that consumes the corresponding
  block argument. Handles can point to ops, values, or parameters.
  
  #### Return Modes
  
  This op produces as many result handles as the body's terminating YieldOp
  has operands. For each result, the payloads of the corresponding YieldOp
  operand are merged and mapped to the same resulting handle.
  
  If the target handles do not associate payloads of the same size, a
  silencable failure will be generated.
  
  During application, if any transformation in the sequence fails, the entire
  sequence fails immediately with the same failure, leaving the payload IR in
  a potentially invalid state, i.e., this operation offers no transformation
  rollback capabilities.
  """

  OPERATION_NAME = "transform.foreach"

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, targets, *, with_zip_shortest=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(targets))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(with_zip_shortest): attributes["with_zip_shortest"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def targets(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def with_zip_shortest(self) -> bool:
    return "with_zip_shortest" in self.operation.attributes

  @with_zip_shortest.setter
  def with_zip_shortest(self, value):
    if bool(value):
      self.operation.attributes["with_zip_shortest"] = _ods_ir.UnitAttr.get()
    elif "with_zip_shortest" in self.operation.attributes:
      del self.operation.attributes["with_zip_shortest"]

  @with_zip_shortest.deleter
  def with_zip_shortest(self):
    del self.operation.attributes["with_zip_shortest"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def foreach(results_, targets, *, with_zip_shortest=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ForeachOp]:
  op = ForeachOp(results_=results_, targets=targets, with_zip_shortest=with_zip_shortest, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class GetConsumersOfResult(_ods_ir.OpView):
  r"""
  The handle defined by this Transform op corresponds to all operations that
  consume the SSA value defined by the `target` and `result_number`
  arguments.
  This operation applies to a single payload operation, otherwise it produces
  a definite failure.
  The return handle points to the consuming operations operations, which can
  be empty.
  """

  OPERATION_NAME = "transform.get_consumers_of_result"

  _ODS_REGIONS = (0, True)

  def __init__(self, consumers, target, result_number, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["result_number"] = (result_number if (
    isinstance(result_number, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(result_number, context=_ods_context))
    results = []
    results.append(consumers)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result_number(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["result_number"]

  @result_number.setter
  def result_number(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["result_number"] = value

  @builtins.property
  def consumers(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def get_consumers_of_result(consumers, target, result_number, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GetConsumersOfResult(consumers=consumers, target=target, result_number=result_number, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetDefiningOp(_ods_ir.OpView):
  r"""
  The handle defined by this Transform op corresponds to the defining op of
  the targeted value.
  
  This transform produces a silenceable failure if the targeted value is a
  block argument.
  """

  OPERATION_NAME = "transform.get_defining_op"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, target, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def get_defining_op(result, target, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GetDefiningOp(result=result, target=target, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetOperandOp(_ods_ir.OpView):
  r"""
  The handle defined by this Transform op corresponds to the operands of the
  given `target` operation specified by the given set of positions. There are
  three possible modes:
  
   - Position list directly, i.e. `%target[0, 1, 2]`. This will return the
     operands at the specified positions.
   - Inverted position list, i.e. `%target[except(0, 1, 2)]`. This will return
     all operands except those at the given positions.
   - All, i.e. `%target[all]`. This will return all operands of the operation.
  
  This transform produces a silenceable failure if any of the operand indices
  exceeds the number of operands in the target. It reads the target handle and
  produces the result handle.
  """

  OPERATION_NAME = "transform.get_operand"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, target, raw_position_list, *, is_inverted=None, is_all=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["raw_position_list"] = (raw_position_list if (
    isinstance(raw_position_list, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(raw_position_list, context=_ods_context))
    if bool(is_inverted): attributes["is_inverted"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(is_all): attributes["is_all"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def raw_position_list(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["raw_position_list"]

  @raw_position_list.setter
  def raw_position_list(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["raw_position_list"] = value

  @builtins.property
  def is_inverted(self) -> bool:
    return "is_inverted" in self.operation.attributes

  @is_inverted.setter
  def is_inverted(self, value):
    if bool(value):
      self.operation.attributes["is_inverted"] = _ods_ir.UnitAttr.get()
    elif "is_inverted" in self.operation.attributes:
      del self.operation.attributes["is_inverted"]

  @is_inverted.deleter
  def is_inverted(self):
    del self.operation.attributes["is_inverted"]

  @builtins.property
  def is_all(self) -> bool:
    return "is_all" in self.operation.attributes

  @is_all.setter
  def is_all(self, value):
    if bool(value):
      self.operation.attributes["is_all"] = _ods_ir.UnitAttr.get()
    elif "is_all" in self.operation.attributes:
      del self.operation.attributes["is_all"]

  @is_all.deleter
  def is_all(self):
    del self.operation.attributes["is_all"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def get_operand(result, target, raw_position_list, *, is_inverted=None, is_all=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GetOperandOp(result=result, target=target, raw_position_list=raw_position_list, is_inverted=is_inverted, is_all=is_all, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetParentOp(_ods_ir.OpView):
  r"""
  The handle defined by this Transform op corresponds to the parents of the
  targeted payload ops (in the same order).
  
  Requirements that parent ops must fulfill can be optionally specified. In
  that case for each target op, the closest parent op that fulfills all
  requirements, is returned.
  - `isolated_from_above`: the parent op must be isolated from above
  - `allow_empty_results`: get_parent_op is allowed to return an empty list
    and still succeeds. In such a case, if `get_parent_op` fails for any
    operation in the list, the entire transform returns an empty handle.
  - `op_name`: the parent op must have the specified name
  - `nth_parent`: get the n-th parent of that satisfies the above requirements
  
  If `deduplicate` is set, the result handle does not contain any duplicate
  ops. For example, given the list
  "(childof(A), childof(B), childof(B), childof(A), childof(B))", the
  resulting list will be just "(A, B)". Note that no other semantic ordering
  is applied, e.g., "B" may itself be a parent of "A". This may have an impact
  on the further transformation applied to the handle produced here.
  
  If any of the given Payload IR ops has no such suitable parent, then:
    - if `allow_empty_results` is set, the result handle is empty
    - otherwise, the transformation produces a silenceable failure.
  """

  OPERATION_NAME = "transform.get_parent_op"

  _ODS_REGIONS = (0, True)

  def __init__(self, parent, target, *, isolated_from_above=None, allow_empty_results=None, op_name=None, deduplicate=None, nth_parent=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(isolated_from_above): attributes["isolated_from_above"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(allow_empty_results): attributes["allow_empty_results"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if op_name is not None: attributes["op_name"] = (op_name if (
        isinstance(op_name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(op_name, context=_ods_context))
    if bool(deduplicate): attributes["deduplicate"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if nth_parent is not None: attributes["nth_parent"] = (nth_parent if (
        isinstance(nth_parent, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(nth_parent, context=_ods_context))
    results = []
    results.append(parent)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def isolated_from_above(self) -> bool:
    return "isolated_from_above" in self.operation.attributes

  @isolated_from_above.setter
  def isolated_from_above(self, value):
    if bool(value):
      self.operation.attributes["isolated_from_above"] = _ods_ir.UnitAttr.get()
    elif "isolated_from_above" in self.operation.attributes:
      del self.operation.attributes["isolated_from_above"]

  @isolated_from_above.deleter
  def isolated_from_above(self):
    del self.operation.attributes["isolated_from_above"]

  @builtins.property
  def allow_empty_results(self) -> bool:
    return "allow_empty_results" in self.operation.attributes

  @allow_empty_results.setter
  def allow_empty_results(self, value):
    if bool(value):
      self.operation.attributes["allow_empty_results"] = _ods_ir.UnitAttr.get()
    elif "allow_empty_results" in self.operation.attributes:
      del self.operation.attributes["allow_empty_results"]

  @allow_empty_results.deleter
  def allow_empty_results(self):
    del self.operation.attributes["allow_empty_results"]

  @builtins.property
  def op_name(self) -> _Optional[_ods_ir.StringAttr]:
    if "op_name" not in self.operation.attributes:
      return None
    return self.operation.attributes["op_name"]

  @op_name.setter
  def op_name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["op_name"] = value
    elif "op_name" in self.operation.attributes:
      del self.operation.attributes["op_name"]

  @op_name.deleter
  def op_name(self):
    del self.operation.attributes["op_name"]

  @builtins.property
  def deduplicate(self) -> bool:
    return "deduplicate" in self.operation.attributes

  @deduplicate.setter
  def deduplicate(self, value):
    if bool(value):
      self.operation.attributes["deduplicate"] = _ods_ir.UnitAttr.get()
    elif "deduplicate" in self.operation.attributes:
      del self.operation.attributes["deduplicate"]

  @deduplicate.deleter
  def deduplicate(self):
    del self.operation.attributes["deduplicate"]

  @builtins.property
  def nth_parent(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["nth_parent"]

  @nth_parent.setter
  def nth_parent(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nth_parent"] = value

  @builtins.property
  def parent(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def get_parent_op(parent, target, *, isolated_from_above=None, allow_empty_results=None, op_name=None, deduplicate=None, nth_parent=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GetParentOp(parent=parent, target=target, isolated_from_above=isolated_from_above, allow_empty_results=allow_empty_results, op_name=op_name, deduplicate=deduplicate, nth_parent=nth_parent, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetProducerOfOperand(_ods_ir.OpView):
  r"""
  The handle defined by this Transform op corresponds to operation that
  produces the SSA value defined by the `target` and `operand_number`
  arguments. If the origin of the SSA value is not an operations (i.e. it is
  a block argument), the transform produces a silenceable failure.
  The return handle points to only the subset of successfully produced
  computational operations, which can be empty.
  """

  OPERATION_NAME = "transform.get_producer_of_operand"

  _ODS_REGIONS = (0, True)

  def __init__(self, producer, target, operand_number, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["operand_number"] = (operand_number if (
    isinstance(operand_number, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(operand_number, context=_ods_context))
    results = []
    results.append(producer)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand_number(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["operand_number"]

  @operand_number.setter
  def operand_number(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["operand_number"] = value

  @builtins.property
  def producer(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def get_producer_of_operand(producer, target, operand_number, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GetProducerOfOperand(producer=producer, target=target, operand_number=operand_number, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetResultOp(_ods_ir.OpView):
  r"""
  The handle defined by this Transform op correspond to the OpResults of the
  given `target` operation. Optionally `result_number` can be specified to
  select a specific result.
  
  This transform fails silently if the targeted operation does not have enough
  results. It reads the target handle and produces the result handle.
  
  The handle defined by this Transform op corresponds to the results of the
  given `target` operation specified by the given set of positions. There are
  three possible modes:
  
   - Position list directly, i.e. `%target[0, 1, 2]`. This will return the
     results at the specified positions.
   - Inverted position list, i.e. `%target[except(0, 1, 2)]`. This will return
     all results except those at the given positions.
   - All, i.e. `%target[all]`. This will return all results of the operation.
  
  This transform produces a silenceable failure if any of the result indices
  exceeds the number of results returned by the target. It reads the target
  handle and produces the result handle.
  """

  OPERATION_NAME = "transform.get_result"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, target, raw_position_list, *, is_inverted=None, is_all=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["raw_position_list"] = (raw_position_list if (
    isinstance(raw_position_list, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(raw_position_list, context=_ods_context))
    if bool(is_inverted): attributes["is_inverted"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(is_all): attributes["is_all"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def raw_position_list(self) -> _ods_ir.DenseI64ArrayAttr:
    return self.operation.attributes["raw_position_list"]

  @raw_position_list.setter
  def raw_position_list(self, value: _ods_ir.DenseI64ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["raw_position_list"] = value

  @builtins.property
  def is_inverted(self) -> bool:
    return "is_inverted" in self.operation.attributes

  @is_inverted.setter
  def is_inverted(self, value):
    if bool(value):
      self.operation.attributes["is_inverted"] = _ods_ir.UnitAttr.get()
    elif "is_inverted" in self.operation.attributes:
      del self.operation.attributes["is_inverted"]

  @is_inverted.deleter
  def is_inverted(self):
    del self.operation.attributes["is_inverted"]

  @builtins.property
  def is_all(self) -> bool:
    return "is_all" in self.operation.attributes

  @is_all.setter
  def is_all(self, value):
    if bool(value):
      self.operation.attributes["is_all"] = _ods_ir.UnitAttr.get()
    elif "is_all" in self.operation.attributes:
      del self.operation.attributes["is_all"]

  @is_all.deleter
  def is_all(self):
    del self.operation.attributes["is_all"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def get_result(result, target, raw_position_list, *, is_inverted=None, is_all=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GetResultOp(result=result, target=target, raw_position_list=raw_position_list, is_inverted=is_inverted, is_all=is_all, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetTypeOp(_ods_ir.OpView):
  r"""
  This operation creates a new Transform parameter containing the
  type(s) of the value(s) associated with the operand handle.
  
  This transform never fails.
  """

  OPERATION_NAME = "transform.get_type"

  _ODS_REGIONS = (0, True)

  def __init__(self, type_param, value, *, elemental=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(elemental): attributes["elemental"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(type_param)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def elemental(self) -> bool:
    return "elemental" in self.operation.attributes

  @elemental.setter
  def elemental(self, value):
    if bool(value):
      self.operation.attributes["elemental"] = _ods_ir.UnitAttr.get()
    elif "elemental" in self.operation.attributes:
      del self.operation.attributes["elemental"]

  @elemental.deleter
  def elemental(self):
    del self.operation.attributes["elemental"]

  @builtins.property
  def type_param(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def get_type(type_param, value, *, elemental=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GetTypeOp(type_param=type_param, value=value, elemental=elemental, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IncludeOp(_ods_ir.OpView):
  r"""
  The application of this transform operation is equivalent to applying the
  operations contained in the named transform sequence with operands being
  remapped to block arguments. The behavior of the operation when a
  transformation in the included named sequence produces a silenceable error
  is controlled by the `failure_propagation_mode` attribute. When set to
  `propagate`, the failure of any nested transformation in the sequence
  implies immediate failure of the entire sequence with a silenceable error,
  and no further transformation is attempted. When set to `suppress`,
  silenceable errors in nested operations are ignored and further
  transformations are applied. Beware that even silenceable errors may leave
  the payload IR in a state unsuitable for further transformations. It is the
  responsibility of the user to ensure the following transformations are
  robust enough when errors are suppressed. Definite errors are propagated
  immediately regardless of the mode. The objects associated with the results
  of this operation are the same as those associated with the operands of the
  `transform.yield` in the referenced named sequence.
  """

  OPERATION_NAME = "transform.include"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, target, failure_propagation_mode, operands_, *, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["target"] = (target if (
    isinstance(target, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(target, context=_ods_context))
    attributes["failure_propagation_mode"] = (failure_propagation_mode if (
    isinstance(failure_propagation_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FailurePropagationMode')) else
      _ods_ir.AttrBuilder.get('FailurePropagationMode')(failure_propagation_mode, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def target(self) -> _ods_ir.SymbolRefAttr:
    return self.operation.attributes["target"]

  @target.setter
  def target(self, value: _ods_ir.SymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target"] = value

  @builtins.property
  def failure_propagation_mode(self) -> _ods_ir.Attribute:
    return self.operation.attributes["failure_propagation_mode"]

  @failure_propagation_mode.setter
  def failure_propagation_mode(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["failure_propagation_mode"] = value

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def include(results_, target, failure_propagation_mode, operands_, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, IncludeOp]:
  op = IncludeOp(results_=results_, target=target, failure_propagation_mode=failure_propagation_mode, operands_=operands_, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class MatchOperationEmptyOp(_ods_ir.OpView):
  r"""
  Succeeds if the handle is not associated to any op.
  """

  OPERATION_NAME = "transform.match.operation_empty"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand_handle, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand_handle)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand_handle(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def match_operation_empty(operand_handle, *, loc=None, ip=None) -> MatchOperationEmptyOp:
  return MatchOperationEmptyOp(operand_handle=operand_handle, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MatchOperationNameOp(_ods_ir.OpView):
  r"""
  Succeeds if the operation associated with the operand handle has one of the
  given operation names. Produces a silenceable failure otherwise.
  
  If more than one payload operation is associated with the operand handle,
  produces a definite failure.
  """

  OPERATION_NAME = "transform.match.operation_name"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand_handle, op_names, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand_handle)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["op_names"] = (op_names if (
    isinstance(op_names, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(op_names, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand_handle(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def op_names(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["op_names"]

  @op_names.setter
  def op_names(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["op_names"] = value

def match_operation_name(operand_handle, op_names, *, loc=None, ip=None) -> MatchOperationNameOp:
  return MatchOperationNameOp(operand_handle=operand_handle, op_names=op_names, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MatchParamCmpIOp(_ods_ir.OpView):
  r"""
  Succeeds if all of the co-indexed values associated with the given
  parameters relate as specified by the predicate (greater than, less than,
  equal to, or their combinations). Comparison treats all values as signed.
  Produces a silenceable failure otherwise.
  """

  OPERATION_NAME = "transform.match.param.cmpi"

  _ODS_REGIONS = (0, True)

  def __init__(self, param, reference, predicate, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(param)
    operands.append(reference)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["predicate"] = (predicate if (
    isinstance(predicate, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MatchCmpIPredicateAttr')) else
      _ods_ir.AttrBuilder.get('MatchCmpIPredicateAttr')(predicate, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def param(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def reference(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def predicate(self) -> _ods_ir.Attribute:
    return self.operation.attributes["predicate"]

  @predicate.setter
  def predicate(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["predicate"] = value

def match_param_cmpi(param, reference, predicate, *, loc=None, ip=None) -> MatchParamCmpIOp:
  return MatchParamCmpIOp(param=param, reference=reference, predicate=predicate, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MergeHandlesOp(_ods_ir.OpView):
  r"""
  Creates a new Transform IR handle value that points to the same Payload IR
  operations/values/parameters as the operand handles. The Payload IR elements
  are listed in the same order as they are in the operand handles, grouped by
  operand handle, e.g., all Payload IR associated with the first handle comes
  first, then all Payload IR associated with the second handle and so on. If
  `deduplicate` is set, do not add the given Payload IR operation, value, or
  parameter more than once to the final list regardless of it coming from the
  same or different handles. Consumes the operands and produces a new handle.
  """

  OPERATION_NAME = "transform.merge_handles"

  _ODS_REGIONS = (0, True)

  def __init__(self, handles, *, deduplicate=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(handles))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(deduplicate): attributes["deduplicate"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def handles(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def deduplicate(self) -> bool:
    return "deduplicate" in self.operation.attributes

  @deduplicate.setter
  def deduplicate(self, value):
    if bool(value):
      self.operation.attributes["deduplicate"] = _ods_ir.UnitAttr.get()
    elif "deduplicate" in self.operation.attributes:
      del self.operation.attributes["deduplicate"]

  @deduplicate.deleter
  def deduplicate(self):
    del self.operation.attributes["deduplicate"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def merge_handles(handles, *, deduplicate=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MergeHandlesOp(handles=handles, deduplicate=deduplicate, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NamedSequenceOp(_ods_ir.OpView):
  r"""
  Defines a named (callable, function-like) sequence of other Transform
  dialect operations that can be included using `transform.include` as part of
  another Transform dialect construct. This sequence is not processed
  immediately but rather dispatched to when the inclusion is processed. The
  arguments and results can be used to communicate a subset of mapping into
  the named sequence. The sequence must consist of a single block and end with
  a `transform.yield` terminator. The operands of the terminator become the
  results of the `transform.include`.
  
  When dispatched to, the operations in the named sequence are executed one by
  one, similarly to the regular unnamed sequence. The failure propagation mode
  is specified on the `transform.include`. Different inclusions may use
  different failure propagation modes. This transform operation always
  succeeds by itself, but the inclusion may fail if any of the operations
  fail.
  
  Named sequences can only appear at the top-level of the Transform dialect
  nesting structure. That is, they cannot be nested in other Transform dialect
  operations. Furthermore, one of the ancestors must have the `SymbolTable`
  trait and have the `transform.with_named_sequence` attribute attached.
  
  Named sequences may include other named sequences via `transform.include`,
  but recursion is *not* allowed.
  """

  OPERATION_NAME = "transform.named_sequence"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_type, *, sym_visibility=None, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_500')) else
      _ods_ir.AttrBuilder.get('anonymous_500')(function_type, context=_ods_context))
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def named_sequence(sym_name, function_type, *, sym_visibility=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> NamedSequenceOp:
  return NamedSequenceOp(sym_name=sym_name, function_type=function_type, sym_visibility=sym_visibility, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class NumAssociationsOp(_ods_ir.OpView):
  r"""
  Given an argument, handle or parameter, returns a new parameter associated
  with a single 64-bit number that corresponds to the number of payload
  objects (operations or values for a handle, attributes for a parameter)
  associated with the argument.
  
  Always succeeds.
  """

  OPERATION_NAME = "transform.num_associations"

  _ODS_REGIONS = (0, True)

  def __init__(self, num, handle, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(handle)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(num)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def handle(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def num(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def num_associations(num, handle, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return NumAssociationsOp(num=num, handle=handle, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ParamConstantOp(_ods_ir.OpView):
  r"""
  Produces a new transform dialect parameter associated with the singleton
  list containing the given attribute. The operation itself always succeeds,
  but the general association check may fail if the parameter type does not
  accept the given kind of attribute as valid.
  """

  OPERATION_NAME = "transform.param.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, param, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AnyAttr')) else
      _ods_ir.AttrBuilder.get('AnyAttr')(value, context=_ods_context))
    results = []
    results.append(param)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def param(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def param_constant(param, value, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ParamConstantOp(param=param, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrintOp(_ods_ir.OpView):
  r"""
  Prints each payload op that is associated with the `target` operand to
  `stdout`. It also prints the `name` string attribute. If no target is
  specified, the top-level op is dumped.
  
  This op is useful for printf-style debugging.
  
  Supported printing flag attributes:
  * `assume_verified` -- skips verification when the unit attribute is
    specified. This improves performace but may lead to crashes and
    unexpected behavior when the printed payload op is invalid.
  * `use_local_scope` -- prints in local scope when the unit attribute is
    specified. This improves performance but may not be identical to
    printing within the full module.
  * `skip_regions` -- does not print regions of operations when the unit
    attribute is specified.
  """

  OPERATION_NAME = "transform.print"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, target=None, name=None, assume_verified=None, use_local_scope=None, skip_regions=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    if target is not None: operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    if bool(assume_verified): attributes["assume_verified"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(use_local_scope): attributes["use_local_scope"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(skip_regions): attributes["skip_regions"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 1 else self.operation.operands[0]

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def assume_verified(self) -> bool:
    return "assume_verified" in self.operation.attributes

  @assume_verified.setter
  def assume_verified(self, value):
    if bool(value):
      self.operation.attributes["assume_verified"] = _ods_ir.UnitAttr.get()
    elif "assume_verified" in self.operation.attributes:
      del self.operation.attributes["assume_verified"]

  @assume_verified.deleter
  def assume_verified(self):
    del self.operation.attributes["assume_verified"]

  @builtins.property
  def use_local_scope(self) -> bool:
    return "use_local_scope" in self.operation.attributes

  @use_local_scope.setter
  def use_local_scope(self, value):
    if bool(value):
      self.operation.attributes["use_local_scope"] = _ods_ir.UnitAttr.get()
    elif "use_local_scope" in self.operation.attributes:
      del self.operation.attributes["use_local_scope"]

  @use_local_scope.deleter
  def use_local_scope(self):
    del self.operation.attributes["use_local_scope"]

  @builtins.property
  def skip_regions(self) -> bool:
    return "skip_regions" in self.operation.attributes

  @skip_regions.setter
  def skip_regions(self, value):
    if bool(value):
      self.operation.attributes["skip_regions"] = _ods_ir.UnitAttr.get()
    elif "skip_regions" in self.operation.attributes:
      del self.operation.attributes["skip_regions"]

  @skip_regions.deleter
  def skip_regions(self):
    del self.operation.attributes["skip_regions"]

def print_(*, target=None, name=None, assume_verified=None, use_local_scope=None, skip_regions=None, loc=None, ip=None) -> PrintOp:
  return PrintOp(target=target, name=name, assume_verified=assume_verified, use_local_scope=use_local_scope, skip_regions=skip_regions, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ReplicateOp(_ods_ir.OpView):
  r"""
  Produces a new handle associated with a list of payload IR ops that is
  computed by repeating the list of payload IR ops associated with the
  operand handle as many times as the "pattern" handle has associated
  operations. For example, if pattern is associated with [op1, op2] and the
  operand handle is associated with [op3, op4, op5], the resulting handle
  will be associated with [op3, op4, op5, op3, op4, op5].
  
  This transformation is useful to "align" the sizes of payload IR lists
  before a transformation that expects, e.g., identically-sized lists. For
  example, a transformation may be parameterized by same notional per-target
  size computed at runtime and supplied as another handle, the replication
  allows this size to be computed only once and used for every target instead
  of replicating the computation itself.
  
  Note that it is undesirable to pass a handle with duplicate operations to
  an operation that consumes the handle. Handle consumption often indicates
  that the associated payload IR ops are destroyed, so having the same op
  listed more than once will lead to double-free. Single-operand
  MergeHandlesOp may be used to deduplicate the associated list of payload IR
  ops when necessary. Furthermore, a combination of ReplicateOp and
  MergeHandlesOp can be used to construct arbitrary lists with repetitions.
  """

  OPERATION_NAME = "transform.replicate"

  _ODS_REGIONS = (0, True)

  def __init__(self, replicated, pattern, handles, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pattern)
    operands.extend(_get_op_results_or_values(handles))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(replicated)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pattern(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def handles(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def replicated(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def replicate(replicated, pattern, handles, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ReplicateOp]:
  op = ReplicateOp(replicated=replicated, pattern=pattern, handles=handles, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class SelectOp(_ods_ir.OpView):
  r"""
  The handle defined by this Transform op corresponds to all operations among
  `target` that have the specified properties. Currently the following
  properties are supported:
  
  - `op_name`: The op must have the specified name.
  
  The result payload ops are in the same relative order as the targeted ops.
  This transform op reads the `target` handle and produces the `result`
  handle. It reads the payload, but does not modify it.
  """

  OPERATION_NAME = "transform.select"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, target, op_name, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["op_name"] = (op_name if (
    isinstance(op_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(op_name, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def op_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["op_name"]

  @op_name.setter
  def op_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["op_name"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def select(result, target, op_name, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SelectOp(result=result, target=target, op_name=op_name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SequenceOp(_ods_ir.OpView):
  r"""
  The transformations indicated by the sequence are applied in order of their
  appearance. Each value produced by a transformation within the sequence
  corresponds to a group of operations or values in the payload IR, or to a
  group of parameters, depending on the type of the value. The behavior of the
  operation when a nested transformation produces a silenceable error is
  controlled by the `failure_propagation_mode` attribute. When set to
  `propagate`, the failure of any nested transformation in the sequence
  implies immediate failure of the entire sequence with a silenceable error,
  and no further transformation is attempted. When set to `suppress`,
  silenceable errors in nested operations are ignored and further
  transformations are applied. Beware that even silenceable errors may leave
  the payload IR in a state unsuitable for further transformations. It is the
  responsibility of the caller to ensure the following transformations are
  robust enough when errors are suppressed. Definite errors reported by nested
  transformations abort the sequence regardless of the propagation mode. The
  set of modes may be extended in the future, e.g., to collect silenceable
  errors and report them after attempting all transformations in the sequence.
  
  The entry block of this operation has a single argument that maps to either
  the operand if provided or the top-level container operation of the payload
  IR, typically the root operation of the pass interpreting the transform
  dialect. Operand omission is only allowed for sequences not contained in
  another sequence.
  
  The type of the block argument must match the type of the operand. If the
  sequence is a top-level transform (without an operand), it can be used for
  matching operations if the specified type within the top-level container
  payload IR (including the container op itself). E.g.:
  
  ```mlir
  transform.sequence failures(propagate) {
  ^bb1(%arg1: !transform.any_op):
    // %arg1 is mapped to the top-level container of the payload IR, which is
    // typically a module
  }
  
  transform.sequence failures(propagate) {
  ^bb1(%arg1: !transform.op<"func.func>"):
    // %arg1 is mapped to all "func.func" ops within and including the
    // top-level container of the payload IR. Nested operations that have the
    // specified op type are not included.
  }
  ```
  
  The body of the sequence terminates with an implicit or explicit
  `transform.yield` op. The operands of the terminator are returned as the
  results of the sequence op.
  """

  OPERATION_NAME = "transform.sequence"

  _ODS_OPERAND_SEGMENTS = [0,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, failure_propagation_mode, extra_bindings, *, root=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(root)
    operands.append(_get_op_results_or_values(extra_bindings))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["failure_propagation_mode"] = (failure_propagation_mode if (
    isinstance(failure_propagation_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FailurePropagationMode')) else
      _ods_ir.AttrBuilder.get('FailurePropagationMode')(failure_propagation_mode, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def root(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def extra_bindings(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def failure_propagation_mode(self) -> _ods_ir.Attribute:
    return self.operation.attributes["failure_propagation_mode"]

  @failure_propagation_mode.setter
  def failure_propagation_mode(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["failure_propagation_mode"] = value

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def sequence(results_, failure_propagation_mode, extra_bindings, *, root=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, SequenceOp]:
  op = SequenceOp(results_=results_, failure_propagation_mode=failure_propagation_mode, extra_bindings=extra_bindings, root=root, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class SplitHandleOp(_ods_ir.OpView):
  r"""
  Splits `handle` into one or multiple handles, as specified by the number
  of results of this operation. `handle` should be mapped to as many payload
  ops, values or parameteres as there are results. Otherwise, this transform
  will fail producing a silenceable failure by default. Each result handle
  is mapped to exactly one payload unless specified otherwise by attributes
  described below. The order of the payloads is preserved,  i.e., the i-th
  payload is mapped to the i-th result handle.
  
  This operation is useful for ensuring a statically known number of
  payloads are tracked by the source `handle` and to extract them into
  individual handles that can be further manipulated in isolation.
  
  If there are more payloads than results, the remaining payloads are mapped to
  the result with index `overflow_result`. If no `overflow_result` is
  specified, the transform produces a silenceable failure.
  
  If there are fewer payload ops than results, the transform produces a
  silenceable failure if `fail_on_payload_too_small` is set to "true".
  Otherwise, it succeeds and the remaining result handles are not mapped to
  anything. It also succeeds if `handle` is empty and
  `pass_through_empty_handle` is set to "true", regardless of
  `fail_on_payload_too_small`.
  """

  OPERATION_NAME = "transform.split_handle"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, handle, *, pass_through_empty_handle=None, fail_on_payload_too_small=None, overflow_result=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(handle)
    _ods_context = _ods_get_default_loc_context(loc)
    if pass_through_empty_handle is not None: attributes["pass_through_empty_handle"] = (pass_through_empty_handle if (
        isinstance(pass_through_empty_handle, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(pass_through_empty_handle, context=_ods_context))
    if fail_on_payload_too_small is not None: attributes["fail_on_payload_too_small"] = (fail_on_payload_too_small if (
        isinstance(fail_on_payload_too_small, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(fail_on_payload_too_small, context=_ods_context))
    if overflow_result is not None: attributes["overflow_result"] = (overflow_result if (
        isinstance(overflow_result, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(overflow_result, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def handle(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def pass_through_empty_handle(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["pass_through_empty_handle"]

  @pass_through_empty_handle.setter
  def pass_through_empty_handle(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pass_through_empty_handle"] = value

  @builtins.property
  def fail_on_payload_too_small(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["fail_on_payload_too_small"]

  @fail_on_payload_too_small.setter
  def fail_on_payload_too_small(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fail_on_payload_too_small"] = value

  @builtins.property
  def overflow_result(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "overflow_result" not in self.operation.attributes:
      return None
    return self.operation.attributes["overflow_result"]

  @overflow_result.setter
  def overflow_result(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["overflow_result"] = value
    elif "overflow_result" in self.operation.attributes:
      del self.operation.attributes["overflow_result"]

  @overflow_result.deleter
  def overflow_result(self):
    del self.operation.attributes["overflow_result"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def split_handle(results_, handle, *, pass_through_empty_handle=None, fail_on_payload_too_small=None, overflow_result=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, SplitHandleOp]:
  op = SplitHandleOp(results_=results_, handle=handle, pass_through_empty_handle=pass_through_empty_handle, fail_on_payload_too_small=fail_on_payload_too_small, overflow_result=overflow_result, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class VerifyOp(_ods_ir.OpView):
  r"""
  This transform verifies the targeted ops. If at least one op fails to
  verify, the transform produces a definite failure.
  
  Note: This op was designed for debugging purposes and should be used like an
  assertion. It is intentional that this op produces a definite failure and
  not a silenceable one. Correctness of the program should not depend on this
  op.
  
  This transform reads the target handle.
  """

  OPERATION_NAME = "transform.verify"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def verify_(target, *, loc=None, ip=None) -> VerifyOp:
  return VerifyOp(target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  r"""
  This terminator operation yields operation handles from regions of the
  transform IR ops back to the containing op. It is not itself associated with
  any transformation on the payload IR and is used for flow purposes only.
  """

  OPERATION_NAME = "transform.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def yield_(operands_, *, loc=None, ip=None) -> YieldOp:
  return YieldOp(operands_=operands_, loc=loc, ip=ip)
