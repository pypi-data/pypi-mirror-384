import pandas as pd
import os
from typing import Dict, Optional

from src.metrics.feature_data import FeatureReport
from src.metrics.metrics import full_report

# Optional visualization libraries
try:
    import matplotlib.pyplot as plt
    import seaborn as sns
    _VISUALIZATION_ENABLED = True
except ImportError:
    _VISUALIZATION_ENABLED = False


class PartitionProfiler:
    """
    Analyzes and visualizes the characteristics of data partitions
    generated by any partitioning algorithm.
    """

    def __init__(self, data: pd.DataFrame, partition_labels: pd.Series, plot_threshold: int = 50, output_path: Optional[str] = None):
        """
        Initializes the profiler with the original data and partition assignments.

        Args:
            data: The original DataFrame, indexed in line with partition_labels.
            partition_labels: A Series with the same index as `data`.
            plot_threshold: The number of unique partitions above which to switch
                              from detailed plots to summary histograms.
            output_path: Optional. If provided, saves plots and data to this directory.
        """
        if not isinstance(data, pd.DataFrame):
            raise TypeError("`data` must be a pandas DataFrame.")
        if not isinstance(partition_labels, pd.Series):
            raise TypeError("`partition_labels` must be a pandas Series.")
        if not data.index.equals(partition_labels.index):
            raise ValueError("Index of `data` and `partition_labels` must match.")

        self.data = data
        self.partitions = partition_labels
        self.n_partitions = self.partitions.nunique()
        self.plot_threshold = plot_threshold
        self.output_path = output_path
        self.report: Dict[str, FeatureReport] = {}

    def generate_summary_table(self) -> pd.DataFrame:
        """
        Creates a summary table of HHI and other key metrics for each feature.
        """
        if not self.report:
            print("Report not generated. Please run `run_profiling()` first.")
            return pd.DataFrame()

        summary_data = []
        for feature_name, report in self.report.items():
            summary_data.append({
                "feature": feature_name,
                "variance_hhi": report.variance_report.hhi,
                "span_hhi": report.span_report.hhi,
            })
        
        return pd.DataFrame(summary_data).sort_values(by="variance_hhi", ascending=False).reset_index(drop=True)

    def _plot_partition_sizes_detailed(self, save_path: Optional[str] = None):
        if not _VISUALIZATION_ENABLED:
            return
        plt.figure(figsize=(12, 6))
        sns.countplot(x=self.partitions)
        plt.title("Distribution of Samples Across Partitions")
        plt.xlabel("Partition ID")
        plt.ylabel("Number of Samples")
        if save_path:
            plt.savefig(save_path)
            plt.close()
        else:
            plt.show()

    def _plot_partition_sizes_summary(self, save_path: Optional[str] = None):
        if not _VISUALIZATION_ENABLED:
            return
        partition_sizes = self.partitions.value_counts()
        plt.figure(figsize=(12, 6))
        sns.histplot(partition_sizes, bins=min(self.n_partitions, 50))
        plt.title("Histogram of Partition Sizes")
        plt.xlabel("Number of Samples in Partition")
        plt.ylabel("Frequency")
        if save_path:
            plt.savefig(save_path)
            plt.close()
        else:
            plt.show()

    def _plot_feature_distribution_detailed(self, feature_name: str, save_path: Optional[str] = None):
        if not _VISUALIZATION_ENABLED:
            return
        if feature_name not in self.data.columns:
            raise ValueError(f"Feature '{feature_name}' not found.")
        plt.figure(figsize=(15, 7))
        plot_df = self.data.copy()
        plot_df['partition'] = self.partitions
        sns.boxplot(x='partition', y=feature_name, data=plot_df)
        plt.title(f"Distribution of '{feature_name}' Across Partitions")
        plt.xlabel("Partition ID")
        plt.ylabel(feature_name)
        if save_path:
            plt.savefig(save_path)
            plt.close()
        else:
            plt.show()

    def _plot_feature_distribution_binned_violin(self, feature_name: str, n_bins: int = 20, save_path: Optional[str] = None):
        """
        Generates a binned violin plot to show the trend of a feature's distribution
        across a large number of sorted partitions.
        """
        if not _VISUALIZATION_ENABLED:
            return

        if feature_name not in self.data.columns:
            raise ValueError(f"Feature '{feature_name}' not found.")

        # 1. Calculate mean of the feature for each partition
        plot_df = self.data.copy()
        plot_df['partition'] = self.partitions
        partition_means = plot_df.groupby('partition')[feature_name].mean()

        # 2. Sort partitions by the calculated mean
        sorted_partitions = partition_means.sort_values().index

        # 3. Create a mapping from partition ID to its rank
        partition_rank_map = {part_id: rank for rank, part_id in enumerate(sorted_partitions)}
        plot_df['partition_rank'] = plot_df['partition'].map(partition_rank_map)

        # 4. Bin the partitions by rank
        plot_df['bin'] = pd.cut(plot_df['partition_rank'], bins=n_bins, labels=False)

        # 5. Create the violin plot
        plt.figure(figsize=(18, 8))
        sns.violinplot(x='bin', y=feature_name, data=plot_df, cut=0)
        plt.title(f"Binned Distribution Trend for '{feature_name}'")
        plt.xlabel(f"Partition Bins (Sorted by mean '{feature_name}')")
        plt.ylabel(feature_name)
        
        if save_path:
            plt.savefig(save_path)
            plt.close()
        else:
            plt.show()

    def run_profiling(self):
        """
        Runs the full profiling analysis, saving artifacts if output_path is set.
        """
        print(f"Found {self.n_partitions} unique partitions.")
        if self.output_path:
            os.makedirs(self.output_path, exist_ok=True)
            print(f"Saving artifacts to: {os.path.abspath(self.output_path)}")

        print("Generating full report...")
        self.report = full_report(self.data, self.partitions.to_numpy())
        
        summary_df = self.generate_summary_table()
        print("\n--- Feature Analysis Summary (Sorted by Variance HHI) ---")
        print(summary_df.to_string())
        if self.output_path:
            summary_df.to_csv(os.path.join(self.output_path, "feature_summary.csv"), index=False)

        if not _VISUALIZATION_ENABLED:
            print("\nPlotting libraries not installed. Skipping visualization.")
            print("To enable plotting, please install with: pip install .[viz]")
            return

        print("\n--- Generating Visualizations ---")
        
        size_plot_path = None
        if self.output_path:
            size_plot_path = os.path.join(self.output_path, "partition_size_distribution.png")

        if self.n_partitions > self.plot_threshold:
            self._plot_partition_sizes_summary(save_path=size_plot_path)
        else:
            self._plot_partition_sizes_detailed(save_path=size_plot_path)

        top_features = summary_df["feature"].head(3)
        for feature in top_features:
            feature_path = None
            if self.output_path:
                feature_path = os.path.join(self.output_path, feature)
                os.makedirs(feature_path, exist_ok=True)

            if self.n_partitions > self.plot_threshold:
                plot_path = os.path.join(feature_path, "feature_distribution_trend.png") if feature_path else None
                self._plot_feature_distribution_binned_violin(feature, save_path=plot_path)
            else:
                plot_path = os.path.join(feature_path, "feature_distribution_detailed.png") if feature_path else None
                self._plot_feature_distribution_detailed(feature, save_path=plot_path)

            if feature_path:
                var_report = self.report[feature].variance_report
                var_prefix = "prop" if var_report.is_proportional else "raw"
                pd.DataFrame(var_report.distribution).to_csv(os.path.join(feature_path, f"{var_prefix}_variance_distribution.csv"))

                span_report = self.report[feature].span_report
                span_prefix = "prop" if span_report.is_proportional else "raw"
                pd.DataFrame(span_report.distribution).to_csv(os.path.join(feature_path, f"{span_prefix}_span_distribution.csv"))