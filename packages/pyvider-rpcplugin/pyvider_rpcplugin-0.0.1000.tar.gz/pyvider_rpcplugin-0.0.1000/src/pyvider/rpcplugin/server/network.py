#
# pyvider/rpcplugin/server/network.py
#
"""
Network setup, handshake, and credential handling for RPC plugin servers.

This module contains the ServerNetworkMixin with methods for handling
transport setup, TLS/mTLS credentials, handshake negotiation, and
server configuration.
"""

import asyncio
from pathlib import Path
import sys
from typing import Any, cast

import grpc
from grpc.aio import server as GRPCServer
from grpc_health.v1 import health_pb2_grpc
from provide.foundation.crypto import Certificate
from provide.foundation.logger import get_logger

from pyvider.rpcplugin.config import rpcplugin_config
from pyvider.rpcplugin.exception import (
    ProtocolError,
    SecurityError,
    TransportError,
)
from pyvider.rpcplugin.handshake import (
    build_handshake_response,
    negotiate_protocol_version,
    negotiate_transport,
    validate_magic_cookie,
)
from pyvider.rpcplugin.protocol import register_protocol_service
from pyvider.rpcplugin.transport import TCPSocketTransport, UnixSocketTransport
from pyvider.rpcplugin.transport.types import (
    RPCPluginTransport as RPCPluginTransportType,
)

# Module logger
logger = get_logger(__name__)


# Network and transport-related methods that will be mixed into RPCPluginServer
class ServerNetworkMixin:
    """Mixin class containing network and transport methods for RPCPluginServer."""

    # Forward declarations for attributes that will be on the main server class
    config: dict[str, Any] | None
    protocol: Any  # BaseRpcAbcProtocol
    handler: Any  # HandlerT
    transport: Any | None  # TransportT
    _transport: Any | None  # TransportT
    _server: Any | None  # ServerT
    _handshake_config: Any  # HandshakeConfig
    _protocol_version: int
    _transport_name: str
    _server_cert_obj: Certificate | None
    _port: int | None
    _serving_future: asyncio.Future[None]
    _serving_event: asyncio.Event
    _shutdown_event: asyncio.Event
    _rate_limiter: Any | None  # TokenBucketRateLimiter
    _health_servicer: Any | None  # HealthServicer

    # Forward declarations for methods from main class
    def _get_instance_override(self, key: str, default_value: Any) -> Any: ...

    def _read_client_cert(self) -> str | None:
        """Read client certificate configuration if available."""
        return self._get_instance_override("PLUGIN_CLIENT_CERT", rpcplugin_config.plugin_client_cert)

    def _should_skip_credentials(
        self,
        auto_mtls: bool,
        server_cert_conf: str | None,
        server_key_conf: str | None,
    ) -> bool:
        if auto_mtls or (server_cert_conf and server_key_conf):
            return False
        logger.info("auto_mtls is false and no server cert/key provided. Operating insecurely.")
        return True

    def _load_server_certificate(
        self,
        server_cert_conf: str | None,
        server_key_conf: str | None,
        auto_mtls: bool,
    ) -> Certificate | None:
        if server_cert_conf and server_key_conf:
            try:
                return Certificate.from_pem(cert_pem=server_cert_conf, key_pem=server_key_conf)
            except Exception as exc:
                raise SecurityError(f"Failed to load server certificate/key: {exc}") from exc

        if not auto_mtls:
            return None

        try:
            cert_obj = Certificate.create_self_signed_server_cert(
                common_name="pyvider.rpcplugin.autogen.server",
                organization_name="Pyvider AutoGenerated",
                validity_days=365,
                alt_names=["localhost"],
            )
        except Exception as exc:
            raise SecurityError(f"Failed to auto-generate server certificate: {exc}") from exc

        common_name_val = getattr(cert_obj, "common_name", "Unknown")
        logger.info(f"📜🔑🏭 Created new self-signed SERVER certificate for CN={common_name_val}")
        return cert_obj

    def _validate_server_certificate_obj(self, cert_obj: Certificate | None) -> Certificate:
        if not cert_obj or not getattr(cert_obj, "cert_pem", None) or not getattr(cert_obj, "key_pem", None):
            raise SecurityError("Server certificate object is invalid or missing PEM data after processing.")
        return cert_obj

    def _load_client_root_certificates(
        self,
        auto_mtls: bool,
        client_root_certs_conf: str | None,
    ) -> tuple[bytes | None, bool]:
        if not auto_mtls:
            return None, False

        if not client_root_certs_conf:
            logger.warning(
                "auto_mtls is True, but PLUGIN_CLIENT_ROOT_CERTS not provided. "
                "Client certs will not be required/verified."
            )
            return None, False

        try:
            if client_root_certs_conf.startswith("file://"):
                with Path(client_root_certs_conf.removeprefix("file://")).open("rb") as file_handle:
                    return file_handle.read(), True
            return client_root_certs_conf.encode("utf-8"), True
        except Exception as exc:
            raise SecurityError(f"Failed to load client root CAs: {exc}") from exc

    def _generate_server_credentials(self) -> grpc.ServerCredentials | None:
        """
        Generate gRPC server credentials based on configuration.

        This method handles both manual certificate configuration and
        automatic mTLS certificate generation. It supports client certificate
        validation when configured.

        Returns:
            gRPC server credentials for secure connections, or None for insecure mode

        Raises:
            SecurityError: If certificate configuration or generation fails
        """
        server_cert_conf = self._get_instance_override(
            "PLUGIN_SERVER_CERT", rpcplugin_config.plugin_server_cert
        )
        server_key_conf = self._get_instance_override("PLUGIN_SERVER_KEY", rpcplugin_config.plugin_server_key)
        auto_mtls = self._get_instance_override("PLUGIN_AUTO_MTLS", rpcplugin_config.plugin_auto_mtls)
        client_root_certs_conf = self._get_instance_override(
            "PLUGIN_CLIENT_ROOT_CERTS", rpcplugin_config.plugin_client_root_certs
        )

        if self._should_skip_credentials(auto_mtls, server_cert_conf, server_key_conf):
            return None

        self._server_cert_obj = self._load_server_certificate(server_cert_conf, server_key_conf, auto_mtls)
        valid_cert = self._validate_server_certificate_obj(self._server_cert_obj)
        key_bytes = valid_cert.key_pem.encode("utf-8")
        cert_bytes = valid_cert.cert_pem.encode("utf-8")
        client_ca_pem_bytes, require_auth = self._load_client_root_certificates(
            auto_mtls,
            client_root_certs_conf,
        )

        return grpc.ssl_server_credentials(
            private_key_certificate_chain_pairs=[(key_bytes, cert_bytes)],
            root_certificates=client_ca_pem_bytes,
            require_client_auth=require_auth,
        )

    async def _initialize_server_with_services(self) -> grpc.aio.Server:
        from .core import RateLimitingInterceptor

        interceptors_list: list[grpc.aio.ServerInterceptor] = (
            [RateLimitingInterceptor(self._rate_limiter)] if self._rate_limiter else []
        )
        self._server = cast(Any, GRPCServer(interceptors=interceptors_list))

        proto_instance = self.protocol
        await proto_instance.add_to_server(handler=self.handler, server=self._server)

        if self._server is None:
            raise TransportError("Server object not initialized before registration.")

        concrete_server = cast(grpc.aio.Server, self._server)
        register_protocol_service(server=concrete_server, shutdown_event=self._shutdown_event)
        if self._health_servicer:
            health_pb2_grpc.add_HealthServicer_to_server(self._health_servicer, concrete_server)
        return concrete_server

    def _ensure_transport_ready(self) -> RPCPluginTransportType:
        if self._transport is None:
            raise TransportError("Transport not initialized before server setup.")
        return cast(RPCPluginTransportType, self._transport)

    async def _prepare_transport_binding(
        self,
        transport: RPCPluginTransportType,
    ) -> tuple[str, str]:
        await transport.listen()
        endpoint = transport.endpoint
        if not endpoint:
            raise TransportError("Transport endpoint not available after listen.")
        bind_address = f"unix:{endpoint}" if isinstance(transport, UnixSocketTransport) else endpoint
        return endpoint, bind_address

    def _determine_requested_tcp_port(self) -> int:
        if (
            self.transport is not None
            and isinstance(self.transport, TCPSocketTransport)
            and getattr(self.transport, "port", 0)
        ):
            return self.transport.port

        port_conf = self._get_instance_override("PLUGIN_SERVER_PORT", rpcplugin_config.plugin_server_port)
        if port_conf is None:
            return 0

        try:
            return int(port_conf)
        except (ValueError, TypeError):
            logger.warning(
                "Could not parse port from PLUGIN_SERVER_PORT='%s'. Assuming ephemeral.",
                port_conf,
            )
            return 0

    def _apply_tcp_port_configuration(self, transport: TCPSocketTransport, port_num: int) -> None:
        requested_port = self._determine_requested_tcp_port()
        if port_num == 0 and requested_port != 0:
            bind_address = transport.endpoint or f"{transport.host}:{requested_port}"
            raise TransportError(
                "Failed to bind to specifically requested TCP port in "
                f"{bind_address} (requested port was {requested_port}). Port returned by gRPC was 0."
            )

        self._port = port_num
        transport.port = port_num
        current_host = transport.host if transport.host else "0.0.0.0"
        transport.endpoint = f"{current_host}:{port_num}"

    def _configure_port_binding(
        self,
        server: grpc.aio.Server,
        bind_address: str,
        creds: grpc.ServerCredentials | None,
        transport: RPCPluginTransportType,
    ) -> None:
        if creds:
            port_num = server.add_secure_port(bind_address, creds)
            logger.info(f"🔒 Server starting in secure mode on {bind_address} (port_num: {port_num})")
        else:
            port_num = server.add_insecure_port(bind_address)
            logger.info(f"🔌 Server starting in insecure mode on {bind_address} (port_num: {port_num})")

        if isinstance(transport, TCPSocketTransport):
            self._apply_tcp_port_configuration(transport, port_num)

    async def _setup_server(self) -> None:
        """
        Set up the gRPC server with transport, credentials, and service registration.

        This method handles the complete server setup process including:
        - Creating the gRPC server with interceptors
        - Registering protocol services
        - Setting up TLS/mTLS credentials
        - Configuring transport binding
        - Starting the server

        Raises:
            TransportError: If transport or server setup fails
            SecurityError: If credential setup fails
            ProtocolError: If service registration fails
        """
        try:
            concrete_server = await self._initialize_server_with_services()
            creds = self._generate_server_credentials()
            active_transport_checked = self._ensure_transport_ready()
            _, bind_address = await self._prepare_transport_binding(active_transport_checked)
            self._configure_port_binding(concrete_server, bind_address, creds, active_transport_checked)
            await concrete_server.start()
        except (TransportError, ProtocolError, SecurityError):
            raise
        except Exception as e:
            raise TransportError(f"gRPC server failed to start: {e}") from e

    async def _negotiate_handshake(self) -> None:
        """
        Perform handshake protocol negotiation with the client.

        This method validates the magic cookie, negotiates protocol version,
        and sets up transport if not already configured.

        Raises:
            ProtocolError: If handshake negotiation fails
            TransportError: If transport setup fails
        """
        validate_magic_cookie(
            magic_cookie_key=self._handshake_config.magic_cookie_key,
            magic_cookie_value=self._handshake_config.magic_cookie_value,
        )
        self._protocol_version = negotiate_protocol_version(self._handshake_config.protocol_versions)
        if not self._transport:
            negotiated_transport_typed: RPCPluginTransportType
            (
                self._transport_name,
                negotiated_transport_typed,
            ) = await negotiate_transport(self._handshake_config.supported_transports)
            self._transport = cast(Any, negotiated_transport_typed)  # TransportT
        else:
            self._transport_name = "tcp" if isinstance(self._transport, TCPSocketTransport) else "unix"

    async def _build_and_send_handshake_response(self) -> None:
        """
        Build and send handshake response to stdout.

        This method creates the handshake response with transport and certificate
        information and sends it to stdout for the client to read.

        Raises:
            TransportError: If transport is not properly initialized
        """
        if self._transport is None:
            err_msg = "Internal error: Transport is None before building handshake response."
            logger.error(f"💣💥 {err_msg}")
            raise TransportError(err_msg)

        concrete_transport = cast(RPCPluginTransportType, self._transport)
        response = await build_handshake_response(
            plugin_version=self._protocol_version,
            transport_name=self._transport_name,
            transport=concrete_transport,
            server_cert=self._server_cert_obj,
            port=self._port,
        )
        sys.stdout.buffer.write(f"{response}\n".encode())
        sys.stdout.buffer.flush()
