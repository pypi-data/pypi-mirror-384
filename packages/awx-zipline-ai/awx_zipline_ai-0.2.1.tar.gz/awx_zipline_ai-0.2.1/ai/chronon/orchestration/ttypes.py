#
# Autogenerated by Thrift Compiler (0.22.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID

import sys
import ai.chronon.api.common.ttypes
import ai.chronon.api.ttypes

from thrift.transport import TTransport
all_structs = []


class TabularDataType(object):
    EVENT = 1
    ENTITY = 2
    CUMULATIVE_EVENTS = 3

    _VALUES_TO_NAMES = {
        1: "EVENT",
        2: "ENTITY",
        3: "CUMULATIVE_EVENTS",
    }

    _NAMES_TO_VALUES = {
        "EVENT": 1,
        "ENTITY": 2,
        "CUMULATIVE_EVENTS": 3,
    }


class ConfType(object):
    GROUP_BY = 0
    JOIN = 1
    STAGING_QUERY = 2
    MODEL = 3

    _VALUES_TO_NAMES = {
        0: "GROUP_BY",
        1: "JOIN",
        2: "STAGING_QUERY",
        3: "MODEL",
    }

    _NAMES_TO_VALUES = {
        "GROUP_BY": 0,
        "JOIN": 1,
        "STAGING_QUERY": 2,
        "MODEL": 3,
    }


class GroupByNodeType(object):
    PARTIAL_IR = 1
    SAWTOOTH_IR = 2
    SNAPSHOT = 3
    PREPARE_UPLOAD = 10
    UPLOAD = 11
    STREAMING = 12

    _VALUES_TO_NAMES = {
        1: "PARTIAL_IR",
        2: "SAWTOOTH_IR",
        3: "SNAPSHOT",
        10: "PREPARE_UPLOAD",
        11: "UPLOAD",
        12: "STREAMING",
    }

    _NAMES_TO_VALUES = {
        "PARTIAL_IR": 1,
        "SAWTOOTH_IR": 2,
        "SNAPSHOT": 3,
        "PREPARE_UPLOAD": 10,
        "UPLOAD": 11,
        "STREAMING": 12,
    }


class JoinNodeType(object):
    LEFT_SOURCE = 1
    BOOTSTRAP = 2
    RIGHT_PART = 3
    MERGE = 4
    DERIVE = 5
    LABEL_PART = 6
    LABEL_JOIN = 7
    METADATA_UPLOAD = 20
    PREPARE_LOGS = 21
    SUMMARIZE = 40
    DRIFT = 41
    DRIFT_UPLOAD = 42

    _VALUES_TO_NAMES = {
        1: "LEFT_SOURCE",
        2: "BOOTSTRAP",
        3: "RIGHT_PART",
        4: "MERGE",
        5: "DERIVE",
        6: "LABEL_PART",
        7: "LABEL_JOIN",
        20: "METADATA_UPLOAD",
        21: "PREPARE_LOGS",
        40: "SUMMARIZE",
        41: "DRIFT",
        42: "DRIFT_UPLOAD",
    }

    _NAMES_TO_VALUES = {
        "LEFT_SOURCE": 1,
        "BOOTSTRAP": 2,
        "RIGHT_PART": 3,
        "MERGE": 4,
        "DERIVE": 5,
        "LABEL_PART": 6,
        "LABEL_JOIN": 7,
        "METADATA_UPLOAD": 20,
        "PREPARE_LOGS": 21,
        "SUMMARIZE": 40,
        "DRIFT": 41,
        "DRIFT_UPLOAD": 42,
    }


class StagingQueryNodeType(object):
    BACKFILL = 1

    _VALUES_TO_NAMES = {
        1: "BACKFILL",
    }

    _NAMES_TO_VALUES = {
        "BACKFILL": 1,
    }


class ModelNodeType(object):
    TRAINING = 300
    BULK_INFERENCE = 301

    _VALUES_TO_NAMES = {
        300: "TRAINING",
        301: "BULK_INFERENCE",
    }

    _NAMES_TO_VALUES = {
        "TRAINING": 300,
        "BULK_INFERENCE": 301,
    }


class TableNodeType(object):
    MATERIALIZED = 1
    VIEW = 2

    _VALUES_TO_NAMES = {
        1: "MATERIALIZED",
        2: "VIEW",
    }

    _NAMES_TO_VALUES = {
        "MATERIALIZED": 1,
        "VIEW": 2,
    }


class NodeRunStatus(object):
    UNKNOWN = 0
    WAITING = 1
    RUNNING = 2
    SUCCEEDED = 3
    FAILED = 4

    _VALUES_TO_NAMES = {
        0: "UNKNOWN",
        1: "WAITING",
        2: "RUNNING",
        3: "SUCCEEDED",
        4: "FAILED",
    }

    _NAMES_TO_VALUES = {
        "UNKNOWN": 0,
        "WAITING": 1,
        "RUNNING": 2,
        "SUCCEEDED": 3,
        "FAILED": 4,
    }


class WorkflowStatus(object):
    UNKNOWN = 0
    SUBMITTED = 1
    RUNNING = 2
    SUCCEEDED = 3
    FAILED = 4

    _VALUES_TO_NAMES = {
        0: "UNKNOWN",
        1: "SUBMITTED",
        2: "RUNNING",
        3: "SUCCEEDED",
        4: "FAILED",
    }

    _NAMES_TO_VALUES = {
        "UNKNOWN": 0,
        "SUBMITTED": 1,
        "RUNNING": 2,
        "SUCCEEDED": 3,
        "FAILED": 4,
    }


class CheckResult(object):
    SUCCESS = 0
    FAILURE = 1
    SKIPPED = 2

    _VALUES_TO_NAMES = {
        0: "SUCCESS",
        1: "FAILURE",
        2: "SKIPPED",
    }

    _NAMES_TO_VALUES = {
        "SUCCESS": 0,
        "FAILURE": 1,
        "SKIPPED": 2,
    }


class TabularData(object):
    """
    Represents a group of structured data assets that the same data flows through
    just a normalized version of Events + Entity sources.


    Attributes:
     - table
     - topic
     - mutationTable
     - type

    """
    thrift_spec = None


    def __init__(self, table = None, topic = None, mutationTable = None, type = None,):
        self.table = table
        self.topic = topic
        self.mutationTable = mutationTable
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.topic = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.mutationTable = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TabularData')
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 1)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.topic is not None:
            oprot.writeFieldBegin('topic', TType.STRING, 2)
            oprot.writeString(self.topic.encode('utf-8') if sys.version_info[0] == 2 else self.topic)
            oprot.writeFieldEnd()
        if self.mutationTable is not None:
            oprot.writeFieldBegin('mutationTable', TType.STRING, 3)
            oprot.writeString(self.mutationTable.encode('utf-8') if sys.version_info[0] == 2 else self.mutationTable)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 4)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LogicalNode(object):
    """
    Attributes:
     - stagingQuery
     - join
     - groupBy
     - model
     - tabularData

    """
    thrift_spec = None


    def __init__(self, stagingQuery = None, join = None, groupBy = None, model = None, tabularData = None,):
        self.stagingQuery = stagingQuery
        self.join = join
        self.groupBy = groupBy
        self.model = model
        self.tabularData = tabularData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stagingQuery = ai.chronon.api.ttypes.StagingQuery()
                    self.stagingQuery.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.join = ai.chronon.api.ttypes.Join()
                    self.join.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.groupBy = ai.chronon.api.ttypes.GroupBy()
                    self.groupBy.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.model = ai.chronon.api.ttypes.Model()
                    self.model.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.tabularData = TabularData()
                    self.tabularData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LogicalNode')
        if self.stagingQuery is not None:
            oprot.writeFieldBegin('stagingQuery', TType.STRUCT, 1)
            self.stagingQuery.write(oprot)
            oprot.writeFieldEnd()
        if self.join is not None:
            oprot.writeFieldBegin('join', TType.STRUCT, 2)
            self.join.write(oprot)
            oprot.writeFieldEnd()
        if self.groupBy is not None:
            oprot.writeFieldBegin('groupBy', TType.STRUCT, 3)
            self.groupBy.write(oprot)
            oprot.writeFieldEnd()
        if self.model is not None:
            oprot.writeFieldBegin('model', TType.STRUCT, 4)
            self.model.write(oprot)
            oprot.writeFieldEnd()
        if self.tabularData is not None:
            oprot.writeFieldBegin('tabularData', TType.STRUCT, 5)
            self.tabularData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeKey(object):
    """
    Attributes:
     - name
     - logicalType
     - physicalType

    """
    thrift_spec = None


    def __init__(self, name = None, logicalType = None, physicalType = None,):
        self.name = name
        self.logicalType = logicalType
        self.physicalType = physicalType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.logicalType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.physicalType = PhysicalNodeType()
                    self.physicalType.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NodeKey')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.logicalType is not None:
            oprot.writeFieldBegin('logicalType', TType.I32, 2)
            oprot.writeI32(self.logicalType)
            oprot.writeFieldEnd()
        if self.physicalType is not None:
            oprot.writeFieldBegin('physicalType', TType.STRUCT, 3)
            self.physicalType.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeInfo(object):
    """
    Attributes:
     - semanticHash: represents the computation that a node does
    direct changes to conf that change output will affect semantic hash
    changing spark params etc shouldn't affect this

     - confHash: simple hash of the entire conf (that is TSimpleJsonProtocol serialized),
    computed by cli and used to check if new conf_json need to be pushed from user's machine

     - branch: when new/updated conf's are pushed the branch is also set from the cli
    upon merging the branch will be unset

     - author: will be set to the author of the last semantic change to node
    (non-semantic changes like code-mods or spark params don't affect this)

     - conf: contents of the conf itself


    """
    thrift_spec = None


    def __init__(self, semanticHash = None, confHash = None, branch = None, author = None, conf = None,):
        self.semanticHash = semanticHash
        self.confHash = confHash
        self.branch = branch
        self.author = author
        self.conf = conf

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 11:
                if ftype == TType.STRING:
                    self.semanticHash = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRING:
                    self.confHash = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.STRING:
                    self.branch = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.STRING:
                    self.author = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 30:
                if ftype == TType.STRUCT:
                    self.conf = LogicalNode()
                    self.conf.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NodeInfo')
        if self.semanticHash is not None:
            oprot.writeFieldBegin('semanticHash', TType.STRING, 11)
            oprot.writeString(self.semanticHash.encode('utf-8') if sys.version_info[0] == 2 else self.semanticHash)
            oprot.writeFieldEnd()
        if self.confHash is not None:
            oprot.writeFieldBegin('confHash', TType.STRING, 12)
            oprot.writeString(self.confHash.encode('utf-8') if sys.version_info[0] == 2 else self.confHash)
            oprot.writeFieldEnd()
        if self.branch is not None:
            oprot.writeFieldBegin('branch', TType.STRING, 20)
            oprot.writeString(self.branch.encode('utf-8') if sys.version_info[0] == 2 else self.branch)
            oprot.writeFieldEnd()
        if self.author is not None:
            oprot.writeFieldBegin('author', TType.STRING, 21)
            oprot.writeString(self.author.encode('utf-8') if sys.version_info[0] == 2 else self.author)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.STRUCT, 30)
            self.conf.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeConnections(object):
    """
    Attributes:
     - parents
     - children

    """
    thrift_spec = None


    def __init__(self, parents = None, children = None,):
        self.parents = parents
        self.children = children

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.parents = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = NodeKey()
                        _elem5.read(iprot)
                        self.parents.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.children = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = NodeKey()
                        _elem11.read(iprot)
                        self.children.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NodeConnections')
        if self.parents is not None:
            oprot.writeFieldBegin('parents', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.parents))
            for iter12 in self.parents:
                iter12.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.children is not None:
            oprot.writeFieldBegin('children', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.children))
            for iter13 in self.children:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeGraph(object):
    """
    Attributes:
     - connections
     - infoMap

    """
    thrift_spec = None


    def __init__(self, connections = None, infoMap = None,):
        self.connections = connections
        self.infoMap = infoMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.connections = {}
                    (_ktype15, _vtype16, _size14) = iprot.readMapBegin()
                    for _i18 in range(_size14):
                        _key19 = NodeKey()
                        _key19.read(iprot)
                        _val20 = NodeConnections()
                        _val20.read(iprot)
                        self.connections[_key19] = _val20
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.infoMap = {}
                    (_ktype22, _vtype23, _size21) = iprot.readMapBegin()
                    for _i25 in range(_size21):
                        _key26 = NodeKey()
                        _key26.read(iprot)
                        _val27 = NodeInfo()
                        _val27.read(iprot)
                        self.infoMap[_key26] = _val27
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NodeGraph')
        if self.connections is not None:
            oprot.writeFieldBegin('connections', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(self.connections))
            for kiter28, viter29 in self.connections.items():
                kiter28.write(oprot)
                viter29.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.infoMap is not None:
            oprot.writeFieldBegin('infoMap', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(self.infoMap))
            for kiter30, viter31 in self.infoMap.items():
                kiter30.write(oprot)
                viter31.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PhysicalNodeType(object):
    """
    Attributes:
     - groupByNodeType
     - joinNodeType
     - stagingNodeType
     - modelNodeType
     - tableNodeType

    """
    thrift_spec = None


    def __init__(self, groupByNodeType = None, joinNodeType = None, stagingNodeType = None, modelNodeType = None, tableNodeType = None,):
        self.groupByNodeType = groupByNodeType
        self.joinNodeType = joinNodeType
        self.stagingNodeType = stagingNodeType
        self.modelNodeType = modelNodeType
        self.tableNodeType = tableNodeType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.groupByNodeType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.joinNodeType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.stagingNodeType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.modelNodeType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.tableNodeType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PhysicalNodeType')
        if self.groupByNodeType is not None:
            oprot.writeFieldBegin('groupByNodeType', TType.I32, 1)
            oprot.writeI32(self.groupByNodeType)
            oprot.writeFieldEnd()
        if self.joinNodeType is not None:
            oprot.writeFieldBegin('joinNodeType', TType.I32, 2)
            oprot.writeI32(self.joinNodeType)
            oprot.writeFieldEnd()
        if self.stagingNodeType is not None:
            oprot.writeFieldBegin('stagingNodeType', TType.I32, 3)
            oprot.writeI32(self.stagingNodeType)
            oprot.writeFieldEnd()
        if self.modelNodeType is not None:
            oprot.writeFieldBegin('modelNodeType', TType.I32, 4)
            oprot.writeI32(self.modelNodeType)
            oprot.writeFieldEnd()
        if self.tableNodeType is not None:
            oprot.writeFieldBegin('tableNodeType', TType.I32, 5)
            oprot.writeI32(self.tableNodeType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PhysicalNode(object):
    """
    Attributes:
     - name
     - nodeType
     - logicalNode
     - confHash
     - tableDependencies
     - outputColumns
     - outputTable

    """
    thrift_spec = None


    def __init__(self, name = None, nodeType = None, logicalNode = None, confHash = None, tableDependencies = None, outputColumns = None, outputTable = None,):
        self.name = name
        self.nodeType = nodeType
        self.logicalNode = logicalNode
        self.confHash = confHash
        self.tableDependencies = tableDependencies
        self.outputColumns = outputColumns
        self.outputTable = outputTable

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.nodeType = PhysicalNodeType()
                    self.nodeType.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.logicalNode = LogicalNode()
                    self.logicalNode.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.confHash = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 100:
                if ftype == TType.LIST:
                    self.tableDependencies = []
                    (_etype35, _size32) = iprot.readListBegin()
                    for _i36 in range(_size32):
                        _elem37 = ai.chronon.api.common.ttypes.TableDependency()
                        _elem37.read(iprot)
                        self.tableDependencies.append(_elem37)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 101:
                if ftype == TType.LIST:
                    self.outputColumns = []
                    (_etype41, _size38) = iprot.readListBegin()
                    for _i42 in range(_size38):
                        _elem43 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.outputColumns.append(_elem43)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 102:
                if ftype == TType.STRING:
                    self.outputTable = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PhysicalNode')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.nodeType is not None:
            oprot.writeFieldBegin('nodeType', TType.STRUCT, 2)
            self.nodeType.write(oprot)
            oprot.writeFieldEnd()
        if self.logicalNode is not None:
            oprot.writeFieldBegin('logicalNode', TType.STRUCT, 3)
            self.logicalNode.write(oprot)
            oprot.writeFieldEnd()
        if self.confHash is not None:
            oprot.writeFieldBegin('confHash', TType.STRING, 4)
            oprot.writeString(self.confHash.encode('utf-8') if sys.version_info[0] == 2 else self.confHash)
            oprot.writeFieldEnd()
        if self.tableDependencies is not None:
            oprot.writeFieldBegin('tableDependencies', TType.LIST, 100)
            oprot.writeListBegin(TType.STRUCT, len(self.tableDependencies))
            for iter44 in self.tableDependencies:
                iter44.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.outputColumns is not None:
            oprot.writeFieldBegin('outputColumns', TType.LIST, 101)
            oprot.writeListBegin(TType.STRING, len(self.outputColumns))
            for iter45 in self.outputColumns:
                oprot.writeString(iter45.encode('utf-8') if sys.version_info[0] == 2 else iter45)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.outputTable is not None:
            oprot.writeFieldBegin('outputTable', TType.STRING, 102)
            oprot.writeString(self.outputTable.encode('utf-8') if sys.version_info[0] == 2 else self.outputTable)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PhysicalGraph(object):
    """
    Attributes:
     - node
     - dependencies
     - range

    """
    thrift_spec = None


    def __init__(self, node = None, dependencies = None, range = None,):
        self.node = node
        self.dependencies = dependencies
        self.range = range

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.node = PhysicalNode()
                    self.node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.dependencies = []
                    (_etype49, _size46) = iprot.readListBegin()
                    for _i50 in range(_size46):
                        _elem51 = PhysicalGraph()
                        _elem51.read(iprot)
                        self.dependencies.append(_elem51)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.range = ai.chronon.api.common.ttypes.DateRange()
                    self.range.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PhysicalGraph')
        if self.node is not None:
            oprot.writeFieldBegin('node', TType.STRUCT, 1)
            self.node.write(oprot)
            oprot.writeFieldEnd()
        if self.dependencies is not None:
            oprot.writeFieldBegin('dependencies', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.dependencies))
            for iter52 in self.dependencies:
                iter52.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.range is not None:
            oprot.writeFieldBegin('range', TType.STRUCT, 3)
            self.range.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PhysicalNodeKey(object):
    """
    Multiple logical nodes could share the same physical node
    For that reason we don't have a 1-1 mapping between logical and physical nodes
    TODO -- kill this (typescript dependency)


    Attributes:
     - name
     - nodeType

    """
    thrift_spec = None


    def __init__(self, name = None, nodeType = None,):
        self.name = name
        self.nodeType = nodeType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.nodeType = PhysicalNodeType()
                    self.nodeType.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PhysicalNodeKey')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.nodeType is not None:
            oprot.writeFieldBegin('nodeType', TType.STRUCT, 2)
            self.nodeType.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Conf(object):
    """
    Attributes:
     - name
     - hash
     - contents
     - confType

    """
    thrift_spec = None


    def __init__(self, name = None, hash = None, contents = None, confType = None,):
        self.name = name
        self.hash = hash
        self.contents = contents
        self.confType = confType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.hash = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.contents = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.confType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Conf')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.hash is not None:
            oprot.writeFieldBegin('hash', TType.STRING, 2)
            oprot.writeString(self.hash.encode('utf-8') if sys.version_info[0] == 2 else self.hash)
            oprot.writeFieldEnd()
        if self.contents is not None:
            oprot.writeFieldBegin('contents', TType.STRING, 3)
            oprot.writeString(self.contents.encode('utf-8') if sys.version_info[0] == 2 else self.contents)
            oprot.writeFieldEnd()
        if self.confType is not None:
            oprot.writeFieldBegin('confType', TType.I32, 4)
            oprot.writeI32(self.confType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DiffRequest(object):
    """
    Attributes:
     - namesToHashes

    """
    thrift_spec = None


    def __init__(self, namesToHashes = None,):
        self.namesToHashes = namesToHashes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.namesToHashes = {}
                    (_ktype54, _vtype55, _size53) = iprot.readMapBegin()
                    for _i57 in range(_size53):
                        _key58 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val59 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.namesToHashes[_key58] = _val59
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DiffRequest')
        if self.namesToHashes is not None:
            oprot.writeFieldBegin('namesToHashes', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.namesToHashes))
            for kiter60, viter61 in self.namesToHashes.items():
                oprot.writeString(kiter60.encode('utf-8') if sys.version_info[0] == 2 else kiter60)
                oprot.writeString(viter61.encode('utf-8') if sys.version_info[0] == 2 else viter61)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DiffResponse(object):
    """
    Attributes:
     - diff

    """
    thrift_spec = None


    def __init__(self, diff = None,):
        self.diff = diff

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.diff = []
                    (_etype65, _size62) = iprot.readListBegin()
                    for _i66 in range(_size62):
                        _elem67 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.diff.append(_elem67)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DiffResponse')
        if self.diff is not None:
            oprot.writeFieldBegin('diff', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.diff))
            for iter68 in self.diff:
                oprot.writeString(iter68.encode('utf-8') if sys.version_info[0] == 2 else iter68)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UploadRequest(object):
    """
    Attributes:
     - diffConfs
     - branch

    """
    thrift_spec = None


    def __init__(self, diffConfs = None, branch = None,):
        self.diffConfs = diffConfs
        self.branch = branch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.diffConfs = []
                    (_etype72, _size69) = iprot.readListBegin()
                    for _i73 in range(_size69):
                        _elem74 = Conf()
                        _elem74.read(iprot)
                        self.diffConfs.append(_elem74)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.branch = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UploadRequest')
        if self.diffConfs is not None:
            oprot.writeFieldBegin('diffConfs', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.diffConfs))
            for iter75 in self.diffConfs:
                iter75.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.branch is not None:
            oprot.writeFieldBegin('branch', TType.STRING, 2)
            oprot.writeString(self.branch.encode('utf-8') if sys.version_info[0] == 2 else self.branch)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UploadResponse(object):
    """
    Attributes:
     - message

    """
    thrift_spec = None


    def __init__(self, message = None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UploadResponse')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class WorkflowStartRequest(object):
    """
    Attributes:
     - confName
     - mode
     - branch
     - user
     - start
     - end
     - confHash

    """
    thrift_spec = None


    def __init__(self, confName = None, mode = None, branch = None, user = None, start = None, end = None, confHash = None,):
        self.confName = confName
        self.mode = mode
        self.branch = branch
        self.user = user
        self.start = start
        self.end = end
        self.confHash = confHash

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.confName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mode = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.branch = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.start = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.end = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.confHash = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('WorkflowStartRequest')
        if self.confName is not None:
            oprot.writeFieldBegin('confName', TType.STRING, 1)
            oprot.writeString(self.confName.encode('utf-8') if sys.version_info[0] == 2 else self.confName)
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.STRING, 2)
            oprot.writeString(self.mode.encode('utf-8') if sys.version_info[0] == 2 else self.mode)
            oprot.writeFieldEnd()
        if self.branch is not None:
            oprot.writeFieldBegin('branch', TType.STRING, 3)
            oprot.writeString(self.branch.encode('utf-8') if sys.version_info[0] == 2 else self.branch)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 4)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.STRING, 5)
            oprot.writeString(self.start.encode('utf-8') if sys.version_info[0] == 2 else self.start)
            oprot.writeFieldEnd()
        if self.end is not None:
            oprot.writeFieldBegin('end', TType.STRING, 6)
            oprot.writeString(self.end.encode('utf-8') if sys.version_info[0] == 2 else self.end)
            oprot.writeFieldEnd()
        if self.confHash is not None:
            oprot.writeFieldBegin('confHash', TType.STRING, 7)
            oprot.writeString(self.confHash.encode('utf-8') if sys.version_info[0] == 2 else self.confHash)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class WorkflowStartResponse(object):
    """
    Attributes:
     - workflowId

    """
    thrift_spec = None


    def __init__(self, workflowId = None,):
        self.workflowId = workflowId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.workflowId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('WorkflowStartResponse')
        if self.workflowId is not None:
            oprot.writeFieldBegin('workflowId', TType.STRING, 1)
            oprot.writeString(self.workflowId.encode('utf-8') if sys.version_info[0] == 2 else self.workflowId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeExecutionInfo(object):
    """
    Attributes:
     - nodeName
     - nodeHash
     - startPartition
     - endPartition
     - dependencies
     - stepRuns

    """
    thrift_spec = None


    def __init__(self, nodeName = None, nodeHash = None, startPartition = None, endPartition = None, dependencies = None, stepRuns = None,):
        self.nodeName = nodeName
        self.nodeHash = nodeHash
        self.startPartition = startPartition
        self.endPartition = endPartition
        self.dependencies = dependencies
        self.stepRuns = stepRuns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.nodeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.nodeHash = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.startPartition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.endPartition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.dependencies = []
                    (_etype79, _size76) = iprot.readListBegin()
                    for _i80 in range(_size76):
                        _elem81 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.dependencies.append(_elem81)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.stepRuns = []
                    (_etype85, _size82) = iprot.readListBegin()
                    for _i86 in range(_size82):
                        _elem87 = NodeStepRunInfo()
                        _elem87.read(iprot)
                        self.stepRuns.append(_elem87)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NodeExecutionInfo')
        if self.nodeName is not None:
            oprot.writeFieldBegin('nodeName', TType.STRING, 1)
            oprot.writeString(self.nodeName.encode('utf-8') if sys.version_info[0] == 2 else self.nodeName)
            oprot.writeFieldEnd()
        if self.nodeHash is not None:
            oprot.writeFieldBegin('nodeHash', TType.STRING, 2)
            oprot.writeString(self.nodeHash.encode('utf-8') if sys.version_info[0] == 2 else self.nodeHash)
            oprot.writeFieldEnd()
        if self.startPartition is not None:
            oprot.writeFieldBegin('startPartition', TType.STRING, 3)
            oprot.writeString(self.startPartition.encode('utf-8') if sys.version_info[0] == 2 else self.startPartition)
            oprot.writeFieldEnd()
        if self.endPartition is not None:
            oprot.writeFieldBegin('endPartition', TType.STRING, 4)
            oprot.writeString(self.endPartition.encode('utf-8') if sys.version_info[0] == 2 else self.endPartition)
            oprot.writeFieldEnd()
        if self.dependencies is not None:
            oprot.writeFieldBegin('dependencies', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.dependencies))
            for iter88 in self.dependencies:
                oprot.writeString(iter88.encode('utf-8') if sys.version_info[0] == 2 else iter88)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.stepRuns is not None:
            oprot.writeFieldBegin('stepRuns', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.stepRuns))
            for iter89 in self.stepRuns:
                iter89.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JobTrackingInfo(object):
    """
    Attributes:
     - jobUrl
     - sparkUrl
     - flinkUrl

    """
    thrift_spec = None


    def __init__(self, jobUrl = None, sparkUrl = None, flinkUrl = None,):
        self.jobUrl = jobUrl
        self.sparkUrl = sparkUrl
        self.flinkUrl = flinkUrl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.jobUrl = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sparkUrl = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.flinkUrl = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JobTrackingInfo')
        if self.jobUrl is not None:
            oprot.writeFieldBegin('jobUrl', TType.STRING, 1)
            oprot.writeString(self.jobUrl.encode('utf-8') if sys.version_info[0] == 2 else self.jobUrl)
            oprot.writeFieldEnd()
        if self.sparkUrl is not None:
            oprot.writeFieldBegin('sparkUrl', TType.STRING, 2)
            oprot.writeString(self.sparkUrl.encode('utf-8') if sys.version_info[0] == 2 else self.sparkUrl)
            oprot.writeFieldEnd()
        if self.flinkUrl is not None:
            oprot.writeFieldBegin('flinkUrl', TType.STRING, 3)
            oprot.writeString(self.flinkUrl.encode('utf-8') if sys.version_info[0] == 2 else self.flinkUrl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeStepRunInfo(object):
    """
    Attributes:
     - runId
     - startPartition
     - endPartition
     - startTime
     - endTime
     - status
     - dependentStepRunIds
     - workflowId
     - jobTrackingInfo

    """
    thrift_spec = None


    def __init__(self, runId = None, startPartition = None, endPartition = None, startTime = None, endTime = None, status = None, dependentStepRunIds = None, workflowId = None, jobTrackingInfo = None,):
        self.runId = runId
        self.startPartition = startPartition
        self.endPartition = endPartition
        self.startTime = startTime
        self.endTime = endTime
        self.status = status
        self.dependentStepRunIds = dependentStepRunIds
        self.workflowId = workflowId
        self.jobTrackingInfo = jobTrackingInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.runId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.startPartition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.endPartition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.startTime = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.endTime = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.status = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.dependentStepRunIds = []
                    (_etype93, _size90) = iprot.readListBegin()
                    for _i94 in range(_size90):
                        _elem95 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.dependentStepRunIds.append(_elem95)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.workflowId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.jobTrackingInfo = JobTrackingInfo()
                    self.jobTrackingInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NodeStepRunInfo')
        if self.runId is not None:
            oprot.writeFieldBegin('runId', TType.STRING, 1)
            oprot.writeString(self.runId.encode('utf-8') if sys.version_info[0] == 2 else self.runId)
            oprot.writeFieldEnd()
        if self.startPartition is not None:
            oprot.writeFieldBegin('startPartition', TType.STRING, 2)
            oprot.writeString(self.startPartition.encode('utf-8') if sys.version_info[0] == 2 else self.startPartition)
            oprot.writeFieldEnd()
        if self.endPartition is not None:
            oprot.writeFieldBegin('endPartition', TType.STRING, 3)
            oprot.writeString(self.endPartition.encode('utf-8') if sys.version_info[0] == 2 else self.endPartition)
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.STRING, 4)
            oprot.writeString(self.startTime.encode('utf-8') if sys.version_info[0] == 2 else self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.STRING, 5)
            oprot.writeString(self.endTime.encode('utf-8') if sys.version_info[0] == 2 else self.endTime)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.I32, 6)
            oprot.writeI32(self.status)
            oprot.writeFieldEnd()
        if self.dependentStepRunIds is not None:
            oprot.writeFieldBegin('dependentStepRunIds', TType.LIST, 7)
            oprot.writeListBegin(TType.STRING, len(self.dependentStepRunIds))
            for iter96 in self.dependentStepRunIds:
                oprot.writeString(iter96.encode('utf-8') if sys.version_info[0] == 2 else iter96)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.workflowId is not None:
            oprot.writeFieldBegin('workflowId', TType.STRING, 8)
            oprot.writeString(self.workflowId.encode('utf-8') if sys.version_info[0] == 2 else self.workflowId)
            oprot.writeFieldEnd()
        if self.jobTrackingInfo is not None:
            oprot.writeFieldBegin('jobTrackingInfo', TType.STRUCT, 9)
            self.jobTrackingInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class WorkflowStatusResponse(object):
    """
    Attributes:
     - workflowId
     - confName
     - mode
     - branch
     - user
     - status
     - startPartition
     - endPartition
     - nodeExecutions
     - terminalNodes

    """
    thrift_spec = None


    def __init__(self, workflowId = None, confName = None, mode = None, branch = None, user = None, status = None, startPartition = None, endPartition = None, nodeExecutions = None, terminalNodes = None,):
        self.workflowId = workflowId
        self.confName = confName
        self.mode = mode
        self.branch = branch
        self.user = user
        self.status = status
        self.startPartition = startPartition
        self.endPartition = endPartition
        self.nodeExecutions = nodeExecutions
        self.terminalNodes = terminalNodes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.workflowId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.confName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.mode = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.branch = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.status = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.startPartition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.endPartition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.nodeExecutions = []
                    (_etype100, _size97) = iprot.readListBegin()
                    for _i101 in range(_size97):
                        _elem102 = NodeExecutionInfo()
                        _elem102.read(iprot)
                        self.nodeExecutions.append(_elem102)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.LIST:
                    self.terminalNodes = []
                    (_etype106, _size103) = iprot.readListBegin()
                    for _i107 in range(_size103):
                        _elem108 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.terminalNodes.append(_elem108)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('WorkflowStatusResponse')
        if self.workflowId is not None:
            oprot.writeFieldBegin('workflowId', TType.STRING, 1)
            oprot.writeString(self.workflowId.encode('utf-8') if sys.version_info[0] == 2 else self.workflowId)
            oprot.writeFieldEnd()
        if self.confName is not None:
            oprot.writeFieldBegin('confName', TType.STRING, 2)
            oprot.writeString(self.confName.encode('utf-8') if sys.version_info[0] == 2 else self.confName)
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.STRING, 3)
            oprot.writeString(self.mode.encode('utf-8') if sys.version_info[0] == 2 else self.mode)
            oprot.writeFieldEnd()
        if self.branch is not None:
            oprot.writeFieldBegin('branch', TType.STRING, 4)
            oprot.writeString(self.branch.encode('utf-8') if sys.version_info[0] == 2 else self.branch)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 5)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.I32, 6)
            oprot.writeI32(self.status)
            oprot.writeFieldEnd()
        if self.startPartition is not None:
            oprot.writeFieldBegin('startPartition', TType.STRING, 7)
            oprot.writeString(self.startPartition.encode('utf-8') if sys.version_info[0] == 2 else self.startPartition)
            oprot.writeFieldEnd()
        if self.endPartition is not None:
            oprot.writeFieldBegin('endPartition', TType.STRING, 8)
            oprot.writeString(self.endPartition.encode('utf-8') if sys.version_info[0] == 2 else self.endPartition)
            oprot.writeFieldEnd()
        if self.nodeExecutions is not None:
            oprot.writeFieldBegin('nodeExecutions', TType.LIST, 9)
            oprot.writeListBegin(TType.STRUCT, len(self.nodeExecutions))
            for iter109 in self.nodeExecutions:
                iter109.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.terminalNodes is not None:
            oprot.writeFieldBegin('terminalNodes', TType.LIST, 10)
            oprot.writeListBegin(TType.STRING, len(self.terminalNodes))
            for iter110 in self.terminalNodes:
                oprot.writeString(iter110.encode('utf-8') if sys.version_info[0] == 2 else iter110)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class WorkflowStatusRequest(object):
    """
    Attributes:
     - workflowId

    """
    thrift_spec = None


    def __init__(self, workflowId = None,):
        self.workflowId = workflowId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.workflowId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('WorkflowStatusRequest')
        if self.workflowId is not None:
            oprot.writeFieldBegin('workflowId', TType.STRING, 1)
            oprot.writeString(self.workflowId.encode('utf-8') if sys.version_info[0] == 2 else self.workflowId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeStatusRequest(object):
    """
    Attributes:
     - nodeName
     - start
     - end

    """
    thrift_spec = None


    def __init__(self, nodeName = None, start = None, end = None,):
        self.nodeName = nodeName
        self.start = start
        self.end = end

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.nodeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.start = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.end = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NodeStatusRequest')
        if self.nodeName is not None:
            oprot.writeFieldBegin('nodeName', TType.STRING, 1)
            oprot.writeString(self.nodeName.encode('utf-8') if sys.version_info[0] == 2 else self.nodeName)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.STRING, 2)
            oprot.writeString(self.start.encode('utf-8') if sys.version_info[0] == 2 else self.start)
            oprot.writeFieldEnd()
        if self.end is not None:
            oprot.writeFieldBegin('end', TType.STRING, 3)
            oprot.writeString(self.end.encode('utf-8') if sys.version_info[0] == 2 else self.end)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeStatusResponse(object):
    """
    Attributes:
     - nodeExecutions

    """
    thrift_spec = None


    def __init__(self, nodeExecutions = None,):
        self.nodeExecutions = nodeExecutions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.nodeExecutions = []
                    (_etype114, _size111) = iprot.readListBegin()
                    for _i115 in range(_size111):
                        _elem116 = NodeExecutionInfo()
                        _elem116.read(iprot)
                        self.nodeExecutions.append(_elem116)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NodeStatusResponse')
        if self.nodeExecutions is not None:
            oprot.writeFieldBegin('nodeExecutions', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.nodeExecutions))
            for iter117 in self.nodeExecutions:
                iter117.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConfStatusRequest(object):
    """
    Attributes:
     - confName
     - start
     - end
     - confHash

    """
    thrift_spec = None


    def __init__(self, confName = None, start = None, end = None, confHash = None,):
        self.confName = confName
        self.start = start
        self.end = end
        self.confHash = confHash

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.confName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.start = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.end = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.confHash = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConfStatusRequest')
        if self.confName is not None:
            oprot.writeFieldBegin('confName', TType.STRING, 1)
            oprot.writeString(self.confName.encode('utf-8') if sys.version_info[0] == 2 else self.confName)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.STRING, 2)
            oprot.writeString(self.start.encode('utf-8') if sys.version_info[0] == 2 else self.start)
            oprot.writeFieldEnd()
        if self.end is not None:
            oprot.writeFieldBegin('end', TType.STRING, 3)
            oprot.writeString(self.end.encode('utf-8') if sys.version_info[0] == 2 else self.end)
            oprot.writeFieldEnd()
        if self.confHash is not None:
            oprot.writeFieldBegin('confHash', TType.STRING, 4)
            oprot.writeString(self.confHash.encode('utf-8') if sys.version_info[0] == 2 else self.confHash)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConfStatusResponse(object):
    """
    Attributes:
     - nodeExecutions
     - terminalNodes

    """
    thrift_spec = None


    def __init__(self, nodeExecutions = None, terminalNodes = None,):
        self.nodeExecutions = nodeExecutions
        self.terminalNodes = terminalNodes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.nodeExecutions = []
                    (_etype121, _size118) = iprot.readListBegin()
                    for _i122 in range(_size118):
                        _elem123 = NodeExecutionInfo()
                        _elem123.read(iprot)
                        self.nodeExecutions.append(_elem123)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.terminalNodes = []
                    (_etype127, _size124) = iprot.readListBegin()
                    for _i128 in range(_size124):
                        _elem129 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.terminalNodes.append(_elem129)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConfStatusResponse')
        if self.nodeExecutions is not None:
            oprot.writeFieldBegin('nodeExecutions', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.nodeExecutions))
            for iter130 in self.nodeExecutions:
                iter130.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.terminalNodes is not None:
            oprot.writeFieldBegin('terminalNodes', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.terminalNodes))
            for iter131 in self.terminalNodes:
                oprot.writeString(iter131.encode('utf-8') if sys.version_info[0] == 2 else iter131)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class WorkflowResponse(object):
    """
    Attributes:
     - workflowId
     - confName
     - mode
     - branch
     - user
     - status
     - startPartition
     - endPartition
     - terminalNodes
     - confType

    """
    thrift_spec = None


    def __init__(self, workflowId = None, confName = None, mode = None, branch = None, user = None, status = None, startPartition = None, endPartition = None, terminalNodes = None, confType = None,):
        self.workflowId = workflowId
        self.confName = confName
        self.mode = mode
        self.branch = branch
        self.user = user
        self.status = status
        self.startPartition = startPartition
        self.endPartition = endPartition
        self.terminalNodes = terminalNodes
        self.confType = confType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.workflowId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.confName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.mode = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.branch = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.status = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.startPartition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.endPartition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.LIST:
                    self.terminalNodes = []
                    (_etype135, _size132) = iprot.readListBegin()
                    for _i136 in range(_size132):
                        _elem137 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.terminalNodes.append(_elem137)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.confType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('WorkflowResponse')
        if self.workflowId is not None:
            oprot.writeFieldBegin('workflowId', TType.STRING, 1)
            oprot.writeString(self.workflowId.encode('utf-8') if sys.version_info[0] == 2 else self.workflowId)
            oprot.writeFieldEnd()
        if self.confName is not None:
            oprot.writeFieldBegin('confName', TType.STRING, 2)
            oprot.writeString(self.confName.encode('utf-8') if sys.version_info[0] == 2 else self.confName)
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.STRING, 3)
            oprot.writeString(self.mode.encode('utf-8') if sys.version_info[0] == 2 else self.mode)
            oprot.writeFieldEnd()
        if self.branch is not None:
            oprot.writeFieldBegin('branch', TType.STRING, 4)
            oprot.writeString(self.branch.encode('utf-8') if sys.version_info[0] == 2 else self.branch)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 5)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.I32, 6)
            oprot.writeI32(self.status)
            oprot.writeFieldEnd()
        if self.startPartition is not None:
            oprot.writeFieldBegin('startPartition', TType.STRING, 7)
            oprot.writeString(self.startPartition.encode('utf-8') if sys.version_info[0] == 2 else self.startPartition)
            oprot.writeFieldEnd()
        if self.endPartition is not None:
            oprot.writeFieldBegin('endPartition', TType.STRING, 8)
            oprot.writeString(self.endPartition.encode('utf-8') if sys.version_info[0] == 2 else self.endPartition)
            oprot.writeFieldEnd()
        if self.terminalNodes is not None:
            oprot.writeFieldBegin('terminalNodes', TType.LIST, 10)
            oprot.writeListBegin(TType.STRING, len(self.terminalNodes))
            for iter138 in self.terminalNodes:
                oprot.writeString(iter138.encode('utf-8') if sys.version_info[0] == 2 else iter138)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.confType is not None:
            oprot.writeFieldBegin('confType', TType.I32, 11)
            oprot.writeI32(self.confType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class WorkflowListRequest(object):
    """
    Attributes:
     - limit
     - numOfWorkflows

    """
    thrift_spec = None


    def __init__(self, limit = None, numOfWorkflows = None,):
        self.limit = limit
        self.numOfWorkflows = numOfWorkflows

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.numOfWorkflows = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('WorkflowListRequest')
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 1)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        if self.numOfWorkflows is not None:
            oprot.writeFieldBegin('numOfWorkflows', TType.I32, 2)
            oprot.writeI32(self.numOfWorkflows)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class WorkflowListResponse(object):
    """
    Attributes:
     - workflows

    """
    thrift_spec = None


    def __init__(self, workflows = None,):
        self.workflows = workflows

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.workflows = []
                    (_etype142, _size139) = iprot.readListBegin()
                    for _i143 in range(_size139):
                        _elem144 = WorkflowResponse()
                        _elem144.read(iprot)
                        self.workflows.append(_elem144)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('WorkflowListResponse')
        if self.workflows is not None:
            oprot.writeFieldBegin('workflows', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.workflows))
            for iter145 in self.workflows:
                iter145.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConfListRequest(object):
    """
    lists all confs of the specified type

    Attributes:
     - confType
     - branch

    """
    thrift_spec = None


    def __init__(self, confType = None, branch = None,):
        self.confType = confType
        self.branch = branch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.confType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.branch = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConfListRequest')
        if self.confType is not None:
            oprot.writeFieldBegin('confType', TType.I32, 1)
            oprot.writeI32(self.confType)
            oprot.writeFieldEnd()
        if self.branch is not None:
            oprot.writeFieldBegin('branch', TType.STRING, 2)
            oprot.writeString(self.branch.encode('utf-8') if sys.version_info[0] == 2 else self.branch)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConfListItemResponse(object):
    """
    Response for listing configurations of a specific type

    Attributes:
     - confName
     - confType
     - confHash

    """
    thrift_spec = None


    def __init__(self, confName = None, confType = None, confHash = None,):
        self.confName = confName
        self.confType = confType
        self.confHash = confHash

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.confName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.confType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.confHash = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConfListItemResponse')
        if self.confName is not None:
            oprot.writeFieldBegin('confName', TType.STRING, 1)
            oprot.writeString(self.confName.encode('utf-8') if sys.version_info[0] == 2 else self.confName)
            oprot.writeFieldEnd()
        if self.confType is not None:
            oprot.writeFieldBegin('confType', TType.I32, 2)
            oprot.writeI32(self.confType)
            oprot.writeFieldEnd()
        if self.confHash is not None:
            oprot.writeFieldBegin('confHash', TType.STRING, 3)
            oprot.writeString(self.confHash.encode('utf-8') if sys.version_info[0] == 2 else self.confHash)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConfListResponse(object):
    """
    Attributes:
     - confs

    """
    thrift_spec = None


    def __init__(self, confs = None,):
        self.confs = confs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.confs = []
                    (_etype149, _size146) = iprot.readListBegin()
                    for _i150 in range(_size146):
                        _elem151 = ConfListItemResponse()
                        _elem151.read(iprot)
                        self.confs.append(_elem151)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConfListResponse')
        if self.confs is not None:
            oprot.writeFieldBegin('confs', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.confs))
            for iter152 in self.confs:
                iter152.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConfGetRequest(object):
    """
    Attributes:
     - confName
     - confType

    """
    thrift_spec = None


    def __init__(self, confName = None, confType = None,):
        self.confName = confName
        self.confType = confType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.confName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.confType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConfGetRequest')
        if self.confName is not None:
            oprot.writeFieldBegin('confName', TType.STRING, 1)
            oprot.writeString(self.confName.encode('utf-8') if sys.version_info[0] == 2 else self.confName)
            oprot.writeFieldEnd()
        if self.confType is not None:
            oprot.writeFieldBegin('confType', TType.I32, 2)
            oprot.writeI32(self.confType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConfGetResponse(object):
    """
    Attributes:
     - confName
     - confHash
     - confType
     - confContents

    """
    thrift_spec = None


    def __init__(self, confName = None, confHash = None, confType = None, confContents = None,):
        self.confName = confName
        self.confHash = confHash
        self.confType = confType
        self.confContents = confContents

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.confName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.confHash = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.confType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.confContents = LogicalNode()
                    self.confContents.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConfGetResponse')
        if self.confName is not None:
            oprot.writeFieldBegin('confName', TType.STRING, 1)
            oprot.writeString(self.confName.encode('utf-8') if sys.version_info[0] == 2 else self.confName)
            oprot.writeFieldEnd()
        if self.confHash is not None:
            oprot.writeFieldBegin('confHash', TType.STRING, 2)
            oprot.writeString(self.confHash.encode('utf-8') if sys.version_info[0] == 2 else self.confHash)
            oprot.writeFieldEnd()
        if self.confType is not None:
            oprot.writeFieldBegin('confType', TType.I32, 3)
            oprot.writeI32(self.confType)
            oprot.writeFieldEnd()
        if self.confContents is not None:
            oprot.writeFieldBegin('confContents', TType.STRUCT, 4)
            self.confContents.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BaseEvalResult(object):
    """
    Attributes:
     - checkResult
     - message

    """
    thrift_spec = None


    def __init__(self, checkResult = None, message = None,):
        self.checkResult = checkResult
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.checkResult = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BaseEvalResult')
        if self.checkResult is not None:
            oprot.writeFieldBegin('checkResult', TType.I32, 1)
            oprot.writeI32(self.checkResult)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JoinPartEvalResult(object):
    """
    Attributes:
     - partName
     - gbEvalResult
     - keySchemaCheck

    """
    thrift_spec = None


    def __init__(self, partName = None, gbEvalResult = None, keySchemaCheck = None,):
        self.partName = partName
        self.gbEvalResult = gbEvalResult
        self.keySchemaCheck = keySchemaCheck

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.partName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.gbEvalResult = GroupByEvalResult()
                    self.gbEvalResult.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.keySchemaCheck = BaseEvalResult()
                    self.keySchemaCheck.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JoinPartEvalResult')
        if self.partName is not None:
            oprot.writeFieldBegin('partName', TType.STRING, 1)
            oprot.writeString(self.partName.encode('utf-8') if sys.version_info[0] == 2 else self.partName)
            oprot.writeFieldEnd()
        if self.gbEvalResult is not None:
            oprot.writeFieldBegin('gbEvalResult', TType.STRUCT, 2)
            self.gbEvalResult.write(oprot)
            oprot.writeFieldEnd()
        if self.keySchemaCheck is not None:
            oprot.writeFieldBegin('keySchemaCheck', TType.STRUCT, 3)
            self.keySchemaCheck.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JoinEvalResult(object):
    """
    Attributes:
     - leftExpressionCheck
     - leftTimestampCheck
     - joinPartChecks
     - derivationValidityCheck
     - leftQuerySchema
     - rightPartsSchema
     - derivationsSchema
     - externalPartsSchema

    """
    thrift_spec = None


    def __init__(self, leftExpressionCheck = None, leftTimestampCheck = None, joinPartChecks = None, derivationValidityCheck = None, leftQuerySchema = None, rightPartsSchema = None, derivationsSchema = None, externalPartsSchema = None,):
        self.leftExpressionCheck = leftExpressionCheck
        self.leftTimestampCheck = leftTimestampCheck
        self.joinPartChecks = joinPartChecks
        self.derivationValidityCheck = derivationValidityCheck
        self.leftQuerySchema = leftQuerySchema
        self.rightPartsSchema = rightPartsSchema
        self.derivationsSchema = derivationsSchema
        self.externalPartsSchema = externalPartsSchema

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.leftExpressionCheck = BaseEvalResult()
                    self.leftExpressionCheck.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.leftTimestampCheck = BaseEvalResult()
                    self.leftTimestampCheck.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.joinPartChecks = []
                    (_etype156, _size153) = iprot.readListBegin()
                    for _i157 in range(_size153):
                        _elem158 = JoinPartEvalResult()
                        _elem158.read(iprot)
                        self.joinPartChecks.append(_elem158)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.derivationValidityCheck = BaseEvalResult()
                    self.derivationValidityCheck.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.leftQuerySchema = {}
                    (_ktype160, _vtype161, _size159) = iprot.readMapBegin()
                    for _i163 in range(_size159):
                        _key164 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val165 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.leftQuerySchema[_key164] = _val165
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.rightPartsSchema = {}
                    (_ktype167, _vtype168, _size166) = iprot.readMapBegin()
                    for _i170 in range(_size166):
                        _key171 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val172 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.rightPartsSchema[_key171] = _val172
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.MAP:
                    self.derivationsSchema = {}
                    (_ktype174, _vtype175, _size173) = iprot.readMapBegin()
                    for _i177 in range(_size173):
                        _key178 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val179 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.derivationsSchema[_key178] = _val179
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.MAP:
                    self.externalPartsSchema = {}
                    (_ktype181, _vtype182, _size180) = iprot.readMapBegin()
                    for _i184 in range(_size180):
                        _key185 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val186 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.externalPartsSchema[_key185] = _val186
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JoinEvalResult')
        if self.leftExpressionCheck is not None:
            oprot.writeFieldBegin('leftExpressionCheck', TType.STRUCT, 1)
            self.leftExpressionCheck.write(oprot)
            oprot.writeFieldEnd()
        if self.leftTimestampCheck is not None:
            oprot.writeFieldBegin('leftTimestampCheck', TType.STRUCT, 2)
            self.leftTimestampCheck.write(oprot)
            oprot.writeFieldEnd()
        if self.joinPartChecks is not None:
            oprot.writeFieldBegin('joinPartChecks', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.joinPartChecks))
            for iter187 in self.joinPartChecks:
                iter187.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.derivationValidityCheck is not None:
            oprot.writeFieldBegin('derivationValidityCheck', TType.STRUCT, 4)
            self.derivationValidityCheck.write(oprot)
            oprot.writeFieldEnd()
        if self.leftQuerySchema is not None:
            oprot.writeFieldBegin('leftQuerySchema', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.leftQuerySchema))
            for kiter188, viter189 in self.leftQuerySchema.items():
                oprot.writeString(kiter188.encode('utf-8') if sys.version_info[0] == 2 else kiter188)
                oprot.writeString(viter189.encode('utf-8') if sys.version_info[0] == 2 else viter189)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.rightPartsSchema is not None:
            oprot.writeFieldBegin('rightPartsSchema', TType.MAP, 6)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.rightPartsSchema))
            for kiter190, viter191 in self.rightPartsSchema.items():
                oprot.writeString(kiter190.encode('utf-8') if sys.version_info[0] == 2 else kiter190)
                oprot.writeString(viter191.encode('utf-8') if sys.version_info[0] == 2 else viter191)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.derivationsSchema is not None:
            oprot.writeFieldBegin('derivationsSchema', TType.MAP, 7)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.derivationsSchema))
            for kiter192, viter193 in self.derivationsSchema.items():
                oprot.writeString(kiter192.encode('utf-8') if sys.version_info[0] == 2 else kiter192)
                oprot.writeString(viter193.encode('utf-8') if sys.version_info[0] == 2 else viter193)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.externalPartsSchema is not None:
            oprot.writeFieldBegin('externalPartsSchema', TType.MAP, 8)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.externalPartsSchema))
            for kiter194, viter195 in self.externalPartsSchema.items():
                oprot.writeString(kiter194.encode('utf-8') if sys.version_info[0] == 2 else kiter194)
                oprot.writeString(viter195.encode('utf-8') if sys.version_info[0] == 2 else viter195)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GroupByEvalResult(object):
    """
    Attributes:
     - sourceExpressionCheck
     - sourceTimestampCheck
     - aggExpressionCheck
     - derivationsExpressionCheck
     - keySchema
     - aggSchema
     - derivationsSchema

    """
    thrift_spec = None


    def __init__(self, sourceExpressionCheck = None, sourceTimestampCheck = None, aggExpressionCheck = None, derivationsExpressionCheck = None, keySchema = None, aggSchema = None, derivationsSchema = None,):
        self.sourceExpressionCheck = sourceExpressionCheck
        self.sourceTimestampCheck = sourceTimestampCheck
        self.aggExpressionCheck = aggExpressionCheck
        self.derivationsExpressionCheck = derivationsExpressionCheck
        self.keySchema = keySchema
        self.aggSchema = aggSchema
        self.derivationsSchema = derivationsSchema

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.sourceExpressionCheck = BaseEvalResult()
                    self.sourceExpressionCheck.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.sourceTimestampCheck = BaseEvalResult()
                    self.sourceTimestampCheck.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.aggExpressionCheck = BaseEvalResult()
                    self.aggExpressionCheck.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.derivationsExpressionCheck = BaseEvalResult()
                    self.derivationsExpressionCheck.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.keySchema = {}
                    (_ktype197, _vtype198, _size196) = iprot.readMapBegin()
                    for _i200 in range(_size196):
                        _key201 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val202 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.keySchema[_key201] = _val202
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.aggSchema = {}
                    (_ktype204, _vtype205, _size203) = iprot.readMapBegin()
                    for _i207 in range(_size203):
                        _key208 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val209 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.aggSchema[_key208] = _val209
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.MAP:
                    self.derivationsSchema = {}
                    (_ktype211, _vtype212, _size210) = iprot.readMapBegin()
                    for _i214 in range(_size210):
                        _key215 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val216 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.derivationsSchema[_key215] = _val216
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GroupByEvalResult')
        if self.sourceExpressionCheck is not None:
            oprot.writeFieldBegin('sourceExpressionCheck', TType.STRUCT, 1)
            self.sourceExpressionCheck.write(oprot)
            oprot.writeFieldEnd()
        if self.sourceTimestampCheck is not None:
            oprot.writeFieldBegin('sourceTimestampCheck', TType.STRUCT, 2)
            self.sourceTimestampCheck.write(oprot)
            oprot.writeFieldEnd()
        if self.aggExpressionCheck is not None:
            oprot.writeFieldBegin('aggExpressionCheck', TType.STRUCT, 3)
            self.aggExpressionCheck.write(oprot)
            oprot.writeFieldEnd()
        if self.derivationsExpressionCheck is not None:
            oprot.writeFieldBegin('derivationsExpressionCheck', TType.STRUCT, 4)
            self.derivationsExpressionCheck.write(oprot)
            oprot.writeFieldEnd()
        if self.keySchema is not None:
            oprot.writeFieldBegin('keySchema', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.keySchema))
            for kiter217, viter218 in self.keySchema.items():
                oprot.writeString(kiter217.encode('utf-8') if sys.version_info[0] == 2 else kiter217)
                oprot.writeString(viter218.encode('utf-8') if sys.version_info[0] == 2 else viter218)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.aggSchema is not None:
            oprot.writeFieldBegin('aggSchema', TType.MAP, 6)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.aggSchema))
            for kiter219, viter220 in self.aggSchema.items():
                oprot.writeString(kiter219.encode('utf-8') if sys.version_info[0] == 2 else kiter219)
                oprot.writeString(viter220.encode('utf-8') if sys.version_info[0] == 2 else viter220)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.derivationsSchema is not None:
            oprot.writeFieldBegin('derivationsSchema', TType.MAP, 7)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.derivationsSchema))
            for kiter221, viter222 in self.derivationsSchema.items():
                oprot.writeString(kiter221.encode('utf-8') if sys.version_info[0] == 2 else kiter221)
                oprot.writeString(viter222.encode('utf-8') if sys.version_info[0] == 2 else viter222)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StagingQueryEvalResult(object):
    """
    Attributes:
     - queryCheck
     - outputSchema

    """
    thrift_spec = None


    def __init__(self, queryCheck = None, outputSchema = None,):
        self.queryCheck = queryCheck
        self.outputSchema = outputSchema

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.queryCheck = BaseEvalResult()
                    self.queryCheck.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.outputSchema = {}
                    (_ktype224, _vtype225, _size223) = iprot.readMapBegin()
                    for _i227 in range(_size223):
                        _key228 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val229 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.outputSchema[_key228] = _val229
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('StagingQueryEvalResult')
        if self.queryCheck is not None:
            oprot.writeFieldBegin('queryCheck', TType.STRUCT, 1)
            self.queryCheck.write(oprot)
            oprot.writeFieldEnd()
        if self.outputSchema is not None:
            oprot.writeFieldBegin('outputSchema', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.outputSchema))
            for kiter230, viter231 in self.outputSchema.items():
                oprot.writeString(kiter230.encode('utf-8') if sys.version_info[0] == 2 else kiter230)
                oprot.writeString(viter231.encode('utf-8') if sys.version_info[0] == 2 else viter231)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TabularData)
TabularData.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'table', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'topic', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'mutationTable', 'UTF8', None, ),  # 3
    (4, TType.I32, 'type', None, None, ),  # 4
)
all_structs.append(LogicalNode)
LogicalNode.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'stagingQuery', [ai.chronon.api.ttypes.StagingQuery, None], None, ),  # 1
    (2, TType.STRUCT, 'join', [ai.chronon.api.ttypes.Join, None], None, ),  # 2
    (3, TType.STRUCT, 'groupBy', [ai.chronon.api.ttypes.GroupBy, None], None, ),  # 3
    (4, TType.STRUCT, 'model', [ai.chronon.api.ttypes.Model, None], None, ),  # 4
    (5, TType.STRUCT, 'tabularData', [TabularData, None], None, ),  # 5
)
all_structs.append(NodeKey)
NodeKey.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'logicalType', None, None, ),  # 2
    (3, TType.STRUCT, 'physicalType', [PhysicalNodeType, None], None, ),  # 3
)
all_structs.append(NodeInfo)
NodeInfo.thrift_spec = (
    None,  # 0
    None,  # 1
    None,  # 2
    None,  # 3
    None,  # 4
    None,  # 5
    None,  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    None,  # 10
    (11, TType.STRING, 'semanticHash', 'UTF8', None, ),  # 11
    (12, TType.STRING, 'confHash', 'UTF8', None, ),  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    (20, TType.STRING, 'branch', 'UTF8', None, ),  # 20
    (21, TType.STRING, 'author', 'UTF8', None, ),  # 21
    None,  # 22
    None,  # 23
    None,  # 24
    None,  # 25
    None,  # 26
    None,  # 27
    None,  # 28
    None,  # 29
    (30, TType.STRUCT, 'conf', [LogicalNode, None], None, ),  # 30
)
all_structs.append(NodeConnections)
NodeConnections.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'parents', (TType.STRUCT, [NodeKey, None], False), None, ),  # 1
    (2, TType.LIST, 'children', (TType.STRUCT, [NodeKey, None], False), None, ),  # 2
)
all_structs.append(NodeGraph)
NodeGraph.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'connections', (TType.STRUCT, [NodeKey, None], TType.STRUCT, [NodeConnections, None], False), None, ),  # 1
    (2, TType.MAP, 'infoMap', (TType.STRUCT, [NodeKey, None], TType.STRUCT, [NodeInfo, None], False), None, ),  # 2
)
all_structs.append(PhysicalNodeType)
PhysicalNodeType.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'groupByNodeType', None, None, ),  # 1
    (2, TType.I32, 'joinNodeType', None, None, ),  # 2
    (3, TType.I32, 'stagingNodeType', None, None, ),  # 3
    (4, TType.I32, 'modelNodeType', None, None, ),  # 4
    (5, TType.I32, 'tableNodeType', None, None, ),  # 5
)
all_structs.append(PhysicalNode)
PhysicalNode.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'nodeType', [PhysicalNodeType, None], None, ),  # 2
    (3, TType.STRUCT, 'logicalNode', [LogicalNode, None], None, ),  # 3
    (4, TType.STRING, 'confHash', 'UTF8', None, ),  # 4
    None,  # 5
    None,  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    None,  # 10
    None,  # 11
    None,  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    None,  # 20
    None,  # 21
    None,  # 22
    None,  # 23
    None,  # 24
    None,  # 25
    None,  # 26
    None,  # 27
    None,  # 28
    None,  # 29
    None,  # 30
    None,  # 31
    None,  # 32
    None,  # 33
    None,  # 34
    None,  # 35
    None,  # 36
    None,  # 37
    None,  # 38
    None,  # 39
    None,  # 40
    None,  # 41
    None,  # 42
    None,  # 43
    None,  # 44
    None,  # 45
    None,  # 46
    None,  # 47
    None,  # 48
    None,  # 49
    None,  # 50
    None,  # 51
    None,  # 52
    None,  # 53
    None,  # 54
    None,  # 55
    None,  # 56
    None,  # 57
    None,  # 58
    None,  # 59
    None,  # 60
    None,  # 61
    None,  # 62
    None,  # 63
    None,  # 64
    None,  # 65
    None,  # 66
    None,  # 67
    None,  # 68
    None,  # 69
    None,  # 70
    None,  # 71
    None,  # 72
    None,  # 73
    None,  # 74
    None,  # 75
    None,  # 76
    None,  # 77
    None,  # 78
    None,  # 79
    None,  # 80
    None,  # 81
    None,  # 82
    None,  # 83
    None,  # 84
    None,  # 85
    None,  # 86
    None,  # 87
    None,  # 88
    None,  # 89
    None,  # 90
    None,  # 91
    None,  # 92
    None,  # 93
    None,  # 94
    None,  # 95
    None,  # 96
    None,  # 97
    None,  # 98
    None,  # 99
    (100, TType.LIST, 'tableDependencies', (TType.STRUCT, [ai.chronon.api.common.ttypes.TableDependency, None], False), None, ),  # 100
    (101, TType.LIST, 'outputColumns', (TType.STRING, 'UTF8', False), None, ),  # 101
    (102, TType.STRING, 'outputTable', 'UTF8', None, ),  # 102
)
all_structs.append(PhysicalGraph)
PhysicalGraph.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'node', [PhysicalNode, None], None, ),  # 1
    (2, TType.LIST, 'dependencies', (TType.STRUCT, [PhysicalGraph, None], False), None, ),  # 2
    (3, TType.STRUCT, 'range', [ai.chronon.api.common.ttypes.DateRange, None], None, ),  # 3
)
all_structs.append(PhysicalNodeKey)
PhysicalNodeKey.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'nodeType', [PhysicalNodeType, None], None, ),  # 2
)
all_structs.append(Conf)
Conf.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'hash', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'contents', 'UTF8', None, ),  # 3
    (4, TType.I32, 'confType', None, None, ),  # 4
)
all_structs.append(DiffRequest)
DiffRequest.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'namesToHashes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(DiffResponse)
DiffResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'diff', (TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(UploadRequest)
UploadRequest.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'diffConfs', (TType.STRUCT, [Conf, None], False), None, ),  # 1
    (2, TType.STRING, 'branch', 'UTF8', None, ),  # 2
)
all_structs.append(UploadResponse)
UploadResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(WorkflowStartRequest)
WorkflowStartRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'confName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mode', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'branch', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'user', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'start', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'end', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'confHash', 'UTF8', None, ),  # 7
)
all_structs.append(WorkflowStartResponse)
WorkflowStartResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'workflowId', 'UTF8', None, ),  # 1
)
all_structs.append(NodeExecutionInfo)
NodeExecutionInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'nodeName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'nodeHash', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'startPartition', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'endPartition', 'UTF8', None, ),  # 4
    (5, TType.LIST, 'dependencies', (TType.STRING, 'UTF8', False), None, ),  # 5
    (6, TType.LIST, 'stepRuns', (TType.STRUCT, [NodeStepRunInfo, None], False), None, ),  # 6
)
all_structs.append(JobTrackingInfo)
JobTrackingInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'jobUrl', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'sparkUrl', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'flinkUrl', 'UTF8', None, ),  # 3
)
all_structs.append(NodeStepRunInfo)
NodeStepRunInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'runId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'startPartition', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'endPartition', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'startTime', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'endTime', 'UTF8', None, ),  # 5
    (6, TType.I32, 'status', None, None, ),  # 6
    (7, TType.LIST, 'dependentStepRunIds', (TType.STRING, 'UTF8', False), None, ),  # 7
    (8, TType.STRING, 'workflowId', 'UTF8', None, ),  # 8
    (9, TType.STRUCT, 'jobTrackingInfo', [JobTrackingInfo, None], None, ),  # 9
)
all_structs.append(WorkflowStatusResponse)
WorkflowStatusResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'workflowId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'confName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'mode', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'branch', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'user', 'UTF8', None, ),  # 5
    (6, TType.I32, 'status', None, None, ),  # 6
    (7, TType.STRING, 'startPartition', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'endPartition', 'UTF8', None, ),  # 8
    (9, TType.LIST, 'nodeExecutions', (TType.STRUCT, [NodeExecutionInfo, None], False), None, ),  # 9
    (10, TType.LIST, 'terminalNodes', (TType.STRING, 'UTF8', False), None, ),  # 10
)
all_structs.append(WorkflowStatusRequest)
WorkflowStatusRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'workflowId', 'UTF8', None, ),  # 1
)
all_structs.append(NodeStatusRequest)
NodeStatusRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'nodeName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'start', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'end', 'UTF8', None, ),  # 3
)
all_structs.append(NodeStatusResponse)
NodeStatusResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'nodeExecutions', (TType.STRUCT, [NodeExecutionInfo, None], False), None, ),  # 1
)
all_structs.append(ConfStatusRequest)
ConfStatusRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'confName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'start', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'end', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'confHash', 'UTF8', None, ),  # 4
)
all_structs.append(ConfStatusResponse)
ConfStatusResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'nodeExecutions', (TType.STRUCT, [NodeExecutionInfo, None], False), None, ),  # 1
    (2, TType.LIST, 'terminalNodes', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(WorkflowResponse)
WorkflowResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'workflowId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'confName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'mode', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'branch', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'user', 'UTF8', None, ),  # 5
    (6, TType.I32, 'status', None, None, ),  # 6
    (7, TType.STRING, 'startPartition', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'endPartition', 'UTF8', None, ),  # 8
    None,  # 9
    (10, TType.LIST, 'terminalNodes', (TType.STRING, 'UTF8', False), None, ),  # 10
    (11, TType.I32, 'confType', None, None, ),  # 11
)
all_structs.append(WorkflowListRequest)
WorkflowListRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'limit', None, None, ),  # 1
    (2, TType.I32, 'numOfWorkflows', None, None, ),  # 2
)
all_structs.append(WorkflowListResponse)
WorkflowListResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'workflows', (TType.STRUCT, [WorkflowResponse, None], False), None, ),  # 1
)
all_structs.append(ConfListRequest)
ConfListRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'confType', None, None, ),  # 1
    (2, TType.STRING, 'branch', 'UTF8', None, ),  # 2
)
all_structs.append(ConfListItemResponse)
ConfListItemResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'confName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'confType', None, None, ),  # 2
    (3, TType.STRING, 'confHash', 'UTF8', None, ),  # 3
)
all_structs.append(ConfListResponse)
ConfListResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'confs', (TType.STRUCT, [ConfListItemResponse, None], False), None, ),  # 1
)
all_structs.append(ConfGetRequest)
ConfGetRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'confName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'confType', None, None, ),  # 2
)
all_structs.append(ConfGetResponse)
ConfGetResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'confName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'confHash', 'UTF8', None, ),  # 2
    (3, TType.I32, 'confType', None, None, ),  # 3
    (4, TType.STRUCT, 'confContents', [LogicalNode, None], None, ),  # 4
)
all_structs.append(BaseEvalResult)
BaseEvalResult.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'checkResult', None, None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
)
all_structs.append(JoinPartEvalResult)
JoinPartEvalResult.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'partName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'gbEvalResult', [GroupByEvalResult, None], None, ),  # 2
    (3, TType.STRUCT, 'keySchemaCheck', [BaseEvalResult, None], None, ),  # 3
)
all_structs.append(JoinEvalResult)
JoinEvalResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'leftExpressionCheck', [BaseEvalResult, None], None, ),  # 1
    (2, TType.STRUCT, 'leftTimestampCheck', [BaseEvalResult, None], None, ),  # 2
    (3, TType.LIST, 'joinPartChecks', (TType.STRUCT, [JoinPartEvalResult, None], False), None, ),  # 3
    (4, TType.STRUCT, 'derivationValidityCheck', [BaseEvalResult, None], None, ),  # 4
    (5, TType.MAP, 'leftQuerySchema', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 5
    (6, TType.MAP, 'rightPartsSchema', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.MAP, 'derivationsSchema', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 7
    (8, TType.MAP, 'externalPartsSchema', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 8
)
all_structs.append(GroupByEvalResult)
GroupByEvalResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'sourceExpressionCheck', [BaseEvalResult, None], None, ),  # 1
    (2, TType.STRUCT, 'sourceTimestampCheck', [BaseEvalResult, None], None, ),  # 2
    (3, TType.STRUCT, 'aggExpressionCheck', [BaseEvalResult, None], None, ),  # 3
    (4, TType.STRUCT, 'derivationsExpressionCheck', [BaseEvalResult, None], None, ),  # 4
    (5, TType.MAP, 'keySchema', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 5
    (6, TType.MAP, 'aggSchema', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.MAP, 'derivationsSchema', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 7
)
all_structs.append(StagingQueryEvalResult)
StagingQueryEvalResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'queryCheck', [BaseEvalResult, None], None, ),  # 1
    (2, TType.MAP, 'outputSchema', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
)
fix_spec(all_structs)
del all_structs
