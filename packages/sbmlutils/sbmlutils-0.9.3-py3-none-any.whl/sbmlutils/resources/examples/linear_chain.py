"""
Autogenerated ODE definition SBML file with sbmlutils (https://github.com/matthiaskoenig/sbmlutils).

    model: linear_chain

time: [-]
substance: [-]
extent: [-]
volume: [-]
area: [-]
length: [-]
"""

from typing import Any
import numpy as np
import pandas as pd


def piecewise(*kwargs: Any) -> Any:
    """Piecewise function.

    piecewise      | x1, y1, [x2, y2,] [...] [z] | A piecewise function: if (y1), x1.  Otherwise, if (y2), x2, etc.  Otherwise, z.
    """
    for k in np.floor(len(kwargs) / 2.0):
        if kwargs[k + 1]:
            return kwargs[k]
    if len(kwargs) % 2 == 1:
        return kwargs[-1]


# -------------------
# ids
# -------------------
xids = [
    "S1",
    "S10",
    "S11",
    "S12",
    "S13",
    "S14",
    "S15",
    "S16",
    "S17",
    "S18",
    "S19",
    "S2",
    "S20",
    "S21",
    "S3",
    "S4",
    "S5",
    "S6",
    "S7",
    "S8",
    "S9",
]
pids = [
    "cell",
    "k1",
    "k10",
    "k11",
    "k12",
    "k13",
    "k14",
    "k15",
    "k16",
    "k17",
    "k18",
    "k19",
    "k2",
    "k20",
    "k3",
    "k4",
    "k5",
    "k6",
    "k7",
    "k8",
    "k9",
]
yids = [
    "J1",
    "J10",
    "J11",
    "J12",
    "J13",
    "J14",
    "J15",
    "J16",
    "J17",
    "J18",
    "J19",
    "J2",
    "J20",
    "J3",
    "J4",
    "J5",
    "J6",
    "J7",
    "J8",
    "J9",
]

# -------------------
# initial conditions
# -------------------
x0 = np.array(
    [
        10.0,  # [0] S1 [-/-]  in cell
        0.0,  # [1] S10 [-/-] Species 10 in cell
        0.0,  # [2] S11 [-/-] Species 11 in cell
        0.0,  # [3] S12 [-/-] Species 12 in cell
        0.0,  # [4] S13 [-/-] Species 13 in cell
        0.0,  # [5] S14 [-/-] Species 14 in cell
        0.0,  # [6] S15 [-/-] Species 15 in cell
        0.0,  # [7] S16 [-/-] Species 16 in cell
        0.0,  # [8] S17 [-/-] Species 17 in cell
        0.0,  # [9] S18 [-/-] Species 18 in cell
        0.0,  # [10] S19 [-/-] Species 19 in cell
        0.0,  # [11] S2 [-/-] Species 2 in cell
        0.0,  # [12] S20 [-/-] Species 20 in cell
        0.0,  # [13] S21 [-/-] Species 21 in cell
        0.0,  # [14] S3 [-/-] Species 3 in cell
        0.0,  # [15] S4 [-/-] Species 4 in cell
        0.0,  # [16] S5 [-/-] Species 5 in cell
        0.0,  # [17] S6 [-/-] Species 6 in cell
        0.0,  # [18] S7 [-/-] Species 7 in cell
        0.0,  # [19] S8 [-/-] Species 8 in cell
        0.0,  # [20] S9 [-/-] Species 9 in cell
    ]
)

# -------------------
# parameters
# -------------------
p = np.array(
    [
        1.0,  # [0] cell [-]
        0.1,  # [1] k1 [-] rate constant 1
        0.1,  # [2] k10 [-] rate constant 10
        0.1,  # [3] k11 [-] rate constant 11
        0.1,  # [4] k12 [-] rate constant 12
        0.1,  # [5] k13 [-] rate constant 13
        0.1,  # [6] k14 [-] rate constant 14
        0.1,  # [7] k15 [-] rate constant 15
        0.1,  # [8] k16 [-] rate constant 16
        0.1,  # [9] k17 [-] rate constant 17
        0.1,  # [10] k18 [-] rate constant 18
        0.1,  # [11] k19 [-] rate constant 19
        0.1,  # [12] k2 [-] rate constant 2
        0.1,  # [13] k20 [-] rate constant 20
        0.1,  # [14] k3 [-] rate constant 3
        0.1,  # [15] k4 [-] rate constant 4
        0.1,  # [16] k5 [-] rate constant 5
        0.1,  # [17] k6 [-] rate constant 6
        0.1,  # [18] k7 [-] rate constant 7
        0.1,  # [19] k8 [-] rate constant 8
        0.1,  # [20] k9 [-] rate constant 9
    ]
)


def f_dxdt(x: np.ndarray, t: float, p: np.ndarray) -> np.ndarray:
    """ODE system."""
    J1 = p[1] * x[0]  # [0] J1 [-/-]
    J10 = p[2] * x[1]  # [1] J10 [-/-]
    J11 = p[3] * x[2]  # [2] J11 [-/-]
    J12 = p[4] * x[3]  # [3] J12 [-/-]
    J13 = p[5] * x[4]  # [4] J13 [-/-]
    J14 = p[6] * x[5]  # [5] J14 [-/-]
    J15 = p[7] * x[6]  # [6] J15 [-/-]
    J16 = p[8] * x[7]  # [7] J16 [-/-]
    J17 = p[9] * x[8]  # [8] J17 [-/-]
    J18 = p[10] * x[9]  # [9] J18 [-/-]
    J19 = p[11] * x[10]  # [10] J19 [-/-]
    J2 = p[12] * x[11]  # [11] J2 [-/-]
    J20 = p[13] * x[12]  # [12] J20 [-/-]
    J3 = p[14] * x[14]  # [13] J3 [-/-]
    J4 = p[15] * x[15]  # [14] J4 [-/-]
    J5 = p[16] * x[16]  # [15] J5 [-/-]
    J6 = p[17] * x[17]  # [16] J6 [-/-]
    J7 = p[18] * x[18]  # [17] J7 [-/-]
    J8 = p[19] * x[19]  # [18] J8 [-/-]
    J9 = p[20] * x[20]  # [19] J9 [-/-]

    # ode
    return np.ndarray(
        [
            -J1 / p[0],  # [0] S1 [-/-]
            J9 / p[0] - J10 / p[0],  # [1] S10 [-/-] Species 10
            J10 / p[0] - J11 / p[0],  # [2] S11 [-/-] Species 11
            J11 / p[0] - J12 / p[0],  # [3] S12 [-/-] Species 12
            J12 / p[0] - J13 / p[0],  # [4] S13 [-/-] Species 13
            J13 / p[0] - J14 / p[0],  # [5] S14 [-/-] Species 14
            J14 / p[0] - J15 / p[0],  # [6] S15 [-/-] Species 15
            J15 / p[0] - J16 / p[0],  # [7] S16 [-/-] Species 16
            J16 / p[0] - J17 / p[0],  # [8] S17 [-/-] Species 17
            J17 / p[0] - J18 / p[0],  # [9] S18 [-/-] Species 18
            J18 / p[0] - J19 / p[0],  # [10] S19 [-/-] Species 19
            J1 / p[0] - J2 / p[0],  # [11] S2 [-/-] Species 2
            J19 / p[0] - J20 / p[0],  # [12] S20 [-/-] Species 20
            J20 / p[0],  # [13] S21 [-/-] Species 21
            J2 / p[0] - J3 / p[0],  # [14] S3 [-/-] Species 3
            J3 / p[0] - J4 / p[0],  # [15] S4 [-/-] Species 4
            J4 / p[0] - J5 / p[0],  # [16] S5 [-/-] Species 5
            J5 / p[0] - J6 / p[0],  # [17] S6 [-/-] Species 6
            J6 / p[0] - J7 / p[0],  # [18] S7 [-/-] Species 7
            J7 / p[0] - J8 / p[0],  # [19] S8 [-/-] Species 8
            J8 / p[0] - J9 / p[0],  # [20] S9 [-/-] Species 9
        ]
    )


def f_y(x: np.ndarray, t: float, p: np.ndarray) -> np.ndarray:
    """Calculate y.

    :param x: state vector
    :param t: time
    :param p: parameter vector
    :return:
    """

    J1 = p[1] * x[0]  # [0] J1  [-/-]
    J10 = p[2] * x[1]  # [1] J10  [-/-]
    J11 = p[3] * x[2]  # [2] J11  [-/-]
    J12 = p[4] * x[3]  # [3] J12  [-/-]
    J13 = p[5] * x[4]  # [4] J13  [-/-]
    J14 = p[6] * x[5]  # [5] J14  [-/-]
    J15 = p[7] * x[6]  # [6] J15  [-/-]
    J16 = p[8] * x[7]  # [7] J16  [-/-]
    J17 = p[9] * x[8]  # [8] J17  [-/-]
    J18 = p[10] * x[9]  # [9] J18  [-/-]
    J19 = p[11] * x[10]  # [10] J19  [-/-]
    J2 = p[12] * x[11]  # [11] J2  [-/-]
    J20 = p[13] * x[12]  # [12] J20  [-/-]
    J3 = p[14] * x[14]  # [13] J3  [-/-]
    J4 = p[15] * x[15]  # [14] J4  [-/-]
    J5 = p[16] * x[16]  # [15] J5  [-/-]
    J6 = p[17] * x[17]  # [16] J6  [-/-]
    J7 = p[18] * x[18]  # [17] J7  [-/-]
    J8 = p[19] * x[19]  # [18] J8  [-/-]
    J9 = p[20] * x[20]  # [19] J9  [-/-]

    # --------------------------------------

    y = np.empty(shape=(20))
    y[0] = J1  # [0] J1  [-/-]
    y[1] = J10  # [1] J10  [-/-]
    y[2] = J11  # [2] J11  [-/-]
    y[3] = J12  # [3] J12  [-/-]
    y[4] = J13  # [4] J13  [-/-]
    y[5] = J14  # [5] J14  [-/-]
    y[6] = J15  # [6] J15  [-/-]
    y[7] = J16  # [7] J16  [-/-]
    y[8] = J17  # [8] J17  [-/-]
    y[9] = J18  # [9] J18  [-/-]
    y[10] = J19  # [10] J19  [-/-]
    y[11] = J2  # [11] J2  [-/-]
    y[12] = J20  # [12] J20  [-/-]
    y[13] = J3  # [13] J3  [-/-]
    y[14] = J4  # [14] J4  [-/-]
    y[15] = J5  # [15] J5  [-/-]
    y[16] = J6  # [16] J6  [-/-]
    y[17] = J7  # [17] J7  [-/-]
    y[18] = J8  # [18] J8  [-/-]
    y[19] = J9  # [19] J9  [-/-]

    return y


def f_z(X: np.ndarray, T: np.ndarray, p: np.ndarray) -> np.ndarray:
    """DataFrame of full timecourse of solution."""
    (Nt, Nx) = X.shape
    Ny = len(yids)
    Nz = 1 + Nx + Ny
    columns = ["time"] + xids + yids
    Z = np.empty(shape=(Nt, Nz))
    Z[:, 0] = T
    Z[:, 1 : (Nx + 1)] = X
    for kt in range(Nt):
        y = f_y(x=X[kt, :], t=T[kt], p=p)
        Z[kt, (Nx + 1) :] = y

    Z = pd.DataFrame(Z, columns=columns)
    return Z
