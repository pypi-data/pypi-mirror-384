{
	"inherit_from":["final_master_dbx_sql_scripting.json"],
	"target_sql" : "DATABRICKSQL",
	"target_capabilities" : {"loops":"0"},
	"from_after_delete" : "1",

	"target_file_extension" : "sql",

	"preprocess_subst" : [ // get rid of elements that are not needed, before normal file processing starts, multi line matching
		{"from" : "\.BEGIN\s+IMPORT\s+MLOAD.*\.END\s+MLOAD;", "to" : "__MLOAD_PLACEHOLDER__"} // implement a hook to convert this using $MLOAD->{MLOAD_INFO} structure.
	],

	//"script_header" : "-- Databricks notebook source\n\nUSE CATALOG main;\n\n-- COMMAND ----------\n",

	//"prescan_and_collect_info_hook" : "::prescan_code_bteq", //capture env variables, mload commands.  This instruction fires off before "initialize_hooks_call"
	//"initialize_hooks_call" : "::init_hooks", //initialize context, pass all relevant info

	"extract_embedded_sql" : ["sh","ksh","ssh"], //listing extensions of files from which to extract embedded sql.  Use "embedded_sql_tags" key to list STRINGs depicting the start of sql
	//examples:
	//"embedded_sql_tags" : ["$RUN_SQL", "$RUN_INLINE_SQL", "$RUN_DDL", "bteq"],
	//"embedded_sql_file_ref" : ["$RUN_SQL -f"] //references a sql file

	//"target_sql_filename_prefix": "sn_",
	//"target_sql_file_header": "--/********* File converted at %CONVERTER_TIMESTAMP% *********/\n!set timing=true\n!set variable_substitution=true",
	//"target_sql_file_header": "!set variable_substitution=true",
	"code_fragment_breakers": {
		"one_liner_start": ["^\s*\.OS"],
		"line_start": ["\s*\.[a-zA-Z]"], //BTEQ's dot commands
		"line_end": ["\;"]
	},
	"statement_end" : ";",
	//apply substitutions when lines that begin with these tokens
	"line_begin_with_subst" : [
		{"from" : "set heading off.*", "to" : "!set header=false"},
		{"from" : "set heading on", "to" : "!set header=true"},
		{"from" : "DEFINE", "to" : "!DEFINE"},
		{"from" :"@", "to" : "!source "}
		//{"from" : "WHENEVER SQLERROR EXIT SQL.SQLCODE", "to" : "!set exit_on_error=true"}
	],

	"line_subst" : [
		{"from" : "#(\w+)#", "to" : "${$1}", "upcase_STRING" : true},
		{"from" : "POSITION\s*(\(.*?)\bIN\b", "to" : "POSITION$1,"},
		{"from" : "\bSTRING\s+NOT\s+CASESPECIFIC\b", "to" : "STRING COLLATE UTF8_LCASE"},
		//{"from" : "\bvarchar\s*\([0-9]+\)", "to" : "STRING"},
		{"from" : "\bchar\s*\([0-9]+\)", "to" : "STRING"},
		{"from" : "\bTIMESTAMP\s*\([0-9]+\)", "to" : "TIMESTAMP"},
		{"from" : "\bTIMESTAMP\s+WITH\s+TIME\s+ZONE\b", "to" : "TIMESTAMP"},
		{"from" : "\btime\b", "to" : "TIMESTAMP"},
		{"from" : "__MLOAD_PLACEHOLDER__", "extension_call" : "::synapse_load_file"}, //special handler for MLOAD

		{"from" : "\bnchar\b", "to" : "STRING"},
		{"from" : "\bSTRING\s*\([0-9]+\)", "to" : "STRING"},
		{"from" : "\bDATE\b", "to" : "CURRENT_DATE", "statement_categories": ["TABLE_DDL_AS_SELECT"]},
		{"from" : "CURRENT_DATE(?!\()", "to" : "CURRENT_DATE()"},
		{"from" : "^\s*DATABASE\s*(\S+);", "to" : "USE SCHEMA $1;"},
		{"from" : "\bSEL\b", "to" : "SELECT"}, //abbreviation for SELECT
		{"from" : "\bDEL\b \bFROM\b", "to" : "DELETE FROM"}, //abbreviation for DELETE
		{"from" : "\bDEL\b", "to" : "DELETE FROM"}, //abbreviation for DELETE
		{"from" : "\bINS\b", "to" : "INSERT INTO"}, //abbreviation for INSERT,
		{"from" : "\bDROP\b\s+\bTEMPORARY\b", "to" : "DROP"},

		{"from" : "\bdatetime\b", "to" : "DATE"},
		{"from": "LOCK\s+TABLE\s+.*", "to": ""},
		{"from" : "\(\s+NAMED\s(\w+)\s+\)", "to" : ""},
		{"from" : "\.os\s(.*)", "to" : "!SYSTEM $1"},
		//{"from" : "\s*DBMS_OUTPUT.PUT_LINE\((.*)\)\;", "to" : "SELECT $1;"},
		{"from" : "CREATE(.*?)VOLATILE TABLE", "to": "CREATE TEMPORARY VIEW"},
		{"from" : "ON COMMIT PRESERVE ROWS", "to" : ""},
		{"from" : "SET QUERY_BAND.*", "to":""},
		{"from" : "CREATE(\s+?)MULTISET(\s+?)TABLE", "to": "CREATE TABLE"}, //no create or replace in Hive
		//{"from" : "CREATE SET TABLE", "to" : "CREATE TABLE IF NOT EXISTS"},
		{"from" : "CREATE SET TABLE", "to" : "CREATE TABLE"},
//		{"from" : "CREATE(\s+?)TABLE", "to": "CREATE OR REPLACE TABLE"},
		{"from" : ",(.*?)NO FALLBACK", "to": ""},
		{"from" : "(.*?)NO FALLBACK", "to": ""},
		{"from" : ",(.*?)FALLBACK\s*,", "to": ""},
		{"from" : ",(.*?)FALLBACK", "to": ""},
		{"from" : "NO BEFORE JOURNAL\s*\,*\s*", "to": ""},
		{"from" : "NO AFTER JOURNAL\s*\,*\s*", "to": ""},
		{"from" : "NO BEFORE JOURNAL", "to": ""},
		{"from" : "NO AFTER JOURNAL", "to": ""},
		{"from" : "MAP\s*=\s*(\w+)", "to" : ""},
		{"from" : "CHECKSUM\s*=\s*DEFAULT\s*(,|)", "to": ""},
		{"from" : ",(.*?)NO LOG", "to": ""},
		{"from" : ",(.*?)CHECKSUM = DEFAULT,", "to": ""},
		{"from" : ",(.*?)CHECKSUM = DEFAULT", "to": ""},
		{"from" : "CREATE JOIN INDEX", "to": "CREATE TEMPORARY TABLE"},
		{"from" : "^(\s*?)REPLACE(\s+?)VIEW", "to": "CREATE OR REPLACE VIEW"},
		{"from" : "^(\s*?)CREATE VIEW", "to": "CREATE OR REPLACE VIEW"},
		{"from" : "\sBLOB", "to" : " BINARY"},
		{"from" : "\sVARBINARY", "to" : " BINARY"},
		{"from" : "\sBYTE\b", "to" : " BINARY"},
		{"from" : "SAMPLE", "to" : "LIMIT"},

		{"from" : "LOCKING(.+?)FOR\s+ACCESS\s+MODE", "to": ""},
		{"from" : "LOCKING(.+?)FOR ACCESS", "to": ""},
		{"from" : "LOCK ROW FOR ACCESS", "to": ""},
		{"from" : "FREESPACE = 0 PERCENT,", "to": ""},
		{"from" : "END TRANSACTION;", "to": "COMMIT;"},
		{"from" : "current_date - ([0-9]+)", "to": "dateadd('DAY',-$1,current_date)"},
		{"from" : "(\w+\.\w+?DT) - ([0-9]+)", "to": "dateadd('DAY',-$2,$1)"},
		{"from" : "(\w+\.\w+?DT) + ([0-9]+)", "to": "dateadd('DAY',$2,$1)"},

		{"from" : "VARBYTE", "to" : "VARBINARY"},
		{"from" : "EXCEPT ALL", "to" : "MINUS"},


		{"from" : "EXTRACT\(DAY FROM", "to" : "DAY("},
		{"from" : "EXTRACT\(HOUR FROM", "to" : "HOUR("},
		{"from" : "EXTRACT\(MINUTE FROM", "to" : "MINUTE("},

		{"from" : "CREATE TABLE ([$|\S]+?) AS ([$|\S]+?) WITH NO DATA", "to" : "CREATE TABLE $1 LIKE $2"},
		{"from" : "\'([0-9][0-9])\'XC", "to" : "TRY_HEX_DECODE_STRING($1)"},
		{"from" : "CHARACTER SET LATIN NOT CASESPECIFIC", "to" : ""}, //no collation feature
		{"from" : "CHARACTER SET LATIN NOT CS", "to" : ""},
		{"from" : "CHARACTER(\s+)SET LATIN", "to" : ""},
		{"from" : " NOT CS ", "to" : " "},
		{"from" : " NOT CS$", "to" : " "},
		{"from" : " CS ", "to" : " "},
		{"from" : " CS,", "to" : ","},
		{"from" : " CS$", "to" : " "},
		{"from" : "WITH\s+DATA", "to" : ""},
		{"from" : "COLLECT STATISTICS.*;", "to" : ""},
		{"from" : "COLLECT STATS.*;", "to" : ""},
		{"from" : "COLLECT STATS.*", "to" : ""},
		{"from" : "update command options using c off\s;", "to" : ""},
		{"from" : "NOT NULL WITH DEFAULT", "to" : ""},
		{"from" : "CHARACTER SET UNICODE NOT CASESPECIFIC", "to" : ""},
		{"from" : "\(NOT CASESPECIFIC\)", "to" : ""},
		//{"from" : "NOT CASESPECIFIC", "to" : ""},
		//{"from" : "\(CASESPECIFIC\)", "to" : ""},
		//{"from" : "\sCASESPECIFIC", "to" : ""},
		{"from" : "CHARACTER SET UNICODE", "to" : ""},
		{"from" : "USING UNICODE_TO_LATIN", "to" : ""},

		//{"from" : "__EXPRESSION__\s(FORMAT '(9+)')", "to" : "LPAD(__EXPRESSION__,__LENGTH__,'0')"

		//{"from" : "TRIM\((\S+) \(FORMAT'9999999999'\)\)","to": "TRIM(LPAD($1,10,'0'))"},
		//{"from" : "CAST\((\w+) AS FORMAT 'HH:MI:SS'\)", "to" : "TO_CHAR($1,'HH:MI:SS')"},
		{"from" : "CAST\(\((\w*\.*\w*)\s*\(FORMAT'HHMISS'\)\)\s+(AS|as)\s+(STRING|STRING)\)", "to" : "DATE_FORMAT($1, 'HHmmss')"},
		//{"from" : "CAST\((\w+) AS FORMAT 'YYYY-MM-DD'\)", "to" : "TO_CHAR($1,'YYYY-MM-DD')"},
		{"from" : "([\w.]+)\s*\(\s*FORMAT '99999'\s*\)", "to" : "LPAD($1,5,'0')"},
		{"from" : "CAST\s*\(\s*\(\s*([\w.]+)\s*\(\s*FORMAT\s+'YYYY-MM-DD'\s*\)\s*\)\s*AS\s+CHAR\s*\(\s*10\s*\)\s*\)", "to" : "TO_CHAR($1,'YYYY-MM-DD')"},

		{"from" : "LOGGING ALL ERRORS WITH NO LIMIT", "to" : ""},
		{"from" : "NO\s+PRIMARY\s+INDEX", "to" : ""},

		//{"from" : "\(DATE, FORMAT 'MM\/DD\/YYYY'\)", "to" : ""},
		//{"from" : "\(FORMAT 'Z\(([0-9]+)\)'\)", "to" : ""},
		//{"from" : "DATE FORMAT 'YY/MM/DD'", "to" : "DATE"},
		//{"from" : "FORMAT '99999'", "to" : "INT"},
		//{"from" : "DATE(\s*?)FORMAT 'YYYY-MM-DD'", "to" : "DATE"},
		//{"from" : "DATE(\s*?)FORMAT '(.+?)'", "to" : "DATE"},
		//{"from" : "TIMESTAMP\(6\)(\s*?)FORMAT '(.+?)'", "to" : "TIMESTAMP(6)"},
		//{"from" : "DATE FORMAT 'MM/DD/YYYY'", "to" : "DATE"},
		//{"from" : "FORMAT 'ZZ9.99'", "to" : "VARCHAR(6)"},
		//{"from" : "FORMAT 'YY/MM/DD' NOT NULL", "to" : ""},
		{"from" : "MAXIMUM ", "to" : "MAX "},
		{"from" : "MAXIMUM\(", "to" : "MAX("},
		{"from" : "\(NOT CS\)", "to" : ""},
		{"from" : "\(CS\)", "to" : ""},
		//{"from" : "TRANSLATE\((.*?)\)", "to" : "$1"},
		//{"from" : "\(FORMAT '9\(2\)'\)", "to" : ""},
		{"from" : "CHARACTER_LENGTH", "to" : "LENGTH"},

		{"from" : "AS FORMAT 'YYYY-MM-DD'", "to": " AS DATE"},
		{"from" : "AS FORMAT 'HH:MI:SS'", "to": " AS TIMESTAMP(6)"},
		{"from" : "FROM ([0-9]+) FOR ([0-9])", "to" : ", $1, $2"}, //used in SUBSTRING function
		{"from" : "FROM(\s+)([0-9]+)(\s+)FOR(\s+)([0-9])", "to" : ", $2, $5"}, //used in SUBSTRING function
		{"from" : "FROM ([0-9]+)\)", "to" : ", $1)"}, //used in SUBSTRING function without 3rd arg



		{"from" : "TRIM\(LEADING'", "to" : "TRIM(LEADING '"},
		{"from" : "TRIM\(TRAILING'", "to" : "TRIM(TRAILING '"},
		{"from" : "TRIM\(LEADING ", "to" : "TRIM_LEADING("},
		{"from" : "TRIM\(TRAILING ", "to" : "TRIM_TRAILING("},



		{"from" : "OREPLACE", "to" : "REPLACE"},
		{"from" : "OTRANSLATE", "to" : "REPLACE"},

		{"from" : "'\$           0'", "to":"'$'"},
		//{"from" : "\((.+) MOD (\w*)\)", "to":"MOD ( $1, $2 )"},
		{"from" : " MOD ", "to":" % "},

		{"from" : "DEFAULT(\s+)MERGEBLOCKRATIO", "to" : "$1"},
		{"from" : "DEFAULT DATE", "to" : "DEFAULT CURRENT_DATE"},
		//{"from" : "PARTITION(\s+)BY(\s+)CASE_N", "to" : "PARTITION_BY_CASE_N"},
		{"from" : "PARTITION BY RANGE_N", "to" : "PARTITION_BY_RANGE_N"},
		{"from" : "PARTITION\s+BY", "to" : "PARTITION_BY", "statement_categories": ["TABLE_DDL"]},
		{"from" : "CONSTRAINT\s(.*)CHECK\s", "to" : ",CONSTRAINT_CHECK ", "statement_categories": ["TABLE_DDL"]},
		{"from" : "\sCHECK\s", "to" : " CONSTRAINT_CHECK ", "statement_categories": ["TABLE_DDL"]},
		{"from" : ",CHECK\s", "to" : ",CONSTRAINT_CHECK ", "statement_categories": ["TABLE_DDL"]},
		{"from" : "FOREIGN KEY", "to" : "FOREIGN_KEY", "statement_categories": ["TABLE_DDL"]},
		{"from" : "ORDER BY VALUES", "to" : "ORDER_BY_VALUES", "statement_categories": ["TABLE_DDL"]},
		{"from" : "REFERENCES(\s*)(.*)(\s*)\(", "to" : "REFERENCES(", "statement_categories": ["TABLE_DDL"]},

		{"from" : "EFF_PERIOD\s*PERIOD\(DATE\)\s*FORMAT 'YY\/MM\/DD' AS VALIDTIME", "to" : "EFF_BEGIN_DT DATE, EFF_END_DT DATE"},

		{"from" : "EFF_PERIOD\s*PERIOD\(DATE\)\s*AS VALIDTIME", "to" : "EFF_BEGIN_DT DATE, EFF_END_DT DATE"},
		{"from" : "VALID_DT\s*PERIOD\(DATE\)\s*AS VALIDTIME", "to" : "VALID_BEGIN_DT DATE, VALID_END_DT DATE"},

		{"from" : "AU_TS_PERIOD\s*PERIOD\(TIMESTAMP\(0\)\) NOT NULL AS VALIDTIME", "to" : "AU_BEGIN_TS TIMESTAMP(0), AU_END_TS TIMESTAMP(0)"},
		{"from" : "EFFTS_PERIOD\s*PERIOD\s*\(TIMESTAMP\(6\)\) WITH TIME ZONE\) NOT NULL AS VALIDTIME", "to" : "EFFTS_BEGIN_TS TIMESTAMP(6), EFFT_END_TS TIMESTAMP(6)"},

		{"from" : "PERIOD\(TIMESTAMP\(0\)\) NOT NULL AS VALIDTIME", "to" : "TIMESTAMP(0) default current_TIMESTAMP"},
		{"from" : "PERIOD\(DATE\)(\s+)AS VALIDTIME", "to" : "TIMESTAMP(0)"},
		{"from" : "PERIOD\(DATE\) FORMAT 'YY\/MM\/DD' AS VALIDTIME", "to" : "TIMESTAMP(0)"},
		{"from" : "PERIOD\(TIMESTAMP\(6\) WITH TIME ZONE\) NOT NULL AS TRANSACTIONTIME", "to" : "TIMESTAMP(6) default current_TIMESTAMP"},
		//{"from" : "CURRENT_TIMESTAMP", "to" : "CAST(CURRENT_TIMESTAMP as TIMESTAMP_NTZ)"},
		{"from" : "current_TIMESTAMP at 'america eastern'", "to" : "CURRENT_TIMESTAMP"},
		{"from" : "current_TIMESTAMP\([0-9]\)", "to" : "current_TIMESTAMP()"},

		{"from" : "PERIOD\(DATE\)", "to" : "DATE"},

		//date arithmetic
		{"from" : "DAY\(4\) TO MINUTE", "to" : ""},


		{"from" : " UPPERCASE ", "to": ""},
		{"from" : "NONSEQUENCED VALIDTIME", "to" : ""},
		{"from" : "COMPRESS '(.+)'","to": ""},
		{"from" : "COMPRESS\s*\(", "to" : "COMPRESS_SUPPRESS("},
		{"from" : "COMPRESS 'SAN'","to": ""},
		{"from" : "COMPRESS 1737","to": ""},
		{"from" : "COMPRESS 888", "to": ""},
		{"from" : "COMPRESS 'N'", "to": ""},
		{"from" : "COMPRESS 'M'", "to": ""},
		{"from" : "COMPRESS ,","to": ","},
		{"from" : "COMPRESS '6'","to": ""},
		{"from" : "COMPRESS 'P'","to": ""},
		{"from" : "COMPRESS 1 ,","to": ","},
		{"from" : "COMPRESS 0 ,","to": ","},
		{"from" : "COMPRESS 0,","to": ","},
		{"from" : "COMPRESS 0(\s+)$","to": ""},
		{"from" : "COMPRESS .0000","to": ""},
		{"from" : "COMPRESS \.00","to": ""},
		{"from" : "COMPRESS -1(\s*),(\s*)$","to": ","},
		{"from" : "COMPRESS ([[0-9].]+)(\s*),", "to": ","},
		{"from" : "COMPRESS ([0-9]+)\.([0-9]+)(\s*)", "to": ""},
		{"from" : "COMPRESS 0\b","to": ""},
		{"from" : "COMPRESS(\s+)0(\s+),", "to": ",", "statement_categories": ["TABLE_DDL"] },
		{"from" : "COMPRESS(\s+)0$", "to": "", "statement_categories": ["TABLE_DDL"] },
		{"from" : "COMPRESS ' ',", "to": ",", "statement_categories": ["TABLE_DDL"] },
		{"from" : "COMPRESS(\s*),", "to": ",", "statement_categories": ["TABLE_DDL"] },
		{"from" : "COMPRESS(\s*)\)", "to": ")", "statement_categories": ["TABLE_DDL"] },
		{"from" : "COMPRESS\s*'\s*?',", "to": "", "statement_categories": ["TABLE_DDL"] },
		{"from" : " COMPRESS$", "to": "", "statement_categories": ["TABLE_DDL"] },
		{"from" : "DATE\s+FORMAT\s+'YY\/MM\/DD'", "to" : "DATE",  "statement_categories": ["TABLE_DDL"] },
		{"from" : "DATE\s+FORMAT\s+'YYYY-MM-DD'", "to" : "DATE",  "statement_categories": ["TABLE_DDL"] },
		{"from" : "\bformat\s*'(.*?)'", "to" : "",  "statement_categories": ["TABLE_DDL"] },
		{"from" : "UNIQUE PRIMARY INDEX\s+(\w*)\s*\(", "to" : "UPI ($1, "},
		{"from" : "PRIMARY INDEX", "to": "PRIM_IDX"},
		{"from" : "CREATE UNIQUE INDEX .*\((.*?)\).*;", "to": ""},
		{"from" : "CREATE INDEX \((.*?)\).*;", "to": ""},
		{"from" : "UNIQUE\s+INDEX", "to": "UNK_IDX"},
		{"from" : "INDEX\s+(\w+)\s*\(", "to" : "INDEX ($1, "},

		//{"from" : "\bINDEX\b\(", "to": "CREATE_INDEX("},


		{"from" : "INTERVAL '([0-9]+)' DAY", "to": "$1"},
		{"from" : "INTERVAL\s+'([0-9.]+)'\s+SECOND", "to": "INTERVAL '$1 SECOND'"},

		//casting
		{"from" : "\( ([0-9]+)\)", "to": "($1)"},
		{"from" : "\(VARCHAR\(([0-9]+)\)\)", "to" : "::VARCHAR($1)"},
		{"from" : "\(CHAR\(([0-9]+)\)\)", "to" : "::CHAR($1)"},
		{"from" : "\((\s*)SMALLINT(\s*)\)", "to" : "::SMALLINT"},
		{"from" : "\(INTEGER\)", "to" : "::INTEGER"},
		{"from" : "\s*\(\s*DATE\s*\)", "to" : "::DATE"},
		{"from" : "\(DECIMAL\(([[0-9]|,]+)\)\)", "to" : "::DECIMAL($1)"},

		{"from" : "\(BYTEINT\)", "to" : ""},
		{"from" : "AS BYTEINT", "to" : "AS TINYINT"},
		{"from" : "BYTEINT", "to" : "TINYINT"},

		//************ constraints ************.  example:

		{"from" : "IN .*", "to" : "", "statement_categories": ["TABLE_DDL_LIKE"]},

		//************ Comments ************
		{"from" : "COMMENT ON ([\s|&\w]+).([\s|&\w]+) '(.*)'", "to" : "COMMENT ON__PARSED__TABLE $1.$2 IS '$3'"},
		{"from" : "COMMENT ON ([\s|\$\w]+).([\s|\$\w]+) '(.*)'", "to" : "COMMENT ON__PARSED__TABLE $1.$2 IS '$3'"},
		{"from" : "COMMENT ON ([\s|&\w]+).([\s|&\w]+).([\s|&\w]+) '(.*)'", "to" : "COMMENT ON COLUMN $1.$2.$3 IS '$4'"},
		{"from" : "__PARSED__", "to" : " "},

		{"from" : "DELETE\s+FROM\s+(.*) ALL\b", "to" : "TRUNCATE TABLE $1"},

		{"from" : "SYSLIB\.ISO8601_TO_DT", "to" : "TRY_TO_DATE"},
		{"from" : "SYSLIB\.ISO8601_TO_TS", "to" : "TRY_TO_TIMESTAMP"},
		{"from" : "REPLACE_CHARS", "to" : "REPLACE"},
		{"from" : "CHAR_LENGTH", "to" : "LENGTH"},

		{"from" : "FLOAT\s+\.\S+ [0-9]+\b", "to" : "FLOAT", "statement_categories": ["TABLE_DDL"]},

		{"from" : "\bSEPARATOR\s*\'(.*?)\'", "to" : ", $1"},
		{"from" : "\bTEMPORAL_TIMESTAMP\b", "to" : "current_timestamp()"},
		//DBC objects, database catalog STRINGs
		
		{"from" : "\bDBC\.TABLES\b", "to" : "INFORMATION_SCHEMA.TABLES"},
		{"from" : "\bDBC\.COLUMNS\b", "to" : "INFORMATION_SCHEMA.COLUMNS"},
		{"from" : "\bdatabasename\b", "to" : "TABLE_CATALOG"},
		{"from" : "\btablename\b", "to" : "TABLE_NAME"},
		{"from" : "\bCHAR__OPEN_PARENTHESIS__[0-9]+__CLOSE_PARENTHESIS__", "to" : "STRING", "statement_categories" : ["TABLE_DDL"]},
		{"from" : "\bDATE\s+FORMAT.*?\,", "to" : "DATE,"}
	],
	"suppress_lines_starting_with": ["WHENEVER","ALTER SESSION","NOLOGGING","NOMONITORING","PARALLEL", "EXECUTE DBMS_OUTPUT.ENABLE",
		//"\.IF", "\.LABEL", // keep these in, we will implement python
		".\QUIT", "\.EXPORT", "\.LOGOFF"
		],
	"suppress_lines_containing": ["LOGMECH"],
	"line_suppression_behavior":"COMMENT", //choices: COMMENT or ELIMINATE
	
	"block_subst" : [
		{"from" : "\bupdate\b.*\bwhere\b\s+\w*\.*\w+\s+IN\b.*\bIN\b.*\;", "extension_call" : "$self->nested_update_to_merge"},
		{"from" : "(UPDATE\s+.*?\bSET\s+.*?(?!FROM).*?WHERE\s+.*?;)", "extension_call" : "$self->update_without_from_to_merge"},
		{"from" : "^UPDATE\b.*\bSET\b.*\bFROM\b", "extension_call" : "$self->convert_update_to_merge"},
		{"from" : "\bUPDATE\s+\$*\{*\w*\.*\w+\}*\s+FROM\b", "extension_call" : "$self->convert_update_to_merge"},
		{"from" : "U_P_D_A_T_E", "to" : "UPDATE"},
		{"from" : "update\s+(\w+)\s+from\s+(\s*\$*\{*\w+\}*\.\w+\s+\w+)\s*,\s*\(\s*(select.*?)\)\s*(\w+)\s*\(.*?\)\s*SET\s+(.*?)\bwhere\b(.*);" , "to" : "MERGE INTO $2\nUSING ($3) $4\nON $6\nWHEN MATCHED THEN UPDATE \nSET $5;"},
		{"from" : "update\s+(\w+)\s+from\s+(\s*\$*\{*\w+\}*\.\w+\s+as\s+\w+)\s*,\s*\(\s*(select.*?)\)\s*(\w+)\s*SET\s+(.*?)\bwhere\b(.*);" , "to" : "MERGE INTO $2\nUSING ($3) $4\nON $6\nWHEN MATCHED THEN UPDATE \nSET $5;"},
		{"from" : "update\s+(\w+)\s+from\s+(\s*\$*\{*\w+\}*\.\w+\s+as\s+\w+)\s*,\s*\(\s*(select.*)\)\s*(\w+)\s*\(.*?\)\s*SET\s+(.*?)\bwhere\b(.*);" , "to" : "MERGE INTO $2\nUSING ($3) $4\nON $6\nWHEN MATCHED THEN UPDATE \nSET $5;"},
		{"from" : "update\s+(\w+)\s+from\s+(\s*\$*\{*\w+\}*\.\w+\s+as\s+\w+)\s*,\s*\(\s*(select.*?)\)\s*\bas\s+(\w+)\s*\(.*?\)\s*SET\s+(.*?)\bwhere\b(.*);" , "to" : "MERGE INTO $2\nUSING ($3) $4\nON $6\nWHEN MATCHED THEN UPDATE \nSET $5;"},
		{"from" : "update\s+(\w+)\s+from\s+(\s*\$*\{*\w+\}*\.\w+\s+as\s+\w+)\s*\,\s*\((.*)\b(select.*)\)\s*(\w+)\s*\(.*?\)\s*\bset(\b.*?)where(.*)\;", "to" : "MERGE INTO $2\nUSING ($3$4) $5\nON $7\nWHEN MATCHED THEN UPDATE \nSET $6;"},
		{"from" : "\s*\)\s*UPI\b", "to": ",\nUPI"},
		{"from" : "CREATE\s+TABLE\s+(\S+)\W*\(", "to" : "CREATE TABLE_NO_SPACES $1\n(", "statement_categories1" : ["TABLE_DDL"]},
		{"from" : "CREATE TABLE_NO_SPACES", "to" : "CREATE TABLE"},
		{"from" : "DATABLOCKSIZE(.*?)BYTES\s*(,\s*|)","to" : ""},
		{"from" : "__EXPRESSION__\s(FORMAT '(9+)')", "to" : "LPAD(__EXPRESSION__,__LENGTH__,'0')"},
		{"from" : "\)\s*WITH NO DATA", "to" : " WHERE 1=2)"},
		{"from" : "\(\s*TITLE\s+'\w+'\s*\)", "to" : ""}, //blank out TITLE spec
		{"from" : "TITLE\s*'.*?'", "to" : "", "statement_categories": ["TABLE_DDL"]},
		//{"from": "^\s*UPDATE(.*?)FROM(.*;)", "parse_method":"convert_update_to_merge", "statement_categories": ["WRITE_DML"]},
		{"from" : "\)__GAMMA_NL__\s*WITH NO DATA", "to" : " WHERE 1=2)"}, //use __GAMMA_NL__ for newline pattern
		{"from" : "CREATE INDEX \((.*?)\).*;", "to": "", "statement_categories": ["CREATE_INDEX"] },
		{"from" : "VALIDTIME .*\(SELECT.*\)(.*?)(SELECT?)", "to" : "SELECT"},
		{"from" : "__EXPRESSION__\s\(FORMAT\s*'9\(18\)'\)", "to" : "LPAD(__EXPRESSION__,18,'0')"},
		{"from" : "__EXPRESSION__\s\(FORMAT\s*'999999'\)", "to" : "LPAD(__EXPRESSION__,6,'0')"},
		{"from" : "__EXPRESSION__\s\(FORMAT\s*'9\(2\)'\s*\)", "to" : "LPAD(__EXPRESSION__,2,'0')"},
		{"from" : "PRIM_IDX\s+\S+\s*\(.+?\)", "to": "", "statement_categories": ["TABLE_DDL"]}, //get rid of named primary index

		{"from": "\bCOLLECT\s+STATISTICS\b.*?\;", "to": ""},

		{"from" : "(DELETE.*?FROM\s+([\w\{\}\.\$]+)\s*(?-1)?\s*)\,(\s*(?-2)\s*(?-2)?;)", "to": "$1 USING $3"},
		//{"from" : "(DELETE\s*FROM)\s*(.*?)\,\s*(.*)\s*(.*\s*.*\s*.*\s*\;)", "to" : "$1 $2 USING $3 $4", "first_match" : "1" },
		{"from" : "^(\s*)(SELECT\s+COUNT\(\*\).*)", "to": "$1set ret = get_rowcount_from_snowsql << EO_STMT\n$2\nEO_STMT\nif ret == 0\n\texit 0\nfi", "relative_fragment_offset" : "1,2", "relative_fragment_pattern" : "ACTIVITYCOUNT = 0"},

		{"from" : "(.*)\s*\)\s*;\s*", "to" : "$1)\nTBLPROPERTIES('delta.feature.allowColumnDefaults' = 'supported');\n", "statement_categories": ["TABLE_DDL"], "first_match" : "1"},

		{"from" : "\<\s*ANY\b", "to" : "__LESS_ANY__"},
		{"from" : "\<\s*\=\s*ANY\b", "to" : "__LESS_EQUAL_ANY__"},
		{"from" : "\>\s*ANY\b", "to" : "__GREAT_ANY__"},
		{"from" : "\>\s*\=\s*ANY\b", "to" : "__GREAT_EQUAL_ANY__"},
		{"from" : "dummy line", "to" : "some dummy line"}
	],

	"datepart_translations" : { // case sensitive! will be processed lengthier pattern first (yyyy goes before DD)
		"\bSYYY\b" : "YEAR",
		"\bSYEAR\b" : "YEAR",
		"\bYYY\b" : "YEAR",
		"\bY\b" : "YEAR",
		"\bRM\b" : "MONTH",
		"\bWW\b" : "WEEK",
		"\bW\b" : "WEEK",
		"\bQ\b" : "QUARTER",
		"\bIY\b" : "yy",
		"\bD\b":"DAY",
		"\bDDD\b":"DAY",
		"\bJ\b":"DAY",
		"\bDY\b":"DAY",
		"hh24" : "HOUR",
		"hh12" : "HOUR",
		"HH24" : "HOUR",
		"HH12" : "HOUR",
		"HH" : "HOUR",
		"\bmi\b" : "MM",
		"\bMI\b" : "MM",
		"\bMi\b" : "MM",
		"\bSS\b" : "SECOND"	
	},


	"function_subst" : [
		{"from"  : "TO_NUMBER", "output_template" : "TRY_CAST($1 AS DOUBLE)"},
		{"from": "CONSTRAINT_CHECK", "to": "__BLANK__"},
		{"from": "FOREIGN_KEY", "to": "__BLANK__"},
		{"from": "REFERENCES", "to": "__BLANK__"},
		{"from": "PARTITION_BY_CASE_N", "to": "__BLANK__"},
		{"from": "PARTITION_BY_RANGE_N", "to": "__BLANK__"},
		{"from": "PARTITION_BY", "to": "__BLANK__"},

		{"from": "TRIM_LEADING", "to" : "LTRIM", "arg_token_output" : "1,2", "split_STRING" : "FROM" },
		{"from": "TRIM_TRAILING", "to" : "RTRIM", "arg_token_output" : "1,2", "split_STRING" : "FROM" }, //tells the parser to get tokens from args and place them inside the new call

		{"from": "UPI", "output_template" : "PRIMARY KEY ($ARGS_AFTER_1ST_ARG) )"},
		{"from": "UNK_IDX", "to": "UNIQUE", "statement_categories" : ["TABLE_DDL"], "placement" : "append_inside_ddl"},
		{"from": "UNK_IDX", "to": "ALTER TABLE __LAST_OBJECT_CREATED__ ADD UNIQUE", "statement_categories" : ["TABLE_DDL_LIKE","TABLE_DDL_AS_SELECT"], "placement" : "append_after_ddl"},
		{"from": "CREATE_INDEX", "to": "__BLANK__", "statement_categories" : ["TABLE_DDL","TABLE_DDL_LIKE","TABLE_DDL_AS_SELECT"]},
		{"from": "PRIM_IDX", "to": "__BLANK__"},
		{"from": "INDEX", "to": "__BLANK__", "statement_categories" : ["TABLE_DDL","TABLE_DDL_LIKE","TABLE_DDL_AS_SELECT"]},
		{"from": "ORDER_BY_VALUES", "to": "__BLANK__", "statement_categories" : ["TABLE_DDL","TABLE_DDL_LIKE","TABLE_DDL_AS_SELECT"]},


		{"from": "TRANSLATE", "to" : "__ELIMINATE_CALL__"}, //get rid of the function call with the parens, but leave the inner part
		{"from": "BEGIN", "to" : "__ELIMINATE_CALL__"},
		{"from": "END", "to" : "__ELIMINATE_CALL__"},

		{"from" : "INSTR", "to": "REGEXP_INSTR"},
		{"from": "STRTOK", "to" : "SPLIT_PART"},

		{"from": "TSDIFFDAY", "to": "DATEDIFF", "arg_placement" : { "1":"3||'DAY'", "2":"2", "3":"1" } },
		{"from": "TSDIFFSEC", "to": "DATEDIFF", "arg_placement" : { "1":"3||'SECOND'", "2":"2", "3":"1" } },

		//in arg_placement section, the key represents the target arg order, value represents the source arg order or default
		{"from" : "TRUNC","arg_pattern" : {"2" : "(IYYY|IYY|IY|\bI\b)"},"output_template" :"next_day(date_sub(date_add(date_trunc('year', $1), 3), 7), 'Monday')"},
		{"from" : "TRUNC","arg_pattern" : {"2" : "IW"},"output_template" :"next_day(date_add($1, -7), 'Monday')"},
		{"from" : "TRUNC","arg_pattern" : {"2" : "(\bCC\b|\bSCC\b)"},"output_template" :"CAST(make_date((FLOOR((year($1) - 1) / 100) * 100) + 1, 1, 1) AS TIMESTAMP)"},
		{"from" : "TRUNC","arg_pattern" : {"2" : "(YYYY|Y|M|Q|D|W|SYYY|SYEAR|I|RM|H|J|\bSS\b)"},"output_template" :"DATE_TRUNC($2,$1)","date_format_arg" : "2"},
		{"from" : "TRUNC","arg_pattern" : {"2" : "[0-9]+"},"output_template" :"FLOOR($1 * POWER(10, $2)) / POWER(10, $2)"},	
		{"from" :"POSITION", "output_template" : "INSTR($2,$1)"},

		{"from": "ZEROIFNULL", "output_template": "COALESCE($1, 0)"},
		{"from": "TRYCAST", "to": "try_cast"},
		{"from" : "__LESS_ANY__", "output_template" : "< (SELECT MIN(col) FROM($1) AS subquery(col))"},
		{"from" : "__LESS_EQUAL_ANY__", "output_template" : "<= (SELECT MIN(col) FROM($1) AS subquery(col))"},
		{"from" : "__GREAT_ANY__", "output_template" : "> (SELECT MAX(col) FROM($1) AS subquery(col))"},
		{"from" : "__GREAT_EQUAL_ANY__", "output_template" : "> (SELECT MAX(col) FROM($1) AS subquery(col))"},
		{"from" : "ANY", "output_template" : "IN"},
		// {"from" : "XMLAGG", "output_template" : "ARRAY_JOIN(ARRAY_AGG($1), $2)", "num_args" : 2},
		{"from" : "FIRST", "to" : "FIRST_VALUE"},
		{"from" : "NULLIFZERO", "output_template" : "NULLIF($1, 0)"},
		{"from" : "DECODE","num_args" : "3","output_template" :"case when $1=$2 then $3 END"},
		{"from" : "DECODE","num_args" : "4","output_template" :"case when $1=$2 then $3 else $4 END"},
		{"from" : "DECODE","num_args" : "5","output_template" :"case when $1=$2 then $3 when $1=$4 then $5 END"},
		{"from" : "DECODE","num_args" : "6","output_template" :"case when $1=$2 then $3 when $1=$4 then $5 else $6 END"},
		{"from" : "DECODE","num_args" : "7","output_template" :"case when $1=$2 then $3 when $1=$4 then $5 when $1=$6 then $7 END"},
		{"from" : "DECODE","num_args" : "8","output_template" :"case when $1=$2 then $3 when $1=$4 then $5 when $1=$6 then $7 else $8 END"},
		{"from" : "DECODE","num_args" : "9","output_template" :"case when $1=$2 then $3 when $1=$4 then $5 when $1=$6 then $7 when $1=$8 then $9 END"},
		{"from" : "HASHAMP", "output_template" :"pmod(abs(hash($1)), 10)"},

		{"from": "COMPRESS", "to": "__BLANK__"},
		{"from": "COMPRESS_SUPPRESS", "to": "__BLANK__"},
		{"from": "CHAR", "output_template" : "STRING", "statement_categories" : ["TABLE_DDL"]}
],

	"tag_capture" :
		{	//format: descriptive_key : array of regex patterns
			"COMPRESS" : ["COMPRESS"], //COMPRESS([\s|,(]|$)
			"TEMPORAL" : ["VALIDTIME"],
			"SYSLIB" : ["SYSLIB\."],
			"PERIOD_FUNCTIONS" : ["PERIOD(\s*)\("],
			"BINARY_DATATYPES" : ["BYTEINT", "VARBYTE"],
			"NATIVE_CASTING" : ["\(VARCHAR\(([0-9]+)\)\)", "\INT\)", "\(CHAR\(([0-9]+)\)\)"],
			"FORMAT_SPEC": ["FORMAT "],
			"FLOAT DEFAULT TIME" : ["FLOAT(\s+?)DEFAULT(\s+?)TIME"],
			"STRING_TRIMMING" : ["LEADING", "TRAILING"],
			"UNIQUE_PRIMARY_INDEX" : ["UNIQUE\s+PRIMARY\s+INDEX"],
			"UNIQUE_INDEX" : ["UNIQUE\s+INDEX"],
			"CROSS JOIN" : ["CROSS(\s+)JOIN"],
			"RECURSIVE" : ["RECURSIVE"],
			"LOADER CALL" : ["FAST_LOAD"],
			"DBC OBJECTS" : ["DBC\."],
			"CASESPECIFIC" : ["CASESPECIFIC"],
			"QUALIFY" : ["QUALIFY"],
			"GOTO" : ["THEN GOTO", "THEN\s+\.GOTO"]

		},
	//enable column parsing for: manipulate on 1 column at a time, it is safer; for lin-place aliases, swap column order; format functionality handling
	"column_level_parsing" : ["VIEW_DDL", "TABLE_DDL_AS_SELECT", "TABLE_DDL"],
	"adjust_format_tokens" : "1",
	"adjust_native_casting" : "1", //yet to be implemented
	"embedded_sql_var_prefix" : "&"
}


