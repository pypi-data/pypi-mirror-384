{
	"CUSTOM_CONVERTER_MODULES" : ["generic_sql_databricks_hooks_V2"],
	"target_file_extension" : "py",
	"post_process_header" : "# Databricks notebook source\nimport os\nfrom pyspark.sql import *\nfrom pyspark.sql.functions import *\nfrom datetime import datetime\nfrom utils.genericUtilities import *\nfrom utils.configs import *\n\n",
	//"post_process_footer" : "except Exception as e:\n\tprint(e)\n",
	"substitution_iter_limit" : 20000,
	"pattern_match_while_iter_limit" : 20000,
	"preprocess_file" : "1",
	"preprocess_routine": "::preprocess_generic_sql",
	"initialize_hooks_call" : "::init_hooks", //initialize context, pass all relevant info
	"pre_finalization_handler" : "::finalize_content",
	"code_fragment_breakers": { "line_end": [";"] },
	"keep_comments_in_place" : "1",

	"fragment_split_regex" : "(?=\bEXEC\b|\bCREATE\b|\bDECLARE\b|\bFETCH\b|\bWHILE\b|\bCLOSE\b|\bDEALLOCATE\b|\bINSERT\s+INTO\b|\bINSERT\s+[\w\.\`\[\]]*\s+SELECT\b|\bINSERT\s+\w+\.?\w*|\bUPDATE\b|\bDELETE\s+FROM\b|\bDELETE\s+[\w\.\`\[\]]*\s+WHERE\b|\bTRUNCATE\s+TABLE\b|\bDROP\s+TABLE\b|\bDROP\s+VIEW\b|\bWITH\s+\w+\s+AS\s*\(\s*SELECT\b|\,\s+\w+\s+AS\s*\(\s*SELECT\b|\bIF\s+NOT\s+EXISTS\b)", //|\bELSE\s+IF\b|\bIF\b|\bEND\b
	"fragment_sub_split_regex" : "(?=\bSELECT\b.*?\bINTO\b)", //|\bELSE\s+IF\b|\bIF\b|\bEND\b
	"proc_variable_default_widget_value" : "",
	"proc_variable_declaration_template" : "dbutils.widgets.text(name = '%VARNAME%', defaultValue = '%DEFAULT_VALUE%')\n%VARNAME% = dbutils.widgets.get(\"%VARNAME%\")\n\n",
	"proc_variable_declaration_header" : "# COMMAND ----------\n# Variable_declaration_comment",
	"proc_variable_sql_wrapping" : "'{%VARNAME%}'",
	"variable_assignment_from_select" : "query_1 = spark.sql(\"\"\"%QUERY%\"\"\")\n%VARIABLES_STRING% = query_1.first()%IS_SINGLE%",

	"custom_var_regex_wrap" : "(\@\w+)",

	"convert_cte_to_tables" : "1",

	"wrap_non_sql_comments_in_string" : "1",
	"cross_apply_var_substitution" : "1",

	"file_tabbing" : "\t",
	//"try_except_handling" : 1,

	"try_catch_split" : 1,
	"return_backup_merge_sql_if_no_match" : "1",
	"stmt_categorization_patterns":
	[
		{"category": "MARKER", "patterns" : ["^[\s\n]*\bEND\b\s+IF[\s\n]*$", "^[\s\n]*\bEND\b\s+LOOP[\s\n]*$"]},
		{"category": "TRY_EXCEPT", "patterns" : ["^\s*\bBEGIN\b\s*$", "^\s*\bEXCEPTION\b\s*$", "^\s*\bEND\b\s+\w+\s*$", "^\s*\bTRY\b\s*$", "^\s*\bCATCH\b\s*$"]},
		{"category": "DELETE", "patterns" : ["^[\s\n]*\bCOMMIT\b[\s\n]*$", "^[\s\n]*$", "^\s*\bCREATE\s+INDEX\b", "^\s*\bCREATE\s+\w+\s+INDEX\b"]},
		//{"category": "SET_SQL", "patterns" : ["^[\s\n]*\bSET\s+[\@\$\w]+\s+\="]},
		{"category": "PYTHON_VARIABLE_ASSIGNMENT", "patterns" : ["^[\s\n]*\w+\s*:=", "^[\s\n]*\bBEGIN\b[\s\n]*\w+\s*:="]},
		{"category": "PYTHON_VARIABLE_DECLARATION", "patterns" : [
			"^[\s\n]*\w+\s+(\bDATE\b|\bNUMBER\b|\bINT\b|\bVARCHAR2\b|\bLONG\b|\bRAW\b|\bTIMESTAMP\b|\bINTERVAL\b)",
			"^[\s\n]*\bBEGIN\b[\s\n]*\w+\s+(\bDATE\b|\bNUMBER\b|\bINT\b|\bVARCHAR\b|\bLONG\b|\bRAW\b|\bTIMESTAMP\b|\bINTERVAL\b)"
		]},
		{"category": "LOOP_FETCH", "patterns" : ["^[\s\n]*LOOP\s+FETCH"]},
		{"category": "PYTHON_FOR_LOOP", "patterns" : ["^[\s\n]*FOR", "^[\s\n]*\bBEGIN\b[\s\n]+\bFOR\b"]},
		{"category": "PYTHON_CONDITIONAL", "patterns" : ["^[\s\n]*(\bIF\b|\bELSIF\b|\bELSE\b\s+[^0-9])"]},
		//{"category": "CURSOR_DEF", "patterns" : ["^\s*CURSOR\s+"]},
		{"category": "CURSOR_FOR_LOOP", "patterns" : ["^\s*DECLARE\s+\w+\s+CURSOR\b", "^\s*FETCH\s+NEXT\s+FROM\s+\w+\s+INTO\s+[\@\w]+"]},
		{"category": "FUNCTION_CALL", "patterns" : ["^\s*exec\b"]},
		{"category": "EXECUTE_IMMEDIATE", "patterns" : ["^\s*EXECUTE\s+IMMEDIATE\b"]},
		{"category": "SELECT_INTO", "patterns" : ["^\s*SELECT\s+.*?\bINTO\b"]},
		{"category": "DECLARE_SQL", "patterns" : ["^\s*\bDECLARE\b\s+[\@\w]+\s+TABLE\b", "^\s*\bDECLARE\b\s+[\@\w\s]+?\bINSERT\b"]},
		{"category": "DECLARE", "patterns" : ["^\s*DECLARE\b"]},
		{"category": "CTE_TABLE", "patterns" : ["\bWITH\s+\w+\s+AS\s*\(\s*SELECT\b", "\,\s+\w+\s+AS\s*\(\s*SELECT\b"]},
		{"category": "MERGE_INTO", "patterns" : ["^\s*MERGE(\s?)"]},
		{"category": "PYTHON_PRINT", "patterns" : ["^[\s\n]*\bPRINT\b\s+(\'|\")"]},
		
		{"category": "SP_LOG", "patterns" : ["^\s*sp_log_oids_messages\s+"]}
	],

	"fragment_handling" :
	{
		"PYTHON_VARIABLE_DECLARATION": "::python_variable_declaration",
		"PYTHON_VARIABLE_ASSIGNMENT": "::python_variable_assignment",
		"PYTHON_CONDITIONAL": "::python_conditional",
		"MERGE_INTO" : "::convert_merge_into",
		"TRY_EXCEPT": "::try_except",
		"PYTHON_FOR_LOOP": "::python_for_loop",
		"LOOP_FETCH": "::python_loop_fetch",
		"DELETE": "::delete_fragment",
		"CURSOR_DEF": "::cursor_def",
		"CURSOR_FOR_LOOP": "::cursor_for_loop",
		"FUNCTION_CALL": "::function_call",
		"SP_LOG": "::sp_log",
		"EXECUTE_IMMEDIATE" : "::execute_immediate_fragment",
		//"SELECT_INTO" : "::select_into_fragment",
		"SELECT_INTO" : "::default_handler",
		"SET_SQL": "::set_sql",
		"DECLARE" : "::declare_fragment",
		"DECLARE_SQL": "::default_handler",
		"PYTHON_PRINT": "::python_print",
		"CTE_TABLE": "::default_handler",
		"__DEFAULT_HANDLER__": "::default_handler"
	},

	// "between_sql_fragments" : "\n# COMMAND ----------\n",
	"between_default_fragments" : "\n# COMMAND ----------\n",
	"default_sql_wrapping": "%DF% = spark.sql(f\"\"\"\n%SQL%\n\"\"\")\nnum_count = %DF%.first()",
	"default_cte_sql_wrapping": "%DF% = spark.sql(f\"\"\"\n%SQL%\n\"\"\")\n%DF%.CreateorReplaceTempView('%CTE_TABLE%')\nnum_count = %DF%.first()",

	"identify_procedure_headers" : [
		"(CREATE\s+OR\s+REPLACE\s+EDITIONABLE\s+PROCEDURE.*?\)\s*(__BB_COMMENT_[0-9]+__)*\s*(\bIS\b|\bAS\b))",
		"(CREATE\s+OR\s+REPLACE\s+EDITIONABLE\s+PROCEDURE.*\s*(\bIS\b|\bAS\b))",
		"(CREATE\s+OR\s+REPLACE\s+PROCEDURE\s+\w+\s+(\bIS\b|\bAS\b)\s+[\w\;\s]+\s+\bBEGIN\b)",
		"(CREATE\s+OR\s+REPLACE\s+PROCEDURE.*?(\bIS\b|\bAS\b))",
		//"(CREATE\s+OR\s+ALTER\s+PROCEDURE\s+\w+\s+(\bIS\b|\bAS\b)\s+[\w\;\s]+\s+\bBEGIN\b)",
		"(CREATE\s+OR\s+ALTER\s+PROCEDURE.*?(\bIS\b|\bAS\b))",
		"(CREATE\s+PROCEDURE\s+\w+\s+(\bIS\b|\bAS\b)\s+[\w\;\s]+\s+\bBEGIN\b)",
		"(CREATE\s+PROCEDURE.*?(\bIS\b|\bAS\b))"
	],

	"pre_process_subst" : [

		{"from": "\bDROP\s+TABLE\s+IF\s+EXISTS\s*\[?\#?(\w+)\]?", "to": "DROP VIEW IF EXISTS $1"},
		{"from": "\bDROP\s+TABLE\s+.*?\bCREATE\s+TABLE\b", "to": "CREATE OR REPLACE TABLE"},

		{"from": "(__BB_COMMENT_[0-9]+__)([\n\s]*\bAS\b)", "to": "$2\n$1"},

		{"from": "\bCREATE\s+UNIQUE\s+CLUSTERED\s+INDEX\s+\w+\s+ON\s+\w+\s*\(.*\)", "to": ""},
		{"from": "CREATE\s+OR\s+REPLACE\s+EDITIONABLE\s+PROCEDURE\s*([\w\.\[\]\\]+)\s*(.*?)([\w\.\[\]\\]+)\s+\)\s*(__BB_COMMENT_[0-9]+__)*\s*(\bIS\b|\bAS\b)", "to": ""},
		{"from": "CREATE\s+OR\s+REPLACE\s+EDITIONABLE\s+PROCEDURE\s*([\w\.\[\]\\]+)\s*(.*?)([\w\.\[\]\\]+)\s+\s*(\bIS\b|\bAS\b)", "to": ""},
		{"from": "CREATE\s+OR\s+REPLACE\s+PROCEDURE\s*([\w\.\[\]\\]+)\s*(.*?)(\bIS\b|\bAS\b)\s+[\w\;\s]+\s+\bBEGIN\b", "to": ""},
		{"from": "CREATE\s+OR\s+REPLACE\s+PROCEDURE\s*([\w\.\[\]\\]+)\s*(.*?)(\bIS\b|\bAS\b)", "to": ""},
		//{"from": "CREATE\s+OR\s+ALTER\s+PROCEDURE\s*([\w\.\[\]\\]+)\s*(.*?)(\bIS\b|\bAS\b)\s+[\w\;\s]+\s+\bBEGIN\b", "to": "def $1(spark,\n$2):\n__TAB_ADD__try:"},
		{"from": "CREATE\s+OR\s+ALTER\s+PROCEDURE\s*([\w\.\[\]\\]+)\s*(.*?)(\bIS\b|\bAS\b)", "to": ""},
		{"from": "CREATE\s+PROCEDURE\s*([\w\.\[\]\\]+)\s*(.*?)(\bIS\b|\bAS\b)\s+[\w\;\s]+\s+\bBEGIN\b", "to": ""},
		{"from": "CREATE\s+PROCEDURE\s*([\w\.\[\]\\]+)\s*(.*?)(\bIS\s*\n|\bAS\s*\n)", "to": ""},

		{"from": "\bdef [\w\[\]\\\/]+\.([\w\[\]\\\/]+)\(spark", "to": ""},
		{"from": "\bdef \[([\w\\\/]+)\]\s*\(spark", "to": ""},
		{"from": "\bdef ([\w\\\/]+)\s*\(spark\,\s*\((.*?)\)\s*\)\:", "to": ""},

		{"from": "\bAS\s+(DATETIME|VARCHAR|INT)(\s*\(\s*[0-9]+\s*\)|)\s*\=", "to": "="},
		{"from": "\bAS\s+(DATETIME|VARCHAR|INT)(\s*\(\s*[0-9]+\s*\)|)\s*\=", "to": "="},

		{"from": "(\bdef [\w\\\/]+\s*\(spark\,[\-\s\w\@\,\{\}]*)\b(AS|INT|VARCHAR|DATETIME|VARCHAR\s*\(.*?\))\s*(\,|\)\:)", "to": "$1$3"},
		{"from": "(\bdef [\w\\\/]+\s*\(spark\,[\-\s\w\,\{\}]*)\@(\w+)", "to": "$1$2"},
		{"from": "(\bdef [\w\\\/]+\s*\(spark)\,\s*(\)\:)", "to": "$1$2"},

		{"from": "(\bdef [\w\\\/]+\s*\(spark\,[\-\s\w\,\{\}\=\@]*)(\w+)\s+\w+\s+READONLY\b\s*", "to": "$1$2"},
		{"from": "(\bdef [\w\\\/]+\s*\(spark\,[\-\s\w\,\{\}\=\@\'\"]*)(\w+)\s+(bit|int|DATE)\b\s*", "to": "$1$2"},
		{"from": "(\bdef [\w\\\/]+\s*\(spark\,[\-\s\w\,\{\}\=\@\'\"]*)(\w+)\s+(bit|int|DATE)\b\s*", "to": "$1$2"},
		{"from": "(\bdef [\w\\\/]+\s*\(spark\,[\-\s\w\,\{\}\=\@]*)(\=\s*)NULL\b\s*", "to": "$1$2None"},

		{"from": "(\'|\")([^\'\"\n]+)\bEXCEPTION\b([^\'\"\n]+\1)", "to": "$1$2__PART_OF_STRING_EXCPT__$3"},
		{"from": "\s*\bsp_log_messages\b\s*\([\s\S]+?\)\s*\;",  "to" : ""}, //remove entire  block
		{"from": "\%TYPE\b", "to": ""},
		{"from": "\bDBMS_UTILITY\.get_time\b", "to": "datetime.datetime.now()"},

		{"from": "\bSET\s+NOCOUNT\s+ON\b", "to": ""},
		{"from": "\;", "to": ""},

		{"from": "(\n|^)\s*\bUSE\s*\[\w+\]\s*\n", "to": "\n"},
		{"from": "\n\s*\bGO\b\s*\n", "to": "\n"},
		{"from": "(^|\n)(\s*\bSET\s+\w+\s*(\bON\b|\bOFF\b)\s*)\n", "to": "\n# $2\n"},

		{"from" : "\[(.*?)\]", "to" : "`$1`"},
		//{"from" : "\`(\w+)\`", "to" : "$1"}

		{"from" : "\bINSERT(\s+[\w\`\[\]\.]+\s*\bSELECT\s+FORMAT\s*\()", "to" : "INSERT INTO$1"}
	],

	"default_sql_subst" : [
		{"from" : "\[(\w+?)\]", "to" : "$1"},
		{"from" : "\[(.*?)\]", "to" : "`$1`"},
		{"from": "\bCROSS\s+APPLY\s*\(\s*VALUES\b([\s\w\(\)\'\"\,\`\[\]\.]+?)\)(\s*\w+\s*)", "to": "LATERAL VIEW\nEXPLODE(ARRAY($1))$2%CROSS_VAR_VALS%"},
		{"from": "\bCROSS\s+APPLY\b", "to": "\nCROSS JOIN"},
		{"from": "\n\s*\(\s*([\w\'\"]+)\s*\,\s*([\w\.\[\]\`]+)\s*\)", "to": "\nSTRUCT($1 AS %CROSS_VAR_1%, $2 AS %CROSS_VAR_2%)"}
	],

	"declare_subst" : [
		{"from": "DECLARE", "to": ""},
		{"from": "([\-0-9]+\s*),", "to": "$1__COMMA__"},
		{"from": ",", "to": "\n"},
		{"from": "\bAS\b\s+(DATE|NUMBER|VARCHAR|LONG|RAW|TIMESTAMP)", "to": "__AS__$1__"},
		{"from": "(\s*\w+)\s+(DATE|NUMBER|VARCHAR|LONG|RAW|TIMESTAMP)", "to": "$1 = ''"},
		{"from": "(\s*\w+)\s+(INT|BIGINT|SMALLINT)", "to": "$1 = 1"},
		{"from": "\=\s*\'\'(\w+|)\s*\=", "to": "="},
		{"from": "CONVERT\s*\(\s*DATE\s+([\s\S]+?)\s*\)", "to": "$1"},
		{"from": "__AS__(\w+)__", "to": "AS $1"},
		{"from": "(\w+\s+\=\s+)(\bCAST\b[\s\S]+?)\bGETDATE\s*\(\s*\)([\s\S]+?\bAS\s+\w+\s*\))", "to": "$1spark.sql(f\"\"\"SELECT $2CURRENT_DATE()$3\"\"\").collect()[0][0]"},
		{"from": "\bGETDATE\s*\(\s*\)", "to": "spark.sql(\"select current_timestamp\").collect()[0][0]"}, // will get updated by variables later
		{"from": "SET\s+\w+\s+(OFF|ON)\s*(\;|)", "to": ""},
		// {"from": "\=\s*([0-9]+)", "to": "= '$1'"},

		{"from": "(\s*\w+)\s+NVARCHAR(\s*\(\s*\w+\s*\)|)", "to": "$1 = ''"},
		{"from": "\=\s*\'\'[\w\(\)]+\;", "to": "= '';"},
		{"from": "\[\w+\]\([0-9]+\)\s*\=", "to": "="},
		{"from": "(\=\s*[0-9]+\s*)\=\s*[0-9]+", "to": "$1"},
		{"from": "(\=\s*\'\s*\')\s*\(\s*[0-9]+\s*\)", "to": "$1"},
		{"from": "\=\s*\'\'\s*\=", "to": "="},
		{"from": "__COMMA__", "to": ","}

		//convert to dbutil widget
		//{"from": "(\w+)\s*\=\s*([\s\S]+?)\;", "to" : "dbutils.widgets.text(name = '$1', defaultValue = $2)\n$1 = dbutils.widgets.get(\"$1\")\n"}
	],

	"pre_python_conditional_subst" : [
		{"from": "\bNOT\s+EXISTS\s*\(([\s\S]+?)\)(\s*)($|\bor\b|\band\b)", "to": "spark.sql(\"\"\"$1\"\"\").count() <= 0$2$3"},
		{"from": "\bEXISTS\s*\(([\s\S]+?)\)(\s*)($|\bor\b|\band\b)", "to": "spark.sql(\"\"\"$1\"\"\").count() > 0$2$3"}
	],

	"python_conditional_subst" : [
		{"from": "\bIF\b(.*?)=(.*)", "to": "if $1 __equals__ $2"},
		{"from": "\bELSIF\b(.*?)=(.*)", "to": "elif $1 __equals__ $2"},
		{"from": "\bELSE\b(.*?)=(.*)", "to": "else $1 __equals__ $2"},
		{"from": "\bIF\b(.*?)\bIN\b(.*)", "to": "if $1 __i_n__ $2"},
		{"from": "\bELSIF\b(.*?)\bIN\b(.*)", "to": "elif $1 __i_n__ $2"},
		{"from": "\bELSE\b(.*?)\bIN\b(.*)", "to": "else $1 __i_n__ $2"},

		{"from": "\bISNULL\s*\(\s*([\w\@]+)\s*\,\s*([0-9]+)\s*\)", "to": "($1 or $2)"},


		{"from": "__equals__", "to": "=="},
		{"from": "__i_n__", "to": "in"},
		{"from": "IF", "to": "__i_f__"},
		{"from": "__i_f__", "to": "if"},
		{"from": "ELSE", "to": "__el_se__"},
		{"from": "__el_se__", "to": "else"},
		{"from": "ELSIF", "to": "__el_sif__"},
		{"from": "__el_sif__", "to": "elif"},
		{"from": "(<|>)\s*==", "to": "$1="},
		{"from": "null", "to": "None"},
		{"from": "<>", "to": "!="},
		{"from": "\bIS\s+NOT\b", "to": "NOT"},
		{"from": "NOT", "to": "__n_o_t__"},
		{"from": "__n_o_t__", "to": "not"},
		{"from": "\bIS\b", "to": "__i_s__"},
		{"from": "__i_s__", "to": "is"},
		{"from": "\bAND\b", "to": "__a_n_d__"},
		{"from": "__a_n_d__", "to": "and"},
		{"from": "\bOR\b", "to": "__o_r__"},
		{"from": "__o_r__", "to": "or"},
		{"from": "([\w\s])\=([\w\s])", "to": "$1==$2"},
		{"from": "None\s*\=\=\s*([0-9]+)", "to": "$1"}
	],

	"set_sql_subst" : [
		{"from": "dateadd\s*\(\s*(\w+)\s*\,\s*([\-0-9]+)\s*\,\s*(\w+\s*\(\s*\))\s*\)", "to": "date_add($3, $2)"},
		{"from": "GETDATE\s*\(\s*\)", "to": "current_timestamp()"},
		{"from": "\bSET\s+([\@\$\w]+)\s+\=\s*([\s\S]+?)\s*\;", "to": "$1 = spark.sql(f\"\"\"SELECT $2\"\"\").collect()[0][0]"},

		{"from": "\bSET\s+", "to": ""}
	],

	"python_for_loop_subst" : [
		{"from": "FOR\s+(\w+)\s+IN\s+(.*)", "to": "for $1 __in__ $2"},
		{"from": "__in__", "to": "in"},
		{"from": "([0-9]+)\s*\.\.\s*([0-9]+)", "to": "range($1, $2+1)"}

		// further hook processing after this
	],

	"python_variable_declaration_subst" : [
		{"from": "(\s*\w+)\s+(DATE|NUMBER|INT|VARCHAR|LONG|RAW|TIMESTAMP)\s*:=\s*(.*)", "to": "$1 = $3"},
		{"from": "(\s*\w+)\s+NUMBER\s+DEFAULT\s+(datetime\.datetime\.now\(\)).*", "to": "$1 = $2"},
		{"from": "(\s*\w+)\s+(DATE|NUMBER|INT|VARCHAR|LONG|RAW|TIMESTAMP|INTERVAL).*", "to": "$1 = None"}
	],

	"python_print_subst" : [
		{"from": "\bPRINT\s+(\'|\")([\s\S]+?)\1", "to": "print($1$2$1)"}
	],

	"python_variable_assignment_subst" : [
		{"from": "\s*:=\s*", "to": " = "},
		{"from": "\bNULL\b", "to": "None"},
		{"from": "\+\s*\n", "to": "+ \\n"}
	],

	"sp_log_subst" : [
		{"from": "sp_log_oids_messages\s*\(([\s\S]+)\)\s*$",  "to" : "dbutils.notebook.run('path/sp_log_oids_messages.py',arguments={$1})"},
		{"from": "(\w+)\s*\=\>\s*([\s\S]+)?(\,|\})", "to": "\"$1\" : $2$3"}
	],

	"cursor_def_pre_subst" : [
		{"from": "\s*CURSOR\s+", "to": "def "},
		{"from": "\s*IN\s+[\w\.]+\s*[\%\w]", "to": ""}
		//{"from": "\s*\bIS\b", "to": "__COLON__"}
		// {"from": "__COLON__([\s\S]+)", "to": ":\n\tinner_query = spark.sql(f\"\"\"$1\"\"\")\n\treturn inner_query"}

		// further hook processing after this
	],

	"cursor_for_loop_pre_subst" : [
		{"from": "(^\s*)DECLARE\s+(\w+)\s+CURSOR\s+FOR\s(.*?)(\bOPEN\s*\w+)", "to": "$1$2 = spark.sql(\"\"\"$3\"\"\")\n$4"},
		{"from": "(^\s*)DECLARE\s+(\w+)\s+CURSOR\s+FOR\s(.*)", "to": "$1$2 = spark.sql(\"\"\"$3\"\"\")"},
		{"from": "\bOPEN\s+(\w+)", "to": "for row in $1.collect():"},
		{"from": "\bFETCH\s+NEXT\s+FROM\s+(\w+)\s+INTO\s+([\@\w]+)", "to": "$2 = row[0][0]"}
		//{"from": "\bFETCH\s+NEXT\s+FROM\s+(\w+)\s+INTO\s+([\@\w]+)\s+WHILE\s+[\@\w+]+\s*\=\s*[0-9]+", "to": "$1 = row[0][0]"}
	],

	"function_call_subst" : [
		{"from": "exec\s+(\w+)\s*\.\s*(\w+)\s+([\@\w\,\s\-]+)", "to": "$2($3)"},
		{"from": "exec\s+(\w+)\s+([\@\w\,\s\-]+)", "to": "$1($2)"}
	],

	"try_except_subst" : [
		{"from": "#TRY", "to": "# TRY"},
		{"from": "#CATCH", "to": "# CATCH"},
		{"from": "# TRY", "to": "try:"},
		{"from": "# CATCH", "to": "except:"}
	],

	// this is the last step
	"final_visual_subst" : [
		{"from": "#__endif__", "to": ""},
		{"from": "#__endloop__", "to": ""},
		{"from": "#__ignored_except__", "to": ""},
		{"from": "#BEGIN __TRY_EXCEPT__", "to": ""},
		{"from": "__TRY_EXCEPT__", "to": "$1"},
		{"from": "# COMMAND ----------[\s\n\:]*# COMMAND ----------", "to": "# COMMAND ----------"},
//		{"from": "\n[\ \t]+# COMMAND ----------\n",  "to" : "\n"},
//		{"from": "\n# COMMAND ----------[\n\s]*$", "to": "\n"},
		{"from": "#\"\"\"--", "to": "\"\"\"--"},
		{"from": "\n(\s*)(\/\s*)\n", "to": "\n$1# $2\n"},
		{"from": "\n(\s*)(\bGRANT\b.*)", "to": "\n$1# $2"},
		{"from": "\n\s*\bRAISE\b\s*\n", "to": "\n\n"},
		{"from": "\bexcept\b:", "to": "except Exception as ex:"},
		{"from": "\bSQLERRM\b", "to": "str(ex)"},
		{"from": ":=", "to": "="},
		{"from": "\belse\:\s+if\b", "to": "elif"},
		{"from": "([\s\(\'\"\,\=])\@(\w+)", "to": "$1$2"},
		{"from": "(\s*)\@(\w+)", "to": "$1$2"},
		//{"from": "([\s\(])\#(\w+)", "to": "$1cat.TempDb.$2"},
		{"from": "([\s\(])\#(\w+)", "to": "$1$2"},
		{"from": "\.\.\#(\w+)", "to": ".$1"},
		{"from": "\#(\w+)", "to": "$1"},
		{"from": "# TRY", "to": ""},
		{"from": "# CATCH", "to": ""},
		{"from": "\bWHILE\s+[\@\w]+\s*\=\s*[0-9]+", "to": ""},
		{"from": "\bWHILE\s+\(\s*[\@\w]+\s*\=\s*[0-9]+\s*\)", "to": ""},
		{"from": "\bCLOSE\s+\w+", "to": ""},
		{"from": "\bDEALLOCATE\s+\w+", "to": ""},
		{"from": "ERROR_MESSAGE\s*\(\s*\)", "to": "{ex}"},
		{"from": "\bGETDATE\s*\(\s*\)", "to": "CURRENT_DATE()"},
		{"from": "\:\s*\:", "to": ":"},
		{"from": "\;", "to": ""},
		{"from": "\bGO(\s*except Exception)", "to": "$1"},
		{"from": "\bCREATE\s+UNIQUE\s+CLUSTERED\s+INDEX\s+\w+\s+ON\s+\w+\s*\(.*?\)", "to": ""},

		//{"from": "\n(\s*)(\-\-.*)\n", "to": "\n$1#$2\n"},
		{"from": "\n(\s*)\bSET\s+(\w+\s*\=)", "to": "\n$1$2"},
		{"from": "\bGO\b\s*\"\"\"\)", "to": "\"\"\")"},
		{"from": "# COMMAND ----------\s*$", "to": ""}
	],

	"line_subst" : [
		{"from": "\bSET\s+IDENTITY_INSERT\s+.*\s+OFF\b",  "to" : ""},
		{"from": "\bset\s+define\s+off\b",  "to" : ""},
		{"from": "\bEXIT\s+WHEN\b.*",  "to" : ""},
		{"from": "\bRAISE\b\;",  "to" : ""},
		{"from": "(\bEND\s+IF\b)",  "to" : "#__endif__"}, //needed for hook processing
		//{"from": "\bEXECUTE\s+IMMEDIATE\b",  "to" : "EXECUTE_IMMEDIATE"}, //needed for hook processing
		
		{"from": "\bCONVERT\(VARCHAR\([0-9]+\)\s*\,\s*DATEADD\(YEAR\,\s*DATEDIFF\(YEAR\,\s*0\,\s*GETDATE\(\)\)\s*\-\s*1\,\s*0\)\,\s*[0-9]+\)",  "to" : "date_format(add_months(current_date(), -12), 'yyyyMM')"}, //needed for hook processing
		{"from": "(\bEND\s+LOOP\b)",  "to" : "#__endloop__"}, //needed for hook processing
		{"from": "__PART_OF_STRING_EXCPT__",  "to" : "exception"} //needed for hook processing
	],
	// for default handler -- in this case sql fragments, comments (not python fragments)
	"block_subst" : [
		{"from": "\n\s*\n",  "to" : "\n"},
		{"from": "(\bEND\s+IF\b)",  "to" : "#__endif__"}, //needed for hook processing
		{"from": "(\bEND\b)",  "to" : "#__endif__"}, //needed for hook processing
		{"from": "\|\|", "to": "+"},
		{"from": "(\bEND\s+LOOP\b)",  "to" : "#__endloop__"} //needed for hook processing
	],

	"function_subst" : [
		{"from": "TRUNC", "to": "date_trunc", "arg_placement": { "1":"2||'DD'", "2":"1" } },
		{"from": "SYSDATE",  "to" : "current_date()"},
		{"from": "ISNULL",  "to" : "NVL"},
		{"from": "TO_NUMBER", "to" : "INT"},
		{"from": "CONVERT", "output_template" : "CAST($2 AS $1)"},
		{"from": "VARCHAR", "output_template" : "STRING"},
		{"from": "TO_CHAR", "num_args" : 1, "output_template" : "date_format($1,'MM/dd/yyy')"},
		{"from": "DATEPART", "output_template" : "DAYOFWEEK($2)", "arg_placement": { "1":"WEEKDAY"}},
		{"from": "ODS.SP_LOG_MESSAGES", "to" : "__BLANK__"},
		{"from": "RAISE_APPLICATION_ERROR", "output_template" : "print($2)"},
		//{"from": "SP_LOG_OIDS_MESSAGES", "to" : "__BLANK__"},
		//{"from": "EXECUTE_IMMEDIATE", "to" : "spark.sql"},
		{"from": "TO_CHAR", "to" : "date_format"},
		{"from": "ROUND", "to" : "np.round"},
		{"from": "FORMAT", "to" : "DATE_FORMAT"},
		{"from": "ISNone", "output_template" : "$1 is not None"},
		{"from": "Object_ID", "output_template" : "$1 in spark.catalog.listTables()"},
		{"from": "DBMS_OUTPUT.put_line", "to" : "print"},
		{"from": "SUBSTR", "num_args" : 2, "output_template" : "$1[$2:]"},
		{"from": "SUBSTR", "num_args" : 3, "output_template" : "$1[$2:$3]"}
	]

}
