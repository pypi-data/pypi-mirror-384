{
    "description": "<div class=\"document\" id=\"traited-class-tvb-simulator-models-infinite-theta-montbriopazoroxin\">\n<h1 class=\"title\">Traited class [tvb.simulator.models.infinite_theta.MontbrioPazoRoxin]</h1>\n<blockquote>\n<p>2D model describing the Ott-Antonsen reduction of infinite all-to-all\ncoupled QIF neurons (Theta-neurons) as in <a class=\"citation-reference\" href=\"#montbrio-pazo-roxin-2015\" id=\"citation-reference-1\">[Montbrio_Pazo_Roxin_2015]</a>.</p>\n<p>The two state variables <span class=\"math first last\">\\(r\\)</span> and <span class=\"math first last\">\\(V\\)</span> represent the average\nfiring rate and the average membrane potential of our QIF neurons.</p>\n<p>The equations of the infinite QIF 2D population model read</p>\n<div class=\"math first last\">\n\\begin{align*}\n\\dot{r} &amp;= 1/\\tau (\\Delta/(\\pi \\tau) + 2 V r)\\\\\n\\dot{V} &amp;= 1/\\tau (V^2 - \\tau^2 \\pi^2 r^2 + \\eta + J \\tau r + I)\n\\end{align*}\n</div>\n<p>Input from the network enters in the <span class=\"math first last\">\\(V\\)</span> variable as\n<span class=\"math first last\">\\(1/\\tau(c_r C_r + c_v C_V)\\)</span> where C is the incomming coupling. In\nother words, depending on the parameters <span class=\"math first last\">\\(c_r\\)</span>, <span class=\"math first last\">\\(c_v\\)</span> we couple\nthe neural masses via the firing rate and/or the membrane potential.</p>\n<table class=\"docutils citation\" frame=\"void\" id=\"montbrio-pazo-roxin-2015\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\"><a class=\"fn-backref\" href=\"#citation-reference-1\">[Montbrio_Pazo_Roxin_2015]</a></td><td>Montbri\u00f3, E., Paz\u00f3, D., &amp; Roxin, A. (2015). Macroscopic description for networks of spiking neurons. <em>Physical Review X</em>, 5(2), 021028.</td></tr>\n</tbody>\n</table>\n</blockquote>\n<div class=\"section\" id=\"attributes-declared\">\n<h1>Attributes declared</h1>\n<dl class=\"docutils\">\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tvb.simulator.models.infinite_theta.MontbrioPazoRoxin.tau = NArray(label='<span class=\"math first last\">\\(\\\\tau\\)</span>', dtype=float64, default=array([1.]), dim_names=(), ndim=None, required=True)</span></dt>\n<dd>Characteristic time</dd>\n<dt>I <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tvb.simulator.models.infinite_theta.MontbrioPazoRoxin.I = NArray(label='<span class=\"math first last\">\\(I_{ext}\\)</span>', dtype=float64, default=array([0.]), dim_names=(), ndim=None, required=True)</span></dt>\n<dd>External Current</dd>\n<dt>Delta <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tvb.simulator.models.infinite_theta.MontbrioPazoRoxin.Delta = NArray(label='<span class=\"math first last\">\\(\\\\Delta\\)</span>', dtype=float64, default=array([1.]), dim_names=(), ndim=None, required=True)</span></dt>\n<dd>Mean heterogeneous noise</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tvb.simulator.models.infinite_theta.MontbrioPazoRoxin.J = NArray(label='<span class=\"math first last\">\\(J\\)</span>', dtype=float64, default=array([15.]), dim_names=(), ndim=None, required=True)</span></dt>\n<dd>Mean Synaptic weight.</dd>\n<dt>eta <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tvb.simulator.models.infinite_theta.MontbrioPazoRoxin.eta = NArray(label='<span class=\"math first last\">\\(\\\\eta\\)</span>', dtype=float64, default=array([-5.]), dim_names=(), ndim=None, required=True)</span></dt>\n<dd>Constant parameter to scale the rate of feedback from the\nfiring rate variable to itself</dd>\n<dt>Gamma <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tvb.simulator.models.infinite_theta.MontbrioPazoRoxin.Gamma = NArray(label='<span class=\"math first last\">\\(\\\\Gamma\\)</span>', dtype=float64, default=array([0.]), dim_names=(), ndim=None, required=True)</span></dt>\n<dd>Half-width of synaptic weight distribution</dd>\n<dt>cr <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tvb.simulator.models.infinite_theta.MontbrioPazoRoxin.cr = NArray(label='<span class=\"math first last\">\\(cr\\)</span>', dtype=float64, default=array([1.]), dim_names=(), ndim=None, required=True)</span></dt>\n<dd>It is the weight on Coupling through variable r.</dd>\n<dt>cv <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tvb.simulator.models.infinite_theta.MontbrioPazoRoxin.cv = NArray(label='<span class=\"math first last\">\\(cv\\)</span>', dtype=float64, default=array([0.]), dim_names=(), ndim=None, required=True)</span></dt>\n<dd>It is the weight on Coupling through variable V.</dd>\n<dt>state_variable_range <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tvb.simulator.models.infinite_theta.MontbrioPazoRoxin.state_variable_range = Final(field_type=&lt;class 'dict'&gt;, default={'r': array([0., 2.]), 'V': array([-2. ,  1.5])}, required=True)</span></dt>\n<dd>Expected ranges of the state variables for initial condition generation and phase plane setup.</dd>\n</dl>\n<p>state_variable_boundaries : tvb.simulator.models.infinite_theta.MontbrioPazoRoxin.state_variable_boundaries = Final(field_type=&lt;class 'dict'&gt;, default={'r': array([ 0., inf])}, required=True)</p>\n<p>coupling_terms : tvb.simulator.models.infinite_theta.MontbrioPazoRoxin.coupling_terms = Final(field_type=&lt;class 'list'&gt;, default=['Coupling_Term_r', 'Coupling_Term_V'], required=True)</p>\n<p>state_variable_dfuns : tvb.simulator.models.infinite_theta.MontbrioPazoRoxin.state_variable_dfuns = Final(field_type=&lt;class 'dict'&gt;, default={'r': '1/tau * ( Delta / (pi * tau) + 2 * V * r)', 'V': '1/tau * ( V*V - pi*pi*tau*tau*r*r + eta + J * tau * r + I + cr * Coupling_Term_r + cv * Coupling_Term_V)'}, required=True)</p>\n<dl class=\"docutils\">\n<dt>variables_of_interest <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tvb.simulator.models.infinite_theta.MontbrioPazoRoxin.variables_of_interest = List(of=&lt;class 'str'&gt;, default=('r', 'V'), required=True)</span></dt>\n<dd>The quantities of interest for monitoring for the Infinite QIF 2D oscillator.</dd>\n</dl>\n<p>parameter_names : tvb.simulator.models.infinite_theta.MontbrioPazoRoxin.parameter_names = List(of=&lt;class 'str'&gt;, default=['tau', 'Delta', 'eta', 'J', 'I', 'cr', 'cv'], required=True)</p>\n<p>gid : tvb.basic.neotraits._core.HasTraits.gid = Attr(field_type=&lt;class 'uuid.UUID'&gt;, default=None, required=True)</p>\n</div>\n</div>\n",
    "arguments": {
        "tau": "<div class=\"document\">\n<p>Characteristic time</p>\n</div>\n",
        "I": "<div class=\"document\">\n<p>External Current</p>\n</div>\n",
        "Delta": "<div class=\"document\">\n<p>Mean heterogeneous noise</p>\n</div>\n",
        "J": "<div class=\"document\">\n<p>Mean Synaptic weight.</p>\n</div>\n",
        "eta": "<div class=\"document\">\n<dl class=\"docutils\">\n<dt>Constant parameter to scale the rate of feedback from the</dt>\n<dd>firing rate variable to itself</dd>\n</dl>\n</div>\n",
        "Gamma": "<div class=\"document\">\n<p>Half-width of synaptic weight distribution</p>\n</div>\n",
        "cr": "<div class=\"document\">\n<p>It is the weight on Coupling through variable r.</p>\n</div>\n",
        "cv": "<div class=\"document\">\n<p>It is the weight on Coupling through variable V.</p>\n</div>\n",
        "state_variable_range": "<div class=\"document\">\n<p>Expected ranges of the state variables for initial condition generation and phase plane setup.</p>\n</div>\n",
        "variables_of_interest": "<div class=\"document\">\n<p>The quantities of interest for monitoring for the Infinite QIF 2D oscillator.</p>\n</div>\n"
    }
}