---
title: 'Custom Tools & Credential Management'
description: 'Extend DroidRun agents with custom tools and secure credential storage'
---

# Custom Tools & Credential Management

Extend DroidRun agents with custom tools and secure credential management. This guide is focused on practical implementation for developers.

---

## Quick Start

### Custom Tools
```python
import asyncio
from droidrun import AdbTools, DroidAgent
from llama_index.llms.google_genai import GoogleGenAI

def my_custom_tool(tool_instance, message: str) -> str:
    """Custom tool that processes a message."""
    return f"Processed: {message}"

custom_tools = {
    "my_custom_tool": {
        "arguments": ["message"],  # List arguments (excluding tool_instance)
        "description": 'Process a message. Usage: {"action": "my_custom_tool", "message": "hello"}',
        "function": my_custom_tool,
    }
}

async def main():
    tools = AdbTools()
    llm = GoogleGenAI(model="models/gemini-2.5-flash")

    agent = DroidAgent(
        goal="Use my custom tool to process 'Hello World'",
        llm=llm,
        tools=tools,
        custom_tools=custom_tools  # Pass custom tools here
    )

    result = await agent.run()
    print(result.success, result.reason)

asyncio.run(main())
```

### Credentials
```python
# Method 1: Direct dict (in-memory)
credentials = {
    "MY_PASSWORD": "secret123",
    "API_KEY": "sk-1234567890"
}

agent = DroidAgent(
    goal="Login to my app",
    llm=llm,
    tools=tools,
    credentials=credentials  # Pass credentials directly
)

# Method 2: YAML file (config.yaml)
# credentials:
#   enabled: true
#   file_path: credentials.yaml
```

---

## Overview

### Custom Tools
User-defined Python functions that extend agent capabilities beyond built-in atomic actions (click, type, swipe, etc.).

**Use cases:**
- Integrate with external APIs (webhooks, REST services)
- Perform complex computations or data processing
- Access third-party services (databases, cloud APIs)
- Implement domain-specific actions

**Key features:**
- Passed via `custom_tools` parameter to `DroidAgent`
- Automatically merged with atomic actions and credential tools
- Available to all agents (Manager, Executor, CodeAct)
- Support both sync and async functions

### Credential Management
Secure storage and retrieval of sensitive data like passwords, API keys, and tokens.

**Key features:**
- Stored in YAML files or passed as in-memory dicts
- Never logged or exposed in output
- Automatically injected as `type_secret` custom tool
- Accessible to all agents via credential manager

**Security Notes:**
- Credentials are NOT encrypted by DroidRun
- Always add `credentials.yaml` to `.gitignore`
- Use external encryption (GPG) or environment variables for production
- Secret values are never logged, only secret IDs

---

## Custom Tools

### Architecture

Custom tools are defined as Python dictionaries following this structure:

```python
custom_tools = {
    "tool_name": {
        "arguments": ["arg1", "arg2"],  # List of parameter names (required)
        "description": "Tool description with usage example",  # For LLM prompt (required)
        "function": callable_function  # Python function to execute (required)
    }
}
```

**Key points:**
- `arguments`: List of parameter names (excluding the required `tool_instance` first parameter)
- `description`: Clear description with JSON usage example for the LLM
- `function`: Python callable (sync or async)

The custom tool system merges seamlessly with atomic actions:
- **Atomic actions** (click, type, swipe, etc.) are always available
- **Custom tools** are added on top via the `custom_tools` parameter
- **Credential tools** (`type_secret`) are auto-injected when credentials are provided
- All agents (Manager, Executor, CodeAct) can use custom tools

### Creating Custom Tools

#### Basic Example: Webhook Integration

```python
#!/usr/bin/env python3
import asyncio
import requests
from droidrun import AdbTools, DroidAgent
from llama_index.llms.google_genai import GoogleGenAI

def send_webhook(tool_instance, url: str, data: str) -> str:
    """
    Send data to a webhook URL.

    Args:
        tool_instance: Tools instance (required by DroidRun)
        url: Webhook URL
        data: Data to send (JSON string or plain text)

    Returns:
        Result message
    """
    try:
        response = requests.post(url, json={"data": data}, timeout=10)
        response.raise_for_status()
        return f"Webhook sent successfully. Status: {response.status_code}"
    except Exception as e:
        return f"Error sending webhook: {str(e)}"

# Define custom tool
custom_tools = {
    "send_webhook": {
        "arguments": ["url", "data"],
        "description": 'Send data to a webhook URL. Usage: {"action": "send_webhook", "url": "https://webhook.site/abc123", "data": "your data here"}',
        "function": send_webhook,
    }
}

async def main():
    tools = AdbTools()
    llm = GoogleGenAI(model="models/gemini-2.5-flash")

    agent = DroidAgent(
        goal="Check my Gmail unread count and send it to webhook https://webhook.site/abc123",
        llm=llm,
        tools=tools,
        custom_tools=custom_tools  # Pass custom tools here
    )

    result = await agent.run()
    print(f"Success: {result.success}")
    print(f"Reason: {result.reason}")

if __name__ == "__main__":
    asyncio.run(main())
```

#### Advanced Example: API Integration

```python
import json
import requests
from typing import Dict

def fetch_weather(tool_instance, city: str) -> str:
    """
    Fetch weather data for a city.

    Args:
        tool_instance: Tools instance
        city: City name

    Returns:
        Weather information as string
    """
    try:
        # Example using OpenWeatherMap API
        api_key = "your_api_key_here"  # Or use credential manager
        url = f"https://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}"
        response = requests.get(url, timeout=10)
        response.raise_for_status()

        data = response.json()
        temp = data["main"]["temp"] - 273.15  # Convert to Celsius
        weather = data["weather"][0]["description"]

        return f"Weather in {city}: {weather}, {temp:.1f}Â°C"
    except Exception as e:
        return f"Error fetching weather: {str(e)}"

def save_to_database(tool_instance, table: str, data: str) -> str:
    """
    Save data to a database.

    Args:
        tool_instance: Tools instance
        table: Table name
        data: JSON data to save

    Returns:
        Result message
    """
    try:
        # Parse JSON data
        json_data = json.loads(data)

        # Example database operation (pseudo-code)
        # db.insert(table, json_data)

        return f"Data saved to {table}: {len(json_data)} records"
    except json.JSONDecodeError:
        return "Error: Invalid JSON data"
    except Exception as e:
        return f"Error saving to database: {str(e)}"

custom_tools = {
    "fetch_weather": {
        "arguments": ["city"],
        "description": 'Fetch current weather for a city. Usage: {"action": "fetch_weather", "city": "London"}',
        "function": fetch_weather,
    },
    "save_to_database": {
        "arguments": ["table", "data"],
        "description": 'Save JSON data to database table. Usage: {"action": "save_to_database", "table": "users", "data": "{\\"name\\": \\"John\\", \\"age\\": 30}"}',
        "function": save_to_database,
    }
}
```

### Custom Tool Function Signature

All custom tool functions **must** follow this signature:

```python
def tool_function(tool_instance: Tools, arg1: type, arg2: type, ...) -> str:
    """
    Tool description.

    Args:
        tool_instance: Tools instance (REQUIRED as first parameter)
        arg1: Description of argument 1
        arg2: Description of argument 2

    Returns:
        Result message (string)
    """
    # Implementation
    return "result"
```

**Critical Requirements:**

1. **First parameter MUST be `tool_instance`**: This is the `Tools` instance (AdbTools or IOSTools) that DroidRun passes automatically. Even if you don't use it, it must be the first parameter.

2. **List only user arguments in `arguments`**: The `arguments` list in your custom tool definition should NOT include `tool_instance`. Only list the arguments that the LLM will provide (arg1, arg2, etc.).

3. **Return type should be `str`**: Agents expect string responses for all tool calls.

4. **Async functions are supported**: Use `async def` for async operations.

5. **Handle exceptions**: Always catch exceptions and return error messages as strings.

**Example:**
```python
def my_tool(tool_instance, message: str) -> str:
    # tool_instance is passed by DroidRun automatically
    return f"Processed: {message}"

custom_tools = {
    "my_tool": {
        "arguments": ["message"],  # Only list user arguments, NOT tool_instance
        "description": 'Process a message. Usage: {"action": "my_tool", "message": "hello"}',
        "function": my_tool,
    }
}
```

### Async Custom Tools

For async operations, use `async def`:

```python
import asyncio
import aiohttp

async def fetch_async(tool_instance, url: str) -> str:
    """Fetch data asynchronously."""
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=10) as response:
                data = await response.text()
                return f"Fetched {len(data)} bytes"
    except Exception as e:
        return f"Error: {str(e)}"

custom_tools = {
    "fetch_async": {
        "arguments": ["url"],
        "description": 'Fetch data from URL asynchronously. Usage: {"action": "fetch_async", "url": "https://api.example.com/data"}',
        "function": fetch_async,
    }
}
```

### How Custom Tools Work

1. **Tool Registration**: Custom tools are passed to `DroidAgent` via the `custom_tools` parameter
2. **Tool Merging**: Custom tools are merged with:
   - Atomic actions (click, type, swipe, etc.)
   - Auto-generated credential tools (type_secret) if credentials are provided
   - Built-in helper tools (open_app)
3. **Prompt Injection**: Tool descriptions are injected into agent prompts
4. **Execution**: When an agent selects a custom tool, DroidRun calls the function with:
   - `tool_instance` (injected automatically by DroidRun)
   - User arguments from the LLM's action

**Internal Flow Example:**
```python
# 1. Agent receives tool description in prompt:
#    "send_webhook(url, data): Send data to webhook URL. Usage: {...}"

# 2. Agent decides to use tool and outputs:
#    {"action": "send_webhook", "url": "https://api.example.com", "data": "hello"}

# 3. DroidRun internally calls your function:
#    result = send_webhook(
#        tool_instance=tools_instance,  # Injected by DroidRun
#        url="https://api.example.com",  # From agent output
#        data="hello"                    # From agent output
#    )

# 4. Result is returned to agent for next decision
```

**Key Point:** The `tool_instance` parameter is NOT visible to the LLM. It's automatically injected by DroidRun's execution layer.

### Best Practices for Custom Tools

<AccordionGroup>
  <Accordion title="1. Clear Descriptions">
    Write detailed descriptions with usage examples for the LLM:

    ```python
    # Good
    "description": 'Send POST request to webhook URL with JSON payload. Usage: {"action": "send_webhook", "url": "https://webhook.site/abc", "data": "{\\"key\\": \\"value\\"}"}',

    # Bad
    "description": "Send webhook",
    ```
  </Accordion>

  <Accordion title="2. Error Handling">
    Always catch exceptions and return meaningful error messages:

    ```python
    def robust_tool(tool_instance, url: str) -> str:
        try:
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            return f"Success: {response.status_code}"
        except requests.Timeout:
            return "Error: Request timed out after 10 seconds"
        except requests.RequestException as e:
            return f"Error: HTTP request failed - {str(e)}"
        except Exception as e:
            return f"Error: Unexpected error - {str(e)}"
    ```
  </Accordion>

  <Accordion title="3. Argument Validation">
    Validate inputs before processing:

    ```python
    def validated_tool(tool_instance, count: int) -> str:
        if not isinstance(count, int):
            return "Error: count must be an integer"
        if count < 0 or count > 100:
            return "Error: count must be between 0 and 100"

        # Process valid input
        return f"Processed {count} items"
    ```
  </Accordion>

  <Accordion title="4. Timeout Handling">
    Add timeouts to network operations:

    ```python
    def api_call(tool_instance, endpoint: str) -> str:
        try:
            response = requests.get(endpoint, timeout=10)  # Always set timeout
            return response.text
        except requests.Timeout:
            return "Error: API call timed out"
    ```
  </Accordion>

  <Accordion title="5. Logging (Optional)">
    Use Python logging for debugging (logs appear in DroidRun output):

    ```python
    import logging
    logger = logging.getLogger("droidrun")

    def logged_tool(tool_instance, data: str) -> str:
        logger.info(f"Processing data: {data[:50]}...")  # Log first 50 chars
        # Process data
        logger.info("Processing complete")
        return "Success"
    ```
  </Accordion>
</AccordionGroup>

---

## Credential Management

### Overview

The credential manager provides secure storage for sensitive data like passwords, API keys, and authentication tokens. Credentials are:
- **Stored in plain text** (YAML or in-memory dict - not encrypted)
- **Never logged** or exposed in output
- **Automatically available** as the `type_secret` custom tool
- **Access-logged** for audit purposes (logs secret ID, not value)

**Important:** DroidRun does NOT encrypt credentials. Use external encryption (GPG), environment variables, or secret management systems for production deployments.

### Setting Up Credentials

#### Method 1: Configuration File (Recommended)

1. **Create credentials file** (`credentials.yaml`):

```yaml
# credentials.yaml
secrets:
  # Dict format (recommended)
  MY_PASSWORD:
    value: "your_password_here"
    enabled: true

  GMAIL_PASSWORD:
    value: "gmail_pass_123"
    enabled: true

  API_KEY:
    value: "sk-1234567890abcdef"
    enabled: true

  # Simple string format (auto-enabled)
  WEBHOOK_TOKEN: "webhook_secret_token"

  # Disabled secret (not loaded)
  OLD_PASSWORD:
    value: "old_pass"
    enabled: false  # This secret will NOT be available
```

2. **Enable in config.yaml**:

```yaml
# config.yaml
credentials:
  enabled: true
  file_path: credentials.yaml  # Path relative to working directory
```

3. **Use in your script**:

```python
#!/usr/bin/env python3
import asyncio
from droidrun import AdbTools, DroidAgent
from droidrun.config_manager.config import DroidRunConfig
from llama_index.llms.google_genai import GoogleGenAI

async def main():
    # Initialize config and enable credentials from file
    config = DroidRunConfig()
    config.credentials.enabled = True
    config.credentials.file_path = "credentials.yaml"

    tools = AdbTools()
    llm = GoogleGenAI(model="models/gemini-2.5-flash")

    agent = DroidAgent(
        goal="Login to my Gmail account",
        llm=llm,
        tools=tools,
        config=config  # Credentials loaded from config
    )

    result = await agent.run()
    print(f"Success: {result.success}")

if __name__ == "__main__":
    asyncio.run(main())
```

#### Method 2: In-Memory Credentials (Programmatic)

Pass credentials directly as a dictionary:

```python
#!/usr/bin/env python3
import asyncio
from droidrun import AdbTools, DroidAgent
from llama_index.llms.google_genai import GoogleGenAI

async def main():
    # Define credentials in-memory
    credentials = {
        "MY_PASSWORD": "secret123",
        "API_KEY": "sk-1234567890abcdef"
    }

    tools = AdbTools()
    llm = GoogleGenAI(model="models/gemini-2.5-flash")

    agent = DroidAgent(
        goal="Login to my account",
        llm=llm,
        tools=tools,
        credentials=credentials  # Pass directly
    )

    result = await agent.run()
    print(f"Success: {result.success}")

if __name__ == "__main__":
    asyncio.run(main())
```

### Using Credentials in Agents

When credentials are provided (via config or parameter), the `type_secret` custom tool is **automatically injected** by DroidRun. You don't need to define it manually.

#### How Agents Use Credentials

The agent receives available secret IDs in the system prompt:

```
## Available Secrets:
The credential manager has the following secret IDs available for use with the `type_secret` function:
- MY_PASSWORD
- GMAIL_PASSWORD
- API_KEY

Use `type_secret(secret_id, index)` to type these secrets into input fields without exposing their values.
```

The agent then uses `type_secret` to input credentials:

```python
# Agent's generated code (CodeAct mode)
type_secret("MY_PASSWORD", index=5)
```

**Note:** The `type_secret` tool is built into DroidRun (see `droidrun/agent/utils/tools.py` â `build_credential_tools()`). It's automatically added when you pass credentials to `DroidAgent`.

#### Example: Login Automation

```python
#!/usr/bin/env python3
import asyncio
from droidrun import AdbTools, DroidAgent
from llama_index.llms.google_genai import GoogleGenAI

async def main():
    # Define credentials
    credentials = {
        "EMAIL_USER": "user@example.com",
        "EMAIL_PASS": "secret_password_123"
    }

    tools = AdbTools()
    llm = GoogleGenAI(model="models/gemini-2.5-flash")

    agent = DroidAgent(
        goal="Open Gmail app and login with my credentials",
        llm=llm,
        tools=tools,
        credentials=credentials
    )

    result = await agent.run()
    print(f"Success: {result.success}")
    print(f"Result: {result['reason']}")

if __name__ == "__main__":
    asyncio.run(main())
```

**What the agent does internally:**
1. Opens Gmail app using `open_app("Gmail")`
2. Clicks on email input field: `click(index=3)`
3. Types email using regular type: `type("user@example.com", index=3)`
4. Clicks on password field: `click(index=5)`
5. Types password securely: `type_secret("EMAIL_PASS", index=5)`
6. Clicks login button: `click(index=7)`

### Credential Manager API

If you need direct access to credentials (e.g., for custom tools):

```python
from droidrun.credential_manager import CredentialManager

# Load from file
cm = CredentialManager(credentials_path="credentials.yaml")

# Load from dict
cm = CredentialManager(credentials_dict={"PASSWORD": "secret123"})

# Get secret value
password = cm.get_credential("PASSWORD")

# List available secrets
secret_ids = cm.list_available_secrets()  # ["PASSWORD", "API_KEY", ...]

# Check if secret exists
if cm.has_credential("API_KEY"):
    api_key = cm.get_credential("API_KEY")
```

### Security Features

<AccordionGroup>
  <Accordion title="1. No Logging">
    Secret values are **never** logged or displayed:

    ```
    â Logged: "ð Accessing secret: 'MY_PASSWORD'"
    â Never logged: "MY_PASSWORD value is: secret123"
    ```
  </Accordion>

  <Accordion title="2. Sanitized Errors">
    Error messages show secret IDs but never values:

    ```
    â Error message: "Secret 'WRONG_ID' not found. Available: ['MY_PASSWORD', 'API_KEY']"
    â Never shown: "Secret value 'secret123' is invalid"
    ```
  </Accordion>

  <Accordion title="3. External Encryption (Recommended)">
    DroidRun does NOT encrypt credentials. For production, use external encryption:

    ```bash
    # Option 1: GPG encryption
    gpg --encrypt --recipient you@example.com credentials.yaml
    # Decrypt before running
    gpg --decrypt credentials.yaml.gpg > credentials.yaml
    droidrun run "your command"
    rm credentials.yaml  # Clean up after run

    # Option 2: Use a secret manager (AWS Secrets Manager, HashiCorp Vault, etc.)
    # Option 3: Environment variables (see Accordion 5)
    ```

    **Why external encryption?** Credentials are stored in plain text YAML. Always encrypt sensitive files or use environment variables.
  </Accordion>

  <Accordion title="4. Production Security">
    For production deployments, consider these security measures:

    ```python
    import os
    from droidrun import DroidAgent

    # Option 1: Environment variables (recommended)
    credentials = {
        "PASSWORD": os.environ.get("APP_PASSWORD"),
        "API_KEY": os.environ.get("API_KEY")
    }

    # Option 2: Secret management services
    # Use AWS Secrets Manager, HashiCorp Vault, etc.
    # from your_secret_manager import get_secret
    # credentials = {"PASSWORD": get_secret("app_password")}

    agent = DroidAgent(goal="...", credentials=credentials)
    ```

    **Always** add `credentials.yaml` to `.gitignore`:

    ```bash
    # .gitignore
    credentials.yaml
    credentials_*.yaml
    *.credentials.yaml
    ```
  </Accordion>

  <Accordion title="5. Git Ignore (Required)">
    **Always** add credential files to `.gitignore`:

    ```bash
    # .gitignore
    credentials.yaml
    credentials_*.yaml
    *.credentials.yaml
    .env
    secrets/
    ```

    Never commit secrets to version control!
  </Accordion>
</AccordionGroup>

---

## Combining Custom Tools and Credentials

Custom tools can access credentials via the credential manager attached to the `tool_instance`:

```python
#!/usr/bin/env python3
import asyncio
import requests
from droidrun import AdbTools, DroidAgent
from llama_index.llms.google_genai import GoogleGenAI

def send_authenticated_webhook(tool_instance, url: str, data: str) -> str:
    """
    Send data to webhook with API key authentication.

    Args:
        tool_instance: Tools instance (required first parameter)
        url: Webhook URL
        data: Data to send

    Returns:
        Result message
    """
    try:
        # Access credential manager from tools instance
        if not hasattr(tool_instance, 'credential_manager') or tool_instance.credential_manager is None:
            return "Error: Credential manager not available"

        # Get API key from credential manager
        api_key = tool_instance.credential_manager.get_credential("WEBHOOK_API_KEY")

        # Send authenticated request
        headers = {"Authorization": f"Bearer {api_key}"}
        response = requests.post(url, json={"data": data}, headers=headers, timeout=10)
        response.raise_for_status()

        return f"Webhook sent successfully. Status: {response.status_code}"
    except Exception as e:
        return f"Error: {str(e)}"

async def main():
    # Define credentials
    credentials = {
        "WEBHOOK_API_KEY": "sk-webhook-secret-key",
        "EMAIL_PASSWORD": "email_pass_123"
    }

    # Define custom tool
    custom_tools = {
        "send_authenticated_webhook": {
            "arguments": ["url", "data"],
            "description": 'Send authenticated webhook. Usage: {"action": "send_authenticated_webhook", "url": "https://api.example.com/webhook", "data": "message"}',
            "function": send_authenticated_webhook,
        }
    }

    tools = AdbTools()
    llm = GoogleGenAI(model="models/gemini-2.5-flash")

    agent = DroidAgent(
        goal="Check my unread Gmail count and send to webhook https://api.example.com/webhook",
        llm=llm,
        tools=tools,
        credentials=credentials,
        custom_tools=custom_tools
    )

    result = await agent.run()
    print(f"Success: {result.success}")

if __name__ == "__main__":
    asyncio.run(main())
```

---

## Custom Variables vs Credentials

DroidRun supports both **credentials** (sensitive) and **variables** (non-sensitive):

| Feature | Credentials | Variables |
|---------|------------|-----------|
| **Purpose** | Passwords, API keys, secrets | Non-sensitive data (emails, names, config) |
| **Storage** | YAML file or in-memory dict | In-memory dict only |
| **Logging** | Never logged (only secret IDs) | May appear in logs/prompts |
| **Access** | Via `type_secret` tool | Directly in shared state |
| **Security** | Protected, sanitized errors | No special protection |

**Example: Using Variables**
```python
import asyncio
from droidrun import AdbTools, DroidAgent
from llama_index.llms.google_genai import GoogleGenAI

async def main():
    # Define custom variables (non-sensitive data)
    variables = {
        "target_email": "john@example.com",
        "subject_line": "Monthly Report",
        "cc_recipients": ["alice@example.com", "bob@example.com"]
    }

    tools = AdbTools()
    llm = GoogleGenAI(model="models/gemini-2.5-flash")

    agent = DroidAgent(
        goal="Compose email to {{target_email}} with subject {{subject_line}}",
        llm=llm,
        tools=tools,
        variables=variables  # Pass non-sensitive variables
    )

    result = await agent.run()
    print(result.success, result.reason)

asyncio.run(main())
```

**When to use:**
- Use **credentials** for passwords, API keys, tokens (sensitive)
- Use **variables** for emails, names, configuration (non-sensitive)

---

## CLI Usage

### With Configuration File

```bash
# Enable credentials in config.yaml
# credentials:
#   enabled: true
#   file_path: credentials.yaml

droidrun run "Login to my Gmail account" --provider GoogleGenAI --model gemini-2.5-flash
```

### With Custom Tools (SDK Only)

Custom tools and programmatic credentials are only available via the SDK (not CLI).

---

## Troubleshooting

<AccordionGroup>
  <Accordion title="Error: Credential manager not initialized">
    **Cause**: Credentials not enabled or file not found

    **Solution**:
    ```yaml
    # config.yaml
    credentials:
      enabled: true  # Must be true
      file_path: credentials.yaml  # Check path is correct
    ```

    Or pass credentials programmatically:
    ```python
    agent = DroidAgent(..., credentials={"PASSWORD": "secret"})
    ```
  </Accordion>

  <Accordion title="Error: Secret 'X' not found">
    **Cause**: Secret ID doesn't exist or is disabled

    **Solution**:
    ```python
    from droidrun.credential_manager import CredentialManager

    cm = CredentialManager(credentials_path="credentials.yaml")
    print(cm.list_available_secrets())  # Check available secrets
    ```

    Check `credentials.yaml`:
    ```yaml
    secrets:
      X:
        value: "your_value"
        enabled: true  # Must be true
    ```
  </Accordion>

  <Accordion title="Custom tool not working">
    **Cause**: Tool not registered or incorrect signature

    **Solution**:
    1. Check tool signature has `tool_instance` as first param:
       ```python
       def my_tool(tool_instance, arg1: str) -> str:  # â Correct
           pass

       def my_tool(arg1: str) -> str:  # â Wrong
           pass
       ```

    2. Verify custom_tools format:
       ```python
       custom_tools = {
           "tool_name": {
               "arguments": ["arg1"],
               "description": "...",
               "function": my_tool  # Function reference, not call
           }
       }
       ```

    3. Check agent received custom tools:
       ```python
       agent = DroidAgent(..., custom_tools=custom_tools)  # Pass here
       ```
  </Accordion>

  <Accordion title="Agent not using custom tool">
    **Cause**: LLM doesn't understand tool description

    **Solution**: Improve description with clear usage example:
    ```python
    # Bad
    "description": "Send webhook"

    # Good
    "description": 'Send POST request to webhook. Usage: {"action": "send_webhook", "url": "https://webhook.site/abc123", "data": "your message"}'
    ```
  </Accordion>
</AccordionGroup>

---

## API Reference

For more technical details:

### Custom Tools
- Implementation: `droidrun/agent/utils/tools.py` â `build_custom_tools()`
- Format: `{"tool_name": {"arguments": [...], "description": "...", "function": callable}}`
- Used in: `DroidAgent`, `CodeActAgent`, `ExecutorAgent`, `ManagerAgent`

### Credential Manager
- Implementation: `droidrun/credential_manager/credential_manager.py`
- Loader: `droidrun/credential_manager/credential_loader.py` â `load_credential_manager()`
- Type Secret Tool: `droidrun/agent/utils/tools.py` â `type_secret()`, `build_credential_tools()`

### DroidAgent Parameters
```python
DroidAgent(
    goal: str,
    custom_tools: dict = None,  # Custom tool definitions
    credentials: CredentialsConfig | dict | None = None,  # Credentials config or direct dict
    variables: dict | None = None,  # Non-sensitive variables
    # ... other parameters
)
```

---

## Next Steps

- Learn about [Agent Architecture](/v4/concepts/architecture)
- Explore [DroidAgent SDK Reference](/v4/sdk/droid-agent)
- See [Configuration Guide](/v4/guides/configuration)
