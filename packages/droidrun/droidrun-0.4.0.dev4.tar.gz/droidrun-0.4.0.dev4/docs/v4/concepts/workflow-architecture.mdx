---
title: 'Workflow Architecture'
description: 'Deep dive into DroidRun multi-agent workflow system and event-driven coordination patterns'
---

## Overview

DroidRun uses a hierarchical multi-agent architecture built on **LlamaIndex Workflows**, where specialized agents coordinate through event-driven communication. The system supports two execution modes: **Direct Execution** (single agent) and **Reasoning Mode** (multi-agent coordination).

```
┌─────────────────────────────────────────────────────────────┐
│                        DroidAgent                           │
│                    (Main Orchestrator)                      │
│                                                             │
│  ┌─────────────────┐              ┌───────────────────┐   │
│  │ Direct Mode     │              │ Reasoning Mode    │   │
│  │                 │              │                   │   │
│  │ CodeActAgent    │              │ Manager/Executor  │   │
│  │    (fast)       │              │   + Scripter      │   │
│  └─────────────────┘              └───────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

---

## Core Components

### DroidAgent (Main Orchestrator)

The top-level workflow that routes between execution modes and manages shared state.

**Key Responsibilities:**
- Initialize all child agents (Manager, Executor, CodeAct, Scripter)
- Route between direct execution and reasoning workflows
- Maintain shared state (`DroidAgentState`) across all agents
- Stream events to frontend/CLI
- Handle structured output extraction (if output model provided)

**Location:** `/droidrun/agent/droid/droid_agent.py`

---

## Execution Modes

### Direct Execution Mode (`reasoning=False`)

Simple, fast execution for single-task operations using CodeActAgent.

```
StartEvent
    ↓
start_handler() → CodeActExecuteEvent
    ↓
execute_task() → CodeActResultEvent
    ↓
handle_codeact_execute() → FinalizeEvent
    ↓
finalize() → StopEvent (result)
```

**When to Use:**
- Simple 1-5 step tasks
- Direct UI automation
- No planning/reasoning needed
- Fast execution priority

**Example:**
```python
from droidrun.config_manager.config_manager import DroidRunConfig
from droidrun.agent.droid.droid_agent import DroidAgent

config = DroidRunConfig()

agent = DroidAgent(
    goal="Open Settings app",
    config=config,
    llms=llm,
    reasoning=False  # Direct mode
)
```

---

### Reasoning Mode (`reasoning=True`)

Multi-agent workflow with planning (Manager) and execution (Executor) coordination.

```
StartEvent
    ↓
start_handler() → ManagerInputEvent
    ↓
┌─────────────────────────────────────────────┐
│         Manager/Executor Loop               │
│                                             │
│  run_manager() → ManagerPlanEvent           │
│         ↓                                   │
│  handle_manager_plan()                      │
│         ↓                                   │
│  ┌──────────────────────────────────┐      │
│  │ ExecutorInputEvent               │      │
│  │  ↓                               │      │
│  │ run_executor() → ExecutorResultEvent    │
│  │  ↓                               │      │
│  │ handle_executor_result()         │      │
│  │  ↓                               │      │
│  │ Loop back to ManagerInputEvent   │      │
│  └──────────────────────────────────┘      │
│                                             │
│  OR                                         │
│                                             │
│  ┌──────────────────────────────────┐      │
│  │ ScripterExecutorInputEvent       │      │
│  │  ↓                               │      │
│  │ run_scripter() → ScripterResultEvent    │
│  │  ↓                               │      │
│  │ handle_scripter_result()         │      │
│  │  ↓                               │      │
│  │ Loop back to ManagerInputEvent   │      │
│  └──────────────────────────────────┘      │
│                                             │
└─────────────────────────────────────────────┘
    ↓
FinalizeEvent → finalize() → StopEvent
```

**When to Use:**
- Complex multi-step tasks (10-50+ steps)
- Tasks requiring planning and subgoals
- Error recovery and adaptive planning
- Multi-app workflows

**Example:**
```python
from droidrun.config_manager.config_manager import DroidRunConfig
from droidrun.agent.droid.droid_agent import DroidAgent

config = DroidRunConfig()

agent = DroidAgent(
    goal="Find cheapest hotel in Manhattan, compare prices, share on Slack",
    config=config,
    llms={"manager": manager_llm, "executor": executor_llm},
    reasoning=True  # Reasoning mode
)
```

---

## Agent Deep Dive

### ManagerAgent (Planning Agent)

Plans high-level strategy and breaks down tasks into subgoals.

**Workflow Steps:**

1. **`prepare_input()`**
   - Get device state via `tools.get_state()`
   - Format device state (UI tree, phone state)
   - Update shared state
   - Start background app card loading
   - Capture screenshot if vision enabled
   - Detect text manipulation mode
   - Build user message with action context

2. **`think()`**
   - Build system prompt with context:
     - Instruction, app card, error history
     - Custom tools, scripter config
     - Available secrets, variables
     - Output schema (if structured output enabled)
   - Inject device state + memory + screenshot into messages
   - Call LLM with retry logic
   - Validate response (plan/answer rules)
   - Parse response for plan, subgoal, thought, answer
   - Update shared state memory
   - Append to message history

3. **`finalize()`**
   - Return plan, subgoal, thought, answer to DroidAgent

**Key Features:**
- **App Card Integration**: Loads app-specific instructions in background
- **Error Escalation**: Tracks consecutive errors, sets `error_flag_plan`
- **Answer-Type Tasks**: Can provide direct answers via `<request_accomplished>` tag
- **Script Routing**: Detects `<script>` tags and routes to ScripterAgent
- **Memory Management**: Accumulates memory across planning cycles

**Location:** `/droidrun/agent/manager/manager_agent.py`

---

### ExecutorAgent (Action Execution Agent)

Selects and executes specific atomic actions for each subgoal.

**Workflow Steps:**

1. **`think()`**
   - Build system prompt with:
     - Current subgoal, plan, device state
     - Available atomic actions + custom tools
     - Action history (last 5 actions)
     - Available secrets, variables
   - Add screenshot if vision enabled
   - Call LLM
   - Parse response for action, thought, description
   - Stream `ExecutorInternalActionEvent`

2. **`execute()`**
   - Parse action JSON
   - Route to appropriate action handler:
     - Atomic actions: `click`, `type`, `swipe`, `system_button`, `long_press`, `open_app`
     - Custom tools: Execute via `self.custom_tools`
   - Validate parameters
   - Execute action via `tools_instance`
   - Return outcome (success/fail), error, summary
   - Stream `ExecutorInternalResultEvent`

3. **`finalize()`**
   - Return action, outcome, error, summary to DroidAgent

**Action Execution Pattern:**
```python
# Atomic action example
if action_type == "click":
    index = action_dict.get("index")
    result = click(self.tools_instance, index)
    return True, "None", f"Clicked element at index {index}"

# Custom tool example
if action_type in self.custom_tools:
    tool_func = self.custom_tools[action_type]["function"]
    result = await tool_func(self.tools_instance, **tool_args)
    return True, "None", f"Executed custom tool '{action_type}': {result}"
```

**Location:** `/droidrun/agent/executor/executor_agent.py`

---

### CodeActAgent (Direct Execution Agent)

ReAct-style agent that generates and executes Python code using atomic actions.

**Workflow Steps:**

1. **`prepare_chat()`**
   - Initialize chat memory
   - Load system prompt with tool descriptions
   - Format user message with goal
   - Add to memory

2. **`handle_llm_input()`**
   - Check max steps
   - Add memory block if remembered info exists
   - Capture screenshot (always for trajectory)
   - Get device state and format
   - Add device state to chat
   - Call LLM
   - Extract code + thoughts
   - Stream `TaskThinkingEvent`

3. **`handle_llm_output()`**
   - Validate thoughts exist (warn if missing)
   - If code exists → `TaskExecutionEvent`
   - If no code → add prompt reminder, loop back

4. **`execute_code()`**
   - Execute code via `SimpleCodeExecutor`
   - Check if `complete()` was called → `TaskEndEvent`
   - Otherwise → `TaskExecutionResultEvent` with output

5. **`handle_execution_result()`**
   - Add observation to chat history
   - Loop back to `handle_llm_input()`

6. **`finalize()`**
   - Add final state observation to episodic memory
   - Return success, reason, code_executions

**Code Execution Example:**
```python
# Agent generates:
click(5)  # Click element at index 5
type("Hello", 3)  # Type into element 3
system_button("back")  # Press back button
remember("User logged in")  # Save info
complete(True, "Task finished")  # Mark done
```

**Key Features:**
- **Tool List**: Atomic actions + `remember()` + `complete()`
- **Safe Execution**: Optional import/builtin restrictions
- **Episodic Memory**: Tracks chat history + screenshots
- **Vision Support**: Screenshots added to chat if enabled

**Location:** `/droidrun/agent/codeact/codeact_agent.py`

---

### ScripterAgent (Off-Device Operations)

ReAct agent for Python script execution without device interaction.

**Workflow Steps:**

1. **`prepare_chat()`**
   - Load system prompt with task description
   - Add available libraries (requests, json, etc.)
   - Initialize message history

2. **`handle_llm_input()`**
   - Check max steps
   - Call LLM
   - Extract code + thoughts
   - Stream `ScripterThinkingEvent`

3. **`handle_llm_output()`**
   - If code exists → `ScripterExecutionEvent`
   - If no code → treat as final answer → `ScripterEndEvent`

4. **`execute_code()`**
   - Execute code via `SimpleCodeExecutor`
   - Variables persist across executions (Jupyter-style)
   - Stream `ScripterExecutionResultEvent`

5. **`handle_execution_result()`**
   - Add execution result to chat
   - Loop back to `handle_llm_input()`

6. **`finalize()`**
   - Return message, success, code_executions

**When Manager Routes to Scripter:**
```python
# Manager detects <script> tag in plan:
<script>
Fetch weather data for Manhattan from OpenWeatherMap API,
calculate average temperature, return formatted string
</script>

# DroidAgent routes to ScripterAgent
# Scripter executes code without device tools
# Result stored in shared_state.last_scripter_message
# Manager receives result in next cycle
```

**Key Features:**
- **No Device Tools**: Only Python libraries
- **State Preservation**: Variables persist across code blocks
- **Completion Signal**: No code = final answer
- **Safe Execution**: Optional restrictions (same as CodeAct)

**Location:** `/droidrun/agent/scripter/scripter_agent.py`

---

## Event System

### Event Types

DroidRun uses two categories of events:

1. **Coordination Events** (`droid/events.py`)
   - Minimal data for workflow routing
   - Used by DroidAgent to orchestrate agents
   - Examples: `ManagerInputEvent`, `ExecutorResultEvent`, `CodeActExecuteEvent`

2. **Internal Events** (per-agent `events.py`)
   - Full debug metadata
   - Streamed to frontend/CLI for monitoring
   - Examples: `ManagerInternalPlanEvent`, `ExecutorInternalActionEvent`, `TaskThinkingEvent`

### Event Flow Diagram

```
┌──────────────────────────────────────────────────────────────┐
│                      DroidAgent Events                       │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│  StartEvent                                                  │
│      ↓                                                       │
│  ManagerInputEvent (coordination)                            │
│      ↓                                                       │
│  ┌────────────────────────────────────────────────┐         │
│  │         ManagerAgent (nested workflow)         │         │
│  │                                                │         │
│  │  ManagerThinkingEvent (internal, streamed)     │         │
│  │      ↓                                         │         │
│  │  ManagerInternalPlanEvent (internal, streamed) │         │
│  │      ↓                                         │         │
│  │  StopEvent → result returned to parent        │         │
│  └────────────────────────────────────────────────┘         │
│      ↓                                                       │
│  ManagerPlanEvent (coordination)                             │
│      ↓                                                       │
│  ExecutorInputEvent (coordination)                           │
│      ↓                                                       │
│  ┌────────────────────────────────────────────────┐         │
│  │         ExecutorAgent (nested workflow)        │         │
│  │                                                │         │
│  │  ExecutorInternalActionEvent (internal)        │         │
│  │      ↓                                         │         │
│  │  ExecutorInternalResultEvent (internal)        │         │
│  │      ↓                                         │         │
│  │  StopEvent → result returned to parent        │         │
│  └────────────────────────────────────────────────┘         │
│      ↓                                                       │
│  ExecutorResultEvent (coordination)                          │
│      ↓                                                       │
│  Loop back to ManagerInputEvent                              │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

### Coordination Events

| Event | Source | Target | Purpose |
|-------|--------|--------|---------|
| `StartEvent` | Workflow start | `start_handler()` | Initialize execution |
| `ManagerInputEvent` | Various | `run_manager()` | Trigger Manager planning |
| `ManagerPlanEvent` | `run_manager()` | `handle_manager_plan()` | Route plan to execution |
| `ExecutorInputEvent` | `handle_manager_plan()` | `run_executor()` | Trigger Executor action |
| `ExecutorResultEvent` | `run_executor()` | `handle_executor_result()` | Process action result |
| `ScripterExecutorInputEvent` | `handle_manager_plan()` | `run_scripter()` | Trigger Scripter |
| `ScripterExecutorResultEvent` | `run_scripter()` | `handle_scripter_result()` | Process script result |
| `CodeActExecuteEvent` | `start_handler()` | `execute_task()` | Direct execution task |
| `CodeActResultEvent` | `execute_task()` | `handle_codeact_execute()` | CodeAct result |
| `FinalizeEvent` | Various | `finalize()` | Complete workflow |
| `StopEvent` | `finalize()` | Workflow end | Return final result |

### Internal Events (Streamed)

| Event | Agent | Purpose | Fields |
|-------|-------|---------|--------|
| `ManagerThinkingEvent` | Manager | Manager is thinking | - |
| `ManagerInternalPlanEvent` | Manager | Plan created | plan, subgoal, thought, answer, memory_update |
| `ExecutorInternalActionEvent` | Executor | Action selected | action_json, thought, description |
| `ExecutorInternalResultEvent` | Executor | Action completed | action, outcome, error, summary, thought |
| `TaskInputEvent` | CodeAct | LLM input ready | input (messages) |
| `TaskThinkingEvent` | CodeAct | LLM response received | thoughts, code, usage |
| `TaskExecutionEvent` | CodeAct | Code ready for execution | code |
| `TaskExecutionResultEvent` | CodeAct | Code executed | output |
| `TaskEndEvent` | CodeAct | Task complete | success, reason |
| `ScripterThinkingEvent` | Scripter | Scripter thinking | thoughts, code, full_response |
| `ScripterExecutionEvent` | Scripter | Script executing | code |
| `ScripterExecutionResultEvent` | Scripter | Script completed | output |
| `ScripterEndEvent` | Scripter | Scripter done | message, success, code_executions |

---

## Shared State Management

### DroidAgentState

Central coordination state shared across all agents.

**Location:** `/droidrun/agent/droid/events.py`

**Key Fields:**

```python
class DroidAgentState(BaseModel):
    # Task Context
    instruction: str                      # User goal
    step_number: int                      # Current step

    # Device State
    formatted_device_state: str           # UI tree + phone state (formatted)
    a11y_tree: List[Dict]                 # Raw accessibility tree
    phone_state: Dict                     # Raw phone state
    focused_text: str                     # Currently focused text element
    width: int, height: int               # Screen dimensions
    screenshot: str | bytes | None        # Screenshot data

    # App Context
    app_card: str                         # App-specific instructions
    current_package_name: str             # Current app package
    current_activity_name: str            # Current activity
    visited_packages: set                 # Unique packages visited
    visited_activities: set               # Unique activities visited

    # Action History
    action_history: List[Dict]            # All actions taken
    summary_history: List[str]            # Action summaries
    action_outcomes: List[bool]           # Success/failure
    error_descriptions: List[str]         # Error messages
    last_action: Dict                     # Most recent action
    last_summary: str                     # Most recent summary
    last_action_thought: str              # LLM reasoning

    # Planning
    plan: str                             # Current plan
    current_subgoal: str                  # Active subgoal
    progress_status: str                  # Progress description
    manager_answer: str                   # Answer for answer-type tasks

    # Error Handling
    error_flag_plan: bool                 # Error escalation flag
    err_to_manager_thresh: int            # Consecutive errors before escalation

    # Memory
    memory: str                           # Accumulated agent memory
    message_history: List[Dict]           # Chat history (Manager)

    # Script Execution
    scripter_history: List[Dict]          # Script execution records
    last_scripter_message: str            # Most recent script result
    last_scripter_success: bool           # Script success status

    # Custom Extensions
    custom_variables: Dict                # User-defined variables
```

**State Update Patterns:**

```python
# Update device state (Manager/CodeAct)
state = tools.get_state()
formatted_text, focused_text, a11y_tree, phone_state = format_device_state(state)
shared_state.formatted_device_state = formatted_text
shared_state.a11y_tree = a11y_tree
shared_state.phone_state = phone_state

# Update current app (unified method)
shared_state.update_current_app(
    package_name="com.example.app",
    activity_name="MainActivity"
)

# Update action history (Executor)
shared_state.action_history.append(action)
shared_state.action_outcomes.append(outcome)
shared_state.error_descriptions.append(error)

# Update memory (Manager)
if memory_update:
    shared_state.memory += "\n" + memory_update

# Update scripter result (Scripter)
shared_state.last_scripter_message = result["message"]
shared_state.last_scripter_success = result["success"]
```

---

## Workflow Step Patterns

### The `@step` Decorator

LlamaIndex workflows use the `@step` decorator to define workflow handlers.

**Basic Pattern:**
```python
from llama_index.core.workflow import Context, step

@step
async def step_name(self, ctx: Context, ev: InputEvent) -> OutputEvent:
    """Step handler that processes InputEvent and returns OutputEvent."""
    # 1. Extract data from event
    data = ev.some_field

    # 2. Perform operations
    result = await some_operation(data)

    # 3. Update context (optional)
    await ctx.store.set("key", value)

    # 4. Stream events to frontend (optional)
    ctx.write_event_to_stream(some_event)

    # 5. Return next event
    return OutputEvent(result=result)
```

**Event Routing:**
- Workflow automatically routes events to matching step handlers
- Handler signature determines which events it receives: `ev: EventType`
- Return value determines next step(s) to execute

---

### Nested Workflow Pattern

DroidAgent runs child agents as nested workflows.

**Pattern:**
```python
@step
async def run_manager(self, ctx: Context, ev: ManagerInputEvent) -> ManagerPlanEvent:
    """Run Manager as nested workflow and stream its events."""

    # 1. Start child workflow
    handler = self.manager_agent.run()

    # 2. Stream all nested events to parent context
    async for nested_ev in handler.stream_events():
        self.handle_stream_event(nested_ev, ctx)

    # 3. Await final result
    result = await handler

    # 4. Return coordination event to parent
    return ManagerPlanEvent(
        plan=result["plan"],
        current_subgoal=result["current_subgoal"]
    )
```

**Why Nested Workflows?**
- **Modularity**: Each agent is self-contained
- **Event Isolation**: Internal events don't pollute parent
- **Streaming**: All child events forwarded to frontend
- **Error Handling**: Child failures can be caught and handled

---

### Loop Pattern (Manager/Executor Cycle)

Manager and Executor continuously loop until task completion.

```python
# Manager plans → Executor acts → Manager re-plans → Executor acts → ...

@step
async def run_manager(self, ctx: Context, ev: ManagerInputEvent) -> ManagerPlanEvent | FinalizeEvent:
    """Pre-flight check, then run Manager."""

    # Pre-flight: Check max steps
    if self.shared_state.step_number >= self.config.agent.max_steps:
        return FinalizeEvent(success=False, reason="Max steps reached")

    # Run Manager workflow (nested)
    handler = self.manager_agent.run()
    async for nested_ev in handler.stream_events():
        self.handle_stream_event(nested_ev, ctx)
    result = await handler

    return ManagerPlanEvent(plan=result["plan"], current_subgoal=result["current_subgoal"])

@step
async def handle_manager_plan(self, ctx: Context, ev: ManagerPlanEvent) -> ExecutorInputEvent | FinalizeEvent:
    """Route Manager plan to Executor or finish."""

    # Check if Manager provided answer (task complete)
    if ev.manager_answer.strip():
        return FinalizeEvent(success=True, reason=ev.manager_answer)

    # Check if <script> tag (route to Scripter)
    if "<script>" in ev.current_subgoal:
        # Extract script content...
        return ScripterExecutorInputEvent(task=script_content)

    # Normal case: execute subgoal
    return ExecutorInputEvent(current_subgoal=ev.current_subgoal)

@step
async def run_executor(self, ctx: Context, ev: ExecutorInputEvent) -> ExecutorResultEvent:
    """Run Executor workflow."""
    handler = self.executor_agent.run(subgoal=ev.current_subgoal)
    async for nested_ev in handler.stream_events():
        self.handle_stream_event(nested_ev, ctx)
    result = await handler

    # Update shared state
    self.shared_state.action_history.append(result["action"])
    self.shared_state.action_outcomes.append(result["outcome"])

    return ExecutorResultEvent(action=result["action"], outcome=result["outcome"])

@step
async def handle_executor_result(self, ctx: Context, ev: ExecutorResultEvent) -> ManagerInputEvent:
    """Process Executor result and loop back to Manager."""

    # Check error escalation
    if len(self.shared_state.action_outcomes) >= thresh:
        latest = self.shared_state.action_outcomes[-thresh:]
        if all(not outcome for outcome in latest):
            self.shared_state.error_flag_plan = True

    # Increment step counter
    self.shared_state.step_number += 1

    # Loop back to Manager
    return ManagerInputEvent()
```

**Loop Termination:**
- Max steps reached (pre-flight check in `run_manager()`)
- Manager returns answer (detected in `handle_manager_plan()`)
- Error recovery exhausted

---

### Streaming Events to Frontend

Events are streamed via `ctx.write_event_to_stream()`.

**Pattern:**
```python
@step
async def think(self, ctx: Context, ev: StartEvent) -> ThinkingEvent:
    """Call LLM and stream result."""

    # Call LLM
    response = await self.llm.achat(messages)

    # Parse response
    parsed = parse_response(response.message.content)

    # Create event
    event = ThinkingEvent(
        thought=parsed["thought"],
        code=parsed["code"]
    )

    # Stream to frontend (CLI/web interface receives this)
    ctx.write_event_to_stream(event)

    return event
```

**Frontend Integration:**
```python
# Running DroidAgent with event streaming
handler = agent.run()

async for event in handler.stream_events():
    if isinstance(event, ManagerInternalPlanEvent):
        print(f"Plan: {event.plan}")
    elif isinstance(event, ExecutorInternalActionEvent):
        print(f"Action: {event.description}")
    elif isinstance(event, TaskThinkingEvent):
        print(f"Thoughts: {event.thoughts}")

result = await handler
```

---

## Error Handling Patterns

### Error Escalation (Manager/Executor)

When Executor fails repeatedly, error escalates to Manager.

```python
# ExecutorAgent reports outcome
return ExecutorResultEvent(outcome=False, error="Element not found")

# DroidAgent tracks consecutive errors
@step
async def handle_executor_result(self, ctx: Context, ev: ExecutorResultEvent) -> ManagerInputEvent:
    thresh = self.shared_state.err_to_manager_thresh

    if len(self.shared_state.action_outcomes) >= thresh:
        latest = self.shared_state.action_outcomes[-thresh:]
        error_count = sum(1 for o in latest if not o)

        if error_count == thresh:
            # Set error flag for Manager to see
            self.shared_state.error_flag_plan = True
        else:
            # Errors resolved
            self.shared_state.error_flag_plan = False

    return ManagerInputEvent()

# Manager sees error flag in next planning cycle
@step
async def think(self, ctx: Context, ev: ManagerThinkingEvent) -> ManagerInternalPlanEvent:
    # Build system prompt with error context
    error_history = None
    if self.shared_state.error_flag_plan:
        k = self.shared_state.err_to_manager_thresh
        error_history = [
            {"action": act, "summary": summ, "error": err}
            for act, summ, err in zip(
                self.shared_state.action_history[-k:],
                self.shared_state.summary_history[-k:],
                self.shared_state.error_descriptions[-k:]
            )
        ]

    system_prompt = build_prompt(error_history=error_history)
    # ... Manager re-plans with error awareness
```

### LLM Retry Logic

All agents use `acall_with_retries()` for robust LLM calls.

```python
from droidrun.agent.utils.inference import acall_with_retries

# Automatic retry with exponential backoff
response = await acall_with_retries(self.llm, messages)
```

### Validation and Re-prompting (Manager)

Manager validates its own output and retries if invalid.

```python
@step
async def think(self, ctx: Context, ev: ManagerThinkingEvent) -> ManagerInternalPlanEvent:
    # Initial LLM call
    response = await acall_with_retries(self.llm, messages)
    output = response.message.content

    # Validate and retry if needed
    output = await self._validate_and_retry_llm_call(ctx, messages, output)

    return event

async def _validate_and_retry_llm_call(self, ctx, initial_messages, initial_response):
    parsed = parse_manager_response(initial_response)

    max_retries = 3
    retry_count = 0

    while retry_count < max_retries:
        # Validation rules
        error_message = None

        if parsed["answer"] and parsed["plan"]:
            error_message = "Cannot use both answer and plan. Choose one."
        elif not parsed["plan"] and not parsed["answer"]:
            error_message = "Must provide either plan or answer."
        else:
            break  # Valid

        if error_message:
            retry_count += 1

            # Add error message and retry
            retry_messages = initial_messages + [
                {"role": "assistant", "content": [{"text": initial_response}]},
                {"role": "user", "content": [{"text": error_message}]}
            ]

            response = await acall_with_retries(self.llm, retry_messages)
            initial_response = response.message.content
            parsed = parse_manager_response(initial_response)

    return initial_response
```

---

## Best Practices

### Extending the Workflow

**Adding a New Agent:**

1. Create agent class extending `Workflow`
2. Define workflow steps with `@step` decorator
3. Define coordination events in `droid/events.py`
4. Add step handler in `DroidAgent` to run nested workflow
5. Update shared state as needed

**Example: Custom analysis agent**
```python
# 1. Create agent
class AnalyzerAgent(Workflow):
    @step
    async def analyze(self, ctx: Context, ev: StartEvent) -> AnalyzerResultEvent:
        # Analysis logic
        return AnalyzerResultEvent(result=analysis)

# 2. Define events
class AnalyzerInputEvent(Event):
    task: str

class AnalyzerResultEvent(Event):
    result: str

# 3. Add to DroidAgent
@step
async def run_analyzer(self, ctx: Context, ev: AnalyzerInputEvent) -> AnalyzerResultEvent:
    handler = self.analyzer_agent.run()
    async for nested_ev in handler.stream_events():
        self.handle_stream_event(nested_ev, ctx)
    result = await handler
    return AnalyzerResultEvent(result=result["result"])
```

---

### Custom Tools Integration

Custom tools are automatically available in all agents.

**Define custom tool:**
```python
from droidrun.config_manager.config_manager import DroidRunConfig
from droidrun.agent.droid.droid_agent import DroidAgent

def custom_action(tools_instance, param1: str, param2: int) -> str:
    """Custom action description."""
    # Implementation
    return f"Executed with {param1}, {param2}"

custom_tools = {
    "custom_action": {
        "signature": "custom_action(param1: str, param2: int) -> str",
        "description": "Custom action description",
        "function": custom_action
    }
}

config = DroidRunConfig()

agent = DroidAgent(
    goal="Use custom action",
    config=config,
    llms=llm,
    custom_tools=custom_tools
)
```

**ExecutorAgent automatically includes custom tools:**
```python
# In ExecutorAgent.__init__()
merged_signatures = {**atomic_tools, **(custom_tools or {})}
self.all_actions = merged_signatures

# In ExecutorAgent.execute()
if action_type in self.custom_tools:
    return await self._execute_custom_tool(action_type, action_dict)
```

**CodeActAgent adds to tool list:**
```python
# In CodeActAgent.__init__()
for action_name, signature in merged_signatures.items():
    func = signature["function"]
    self.tool_list[action_name] = lambda *args, f=func, **kwargs: f(tools_instance, *args, **kwargs)
```

---

### State Persistence

Shared state persists across all workflow steps.

```python
# Manager updates memory
self.shared_state.memory += "\n" + new_memory

# Executor reads memory (via CodeAct)
remembered_info = self.tools_instance.memory

# Scripter result persists for Manager
self.shared_state.last_scripter_message = result["message"]

# Manager reads scripter result in next cycle
if self.shared_state.last_scripter_message:
    # Add to prompt context
    script_result = self.shared_state.last_scripter_message
```

---

### Performance Optimization

**1. Background App Card Loading**
```python
# Start loading in background
loading_task = asyncio.create_task(
    self.app_card_provider.load_app_card(package_name, instruction)
)
self.shared_state.app_card_loading_task = loading_task

# Wait with timeout in next cycle
try:
    app_card = await asyncio.wait_for(loading_task, timeout=0.1)
except asyncio.TimeoutError:
    app_card = ""  # Use empty if not ready
```

**2. Tool Wrapping for Async Context**
```python
# In DroidAgent.start_handler() for direct mode
if not self.config.agent.reasoning:
    self.atomic_tools = wrap_async_tools(self.atomic_tools)
    self.custom_tools = wrap_async_tools(self.custom_tools)
```

**3. Message History Limiting**
```python
# In CodeActAgent
def _limit_history(self, chat_history):
    max_messages = LLM_HISTORY_LIMIT * 2
    if len(chat_history) <= max_messages:
        return chat_history

    # Preserve first message (goal)
    preserved_head = [chat_history[0]] if chat_history else []
    tail = chat_history[-max_messages:]

    return preserved_head + tail
```

---

## Debugging Workflows

### Enable Debug Logging

```python
from droidrun.config_manager.config_manager import DroidRunConfig
from droidrun.agent.droid.droid_agent import DroidAgent

config = DroidRunConfig()
config.logging.debug = True

agent = DroidAgent(goal="...", config=config, llms=llm)
```

### Enable Tracing (Arize Phoenix)

```python
from droidrun.config_manager.config_manager import DroidRunConfig
from droidrun.agent.droid.droid_agent import DroidAgent

config = DroidRunConfig()
config.tracing.enabled = True

# Traces viewable at http://localhost:6006
agent = DroidAgent(goal="...", config=config, llms=llm)
```

### Stream Events for Monitoring

```python
handler = agent.run()

async for event in handler.stream_events():
    print(f"{event.__class__.__name__}: {event}")

result: ResultEvent = await handler
```

### Save Trajectories

```python
from droidrun.config_manager.config_manager import DroidRunConfig
from droidrun.agent.droid.droid_agent import DroidAgent

config = DroidRunConfig()
config.logging.save_trajectory = "action"  # "none", "step", or "action"

# Trajectories saved to output directory with screenshots
agent = DroidAgent(goal="...", config=config, llms=llm)
```

---

## Advanced Patterns

### Structured Output Extraction

DroidAgent supports extracting structured data after task completion.

```python
from pydantic import BaseModel
from droidrun.config_manager.config_manager import DroidRunConfig
from droidrun.agent.droid.droid_agent import DroidAgent

class HotelInfo(BaseModel):
    name: str
    price: float
    rating: float

config = DroidRunConfig()

agent = DroidAgent(
    goal="Find cheapest hotel in Manhattan",
    config=config,
    llms=llms,
    output_model=HotelInfo  # Pydantic model
)

handler = agent.run()
result: ResultEvent = await handler

# result.structured_output contains HotelInfo instance
hotel: HotelInfo = result.structured_output
print(f"{hotel.name}: ${hotel.price}, {hotel.rating}★")
```

**How It Works:**
1. Task completes normally (Manager returns answer)
2. `finalize()` step instantiates `StructuredOutputAgent`
3. Structured agent uses LLM to extract data from answer text
4. Returns Pydantic instance in result

---

### Custom Variables

Pass custom variables accessible to all agents.

```python
from droidrun.config_manager.config_manager import DroidRunConfig
from droidrun.agent.droid.droid_agent import DroidAgent

variables = {
    "user_email": "user@example.com",
    "api_key": "secret123",
    "config_path": "/path/to/config"
}

config = DroidRunConfig()

agent = DroidAgent(
    goal="Configure app with user settings",
    config=config,
    llms=llm,
    variables=variables
)

# Variables available in:
# - Manager system prompt
# - Executor system prompt
# - CodeAct system prompt
# - ScripterAgent context
```

---

## Summary

**Key Takeaways:**

1. **Hierarchical Architecture**: DroidAgent orchestrates specialized agents
2. **Two Execution Modes**: Direct (fast) vs Reasoning (complex)
3. **Event-Driven Coordination**: Lightweight coordination events + rich internal events
4. **Nested Workflows**: Each agent is self-contained workflow
5. **Shared State**: `DroidAgentState` coordinates all agents
6. **Error Escalation**: Executor failures escalate to Manager
7. **Extensible**: Add custom agents, tools, variables easily

**When to Use Each Mode:**

| Complexity | Steps | Mode | Agents Used |
|------------|-------|------|-------------|
| Simple | 1-10 | Direct | CodeActAgent |
| Medium | 10-30 | Reasoning | Manager + Executor |
| Complex | 30+ | Reasoning + Scripter | Manager + Executor + Scripter |

**Next Steps:**
- Read [Agent Configuration Guide](/guides/agent-config) for tuning parameters
- Explore [Custom Tools](/guides/custom-tools) for extending functionality
- See [App Cards](/guides/app-cards) for app-specific instructions
- Check [Telemetry](/guides/telemetry) for monitoring production deployments
