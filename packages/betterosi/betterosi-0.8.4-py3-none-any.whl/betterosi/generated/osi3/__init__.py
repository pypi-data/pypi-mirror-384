# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: osi_common.proto, osi_datarecording.proto, osi_detectedlane.proto, osi_detectedobject.proto, osi_detectedoccupant.proto, osi_detectedroadmarking.proto, osi_detectedtrafficlight.proto, osi_detectedtrafficsign.proto, osi_environment.proto, osi_featuredata.proto, osi_groundtruth.proto, osi_hostvehicledata.proto, osi_lane.proto, osi_logicaldetectiondata.proto, osi_logicallane.proto, osi_mapasamopendrive.proto, osi_motionrequest.proto, osi_object.proto, osi_occupant.proto, osi_referenceline.proto, osi_roadmarking.proto, osi_route.proto, osi_sensordata.proto, osi_sensorspecific.proto, osi_sensorview.proto, osi_sensorviewconfiguration.proto, osi_streamingupdate.proto, osi_trafficcommand.proto, osi_trafficcommandupdate.proto, osi_trafficlight.proto, osi_trafficsign.proto, osi_trafficupdate.proto, osi_version.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "BaseMoving",
    "BaseStationary",
    "BoundingBox",
    "BoundingBoxType",
    "CameraDetection",
    "CameraDetectionColor",
    "CameraDetectionData",
    "CameraDetectionImageShapeType",
    "CameraDetectionSpecificHeader",
    "CameraPoint",
    "CameraSensorView",
    "CameraSensorViewConfiguration",
    "CameraSensorViewConfigurationChannelFormat",
    "CameraSensorViewConfigurationPixelOrder",
    "CameraSpecificObjectData",
    "ColorCmyk",
    "ColorDescription",
    "ColorGrey",
    "ColorHsv",
    "ColorLuv",
    "ColorRgb",
    "ColorRgbir",
    "DetectedEntityHeader",
    "DetectedEntityHeaderDataQualifier",
    "DetectedItemHeader",
    "DetectedItemHeaderMeasurementState",
    "DetectedLane",
    "DetectedLaneBoundary",
    "DetectedLaneBoundaryCandidateLaneBoundary",
    "DetectedLaneCandidateLane",
    "DetectedMovingObject",
    "DetectedMovingObjectCandidateMovingObject",
    "DetectedMovingObjectMovementState",
    "DetectedMovingObjectReferencePoint",
    "DetectedOccupant",
    "DetectedOccupantCandidateOccupant",
    "DetectedRoadMarking",
    "DetectedRoadMarkingCandidateRoadMarking",
    "DetectedStationaryObject",
    "DetectedStationaryObjectCandidateStationaryObject",
    "DetectedTrafficLight",
    "DetectedTrafficLightCandidateTrafficLight",
    "DetectedTrafficSign",
    "DetectedTrafficSignDetectedMainSign",
    "DetectedTrafficSignDetectedMainSignCandidateMainSign",
    "DetectedTrafficSignDetectedMainSignGeometry",
    "DetectedTrafficSignDetectedSupplementarySign",
    "DetectedTrafficSignDetectedSupplementarySignCandidateSupplementarySign",
    "DetectionClassification",
    "Dimension3D",
    "EnvironmentalConditions",
    "EnvironmentalConditionsAmbientIllumination",
    "EnvironmentalConditionsCloudLayer",
    "EnvironmentalConditionsCloudLayerFractionalCloudCover",
    "EnvironmentalConditionsFog",
    "EnvironmentalConditionsPrecipitation",
    "EnvironmentalConditionsSun",
    "EnvironmentalConditionsTimeOfDay",
    "EnvironmentalConditionsWind",
    "ExternalReference",
    "FeatureData",
    "GenericSensorView",
    "GenericSensorViewConfiguration",
    "GeodeticPosition",
    "GroundTruth",
    "GroundTruthProjFrameOffset",
    "HostVehicleData",
    "HostVehicleDataVehicleAutomatedDrivingFunction",
    "HostVehicleDataVehicleAutomatedDrivingFunctionDriverOverride",
    "HostVehicleDataVehicleAutomatedDrivingFunctionDriverOverrideReason",
    "HostVehicleDataVehicleAutomatedDrivingFunctionName",
    "HostVehicleDataVehicleAutomatedDrivingFunctionState",
    "HostVehicleDataVehicleBasics",
    "HostVehicleDataVehicleBasicsOperatingState",
    "HostVehicleDataVehicleBrakeSystem",
    "HostVehicleDataVehicleLocalization",
    "HostVehicleDataVehicleMotion",
    "HostVehicleDataVehiclePowertrain",
    "HostVehicleDataVehiclePowertrainMotor",
    "HostVehicleDataVehiclePowertrainMotorType",
    "HostVehicleDataVehicleSteering",
    "HostVehicleDataVehicleWheels",
    "HostVehicleDataVehicleWheelsWheelData",
    "Identifier",
    "InterfaceVersion",
    "KeyValuePair",
    "Lane",
    "LaneBoundary",
    "LaneBoundaryBoundaryPoint",
    "LaneBoundaryBoundaryPointDash",
    "LaneBoundaryClassification",
    "LaneBoundaryClassificationColor",
    "LaneBoundaryClassificationType",
    "LaneClassification",
    "LaneClassificationLanePairing",
    "LaneClassificationRoadCondition",
    "LaneClassificationSubtype",
    "LaneClassificationType",
    "LidarDetection",
    "LidarDetectionData",
    "LidarSensorView",
    "LidarSensorViewConfiguration",
    "LidarSensorViewReflection",
    "LidarSpecificObjectData",
    "LogicalDetection",
    "LogicalDetectionClassification",
    "LogicalDetectionData",
    "LogicalDetectionDataHeader",
    "LogicalDetectionDataHeaderDataQualifier",
    "LogicalLane",
    "LogicalLaneAssignment",
    "LogicalLaneBoundary",
    "LogicalLaneBoundaryLogicalBoundaryPoint",
    "LogicalLaneBoundaryPassingRule",
    "LogicalLaneLaneConnection",
    "LogicalLaneLaneRelation",
    "LogicalLaneMoveDirection",
    "LogicalLanePhysicalLaneReference",
    "LogicalLaneTrafficRule",
    "LogicalLaneTrafficRuleSpeedLimit",
    "LogicalLaneTrafficRuleTrafficRuleType",
    "LogicalLaneTrafficRuleTrafficRuleValidity",
    "LogicalLaneTrafficRuleTrafficRuleValidityTypeValidity",
    "LogicalLaneType",
    "MapAsamOpenDrive",
    "MotionRequest",
    "MotionRequestDesiredState",
    "MotionRequestDesiredTrajectory",
    "MotionRequestMotionRequestType",
    "MountingPosition",
    "MovingObject",
    "MovingObjectMovingObjectClassification",
    "MovingObjectPedestrianAttributes",
    "MovingObjectPedestrianAttributesBone",
    "MovingObjectPedestrianAttributesBoneType",
    "MovingObjectType",
    "MovingObjectVehicleAttributes",
    "MovingObjectVehicleAttributesWheelData",
    "MovingObjectVehicleClassification",
    "MovingObjectVehicleClassificationLightState",
    "MovingObjectVehicleClassificationLightStateBrakeLightState",
    "MovingObjectVehicleClassificationLightStateGenericLightState",
    "MovingObjectVehicleClassificationLightStateIndicatorState",
    "MovingObjectVehicleClassificationRole",
    "MovingObjectVehicleClassificationType",
    "Occupant",
    "OccupantClassification",
    "OccupantClassificationSeat",
    "OccupantClassificationSteeringControl",
    "Orientation3D",
    "Pedalry",
    "Polygon3D",
    "RadarDetection",
    "RadarDetectionData",
    "RadarSensorView",
    "RadarSensorViewConfiguration",
    "RadarSensorViewConfigurationAntennaDiagramEntry",
    "RadarSensorViewReflection",
    "RadarSpecificObjectData",
    "ReferenceLine",
    "ReferenceLineReferenceLinePoint",
    "ReferenceLineType",
    "RoadMarking",
    "RoadMarkingClassification",
    "RoadMarkingClassificationColor",
    "RoadMarkingClassificationType",
    "Route",
    "RouteLogicalLaneSegment",
    "RouteRouteSegment",
    "SensorData",
    "SensorDataSeries",
    "SensorDataSeriesList",
    "SensorDataVirtualDetectionArea",
    "SensorDetectionHeader",
    "SensorDetectionHeaderDataQualifier",
    "SensorDetectionHeaderExtendedQualifier",
    "SensorView",
    "SensorViewConfiguration",
    "SpatialSignalStrength",
    "Spherical3D",
    "StatePoint",
    "StationaryObject",
    "StationaryObjectClassification",
    "StationaryObjectClassificationColor",
    "StationaryObjectClassificationDensity",
    "StationaryObjectClassificationEmittingStructureAttribute",
    "StationaryObjectClassificationMaterial",
    "StationaryObjectClassificationType",
    "StreamingUpdate",
    "Timestamp",
    "TrafficAction",
    "TrafficActionAbortActionsAction",
    "TrafficActionAcquireGlobalPositionAction",
    "TrafficActionActionHeader",
    "TrafficActionCustomAction",
    "TrafficActionDynamicConstraints",
    "TrafficActionDynamicsShape",
    "TrafficActionEndActionsAction",
    "TrafficActionFollowPathAction",
    "TrafficActionFollowTrajectoryAction",
    "TrafficActionFollowingMode",
    "TrafficActionLaneChangeAction",
    "TrafficActionLaneOffsetAction",
    "TrafficActionLateralDistanceAction",
    "TrafficActionLongitudinalDistanceAction",
    "TrafficActionSpeedAction",
    "TrafficActionTeleportAction",
    "TrafficCommand",
    "TrafficCommandUpdate",
    "TrafficCommandUpdateDismissedAction",
    "TrafficLight",
    "TrafficLightClassification",
    "TrafficLightClassificationColor",
    "TrafficLightClassificationIcon",
    "TrafficLightClassificationMode",
    "TrafficSign",
    "TrafficSignMainSign",
    "TrafficSignMainSignClassification",
    "TrafficSignMainSignClassificationDirectionScope",
    "TrafficSignMainSignClassificationType",
    "TrafficSignSupplementarySign",
    "TrafficSignSupplementarySignClassification",
    "TrafficSignSupplementarySignClassificationActor",
    "TrafficSignSupplementarySignClassificationArrow",
    "TrafficSignSupplementarySignClassificationArrowDirection",
    "TrafficSignSupplementarySignClassificationType",
    "TrafficSignValue",
    "TrafficSignValueUnit",
    "TrafficSignVariability",
    "TrafficUpdate",
    "UltrasonicDetection",
    "UltrasonicDetectionData",
    "UltrasonicDetectionSpecificHeader",
    "UltrasonicIndirectDetection",
    "UltrasonicSensorView",
    "UltrasonicSensorViewConfiguration",
    "UltrasonicSpecificObjectData",
    "UltrasonicSpecificObjectDataSignalway",
    "UltrasonicSpecificObjectDataTrend",
    "UltrasonicSpecificObjectDataTrilaterationStatus",
    "Vector2D",
    "Vector3D",
    "VehicleSteeringWheel",
    "WavelengthData",
)

from dataclasses import dataclass

import betterproto2
from google.protobuf.descriptor import Descriptor, EnumDescriptor

from ..google_proto_descriptor_pool import default_google_proto_descriptor_pool
from ..message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class BoundingBoxType(betterproto2.Enum):
    """
    Definition of different types of object contained within the bounding box
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.enum_types_by_name["BoundingBox.Type"]

    UNKNOWN = 0
    """
    Object of unknown type (must not be used in ground truth).
    """

    OTHER = 1
    """
    Any other type of object.
    """

    BASE_STRUCTURE = 2
    """
    The main structure of an object, e.g. a chassis of a vehicle, 
    or the central structure of a building, a tree trunk, etc.
    """

    PROTRUDING_STRUCTURE = 3
    """
    A protruding, integral part of an object, which is not 
    temporarily attached, e.g. a tree crown, a light pole arm, or a 
    parking house gate. The protruding structure is meant to be an 
    additional part to a base structure.
    """

    CARGO = 4
    """
    Additional, temporarily attached cargo to an object.
    """

    DOOR = 5
    """
    The door of an object.

    For vehicles, this includes driver and passenger doors, trunk
    and front hoods, and fuel or charging port covers.
    """

    SIDE_MIRROR = 6
    """
    The side mirror of a vehicle.

    \\note The side mirror is not included in the overall bounding box
    of the parent object.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "TYPE_UNKNOWN",
            1: "TYPE_OTHER",
            2: "TYPE_BASE_STRUCTURE",
            3: "TYPE_PROTRUDING_STRUCTURE",
            4: "TYPE_CARGO",
            5: "TYPE_DOOR",
            6: "TYPE_SIDE_MIRROR",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "TYPE_UNKNOWN": 0,
            "TYPE_OTHER": 1,
            "TYPE_BASE_STRUCTURE": 2,
            "TYPE_PROTRUDING_STRUCTURE": 3,
            "TYPE_CARGO": 4,
            "TYPE_DOOR": 5,
            "TYPE_SIDE_MIRROR": 6,
        }


class CameraDetectionColor(betterproto2.Enum):
    """
    Definition of shape dominant color.

    \\attention DEPRECATED: This color enum will be removed in version
    4.0.0. Use \\c ColorDescription instead.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_FEATUREDATA_PROTO_DESCRIPTOR.enum_types_by_name[
            "CameraDetection.Color"
        ]

    UNKNOWN = 0
    """
    Color of the shape is unknown (must not be used in ground
    truth).
    """

    OTHER = 1
    """
    Shape with another (unspecified but known) color.
    """

    BLACK = 2
    """
    Shape with black color.
    """

    GRAY = 3
    """
    Shape with gray color.
    """

    GREY = 3
    """
    Shape with gray color.

    \\note Deprecated variant spelling of COLOR_GRAY
    """

    WHITE = 4
    """
    Shape with white color.
    """

    YELLOW = 5
    """
    Shape with yellow color.
    """

    ORANGE = 6
    """
    Shape with orange color.
    """

    RED = 7
    """
    Shape with red color.
    """

    VIOLET = 8
    """
    Shape with violet color.
    """

    BLUE = 9
    """
    Shape with blue color.
    """

    GREEN = 10
    """
    Shape with green color.
    """

    REFLECTIVE = 11
    """
    Shape with reflective color.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "COLOR_UNKNOWN",
            1: "COLOR_OTHER",
            2: "COLOR_BLACK",
            3: "COLOR_GRAY",
            3: "COLOR_GREY",
            4: "COLOR_WHITE",
            5: "COLOR_YELLOW",
            6: "COLOR_ORANGE",
            7: "COLOR_RED",
            8: "COLOR_VIOLET",
            9: "COLOR_BLUE",
            10: "COLOR_GREEN",
            11: "COLOR_REFLECTIVE",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "COLOR_UNKNOWN": 0,
            "COLOR_OTHER": 1,
            "COLOR_BLACK": 2,
            "COLOR_GRAY": 3,
            "COLOR_GREY": 3,
            "COLOR_WHITE": 4,
            "COLOR_YELLOW": 5,
            "COLOR_ORANGE": 6,
            "COLOR_RED": 7,
            "COLOR_VIOLET": 8,
            "COLOR_BLUE": 9,
            "COLOR_GREEN": 10,
            "COLOR_REFLECTIVE": 11,
        }


class CameraDetectionImageShapeType(betterproto2.Enum):
    """
    Definition of different image shape types.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_FEATUREDATA_PROTO_DESCRIPTOR.enum_types_by_name[
            "CameraDetection.ImageShapeType"
        ]

    UNKNOWN = 0
    """
    Shape type is unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) shape type.
    """

    POINT = 2
    """
    Image shape is defined by a single point.

    Allowed number of referenced points: 1
    """

    BOX = 3
    """
    Image shape is defined by a box.

    Allowed number of referenced points: 2 or 3

    Allowed number of referenced points = 2: first and third corner of
    the box. Box is aligned horizontal resp. vertical.

    Allowed number of referenced points = 3: first, second and third
    corner of the box. fourth corner is calculated by first+third-second
    corner.
    """

    ELLIPSE = 4
    """
    Image shape is defined by an ellipse.

    Allowed number of referenced points: 2 or 3

    Allowed number of referenced points = 2: center point of circle,
    point on circle

    Allowed number of referenced points = 3: center point of ellipse,
    point on ellipse at main axis of ellipse, point on ellipse at minor
    axis of ellipse
    """

    POLYGON = 5
    """
    Image shape is defined by a polygon.

    Allowed number of referenced points: 3 .. n

    Polygon is defined by the first, second, third and so on points. The
    polygon shape is closed (last and first point are different).
    """

    POLYLINE = 6
    """
    Image shape is defined by a polyline.

    Allowed number of referenced points: 2 .. n

    Polyline is defined by the first, second and so on points. The
    polyline shape is open.
    """

    POINT_CLOUD = 7
    """
    Image shape is defined by a point cloud.

    Allowed number of referenced points: 2 .. n

    Point cloud is defined by a number of points. The points are not
    connected in the point cloud.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "IMAGE_SHAPE_TYPE_UNKNOWN",
            1: "IMAGE_SHAPE_TYPE_OTHER",
            2: "IMAGE_SHAPE_TYPE_POINT",
            3: "IMAGE_SHAPE_TYPE_BOX",
            4: "IMAGE_SHAPE_TYPE_ELLIPSE",
            5: "IMAGE_SHAPE_TYPE_POLYGON",
            6: "IMAGE_SHAPE_TYPE_POLYLINE",
            7: "IMAGE_SHAPE_TYPE_POINT_CLOUD",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "IMAGE_SHAPE_TYPE_UNKNOWN": 0,
            "IMAGE_SHAPE_TYPE_OTHER": 1,
            "IMAGE_SHAPE_TYPE_POINT": 2,
            "IMAGE_SHAPE_TYPE_BOX": 3,
            "IMAGE_SHAPE_TYPE_ELLIPSE": 4,
            "IMAGE_SHAPE_TYPE_POLYGON": 5,
            "IMAGE_SHAPE_TYPE_POLYLINE": 6,
            "IMAGE_SHAPE_TYPE_POINT_CLOUD": 7,
        }


class CameraSensorViewConfigurationChannelFormat(betterproto2.Enum):
    """
    Channel format.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_SENSORVIEWCONFIGURATION_PROTO_DESCRIPTOR.enum_types_by_name[
            "CameraSensorViewConfiguration.ChannelFormat"
        ]

    UNKNOWN = 0
    """
    Type of channel format is unknown (must not be used).
    """

    OTHER = 1
    """
    Unspecified but known channel format.
    Consider proposing an additional format if using
    \\c #CHANNEL_FORMAT_OTHER.
    """

    MONO_U8_LIN = 2
    """
    Single Luminance Channel UINT8 Linear.
    """

    MONO_U16_LIN = 3
    """
    Single Luminance Channel UINT16 Linear.
    """

    MONO_U32_LIN = 4
    """
    Single Luminance Channel UINT32 Linear.
    """

    MONO_F32_LIN = 5
    """
    Single Luminance Channel Single Precision FP Linear.
    """

    RGB_U8_LIN = 6
    """
    Packed RGB Channels (no padding) UINT8 Linear.
    """

    RGB_U16_LIN = 7
    """
    Packed RGB Channels (no padding) UINT16 Linear.
    """

    RGB_U32_LIN = 8
    """
    Packed RGB Channels (no padding) UINT32 Linear.
    """

    RGB_F32_LIN = 9
    """
    Packed RGB Channels (no padding) Single Precision FP Linear.
    """

    BAYER_BGGR_U8_LIN = 10
    """
    Bayer BGGR Channels UINT8 FP Linear.
    """

    BAYER_BGGR_U16_LIN = 11
    """
    Bayer BGGR Channels UINT16 FP Linear.
    """

    BAYER_BGGR_U32_LIN = 12
    """
    Bayer BGGR Channels UINT32 FP Linear.
    """

    BAYER_BGGR_F32_LIN = 13
    """
    Bayer BGGR Channels Single Precision FP Linear.
    """

    BAYER_RGGB_U8_LIN = 14
    """
    Bayer RGGB Channels UINT8 FP Linear.
    """

    BAYER_RGGB_U16_LIN = 15
    """
    Bayer RGGB Channels UINT16 FP Linear.
    """

    BAYER_RGGB_U32_LIN = 16
    """
    Bayer RGGB Channels UINT32 FP Linear.
    """

    BAYER_RGGB_F32_LIN = 17
    """
    Bayer RGGB Channels Single Precision FP Linear.
    """

    RCCC_U8_LIN = 18
    """
    Red Clear Clear Clear Channels UINT8 FP Linear.
    """

    RCCC_U16_LIN = 19
    """
    Red Clear Clear Clear Channels UINT16 FP Linear.
    """

    RCCC_U32_LIN = 20
    """
    Red Clear Clear Clear Channels UINT32 FP Linear.
    """

    RCCC_F32_LIN = 21
    """
    Red Clear Clear Clear Channels Single Precision FP Linear.
    """

    RCCB_U8_LIN = 22
    """
    Red Clear Clear Blue Channels UINT8 FP Linear.
    """

    RCCB_U16_LIN = 23
    """
    Red Clear Clear Blue Channels UINT16 FP Linear.
    """

    RCCB_U32_LIN = 24
    """
    Red Clear Clear Blue Channels UINT32 FP Linear.
    """

    RCCB_F32_LIN = 25
    """
    Red Clear Clear Blue Channels Single Precision FP Linear.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "CHANNEL_FORMAT_UNKNOWN",
            1: "CHANNEL_FORMAT_OTHER",
            2: "CHANNEL_FORMAT_MONO_U8_LIN",
            3: "CHANNEL_FORMAT_MONO_U16_LIN",
            4: "CHANNEL_FORMAT_MONO_U32_LIN",
            5: "CHANNEL_FORMAT_MONO_F32_LIN",
            6: "CHANNEL_FORMAT_RGB_U8_LIN",
            7: "CHANNEL_FORMAT_RGB_U16_LIN",
            8: "CHANNEL_FORMAT_RGB_U32_LIN",
            9: "CHANNEL_FORMAT_RGB_F32_LIN",
            10: "CHANNEL_FORMAT_BAYER_BGGR_U8_LIN",
            11: "CHANNEL_FORMAT_BAYER_BGGR_U16_LIN",
            12: "CHANNEL_FORMAT_BAYER_BGGR_U32_LIN",
            13: "CHANNEL_FORMAT_BAYER_BGGR_F32_LIN",
            14: "CHANNEL_FORMAT_BAYER_RGGB_U8_LIN",
            15: "CHANNEL_FORMAT_BAYER_RGGB_U16_LIN",
            16: "CHANNEL_FORMAT_BAYER_RGGB_U32_LIN",
            17: "CHANNEL_FORMAT_BAYER_RGGB_F32_LIN",
            18: "CHANNEL_FORMAT_RCCC_U8_LIN",
            19: "CHANNEL_FORMAT_RCCC_U16_LIN",
            20: "CHANNEL_FORMAT_RCCC_U32_LIN",
            21: "CHANNEL_FORMAT_RCCC_F32_LIN",
            22: "CHANNEL_FORMAT_RCCB_U8_LIN",
            23: "CHANNEL_FORMAT_RCCB_U16_LIN",
            24: "CHANNEL_FORMAT_RCCB_U32_LIN",
            25: "CHANNEL_FORMAT_RCCB_F32_LIN",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "CHANNEL_FORMAT_UNKNOWN": 0,
            "CHANNEL_FORMAT_OTHER": 1,
            "CHANNEL_FORMAT_MONO_U8_LIN": 2,
            "CHANNEL_FORMAT_MONO_U16_LIN": 3,
            "CHANNEL_FORMAT_MONO_U32_LIN": 4,
            "CHANNEL_FORMAT_MONO_F32_LIN": 5,
            "CHANNEL_FORMAT_RGB_U8_LIN": 6,
            "CHANNEL_FORMAT_RGB_U16_LIN": 7,
            "CHANNEL_FORMAT_RGB_U32_LIN": 8,
            "CHANNEL_FORMAT_RGB_F32_LIN": 9,
            "CHANNEL_FORMAT_BAYER_BGGR_U8_LIN": 10,
            "CHANNEL_FORMAT_BAYER_BGGR_U16_LIN": 11,
            "CHANNEL_FORMAT_BAYER_BGGR_U32_LIN": 12,
            "CHANNEL_FORMAT_BAYER_BGGR_F32_LIN": 13,
            "CHANNEL_FORMAT_BAYER_RGGB_U8_LIN": 14,
            "CHANNEL_FORMAT_BAYER_RGGB_U16_LIN": 15,
            "CHANNEL_FORMAT_BAYER_RGGB_U32_LIN": 16,
            "CHANNEL_FORMAT_BAYER_RGGB_F32_LIN": 17,
            "CHANNEL_FORMAT_RCCC_U8_LIN": 18,
            "CHANNEL_FORMAT_RCCC_U16_LIN": 19,
            "CHANNEL_FORMAT_RCCC_U32_LIN": 20,
            "CHANNEL_FORMAT_RCCC_F32_LIN": 21,
            "CHANNEL_FORMAT_RCCB_U8_LIN": 22,
            "CHANNEL_FORMAT_RCCB_U16_LIN": 23,
            "CHANNEL_FORMAT_RCCB_U32_LIN": 24,
            "CHANNEL_FORMAT_RCCB_F32_LIN": 25,
        }


class CameraSensorViewConfigurationPixelOrder(betterproto2.Enum):
    """
    Pixel layout

    Pixel layout documents the order of pixels in the \\c image_data
    in CameraSensorView.

    \\note this enum does not contain an entry to do mirroring upside down
    and left-to-right at the same time, because this is equivalent to a
    180-degree rotation, which should be indicated in the sensor coordinate
    system.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_SENSORVIEWCONFIGURATION_PROTO_DESCRIPTOR.enum_types_by_name[
            "CameraSensorViewConfiguration.PixelOrder"
        ]

    DEFAULT = 0
    """
    Pixel data is not mirrored (Default).
    Pixels are ordered left-to-right, top-to-bottom.
    """

    OTHER = 1
    """
    Known pixel order that is not supported by OSI.
    Consider proposing an additional format if using
    \\c #PIXEL_ORDER_OTHER.
    """

    RIGHT_LEFT_TOP_BOTTOM = 2
    """
    Pixels are ordered right-to-left, top-to-bottom.
    Pixel data is mirrored along the vertical axis.
    The image is mirrored left-to-right.
    """

    LEFT_RIGHT_BOTTOM_TOP = 3
    """
    Pixels are ordered left-to-right, bottom-to-top.
    Pixel data is mirrored along the horizontal axis.
    The image is mirrored top-to-bottom.

    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "PIXEL_ORDER_DEFAULT",
            1: "PIXEL_ORDER_OTHER",
            2: "PIXEL_ORDER_RIGHT_LEFT_TOP_BOTTOM",
            3: "PIXEL_ORDER_LEFT_RIGHT_BOTTOM_TOP",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "PIXEL_ORDER_DEFAULT": 0,
            "PIXEL_ORDER_OTHER": 1,
            "PIXEL_ORDER_RIGHT_LEFT_TOP_BOTTOM": 2,
            "PIXEL_ORDER_LEFT_RIGHT_BOTTOM_TOP": 3,
        }


class DetectedEntityHeaderDataQualifier(betterproto2.Enum):
    """

    Data qualifier communicates the overall availability of the
    interface.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_SENSORDATA_PROTO_DESCRIPTOR.enum_types_by_name[
            "DetectedEntityHeader.DataQualifier"
        ]

    UNKNOWN = 0
    """
    Unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known).
    """

    AVAILABLE = 2
    """
    Data is available.
    """

    AVAILABLE_REDUCED = 3
    """
    Reduced data is available.
    """

    NOT_AVAILABLE = 4
    """
    Data is not available.
    """

    BLINDNESS = 5
    """
    Sensor is blind.
    """

    TEMPORARY_AVAILABLE = 6
    """
    Sensor temporary available.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "DATA_QUALIFIER_UNKNOWN",
            1: "DATA_QUALIFIER_OTHER",
            2: "DATA_QUALIFIER_AVAILABLE",
            3: "DATA_QUALIFIER_AVAILABLE_REDUCED",
            4: "DATA_QUALIFIER_NOT_AVAILABLE",
            5: "DATA_QUALIFIER_BLINDNESS",
            6: "DATA_QUALIFIER_TEMPORARY_AVAILABLE",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "DATA_QUALIFIER_UNKNOWN": 0,
            "DATA_QUALIFIER_OTHER": 1,
            "DATA_QUALIFIER_AVAILABLE": 2,
            "DATA_QUALIFIER_AVAILABLE_REDUCED": 3,
            "DATA_QUALIFIER_NOT_AVAILABLE": 4,
            "DATA_QUALIFIER_BLINDNESS": 5,
            "DATA_QUALIFIER_TEMPORARY_AVAILABLE": 6,
        }


class DetectedItemHeaderMeasurementState(betterproto2.Enum):
    """
    Definition of measurement states.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_DETECTEDOBJECT_PROTO_DESCRIPTOR.enum_types_by_name[
            "DetectedItemHeader.MeasurementState"
        ]

    UNKNOWN = 0
    """
    Measurement state is unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Measurement state is unspecified (but known, i.e. value is not part
    of this enum list).
    """

    MEASURED = 2
    """
    Entity has been measured by the sensor in the current time step.
    """

    PREDICTED = 3
    """
    Entity has not been measured by the sensor in the current time step.
    Values provided by tracking only.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "MEASUREMENT_STATE_UNKNOWN",
            1: "MEASUREMENT_STATE_OTHER",
            2: "MEASUREMENT_STATE_MEASURED",
            3: "MEASUREMENT_STATE_PREDICTED",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "MEASUREMENT_STATE_UNKNOWN": 0,
            "MEASUREMENT_STATE_OTHER": 1,
            "MEASUREMENT_STATE_MEASURED": 2,
            "MEASUREMENT_STATE_PREDICTED": 3,
        }


class DetectedMovingObjectMovementState(betterproto2.Enum):
    """
    Information about a possible movement of the object during tracking.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_DETECTEDOBJECT_PROTO_DESCRIPTOR.enum_types_by_name[
            "DetectedMovingObject.MovementState"
        ]

    UNKNOWN = 0
    """
    Movement state is unknown.
    """

    OTHER = 1
    """
    Other (unspecified but known).
    """

    STATIONARY = 2
    """
    Until now no object movement was detected in tracking history.
    """

    MOVING = 3
    """
    Object moves currently.
    """

    STOPPED = 4
    """
    Object movement was detected in tracking history, but object is
    currently not moving.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "MOVEMENT_STATE_UNKNOWN",
            1: "MOVEMENT_STATE_OTHER",
            2: "MOVEMENT_STATE_STATIONARY",
            3: "MOVEMENT_STATE_MOVING",
            4: "MOVEMENT_STATE_STOPPED",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "MOVEMENT_STATE_UNKNOWN": 0,
            "MOVEMENT_STATE_OTHER": 1,
            "MOVEMENT_STATE_STATIONARY": 2,
            "MOVEMENT_STATE_MOVING": 3,
            "MOVEMENT_STATE_STOPPED": 4,
        }


class DetectedMovingObjectReferencePoint(betterproto2.Enum):
    """
    Definition of available reference points. Left/middle/right and
    front/middle/rear indicate the position in y- and x-direction
    respectively. The z position is always considered as middle.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_DETECTEDOBJECT_PROTO_DESCRIPTOR.enum_types_by_name[
            "DetectedMovingObject.ReferencePoint"
        ]

    UNKNOWN = 0
    """
    Reference point is unknown, i.e. sensor does not report a reference
    point for the position coordinate.
    Value must not be used in ground truth data.
    Usually this means that the reference point for the given position
    coordinates is a largely arbitrary point within the bounding volume
    unknown to the sensor. If this value is set, the center of the
    bounding box should be used as reference point by convention, unless
    the specific use case requires otherwise.
    """

    OTHER = 1
    """
    Other (unspecified but known) reference point.
    """

    CENTER = 2
    """
    Center of the bounding box.
    """

    MIDDLE_LEFT = 3
    """
    Middle-Left of the bounding box.
    """

    MIDDLE_RIGHT = 4
    """
    Middle-Right of the bounding box.
    """

    REAR_MIDDLE = 5
    """
    Rear-Middle of the bounding box.
    """

    REAR_LEFT = 6
    """
    Rear-Left of the bounding box.
    """

    REAR_RIGHT = 7
    """
    Rear-Right of the bounding box.
    """

    FRONT_MIDDLE = 8
    """
    Front-Middle of the bounding box.
    """

    FRONT_LEFT = 9
    """
    Front-Left of the bounding box.
    """

    FRONT_RIGHT = 10
    """
    Front-Right of the bounding box.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "REFERENCE_POINT_UNKNOWN",
            1: "REFERENCE_POINT_OTHER",
            2: "REFERENCE_POINT_CENTER",
            3: "REFERENCE_POINT_MIDDLE_LEFT",
            4: "REFERENCE_POINT_MIDDLE_RIGHT",
            5: "REFERENCE_POINT_REAR_MIDDLE",
            6: "REFERENCE_POINT_REAR_LEFT",
            7: "REFERENCE_POINT_REAR_RIGHT",
            8: "REFERENCE_POINT_FRONT_MIDDLE",
            9: "REFERENCE_POINT_FRONT_LEFT",
            10: "REFERENCE_POINT_FRONT_RIGHT",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "REFERENCE_POINT_UNKNOWN": 0,
            "REFERENCE_POINT_OTHER": 1,
            "REFERENCE_POINT_CENTER": 2,
            "REFERENCE_POINT_MIDDLE_LEFT": 3,
            "REFERENCE_POINT_MIDDLE_RIGHT": 4,
            "REFERENCE_POINT_REAR_MIDDLE": 5,
            "REFERENCE_POINT_REAR_LEFT": 6,
            "REFERENCE_POINT_REAR_RIGHT": 7,
            "REFERENCE_POINT_FRONT_MIDDLE": 8,
            "REFERENCE_POINT_FRONT_LEFT": 9,
            "REFERENCE_POINT_FRONT_RIGHT": 10,
        }


class DetectedTrafficSignDetectedMainSignGeometry(betterproto2.Enum):
    """
    Definition of traffic sign geometries.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_DETECTEDTRAFFICSIGN_PROTO_DESCRIPTOR.enum_types_by_name[
            "DetectedTrafficSign.DetectedMainSign.Geometry"
        ]

    UNKNOWN = 0
    """
    Geometry of the traffic sign is unknown (must not be used in
    ground truth).
    """

    OTHER = 1
    """
    Geometry of the traffic sign is unspecified (but known).
    """

    CIRCLE = 2
    """
    Traffic sign has a circular geometry. (0 corners)
    """

    TRIANGLE_TOP = 3
    """
    Traffic sign has a triangular geometry pointing to the top. (3
    corners)
    """

    TRIANGLE_DOWN = 4
    """
    Traffic sign has a triangular geometry pointing down. (3 corners)
    """

    SQUARE = 5
    """
    Traffic sign has a square geometry. (4 corners)
    """

    POLE = 6
    """
    Traffic sign that has a pole geometry. (height is bigger than
    width e.g. pole indicating highways exit in xx m). (4 corners)
    """

    RECTANGLE = 7
    """
    Traffic sign has a rectangle geometry. (width is bigger than
    height e.g. one-way) (4 corners)
    """

    PLATE = 8
    """
    Traffic sign that has an oversize rectangle geometry. (4 corners)
    E.g. direction plates on highway or city signs.
    """

    DIAMOND = 9
    """
    Traffic sign has a diamond geometry. (4 corners)
    """

    ARROW_LEFT = 10
    """
    Traffic sign has a geometry of an arrow pointing to the left. (5
    corners)
    """

    ARROW_RIGHT = 11
    """
    Traffic sign has a geometry of an arrow pointing to the right. (5
    corners)
    """

    OCTAGON = 12
    """
    Traffic sign has an octagon geometry. (8 corners)
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "GEOMETRY_UNKNOWN",
            1: "GEOMETRY_OTHER",
            2: "GEOMETRY_CIRCLE",
            3: "GEOMETRY_TRIANGLE_TOP",
            4: "GEOMETRY_TRIANGLE_DOWN",
            5: "GEOMETRY_SQUARE",
            6: "GEOMETRY_POLE",
            7: "GEOMETRY_RECTANGLE",
            8: "GEOMETRY_PLATE",
            9: "GEOMETRY_DIAMOND",
            10: "GEOMETRY_ARROW_LEFT",
            11: "GEOMETRY_ARROW_RIGHT",
            12: "GEOMETRY_OCTAGON",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "GEOMETRY_UNKNOWN": 0,
            "GEOMETRY_OTHER": 1,
            "GEOMETRY_CIRCLE": 2,
            "GEOMETRY_TRIANGLE_TOP": 3,
            "GEOMETRY_TRIANGLE_DOWN": 4,
            "GEOMETRY_SQUARE": 5,
            "GEOMETRY_POLE": 6,
            "GEOMETRY_RECTANGLE": 7,
            "GEOMETRY_PLATE": 8,
            "GEOMETRY_DIAMOND": 9,
            "GEOMETRY_ARROW_LEFT": 10,
            "GEOMETRY_ARROW_RIGHT": 11,
            "GEOMETRY_OCTAGON": 12,
        }


class DetectionClassification(betterproto2.Enum):
    """
    Definition of a basic detection classifications.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_FEATUREDATA_PROTO_DESCRIPTOR.enum_types_by_name[
            "DetectionClassification"
        ]

    UNKNOWN = 0
    """
    Detection is unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) detection.
    """

    INVALID = 2
    """
    Invalid detection, not to be used for object tracking, of unspecified
    type (none of the other types applies).
    """

    CLUTTER = 3
    """
    Clutter (noise, spray, rain, fog etc.).
    """

    OVERDRIVABLE = 4
    """
    Over-drivable (ground etc.).
    """

    UNDERDRIVABLE = 5
    """
    Under-drivable (sign gantry etc.).
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "DETECTION_CLASSIFICATION_UNKNOWN",
            1: "DETECTION_CLASSIFICATION_OTHER",
            2: "DETECTION_CLASSIFICATION_INVALID",
            3: "DETECTION_CLASSIFICATION_CLUTTER",
            4: "DETECTION_CLASSIFICATION_OVERDRIVABLE",
            5: "DETECTION_CLASSIFICATION_UNDERDRIVABLE",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "DETECTION_CLASSIFICATION_UNKNOWN": 0,
            "DETECTION_CLASSIFICATION_OTHER": 1,
            "DETECTION_CLASSIFICATION_INVALID": 2,
            "DETECTION_CLASSIFICATION_CLUTTER": 3,
            "DETECTION_CLASSIFICATION_OVERDRIVABLE": 4,
            "DETECTION_CLASSIFICATION_UNDERDRIVABLE": 5,
        }


class EnvironmentalConditionsAmbientIllumination(betterproto2.Enum):
    """
    Definition of discretized ambient illumination states:
    Ambient light is any light in the vehicle's environment that is not
    emitted by the vehicle itself. It can include sun/moon light, light from
    other cars, street lights etc.

    lx ("lux") is the SI unit of luminance or illumination of an area of exact
    one square meter, which is equal to one lumen per square meter 1 lx =
    1 lm/m^2 [1].
    lm ("lumen") is the SI derived unit of luminous flux and a measure of
    the total quantity of visible light emitted by a source. The lumen is
    defined in relation to cd ("candela") as 1 lm = 1 cd sr, where sr
    denotes steradian, the unit of solid angle used in 3D geometry analogous
    to the radian [1].

    Categorization is done based on natural day/night time illuminance levels
    [2] and standards for required lighting levels on roads [2, 3, 4, 5].

    \\par References:
    [1] DIN Deutsches Institut fuer Normung e. V. (1982). <em>DIN 5031-3 Strahlungsphysik im optischen Bereich und Lichttechnik - Groessen, Formelzeichen und Einheiten der Lichttechnik</em>. (DIN 5031-3:1982-03). Berlin, Germany. \\n
    [2] National Optical Astronomy Observatory. (2015, December 02). <em>Recommended Light Levels</em>. Retrieved January 25, 2020, from https://www.noao.edu/education/QLTkit/ACTIVITY_Documents/Safety/LightLevels_outdoor+indoor.pdf \\n
    [3] Wang, Y. & Zou, Y., (2016, March). <em>Study on Illumination for State Highways</em>. Washington State Department of Transportation. Retrieved January 25, 2020, from http://www.wsdot.wa.gov/research/reports/fullreports/847.1.pdf \\n
    [4] Laperriere, A. (2011, May). <em>LED street lighting in the municipality of Saint-Gedeon-de-Beauce within the framework of advanced lighting technologies</em>. Retrieved January 25, 2020, from http://sslnet.ca/wp-content/uploads/2011/10/LTE-RT-2011-0076-Anglais.pdf \\n
    [5] Crabb, G. I., Beaumont, R. & Webster, D. (2008, October 17). <em>Review of the class and quality of street lighting</em>. Transport Research Laboratory. Retrieved January 25, 2020, from http://courtneystrong.com/wp-content/uploads/2017/07/css-sl1-class-and-quality-of-street-lighting.pdf
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_ENVIRONMENT_PROTO_DESCRIPTOR.enum_types_by_name[
            "EnvironmentalConditions.AmbientIllumination"
        ]

    UNKNOWN = 0
    """
    Ambient illumination is unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) ambient illumination.
    """

    LEVEL1 = 2
    """
    Level 1 illumination in ]0.001, 0.01[ lx. \\n
    E.g. Night with no artificial light.

    \\note Use \\c #AMBIENT_ILLUMINATION_LEVEL1 if illumination is less
    than 0.001 lx.
    """

    LEVEL2 = 3
    """
    Level 2 illumination in [0.01, 1[ lx. \\n
    E.g. Night full moon / Deep twilight.
    """

    LEVEL3 = 4
    """
    Level 3 illumination in [1, 3[ lx. \\n
    E.g. Deep to average twilight / Minimum lighting on local low
    pedestrian conflict roads.
    """

    LEVEL4 = 5
    """
    Level 4 illumination in [3, 10[ lx. \\n
    E.g. Average to full twilight / Minimum lighting on collector roads /
    Minimum lighting on major and expressway roads with low to average
    pedestrian conflict.
    """

    LEVEL5 = 6
    """
    Level 5 illumination in [10, 20[ lx. \\n
    E.g. Minimum lighting on major and expressway roads with high
    pedestrian conflict.
    """

    LEVEL6 = 7
    """
    Level 6 illumination in [20, 400[ lx. \\n
    E.g. Roads with more lighting / Very dark overcast day to sunrise or
    sunset on a clear day.
    """

    LEVEL7 = 8
    """
    Level 7 illumination in [400, 1000[ lx. \\n
    E.g. Sunrise or sunset on a clear day / Overcast day.
    """

    LEVEL8 = 9
    """
    Level 8 illumination in [1000, 10000[ lx. \\n
    E.g. Average to full daylight.
    """

    LEVEL9 = 10
    """
    Level 9 illumination in [10000, 120000[ lx. \\n
    E.g. Full daylight to intense sunlight.

    \\note Use \\c #AMBIENT_ILLUMINATION_LEVEL9 if illumination is more
    than 120000 lx
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "AMBIENT_ILLUMINATION_UNKNOWN",
            1: "AMBIENT_ILLUMINATION_OTHER",
            2: "AMBIENT_ILLUMINATION_LEVEL1",
            3: "AMBIENT_ILLUMINATION_LEVEL2",
            4: "AMBIENT_ILLUMINATION_LEVEL3",
            5: "AMBIENT_ILLUMINATION_LEVEL4",
            6: "AMBIENT_ILLUMINATION_LEVEL5",
            7: "AMBIENT_ILLUMINATION_LEVEL6",
            8: "AMBIENT_ILLUMINATION_LEVEL7",
            9: "AMBIENT_ILLUMINATION_LEVEL8",
            10: "AMBIENT_ILLUMINATION_LEVEL9",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "AMBIENT_ILLUMINATION_UNKNOWN": 0,
            "AMBIENT_ILLUMINATION_OTHER": 1,
            "AMBIENT_ILLUMINATION_LEVEL1": 2,
            "AMBIENT_ILLUMINATION_LEVEL2": 3,
            "AMBIENT_ILLUMINATION_LEVEL3": 4,
            "AMBIENT_ILLUMINATION_LEVEL4": 5,
            "AMBIENT_ILLUMINATION_LEVEL5": 6,
            "AMBIENT_ILLUMINATION_LEVEL6": 7,
            "AMBIENT_ILLUMINATION_LEVEL7": 8,
            "AMBIENT_ILLUMINATION_LEVEL8": 9,
            "AMBIENT_ILLUMINATION_LEVEL9": 10,
        }


class EnvironmentalConditionsCloudLayerFractionalCloudCover(betterproto2.Enum):
    """
    Defines the fractional cloud cover [1] given by observation of total cloud amount in eights (oktas) of the sky.

    For visual alignment please see reference [2].

    The total degree of coverage indicates how much of the sky is covered with clouds altogether.
    0 oktas means that there are no traces of clouds in the sky,
    8 oktas means that the sky is completely covered with clouds and no sky blue can be recognized.

    \\par References:
    [1] CIE engl. International Commission on Illumination. (2020). <em>CIE S017:2020 ILV: Intl. Lighting Vocabulary, 2nd edn.</em>. Retrieved March 8, 2022, from https://cie.co.at/eilvterm/17-29-116 \\n
    [2] UBC The University of British Columbia. (2018). <em>ATSC 113 Weather for Sailing, Flying & Snow Sports</em>. Retrieved March 8, 2022, from https://www.eoas.ubc.ca/courses/atsc113/flying/met_concepts/01-met_concepts/01c-cloud_coverage/index.html
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_ENVIRONMENT_PROTO_DESCRIPTOR.enum_types_by_name[
            "EnvironmentalConditions.CloudLayer.FractionalCloudCover"
        ]

    UNKNOWN = 0
    """
    Fractional cloud cover level is unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) fractional cloud cover level.
    """

    ZERO_OKTAS = 2
    """
    0/8 of the sky is covered with clouds.
    """

    ONE_OKTAS = 3
    """
    1/8 of the sky is covered with clouds.
    """

    TWO_OKTAS = 4
    """
    2/8 of the sky is covered with clouds.
    """

    THREE_OKTAS = 5
    """
    3/8 of the sky is covered with clouds.
    """

    FOUR_OKTAS = 6
    """
    4/8 of the sky is covered with clouds.
    """

    FIVE_OKTAS = 7
    """
    5/8 of the sky is covered with clouds.
    """

    SIX_OKTAS = 8
    """
    6/8 of the sky is covered with clouds.
    """

    SEVEN_OKTAS = 9
    """
    7/8 of the sky is covered with clouds.
    """

    EIGHT_OKTAS = 10
    """
    8/8 of the sky is covered with clouds.
    """

    SKY_OBSCURED = 11
    """
    Sky obscured, describes situations where the sky is not perceivable, e.g. in dense fog.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "FRACTIONAL_CLOUD_COVER_UNKNOWN",
            1: "FRACTIONAL_CLOUD_COVER_OTHER",
            2: "FRACTIONAL_CLOUD_COVER_ZERO_OKTAS",
            3: "FRACTIONAL_CLOUD_COVER_ONE_OKTAS",
            4: "FRACTIONAL_CLOUD_COVER_TWO_OKTAS",
            5: "FRACTIONAL_CLOUD_COVER_THREE_OKTAS",
            6: "FRACTIONAL_CLOUD_COVER_FOUR_OKTAS",
            7: "FRACTIONAL_CLOUD_COVER_FIVE_OKTAS",
            8: "FRACTIONAL_CLOUD_COVER_SIX_OKTAS",
            9: "FRACTIONAL_CLOUD_COVER_SEVEN_OKTAS",
            10: "FRACTIONAL_CLOUD_COVER_EIGHT_OKTAS",
            11: "FRACTIONAL_CLOUD_COVER_SKY_OBSCURED",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "FRACTIONAL_CLOUD_COVER_UNKNOWN": 0,
            "FRACTIONAL_CLOUD_COVER_OTHER": 1,
            "FRACTIONAL_CLOUD_COVER_ZERO_OKTAS": 2,
            "FRACTIONAL_CLOUD_COVER_ONE_OKTAS": 3,
            "FRACTIONAL_CLOUD_COVER_TWO_OKTAS": 4,
            "FRACTIONAL_CLOUD_COVER_THREE_OKTAS": 5,
            "FRACTIONAL_CLOUD_COVER_FOUR_OKTAS": 6,
            "FRACTIONAL_CLOUD_COVER_FIVE_OKTAS": 7,
            "FRACTIONAL_CLOUD_COVER_SIX_OKTAS": 8,
            "FRACTIONAL_CLOUD_COVER_SEVEN_OKTAS": 9,
            "FRACTIONAL_CLOUD_COVER_EIGHT_OKTAS": 10,
            "FRACTIONAL_CLOUD_COVER_SKY_OBSCURED": 11,
        }


class EnvironmentalConditionsFog(betterproto2.Enum):
    """
    Definition of discretized fog states according to [1].
    The bandwidth of thick and dense fog was adjusted to fit the German StVO
    regarding rear fog lights [2, 3].
    (V = Visibility in m)

    Visibility is defined as the length of the atmosphere over which a beam
    of light travels before its luminous flux is reduced to 5% of its
    original value (definition used by the Meteorological Office [4]).
    This is approximately equivalent to visibility measured in terms of the
    contrast of a distant object against its background.

    \\par References:
    [1] Shepard, F. D. (1996). <em>Reduced visibility due to fog on the highway.</em> Transportation Research Board, National Research Council (Ed.). National Academy Press. Washington, D.C., USA. ISBN 0-309-06006-0. \\n
    [2] Strassenverkehrs-Ordnung (StVO) as of dated  March 06, 2013 (BGBl. I S. 367), lastly changed by article 4a of the order from June 06, 2019 (BGBl. I S. 756). \\n
    [3] stvo.de. (2013, April 01). <em>StVO Par. 17 Beleuchtung</em>. Retrieved January 25, 2020, from https://www.stvo.de/strassenverkehrsordnung/101-17-beleuchtung \\n
    [4] Meteorological Office UK. (2020). <em>Homepage of the Meteorological Office - How we measure visibility</em>. Retrieved January 25, 2020, from http://www.metoffice.gov.uk/guide/weather/observations-guide/how-we-measure-visibility
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_ENVIRONMENT_PROTO_DESCRIPTOR.enum_types_by_name[
            "EnvironmentalConditions.Fog"
        ]

    UNKNOWN = 0
    """
    Visibility is unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) fog intensity.
    """

    EXCELLENT_VISIBILITY = 2
    """
    Excellent visibility, when V in [40000,infinity[ m
    """

    GOOD_VISIBILITY = 3
    """
    Good visibility, when V in [10000,40000[ m
    """

    MODERATE_VISIBILITY = 4
    """
    Moderate visibility, when V in [4000,10000[ m
    """

    POOR_VISIBILITY = 5
    """
    Poor visibility, when V in [2000,4000[ m
    """

    MIST = 6
    """
    Mist, when V in [1000,2000[ m
    """

    LIGHT = 7
    """
    Fog, when V in [200,1000[ m
    """

    THICK = 8
    """
    Thick fog, when V in [50,200[ m
    """

    DENSE = 9
    """
    Dense fog, when V in [0,50[ m
    (allowed to use rear fog light according to [3])
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "FOG_UNKNOWN",
            1: "FOG_OTHER",
            2: "FOG_EXCELLENT_VISIBILITY",
            3: "FOG_GOOD_VISIBILITY",
            4: "FOG_MODERATE_VISIBILITY",
            5: "FOG_POOR_VISIBILITY",
            6: "FOG_MIST",
            7: "FOG_LIGHT",
            8: "FOG_THICK",
            9: "FOG_DENSE",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "FOG_UNKNOWN": 0,
            "FOG_OTHER": 1,
            "FOG_EXCELLENT_VISIBILITY": 2,
            "FOG_GOOD_VISIBILITY": 3,
            "FOG_MODERATE_VISIBILITY": 4,
            "FOG_POOR_VISIBILITY": 5,
            "FOG_MIST": 6,
            "FOG_LIGHT": 7,
            "FOG_THICK": 8,
            "FOG_DENSE": 9,
        }


class EnvironmentalConditionsPrecipitation(betterproto2.Enum):
    """
    Definition of discretized precipitation states according to [1].
    (I = Intensity of precipitation in mm per hour mm/h)

    \\par Reference:
    [1] Paulat, M., Frei, C., Hagen, M. & Wernli, H. (2008). A gridded dataset of hourly precipitation in Germany: Its construction, climatology and application. <em>Meteorologische Zeitschrift</em>. Vol. 17, No. 6. pp. 719-732. Berlin, Stuttgart, Germany. https://doi.org/10.1127/0941-2948/2008/0332
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_ENVIRONMENT_PROTO_DESCRIPTOR.enum_types_by_name[
            "EnvironmentalConditions.Precipitation"
        ]

    UNKNOWN = 0
    """
    Intensity of precipitation is unknown (must not be used in ground
    truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) intensity of precipitation.
    """

    NONE = 2
    """
    No precipitation, when I in [0,0.1[ mm/h
    """

    VERY_LIGHT = 3
    """
    Very light intensity of precipitation, when I in [0.1,0.5[ mm/h
    """

    LIGHT = 4
    """
    Light intensity of precipitation, when I in [0.5,1.9[ mm/h
    """

    MODERATE = 5
    """
    Moderate intensity of precipitation, when I in [1.9,8.1[ mm/h
    """

    HEAVY = 6
    """
    Heavy intensity of precipitation, when I in [8.1,34[ mm/h
    """

    VERY_HEAVY = 7
    """
    Very heavy intensity of precipitation, when I in [34,149[ mm/h
    """

    EXTREME = 8
    """
    Extreme intensity of precipitation, when I in [149,infinity[ mm/h
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "PRECIPITATION_UNKNOWN",
            1: "PRECIPITATION_OTHER",
            2: "PRECIPITATION_NONE",
            3: "PRECIPITATION_VERY_LIGHT",
            4: "PRECIPITATION_LIGHT",
            5: "PRECIPITATION_MODERATE",
            6: "PRECIPITATION_HEAVY",
            7: "PRECIPITATION_VERY_HEAVY",
            8: "PRECIPITATION_EXTREME",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "PRECIPITATION_UNKNOWN": 0,
            "PRECIPITATION_OTHER": 1,
            "PRECIPITATION_NONE": 2,
            "PRECIPITATION_VERY_LIGHT": 3,
            "PRECIPITATION_LIGHT": 4,
            "PRECIPITATION_MODERATE": 5,
            "PRECIPITATION_HEAVY": 6,
            "PRECIPITATION_VERY_HEAVY": 7,
            "PRECIPITATION_EXTREME": 8,
        }


class HostVehicleDataVehicleAutomatedDrivingFunctionDriverOverrideReason(
    betterproto2.Enum
):
    """
    Ways in which a driver could override a driving function.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_HOSTVEHICLEDATA_PROTO_DESCRIPTOR.enum_types_by_name[
            "HostVehicleData.VehicleAutomatedDrivingFunction.DriverOverride.Reason"
        ]

    BRAKE_PEDAL = 0
    """
    The driver has applied sufficient input via the break pedal.
    """

    STEERING_INPUT = 1
    """
    The driver has applied sufficient steering input.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "REASON_BRAKE_PEDAL",
            1: "REASON_STEERING_INPUT",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "REASON_BRAKE_PEDAL": 0,
            "REASON_STEERING_INPUT": 1,
        }


class HostVehicleDataVehicleAutomatedDrivingFunctionName(betterproto2.Enum):
    """
    A list of possible automated driving features.

    \\note This can span (in theory) from Level 0 all the way to Level 5.

    \\par References:
    [1] CLEARING THE CONFUSION: Recommended Common Naming for Advanced Driver Assistance Technologies, SAE International, Retrieved October 22, 2021, from https://www.sae.org/binaries/content/assets/cm/content/miscellaneous/adas-nomenclature.pdf
    [2] Automated Driving, German Association of the Automotive Industry (VDA), Retrieved October 22, 2021, from https://www.vda.de/en/topics/innovation-and-technology/automated-driving/automated-driving
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_HOSTVEHICLEDATA_PROTO_DESCRIPTOR.enum_types_by_name[
            "HostVehicleData.VehicleAutomatedDrivingFunction.Name"
        ]

    UNKNOWN = 0
    """
    Unknown feature, should not be used.
    """

    OTHER = 1
    """
    Custom feature, see custom_name.
    """

    BLIND_SPOT_WARNING = 2
    """
    Blind spot warning.
    """

    FORWARD_COLLISION_WARNING = 3
    """
    Forward collision warning.
    """

    LANE_DEPARTURE_WARNING = 4
    """
    Lane departure warning.
    """

    PARKING_COLLISION_WARNING = 5
    """
    Parking collision warning.
    """

    REAR_CROSS_TRAFFIC_WARNING = 6
    """
    Rear cross-traffic warning
    """

    AUTOMATIC_EMERGENCY_BRAKING = 7
    """
    Automatic emergency braking
    """

    AUTOMATIC_EMERGENCY_STEERING = 8
    """
    Emergency steering
    """

    REVERSE_AUTOMATIC_EMERGENCY_BRAKING = 9
    """
    Reverse automatic emergency braking
    """

    ADAPTIVE_CRUISE_CONTROL = 10
    """
    Adaptive cruise control
    """

    LANE_KEEPING_ASSIST = 11
    """
    Lane keeping assist
    """

    ACTIVE_DRIVING_ASSISTANCE = 12
    """
    Active driving assistance
    """

    BACKUP_CAMERA = 13
    """
    Backup camera
    """

    SURROUND_VIEW_CAMERA = 14
    """
    Surround view camera
    """

    ACTIVE_PARKING_ASSISTANCE = 15
    """
    Active parking assistance
    """

    REMOTE_PARKING_ASSISTANCE = 16
    """
    Remote parking assistance
    """

    TRAILER_ASSISTANCE = 17
    """
    Trailer assistance
    """

    AUTOMATIC_HIGH_BEAMS = 18
    """
    Automatic high beams
    """

    DRIVER_MONITORING = 19
    """
    Driver monitoring
    """

    HEAD_UP_DISPLAY = 20
    """
    Head up display
    """

    NIGHT_VISION = 21
    """
    Night vision
    """

    URBAN_DRIVING = 22
    """
    Urban driving
    """

    HIGHWAY_AUTOPILOT = 23
    """
    Highway autopilot.
    """

    CRUISE_CONTROL = 24
    """
    Cruise control.
    """

    SPEED_LIMIT_CONTROL = 25
    """
    Speed limit control
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "NAME_UNKNOWN",
            1: "NAME_OTHER",
            2: "NAME_BLIND_SPOT_WARNING",
            3: "NAME_FORWARD_COLLISION_WARNING",
            4: "NAME_LANE_DEPARTURE_WARNING",
            5: "NAME_PARKING_COLLISION_WARNING",
            6: "NAME_REAR_CROSS_TRAFFIC_WARNING",
            7: "NAME_AUTOMATIC_EMERGENCY_BRAKING",
            8: "NAME_AUTOMATIC_EMERGENCY_STEERING",
            9: "NAME_REVERSE_AUTOMATIC_EMERGENCY_BRAKING",
            10: "NAME_ADAPTIVE_CRUISE_CONTROL",
            11: "NAME_LANE_KEEPING_ASSIST",
            12: "NAME_ACTIVE_DRIVING_ASSISTANCE",
            13: "NAME_BACKUP_CAMERA",
            14: "NAME_SURROUND_VIEW_CAMERA",
            15: "NAME_ACTIVE_PARKING_ASSISTANCE",
            16: "NAME_REMOTE_PARKING_ASSISTANCE",
            17: "NAME_TRAILER_ASSISTANCE",
            18: "NAME_AUTOMATIC_HIGH_BEAMS",
            19: "NAME_DRIVER_MONITORING",
            20: "NAME_HEAD_UP_DISPLAY",
            21: "NAME_NIGHT_VISION",
            22: "NAME_URBAN_DRIVING",
            23: "NAME_HIGHWAY_AUTOPILOT",
            24: "NAME_CRUISE_CONTROL",
            25: "NAME_SPEED_LIMIT_CONTROL",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "NAME_UNKNOWN": 0,
            "NAME_OTHER": 1,
            "NAME_BLIND_SPOT_WARNING": 2,
            "NAME_FORWARD_COLLISION_WARNING": 3,
            "NAME_LANE_DEPARTURE_WARNING": 4,
            "NAME_PARKING_COLLISION_WARNING": 5,
            "NAME_REAR_CROSS_TRAFFIC_WARNING": 6,
            "NAME_AUTOMATIC_EMERGENCY_BRAKING": 7,
            "NAME_AUTOMATIC_EMERGENCY_STEERING": 8,
            "NAME_REVERSE_AUTOMATIC_EMERGENCY_BRAKING": 9,
            "NAME_ADAPTIVE_CRUISE_CONTROL": 10,
            "NAME_LANE_KEEPING_ASSIST": 11,
            "NAME_ACTIVE_DRIVING_ASSISTANCE": 12,
            "NAME_BACKUP_CAMERA": 13,
            "NAME_SURROUND_VIEW_CAMERA": 14,
            "NAME_ACTIVE_PARKING_ASSISTANCE": 15,
            "NAME_REMOTE_PARKING_ASSISTANCE": 16,
            "NAME_TRAILER_ASSISTANCE": 17,
            "NAME_AUTOMATIC_HIGH_BEAMS": 18,
            "NAME_DRIVER_MONITORING": 19,
            "NAME_HEAD_UP_DISPLAY": 20,
            "NAME_NIGHT_VISION": 21,
            "NAME_URBAN_DRIVING": 22,
            "NAME_HIGHWAY_AUTOPILOT": 23,
            "NAME_CRUISE_CONTROL": 24,
            "NAME_SPEED_LIMIT_CONTROL": 25,
        }


class HostVehicleDataVehicleAutomatedDrivingFunctionState(betterproto2.Enum):
    """
    The state that the feature is in.

    \\note Not all of these will be applicable for all vehicles
    and features.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_HOSTVEHICLEDATA_PROTO_DESCRIPTOR.enum_types_by_name[
            "HostVehicleData.VehicleAutomatedDrivingFunction.State"
        ]

    UNKNOWN = 0
    """
    An unknown state, this should not be used.
    """

    OTHER = 1
    """
    Used for custom states not covered by the definitions below.

    A string state can be specified in custom_state.
    """

    ERRORED = 2
    """
    The function has thrown an error in some way that renders it ineffective.
    """

    UNAVAILABLE = 3
    """
    The function cannot be used due to unfulfilled preconditions,
    for example it is a highway only feature and the vehicle is in
    an urban environment.
    """

    AVAILABLE = 4
    """
    The function can be used as all preconditions are satisfied, but
    it hasn't been enabled.
    """

    STANDBY = 5
    """
    The function is available but conditions have not caused it to be
    triggered, for example, no vehicles in front to trigger a forward collision warning.
    """

    ACTIVE = 6
    """
    The function is currently active, for example, a warning is being
    shown to the driver, or emergency braking is being applied/
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "STATE_UNKNOWN",
            1: "STATE_OTHER",
            2: "STATE_ERRORED",
            3: "STATE_UNAVAILABLE",
            4: "STATE_AVAILABLE",
            5: "STATE_STANDBY",
            6: "STATE_ACTIVE",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "STATE_UNKNOWN": 0,
            "STATE_OTHER": 1,
            "STATE_ERRORED": 2,
            "STATE_UNAVAILABLE": 3,
            "STATE_AVAILABLE": 4,
            "STATE_STANDBY": 5,
            "STATE_ACTIVE": 6,
        }


class HostVehicleDataVehicleBasicsOperatingState(betterproto2.Enum):
    """
    Possible operating states of the vehicle.
    It is user specific which states are used and how their transitions work.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_HOSTVEHICLEDATA_PROTO_DESCRIPTOR.enum_types_by_name[
            "HostVehicleData.VehicleBasics.OperatingState"
        ]

    UNKNOWN = 0
    """
    The operating state is unknown.
    """

    OTHER = 1
    """
    The operating state is another one.
    """

    SLEEP = 2
    """
    The minimum electrical state of the vehicle (and its ECUs).
    Usually the driver has left the vehicle a while ago.
    """

    STANDBY = 3
    """
    Cabin lights and entertainment are off. The vehicle can not be driven.
    Some ECUs are still operating and not in their minimum electrical sate.
    Usually the driver has left (and closed) the vehicle recently.
    """

    BOARDING = 4
    """
    Some features of the vehicle are available e.g. cabin lights.
    Entertainment is off and the vehicle can not be driven.
    Usually the driver wants to enter or leave the vehicle.
    """

    ENTERTAINMENT = 5
    """
    Entertainment, navigation or similar systems can be used by the driver.
    The vehicle can not be driven.
    Usually the driver sits in the vehicle before or after a drive.
    """

    DRIVING = 6
    """
    The electrical state that is necessary to drive the vehicle.
    """

    DIAGNOSTIC = 7
    """
    The electrical state that is necessary for analysis and diagnostics.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "OPERATING_STATE_UNKNOWN",
            1: "OPERATING_STATE_OTHER",
            2: "OPERATING_STATE_SLEEP",
            3: "OPERATING_STATE_STANDBY",
            4: "OPERATING_STATE_BOARDING",
            5: "OPERATING_STATE_ENTERTAINMENT",
            6: "OPERATING_STATE_DRIVING",
            7: "OPERATING_STATE_DIAGNOSTIC",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "OPERATING_STATE_UNKNOWN": 0,
            "OPERATING_STATE_OTHER": 1,
            "OPERATING_STATE_SLEEP": 2,
            "OPERATING_STATE_STANDBY": 3,
            "OPERATING_STATE_BOARDING": 4,
            "OPERATING_STATE_ENTERTAINMENT": 5,
            "OPERATING_STATE_DRIVING": 6,
            "OPERATING_STATE_DIAGNOSTIC": 7,
        }


class HostVehicleDataVehiclePowertrainMotorType(betterproto2.Enum):
    """
    Definition which type of motor is used.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_HOSTVEHICLEDATA_PROTO_DESCRIPTOR.enum_types_by_name[
            "HostVehicleData.VehiclePowertrain.Motor.Type"
        ]

    UNKNOWN = 0
    """
    The motor type is unknown.
    """

    OTHER = 1
    """
    It is another motor type.
    """

    OTTO = 2
    """
    A motor working after the principle of Nicolaus Otto.
    """

    DIESEL = 3
    """
    A motor working after the principle of Rudolf Diesel.
    """

    ELECTRIC = 4
    """
    A motor working electric.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "TYPE_UNKNOWN",
            1: "TYPE_OTHER",
            2: "TYPE_OTTO",
            3: "TYPE_DIESEL",
            4: "TYPE_ELECTRIC",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "TYPE_UNKNOWN": 0,
            "TYPE_OTHER": 1,
            "TYPE_OTTO": 2,
            "TYPE_DIESEL": 3,
            "TYPE_ELECTRIC": 4,
        }


class LaneClassificationSubtype(betterproto2.Enum):
    """
    Definition of available lane subtypes, aligned with OpenDRIVE.

    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_LANE_PROTO_DESCRIPTOR.enum_types_by_name[
            "Lane.Classification.Subtype"
        ]

    UNKNOWN = 0
    """
    Lane of unknown subtype. Do not use in ground truth.
    """

    OTHER = 1
    """
    Any other subtype of lane.
    """

    NORMAL = 2
    """
    A normal driving lane.
    Example: Lanes with IDs l1, l2, l3 and l4 in image \\ref
    HighwayExit.

    Since it is intended to be used for normal automotive
    driving, it should be used in combination with TYPE_DRIVING.
    """

    BIKING = 3
    """
    A lane that is designated for bicycles.

    Since it is not intended to be used for normal automotive
    driving, it should be used in combination with TYPE_NONDRIVING.
    """

    SIDEWALK = 4
    """
    A lane that is designated for pedestrians (sidewalk).

    Since it is not intended to be used for normal automotive
    driving, it should be used in combination with TYPE_NONDRIVING.
    """

    PARKING = 5
    """
    A lane with parking spaces.

    Since it is not intended to be used for normal automotive
    driving, it should be used in combination with TYPE_NONDRIVING.
    """

    STOP = 6
    """
    A hard shoulder on motorways for emergency stops.
    Example: Lane l5 in image \\ref
    HighwayExit.

    Since it is not intended to be used for normal automotive
    driving, it should be used in combination with TYPE_NONDRIVING.
    """

    RESTRICTED = 7
    """
    A lane on which cars should not drive.

    Since it is not intended to be used for normal automotive
    driving, it should be used in combination with TYPE_NONDRIVING.
    """

    BORDER = 8
    """
    A hard border on the edge of a road.

    Since it is not intended to be used for normal automotive
    driving, it should be used in combination with TYPE_NONDRIVING.
    """

    SHOULDER = 9
    """
    A soft border on the edge of a road.

    Since it is not intended to be used for normal automotive
    driving, it should be used in combination with TYPE_NONDRIVING.
    """

    EXIT = 10
    """
    A deceleration lane in parallel to the main road.
    Example: Lane l6 in image \\ref
    HighwayExit.

    Since it is intended to be used for normal automotive
    driving, it should be used in combination with TYPE_DRIVING.
    """

    ENTRY = 11
    """
    An acceleration lane in parallel to the main road.

    Since it is intended to be used for normal automotive
    driving, it should be used in combination with TYPE_DRIVING.
    """

    ONRAMP = 12
    """
    A ramp from rural or urban roads joining a motorway.

    Since it is intended to be used for normal automotive
    driving, it should be used in combination with TYPE_DRIVING.
    """

    OFFRAMP = 13
    """
    A ramp leading off a motorway onto rural or urban roads.

    Since it is intended to be used for normal automotive
    driving, it should be used in combination with TYPE_DRIVING.
    """

    CONNECTINGRAMP = 14
    """
    A ramp that connect two motorways.

    Since it is intended to be used for normal automotive
    driving, it should be used in combination with TYPE_DRIVING.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "SUBTYPE_UNKNOWN",
            1: "SUBTYPE_OTHER",
            2: "SUBTYPE_NORMAL",
            3: "SUBTYPE_BIKING",
            4: "SUBTYPE_SIDEWALK",
            5: "SUBTYPE_PARKING",
            6: "SUBTYPE_STOP",
            7: "SUBTYPE_RESTRICTED",
            8: "SUBTYPE_BORDER",
            9: "SUBTYPE_SHOULDER",
            10: "SUBTYPE_EXIT",
            11: "SUBTYPE_ENTRY",
            12: "SUBTYPE_ONRAMP",
            13: "SUBTYPE_OFFRAMP",
            14: "SUBTYPE_CONNECTINGRAMP",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "SUBTYPE_UNKNOWN": 0,
            "SUBTYPE_OTHER": 1,
            "SUBTYPE_NORMAL": 2,
            "SUBTYPE_BIKING": 3,
            "SUBTYPE_SIDEWALK": 4,
            "SUBTYPE_PARKING": 5,
            "SUBTYPE_STOP": 6,
            "SUBTYPE_RESTRICTED": 7,
            "SUBTYPE_BORDER": 8,
            "SUBTYPE_SHOULDER": 9,
            "SUBTYPE_EXIT": 10,
            "SUBTYPE_ENTRY": 11,
            "SUBTYPE_ONRAMP": 12,
            "SUBTYPE_OFFRAMP": 13,
            "SUBTYPE_CONNECTINGRAMP": 14,
        }


class LaneClassificationType(betterproto2.Enum):
    """
    Definition of available lane types.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_LANE_PROTO_DESCRIPTOR.enum_types_by_name["Lane.Classification.Type"]

    UNKNOWN = 0
    """
    Lane of unknown type (must not be used in ground truth).
    """

    OTHER = 1
    """
    Any other type of lane.
    """

    DRIVING = 2
    """
    A normal lane.
    Example: Lanes with IDs l1, l2, l3, l4 and l6 in image \\ref
    HighwayExit.
    """

    NONDRIVING = 3
    """
    A road where driving is normally not permitted.
    Example: Lane with ID l5 in image \\ref HighwayExit.
    """

    INTERSECTION = 4
    """
    An intersection as a lane.
    Example: Lane with ID l7 in image \\ref Intersection.

    \\image html OSI_X-Junction.svg "" width=600px
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "TYPE_UNKNOWN",
            1: "TYPE_OTHER",
            2: "TYPE_DRIVING",
            3: "TYPE_NONDRIVING",
            4: "TYPE_INTERSECTION",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "TYPE_UNKNOWN": 0,
            "TYPE_OTHER": 1,
            "TYPE_DRIVING": 2,
            "TYPE_NONDRIVING": 3,
            "TYPE_INTERSECTION": 4,
        }


class LaneBoundaryBoundaryPointDash(betterproto2.Enum):
    """
    This enum describes the alternation of dashes in case of a
    dashed lane boundary.

    \\note The enum descriptions adhere to the definition direction
    of the lane boundary points. This means that start or end of a
    dash are understood with respect to the direction in which the
    points of the boundary line are defined.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_LANE_PROTO_DESCRIPTOR.enum_types_by_name[
            "LaneBoundary.BoundaryPoint.Dash"
        ]

    UNKNOWN = 0
    """
    The current state of the dash alternation is not known (must
    not be used in ground truth). 
    """

    OTHER = 1
    """
    Other (unspecified but known) type of dash alternation state. 
    """

    START = 2
    """
    The current \\c BoundaryPoint indicates the start of a dash.
    """

    CONTINUE = 3
    """
    The current \\c BoundaryPoint is located on a dash of a dashed
    line. This enables a dash to continue across multiple points.
    """

    END = 4
    """
    The current \\c BoundaryPoint indicates the end of a dash.
    """

    GAP = 5
    """
    The current \\c BoundaryPoint is located in the gap between
    two dashes. When used to describe a first/last point of a lane 
    boundary, it indicates that the lane boundary starts/ends in
    a gap.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "DASH_UNKNOWN",
            1: "DASH_OTHER",
            2: "DASH_START",
            3: "DASH_CONTINUE",
            4: "DASH_END",
            5: "DASH_GAP",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "DASH_UNKNOWN": 0,
            "DASH_OTHER": 1,
            "DASH_START": 2,
            "DASH_CONTINUE": 3,
            "DASH_END": 4,
            "DASH_GAP": 5,
        }


class LaneBoundaryClassificationColor(betterproto2.Enum):
    """
    The semantic color of the lane boundary in case of a lane markings.
    Lane markings that alternate in color must be represented by
    individual \\c LaneBoundary segments.

    \\note The color types represent the semantic color classification of
    lane markings only. They do not represent an actual visual appearance.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_LANE_PROTO_DESCRIPTOR.enum_types_by_name[
            "LaneBoundary.Classification.Color"
        ]

    UNKNOWN = 0
    """
    Color of marking is unknown. Value must not be used in ground
    truth.
    """

    OTHER = 1
    """
    Other (unspecified but known) color.
    """

    NONE = 2
    """
    Marking without color. Used to represent logical boundaries
    without actual physical markings at the respective position.
    Value may be used in ground truth only.
    """

    WHITE = 3
    """
    Marking with white color.
    """

    YELLOW = 4
    """
    Marking with yellow / orange-yellow color.
    """

    RED = 5
    """
    Marking with red color
    """

    BLUE = 6
    """
    Marking with blue color.
    """

    GREEN = 7
    """
    Marking with green color;
    """

    VIOLET = 8
    """
    Marking with violet color.
    """

    ORANGE = 9
    """
    Marking with orange color.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "COLOR_UNKNOWN",
            1: "COLOR_OTHER",
            2: "COLOR_NONE",
            3: "COLOR_WHITE",
            4: "COLOR_YELLOW",
            5: "COLOR_RED",
            6: "COLOR_BLUE",
            7: "COLOR_GREEN",
            8: "COLOR_VIOLET",
            9: "COLOR_ORANGE",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "COLOR_UNKNOWN": 0,
            "COLOR_OTHER": 1,
            "COLOR_NONE": 2,
            "COLOR_WHITE": 3,
            "COLOR_YELLOW": 4,
            "COLOR_RED": 5,
            "COLOR_BLUE": 6,
            "COLOR_GREEN": 7,
            "COLOR_VIOLET": 8,
            "COLOR_ORANGE": 9,
        }


class LaneBoundaryClassificationType(betterproto2.Enum):
    """
    The lane boundary type.
    There is no special representation for double lines, e.g. solid /
    solid or dashed / solid. In such cases, each lane will define its own
    side of the lane boundary.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_LANE_PROTO_DESCRIPTOR.enum_types_by_name[
            "LaneBoundary.Classification.Type"
        ]

    UNKNOWN = 0
    """
    The type of lane boundary is unknown. Value must not be used in
    ground truth.
    """

    OTHER = 1
    """
    Unspecified but known type of lane boundary.
    Consider proposing an additional type if using TYPE_OTHER.
    """

    NO_LINE = 2
    """
    An invisible lane boundary.
    """

    SOLID_LINE = 3
    """
    A solid line at the lane boundary.
    """

    DASHED_LINE = 4
    """
    A dashed line at the lane boundary.
    """

    BOTTS_DOTS = 5
    """
    A lane boundary consisting of Botts' dots (multiple Botts dots).
    """

    ROAD_EDGE = 6
    """
    A lane boundary formed by the road's edge.
    The road edge is the end of the (paved) road surface.
    """

    SNOW_EDGE = 7
    """
    A lane boundary formed by a snow edge that may be on the road
    surface.
    """

    GRASS_EDGE = 8
    """
    A lane boundary covered by grass.
    """

    GRAVEL_EDGE = 9
    """
    A lane boundary covered by gravel.
    """

    SOIL_EDGE = 10
    """
    A lane boundary covered by soil.
    """

    GUARD_RAIL = 11
    """
    A guard rail.
    """

    CURB = 12
    """
    A curb.
    """

    STRUCTURE = 13
    """
    A structure (e.g. building or tunnel wall).
    """

    BARRIER = 14
    """
    A barrier to guide vehicles and to prevent them from entering other lanes (e.g. a concrete barrier on a highway).
    """

    SOUND_BARRIER = 15
    """
    A sound barrier.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "TYPE_UNKNOWN",
            1: "TYPE_OTHER",
            2: "TYPE_NO_LINE",
            3: "TYPE_SOLID_LINE",
            4: "TYPE_DASHED_LINE",
            5: "TYPE_BOTTS_DOTS",
            6: "TYPE_ROAD_EDGE",
            7: "TYPE_SNOW_EDGE",
            8: "TYPE_GRASS_EDGE",
            9: "TYPE_GRAVEL_EDGE",
            10: "TYPE_SOIL_EDGE",
            11: "TYPE_GUARD_RAIL",
            12: "TYPE_CURB",
            13: "TYPE_STRUCTURE",
            14: "TYPE_BARRIER",
            15: "TYPE_SOUND_BARRIER",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "TYPE_UNKNOWN": 0,
            "TYPE_OTHER": 1,
            "TYPE_NO_LINE": 2,
            "TYPE_SOLID_LINE": 3,
            "TYPE_DASHED_LINE": 4,
            "TYPE_BOTTS_DOTS": 5,
            "TYPE_ROAD_EDGE": 6,
            "TYPE_SNOW_EDGE": 7,
            "TYPE_GRASS_EDGE": 8,
            "TYPE_GRAVEL_EDGE": 9,
            "TYPE_SOIL_EDGE": 10,
            "TYPE_GUARD_RAIL": 11,
            "TYPE_CURB": 12,
            "TYPE_STRUCTURE": 13,
            "TYPE_BARRIER": 14,
            "TYPE_SOUND_BARRIER": 15,
        }


class LogicalDetectionClassification(betterproto2.Enum):
    """
    Definition of basic logical detection classifications.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_LOGICALDETECTIONDATA_PROTO_DESCRIPTOR.enum_types_by_name[
            "LogicalDetectionClassification"
        ]

    UNKNOWN = 0
    """
    Logical detection is unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) logical detection.
    """

    INVALID = 2
    """
    Invalid logical detection, not to be used for object tracking, of unspecified
    type (none of the other types applies).
    """

    CLUTTER = 3
    """
    Clutter (noise, spray, rain, fog etc.).
    """

    OVERDRIVABLE = 4
    """
    Over-drivable (ground etc.).
    """

    UNDERDRIVABLE = 5
    """
    Under-drivable (sign gantry etc.).
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "LOGICAL_DETECTION_CLASSIFICATION_UNKNOWN",
            1: "LOGICAL_DETECTION_CLASSIFICATION_OTHER",
            2: "LOGICAL_DETECTION_CLASSIFICATION_INVALID",
            3: "LOGICAL_DETECTION_CLASSIFICATION_CLUTTER",
            4: "LOGICAL_DETECTION_CLASSIFICATION_OVERDRIVABLE",
            5: "LOGICAL_DETECTION_CLASSIFICATION_UNDERDRIVABLE",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "LOGICAL_DETECTION_CLASSIFICATION_UNKNOWN": 0,
            "LOGICAL_DETECTION_CLASSIFICATION_OTHER": 1,
            "LOGICAL_DETECTION_CLASSIFICATION_INVALID": 2,
            "LOGICAL_DETECTION_CLASSIFICATION_CLUTTER": 3,
            "LOGICAL_DETECTION_CLASSIFICATION_OVERDRIVABLE": 4,
            "LOGICAL_DETECTION_CLASSIFICATION_UNDERDRIVABLE": 5,
        }


class LogicalDetectionDataHeaderDataQualifier(betterproto2.Enum):
    """
    Data qualifier communicates the overall availability of the
    interface.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_LOGICALDETECTIONDATA_PROTO_DESCRIPTOR.enum_types_by_name[
            "LogicalDetectionDataHeader.DataQualifier"
        ]

    UNKNOWN = 0
    """
    Unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known).
    """

    AVAILABLE = 2
    """
    Data is available.
    """

    AVAILABLE_REDUCED = 3
    """
    Reduced data is available.
    """

    NOT_AVAILABLE = 4
    """
    Data is not available.
    """

    BLINDNESS = 5
    """
    Sensor is blind.
    """

    TEMPORARY_AVAILABLE = 6
    """
    Sensor temporary available.
    """

    INVALID = 7
    """
    Sensor invalid.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "DATA_QUALIFIER_UNKNOWN",
            1: "DATA_QUALIFIER_OTHER",
            2: "DATA_QUALIFIER_AVAILABLE",
            3: "DATA_QUALIFIER_AVAILABLE_REDUCED",
            4: "DATA_QUALIFIER_NOT_AVAILABLE",
            5: "DATA_QUALIFIER_BLINDNESS",
            6: "DATA_QUALIFIER_TEMPORARY_AVAILABLE",
            7: "DATA_QUALIFIER_INVALID",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "DATA_QUALIFIER_UNKNOWN": 0,
            "DATA_QUALIFIER_OTHER": 1,
            "DATA_QUALIFIER_AVAILABLE": 2,
            "DATA_QUALIFIER_AVAILABLE_REDUCED": 3,
            "DATA_QUALIFIER_NOT_AVAILABLE": 4,
            "DATA_QUALIFIER_BLINDNESS": 5,
            "DATA_QUALIFIER_TEMPORARY_AVAILABLE": 6,
            "DATA_QUALIFIER_INVALID": 7,
        }


class LogicalLaneMoveDirection(betterproto2.Enum):
    """

    Describes in which direction moving objects may typically move along a
    lane.

    This describes the allowed typical driving direction on a lane, or (in
    the case of pedestrian) the allowed walking direction.

    Note: Allowed overtaking (e.g. on country roads) does not automatically
    make a lane bidirectional, since vehicles may normally only drive in the
    other direction during the overtake maneuver, not for longer periods of
    time.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_LOGICALLANE_PROTO_DESCRIPTOR.enum_types_by_name[
            "LogicalLane.MoveDirection"
        ]

    UNKNOWN = 0
    """
    Move direction is unknown. Do not use in ground truth.
    """

    OTHER = 1
    """
    Move direction fits neither of the other categories.

    Example: a lane where cars may only drive in one direction, but
    bikes may drive in both.
    """

    INCREASING_S = 2
    """
    Objects may move in increasing S direction.

    This means they move in the same direction as the reference line.
    """

    DECREASING_S = 3
    """
    Objects may move in decreasing S direction.

    This means they move in the opposite direction as the reference line.
    """

    BOTH_ALLOWED = 4
    """
    Objects may move in both directions.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "MOVE_DIRECTION_UNKNOWN",
            1: "MOVE_DIRECTION_OTHER",
            2: "MOVE_DIRECTION_INCREASING_S",
            3: "MOVE_DIRECTION_DECREASING_S",
            4: "MOVE_DIRECTION_BOTH_ALLOWED",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "MOVE_DIRECTION_UNKNOWN": 0,
            "MOVE_DIRECTION_OTHER": 1,
            "MOVE_DIRECTION_INCREASING_S": 2,
            "MOVE_DIRECTION_DECREASING_S": 3,
            "MOVE_DIRECTION_BOTH_ALLOWED": 4,
        }


class LogicalLaneTrafficRuleTrafficRuleType(betterproto2.Enum):
    """

    The type of the the traffic rule.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_LOGICALLANE_PROTO_DESCRIPTOR.enum_types_by_name[
            "LogicalLane.TrafficRule.TrafficRuleType"
        ]

    SPEED_LIMIT = 0
    """
    Traffic rule is of type speed limit
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "TRAFFIC_RULE_TYPE_SPEED_LIMIT",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "TRAFFIC_RULE_TYPE_SPEED_LIMIT": 0,
        }


class LogicalLaneType(betterproto2.Enum):
    """

    Definition of available lane types.

    This is mostly aligned with OpenDRIVE, except that lane types modeling
    access restrictions (e.g. "taxi") are not made available here. These are
    already deprecated in OpenDRIVE.  To support this, access restrictions
    should be added later, in alignment with OpenDRIVE.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_LOGICALLANE_PROTO_DESCRIPTOR.enum_types_by_name["LogicalLane.Type"]

    UNKNOWN = 0
    """
    %Lane of unknown type. Do not use in ground truth.
    """

    OTHER = 1
    """
    Any other type of lane.
    """

    NORMAL = 2
    """
    A normal driving lane.
    Example: Lanes with IDs l1, l2, l3 and l4 in image \\ref
    HighwayExit.
    This matches the OpenDRIVE type "driving".

    Note: a lane with OpenDRIVE type "bidirectional" will have an OSI
    type of TYPE_NORMAL, with <code>#move_direction ==
    #MOVE_DIRECTION_BOTH_ALLOWED</code>.
    """

    BIKING = 3
    """
    A lane that is designated for bicycles
    Note that biking lanes that cross the road (e.g. on an intersection)
    are also labeled with this type.
    """

    SIDEWALK = 4
    """
    A lane that is designated for pedestrians (sidewalk).
    Note that pedestrian lanes that cross the road (e.g. on an
    intersection) are also labeled with this type.
    """

    PARKING = 5
    """
    A lane with parking spaces.
    """

    STOP = 6
    """
    A hard shoulder on motorways for emergency stops.
    Example: Lane l5 in image \\ref
    HighwayExit.
    """

    RESTRICTED = 7
    """
    A lane on which cars should not drive.
    """

    BORDER = 8
    """
    A hard border on the edge of a road.
    """

    SHOULDER = 9
    """
    A soft border on the edge of a road.
    """

    EXIT = 10
    """
    A deceleration lane in parallel to the main road.
    Example: Lane l6 in image \\ref
    HighwayExit.
    """

    ENTRY = 11
    """
    An acceleration lane in parallel to the main road.
    """

    ONRAMP = 12
    """
    A ramp from rural or urban roads joining a motorway.
    """

    OFFRAMP = 13
    """
    A ramp leading off a motorway onto rural or urban roads.
    """

    CONNECTINGRAMP = 14
    """
    A ramp that connect two motorways.
    """

    MEDIAN = 15
    """
    A lane that sits between driving lanes
    that lead in opposite directions. It is
    typically used to separate traffic in
    towns on large roads.
    """

    CURB = 16
    """
    Curb stones. Curb stones have a different
    height than the adjacent drivable lanes.
    """

    RAIL = 17
    """
    A rail lane. This lane covers the area a train needs to drive along
    its rails.
    #overlapping_lane then describes where a train crosses other lanes.
    """

    TRAM = 18
    """
    A tram lane. This lane covers the area a tram needs to drive along
    its rails.
    #overlapping_lane then describes where a tram crosses other lanes.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "TYPE_UNKNOWN",
            1: "TYPE_OTHER",
            2: "TYPE_NORMAL",
            3: "TYPE_BIKING",
            4: "TYPE_SIDEWALK",
            5: "TYPE_PARKING",
            6: "TYPE_STOP",
            7: "TYPE_RESTRICTED",
            8: "TYPE_BORDER",
            9: "TYPE_SHOULDER",
            10: "TYPE_EXIT",
            11: "TYPE_ENTRY",
            12: "TYPE_ONRAMP",
            13: "TYPE_OFFRAMP",
            14: "TYPE_CONNECTINGRAMP",
            15: "TYPE_MEDIAN",
            16: "TYPE_CURB",
            17: "TYPE_RAIL",
            18: "TYPE_TRAM",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "TYPE_UNKNOWN": 0,
            "TYPE_OTHER": 1,
            "TYPE_NORMAL": 2,
            "TYPE_BIKING": 3,
            "TYPE_SIDEWALK": 4,
            "TYPE_PARKING": 5,
            "TYPE_STOP": 6,
            "TYPE_RESTRICTED": 7,
            "TYPE_BORDER": 8,
            "TYPE_SHOULDER": 9,
            "TYPE_EXIT": 10,
            "TYPE_ENTRY": 11,
            "TYPE_ONRAMP": 12,
            "TYPE_OFFRAMP": 13,
            "TYPE_CONNECTINGRAMP": 14,
            "TYPE_MEDIAN": 15,
            "TYPE_CURB": 16,
            "TYPE_RAIL": 17,
            "TYPE_TRAM": 18,
        }


class LogicalLaneBoundaryPassingRule(betterproto2.Enum):
    """

    Passing rule of the LogicalLaneBoundary.

    This describes how vehicles are legally allowed to move across the
    LogicalLaneBoundary. The PassingRule is determined solely based
    on the semantics of (physical) lane boundaries, not on any signs
    (i.e. it may be overridden by signs).
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_LOGICALLANE_PROTO_DESCRIPTOR.enum_types_by_name[
            "LogicalLaneBoundary.PassingRule"
        ]

    UNKNOWN = 0
    """
    Passing rule is unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Passing rule fits neither of the other categories.

    Example: this type needs to be used if passing depends on the agent
    type, e.g. if cars may change lane, but trucks may not.

    This value is also used between LogicalLanes where the traffic
    regulations do not say anything about passing rules (e.g. for a 
    LogicalLaneBoundary between LogicalLanes of TYPE_NORMAL 
    and TYPE_CURB or between LogicalLanes of TYPE_BORDER and 
    TYPE_SHOULDER) .
    """

    NONE_ALLOWED = 2
    """
    No passing is allowed (neither from left to right nor from right to
    left).
    """

    INCREASING_T = 3
    """
    Only passing in increasing T direction allowed. Passing is allowed
    from one lane to the other if the points on the target lane have
    larger T values than points on the source lane (at the same S
    position). In reference line direction (but not necessarily in
    driving direction), this means changing from right to left is
    allowed.
    """

    DECREASING_T = 4
    """
    Only passing in decreasing T direction allowed. Passing is allowed
    from one lane to the other if the points on the target lane have
    smaller T values than points on the source lane (at the same S
    position). In reference line direction (but not necessarily in
    driving direction), this means changing from left to right is
    allowed.
    """

    BOTH_ALLOWED = 5
    """
    Passing is allowed in both directions (left to right and right to
    left).
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "PASSING_RULE_UNKNOWN",
            1: "PASSING_RULE_OTHER",
            2: "PASSING_RULE_NONE_ALLOWED",
            3: "PASSING_RULE_INCREASING_T",
            4: "PASSING_RULE_DECREASING_T",
            5: "PASSING_RULE_BOTH_ALLOWED",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "PASSING_RULE_UNKNOWN": 0,
            "PASSING_RULE_OTHER": 1,
            "PASSING_RULE_NONE_ALLOWED": 2,
            "PASSING_RULE_INCREASING_T": 3,
            "PASSING_RULE_DECREASING_T": 4,
            "PASSING_RULE_BOTH_ALLOWED": 5,
        }


class MotionRequestMotionRequestType(betterproto2.Enum):
    """
    Define different options for function output.
    Each option corresponds to a field in the message.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_MOTIONREQUEST_PROTO_DESCRIPTOR.enum_types_by_name[
            "MotionRequest.MotionRequestType"
        ]

    DESIRED_STATE = 0
    """
    Desired state calculated by the function.
    """

    TRAJECTORY = 1
    """
    Desired trajectory calculated by the function.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "MOTION_REQUEST_TYPE_DESIRED_STATE",
            1: "MOTION_REQUEST_TYPE_TRAJECTORY",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "MOTION_REQUEST_TYPE_DESIRED_STATE": 0,
            "MOTION_REQUEST_TYPE_TRAJECTORY": 1,
        }


class MovingObjectPedestrianAttributesBoneType(betterproto2.Enum):
    """
    The type of the bone.

    \\image html OSI_PedestrianModelHierarchy.jpg
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_OBJECT_PROTO_DESCRIPTOR.enum_types_by_name[
            "MovingObject.PedestrianAttributes.Bone.Type"
        ]

    ROOT = 0
    """
    Root point of the pedestrian. Defined by bbcenter_to_root
    (\\c PedestrianAttributes::bbcenter_to_root).
    """

    HIP = 1
    """
    Bone defining the hip.
    """

    LOWER_SPINE = 2
    """
    Bone defining the lower part of the spine.
    """

    UPPER_SPINE = 3
    """
    Bone defining the upper part of the spine.
    """

    NECK = 4
    """
    Bone defining the neck.
    """

    HEAD = 5
    """
    Bone defining the head.
    """

    SHOULDER_L = 6
    """
    Bone defining the left shoulder.
    """

    SHOULDER_R = 7
    """
    Bone defining the right shoulder.
    """

    UPPER_ARM_L = 8
    """
    Bone defining the left upper arm.
    """

    UPPER_ARM_R = 9
    """
    Bone defining the right upper arm.
    """

    LOWER_ARM_L = 10
    """
    Bone defining the left forearm.
    """

    LOWER_ARM_R = 11
    """
    Bone defining the right forearm.
    """

    FULL_HAND_L = 12
    """
    Bone defining the left hand.
    """

    FULL_HAND_R = 13
    """
    Bone defining the right hand.
    """

    UPPER_LEG_L = 14
    """
    Bone defining the left thigh.
    """

    UPPER_LEG_R = 15
    """
    Bone defining the right thigh.
    """

    LOWER_LEG_L = 16
    """
    Bone defining the left shin.
    """

    LOWER_LEG_R = 17
    """
    Bone defining the right shin.
    """

    FULL_FOOT_L = 18
    """
    Bone defining the left foot.
    """

    FULL_FOOT_R = 19
    """
    Bone defining the right foot.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "TYPE_ROOT",
            1: "TYPE_HIP",
            2: "TYPE_LOWER_SPINE",
            3: "TYPE_UPPER_SPINE",
            4: "TYPE_NECK",
            5: "TYPE_HEAD",
            6: "TYPE_SHOULDER_L",
            7: "TYPE_SHOULDER_R",
            8: "TYPE_UPPER_ARM_L",
            9: "TYPE_UPPER_ARM_R",
            10: "TYPE_LOWER_ARM_L",
            11: "TYPE_LOWER_ARM_R",
            12: "TYPE_FULL_HAND_L",
            13: "TYPE_FULL_HAND_R",
            14: "TYPE_UPPER_LEG_L",
            15: "TYPE_UPPER_LEG_R",
            16: "TYPE_LOWER_LEG_L",
            17: "TYPE_LOWER_LEG_R",
            18: "TYPE_FULL_FOOT_L",
            19: "TYPE_FULL_FOOT_R",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "TYPE_ROOT": 0,
            "TYPE_HIP": 1,
            "TYPE_LOWER_SPINE": 2,
            "TYPE_UPPER_SPINE": 3,
            "TYPE_NECK": 4,
            "TYPE_HEAD": 5,
            "TYPE_SHOULDER_L": 6,
            "TYPE_SHOULDER_R": 7,
            "TYPE_UPPER_ARM_L": 8,
            "TYPE_UPPER_ARM_R": 9,
            "TYPE_LOWER_ARM_L": 10,
            "TYPE_LOWER_ARM_R": 11,
            "TYPE_FULL_HAND_L": 12,
            "TYPE_FULL_HAND_R": 13,
            "TYPE_UPPER_LEG_L": 14,
            "TYPE_UPPER_LEG_R": 15,
            "TYPE_LOWER_LEG_L": 16,
            "TYPE_LOWER_LEG_R": 17,
            "TYPE_FULL_FOOT_L": 18,
            "TYPE_FULL_FOOT_R": 19,
        }


class MovingObjectType(betterproto2.Enum):
    """
    Definition of object types.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_OBJECT_PROTO_DESCRIPTOR.enum_types_by_name["MovingObject.Type"]

    UNKNOWN = 0
    """
    Type of the object is unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) type of moving object.
    """

    VEHICLE = 2
    """
    Object is a vehicle.
    """

    PEDESTRIAN = 3
    """
    Object is a pedestrian.
    """

    ANIMAL = 4
    """
    Object is an animal.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "TYPE_UNKNOWN",
            1: "TYPE_OTHER",
            2: "TYPE_VEHICLE",
            3: "TYPE_PEDESTRIAN",
            4: "TYPE_ANIMAL",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "TYPE_UNKNOWN": 0,
            "TYPE_OTHER": 1,
            "TYPE_VEHICLE": 2,
            "TYPE_PEDESTRIAN": 3,
            "TYPE_ANIMAL": 4,
        }


class MovingObjectVehicleClassificationLightStateBrakeLightState(betterproto2.Enum):
    """
    Definition of brake light states.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_OBJECT_PROTO_DESCRIPTOR.enum_types_by_name[
            "MovingObject.VehicleClassification.LightState.BrakeLightState"
        ]

    UNKNOWN = 0
    """
    Brake light state is unknown (must not be used in ground
    truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) state of brake light.
    """

    OFF = 2
    """
    Brake lights are off.
    """

    NORMAL = 3
    """
    Brake lights are on with normal intensity.
    """

    STRONG = 4
    """
    Brake lights are on with extra bright intensity (indicating
    stronger braking).
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "BRAKE_LIGHT_STATE_UNKNOWN",
            1: "BRAKE_LIGHT_STATE_OTHER",
            2: "BRAKE_LIGHT_STATE_OFF",
            3: "BRAKE_LIGHT_STATE_NORMAL",
            4: "BRAKE_LIGHT_STATE_STRONG",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "BRAKE_LIGHT_STATE_UNKNOWN": 0,
            "BRAKE_LIGHT_STATE_OTHER": 1,
            "BRAKE_LIGHT_STATE_OFF": 2,
            "BRAKE_LIGHT_STATE_NORMAL": 3,
            "BRAKE_LIGHT_STATE_STRONG": 4,
        }


class MovingObjectVehicleClassificationLightStateGenericLightState(betterproto2.Enum):
    """
    Definition of generic light states for light that may be on or
    off.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_OBJECT_PROTO_DESCRIPTOR.enum_types_by_name[
            "MovingObject.VehicleClassification.LightState.GenericLightState"
        ]

    UNKNOWN = 0
    """
    Light state is unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) state of light.
    """

    OFF = 2
    """
    Light is off.
    """

    ON = 3
    """
    Light is on.
    """

    FLASHING_BLUE = 4
    """
    Light is flashing blue.
    To be used for emergency vehicles.
    """

    FLASHING_BLUE_AND_RED = 5
    """
    Light is flashing blue and red.
    To be used for emergency vehicles.
    """

    FLASHING_AMBER = 6
    """
    Light is flashing amber.
    To be used for service vehicles.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "GENERIC_LIGHT_STATE_UNKNOWN",
            1: "GENERIC_LIGHT_STATE_OTHER",
            2: "GENERIC_LIGHT_STATE_OFF",
            3: "GENERIC_LIGHT_STATE_ON",
            4: "GENERIC_LIGHT_STATE_FLASHING_BLUE",
            5: "GENERIC_LIGHT_STATE_FLASHING_BLUE_AND_RED",
            6: "GENERIC_LIGHT_STATE_FLASHING_AMBER",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "GENERIC_LIGHT_STATE_UNKNOWN": 0,
            "GENERIC_LIGHT_STATE_OTHER": 1,
            "GENERIC_LIGHT_STATE_OFF": 2,
            "GENERIC_LIGHT_STATE_ON": 3,
            "GENERIC_LIGHT_STATE_FLASHING_BLUE": 4,
            "GENERIC_LIGHT_STATE_FLASHING_BLUE_AND_RED": 5,
            "GENERIC_LIGHT_STATE_FLASHING_AMBER": 6,
        }


class MovingObjectVehicleClassificationLightStateIndicatorState(betterproto2.Enum):
    """
    Definition of indicator states.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_OBJECT_PROTO_DESCRIPTOR.enum_types_by_name[
            "MovingObject.VehicleClassification.LightState.IndicatorState"
        ]

    UNKNOWN = 0
    """
    Indicator state is unknown (must not be used in ground
    truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) state of indicator.
    """

    OFF = 2
    """
    Indicators are off.
    """

    LEFT = 3
    """
    Left indicator is on.
    """

    RIGHT = 4
    """
    Right indicator is on.
    """

    WARNING = 5
    """
    Hazard/warning light, i.e. both indicators, are on.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "INDICATOR_STATE_UNKNOWN",
            1: "INDICATOR_STATE_OTHER",
            2: "INDICATOR_STATE_OFF",
            3: "INDICATOR_STATE_LEFT",
            4: "INDICATOR_STATE_RIGHT",
            5: "INDICATOR_STATE_WARNING",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "INDICATOR_STATE_UNKNOWN": 0,
            "INDICATOR_STATE_OTHER": 1,
            "INDICATOR_STATE_OFF": 2,
            "INDICATOR_STATE_LEFT": 3,
            "INDICATOR_STATE_RIGHT": 4,
            "INDICATOR_STATE_WARNING": 5,
        }


class MovingObjectVehicleClassificationRole(betterproto2.Enum):
    """
    Definition of vehicle roles.

    The role specifies the perceived role of a vehicle. Therefore, a
    civil police car is set to ROLE_CIVIL as long as it cannot be
    perceived as a ROLE_POLICE.
    The normal use case will consist of 99% ROLE_CIVIL, as this role is
    used for normal vehicles.
    These roles may influence the behavior in traffic of the surrounding vehicles.
    To check whether a role is "active" (e.g. blue flashing light of an
    ambulance or an amber flashing light of a sweeper) can be looked up
    in message LightState.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_OBJECT_PROTO_DESCRIPTOR.enum_types_by_name[
            "MovingObject.VehicleClassification.Role"
        ]

    UNKNOWN = 0
    """
    Role of vehicle is unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) role of vehicle.
    """

    CIVIL = 2
    """
    The vehicle role is civil, e.g. a "normal" car.
    """

    AMBULANCE = 3
    """
    The vehicle role is ambulance.
    """

    FIRE = 4
    """
    The vehicle role is fire fighting, e.g. fire engine.
    """

    POLICE = 5
    """
    The vehicle role is police.
    """

    PUBLIC_TRANSPORT = 6
    """
    The vehicle role is public transport, e.g. a school bus.
    """

    ROAD_ASSISTANCE = 7
    """
    The vehicle role is roadside assistance, e.g. tow truck.
    """

    GARBAGE_COLLECTION = 8
    """
    The vehicle role is garbage collection, e.g. a garbage truck or sweeper.
    """

    ROAD_CONSTRUCTION = 9
    """
    The vehicle role is road construction, e.g. a excavator or tipper truck.
    """

    MILITARY = 10
    """
    The vehicle role is military, e.g. camouflaged truck.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "ROLE_UNKNOWN",
            1: "ROLE_OTHER",
            2: "ROLE_CIVIL",
            3: "ROLE_AMBULANCE",
            4: "ROLE_FIRE",
            5: "ROLE_POLICE",
            6: "ROLE_PUBLIC_TRANSPORT",
            7: "ROLE_ROAD_ASSISTANCE",
            8: "ROLE_GARBAGE_COLLECTION",
            9: "ROLE_ROAD_CONSTRUCTION",
            10: "ROLE_MILITARY",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "ROLE_UNKNOWN": 0,
            "ROLE_OTHER": 1,
            "ROLE_CIVIL": 2,
            "ROLE_AMBULANCE": 3,
            "ROLE_FIRE": 4,
            "ROLE_POLICE": 5,
            "ROLE_PUBLIC_TRANSPORT": 6,
            "ROLE_ROAD_ASSISTANCE": 7,
            "ROLE_GARBAGE_COLLECTION": 8,
            "ROLE_ROAD_CONSTRUCTION": 9,
            "ROLE_MILITARY": 10,
        }


class MovingObjectVehicleClassificationType(betterproto2.Enum):
    """
    Definition of vehicle types.

    \\note OSI provides a richer set of vehicle types than is supported by some
    other OpenX standards (in particular, OpenScenario 1.x and 2.x, and OpenLabel).
    This is primarily for historical reasons.  Where a single type from a
    different standard can map to multiple OSI types it is left up to the
    discretion of the OSI implementer how that mapping is achieved. In previous
    versions, for example, a simulator might have used the dimensions of a provided
    3d model of a vehicle with type "car" in OpenScenario, to determine whether it
    should be a TYPE_SMALL_CAR or TYPE_MEDIUM_CAR in OSI. As part of the harmonization
    effort, it should now map to TYPE_CAR, which is an alias of the old TYPE_MEDIUM_CAR,
    and all other car type enums have been deprecated in favor of TYPE_CAR.

    \\note Vehicle type classification is a complex area and there are no
    universally recognized standards.  As such, the boundaries between some of the
    OSI vehicle types are not well-defined.  It is left to the implementer to
    decide how to distinguish between them and agree that with any applications which
    make use of that specific interface instance.  For example, how to distinguish
    between a HEAVY_TRUCK and a DELIVERY_VAN, or a TRAILER and a SEMITRAILER.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_OBJECT_PROTO_DESCRIPTOR.enum_types_by_name[
            "MovingObject.VehicleClassification.Type"
        ]

    UNKNOWN = 0
    """
    Type of vehicle is unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) type of vehicle.
    """

    SMALL_CAR = 2
    """
    Vehicle is a small car.

    Definition: Hatchback car with maximum length 4 m.

    \\note Deprecated differentiation, use TYPE_CAR instead
    """

    COMPACT_CAR = 3
    """
    Vehicle is a compact car.

    Definition: Hatchback car with length between 4 and 4.5 m.

    \\note Deprecated differentiation, use TYPE_CAR instead
    """

    CAR = 4
    """
    Vehicle is a car.

    This is to be used for all car-like vehicles, without any
    further differentiated type available.
    """

    MEDIUM_CAR = 4
    """
    Vehicle is a medium car.

    Definition: Hatchback or sedan with length between 4.5 and 5 m.

    \\note Deprecated differentiation, use the alias TYPE_CAR instead
    """

    LUXURY_CAR = 5
    """
    Vehicle is a luxury  car.

    Definition: Sedan or coupe that is longer then 5 m.

    \\note Deprecated differentiation, use TYPE_CAR instead
    """

    DELIVERY_VAN = 6
    """
    Vehicle is a delivery van.

    \\image html OSI_TYPE_DELIVERY_VAN.svg
    """

    HEAVY_TRUCK = 7
    """
    Vehicle is a (heavy) truck.

    \\image html OSI_TYPE_HEAVY_TRUCK.svg
    """

    SEMITRACTOR = 16
    """
    Vehicle is a tractor capable of pulling a semi-trailer.

    \\image html OSI_TYPE_SEMITRACTOR.svg
    """

    SEMITRAILER = 8
    """
    This vehicle is a semi-trailer that can be pulled by a
    semi-tractor.

    \\note The vehicle can be, but doesn't need to be,
    attached to another vehicle.

    \\image html OSI_TYPE_SEMITRAILER.svg
    """

    TRAILER = 9
    """
    Vehicle is a trailer.

    \\note The vehicle can be, but doesn't need to be,
    attached to another vehicle.

    \\image html OSI_TYPE_TRAILER.svg
    """

    MOTORBIKE = 10
    """
    Vehicle is a motorbike or moped.
    """

    BICYCLE = 11
    """
    Vehicle is a bicycle (without motor and specific lights).
    """

    BUS = 12
    """
    Vehicle is a bus.
    """

    TRAM = 13
    """
    Vehicle is a tram.
    """

    TRAIN = 14
    """
    Vehicle is a train.
    """

    WHEELCHAIR = 15
    """
    Vehicle is a wheelchair.
    """

    STANDUP_SCOOTER = 17
    """
    Vehicle is a stand-up scooter, including
    motorized versions.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "TYPE_UNKNOWN",
            1: "TYPE_OTHER",
            2: "TYPE_SMALL_CAR",
            3: "TYPE_COMPACT_CAR",
            4: "TYPE_CAR",
            4: "TYPE_MEDIUM_CAR",
            5: "TYPE_LUXURY_CAR",
            6: "TYPE_DELIVERY_VAN",
            7: "TYPE_HEAVY_TRUCK",
            16: "TYPE_SEMITRACTOR",
            8: "TYPE_SEMITRAILER",
            9: "TYPE_TRAILER",
            10: "TYPE_MOTORBIKE",
            11: "TYPE_BICYCLE",
            12: "TYPE_BUS",
            13: "TYPE_TRAM",
            14: "TYPE_TRAIN",
            15: "TYPE_WHEELCHAIR",
            17: "TYPE_STANDUP_SCOOTER",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "TYPE_UNKNOWN": 0,
            "TYPE_OTHER": 1,
            "TYPE_SMALL_CAR": 2,
            "TYPE_COMPACT_CAR": 3,
            "TYPE_CAR": 4,
            "TYPE_MEDIUM_CAR": 4,
            "TYPE_LUXURY_CAR": 5,
            "TYPE_DELIVERY_VAN": 6,
            "TYPE_HEAVY_TRUCK": 7,
            "TYPE_SEMITRACTOR": 16,
            "TYPE_SEMITRAILER": 8,
            "TYPE_TRAILER": 9,
            "TYPE_MOTORBIKE": 10,
            "TYPE_BICYCLE": 11,
            "TYPE_BUS": 12,
            "TYPE_TRAM": 13,
            "TYPE_TRAIN": 14,
            "TYPE_WHEELCHAIR": 15,
            "TYPE_STANDUP_SCOOTER": 17,
        }


class OccupantClassificationSeat(betterproto2.Enum):
    """
    Definition of seat positions.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_OCCUPANT_PROTO_DESCRIPTOR.enum_types_by_name[
            "Occupant.Classification.Seat"
        ]

    UNKNOWN = 0
    """
    Seat position is unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) seat.
    """

    FRONT_LEFT = 2
    """
    Seat position is in the front row, left seat.
    This is usually the driver's seat in right-hand traffic.
    """

    FRONT_RIGHT = 3
    """
    Seat position is in the front row, right seat.
    This is usually the driver's seat in left-hand traffic.
    """

    FRONT_MIDDLE = 4
    """
    Seat position is in the front row, middle seat.
    """

    BACK_LEFT = 5
    """
    Seat position is in the back row, left seat.
    """

    BACK_RIGHT = 6
    """
    Seat position is in the back row, right seat.
    """

    BACK_MIDDLE = 7
    """
    Seat position is in the back row, middle seat.
    """

    THIRD_ROW_LEFT = 8
    """
    Seat position is in the third row, left seat.
    """

    THIRD_ROW_RIGHT = 9
    """
    Seat position is in the third row, right seat.
    """

    THIRD_ROW_MIDDLE = 10
    """
    Seat position is in the third row, middle seat.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "SEAT_UNKNOWN",
            1: "SEAT_OTHER",
            2: "SEAT_FRONT_LEFT",
            3: "SEAT_FRONT_RIGHT",
            4: "SEAT_FRONT_MIDDLE",
            5: "SEAT_BACK_LEFT",
            6: "SEAT_BACK_RIGHT",
            7: "SEAT_BACK_MIDDLE",
            8: "SEAT_THIRD_ROW_LEFT",
            9: "SEAT_THIRD_ROW_RIGHT",
            10: "SEAT_THIRD_ROW_MIDDLE",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "SEAT_UNKNOWN": 0,
            "SEAT_OTHER": 1,
            "SEAT_FRONT_LEFT": 2,
            "SEAT_FRONT_RIGHT": 3,
            "SEAT_FRONT_MIDDLE": 4,
            "SEAT_BACK_LEFT": 5,
            "SEAT_BACK_RIGHT": 6,
            "SEAT_BACK_MIDDLE": 7,
            "SEAT_THIRD_ROW_LEFT": 8,
            "SEAT_THIRD_ROW_RIGHT": 9,
            "SEAT_THIRD_ROW_MIDDLE": 10,
        }


class OccupantClassificationSteeringControl(betterproto2.Enum):
    """
    Definition of hands related to the steering wheel (mostly driver).
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_OCCUPANT_PROTO_DESCRIPTOR.enum_types_by_name[
            "Occupant.Classification.SteeringControl"
        ]

    UNKNOWN = 0
    """
    Hands state is unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) hand positioning related to the
    steering wheel.
    """

    NO_HAND = 2
    """
    Hands are not on the steering wheel.
    """

    ONE_HAND = 3
    """
    One hand is on the steering wheel. Whether it is the left or
    right hand is unspecified or unknown.

    \\note If there is no differentiation between one or both hands on
    the steering wheel, this value should be used.
    """

    BOTH_HANDS = 4
    """
    Both hands are on the steering wheel.
    """

    LEFT_HAND = 5
    """
    Only left hand is on the steering wheel.
    """

    RIGHT_HAND = 6
    """
    Only right hand is on the steering wheel.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "STEERING_CONTROL_UNKNOWN",
            1: "STEERING_CONTROL_OTHER",
            2: "STEERING_CONTROL_NO_HAND",
            3: "STEERING_CONTROL_ONE_HAND",
            4: "STEERING_CONTROL_BOTH_HANDS",
            5: "STEERING_CONTROL_LEFT_HAND",
            6: "STEERING_CONTROL_RIGHT_HAND",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "STEERING_CONTROL_UNKNOWN": 0,
            "STEERING_CONTROL_OTHER": 1,
            "STEERING_CONTROL_NO_HAND": 2,
            "STEERING_CONTROL_ONE_HAND": 3,
            "STEERING_CONTROL_BOTH_HANDS": 4,
            "STEERING_CONTROL_LEFT_HAND": 5,
            "STEERING_CONTROL_RIGHT_HAND": 6,
        }


class ReferenceLineType(betterproto2.Enum):
    """
    ReferenceLine types

    ReferenceLinePoints might be interpreted differently depending on the type
    of the ReferenceLine.

    See also: "Adding T coordinates"
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_REFERENCELINE_PROTO_DESCRIPTOR.enum_types_by_name[
            "ReferenceLine.Type"
        ]

    POLYLINE = 0
    """
    ReferenceLine is a polyline, where the coordinates of points are
    calculated by projection onto the nearest point on the line.

    \\attention DEPRECATED: Due to the shortcomings documented below, this
               type will be removed in 4.0.0.
    """

    POLYLINE_WITH_T_AXIS = 1
    """
    ReferenceLine is a polyline, where the coordinates of points are
    calculated using the T axis definition.

    \\note If this type is used, ReferenceLinePoint::t_axis_yaw must be set.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "TYPE_POLYLINE",
            1: "TYPE_POLYLINE_WITH_T_AXIS",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "TYPE_POLYLINE": 0,
            "TYPE_POLYLINE_WITH_T_AXIS": 1,
        }


class RoadMarkingClassificationColor(betterproto2.Enum):
    """
    Definition of semantic road marking colors

    \\note The color types represent the semantic classification of
    road markings only. They do not represent an actual visual appearance.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_ROADMARKING_PROTO_DESCRIPTOR.enum_types_by_name[
            "RoadMarking.Classification.Color"
        ]

    UNKNOWN = 0
    """
    Color of road marking is unknown (must not be used in ground
    truth).
    """

    OTHER = 1
    """
    Marking with another (unspecified but known) color.
    """

    WHITE = 2
    """
    Marking with white color.
    """

    YELLOW = 3
    """
    Marking with yellow / orange-yellow color.
    """

    BLUE = 5
    """
    Marking with blue color.
    """

    RED = 6
    """
    Marking with red color.
    """

    GREEN = 7
    """
    Marking with green color.
    """

    VIOLET = 8
    """
    Marking with violet color.
    """

    ORANGE = 9
    """
    Marking with orange color.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "COLOR_UNKNOWN",
            1: "COLOR_OTHER",
            2: "COLOR_WHITE",
            3: "COLOR_YELLOW",
            5: "COLOR_BLUE",
            6: "COLOR_RED",
            7: "COLOR_GREEN",
            8: "COLOR_VIOLET",
            9: "COLOR_ORANGE",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "COLOR_UNKNOWN": 0,
            "COLOR_OTHER": 1,
            "COLOR_WHITE": 2,
            "COLOR_YELLOW": 3,
            "COLOR_BLUE": 5,
            "COLOR_RED": 6,
            "COLOR_GREEN": 7,
            "COLOR_VIOLET": 8,
            "COLOR_ORANGE": 9,
        }


class RoadMarkingClassificationType(betterproto2.Enum):
    """
    Definition of road marking types.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_ROADMARKING_PROTO_DESCRIPTOR.enum_types_by_name[
            "RoadMarking.Classification.Type"
        ]

    UNKNOWN = 0
    """
    Type of road marking is unknown (must not be used in ground
    truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) type of road marking.
    """

    PAINTED_TRAFFIC_SIGN = 2
    """
    Paint on the road surface indicating a color image of a traffic
    sign.
    """

    SYMBOLIC_TRAFFIC_SIGN = 3
    """
    Paint on the road surface indicating a monochrome logical symbol
    of a traffic sign (e.g. digits 50 as start of speed limit 50 or
    stop line for stop sign).
    """

    TEXTUAL_TRAFFIC_SIGN = 4
    """
    Paint on the road surface as a character string (e.g. BUS as bus
    only lane).
    """

    GENERIC_SYMBOL = 5
    """
    Paint on the road surface indicating a generic symbol.
    """

    GENERIC_LINE = 6
    """
    Paint on the road surface indicating a generic line.
    """

    GENERIC_TEXT = 7
    """
    Paint on the road surface indicating a generic character string.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "TYPE_UNKNOWN",
            1: "TYPE_OTHER",
            2: "TYPE_PAINTED_TRAFFIC_SIGN",
            3: "TYPE_SYMBOLIC_TRAFFIC_SIGN",
            4: "TYPE_TEXTUAL_TRAFFIC_SIGN",
            5: "TYPE_GENERIC_SYMBOL",
            6: "TYPE_GENERIC_LINE",
            7: "TYPE_GENERIC_TEXT",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "TYPE_UNKNOWN": 0,
            "TYPE_OTHER": 1,
            "TYPE_PAINTED_TRAFFIC_SIGN": 2,
            "TYPE_SYMBOLIC_TRAFFIC_SIGN": 3,
            "TYPE_TEXTUAL_TRAFFIC_SIGN": 4,
            "TYPE_GENERIC_SYMBOL": 5,
            "TYPE_GENERIC_LINE": 6,
            "TYPE_GENERIC_TEXT": 7,
        }


class SensorDetectionHeaderDataQualifier(betterproto2.Enum):
    """
    Data qualifier communicates the overall availability of the
    interface.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_FEATUREDATA_PROTO_DESCRIPTOR.enum_types_by_name[
            "SensorDetectionHeader.DataQualifier"
        ]

    UNKNOWN = 0
    """
    Unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known).
    """

    AVAILABLE = 2
    """
    Data is available.
    """

    AVAILABLE_REDUCED = 3
    """
    Reduced data is available.
    """

    NOT_AVAILABLE = 4
    """
    Data is not available.
    """

    BLINDNESS = 5
    """
    Sensor is blind.
    """

    TEMPORARY_AVAILABLE = 6
    """
    Sensor temporary available.
    """

    INVALID = 7
    """
    Sensor invalid.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "DATA_QUALIFIER_UNKNOWN",
            1: "DATA_QUALIFIER_OTHER",
            2: "DATA_QUALIFIER_AVAILABLE",
            3: "DATA_QUALIFIER_AVAILABLE_REDUCED",
            4: "DATA_QUALIFIER_NOT_AVAILABLE",
            5: "DATA_QUALIFIER_BLINDNESS",
            6: "DATA_QUALIFIER_TEMPORARY_AVAILABLE",
            7: "DATA_QUALIFIER_INVALID",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "DATA_QUALIFIER_UNKNOWN": 0,
            "DATA_QUALIFIER_OTHER": 1,
            "DATA_QUALIFIER_AVAILABLE": 2,
            "DATA_QUALIFIER_AVAILABLE_REDUCED": 3,
            "DATA_QUALIFIER_NOT_AVAILABLE": 4,
            "DATA_QUALIFIER_BLINDNESS": 5,
            "DATA_QUALIFIER_TEMPORARY_AVAILABLE": 6,
            "DATA_QUALIFIER_INVALID": 7,
        }


class SensorDetectionHeaderExtendedQualifier(betterproto2.Enum):
    """
    The extended qualifier describes the reason (not the effect) why the
    event data qualifier, \\c #data_qualifier, is reduced or not available.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_FEATUREDATA_PROTO_DESCRIPTOR.enum_types_by_name[
            "SensorDetectionHeader.ExtendedQualifier"
        ]

    UNKNOWN = 0
    """
    Unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known).
    """

    NORMAL_OPERATION_MODE = 2
    """
    Normal operation mode.
    """

    POWER_UP_OR_DOWN = 3
    """
    Power up or down.
    """

    SENSOR_NOT_CALIBRATED = 4
    """
    Sensor not calibrated.
    """

    SENSOR_BLOCKED = 5
    """
    Sensor blocked.
    """

    SENSOR_MISALIGNED = 6
    """
    Sensor misaligned.
    """

    BAD_SENSOR_ENVIRONMENTAL_CONDITION = 7
    """
    Bad sensor environmental condition (e.g. Darkness for vision).
    """

    REDUCED_FIELD_OF_VIEW = 8
    """
    Reduced field of view.
    """

    INPUT_NOT_AVAILABLE = 9
    """
    Input not available.
    """

    INTERNAL_REASON = 10
    """
    Internal reason (e.g. an internal hardware or software error has occurred).
    """

    EXTERNAL_DISTURBANCE = 11
    """
    External disturbance, sensor specific for front radar (e.g.
    Interference of different radar sensors).
    """

    BEGINNING_BLOCKAGE = 12
    """
    Beginning blockage, sensor specific for front radar.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "EXTENDED_QUALIFIER_UNKNOWN",
            1: "EXTENDED_QUALIFIER_OTHER",
            2: "EXTENDED_QUALIFIER_NORMAL_OPERATION_MODE",
            3: "EXTENDED_QUALIFIER_POWER_UP_OR_DOWN",
            4: "EXTENDED_QUALIFIER_SENSOR_NOT_CALIBRATED",
            5: "EXTENDED_QUALIFIER_SENSOR_BLOCKED",
            6: "EXTENDED_QUALIFIER_SENSOR_MISALIGNED",
            7: "EXTENDED_QUALIFIER_BAD_SENSOR_ENVIRONMENTAL_CONDITION",
            8: "EXTENDED_QUALIFIER_REDUCED_FIELD_OF_VIEW",
            9: "EXTENDED_QUALIFIER_INPUT_NOT_AVAILABLE",
            10: "EXTENDED_QUALIFIER_INTERNAL_REASON",
            11: "EXTENDED_QUALIFIER_EXTERNAL_DISTURBANCE",
            12: "EXTENDED_QUALIFIER_BEGINNING_BLOCKAGE",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "EXTENDED_QUALIFIER_UNKNOWN": 0,
            "EXTENDED_QUALIFIER_OTHER": 1,
            "EXTENDED_QUALIFIER_NORMAL_OPERATION_MODE": 2,
            "EXTENDED_QUALIFIER_POWER_UP_OR_DOWN": 3,
            "EXTENDED_QUALIFIER_SENSOR_NOT_CALIBRATED": 4,
            "EXTENDED_QUALIFIER_SENSOR_BLOCKED": 5,
            "EXTENDED_QUALIFIER_SENSOR_MISALIGNED": 6,
            "EXTENDED_QUALIFIER_BAD_SENSOR_ENVIRONMENTAL_CONDITION": 7,
            "EXTENDED_QUALIFIER_REDUCED_FIELD_OF_VIEW": 8,
            "EXTENDED_QUALIFIER_INPUT_NOT_AVAILABLE": 9,
            "EXTENDED_QUALIFIER_INTERNAL_REASON": 10,
            "EXTENDED_QUALIFIER_EXTERNAL_DISTURBANCE": 11,
            "EXTENDED_QUALIFIER_BEGINNING_BLOCKAGE": 12,
        }


class StationaryObjectClassificationColor(betterproto2.Enum):
    """
    Definition of colors for structures.

    \\attention DEPRECATED: This color enum will be removed in version
    4.0.0. Use \\c ColorDescription instead.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_OBJECT_PROTO_DESCRIPTOR.enum_types_by_name[
            "StationaryObject.Classification.Color"
        ]

    UNKNOWN = 0
    """
    Color is unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) color.
    """

    YELLOW = 2
    """
    Yellow.
    """

    GREEN = 3
    """
    Green.
    """

    BLUE = 4
    """
    Blue.
    """

    VIOLET = 5
    """
    Violet.
    """

    RED = 6
    """
    Red.
    """

    ORANGE = 7
    """
    Orange.
    """

    BLACK = 8
    """
    Black.
    """

    GRAY = 9
    """
    GRAY.
    """

    GREY = 9
    """
    GRAY.

    \\note Deprecated variant spelling of COLOR_GRAY
    """

    WHITE = 10
    """
    White.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "COLOR_UNKNOWN",
            1: "COLOR_OTHER",
            2: "COLOR_YELLOW",
            3: "COLOR_GREEN",
            4: "COLOR_BLUE",
            5: "COLOR_VIOLET",
            6: "COLOR_RED",
            7: "COLOR_ORANGE",
            8: "COLOR_BLACK",
            9: "COLOR_GRAY",
            9: "COLOR_GREY",
            10: "COLOR_WHITE",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "COLOR_UNKNOWN": 0,
            "COLOR_OTHER": 1,
            "COLOR_YELLOW": 2,
            "COLOR_GREEN": 3,
            "COLOR_BLUE": 4,
            "COLOR_VIOLET": 5,
            "COLOR_RED": 6,
            "COLOR_ORANGE": 7,
            "COLOR_BLACK": 8,
            "COLOR_GRAY": 9,
            "COLOR_GREY": 9,
            "COLOR_WHITE": 10,
        }


class StationaryObjectClassificationDensity(betterproto2.Enum):
    """
    Definition of material density types.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_OBJECT_PROTO_DESCRIPTOR.enum_types_by_name[
            "StationaryObject.Classification.Density"
        ]

    UNKNOWN = 0
    """
    Type of the material density is unknown (must not be used in
    ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) type of material density.
    """

    SOLID = 2
    """
    No perforation - solid;
    """

    SMALL_MESH = 3
    """
    Perforation max. ]0; 100] mm
    """

    MEDIAN_MESH = 4
    """
    Perforation max. ]100; 500] mm
    """

    LARGE_MESH = 5
    """
    Perforation max. ]500; 5000] mm
    """

    OPEN = 6
    """
    Perforation max. ]5000; infinity[ mm
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "DENSITY_UNKNOWN",
            1: "DENSITY_OTHER",
            2: "DENSITY_SOLID",
            3: "DENSITY_SMALL_MESH",
            4: "DENSITY_MEDIAN_MESH",
            5: "DENSITY_LARGE_MESH",
            6: "DENSITY_OPEN",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "DENSITY_UNKNOWN": 0,
            "DENSITY_OTHER": 1,
            "DENSITY_SOLID": 2,
            "DENSITY_SMALL_MESH": 3,
            "DENSITY_MEDIAN_MESH": 4,
            "DENSITY_LARGE_MESH": 5,
            "DENSITY_OPEN": 6,
        }


class StationaryObjectClassificationMaterial(betterproto2.Enum):
    """
    Definition of material types.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_OBJECT_PROTO_DESCRIPTOR.enum_types_by_name[
            "StationaryObject.Classification.Material"
        ]

    UNKNOWN = 0
    """
    Type of the material is unknown (must not be used in ground
    truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) type of material.
    """

    WOOD = 2
    """
    Wooden structure.
    """

    PLASTIC = 3
    """
    Plastic structure.
    """

    CONCRETE = 4
    """
    Concrete structure.
    """

    METAL = 5
    """
    Metal structure.
    """

    STONE = 6
    """
    Natural stone structure.
    """

    GLASS = 7
    """
    Glass structure.
    """

    GLAS = 7
    """
    Glass structure.

    \\note Deprecated variant spelling of MATERIAL_GLASS
    """

    MUD = 8
    """
    Mud structure.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "MATERIAL_UNKNOWN",
            1: "MATERIAL_OTHER",
            2: "MATERIAL_WOOD",
            3: "MATERIAL_PLASTIC",
            4: "MATERIAL_CONCRETE",
            5: "MATERIAL_METAL",
            6: "MATERIAL_STONE",
            7: "MATERIAL_GLASS",
            7: "MATERIAL_GLAS",
            8: "MATERIAL_MUD",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "MATERIAL_UNKNOWN": 0,
            "MATERIAL_OTHER": 1,
            "MATERIAL_WOOD": 2,
            "MATERIAL_PLASTIC": 3,
            "MATERIAL_CONCRETE": 4,
            "MATERIAL_METAL": 5,
            "MATERIAL_STONE": 6,
            "MATERIAL_GLASS": 7,
            "MATERIAL_GLAS": 7,
            "MATERIAL_MUD": 8,
        }


class StationaryObjectClassificationType(betterproto2.Enum):
    """
    Definition of object types.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_OBJECT_PROTO_DESCRIPTOR.enum_types_by_name[
            "StationaryObject.Classification.Type"
        ]

    UNKNOWN = 0
    """
    Type of the object is unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) type of object.
    """

    BRIDGE = 2
    """
    Object is a bridge.
    """

    BUILDING = 3
    """
    Object is a building.
    """

    POLE = 4
    """
    Object is a pole (e.g. from a traffic light).
    """

    PYLON = 5
    """
    Object is a pylon.
    """

    DELINEATOR = 6
    """
    Object is a delineator (e.g. at a construction site).
    """

    TREE = 7
    """
    Object is a tree.
    """

    BARRIER = 8
    """
    Object is a barrier.
    """

    VEGETATION = 9
    """
    Object is vegetation.
    """

    CURBSTONE = 10
    """
    Object is a curbstone.
    """

    WALL = 11
    """
    Object is a wall.
    """

    VERTICAL_STRUCTURE = 12
    """
    Landmarks corresponding to vertical structures in the
    environment.
    """

    RECTANGULAR_STRUCTURE = 13
    """
    Landmarks corresponding to rectangular structures in the
    environment, like walls.
    """

    OVERHEAD_STRUCTURE = 14
    """
    Landmarks corresponding to overhead structures in the
    environment, like sign bridges.
    """

    REFLECTIVE_STRUCTURE = 15
    """
    Landmarks corresponding to reflective structures
    in the environment, like reflective poles on the
    road boarder.
    """

    CONSTRUCTION_SITE_ELEMENT = 16
    """
    Landmarks corresponding to construction site elements in the
    environment, like beacons.
    """

    SPEED_BUMP = 17
    """
    Object is a speed bump.
    """

    EMITTING_STRUCTURE = 18
    """
    Landmarks corresponding to sources of electromagnetic waves
    in the environment, like street lights.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "TYPE_UNKNOWN",
            1: "TYPE_OTHER",
            2: "TYPE_BRIDGE",
            3: "TYPE_BUILDING",
            4: "TYPE_POLE",
            5: "TYPE_PYLON",
            6: "TYPE_DELINEATOR",
            7: "TYPE_TREE",
            8: "TYPE_BARRIER",
            9: "TYPE_VEGETATION",
            10: "TYPE_CURBSTONE",
            11: "TYPE_WALL",
            12: "TYPE_VERTICAL_STRUCTURE",
            13: "TYPE_RECTANGULAR_STRUCTURE",
            14: "TYPE_OVERHEAD_STRUCTURE",
            15: "TYPE_REFLECTIVE_STRUCTURE",
            16: "TYPE_CONSTRUCTION_SITE_ELEMENT",
            17: "TYPE_SPEED_BUMP",
            18: "TYPE_EMITTING_STRUCTURE",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "TYPE_UNKNOWN": 0,
            "TYPE_OTHER": 1,
            "TYPE_BRIDGE": 2,
            "TYPE_BUILDING": 3,
            "TYPE_POLE": 4,
            "TYPE_PYLON": 5,
            "TYPE_DELINEATOR": 6,
            "TYPE_TREE": 7,
            "TYPE_BARRIER": 8,
            "TYPE_VEGETATION": 9,
            "TYPE_CURBSTONE": 10,
            "TYPE_WALL": 11,
            "TYPE_VERTICAL_STRUCTURE": 12,
            "TYPE_RECTANGULAR_STRUCTURE": 13,
            "TYPE_OVERHEAD_STRUCTURE": 14,
            "TYPE_REFLECTIVE_STRUCTURE": 15,
            "TYPE_CONSTRUCTION_SITE_ELEMENT": 16,
            "TYPE_SPEED_BUMP": 17,
            "TYPE_EMITTING_STRUCTURE": 18,
        }


class TrafficActionDynamicsShape(betterproto2.Enum):
    """
    Definition of dynamic shapes.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_TRAFFICCOMMAND_PROTO_DESCRIPTOR.enum_types_by_name[
            "TrafficAction.DynamicsShape"
        ]

    UNSPECIFIED = 0
    """
    Shape is unspecified.
    """

    LINEAR = 1
    """
    Shape is linear.
    """

    CUBIC = 2
    """
    Shape is cubic.
    """

    SINUSOIDAL = 3
    """
    Shape is sinusoidal.
    """

    STEP = 4
    """
    Shape is a step function.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "DYNAMICS_SHAPE_UNSPECIFIED",
            1: "DYNAMICS_SHAPE_LINEAR",
            2: "DYNAMICS_SHAPE_CUBIC",
            3: "DYNAMICS_SHAPE_SINUSOIDAL",
            4: "DYNAMICS_SHAPE_STEP",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "DYNAMICS_SHAPE_UNSPECIFIED": 0,
            "DYNAMICS_SHAPE_LINEAR": 1,
            "DYNAMICS_SHAPE_CUBIC": 2,
            "DYNAMICS_SHAPE_SINUSOIDAL": 3,
            "DYNAMICS_SHAPE_STEP": 4,
        }


class TrafficActionFollowingMode(betterproto2.Enum):
    """
    Definition of following mode.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_TRAFFICCOMMAND_PROTO_DESCRIPTOR.enum_types_by_name[
            "TrafficAction.FollowingMode"
        ]

    POSITION = 0
    """
    Following mode position forces the traffic participant to
    follow a path/trajectory explicitly, disregarding any internal
    constraints, for example, steering dynamics.
    """

    FOLLOW = 1
    """
    Following mode follow allows the traffic participant to
    treat a path/trajectory as a target, to be achieved as closely
    as possible while retaining any internal constraints,
    for example, steering dynamics.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "FOLLOWING_MODE_POSITION",
            1: "FOLLOWING_MODE_FOLLOW",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "FOLLOWING_MODE_POSITION": 0,
            "FOLLOWING_MODE_FOLLOW": 1,
        }


class TrafficLightClassificationColor(betterproto2.Enum):
    """
    Definition of semantic colors for traffic lights.

    \\note The color types represent the semantic classification of a traffic light
    only. They do not represent an actual visual appearance.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_TRAFFICLIGHT_PROTO_DESCRIPTOR.enum_types_by_name[
            "TrafficLight.Classification.Color"
        ]

    UNKNOWN = 0
    """
    Color is unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) color.
    """

    RED = 2
    """
    Red light.
    """

    YELLOW = 3
    """
    Orange-yellow light.
    """

    GREEN = 4
    """
    Green light.
    """

    BLUE = 5
    """
    Blue light.
    """

    WHITE = 6
    """
    White light.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "COLOR_UNKNOWN",
            1: "COLOR_OTHER",
            2: "COLOR_RED",
            3: "COLOR_YELLOW",
            4: "COLOR_GREEN",
            5: "COLOR_BLUE",
            6: "COLOR_WHITE",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "COLOR_UNKNOWN": 0,
            "COLOR_OTHER": 1,
            "COLOR_RED": 2,
            "COLOR_YELLOW": 3,
            "COLOR_GREEN": 4,
            "COLOR_BLUE": 5,
            "COLOR_WHITE": 6,
        }


class TrafficLightClassificationIcon(betterproto2.Enum):
    """
    Definition of traffic light bulb icon.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_TRAFFICLIGHT_PROTO_DESCRIPTOR.enum_types_by_name[
            "TrafficLight.Classification.Icon"
        ]

    UNKNOWN = 0
    """
    Unknown icon of traffic light (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) icon of traffic light.
    """

    NONE = 2
    """
    This is a normal traffic light without specification of e.g.
    direction.
    """

    ARROW_STRAIGHT_AHEAD = 3
    """
    This traffic light applies to the lane straight ahead.
    """

    ARROW_LEFT = 4
    """
    This traffic light applies to left turns.
    """

    ARROW_DIAG_LEFT = 5
    """
    This traffic light applies to diagonal left turns.
    """

    ARROW_STRAIGHT_AHEAD_LEFT = 6
    """
    This traffic light applies to a lane allowing to drive straight
    ahead or to turn left.
    """

    ARROW_RIGHT = 7
    """
    This traffic light applies to right turns.
    """

    ARROW_DIAG_RIGHT = 8
    """
    This traffic light applies to diagonal right turns.
    """

    ARROW_STRAIGHT_AHEAD_RIGHT = 9
    """
    This traffic light applies to a lane allowing to drive straight
    ahead or to turn right.
    """

    ARROW_LEFT_RIGHT = 10
    """
    This traffic light applies to a lane allowing to turn left or
    right.
    """

    ARROW_DOWN = 11
    """
    This traffic light indicates that the assigned lane is open for
    driving.
    """

    ARROW_DOWN_LEFT = 12
    """
    This traffic light indicates a necessary lane change to the left
    ahead.
    """

    ARROW_DOWN_RIGHT = 13
    """
    This traffic light indicates a necessary lane change to the right
    ahead.
    """

    ARROW_CROSS = 14
    """
    This traffic light indicates that the assigned lane is not open
    for driving.
    """

    PEDESTRIAN = 15
    """
    This traffic light is valid for pedestrians.
    """

    WALK = 16
    """
    This traffic light is valid for pedestrians with letters 'walk'.
    """

    DONT_WALK = 17
    """
    This traffic light is valid for pedestrians with letters 'don't
    walk'.
    """

    BICYCLE = 18
    """
    This traffic light is valid for bicyclists.
    """

    PEDESTRIAN_AND_BICYCLE = 19
    """
    This traffic light is valid for pedestrians and bicyclists.
    """

    COUNTDOWN_SECONDS = 20
    """
    This traffic light counter in second.
    """

    COUNTDOWN_PERCENT = 21
    """
    This traffic light counter in percent.
    """

    TRAM = 22
    """
    This traffic light is valid for
    trams.

    \\note There is no detailed traffic light specification for trams
    and buses at the moment.
    """

    BUS = 23
    """
    This traffic light is valid for
    buses.

    \\note There is no detailed traffic light specification for trams
    and buses at the moment.
    """

    BUS_AND_TRAM = 24
    """
    This traffic light is valid for
    buses and trams.

    \\note There is no detailed traffic light specification for trams
    and buses at the moment.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "ICON_UNKNOWN",
            1: "ICON_OTHER",
            2: "ICON_NONE",
            3: "ICON_ARROW_STRAIGHT_AHEAD",
            4: "ICON_ARROW_LEFT",
            5: "ICON_ARROW_DIAG_LEFT",
            6: "ICON_ARROW_STRAIGHT_AHEAD_LEFT",
            7: "ICON_ARROW_RIGHT",
            8: "ICON_ARROW_DIAG_RIGHT",
            9: "ICON_ARROW_STRAIGHT_AHEAD_RIGHT",
            10: "ICON_ARROW_LEFT_RIGHT",
            11: "ICON_ARROW_DOWN",
            12: "ICON_ARROW_DOWN_LEFT",
            13: "ICON_ARROW_DOWN_RIGHT",
            14: "ICON_ARROW_CROSS",
            15: "ICON_PEDESTRIAN",
            16: "ICON_WALK",
            17: "ICON_DONT_WALK",
            18: "ICON_BICYCLE",
            19: "ICON_PEDESTRIAN_AND_BICYCLE",
            20: "ICON_COUNTDOWN_SECONDS",
            21: "ICON_COUNTDOWN_PERCENT",
            22: "ICON_TRAM",
            23: "ICON_BUS",
            24: "ICON_BUS_AND_TRAM",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "ICON_UNKNOWN": 0,
            "ICON_OTHER": 1,
            "ICON_NONE": 2,
            "ICON_ARROW_STRAIGHT_AHEAD": 3,
            "ICON_ARROW_LEFT": 4,
            "ICON_ARROW_DIAG_LEFT": 5,
            "ICON_ARROW_STRAIGHT_AHEAD_LEFT": 6,
            "ICON_ARROW_RIGHT": 7,
            "ICON_ARROW_DIAG_RIGHT": 8,
            "ICON_ARROW_STRAIGHT_AHEAD_RIGHT": 9,
            "ICON_ARROW_LEFT_RIGHT": 10,
            "ICON_ARROW_DOWN": 11,
            "ICON_ARROW_DOWN_LEFT": 12,
            "ICON_ARROW_DOWN_RIGHT": 13,
            "ICON_ARROW_CROSS": 14,
            "ICON_PEDESTRIAN": 15,
            "ICON_WALK": 16,
            "ICON_DONT_WALK": 17,
            "ICON_BICYCLE": 18,
            "ICON_PEDESTRIAN_AND_BICYCLE": 19,
            "ICON_COUNTDOWN_SECONDS": 20,
            "ICON_COUNTDOWN_PERCENT": 21,
            "ICON_TRAM": 22,
            "ICON_BUS": 23,
            "ICON_BUS_AND_TRAM": 24,
        }


class TrafficLightClassificationMode(betterproto2.Enum):
    """
    Definition of light modes for traffic lights.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_TRAFFICLIGHT_PROTO_DESCRIPTOR.enum_types_by_name[
            "TrafficLight.Classification.Mode"
        ]

    UNKNOWN = 0
    """
    Mode is unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) mode.
    """

    OFF = 2
    """
    Traffic light is off.
    """

    CONSTANT = 3
    """
    Light is on and not flashing.
    """

    FLASHING = 4
    """
    Light is flashing.
    """

    COUNTING = 5
    """
    Light is counting.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "MODE_UNKNOWN",
            1: "MODE_OTHER",
            2: "MODE_OFF",
            3: "MODE_CONSTANT",
            4: "MODE_FLASHING",
            5: "MODE_COUNTING",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "MODE_UNKNOWN": 0,
            "MODE_OTHER": 1,
            "MODE_OFF": 2,
            "MODE_CONSTANT": 3,
            "MODE_FLASHING": 4,
            "MODE_COUNTING": 5,
        }


class TrafficSignMainSignClassificationDirectionScope(betterproto2.Enum):
    """
    Definition of the direction of the traffic sign's scope.
    Signs marked with additional arrows. (E.g. No parking sign (StVO
    286) to the left.)
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_TRAFFICSIGN_PROTO_DESCRIPTOR.enum_types_by_name[
            "TrafficSign.MainSign.Classification.DirectionScope"
        ]

    UNKNOWN = 0
    """
    Direction of the sign's scope is unknown (must not be used in
    ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) direction of the sign's scope.
    """

    NO_DIRECTION = 2
    """
    Direction of the sign's scope is not specified.
    """

    LEFT = 3
    """
    Direction of the sign's scope for its viewer is left.
    """

    RIGHT = 4
    """
    Direction of the sign's scope for its viewer is right.
    """

    LEFT_RIGHT = 5
    """
    Direction of the sign's scope for its viewer is to both
    sides.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "DIRECTION_SCOPE_UNKNOWN",
            1: "DIRECTION_SCOPE_OTHER",
            2: "DIRECTION_SCOPE_NO_DIRECTION",
            3: "DIRECTION_SCOPE_LEFT",
            4: "DIRECTION_SCOPE_RIGHT",
            5: "DIRECTION_SCOPE_LEFT_RIGHT",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "DIRECTION_SCOPE_UNKNOWN": 0,
            "DIRECTION_SCOPE_OTHER": 1,
            "DIRECTION_SCOPE_NO_DIRECTION": 2,
            "DIRECTION_SCOPE_LEFT": 3,
            "DIRECTION_SCOPE_RIGHT": 4,
            "DIRECTION_SCOPE_LEFT_RIGHT": 5,
        }


class TrafficSignMainSignClassificationType(betterproto2.Enum):
    """
    Definition of traffic sign types.
    Numbers are given according to German StVO.

    For an overview of the German StVO see:
    \\arg
    https://www.bast.de/DE/Verkehrstechnik/Fachthemen/v1-verkehrszeichen/vz-download.html
    (Catalog of the Federal Road Research Institute - BASt)
    \\arg
    https://www.dvr.de/publikationen/downloads/verkehrszeichen.html
    (Images) \\arg
    https://www.gesetze-im-internet.de/stvo_2013/anlage_1.html
    (Allgemeine und Besondere Gefahrenzeichen) \\arg
    https://www.gesetze-im-internet.de/stvo_2013/anlage_2.html
    (Vorschriftzeichen) \\arg
    https://www.gesetze-im-internet.de/stvo_2013/anlage_3.html
    (Richtzeichen) \\arg
    https://www.gesetze-im-internet.de/stvo_2013/anlage_4.html
    (Verkehrseinrichtungen) \\arg https://traffic-rules.com/

    \\attention Deprecated: A revision is planned for version 4.0.0 to
    replace the type enum with a more semantically defined enumeration,
    with the exact sign specification being relegated to the newly
    introduced 4-tupel traffic sign catalog specification as used in
    <a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE</a>.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_TRAFFICSIGN_PROTO_DESCRIPTOR.enum_types_by_name[
            "TrafficSign.MainSign.Classification.Type"
        ]

    UNKNOWN = 0
    """
    Type of traffic sign is unknown (must not be used in ground
    truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) type of traffic sign.
    """

    DANGER_SPOT = 2
    """
    Warning: Danger sign.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 101.png
    </td>
    <td>
    StVO 101
    </td>
    </table>
    """

    ZEBRA_CROSSING = 87
    """
    Warning: Zebra crossing.
    <table border="0">
    <tr>
    <td>
    \\image html 101-11.png
    </td>
    <td>
    StVO 101-11
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c false.
    </td>
    </tr>
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 101-11.png
    </td>
    <td>
    StVO 101-21
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c true.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 350-10.png
    </td>
    <td>
    StVO 350-10
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c false.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 350-20.png
    </td>
    <td>
    StVO 350-20
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c true.
    </td>
    </tr>
    </table>

    As symbolic road marking \\c
    RoadMarking::Classification::TYPE_SYMBOLIC_TRAFFIC_SIGN.

    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 293.png
    </td>
    <td>
    StVO 293
    </td>
    </table>
    """

    FLIGHT = 110
    """
    Warning: Low-flying aircraft or sudden aircraft noise.
    <table border="0">
    <tr>
    <td>
    \\image html 101-10.png
    </td>
    <td>
    StVO 101-10
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c false.
    </td>
    </tr>
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 101-10.png
    </td>
    <td>
    StVO 101-20
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c true.
    </td>
    </tr>
    </table>
    """

    CATTLE = 200
    """
    Warning: Cattles crossing.
    <table border="0">
    <tr>
    <td>
    \\image html 101-12.png
    </td>
    </td>
    <td>
    StVO 101-12
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c false.
    </td>
    </tr>
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 101-12.png
    </td>
    <td>
    StVO 101-22
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c true.
    </td>
    </tr>
    </table>
    """

    HORSE_RIDERS = 197
    """
    Warning: Horse riders.
    <table border="0">
    <tr>
    <td>
    \\image html 101-13.png
    </td>
    <td>
    StVO 101-13
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c false.
    </td>
    </tr>
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 101-13.png
    </td>
    <td>
    StVO 101-23
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c true.
    </td>
    </tr>
    </table>
    """

    AMPHIBIANS = 188
    """
    Warning: Amphibian migration.
    <table border="0">
    <tr>
    <td>
    \\image html 101-14.png
    </td>
    <td>
    StVO 101-14
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c false.
    </td>
    </tr>
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 101-14.png
    </td>
    <td>
    StVO 101-24
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c true.
    </td>
    </tr>
    </table>
    """

    FALLING_ROCKS = 96
    """
    Warning: Falling rocks.
    <table border="0">
    <tr>
    <td>
    \\image html 101-15.png
    </td>
    <td>
    StVO 101-15
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c false.
    </td>
    </tr>
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 101-15.png
    </td>
    <td>
    StVO 101-25
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c true.
    </td>
    </tr>
    </table>
    """

    SNOW_OR_ICE = 94
    """
    Warning: Risk of snow or ice.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 101-51.png
    </td>
    <td>
    StVO 101-51
    </td>
    </tr>
    </table>
    """

    LOOSE_GRAVEL = 97
    """
    Warning: Crushed stones.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 101-52.png
    </td>
    <td>
    StVO 101-52
    </td>
    </tr>
    </table>
    """

    WATERSIDE = 102
    """
    Warning: Waterside.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 101-53.png
    </td>
    <td>
    StVO 101-53
    </td>
    </tr>
    </table>
    """

    CLEARANCE = 210
    """
    Warning: Not enough clearance.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 101-54.png
    </td>
    <td>
    StVO 101-54
    </td>
    </tr>
    </table>
    """

    MOVABLE_BRIDGE = 101
    """
    Warning: Movable bridge.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 101-55.png
    </td>
    <td>
    StVO 101-55
    </td>
    </tr>
    </table>
    """

    RIGHT_BEFORE_LEFT_NEXT_INTERSECTION = 3
    """
    Warning: "Right before left" rule at the next intersection.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 102.png
    </td>
    <td>
    StVO 102
    </td>
    </tr>
    </table>
    """

    TURN_LEFT = 4
    """
    Warning: Sign for a left turn.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 103-10.png
    </td>
    <td>
    StVO 103-10
    </td>
    </tr>
    </table>

    Right: \\c #TYPE_TURN_RIGHT
    """

    TURN_RIGHT = 5
    """
    Warning: Sign for a right turn.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 103-20.png
    </td>
    <td>
    StVO 103-20
    </td>
    </tr>
    </table>

    Left: \\c #TYPE_TURN_LEFT
    """

    DOUBLE_TURN_LEFT = 6
    """
    Warning: Sign for a double turn (first left turn).
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 105-10.png
    </td>
    <td>
    StVO 105-10
    </td>
    </tr>
    </table>

    Right: \\c #TYPE_DOUBLE_TURN_RIGHT
    """

    DOUBLE_TURN_RIGHT = 7
    """
    Warning: Sign for a double turn (first right turn).
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 105-20.png
    </td>
    <td>
    StVO 105-20
    </td>
    </tr>
    </table>

    Left: \\c #TYPE_DOUBLE_TURN_LEFT
    """

    HILL_DOWNWARDS = 8
    """
    Warning: Steep hill downwards.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 108-4.png
    </td>
    <td>
    StVO 108
    </td>
    <td>
    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit to indicate slope.
    </td>
    </tr>
    </table>
    """

    HILL_UPWARDS = 9
    """
    Warning: Steep hill upwards.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 110-4.png
    </td>
    <td>
    StVO 110
    </td>
    <td>
    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit to indicate slope
    </td>
    </tr>
    </table>
    """

    UNEVEN_ROAD = 93
    """
    Warning: Uneven road.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 112.png
    </td>
    <td>
    StVO 112
    </td>
    </tr>
    </table>
    """

    ROAD_SLIPPERY_WET_OR_DIRTY = 95
    """
    Warning: Road slippery when wet or dirty.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 114.png
    </td>
    <td>
    StVO 114
    </td>
    </tr>
    </table>
    """

    SIDE_WINDS = 98
    """
    Warning: Side winds.
    <table border="0">
    <tr>
    <td>
    \\image html 117-10.png
    </td>
    <td>
    StVO 117-10
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c false.
    </td>
    </tr>
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 117-10.png
    </td>
    <td>
    StVO 117-20
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c true.
    </td>
    </tr>
    </table>
    """

    ROAD_NARROWING = 10
    """
    Warning: Road narrowing.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 120.png
    </td>
    <td>
    StVO 120
    </td>
    </tr>
    </table>
    """

    ROAD_NARROWING_RIGHT = 12
    """
    Warning: Road narrowing on the right.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 121-10.png
    </td>
    <td>
    StVO 121-10
    </td>
    </tr>
    </table>
    """

    ROAD_NARROWING_LEFT = 11
    """
    Warning: Road narrowing on the left.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 121-20.png
    </td>
    <td>
    StVO 121-20
    </td>
    </tr>
    </table>
    """

    ROAD_WORKS = 13
    """
    Warning: Road works sign.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 123.png
    </td>
    <td>
    StVO 123
    </td>
    </tr>
    </table>
    """

    TRAFFIC_QUEUES = 100
    """
    Warning: Traffic queues likely.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 124.png
    </td>
    <td>
    StVO 124
    </td>
    </tr>
    </table>
    """

    TWO_WAY_TRAFFIC = 14
    """
    Warning: Two-way-traffic (after one-way lane).
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 125.png
    </td>
    <td>
    StVO 125
    </td>
    </tr>
    </table>
    """

    ATTENTION_TRAFFIC_LIGHT = 15
    """
    Warning: Traffic light ahead sign.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 131.png
    </td>
    <td>
    StVO 131
    </td>
    </tr>
    </table>
    """

    PEDESTRIANS = 103
    """
    Warning: Pedestrians.
    <table border="0">
    <tr>
    <td>
    \\image html 133-10.png
    </td>
    <td>
    StVO 133-10
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c false.
    </td>
    </tr>
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 133-10.png
    </td>
    <td>
    StVO 133-20
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c true.
    </td>
    </tr>
    </table>
    """

    CHILDREN_CROSSING = 106
    """
    Warning: Children crossing.
    <table border="0">
    <tr>
    <td>
    \\image html 136-10.png
    </td>
    <td>
    StVO 136-10
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c false.
    </td>
    </tr>
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 136-10.png
    </td>
    <td>
    StVO 136-20
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c true.
    </td>
    </tr>
    </table>
    """

    CYCLE_ROUTE = 107
    """
    Warning: Pedal cycle route crossing or joining road sign.
    <table border="0">
    <tr>
    <td>
    \\image html 138-10.png
    </td>
    <td>
    StVO 138-10
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c false.
    </td>
    </tr>
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 138-10.png
    </td>
    <td>
    StVO 138-20
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c true.
    </td>
    </tr>
    </table>
    """

    DEER_CROSSING = 109
    """
    Warning: Deer crossing.
    <table border="0">
    <tr>
    <td>
    \\image html 142-10.png
    </td>
    <td>
    StVO 142-10
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c false.
    </td>
    </tr>
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 142-10.png
    </td>
    <td>
    StVO 142-20
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c true.
    </td>
    </tr>
    </table>
    """

    UNGATED_LEVEL_CROSSING = 144
    """
    Warning: Level crossing without barrier or gate.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 151.png
    </td>
    <td>
    StVO 151
    </td>
    </tr>
    </table>
    """

    LEVEL_CROSSING_MARKER = 112
    """
    Level crossing marker.
    (StVO 156 - Countdown marker indicating that level crossing
    are 2 main signs \\c #TYPE_UNGATED_LEVEL_CROSSING and \\c
    #TYPE_LEVEL_CROSSING_MARKER.)
    <table border="0">
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 157-20.png
    </td>
    <td style="transform:scaleX(-1)">
    \\image html 159-20.png
    </td>
    <td style="transform:scaleX(-1)">
    \\image html 161-20.png
    </td>
    <td>
    \\image html 156-10.png
    </td>
    <td>
    \\image html 156-11.png
    </td>
    </tr>
    <tr style="font-weight:bold">
    <td>
    StVO 157-10
    </td>
    <td>
    StVO 159-10
    </td>
    <td>
    StVO 161-10
    </td>
    <td>
    (StVO 156-10)
    </td>
    <td>
    (StVO 156-11)
    </td>
    </tr>
    <tr>
    <td>
    \\image html 157-20.png
    </td>
    <td>
    \\image html 159-20.png
    </td>
    <td>
    \\image html 161-20.png
    </td>
    <td style="transform:scaleX(-1)">
    \\image html 156-10.png
    </td>
    <td>
    \\image html 156-21.png
    </td>
    </tr>
    <tr style="font-weight:bold">
    <td>
    StVO 157-20
    </td>
    <td>
    StVO 159-20
    </td>
    <td>
    StVO 162-20
    </td>
    <td>
    (StVO 156-20)
    </td>
    <td>
    (StVO 156-21)
    </td>
    </tr>
    </table>

    Variants (here X is any of 157, 159 or 162):
    <table border="0">
    <tr>
    <td>
    StVO X-10
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c false.
    </td>
    </tr>
    <tr>
    <td>
    StVO X-11
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c false.
    Additionally, use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit to indicate the remaining
    distance or the number of displayed red stripes. In
    the second case, set \\c TrafficSignValue::value_unit
    to \\c TrafficSignValue::UNIT_NO_UNIT.
    </td>
    </tr>
    <tr>
    <td>
    StVO X-20
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c true.
    </td>
    </tr>
    <tr>
    <td>
    StVO X-21
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c true.
    Additionally, use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit to indicate the remaining
    distance or the number of displayed red stripes. In
    the second case, set \\c TrafficSignValue::value_unit
    to \\c TrafficSignValue::UNIT_NO_UNIT.
    </td>
    </tr>
    </table>
    """

    RAILWAY_TRAFFIC_PRIORITY = 135
    """
    St.Andrew's cross, railway traffic has priority.
    <table border="0">
    <tr>
    <td>
    \\image html 201-50.png
    <td>
    StVO 201-50
    <td>
    </tr>
    <tr>
    <td>
    \\image html 201-52.png
    </td>
    <td>
    StVO 201-52
    </td>
    <td>
    with lightning bolt indicating voltage-carrying overhead
    line.
    </td>
    </tr>
    </table>
    """

    GIVE_WAY = 16
    """
    Give way.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 205.png
    </td>
    <td>
    StVO 205
    </td>
    </tr>
    </table>

    As symbolic road marking
    \\c RoadMarking::Classification::TYPE_SYMBOLIC_TRAFFIC_SIGN.

    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 341.png
    -->
    </td>
    <td>
    StVO 341
    </td>
    </tr>
    </table>
    """

    STOP = 17
    """
    Stop sign.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 206.png
    </td>
    <td>
    StVO 206
    </td>
    </tr>
    </table>

    As symbolic road marking
    \\c RoadMarking::Classification::TYPE_SYMBOLIC_TRAFFIC_SIGN.

    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 294.png
    </td>
    <td>
    StVO 294
    </td>
    </table>
    """

    PRIORITY_TO_OPPOSITE_DIRECTION = 18
    """
    Priority must be given to vehicles from the opposite
    direction.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 208.png
    </td>
    <td>
    StVO 208
    </td>
    </tr>
    </table>

    See also: \\c
    #TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION.
    """

    PRIORITY_TO_OPPOSITE_DIRECTION_UPSIDE_DOWN = 19
    """
    Priority must be given to vehicles from the opposite
    direction.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td style="transform:rotate(180deg)">
    \\image html 208.png
    </td>
    <td>
    StVO 208, upside down
    </td>
    </tr>
    </table>

    See also: \\c #TYPE_PRIORITY_TO_OPPOSITE_DIRECTION.
    """

    PRESCRIBED_LEFT_TURN = 20
    """
    Prescribed left turn.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 209-10.png
    </td>
    <td>
    StVO 209-10
    </td>
    </tr>
    </table>

    Right: \\c #TYPE_PRESCRIBED_RIGHT_TURN

    As symbolic road marking \\c
    RoadMarking::Classification::TYPE_SYMBOLIC_TRAFFIC_SIGN
    (StVO 297).
    """

    PRESCRIBED_RIGHT_TURN = 21
    """
    Prescribed right turn.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 209-10.png
    </td>
    <td>
    StVO 209-20
    </td>
    </tr>
    </table>

    Left: \\c #TYPE_PRESCRIBED_LEFT_TURN

    As symbolic road marking \\c
    RoadMarking::Classification::TYPE_SYMBOLIC_TRAFFIC_SIGN
    (StVO 297).
    """

    PRESCRIBED_STRAIGHT = 22
    """
    Prescribed driving straight.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 209-30.png
    </td>
    <td>
    StVO 209-30
    </td>
    </tr>
    </table>

    As symbolic road marking \\c
    RoadMarking::Classification::TYPE_SYMBOLIC_TRAFFIC_SIGN
    (StVO 297).
    """

    PRESCRIBED_RIGHT_WAY = 24
    """
    Prescribed right way.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 211.png
    </td>
    <td>
    StVO 211
    </td>
    </tr>
    </table>

    Left: \\c #TYPE_PRESCRIBED_LEFT_WAY
    """

    PRESCRIBED_LEFT_WAY = 23
    """
    Prescribed left way.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 211-10.png
    </td>
    <td>
    StVO 211-10
    </td>
    </tr>
    </table>

    Right: \\c #TYPE_PRESCRIBED_RIGHT_WAY
    """

    PRESCRIBED_RIGHT_TURN_AND_STRAIGHT = 26
    """
    Prescribed right turn and driving straight.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 214.png
    </td>
    <td>
    StVO 214
    </td>
    </tr>
    </table>

    Left: \\c #TYPE_PRESCRIBED_LEFT_TURN_AND_STRAIGHT

    As symbolic road marking \\c
    RoadMarking::Classification::TYPE_SYMBOLIC_TRAFFIC_SIGN
    (StVO 297).
    """

    PRESCRIBED_LEFT_TURN_AND_STRAIGHT = 25
    """
    Prescribed left turn and driving straight .
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 214-10.png
    </td>
    <td>
    StVO 214-10
    </td>
    </tr>
    </table>

    Right: \\c #TYPE_PRESCRIBED_RIGHT_TURN_AND_STRAIGHT

    As symbolic road marking \\c
    RoadMarking::Classification::TYPE_SYMBOLIC_TRAFFIC_SIGN
    (StVO 297).
    """

    PRESCRIBED_LEFT_TURN_AND_RIGHT_TURN = 27
    """
    Prescribed left and right turn.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 214-30.png
    </td>
    <td>
    StVO 214-30
    </td>
    </tr>
    </table>

    As symbolic road marking \\c
    RoadMarking::Classification::TYPE_SYMBOLIC_TRAFFIC_SIGN
    (StVO 297).
    """

    PRESCRIBED_LEFT_TURN_RIGHT_TURN_AND_STRAIGHT = 28
    """
    Prescribed left turn, right turn and driving straight
    (required for logical signs as road marking).

    As symbolic road marking \\c
    RoadMarking::Classification::TYPE_SYMBOLIC_TRAFFIC_SIGN
    (StVO 297).
    """

    ROUNDABOUT = 29
    """
    Roundabout.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 215.png
    </td>
    <td>
    StVO 215
    </td>
    </tr>
    </table>

    \\note The direction of driving (clockwise, counterclockwise)
    is country-specific.
    """

    ONEWAY_LEFT = 30
    """
    One-way road to the left.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 220-10.png
    </td>
    <td>
    StVO 220-10
    </td>
    </tr>
    </table>

    Right: \\c #TYPE_ONEWAY_RIGHT
    """

    ONEWAY_RIGHT = 31
    """
    One-way road to the right.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 220-20.png
    </td>
    <td>
    StVO 220-20
    </td>
    </tr>
    </table>

    Left: \\c #TYPE_ONEWAY_LEFT
    """

    PASS_LEFT = 32
    """
    Drive past on the left side.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 222-10.png
    </td>
    <td>
    StVO 222-10
    </td>
    </tr>
    </table>

    Right: \\c #TYPE_PASS_RIGHT
    """

    PASS_RIGHT = 33
    """
    Drive past on the right side.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 222.png
    </td>
    <td>
    StVO 222
    </td>
    </tr>
    </table>

    Left: \\c #TYPE_PASS_LEFT
    """

    SIDE_LANE_OPEN_FOR_TRAFFIC = 128
    """
    Drive along side lanes.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 223.1-50.png
    </td>
    <td>
    StVO 223.1-50
    </td>
    <td>
    Drive along side lanes, 2 lanes and side lane.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 223.1-51.png
    </td>
    <td>
    StVO 223.1-51
    </td>
    <td>
    Drive along side lanes, 3 lanes and side lane.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 223.1-52.png
    </td>
    <td>
    StVO 223.1-52
    </td>
    <td>
    Drive along side lanes, 4 lanes and side lane.
    </td>
    </tr>
    </table>
    """

    SIDE_LANE_CLOSED_FOR_TRAFFIC = 129
    """
    Do not drive on the side lane.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 223.2-50.png
    </td>
    <td>
    StVO 223.2-50
    </td>
    <td>
    Do not drive on the side lane, 2 lanes and side lane.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 223.2-51.png
    </td>
    <td>
    StVO 223.2-51
    </td>
    <td>
    Do not drive on the side lane, 3 lanes and side lane.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 223.2-52.png
    </td>
    <td>
    StVO 223.2-52
    </td>
    <td>
    Do not drive on the side lane, 4 lanes and side lane.
    </td>
    </tr>
    </table>
    """

    SIDE_LANE_CLOSING_FOR_TRAFFIC = 130
    """
    Side lane closing.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 223.3-50.png
    </td>
    <td>
    StVO 223.3-50
    </td>
    <td>
    Side lane closing, 2 lanes and side lane.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 223.3-51.png
    </td>
    <td>
    StVO 223.3-51
    </td>
    <td>
    Side lane closing, 3 lanes and side lane.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 223.3-52.png
    </td>
    <td>
    StVO 223.3-52
    </td>
    <td>
    Side lane closing, 4 lanes and side lane.
    </td>
    </tr>
    </table>
    """

    BUS_STOP = 137
    """
    Bus stop or tramway stop.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 224.png
    </td>
    <td>
    StVO 224
    </td>
    </tr>
    </table>
    """

    TAXI_STAND = 138
    """
    Taxi rank.
    <table border="0">
    <tr>
    <td colspan="2">
    \\image html 229.png "StVO 229"
    </td>
    <td>
    Set \\c Classification::direction_scope to \\c
    #DIRECTION_SCOPE_NO_DIRECTION
    </td>
    </tr>
    <tr>
    <td>
    \\image html 229-10.png "StVO 229-10"
    </td>
    <td>
    \\image html 229-21.png "StVO 229-21"
    </td>
    <td>
    Set \\c Classification::direction_scope to \\c
    #DIRECTION_SCOPE_LEFT
    </td>
    </tr>
    <tr>
    <td>
    \\image html 229-11.png "StVO 229-11"
    </td>
    <td>
    \\image html 229-20.png "StVO 229-20"
    </td>
    <td>
    Set \\c Classification::direction_scope to \\c
    #DIRECTION_SCOPE_RIGHT
    </td>
    </tr>
    <tr>
    <td>
    \\image html 229-30.png "StVO 229-30"
    </td>
    <td>
    \\image html 229-31.png "StVO 229-31"
    </td>
    <td>
    Set \\c Classification::direction_scope to \\c
    #DIRECTION_SCOPE_LEFT_RIGHT
    </td>
    </tr>
    </table>
    """

    BICYCLES_ONLY = 145
    """
    Route for bicycles only.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 237.png
    </td>
    <td>
    StVO 237
    </td>
    </tr>
    </table>
    """

    HORSE_RIDERS_ONLY = 146
    """
    Route for horse riders only.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 238.png
    </td>
    <td>
    StVO 238
    </td>
    </tr>
    </table>
    """

    PEDESTRIANS_ONLY = 147
    """
    Route for pedestrians only.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 239.png
    </td>
    <td>
    StVO 239
    </td>
    </tr>
    </table>
    """

    BICYCLES_PEDESTRIANS_SHARED_ONLY = 148
    """
    Unsegregated route for use by bicycles and pedestrians only.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 240.png
    </td>
    <td>
    StVO 240
    </td>
    </tr>
    </table>
    """

    BICYCLES_PEDESTRIANS_SEPARATED_LEFT_ONLY = 149
    """
    Segregated route for use by bicycles and pedestrians only,
    bicycles on the left.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 241-30.png
    </td>
    <td>
    StVO 241-30
    </td>
    </tr>
    </table>

    Right: \\c #TYPE_BICYCLES_PEDESTRIANS_SEPARATED_RIGHT_ONLY
    """

    BICYCLES_PEDESTRIANS_SEPARATED_RIGHT_ONLY = 150
    """
    Segregated route for use by bicycles and pedestrians only,
    bicycles on the right.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 241-31.png
    </td>
    <td>
    StVO 241-31
    </td>
    </tr>
    </table>

    Left: \\c #TYPE_BICYCLES_PEDESTRIANS_SEPARATED_LEFT_ONLY
    """

    PEDESTRIAN_ZONE_BEGIN = 151
    """
    Beginning of the pedestrian zone.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 242.1.png
    </td>
    <td>
    StVO 242.1
    </td>
    </tr>
    </table>
    """

    PEDESTRIAN_ZONE_END = 152
    """
    End of the pedestrian zone.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 242.2.png
    </td>
    <td>
    StVO 242.2
    </td>
    </tr>
    </table>
    """

    BICYCLE_ROAD_BEGIN = 153
    """
    Beginning of bicycle road.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 244.1.png
    </td>
    <td>
    StVO 244.1
    </td>
    </tr>
    </table>
    """

    BICYCLE_ROAD_END = 154
    """
    End of bicycle road.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 244.2.png
    </td>
    <td>
    StVO 244.2
    </td>
    </tr>
    </table>
    """

    BUS_LANE = 34
    """
    Lane for buses.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 245.png
    </td>
    <td>
    StVO 245
    </td>
    </tr>
    </table>
    """

    BUS_LANE_BEGIN = 35
    """
    Bus only lane begin.
    \\n
    End: \\c #TYPE_BUS_LANE_END
    """

    BUS_LANE_END = 36
    """
    Bus only lane end.
    \\n
    Begin: \\c #TYPE_BUS_LANE_BEGIN
    """

    ALL_PROHIBITED = 37
    """
    Entry prohibited for all types of vehicles.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 250.png
    </td>
    <td>
    StVO 250
    </td>
    </tr>
    </table>
    """

    MOTORIZED_MULTITRACK_PROHIBITED = 38
    """
    Entry prohibited for cars, trucks, and other motorized
    multi-track vehicles.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 251.png
    </td>
    <td>
    StVO 251
    </td>
    </tr>
    </table>
    """

    TRUCKS_PROHIBITED = 39
    """
    Entry prohibited for trucks.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 253.png
    </td>
    <td>
    StVO 253
    </td>
    </tr>
    </table>

    \\note In the German StVO, trucks are defined as motorized
    vehicles that are heavier than 3.5 t.
    """

    BICYCLES_PROHIBITED = 40
    """
    Entry prohibited for bicycles.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 254.png
    </td>
    <td>
    StVO 254
    </td>
    </tr>
    </table>
    """

    MOTORCYCLES_PROHIBITED = 41
    """
    Entry prohibited for motorcycles.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 255.png
    </td>
    <td>
    StVO 255
    </td>
    </tr>
    </table>
    """

    MOPEDS_PROHIBITED = 155
    """
    Entry prohibited for mopeds.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 257-50.png
    </td>
    <td>
    StVO 257-50
    </td>
    </tr>
    </table>
    """

    HORSE_RIDERS_PROHIBITED = 156
    """
    Entry prohibited for horse riders.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 257-51.png
    </td>
    <td>
    StVO 257-51
    </td>
    </tr>
    </table>
    """

    HORSE_CARRIAGES_PROHIBITED = 157
    """
    Entry prohibited for horse carriages.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 257-52.png
    </td>
    <td>
    StVO 257-52
    </td>
    </tr>
    </table>
    """

    CATTLE_PROHIBITED = 158
    """
    Entry prohibited for cattles.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 257-53.png
    </td>
    <td>
    StVO 257-53
    </td>
    </tr>
    </table>
    """

    BUSES_PROHIBITED = 159
    """
    Entry prohibited for buses.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 257-54.png
    </td>
    <td>
    StVO 257-54
    </td>
    </tr>
    </table>
    """

    CARS_PROHIBITED = 160
    """
    Entry prohibited for passenger cars.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 257-55.png
    </td>
    <td>
    StVO 257-55
    </td>
    </tr>
    </table>
    """

    CARS_TRAILERS_PROHIBITED = 161
    """
    Entry prohibited for passenger cars with trailers.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 257-56.png
    </td>
    <td>
    StVO 257-56
    </td>
    </tr>
    </table>
    """

    TRUCKS_TRAILERS_PROHIBITED = 162
    """
    Entry prohibited for trucks with trailers.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 257-57.png
    </td>
    <td>
    StVO 257-57
    </td>
    </tr>
    </table>
    """

    TRACTORS_PROHIBITED = 163
    """
    Entry prohibited for tractors.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 257-58.png
    </td>
    <td>
    StVO 257-58
    </td>
    </tr>
    </table>

    \\note In the German StVO, tractors are defined as motorized
    vehicles that are not allowed to, or cannot, drive faster
    than 25 km/h.
    """

    PEDESTRIANS_PROHIBITED = 42
    """
    Entry prohibited for pedestrians.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 259.png
    </td>
    <td>
    StVO 259
    </td>
    </tr>
    </table>
    """

    MOTOR_VEHICLES_PROHIBITED = 43
    """
    Entry prohibited for all motor vehicles.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 260.png
    </td>
    <td>
    StVO 260
    </td>
    </tr>
    </table>
    """

    HAZARDOUS_GOODS_VEHICLES_PROHIBITED = 164
    """
    Entry prohibited for marked vehicles transporting hazardous
    goods.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 261.png
    </td>
    <td>
    StVO 261
    </td>
    </tr>
    </table>
    """

    OVER_WEIGHT_VEHICLES_PROHIBITED = 165
    """
    Weight limit (entry prohibited for vehicles over maximum
    gross weight shown).
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 262.png
    </td>
    <td>
    StVO 262
    </td>
    </tr>
    </table>

    Use
    \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit to set the limit.
    """

    VEHICLES_AXLE_OVER_WEIGHT_PROHIBITED = 166
    """
    Axle weight limit (entry prohibited for vehicles over weight
    on axle shown).
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 263.png
    </td>
    <td>
    StVO 263
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit to set the limit.
    """

    VEHICLES_EXCESS_WIDTH_PROHIBITED = 167
    """
    Horizontal clearance (entry prohibited for vehicles wider
    than the width shown).
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html "264-2,3.png"
    </td>
    <td>
    StVO 264
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit to set the limit.
    """

    VEHICLES_EXCESS_HEIGHT_PROHIBITED = 168
    """
    Vertical clearance (entry prohibited for vehicles higher than
    the height shown).
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 265.png
    </td>
    <td>
    StVO 265
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit to set the limit.
    """

    VEHICLES_EXCESS_LENGTH_PROHIBITED = 169
    """
    Length restriction (entry prohibited for vehicles or
    combinations of vehicles longer than the length shown).
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 266.png
    </td>
    <td>
    StVO 266
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit to set the limit.
    """

    DO_NOT_ENTER = 44
    """
    Entry not allowed. One-way road.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 267.png
    </td>
    <td>
    StVO 267
    </td>
    </tr>
    </table>
    """

    SNOW_CHAINS_REQUIRED = 170
    """
    Snow chains required.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 268.png
    </td>
    <td>
    StVO 268
    </td>
    </tr>
    </table>
    """

    WATER_POLLUTANT_VEHICLES_PROHIBITED = 171
    """
    Entry prohibited for vehicles carrying water pollutants.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 269.png
    </td>
    <td>
    StVO 269
    </td>
    </tr>
    </table>
    """

    ENVIRONMENTAL_ZONE_BEGIN = 45
    """
    Start of area without traffic to reduce harmful air
    pollution.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 270.1.png
    </td>
    <td>
    StVO 270.1
    </td>
    </tr>
    </table>

    End: \\c #TYPE_ENVIRONMENTAL_ZONE_END
    """

    ENVIRONMENTAL_ZONE_END = 46
    """
    End of area without traffic to reduce harmful air pollution.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 270.2.png
    </td>
    <td>
    StVO 270.2
    </td>
    </tr>
    </table>

    Begin: \\c #TYPE_ENVIRONMENTAL_ZONE_BEGIN
    """

    NO_U_TURN_LEFT = 47
    """
    No U turn left.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 272.png
    </td>
    <td>
    StVO 272
    </td>
    </tr>
    </table>

    Right: \\c #TYPE_NO_U_TURN_RIGHT
    """

    NO_U_TURN_RIGHT = 48
    """
    No U turn right.
    <!--
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html abc.png
    </td>
    <td>
    </td>
    </tr>
    </table>
    -->

    \\note This type is to be applied in left-driving countries.

    Left: \\c #TYPE_NO_U_TURN_LEFT
    """

    PRESCRIBED_U_TURN_LEFT = 49
    """
    Prescribed U turn left.
    \\n
    Right: \\c #TYPE_PRESCRIBED_U_TURN_RIGHT
    """

    PRESCRIBED_U_TURN_RIGHT = 50
    """
    Prescribed U turn right.
    \\n
    \\note This type is to be applied in left-driving countries.

    Left: \\c #TYPE_PRESCRIBED_U_TURN_LEFT
    """

    MINIMUM_DISTANCE_FOR_TRUCKS = 51
    """
    Minimum safety distance for trucks.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 273.png
    </td>
    <td>
    StVO 273
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit to set the limit.
    """

    SPEED_LIMIT_BEGIN = 52
    """
    Start of speed limit.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 274-30.png
    </td>
    <td>
    StVO 274
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit to set the limit.

    End: \\c #TYPE_SPEED_LIMIT_END
    """

    SPEED_LIMIT_ZONE_BEGIN = 53
    """
    Start of zone with speed limit.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 274.1.png
    </td>
    <td>
    StVO 274.1
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit to set the limit.

    End: \\c #TYPE_SPEED_LIMIT_ZONE_END
    """

    SPEED_LIMIT_ZONE_END = 54
    """
    End of zone with speed limit.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 274.2.png
    </td>
    <td>
    StVO 274.2
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit to set the limit.

    Begin: \\c #TYPE_SPEED_LIMIT_ZONE_BEGIN
    """

    MINIMUM_SPEED_BEGIN = 55
    """
    Start of mandatory minimum speed.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 275.png
    </td>
    <td>
    StVO 275
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit to set the speed.

    End: \\c #TYPE_MINIMUM_SPEED_END
    """

    OVERTAKING_BAN_BEGIN = 56
    """
    Start of overtaking ban.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 276.png
    </td>
    <td>
    StVO 276
    </td>
    </tr>
    </table>

    End: \\c #TYPE_OVERTAKING_BAN_END
    """

    OVERTAKING_BAN_FOR_TRUCKS_BEGIN = 57
    """
    Start of overtaking ban for trucks.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 277.png
    </td>
    <td>
    StVO 277
    </td>
    </tr>
    </table>

    End: \\c #TYPE_OVERTAKING_BAN_FOR_TRUCKS_END
    """

    SPEED_LIMIT_END = 58
    """
    End of speed limit.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 278-60.png
    </td>
    <td>
    StVO 278
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit to refer to the limit.

    Begin: \\c #TYPE_SPEED_LIMIT_BEGIN
    """

    MINIMUM_SPEED_END = 59
    """
    End of mandatory minimum speed.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 279.png
    </td>
    <td>
    StVO 279
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit to refer to the limit.

    Begin: \\c #TYPE_MINIMUM_SPEED_BEGIN
    """

    OVERTAKING_BAN_END = 60
    """
    End of overtaking ban.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 280.png
    </td>
    <td>
    StVO 280
    </td>
    </tr>
    </table>

    Begin: \\c #TYPE_OVERTAKING_BAN_BEGIN
    """

    OVERTAKING_BAN_FOR_TRUCKS_END = 61
    """
    End of overtaking ban for trucks.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 281.png
    </td>
    <td>
    StVO 281
    </td>
    </tr>
    </table>

    Begin: \\c #TYPE_OVERTAKING_BAN_FOR_TRUCKS_BEGIN
    """

    ALL_RESTRICTIONS_END = 62
    """
    End of all speed and overtaking restrictions.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 282.png
    </td>
    <td>
    StVO 282
    </td>
    </tr>
    </table>
    """

    NO_STOPPING = 63
    """
    No stopping sign.
    <table border="0">
    <tr>
    <td colspan="2">
    \\image html 283.png "StVO 283"
    </td>
    <td>
    Set \\c Classification::direction_scope to \\c
    #DIRECTION_SCOPE_NO_DIRECTION
    </td>
    </tr>
    <tr>
    <td>
    \\image html 283-10.png "StVO 283-10"
    </td>
    <td>
    \\image html 283-11.png "StVO 283-11"
    </td>
    <td>
    Set \\c Classification::direction_scope to \\c
    #DIRECTION_SCOPE_LEFT
    </td>
    </tr>
    <tr>
    <td>
    \\image html 283-20.png "StVO 283-20"
    </td>
    <td>
    \\image html 283-21.png "StVO 283-21"
    </td>
    <td>
    Set \\c Classification::direction_scope to \\c
    #DIRECTION_SCOPE_RIGHT
    </td>
    </tr>
    <tr>
    <td>
    \\image html 283-30.png "StVO 283-30"
    </td>
    <td>
    \\image html 283-31.png "StVO 283-31"
    </td>
    <td>
    Set \\c Classification::direction_scope to \\c
    #DIRECTION_SCOPE_LEFT_RIGHT
    </td>
    </tr>
    </table>
    """

    NO_PARKING = 64
    """
    No parking sign.
    <table border="0">
    <tr>
    <td colspan="2">
    \\image html 286.png "StVO 286"
    </td>
    <td>
    Set \\c Classification::direction_scope to \\c
    #DIRECTION_SCOPE_NO_DIRECTION
    </td>
    </tr>
    <tr>
    <td>
    \\image html 286-10.png "StVO 286-10"
    </td>
    <td>
    \\image html 286-11.png "StVO 286-11"
    </td>
    <td>
    Set \\c Classification::direction_scope to \\c
    #DIRECTION_SCOPE_LEFT
    </td>
    </tr>
    <tr>
    <td>
    \\image html 286-20.png "StVO 286-20"
    </td>
    <td>
    \\image html 286-21.png "StVO 286-21"
    </td>
    <td>
    Set \\c Classification::direction_scope to \\c
    #DIRECTION_SCOPE_RIGHT
    </td>
    </tr>
    <tr>
    <td>
    \\image html 286-30.png "StVO 286-30"
    </td>
    <td>
    \\image html 286-31.png "StVO 286-31"
    </td>
    <td>
    Set \\c Classification::direction_scope to \\c
    #DIRECTION_SCOPE_LEFT_RIGHT
    </td>
    </tr>
    </table>

    As symbolic road marking \\c
    RoadMarking::Classification::TYPE_SYMBOLIC_TRAFFIC_SIGN.

    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 299.png
    </td>
    <td>
    StVO 299
    </td>
    </table>
    """

    NO_PARKING_ZONE_BEGIN = 65
    """
    Begin of no parking zone.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 290.1.png
    </td>
    <td>
    StVO 290.1
    </td>
    </tr>
    </table>

    End: \\c #TYPE_NO_PARKING_ZONE_END
    """

    NO_PARKING_ZONE_END = 66
    """
    End of no parking zone.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 290.2.png
    </td>
    <td>
    StVO 290.2
    </td>
    </tr>
    </table>

    Begin: \\c #TYPE_NO_PARKING_ZONE_BEGIN
    """

    RIGHT_OF_WAY_NEXT_INTERSECTION = 67
    """
    Right of way at the next intersection.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 301.png
    </td>
    <td>
    StVO 301
    </td>
    </tr>
    </table>
    """

    RIGHT_OF_WAY_BEGIN = 68
    """
    Begin of priority road with right of way.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 306.png
    </td>
    <td>
    StVO 306
    </td>
    </tr>
    </table>

    End: \\c #TYPE_RIGHT_OF_WAY_END
    """

    RIGHT_OF_WAY_END = 69
    """
    End of priority road with right of way.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 307.png
    </td>
    <td>
    StVO 307
    </td>
    </tr>
    </table>

    Begin: \\c #TYPE_RIGHT_OF_WAY_BEGIN
    """

    PRIORITY_OVER_OPPOSITE_DIRECTION = 70
    """
    Traffic has priority over vehicles from the opposite
    direction.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 308.png
    </td>
    <td>
    StVO 308
    </td>
    </tr>
    </table>

    See also: \\c #TYPE_PRIORITY_TO_OPPOSITE_DIRECTION
    """

    PRIORITY_OVER_OPPOSITE_DIRECTION_UPSIDE_DOWN = 71
    """
    Traffic has priority over vehicles from the opposite
    direction.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td style="transform:rotate(180deg)">
    \\image html 308.png
    </td>
    <td>
    StVO 308, upside down
    </td>
    </tr>
    </table>

    See also: \\c #TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION
    """

    TOWN_BEGIN = 72
    """
    Town entrance.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 310.png
    </td>
    <td>
    StVO 310
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::text to denote the town's name and
    district, e.g. "Wilster, Kreis Steinburg".

    End: \\c #TYPE_TOWN_END
    """

    TOWN_END = 73
    """
    Town exit.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 311.png
    </td>
    <td>
    StVO 311
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::text to denote the town's name and
    district, e.g. "Wilster".

    Begin: \\c #TYPE_TOWN_BEGIN
    """

    CAR_PARKING = 74
    """
    Parking space.
    <table border="0">
    <tr>
    <td>
    \\image html 314.png
    </td>
    <td>
    StVO 314
    </td>
    <td>
    </td>
    <td>
    Set \\c Classification::direction_scope to \\c
    #DIRECTION_SCOPE_NO_DIRECTION.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 314-50.png
    </td>
    <td>
    StVO 314-50
    </td>
    <td>
    Parking house
    </td>
    <td>
    Set \\c Classification::direction_scope to \\c
    #DIRECTION_SCOPE_NO_DIRECTION.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 316.png
    </td>
    <td>
    StVO 316
    </td>
    <td>
    Park and ride
    </td>
    <td>
    Set \\c Classification::direction_scope to \\c
    #DIRECTION_SCOPE_NO_DIRECTION. Set \\c
    TrafficSignValue::text to "P+R".
    </td>
    </tr>
    <tr>
    <td>
    </td>
    <td>
    </td>
    <td>
    Park and move
    </td>
    <td>
    Set \\c Classification::direction_scope to \\c
    #DIRECTION_SCOPE_NO_DIRECTION. Set \\c
    TrafficSignValue::text to "P+M".
    </td>
    </tr>
    <tr>
    <td>
    \\image html 317.png
    </td>
    <td>
    StVO 317
    </td>
    <td>
    Hiker's parking
    </td>
    <td>
    Set \\c Classification::direction_scope to \\c
    #DIRECTION_SCOPE_NO_DIRECTION.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 318.png
    </td>
    <td>
    StVO 318
    </td>
    <td>
    Parking with parking disk
    </td>
    <td>
    Set \\c Classification::direction_scope to \\c
    #DIRECTION_SCOPE_NO_DIRECTION.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 314-10.png
    </td>
    <td>
    StVO 314-10
    </td>
    <td>
    </td>
    <td>
    Set \\c Classification::direction_scope to \\c
    #DIRECTION_SCOPE_LEFT.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 314-20.png
    </td>
    <td>
    StVO 314-20
    </td>
    <td>
    </td>
    <td>
    Set \\c Classification::direction_scope to \\c
    #DIRECTION_SCOPE_RIGHT.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 314-30.png
    </td>
    <td>
    StVO 314-30
    </td>
    <td>
    </td>
    <td>
    Set \\c Classification::direction_scope to \\c
    #DIRECTION_SCOPE_LEFT_RIGHT.
    </td>
    </tr>
    </table>
    """

    CAR_PARKING_ZONE_BEGIN = 75
    """
    Begin of parking zone.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 314.1.png
    </td>
    <td>
    StVO 314.1
    </td>
    </tr>
    </table>

    End: \\c #TYPE_CAR_PARKING_ZONE_END
    """

    CAR_PARKING_ZONE_END = 76
    """
    End of parking zone.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 314.2.png
    </td>
    <td>
    StVO 314.2
    </td>
    </tr>
    </table>

    Begin: \\c #TYPE_CAR_PARKING_ZONE_BEGIN
    """

    SIDEWALK_HALF_PARKING_LEFT = 172
    """
    Parking on sidewalks half in the direction of travel left.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 315-50.png
    -->
    </td>
    <td>
    StVO 315-50
    </td>
    </tr>
    </table>

    Right: \\c #TYPE_SIDEWALK_HALF_PARKING_RIGHT
    """

    SIDEWALK_HALF_PARKING_RIGHT = 173
    """
    Parking on sidewalks half in the direction of travel right.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 315-55.png
    </td>
    <td>
    StVO 315-55
    </td>
    </tr>
    </table>

    Left: \\c #TYPE_SIDEWALK_HALF_PARKING_LEFT
    """

    SIDEWALK_PARKING_LEFT = 174
    """
    Parking on sidewalks completely in the direction of
    travel left.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 315-60.png
    -->
    </td>
    <td>
    StVO 315-60
    </td>
    </tr>
    </table>

    Right: \\c #TYPE_SIDEWALK_PARKING_RIGHT
    """

    SIDEWALK_PARKING_RIGHT = 175
    """
    Parking on sidewalks completely in direction of travel right.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 315-65.png
    -->
    </td>
    <td>
    StVO 315-65
    </td>
    </tr>
    </table>

    Left: \\c #TYPE_SIDEWALK_PARKING_LEFT
    """

    SIDEWALK_PERPENDICULAR_HALF_PARKING_LEFT = 176
    """
    Parking on sidewalks half, perpendicular, in the direction of
    travel left.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 315-70.png
    -->
    </td>
    <td>
    StVO 315-70
    </td>
    </tr>
    </table>

    Right: \\c #TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_RIGHT
    """

    SIDEWALK_PERPENDICULAR_HALF_PARKING_RIGHT = 177
    """
    Parking on sidewalks half, perpendicular, in the direction of
    travel right.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 315-75.png
    -->
    </td>
    <td>
    StVO 315-75
    </td>
    </tr>
    </table>

    Left: \\c #TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_LEFT
    """

    SIDEWALK_PERPENDICULAR_PARKING_LEFT = 178
    """
    Parking on sidewalks, perpendicular, in the direction of
    travel left.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 315-80.png
    -->
    </td>
    <td>
    StVO 315-80
    </td>
    </tr>
    </table>

    Right: \\c #TYPE_SIDEWALK_PERPENDICULAR_PARKING_RIGHT
    """

    SIDEWALK_PERPENDICULAR_PARKING_RIGHT = 179
    """
    Parking on sidewalks, perpendicular, in the direction of
    travel right.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 315-85.png
    -->
    </td>
    <td>
    StVO 315-85
    </td>
    </tr>
    </table>

    Left: \\c #TYPE_SIDEWALK_PERPENDICULAR_PARKING_LEFT
    """

    LIVING_STREET_BEGIN = 77
    """
    Start of area with calmed / reduced traffic / home zone.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 325.1.png
    </td>
    <td>
    StVO 325.1
    </td>
    </tr>
    </table>

    End: \\c #TYPE_LIVING_STREET_END
    """

    LIVING_STREET_END = 78
    """
    End of area with calmed / reduced traffic / home zone.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 325.2.png
    </td>
    <td>
    StVO 325.2
    </td>
    </tr>
    </table>

    Begin: \\c #TYPE_LIVING_STREET_BEGIN
    """

    TUNNEL = 79
    """
    Tunnel ahead.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 327.png
    </td>
    <td>
    StVO 327
    </td>
    </tr>
    </table>
    """

    EMERGENCY_STOPPING_LEFT = 80
    """
    Emergency stopping place left.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 328.png
    </td>
    <td>
    </td>
    </tr>
    </table>

    \\note This type is to be applied in left-driving countries.

    Right: \\c #TYPE_EMERGENCY_STOPPING_RIGHT
    """

    EMERGENCY_STOPPING_RIGHT = 81
    """
    Emergency stopping place right.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 328.png
    </td>
    <td>
    StVO 328
    </td>
    </tr>
    </table>

    Left: \\c #TYPE_EMERGENCY_STOPPING_LEFT
    """

    HIGHWAY_BEGIN = 82
    """
    Begin of highway.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 330.1.png
    </td>
    <td>
    StVO 330.1
    </td>
    </tr>
    </table>

    End: \\c #TYPE_HIGHWAY_END
    """

    HIGHWAY_END = 83
    """
    End of highway.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 330.2.png
    </td>
    <td>
    StVO 330.2
    </td>
    </tr>
    </table>

    Begin: \\c #TYPE_HIGHWAY_BEGIN
    """

    EXPRESSWAY_BEGIN = 84
    """
    Begin of expressway for motor vehicles.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 331.1.png
    </td>
    <td>
    StVO 331.1
    </td>
    </tr>
    </table>

    End: \\c #TYPE_EXPRESSWAY_END
    """

    EXPRESSWAY_END = 85
    """
    End of expressways for motor vehicles.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 331.2.png
    </td>
    <td>
    StVO 331.2
    </td>
    </tr>
    </table>

    Begin: \\c #TYPE_EXPRESSWAY_BEGIN
    """

    NAMED_HIGHWAY_EXIT = 183
    """
    Highway exit.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 332.png
    </td>
    <td>
    StVO 332
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::text to denote the destination
    indicated in the sign, e.g. "Mainz Wiesbaden".
    """

    NAMED_EXPRESSWAY_EXIT = 184
    """
    Expressway exit.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 332.1.png
    </td>
    <td>
    StVO 332.1
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::text to denote the destination
    indicated in the sign, e.g. "Mainz Wiesbaden".
    """

    NAMED_ROAD_EXIT = 185
    """
    Exit sign on other roads.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 332.1-20.png
    </td>
    <td>
    StVO 332.1-20
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::text to denote the destination
    indicated in the sign, e.g. "Duisburg Endeninch".
    """

    HIGHWAY_EXIT = 86
    """
    Highway exit sign.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 333.png
    </td>
    <td>
    StVO 333
    </td>
    </tr>
    </table>
    """

    EXPRESSWAY_EXIT = 186
    """
    Exit from expressway (arrow sign).
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 333.1.png
    </td>
    <td>
    StVO 333.1
    </td>
    </tr>
    </table>
    """

    ONEWAY_STREET = 187
    """
    One-way street.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 353.png
    -->
    </td>
    <td>
    StVO 353  - Valid only until October 2022.
    </td>
    </tr>
    </table>
    """

    CROSSING_GUARDS = 189
    """
    Crossing guards.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 356.png
    </td>
    <td>
    StVO 356
    </td>
    </tr>
    </table>
    """

    DEADEND = 190
    """
    Dead-end street.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 357.png
    </td>
    <td>
    StVO 357
    </td>
    </tr>
    </table>
    """

    DEADEND_EXCLUDING_DESIGNATED_ACTORS = 191
    """
    Dead-end street excluding ...
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 357-50.png
    </td>
    <td>
    StVO 357-50
    </td>
    <td>
    excluding pedestrians and bicycles.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 357-51.png
    </td>
    <td>
    StVO 357-51
    </td>
    <td>
    excluding pedestrians.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 357-52.png
    </td>
    <td>
    StVO 357-52
    </td>
    <td>
    excluding bicycles.
    </td>
    </tr>
    </table>
    """

    FIRST_AID_STATION = 194
    """
    First aid station.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 358.png
    </td>
    <td>
    StVO 358
    </td>
    </tr>
    </table>
    """

    POLICE_STATION = 195
    """
    Police station.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 363.png
    </td>
    <td>
    StVO 363
    </td>
    </tr>
    </table>
    """

    TELEPHONE = 196
    """
    Telephone service.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 365-50.png
    </td>
    <td>
    StVO 365-50
    </td>
    <td>
    Telephone service
    </td>
    <td>
    </td>
    </tr>
    <tr>
    <td>
    \\image html 365-51.png
    </td>
    <td>
    StVO 365-51
    </td>
    <td>
    Emergency telephone service
    </td>
    <td>
    Use \\c TrafficSignValue::text for "SOS".
    </td>
    </tr>
    </table>
    """

    FILLING_STATION = 198
    """
    Filling station.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 365-52.png
    </td>
    <td>
    StVO 365-52
    </td>
    <td>
    Filling station.
    </td>
    <td>
    </td>
    </tr>
    <tr>
    <td>
    \\image html 365-53.png
    </td>
    <td>
    StVO 365-53
    </td>
    <td>
    LPG filling station.
    </td>
    <td>
    Use \\c TrafficSignValue::text for "LPG".
    </td>
    </tr>
    <tr>
    <td>
    \\image html 365-54.png
    </td>
    <td>
    StVO 365-54
    </td>
    <td>
    CNG filling station.
    </td>
    <td>
    Use \\c TrafficSignValue::text for "CNG".
    </td>
    </tr>
    <tr>
    <td>
    \\image html 365-65.png
    </td>
    <td>
    StVO 365-65
    </td>
    <td>
    Charging station for electric vehicles.
    </td>
    <td>
    Use \\c TrafficSignValue::text for "E".
    </td>
    </tr>
    <tr>
    <td>
    \\image html 365-66.png
    </td>
    <td>
    StVO 365-66
    </td>
    <td>
    H2 filling station.
    </td>
    <td>
    Use \\c TrafficSignValue::text for "H2".
    </td>
    </tr>
    </table>
    """

    HOTEL = 201
    """
    Highway hotel.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 365-55.png
    </td>
    <td>
    StVO 365-55
    </td>
    </tr>
    </table>
    """

    INN = 202
    """
    Highway inn.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 365-56.png
    </td>
    <td>
    StVO 365-56
    </td>
    </tr>
    </table>
    """

    KIOSK = 203
    """
    Highway kiosk.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 365-57.png
    </td>
    <td>
    StVO 365-57
    </td>
    </tr>
    </table>
    """

    TOILET = 204
    """
    Toilets.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 365-58.png
    </td>
    <td>
    StVO 365-58
    </td>
    </tr>
    </table>
    """

    CHAPEL = 205
    """
    Highway chapel.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 365-59.png
    </td>
    <td>
    StVO 365-59
    </td>
    </tr>
    </table>
    """

    TOURIST_INFO = 206
    """
    Tourist information.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 365-61.png
    </td>
    <td>
    StVO 365-61
    </td>
    </tr>
    </table>
    """

    REPAIR_SERVICE = 207
    """
    Roadside assistance.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 365-62.png
    </td>
    <td>
    StVO 365-62
    </td>
    </tr>
    </table>
    """

    PEDESTRIAN_UNDERPASS = 208
    """
    Underpass for pedestrians.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 365-63.png
    </td>
    <td>
    StVO 365-63
    </td>
    </tr>
    </table>
    """

    PEDESTRIAN_BRIDGE = 209
    """
    Pedestrian bridge.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 365-64.png
    </td>
    <td>
    StVO 365-64
    </td>
    </tr>
    </table>
    """

    CAMPER_PLACE = 213
    """
    Camper place.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 365-67.png
    </td>
    <td>
    StVO 365-67
    </td>
    </tr>
    </table>
    Camper and caravan place
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 365-68.png
    </td>
    <td>
    StVO 365-68
    </td>
    </tr>
    </table>
    """

    ADVISORY_SPEED_LIMIT_BEGIN = 214
    """
    Advisory speed limit beginning.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 380.png
    -->
    </td>
    <td>
    StVO 380 - Valid only until October 2022.
    </td>
    </tr>
    </table>

    \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit.
    """

    ADVISORY_SPEED_LIMIT_END = 215
    """
    Advisory speed limit end.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 381.png
    -->
    </td>
    <td>
    StVO 381 - Valid only until October 2022
    </td>
    </tr>
    </table>

    \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit.
    """

    PLACE_NAME = 216
    """
    Road passes through the town but not its city center.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 385.png
    </td>
    <td>
    StVO 385
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::text to denote the town indicated in
    the sign.
    """

    TOURIST_ATTRACTION = 217
    """
    Tourist attraction.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 386.1.png
    </td>
    <td>
    StVO 386.1
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::text to denote the attraction
    indicated in the sign.
    """

    TOURIST_ROUTE = 218
    """
    Tourist route.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 386.2.png
    </td>
    <td>
    StVO 386.2
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::text to denote the route indicated
    in the sign.
    """

    TOURIST_AREA = 219
    """
    Geographical area containing several tourist attractions.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 386.3.png
    </td>
    <td>
    StVO 386.3
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::text to denote the area indicated in
    the sign.
    """

    SHOULDER_NOT_PASSABLE_MOTOR_VEHICLES = 220
    """
    Shoulder unsafe for multi-track motor vehicles.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 388.png
    -->
    </td>
    <td>
    StVO 388 - Valid only until October 2022
    </td>
    </tr>
    </table>
    """

    SHOULDER_UNSAFE_TRUCKS_TRACTORS = 221
    """
    Shoulder unsafe for vehicles with a permitted gross weight
    over 3.5 t and for tractors.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 389.png
    -->
    </td>
    <td>
    StVO 389 - Valid only until October 2022
    </td>
    </tr>
    </table>
    """

    TOLL_BEGIN = 222
    """
    Toll highway beginning.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 390.png
    </td>
    <td>
    StVO 390
    </td>
    </tr>
    </table>
    """

    TOLL_END = 223
    """
    Toll highway end.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 390.2.png
    </td>
    <td>
    StVO 390.2
    </td>
    </tr>
    </table>
    """

    TOLL_ROAD = 224
    """
    Toll road.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 391.png
    </td>
    <td>
    StVO 391
    </td>
    </tr>
    </table>
    """

    CUSTOMS = 225
    """
    Customs post.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 392.png
    -->
    </td>
    <td>
    StVO 392
    </td>
    </tr>
    </table>
    """

    INTERNATIONAL_BORDER_INFO = 226
    """
    Information sign posted at international borders.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 393.png
    </td>
    <td>
    StVO 393
    </td>
    </tr>
    </table>
    """

    STREETLIGHT_RED_BAND = 227
    """
    Red band on lamp posts indicate that streetlight does not
    stay on all night.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 394.png "StVO 394"
    <td>
    \\image html 394-50.png "StVO 394-50"
    </tr>
    </table>
    """

    FEDERAL_HIGHWAY_ROUTE_NUMBER = 228
    """
    Federal Highway route number.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 401.png
    </td>
    <td>
    StVO 401
    </td>
    </tr>
    </table>
    """

    HIGHWAY_ROUTE_NUMBER = 229
    """
    Highway route number.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 405.png
    </td>
    <td>
    StVO 405
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::text to denote the route number
    indicated in the sign.
    """

    HIGHWAY_INTERCHANGE_NUMBER = 230
    """
    Highway interchange number (exits, three and four-way
    interchanges).
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 406-50.png "StVO 406-50"
    <td>
    \\image html 406-51.png "StVO 406-51"
    </tr>
    </table>

    Use \\c TrafficSignValue::text to denote the route number
    indicated in the sign.
    """

    EUROPEAN_ROUTE_NUMBER = 231
    """
    European route number.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 410.png
    </td>
    <td>
    StVO 410
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::text to denote the route number
    indicated in the sign.
    """

    FEDERAL_HIGHWAY_DIRECTION_LEFT = 232
    """
    Federal highway direction sign, left.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 415-10.png
    </td>
    <td>
    StVO 415-10
    </td>
    </tr>
    </table>

    Right: \\c #TYPE_FEDERAL_HIGHWAY_DIRECTION_RIGHT
    """

    FEDERAL_HIGHWAY_DIRECTION_RIGHT = 233
    """
    Federal highway direction sign, right.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 415-20.png
    -->
    </td>
    <td>
    StVO 415-20
    </td>
    </tr>
    </table>

    Left: \\c #TYPE_FEDERAL_HIGHWAY_DIRECTION_LEFT
    """

    PRIMARY_ROAD_DIRECTION_LEFT = 234
    """
    Primary road direction sign, left.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 418-10.png
    </td>
    <td>
    StVO 418-10
    </td>
    </tr>
    </table>

    Right: \\c #TYPE_PRIMARY_ROAD_DIRECTION_RIGHT
    """

    PRIMARY_ROAD_DIRECTION_RIGHT = 235
    """
    Primary road direction sign, right.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 418-20.png
    -->
    </td>
    <td>
    StVO 418-20
    </td>
    </tr>
    </table>

    Left: \\c #TYPE_PRIMARY_ROAD_DIRECTION_LEFT
    """

    SECONDARY_ROAD_DIRECTION_LEFT = 236
    """
    Secondary road direction sign, left.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 419-10.png
    </td>
    <td>
    StVO 419-10
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::text to denote the destination
    indicated in the sign.

    Right: \\c #TYPE_SECONDARY_ROAD_DIRECTION_RIGHT
    """

    SECONDARY_ROAD_DIRECTION_RIGHT = 237
    """
    Secondary road direction sign, right.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 419-20.png
    </td>
    <td>
    StVO 419-20
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::text to denote the destination
    indicated in the sign.

    Left: \\c #TYPE_SECONDARY_ROAD_DIRECTION_LEFT
    """

    DIRECTION_DESIGNATED_ACTORS_LEFT = 238
    """
    Advance direction sign for designated type of vehicle, left.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 421-10.png "StVO 421-10"
    <td>
    \\image html 421-11.png "StVO 421-11"
    <td>
    \\image html 421-12.png "StVO 421-12"
    </tr>
    </table>

    Right: \\c #TYPE_DIRECTION_DESIGNATED_ACTORS_RIGHT
    """

    DIRECTION_DESIGNATED_ACTORS_RIGHT = 239
    """
    Advance direction sign for designated type of vehicle, right.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 421-10.png
    <td style="transform:scaleX(-1)">
    \\image html 421-11.png
    <td style="transform:scaleX(-1)">
    \\image html 421-12.png
    </tr>
    <tr style="font-weight:bold">
    <td>
    StVO 421-20
    <td>
    StVO 421-21
    <td>
    StVO 421-22
    </tr>
    </table>

    Left: \\c #TYPE_DIRECTION_DESIGNATED_ACTORS_LEFT
    """

    ROUTING_DESIGNATED_ACTORS = 240
    """
    Routing for designated type of vehicle, left.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 422-10.png "StVO 422-10"
    <td>
    \\image html 422-12.png "StVO 422-12"
    <td>
    \\image html 422-14.png "StVO 422-14"
    <td>
    \\image html 422-16.png "StVO 422-16"
    </tr>
    </table>
    Routing for designated type of vehicle, align left.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 422-11.png "StVO 422-11"
    <td>
    \\image html 422-13.png "StVO 422-13"
    <td>
    \\image html 422-15.png "StVO 422-15"
    <td>
    \\image html 422-17.png "StVO 422-17"
    </tr>
    </table>
    Direction preannouncement sign for designated type of
    vehicle, left.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 442-10.png "StVO 442-10"
    <td>
    \\image html 442-12.png "StVO 442-12"
    <td>
    \\image html 442-13.png "StVO 442-13"
    </tr>
    </table>

    Routing or designated type of vehicle, right.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 422-10.png
    <td style="transform:scaleX(-1)">
    \\image html 422-12.png
    <td style="transform:scaleX(-1)">
    \\image html 422-14.png
    <td style="transform:scaleX(-1)">
    \\image html 422-16.png
    </tr>
    <tr style="font-weight:bold">
    <td>
    StVO 422-20
    <td>
    StVO 422-22
    <td>
    StVO 422-24
    <td>
    StVO 422-26
    </tr>
    </table>
    Routing for designated type of vehicle, align right.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 422-11.png
    <td style="transform:scaleX(-1)">
    \\image html 422-13.png
    <td style="transform:scaleX(-1)">
    \\image html 422-15.png
    <td style="transform:scaleX(-1)">
    \\image html 422-17.png
    </tr>
    <tr style="font-weight:bold">
    <td>
    StVO 422-21
    <td>
    StVO 422-23
    <td>
    StVO 422-25
    <td>
    StVO 422-27
    </tr>
    </table>
    Direction preannouncement sign for designated type of
    vehicle, right.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 442-10.png
    <td style="transform:scaleX(-1)">
    \\image html 442-12.png
    <td style="transform:scaleX(-1)">
    \\image html 442-13.png
    </tr>
    <tr style="font-weight:bold">
    <td>
    StVO 442-20
    <td>
    StVO 442-22
    <td>
    StVO 442-23
    </tr>
    </table>
    Routing for designated type of vehicle, straight.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 422-30.png "StVO 422-30"
    <td>
    \\image html 422-32.png "StVO 422-32"
    <td>
    \\image html 422-34.png "StVO 422-34"
    <td>
    \\image html 422-36.png "StVO 422-36"
    </tr>
    </table>

    \\note OSI 4.0 will describe the actors and arrows similar to
    the supplementary signs approach.
    """

    DIRECTION_TO_HIGHWAY_LEFT = 143
    """
    Direction to highway, left.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 430-10.png
    </td>
    <td>
    StVO 430-10
    </td>
    </tr>
    </table>

    Right: \\c #TYPE_DIRECTION_TO_HIGHWAY_RIGHT
    """

    DIRECTION_TO_HIGHWAY_RIGHT = 108
    """
    Direction to highway, right.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 430-20.png
    -->
    </td>
    <td>
    StVO 430-20
    </td>
    </tr>
    </table>

    Left: \\c #TYPE_DIRECTION_TO_HIGHWAY_LEFT
    """

    DIRECTION_TO_LOCAL_DESTINATION_LEFT = 127
    """
    Direction sign to important local destinations, left.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 432-10.png
    </td>
    <td>
    StVO 432-10
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::text to denote the destination
    indicated in the sign.

    Right: \\c #TYPE_DIRECTION_TO_LOCAL_DESTINATION_RIGHT
    """

    DIRECTION_TO_LOCAL_DESTINATION_RIGHT = 136
    """
    Direction sign to important local destinations, right.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 432-20.png
    -->
    </td>
    <td>
    StVO 432-20
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::text to denote the destination
    indicated in the sign.

    Left: \\c #TYPE_DIRECTION_TO_LOCAL_DESTINATION_LEFT
    """

    CONSOLIDATED_DIRECTIONS = 118
    """
    Consolidated direction sign.
    <table border="0">
    <tr>
    <td>
    \\image html 434-50.png "StVO 434-50"
    <td>
    \\image html 434-51.png "StVO 434-51"
    <td>
    \\image html 434-52.png "StVO 434-52"
    <td>
    \\image html 434-53.png "StVO 434-53"
    </tr>
    </table>
    """

    STREET_NAME = 119
    """
    Street name sign.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 437.png
    </td>
    <td>
    StVO 437
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::text to denote the street name.
    """

    DIRECTION_PREANNOUNCEMENT = 120
    """
    Direction preannouncement sign.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 438.png
    </td>
    <td>
    StVO 438
    </td>
    </tr>
    </table>
    """

    DIRECTION_PREANNOUNCEMENT_LANE_CONFIG = 121
    """
    Direction preannouncement sign including lane configuration.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 439.png
    </td>
    <td>
    StVO 439
    </td>
    </tr>
    </table>
    """

    DIRECTION_PREANNOUNCEMENT_HIGHWAY_ENTRIES = 122
    """
    Direction preannouncement sign including highway entries.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 440.png
    </td>
    <td>
    StVO 440
    </td>
    </tr>
    </table>
    """

    HIGHWAY_ANNOUNCEMENT = 123
    """
    Highway announcement board.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 448.png
    </td>
    <td>
    StVO 448
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit to set the distance. Use \\c
    TrafficSignValue::text to denote the highway and the
    direction indicated in the sign, e.g. "26 Duesseldorf -
    Benrath".
    """

    OTHER_ROAD_ANNOUNCEMENT = 124
    """
    Announcement board on other roads outside of highways.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 448-50.png
    </td>
    <td>
    StVO 448-50
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit to set the distance. Use \\c
    TrafficSignValue::text to denote the destination indicated in
    the sign.
    """

    HIGHWAY_ANNOUNCEMENT_TRUCK_STOP = 125
    """
    Announcement highway truck stop.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 448.1.png
    </td>
    <td>
    StVO 448.1
    </td>
    </tr>
    </table>
    """

    HIGHWAY_PREANNOUNCEMENT_DIRECTIONS = 126
    """
    Highway interchange advance directional sign.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 449.png
    </td>
    <td>
    StVO 449
    </td>
    </tr>
    </table>
    """

    POLE_EXIT = 88
    """
    Pole indicating highways exit in ... m.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 450-50.png "StVO 450-50"
    <td>
    \\image html 450-51.png "StVO 450-51"
    <td>
    \\image html 450-52.png "StVO 450-52"
    <td>
    \\image html 450-53.png "StVO 450-53"
    <td>
    \\image html 450-54.png "StVO 450-54"
    <td>
    \\image html 450-55.png "StVO 450-55"
    </tr>
    </table>

    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit to specify the distance in m
    or the displayed number of stripes (in that case, set \\c
    TrafficSignValue::value_unit to \\c
    TrafficSignValue::UNIT_NO_UNIT.).
    """

    HIGHWAY_DISTANCE_BOARD = 180
    """
    Highway distance board.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 453.png "StVO 453"
    <td>
    \\image html 453-50.png "StVO 453-50"
    </tr>
    </table>
    """

    DETOUR_LEFT = 181
    """
    Detour sign, pointing left.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 454-10.png
    </td>
    <td>
    StVO 454-10
    </td>
    </tr>
    </table>

    Right: \\c #TYPE_DETOUR_RIGHT
    """

    DETOUR_RIGHT = 182
    """
    Detour sign, pointing right.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 454-20.png
    -->
    </td>
    <td>
    StVO 454-20
    </td>
    </tr>
    </table>

    Left: \\c #TYPE_DETOUR_LEFT
    """

    NUMBERED_DETOUR = 131
    """
    Numbered detour route.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 455.1.png
    </td>
    <td>
    StVO 455.1
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::text to denote the alternative
    routing name indicated in the sign.

    \\note OSI 4.0 will describe the arrows similar to the
    supplementary signs approach.
    """

    DETOUR_BEGIN = 132
    """
    Announcement; begin of detour.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 457.1.png
    </td>
    <td>
    StVO 457.1
    </td>
    </tr>
    </table>
    """

    DETOUR_END = 133
    """
    End of detour.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 457.2.png
    </td>
    <td>
    StVO 457.2
    </td>
    </tr>
    </table>
    """

    DETOUR_ROUTING_BOARD = 134
    """
    Diversion routing board.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 458.png
    </td>
    <td>
    StVO 458
    </td>
    </tr>
    </table>
    """

    OPTIONAL_DETOUR = 111
    """
    The sign indicates an alternative routing.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 460-50.png
    </td>
    <td>
    StVO 460-50
    </td>
    <td>
    The sign indicates an alternative routing, announcement.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 460-10.png
    </td>
    <td>
    StVO 460-10
    </td>
    <td>
    The sign indicates an alternative routing, preannouncement
    left.
    </td>
    </tr>
    <tr>
    <td>
    <!--
    \\image html 460-11.png
    -->
    </td>
    <td>
    StVO 460-11
    </td>
    <td>
    The sign indicates an alternative routing, left.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 460-12.png
    </td>
    <td>
    StVO 460-12
    </td>
    <td>
    The sign indicates an alternative routing, change lane left.
    </td>
    </tr>
    <tr>
    <td>
    <!--
    \\image html 460-20.png
    -->
    </td>
    <td>
    StVO 460-20
    </td>
    <td>
    The sign indicates an alternative routing, preannouncement
    right.
    </td>
    </tr>
    <tr>
    <td>
    <!--
    \\image html 460-21.png
    -->
    </td>
    <td>
    StVO 460-21
    </td>
    <td>
    The sign indicates an alternative routing, right.
    </td>
    </tr>
    <tr>
    <td>
    <!--
    \\image html 460-22.png
    -->
    </td>
    <td>
    StVO 460-22
    </td>
    <td>
    The sign indicates an alternative routing, lane change
    right.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 460-30.png
    </td>
    <td>
    StVO 460-30
    </td>
    <td>
    The sign indicates an alternative routing, straight.
    </td>
    </tr>
    </table>

    Use \\c TrafficSignValue::text to denote the alternative
    routing name indicated in the sign.

    \\note OSI 4.0 will describe the arrows similar to the
    supplementary signs approach.
    """

    OPTIONAL_DETOUR_ROUTING = 199
    """
    Provisional diversion route schematic.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 466.png
    </td>
    <td>
    StVO 466
    </td>
    </tr>
    </table>
    """

    ROUTE_RECOMMENDATION = 211
    """
    Recommended alternate route.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 467.1-10.png
    </td>
    <td>
    StVO 467.1-10
    </td>
    <td>
    Set \\c Classification::direction_scope as \\c
    DIRECTION_SCOPE_LEFT.
    </td>
    </tr>
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 467.1-10.png
    </td>
    <td>
    StVO 467.1-20
    </td>
    <td>
    Set \\c Classification::direction_scope as \\c
    DIRECTION_SCOPE_RIGHT.
    </td>
    </tr>
    </table>
    """

    ROUTE_RECOMMENDATION_END = 212
    """
    End of recommended alternate route.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 467.2.png
    </td>
    <td>
    StVO 467.2
    </td>
    </tr>
    </table>
    """

    ANNOUNCE_LANE_TRANSITION_LEFT = 192
    """
    X lanes transition, left.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 501-10.png
    -->
    </td>
    <td>
    StVO 501-10
    </td>
    <td>
    One associated lane.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 501-11.png
    </td>
    <td>
    StVO 501-11
    </td>
    <td>
    Two associated lanes.
    </td>
    </tr>
    <tr>
    <td>
    <!--
    \\image html 501-12.png
    -->
    </td>
    <td>
    StVO 501-12
    </td>
    <td>
    Three associated lanes.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 505-11.png
    </td>
    <td>
    (StVO 505-11)
    </td>
    <td>
    Two associated lanes with restriction.
    Restriction defined as additional main sign.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 505-12.png
    </td>
    <td>
    (StVO 505-12)
    </td>
    <td>
    Three associated lanes with restriction.
    Restrictions defined as additional main sign(s).
    </td>
    </tr>
    </table>

    Right: \\c #TYPE_ANNOUNCE_LANE_TRANSITION_RIGHT
    """

    ANNOUNCE_LANE_TRANSITION_RIGHT = 193
    """
    X lanes transition, right.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 501-20.png
    -->
    </td>
    <td>
    StVO 501-20
    </td>
    <td>
    One associated lane.
    </td>
    </tr>
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 501-11.png
    </td>
    <td>
    StVO 501-21
    </td>
    <td>
    Two associated lanes.
    </td>
    </tr>
    <tr>
    <td>
    <!--
    \\image html 501-22.png
    -->
    </td>
    <td>
    StVO 501-22
    </td>
    <td>
    Three associated lanes.
    </td>
    </tr>
    <tr>
    <td>
    <!--
    \\image html 505-21.png
    -->
    </td>
    <td>
    (StVO 505-21)
    </td>
    <td>
    Two associated lanes with restriction.
    Restriction defined as additional main sign.
    </td>
    </tr>
    <tr>
    <td>
    <!--
    \\image html 505-22.png
    -->
    </td>
    <td>
    (StVO 505-22)
    </td>
    <td>
    Three associated lanes with restriction.
    Restrictions defined as additional main sign(s).
    </td>
    </tr>
    </table>

    Left: \\c #TYPE_ANNOUNCE_LANE_TRANSITION_LEFT
    """

    ANNOUNCE_RIGHT_LANE_END = 90
    """
    End of X right lanes.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 531-10.png
    </td>
    <td>
    StVO 531-10
    </td>
    </tr>
    </table>

    As symbolic road marking \\c
    RoadMarking::Classification::TYPE_SYMBOLIC_TRAFFIC_SIGN.

    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image tml 297.1-21.png
    -->
    </td>
    <td>
    StVO 297.1-21
    </td>
    </tr>
    </table>
    """

    ANNOUNCE_LEFT_LANE_END = 89
    """
    End of X left lanes.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 531-10.png
    </td>
    <td>
    StVO 531-20
    </td>
    </tr>
    </table>

    As symbolic road marking \\c
    RoadMarking::Classification::TYPE_SYMBOLIC_TRAFFIC_SIGN.

    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 297.1-21.png
    -->
    </td>
    <td>
    StVO 297.1-21
    </td>
    </tr>
    </table>
    """

    ANNOUNCE_RIGHT_LANE_BEGIN = 115
    """
    Begin of X right lanes.
    <!--
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 545-11.png
    </td>
    <td>
    (StVO 545-11)
    </td>
    <td>
    Extension from two to three lanes with minimum speed by lane.
    </td>
    <td>
    Restrictions defined as additional main sign(s).
    </td>
    </tr>
    </table>-->

    Left: \\c #TYPE_ANNOUNCE_LEFT_LANE_BEGIN
    """

    ANNOUNCE_LEFT_LANE_BEGIN = 116
    """
    Begin of X left lanes.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 545-11.png
    </td>
    <td>
    (StVO 545-11)
    </td>
    <td>
    Extension from two to three lanes with minimum speed by lane.
    </td>
    <td>
    Restrictions defined as additional main signs.
    </td>
    </tr>
    </table>

    Right: \\c #TYPE_ANNOUNCE_RIGHT_LANE_BEGIN
    """

    ANNOUNCE_LANE_CONSOLIDATION = 117
    """
    Announce lane consolidation.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 551-20.png
    -->
    </td>
    <td>
    StVO 551-20
    </td>
    <td>
    Consolidation of lanes from multiple roads, one continuing,
    one opening.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 551-21.png
    </td>
    <td>
    StVO 551-21
    </td>
    <td>
    Consolidation of lanes from multiple roads, two continuing,
    one opening.
    </td>
    </tr>
    <tr>
    <td>
    <!--
    \\image html 551-22.png
    -->
    </td>
    <td>
    StVO 551-22
    </td>
    <td>
    Consolidation of lanes from multiple roads, two continuing,
    two opening.
    </td>
    </tr>
    <tr>
    <td>
    <!--
    \\image html 551-23.png
    -->
    </td>
    <td>
    StVO 551-23
    </td>
    <td>
    Consolidation of lanes from multiple roads, three continuing,
    two opening.
    </td>
    </tr>
    <tr>
    <td>
    <!--
    \\image html 551-24.png
    -->
    </td>
    <td>
    StVO 551-24
    </td>
    <td>
    Consolidation of lanes from multiple roads, three continuing,
    one opening.
    </td>
    </tr>
    </table>
    """

    DETOUR_CITY_BLOCK = 142
    """
    Detour around city block.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 590-10.png
    </td>
    <td>
    StVO 590-10
    </td>
    <td>
    turn right, left, left
    </td>
    </tr>
    <tr>
    <td>
    <!--
    \\image html 590-11.png
    -->
    </td>
    <td>
    StVO 590-11
    </td>
    <td>
    turn right, right, right
    </td>
    </tr>
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 590-10.png
    </td>
    <td>
    </td>
    <td>
    turn left, right, right
    </td>
    </tr>
    <tr>
    <td>
    </td>
    <td>
    </td>
    <td>
    turn left, left, left
    </td>
    </tr>
    </table>
    """

    GATE = 141
    """
    Boom gate.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 600-25.png
    </td>
    <td>
    StVO 600
    </td>
    </tr>
    </table>
    """

    POLE_WARNING = 91
    """
    Pole for warning and guiding purposes
    (red/white stripes - StVO 605, also StVO 628 and StVO 629).
    <table border="0">
    <tr>
    <td>
    \\image html 605-10.png "StVO 605"
    <td>
    \\image html 628-10.png "StVO 628"
    <td>
    \\image html 629-10.png "StVO 629"
    </tr>
    </table>

    Variants (here X can be any of 605, 628 or 629):
    <table border="0">
    <tr>
    <td>
    StVO X-10, -12, -13 and -14
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c false.
    </td>
    </tr>
    <tr>
    <td>
    StVO X-11
    </td>
    <td>
    Set \\c Classification::direction_scope as \\c
    #DIRECTION_SCOPE_RIGHT.
    </td>
    </tr>
    <tr>
    <td>
    StVO X-20, -22, -23 and -24
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c true.
    </td>
    </tr>
    <tr>
    <td>
    StVO X-21
    </td>
    <td>
    Set \\c Classification::direction_scope as \\c
    #DIRECTION_SCOPE_LEFT.
    </td>
    </tr>
    </table>
    """

    TRAFFIC_CONE = 140
    """
    Traffic cone.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 610-41.png
    </td>
    <td>
    StVO 610
    </td>
    </tr>
    </table>
    """

    MOBILE_LANE_CLOSURE = 139
    """
    Mobile lane closure board.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 615.png
    </td>
    <td>
    StVO 615
    </td>
    <td>
    no arrow
    </td>
    </tr>
    <tr>
    <td>
    \\image html 616-30.png
    </td>
    <td>
    StVO 616-30
    </td>
    <td>
    with lighted arrow, large
    </td>
    </tr>
    <tr>
    <td>
    <!--
    \\image html 616-31.png
    -->
    </td>
    <td>
    StVO 616-31
    </td>
    <td>
    with lighted arrow, small
    </td>
    </tr>
    </table>

    \\note Additional traffic signs are modeled as separate main
    signs.
    """

    REFLECTOR_POST = 114
    """
    Reflector guide posts.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 620-40.png
    </td>
    <td>
    StVO 620-40
    </td>
    <td>
    Reflector guide posts, rectangular reflecting.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 620-41.png
    </td>
    <td>
    StVO 621-40
    </td>
    <td>
    Reflector guide posts, two dots reflecting.
    </td>
    </tr>
    </table>

    \\note No reflecting color is specified.
    """

    DIRECTIONAL_BOARD_WARNING = 113
    """
    Directional board used for warning and guiding purposes
    (red/white stripes - StVO 625).

    Use the optional attribute \\c Classification::direction_scope
    to specify the direction the wedge symbols are pointing at.

    Variants (here X is any of 0, 1, 2, 3):
    <table border="0">
    <tr>
    <td>
    \\image html 625-11.png
    </td>
    <td>
    StVO 625-1X
    </td>
    <td>
    - Set \\c Classification::direction_scope as \\c
    #DIRECTION_SCOPE_LEFT.
    - Optionally, use \\c TrafficSignValue::value to specify the
    number of wedges on the board. If you do so, set \\c
    TrafficSignValue::value_unit to \\c
    TrafficSignValue::UNIT_NO_UNIT.
    </td>
    </tr>
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 625-11.png
    </td>
    <td>
    StVO 625-2X
    </td>
    <td>
    - Set \\c Classification::direction_scope as \\c
    DIRECTION_SCOPE_RIGHT.
    - Optionally, use \\c TrafficSignValue::value to specify the
    number of wedges on the board. If you do so, set \\c
    TrafficSignValue::value_unit to \\c
    TrafficSignValue::UNIT_NO_UNIT.
    </td>
    </tr>
    </table>
    """

    GUIDING_PLATE = 104
    """
    Guiding plate.
    <table border="0">
    <tr>
    <td>
    \\image html 626-10.png
    </td>
    <td>
    StVO 626-10
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c false.
    </td>
    </tr>
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 626-10.png
    </td>
    <td>
    StVO 626-20
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c true.
    </td>
    </tr>
    </table>
    """

    GUIDING_PLATE_WEDGES = 105
    """
    Guiding plate, wedges.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 626-30.png
    </td>
    <td>
    StVO 626-30, 626-31
    </td>
    </tr>
    </table>
    """

    PARKING_HAZARD = 99
    """
    Parking hazard.
    <table border="0">
    <tr>
    <td>
    \\image html 630.png
    </td>
    <td>
    StVO 630-10
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c false.
    </td>
    </tr>
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 630.png
    </td>
    <td>
    StVO 630-20
    </td>
    <td>
    Set \\c #vertically_mirrored to \\c true.
    </td>
    </tr>
    </table>
    """

    TRAFFIC_LIGHT_GREEN_ARROW = 92
    """
    Green arrow sign at a traffic light.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 720.png
    </td>
    <td>
    StVO 720
    </td>
    </tr>
    </table>
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "TYPE_UNKNOWN",
            1: "TYPE_OTHER",
            2: "TYPE_DANGER_SPOT",
            87: "TYPE_ZEBRA_CROSSING",
            110: "TYPE_FLIGHT",
            200: "TYPE_CATTLE",
            197: "TYPE_HORSE_RIDERS",
            188: "TYPE_AMPHIBIANS",
            96: "TYPE_FALLING_ROCKS",
            94: "TYPE_SNOW_OR_ICE",
            97: "TYPE_LOOSE_GRAVEL",
            102: "TYPE_WATERSIDE",
            210: "TYPE_CLEARANCE",
            101: "TYPE_MOVABLE_BRIDGE",
            3: "TYPE_RIGHT_BEFORE_LEFT_NEXT_INTERSECTION",
            4: "TYPE_TURN_LEFT",
            5: "TYPE_TURN_RIGHT",
            6: "TYPE_DOUBLE_TURN_LEFT",
            7: "TYPE_DOUBLE_TURN_RIGHT",
            8: "TYPE_HILL_DOWNWARDS",
            9: "TYPE_HILL_UPWARDS",
            93: "TYPE_UNEVEN_ROAD",
            95: "TYPE_ROAD_SLIPPERY_WET_OR_DIRTY",
            98: "TYPE_SIDE_WINDS",
            10: "TYPE_ROAD_NARROWING",
            12: "TYPE_ROAD_NARROWING_RIGHT",
            11: "TYPE_ROAD_NARROWING_LEFT",
            13: "TYPE_ROAD_WORKS",
            100: "TYPE_TRAFFIC_QUEUES",
            14: "TYPE_TWO_WAY_TRAFFIC",
            15: "TYPE_ATTENTION_TRAFFIC_LIGHT",
            103: "TYPE_PEDESTRIANS",
            106: "TYPE_CHILDREN_CROSSING",
            107: "TYPE_CYCLE_ROUTE",
            109: "TYPE_DEER_CROSSING",
            144: "TYPE_UNGATED_LEVEL_CROSSING",
            112: "TYPE_LEVEL_CROSSING_MARKER",
            135: "TYPE_RAILWAY_TRAFFIC_PRIORITY",
            16: "TYPE_GIVE_WAY",
            17: "TYPE_STOP",
            18: "TYPE_PRIORITY_TO_OPPOSITE_DIRECTION",
            19: "TYPE_PRIORITY_TO_OPPOSITE_DIRECTION_UPSIDE_DOWN",
            20: "TYPE_PRESCRIBED_LEFT_TURN",
            21: "TYPE_PRESCRIBED_RIGHT_TURN",
            22: "TYPE_PRESCRIBED_STRAIGHT",
            24: "TYPE_PRESCRIBED_RIGHT_WAY",
            23: "TYPE_PRESCRIBED_LEFT_WAY",
            26: "TYPE_PRESCRIBED_RIGHT_TURN_AND_STRAIGHT",
            25: "TYPE_PRESCRIBED_LEFT_TURN_AND_STRAIGHT",
            27: "TYPE_PRESCRIBED_LEFT_TURN_AND_RIGHT_TURN",
            28: "TYPE_PRESCRIBED_LEFT_TURN_RIGHT_TURN_AND_STRAIGHT",
            29: "TYPE_ROUNDABOUT",
            30: "TYPE_ONEWAY_LEFT",
            31: "TYPE_ONEWAY_RIGHT",
            32: "TYPE_PASS_LEFT",
            33: "TYPE_PASS_RIGHT",
            128: "TYPE_SIDE_LANE_OPEN_FOR_TRAFFIC",
            129: "TYPE_SIDE_LANE_CLOSED_FOR_TRAFFIC",
            130: "TYPE_SIDE_LANE_CLOSING_FOR_TRAFFIC",
            137: "TYPE_BUS_STOP",
            138: "TYPE_TAXI_STAND",
            145: "TYPE_BICYCLES_ONLY",
            146: "TYPE_HORSE_RIDERS_ONLY",
            147: "TYPE_PEDESTRIANS_ONLY",
            148: "TYPE_BICYCLES_PEDESTRIANS_SHARED_ONLY",
            149: "TYPE_BICYCLES_PEDESTRIANS_SEPARATED_LEFT_ONLY",
            150: "TYPE_BICYCLES_PEDESTRIANS_SEPARATED_RIGHT_ONLY",
            151: "TYPE_PEDESTRIAN_ZONE_BEGIN",
            152: "TYPE_PEDESTRIAN_ZONE_END",
            153: "TYPE_BICYCLE_ROAD_BEGIN",
            154: "TYPE_BICYCLE_ROAD_END",
            34: "TYPE_BUS_LANE",
            35: "TYPE_BUS_LANE_BEGIN",
            36: "TYPE_BUS_LANE_END",
            37: "TYPE_ALL_PROHIBITED",
            38: "TYPE_MOTORIZED_MULTITRACK_PROHIBITED",
            39: "TYPE_TRUCKS_PROHIBITED",
            40: "TYPE_BICYCLES_PROHIBITED",
            41: "TYPE_MOTORCYCLES_PROHIBITED",
            155: "TYPE_MOPEDS_PROHIBITED",
            156: "TYPE_HORSE_RIDERS_PROHIBITED",
            157: "TYPE_HORSE_CARRIAGES_PROHIBITED",
            158: "TYPE_CATTLE_PROHIBITED",
            159: "TYPE_BUSES_PROHIBITED",
            160: "TYPE_CARS_PROHIBITED",
            161: "TYPE_CARS_TRAILERS_PROHIBITED",
            162: "TYPE_TRUCKS_TRAILERS_PROHIBITED",
            163: "TYPE_TRACTORS_PROHIBITED",
            42: "TYPE_PEDESTRIANS_PROHIBITED",
            43: "TYPE_MOTOR_VEHICLES_PROHIBITED",
            164: "TYPE_HAZARDOUS_GOODS_VEHICLES_PROHIBITED",
            165: "TYPE_OVER_WEIGHT_VEHICLES_PROHIBITED",
            166: "TYPE_VEHICLES_AXLE_OVER_WEIGHT_PROHIBITED",
            167: "TYPE_VEHICLES_EXCESS_WIDTH_PROHIBITED",
            168: "TYPE_VEHICLES_EXCESS_HEIGHT_PROHIBITED",
            169: "TYPE_VEHICLES_EXCESS_LENGTH_PROHIBITED",
            44: "TYPE_DO_NOT_ENTER",
            170: "TYPE_SNOW_CHAINS_REQUIRED",
            171: "TYPE_WATER_POLLUTANT_VEHICLES_PROHIBITED",
            45: "TYPE_ENVIRONMENTAL_ZONE_BEGIN",
            46: "TYPE_ENVIRONMENTAL_ZONE_END",
            47: "TYPE_NO_U_TURN_LEFT",
            48: "TYPE_NO_U_TURN_RIGHT",
            49: "TYPE_PRESCRIBED_U_TURN_LEFT",
            50: "TYPE_PRESCRIBED_U_TURN_RIGHT",
            51: "TYPE_MINIMUM_DISTANCE_FOR_TRUCKS",
            52: "TYPE_SPEED_LIMIT_BEGIN",
            53: "TYPE_SPEED_LIMIT_ZONE_BEGIN",
            54: "TYPE_SPEED_LIMIT_ZONE_END",
            55: "TYPE_MINIMUM_SPEED_BEGIN",
            56: "TYPE_OVERTAKING_BAN_BEGIN",
            57: "TYPE_OVERTAKING_BAN_FOR_TRUCKS_BEGIN",
            58: "TYPE_SPEED_LIMIT_END",
            59: "TYPE_MINIMUM_SPEED_END",
            60: "TYPE_OVERTAKING_BAN_END",
            61: "TYPE_OVERTAKING_BAN_FOR_TRUCKS_END",
            62: "TYPE_ALL_RESTRICTIONS_END",
            63: "TYPE_NO_STOPPING",
            64: "TYPE_NO_PARKING",
            65: "TYPE_NO_PARKING_ZONE_BEGIN",
            66: "TYPE_NO_PARKING_ZONE_END",
            67: "TYPE_RIGHT_OF_WAY_NEXT_INTERSECTION",
            68: "TYPE_RIGHT_OF_WAY_BEGIN",
            69: "TYPE_RIGHT_OF_WAY_END",
            70: "TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION",
            71: "TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION_UPSIDE_DOWN",
            72: "TYPE_TOWN_BEGIN",
            73: "TYPE_TOWN_END",
            74: "TYPE_CAR_PARKING",
            75: "TYPE_CAR_PARKING_ZONE_BEGIN",
            76: "TYPE_CAR_PARKING_ZONE_END",
            172: "TYPE_SIDEWALK_HALF_PARKING_LEFT",
            173: "TYPE_SIDEWALK_HALF_PARKING_RIGHT",
            174: "TYPE_SIDEWALK_PARKING_LEFT",
            175: "TYPE_SIDEWALK_PARKING_RIGHT",
            176: "TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_LEFT",
            177: "TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_RIGHT",
            178: "TYPE_SIDEWALK_PERPENDICULAR_PARKING_LEFT",
            179: "TYPE_SIDEWALK_PERPENDICULAR_PARKING_RIGHT",
            77: "TYPE_LIVING_STREET_BEGIN",
            78: "TYPE_LIVING_STREET_END",
            79: "TYPE_TUNNEL",
            80: "TYPE_EMERGENCY_STOPPING_LEFT",
            81: "TYPE_EMERGENCY_STOPPING_RIGHT",
            82: "TYPE_HIGHWAY_BEGIN",
            83: "TYPE_HIGHWAY_END",
            84: "TYPE_EXPRESSWAY_BEGIN",
            85: "TYPE_EXPRESSWAY_END",
            183: "TYPE_NAMED_HIGHWAY_EXIT",
            184: "TYPE_NAMED_EXPRESSWAY_EXIT",
            185: "TYPE_NAMED_ROAD_EXIT",
            86: "TYPE_HIGHWAY_EXIT",
            186: "TYPE_EXPRESSWAY_EXIT",
            187: "TYPE_ONEWAY_STREET",
            189: "TYPE_CROSSING_GUARDS",
            190: "TYPE_DEADEND",
            191: "TYPE_DEADEND_EXCLUDING_DESIGNATED_ACTORS",
            194: "TYPE_FIRST_AID_STATION",
            195: "TYPE_POLICE_STATION",
            196: "TYPE_TELEPHONE",
            198: "TYPE_FILLING_STATION",
            201: "TYPE_HOTEL",
            202: "TYPE_INN",
            203: "TYPE_KIOSK",
            204: "TYPE_TOILET",
            205: "TYPE_CHAPEL",
            206: "TYPE_TOURIST_INFO",
            207: "TYPE_REPAIR_SERVICE",
            208: "TYPE_PEDESTRIAN_UNDERPASS",
            209: "TYPE_PEDESTRIAN_BRIDGE",
            213: "TYPE_CAMPER_PLACE",
            214: "TYPE_ADVISORY_SPEED_LIMIT_BEGIN",
            215: "TYPE_ADVISORY_SPEED_LIMIT_END",
            216: "TYPE_PLACE_NAME",
            217: "TYPE_TOURIST_ATTRACTION",
            218: "TYPE_TOURIST_ROUTE",
            219: "TYPE_TOURIST_AREA",
            220: "TYPE_SHOULDER_NOT_PASSABLE_MOTOR_VEHICLES",
            221: "TYPE_SHOULDER_UNSAFE_TRUCKS_TRACTORS",
            222: "TYPE_TOLL_BEGIN",
            223: "TYPE_TOLL_END",
            224: "TYPE_TOLL_ROAD",
            225: "TYPE_CUSTOMS",
            226: "TYPE_INTERNATIONAL_BORDER_INFO",
            227: "TYPE_STREETLIGHT_RED_BAND",
            228: "TYPE_FEDERAL_HIGHWAY_ROUTE_NUMBER",
            229: "TYPE_HIGHWAY_ROUTE_NUMBER",
            230: "TYPE_HIGHWAY_INTERCHANGE_NUMBER",
            231: "TYPE_EUROPEAN_ROUTE_NUMBER",
            232: "TYPE_FEDERAL_HIGHWAY_DIRECTION_LEFT",
            233: "TYPE_FEDERAL_HIGHWAY_DIRECTION_RIGHT",
            234: "TYPE_PRIMARY_ROAD_DIRECTION_LEFT",
            235: "TYPE_PRIMARY_ROAD_DIRECTION_RIGHT",
            236: "TYPE_SECONDARY_ROAD_DIRECTION_LEFT",
            237: "TYPE_SECONDARY_ROAD_DIRECTION_RIGHT",
            238: "TYPE_DIRECTION_DESIGNATED_ACTORS_LEFT",
            239: "TYPE_DIRECTION_DESIGNATED_ACTORS_RIGHT",
            240: "TYPE_ROUTING_DESIGNATED_ACTORS",
            143: "TYPE_DIRECTION_TO_HIGHWAY_LEFT",
            108: "TYPE_DIRECTION_TO_HIGHWAY_RIGHT",
            127: "TYPE_DIRECTION_TO_LOCAL_DESTINATION_LEFT",
            136: "TYPE_DIRECTION_TO_LOCAL_DESTINATION_RIGHT",
            118: "TYPE_CONSOLIDATED_DIRECTIONS",
            119: "TYPE_STREET_NAME",
            120: "TYPE_DIRECTION_PREANNOUNCEMENT",
            121: "TYPE_DIRECTION_PREANNOUNCEMENT_LANE_CONFIG",
            122: "TYPE_DIRECTION_PREANNOUNCEMENT_HIGHWAY_ENTRIES",
            123: "TYPE_HIGHWAY_ANNOUNCEMENT",
            124: "TYPE_OTHER_ROAD_ANNOUNCEMENT",
            125: "TYPE_HIGHWAY_ANNOUNCEMENT_TRUCK_STOP",
            126: "TYPE_HIGHWAY_PREANNOUNCEMENT_DIRECTIONS",
            88: "TYPE_POLE_EXIT",
            180: "TYPE_HIGHWAY_DISTANCE_BOARD",
            181: "TYPE_DETOUR_LEFT",
            182: "TYPE_DETOUR_RIGHT",
            131: "TYPE_NUMBERED_DETOUR",
            132: "TYPE_DETOUR_BEGIN",
            133: "TYPE_DETOUR_END",
            134: "TYPE_DETOUR_ROUTING_BOARD",
            111: "TYPE_OPTIONAL_DETOUR",
            199: "TYPE_OPTIONAL_DETOUR_ROUTING",
            211: "TYPE_ROUTE_RECOMMENDATION",
            212: "TYPE_ROUTE_RECOMMENDATION_END",
            192: "TYPE_ANNOUNCE_LANE_TRANSITION_LEFT",
            193: "TYPE_ANNOUNCE_LANE_TRANSITION_RIGHT",
            90: "TYPE_ANNOUNCE_RIGHT_LANE_END",
            89: "TYPE_ANNOUNCE_LEFT_LANE_END",
            115: "TYPE_ANNOUNCE_RIGHT_LANE_BEGIN",
            116: "TYPE_ANNOUNCE_LEFT_LANE_BEGIN",
            117: "TYPE_ANNOUNCE_LANE_CONSOLIDATION",
            142: "TYPE_DETOUR_CITY_BLOCK",
            141: "TYPE_GATE",
            91: "TYPE_POLE_WARNING",
            140: "TYPE_TRAFFIC_CONE",
            139: "TYPE_MOBILE_LANE_CLOSURE",
            114: "TYPE_REFLECTOR_POST",
            113: "TYPE_DIRECTIONAL_BOARD_WARNING",
            104: "TYPE_GUIDING_PLATE",
            105: "TYPE_GUIDING_PLATE_WEDGES",
            99: "TYPE_PARKING_HAZARD",
            92: "TYPE_TRAFFIC_LIGHT_GREEN_ARROW",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "TYPE_UNKNOWN": 0,
            "TYPE_OTHER": 1,
            "TYPE_DANGER_SPOT": 2,
            "TYPE_ZEBRA_CROSSING": 87,
            "TYPE_FLIGHT": 110,
            "TYPE_CATTLE": 200,
            "TYPE_HORSE_RIDERS": 197,
            "TYPE_AMPHIBIANS": 188,
            "TYPE_FALLING_ROCKS": 96,
            "TYPE_SNOW_OR_ICE": 94,
            "TYPE_LOOSE_GRAVEL": 97,
            "TYPE_WATERSIDE": 102,
            "TYPE_CLEARANCE": 210,
            "TYPE_MOVABLE_BRIDGE": 101,
            "TYPE_RIGHT_BEFORE_LEFT_NEXT_INTERSECTION": 3,
            "TYPE_TURN_LEFT": 4,
            "TYPE_TURN_RIGHT": 5,
            "TYPE_DOUBLE_TURN_LEFT": 6,
            "TYPE_DOUBLE_TURN_RIGHT": 7,
            "TYPE_HILL_DOWNWARDS": 8,
            "TYPE_HILL_UPWARDS": 9,
            "TYPE_UNEVEN_ROAD": 93,
            "TYPE_ROAD_SLIPPERY_WET_OR_DIRTY": 95,
            "TYPE_SIDE_WINDS": 98,
            "TYPE_ROAD_NARROWING": 10,
            "TYPE_ROAD_NARROWING_RIGHT": 12,
            "TYPE_ROAD_NARROWING_LEFT": 11,
            "TYPE_ROAD_WORKS": 13,
            "TYPE_TRAFFIC_QUEUES": 100,
            "TYPE_TWO_WAY_TRAFFIC": 14,
            "TYPE_ATTENTION_TRAFFIC_LIGHT": 15,
            "TYPE_PEDESTRIANS": 103,
            "TYPE_CHILDREN_CROSSING": 106,
            "TYPE_CYCLE_ROUTE": 107,
            "TYPE_DEER_CROSSING": 109,
            "TYPE_UNGATED_LEVEL_CROSSING": 144,
            "TYPE_LEVEL_CROSSING_MARKER": 112,
            "TYPE_RAILWAY_TRAFFIC_PRIORITY": 135,
            "TYPE_GIVE_WAY": 16,
            "TYPE_STOP": 17,
            "TYPE_PRIORITY_TO_OPPOSITE_DIRECTION": 18,
            "TYPE_PRIORITY_TO_OPPOSITE_DIRECTION_UPSIDE_DOWN": 19,
            "TYPE_PRESCRIBED_LEFT_TURN": 20,
            "TYPE_PRESCRIBED_RIGHT_TURN": 21,
            "TYPE_PRESCRIBED_STRAIGHT": 22,
            "TYPE_PRESCRIBED_RIGHT_WAY": 24,
            "TYPE_PRESCRIBED_LEFT_WAY": 23,
            "TYPE_PRESCRIBED_RIGHT_TURN_AND_STRAIGHT": 26,
            "TYPE_PRESCRIBED_LEFT_TURN_AND_STRAIGHT": 25,
            "TYPE_PRESCRIBED_LEFT_TURN_AND_RIGHT_TURN": 27,
            "TYPE_PRESCRIBED_LEFT_TURN_RIGHT_TURN_AND_STRAIGHT": 28,
            "TYPE_ROUNDABOUT": 29,
            "TYPE_ONEWAY_LEFT": 30,
            "TYPE_ONEWAY_RIGHT": 31,
            "TYPE_PASS_LEFT": 32,
            "TYPE_PASS_RIGHT": 33,
            "TYPE_SIDE_LANE_OPEN_FOR_TRAFFIC": 128,
            "TYPE_SIDE_LANE_CLOSED_FOR_TRAFFIC": 129,
            "TYPE_SIDE_LANE_CLOSING_FOR_TRAFFIC": 130,
            "TYPE_BUS_STOP": 137,
            "TYPE_TAXI_STAND": 138,
            "TYPE_BICYCLES_ONLY": 145,
            "TYPE_HORSE_RIDERS_ONLY": 146,
            "TYPE_PEDESTRIANS_ONLY": 147,
            "TYPE_BICYCLES_PEDESTRIANS_SHARED_ONLY": 148,
            "TYPE_BICYCLES_PEDESTRIANS_SEPARATED_LEFT_ONLY": 149,
            "TYPE_BICYCLES_PEDESTRIANS_SEPARATED_RIGHT_ONLY": 150,
            "TYPE_PEDESTRIAN_ZONE_BEGIN": 151,
            "TYPE_PEDESTRIAN_ZONE_END": 152,
            "TYPE_BICYCLE_ROAD_BEGIN": 153,
            "TYPE_BICYCLE_ROAD_END": 154,
            "TYPE_BUS_LANE": 34,
            "TYPE_BUS_LANE_BEGIN": 35,
            "TYPE_BUS_LANE_END": 36,
            "TYPE_ALL_PROHIBITED": 37,
            "TYPE_MOTORIZED_MULTITRACK_PROHIBITED": 38,
            "TYPE_TRUCKS_PROHIBITED": 39,
            "TYPE_BICYCLES_PROHIBITED": 40,
            "TYPE_MOTORCYCLES_PROHIBITED": 41,
            "TYPE_MOPEDS_PROHIBITED": 155,
            "TYPE_HORSE_RIDERS_PROHIBITED": 156,
            "TYPE_HORSE_CARRIAGES_PROHIBITED": 157,
            "TYPE_CATTLE_PROHIBITED": 158,
            "TYPE_BUSES_PROHIBITED": 159,
            "TYPE_CARS_PROHIBITED": 160,
            "TYPE_CARS_TRAILERS_PROHIBITED": 161,
            "TYPE_TRUCKS_TRAILERS_PROHIBITED": 162,
            "TYPE_TRACTORS_PROHIBITED": 163,
            "TYPE_PEDESTRIANS_PROHIBITED": 42,
            "TYPE_MOTOR_VEHICLES_PROHIBITED": 43,
            "TYPE_HAZARDOUS_GOODS_VEHICLES_PROHIBITED": 164,
            "TYPE_OVER_WEIGHT_VEHICLES_PROHIBITED": 165,
            "TYPE_VEHICLES_AXLE_OVER_WEIGHT_PROHIBITED": 166,
            "TYPE_VEHICLES_EXCESS_WIDTH_PROHIBITED": 167,
            "TYPE_VEHICLES_EXCESS_HEIGHT_PROHIBITED": 168,
            "TYPE_VEHICLES_EXCESS_LENGTH_PROHIBITED": 169,
            "TYPE_DO_NOT_ENTER": 44,
            "TYPE_SNOW_CHAINS_REQUIRED": 170,
            "TYPE_WATER_POLLUTANT_VEHICLES_PROHIBITED": 171,
            "TYPE_ENVIRONMENTAL_ZONE_BEGIN": 45,
            "TYPE_ENVIRONMENTAL_ZONE_END": 46,
            "TYPE_NO_U_TURN_LEFT": 47,
            "TYPE_NO_U_TURN_RIGHT": 48,
            "TYPE_PRESCRIBED_U_TURN_LEFT": 49,
            "TYPE_PRESCRIBED_U_TURN_RIGHT": 50,
            "TYPE_MINIMUM_DISTANCE_FOR_TRUCKS": 51,
            "TYPE_SPEED_LIMIT_BEGIN": 52,
            "TYPE_SPEED_LIMIT_ZONE_BEGIN": 53,
            "TYPE_SPEED_LIMIT_ZONE_END": 54,
            "TYPE_MINIMUM_SPEED_BEGIN": 55,
            "TYPE_OVERTAKING_BAN_BEGIN": 56,
            "TYPE_OVERTAKING_BAN_FOR_TRUCKS_BEGIN": 57,
            "TYPE_SPEED_LIMIT_END": 58,
            "TYPE_MINIMUM_SPEED_END": 59,
            "TYPE_OVERTAKING_BAN_END": 60,
            "TYPE_OVERTAKING_BAN_FOR_TRUCKS_END": 61,
            "TYPE_ALL_RESTRICTIONS_END": 62,
            "TYPE_NO_STOPPING": 63,
            "TYPE_NO_PARKING": 64,
            "TYPE_NO_PARKING_ZONE_BEGIN": 65,
            "TYPE_NO_PARKING_ZONE_END": 66,
            "TYPE_RIGHT_OF_WAY_NEXT_INTERSECTION": 67,
            "TYPE_RIGHT_OF_WAY_BEGIN": 68,
            "TYPE_RIGHT_OF_WAY_END": 69,
            "TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION": 70,
            "TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION_UPSIDE_DOWN": 71,
            "TYPE_TOWN_BEGIN": 72,
            "TYPE_TOWN_END": 73,
            "TYPE_CAR_PARKING": 74,
            "TYPE_CAR_PARKING_ZONE_BEGIN": 75,
            "TYPE_CAR_PARKING_ZONE_END": 76,
            "TYPE_SIDEWALK_HALF_PARKING_LEFT": 172,
            "TYPE_SIDEWALK_HALF_PARKING_RIGHT": 173,
            "TYPE_SIDEWALK_PARKING_LEFT": 174,
            "TYPE_SIDEWALK_PARKING_RIGHT": 175,
            "TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_LEFT": 176,
            "TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_RIGHT": 177,
            "TYPE_SIDEWALK_PERPENDICULAR_PARKING_LEFT": 178,
            "TYPE_SIDEWALK_PERPENDICULAR_PARKING_RIGHT": 179,
            "TYPE_LIVING_STREET_BEGIN": 77,
            "TYPE_LIVING_STREET_END": 78,
            "TYPE_TUNNEL": 79,
            "TYPE_EMERGENCY_STOPPING_LEFT": 80,
            "TYPE_EMERGENCY_STOPPING_RIGHT": 81,
            "TYPE_HIGHWAY_BEGIN": 82,
            "TYPE_HIGHWAY_END": 83,
            "TYPE_EXPRESSWAY_BEGIN": 84,
            "TYPE_EXPRESSWAY_END": 85,
            "TYPE_NAMED_HIGHWAY_EXIT": 183,
            "TYPE_NAMED_EXPRESSWAY_EXIT": 184,
            "TYPE_NAMED_ROAD_EXIT": 185,
            "TYPE_HIGHWAY_EXIT": 86,
            "TYPE_EXPRESSWAY_EXIT": 186,
            "TYPE_ONEWAY_STREET": 187,
            "TYPE_CROSSING_GUARDS": 189,
            "TYPE_DEADEND": 190,
            "TYPE_DEADEND_EXCLUDING_DESIGNATED_ACTORS": 191,
            "TYPE_FIRST_AID_STATION": 194,
            "TYPE_POLICE_STATION": 195,
            "TYPE_TELEPHONE": 196,
            "TYPE_FILLING_STATION": 198,
            "TYPE_HOTEL": 201,
            "TYPE_INN": 202,
            "TYPE_KIOSK": 203,
            "TYPE_TOILET": 204,
            "TYPE_CHAPEL": 205,
            "TYPE_TOURIST_INFO": 206,
            "TYPE_REPAIR_SERVICE": 207,
            "TYPE_PEDESTRIAN_UNDERPASS": 208,
            "TYPE_PEDESTRIAN_BRIDGE": 209,
            "TYPE_CAMPER_PLACE": 213,
            "TYPE_ADVISORY_SPEED_LIMIT_BEGIN": 214,
            "TYPE_ADVISORY_SPEED_LIMIT_END": 215,
            "TYPE_PLACE_NAME": 216,
            "TYPE_TOURIST_ATTRACTION": 217,
            "TYPE_TOURIST_ROUTE": 218,
            "TYPE_TOURIST_AREA": 219,
            "TYPE_SHOULDER_NOT_PASSABLE_MOTOR_VEHICLES": 220,
            "TYPE_SHOULDER_UNSAFE_TRUCKS_TRACTORS": 221,
            "TYPE_TOLL_BEGIN": 222,
            "TYPE_TOLL_END": 223,
            "TYPE_TOLL_ROAD": 224,
            "TYPE_CUSTOMS": 225,
            "TYPE_INTERNATIONAL_BORDER_INFO": 226,
            "TYPE_STREETLIGHT_RED_BAND": 227,
            "TYPE_FEDERAL_HIGHWAY_ROUTE_NUMBER": 228,
            "TYPE_HIGHWAY_ROUTE_NUMBER": 229,
            "TYPE_HIGHWAY_INTERCHANGE_NUMBER": 230,
            "TYPE_EUROPEAN_ROUTE_NUMBER": 231,
            "TYPE_FEDERAL_HIGHWAY_DIRECTION_LEFT": 232,
            "TYPE_FEDERAL_HIGHWAY_DIRECTION_RIGHT": 233,
            "TYPE_PRIMARY_ROAD_DIRECTION_LEFT": 234,
            "TYPE_PRIMARY_ROAD_DIRECTION_RIGHT": 235,
            "TYPE_SECONDARY_ROAD_DIRECTION_LEFT": 236,
            "TYPE_SECONDARY_ROAD_DIRECTION_RIGHT": 237,
            "TYPE_DIRECTION_DESIGNATED_ACTORS_LEFT": 238,
            "TYPE_DIRECTION_DESIGNATED_ACTORS_RIGHT": 239,
            "TYPE_ROUTING_DESIGNATED_ACTORS": 240,
            "TYPE_DIRECTION_TO_HIGHWAY_LEFT": 143,
            "TYPE_DIRECTION_TO_HIGHWAY_RIGHT": 108,
            "TYPE_DIRECTION_TO_LOCAL_DESTINATION_LEFT": 127,
            "TYPE_DIRECTION_TO_LOCAL_DESTINATION_RIGHT": 136,
            "TYPE_CONSOLIDATED_DIRECTIONS": 118,
            "TYPE_STREET_NAME": 119,
            "TYPE_DIRECTION_PREANNOUNCEMENT": 120,
            "TYPE_DIRECTION_PREANNOUNCEMENT_LANE_CONFIG": 121,
            "TYPE_DIRECTION_PREANNOUNCEMENT_HIGHWAY_ENTRIES": 122,
            "TYPE_HIGHWAY_ANNOUNCEMENT": 123,
            "TYPE_OTHER_ROAD_ANNOUNCEMENT": 124,
            "TYPE_HIGHWAY_ANNOUNCEMENT_TRUCK_STOP": 125,
            "TYPE_HIGHWAY_PREANNOUNCEMENT_DIRECTIONS": 126,
            "TYPE_POLE_EXIT": 88,
            "TYPE_HIGHWAY_DISTANCE_BOARD": 180,
            "TYPE_DETOUR_LEFT": 181,
            "TYPE_DETOUR_RIGHT": 182,
            "TYPE_NUMBERED_DETOUR": 131,
            "TYPE_DETOUR_BEGIN": 132,
            "TYPE_DETOUR_END": 133,
            "TYPE_DETOUR_ROUTING_BOARD": 134,
            "TYPE_OPTIONAL_DETOUR": 111,
            "TYPE_OPTIONAL_DETOUR_ROUTING": 199,
            "TYPE_ROUTE_RECOMMENDATION": 211,
            "TYPE_ROUTE_RECOMMENDATION_END": 212,
            "TYPE_ANNOUNCE_LANE_TRANSITION_LEFT": 192,
            "TYPE_ANNOUNCE_LANE_TRANSITION_RIGHT": 193,
            "TYPE_ANNOUNCE_RIGHT_LANE_END": 90,
            "TYPE_ANNOUNCE_LEFT_LANE_END": 89,
            "TYPE_ANNOUNCE_RIGHT_LANE_BEGIN": 115,
            "TYPE_ANNOUNCE_LEFT_LANE_BEGIN": 116,
            "TYPE_ANNOUNCE_LANE_CONSOLIDATION": 117,
            "TYPE_DETOUR_CITY_BLOCK": 142,
            "TYPE_GATE": 141,
            "TYPE_POLE_WARNING": 91,
            "TYPE_TRAFFIC_CONE": 140,
            "TYPE_MOBILE_LANE_CLOSURE": 139,
            "TYPE_REFLECTOR_POST": 114,
            "TYPE_DIRECTIONAL_BOARD_WARNING": 113,
            "TYPE_GUIDING_PLATE": 104,
            "TYPE_GUIDING_PLATE_WEDGES": 105,
            "TYPE_PARKING_HAZARD": 99,
            "TYPE_TRAFFIC_LIGHT_GREEN_ARROW": 92,
        }


class TrafficSignSupplementarySignClassificationActor(betterproto2.Enum):
    """
    Definition of the traffic actors the supplementary sign makes
    reference to. E.g. bikes, trucks, cars, etc.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_TRAFFICSIGN_PROTO_DESCRIPTOR.enum_types_by_name[
            "TrafficSign.SupplementarySign.Classification.Actor"
        ]

    UNKNOWN = 0
    """
    An unknown actor
    """

    OTHER = 1
    """
    Other actor (specified but known)
    """

    NO_ACTOR = 2
    """
    The actor is not specified
    """

    AGRICULTURAL_VEHICLES = 3
    """
    Agricultural vehicles
    """

    BICYCLES = 4
    """
    Bicycles
    """

    BUSES = 5
    """
    Buses
    """

    CAMPERS = 6
    """
    Campers
    """

    CARAVANS = 7
    """
    Caravans
    """

    CARS = 8
    """
    Cars
    """

    CARS_WITH_CARAVANS = 9
    """
    Cars with caravans
    """

    CARS_WITH_TRAILERS = 10
    """
    Cars with trailers
    """

    CATTLE = 11
    """
    Cattles
    """

    CHILDREN = 12
    """
    Children
    """

    CONSTRUCTION_VEHICLES = 13
    """
    Construction vehicles
    """

    DELIVERY_VEHICLES = 14
    """
    Delivery vehicles
    """

    DISABLED_PERSONS = 15
    """
    Disabled persons
    """

    EBIKES = 16
    """
    E-bikes
    """

    ELECTRIC_VEHICLES = 17
    """
    Electric vehicles
    """

    EMERGENCY_VEHICLES = 18
    """
    Emergency vehicles
    """

    FERRY_USERS = 19
    """
    Ferry users
    """

    FORESTRY_VEHICLES = 20
    """
    Forestry vehicles
    """

    HAZARDOUS_GOODS_VEHICLES = 21
    """
    Hazardous goods vehicles
    """

    HORSE_CARRIAGES = 22
    """
    Horse carriages
    """

    HORSE_RIDERS = 23
    """
    Horse riders
    """

    INLINE_SKATERS = 24
    """
    Inline skaters
    """

    MEDICAL_VEHICLES = 25
    """
    Medical vehicles
    """

    MILITARY_VEHICLES = 26
    """
    Military vehicles
    """

    MOPEDS = 27
    """
    Mopeds
    """

    MOTORCYCLES = 28
    """
    Motorcycles
    """

    MOTORIZED_MULTITRACK_VEHICLES = 29
    """
    Motorized multi-track vehicles
    """

    OPERATIONAL_AND_UTILITY_VEHICLES = 30
    """
    Operational and utility vehicles
    """

    PEDESTRIANS = 31
    """
    Pedestrians
    """

    PUBLIC_TRANSPORT_VEHICLES = 32
    """
    Public transport vehicles
    """

    RAILROAD_TRAFFIC = 33
    """
    Railroad traffic
    """

    RESIDENTS = 34
    """
    Residents

    \\note In the German StVO, typically denoted with the text
    "Anlieger" or "Bewohner"
    """

    SLURRY_TRANSPORT = 35
    """
    Slurry transport
    """

    TAXIS = 36
    """
    Taxis
    """

    TRACTORS = 37
    """
    Tractors

    \\note In the German StVO, tractors are defined as
    motorized vehicles that are not allowed to, or cannot,
    drive faster than 25 km/h
    """

    TRAILERS = 38
    """
    Trailers
    """

    TRAMS = 39
    """
    Trams
    """

    TRUCKS = 40
    """
    Trucks

    \\note
    In the German StVO, trucks are defined as
    motorized vehicles that are heavier than 3.5 t
    """

    TRUCKS_WITH_SEMITRAILERS = 41
    """
    Trucks with semi-trailers
    """

    TRUCKS_WITH_TRAILERS = 42
    """
    Trucks with trailers
    """

    VEHICLES_WITH_GREEN_BADGES = 43
    """
    Vehicles with green badges
    """

    VEHICLES_WITH_RED_BADGES = 44
    """
    Vehicles with red badges
    """

    VEHICLES_WITH_YELLOW_BADGES = 45
    """
    Vehicles with yellow badges
    """

    WATER_POLLUTANT_VEHICLES = 46
    """
    Water pollutant vehicles
    """

    WINTER_SPORTSPEOPLE = 47
    """
    Winter sportspeople
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "ACTOR_UNKNOWN",
            1: "ACTOR_OTHER",
            2: "ACTOR_NO_ACTOR",
            3: "ACTOR_AGRICULTURAL_VEHICLES",
            4: "ACTOR_BICYCLES",
            5: "ACTOR_BUSES",
            6: "ACTOR_CAMPERS",
            7: "ACTOR_CARAVANS",
            8: "ACTOR_CARS",
            9: "ACTOR_CARS_WITH_CARAVANS",
            10: "ACTOR_CARS_WITH_TRAILERS",
            11: "ACTOR_CATTLE",
            12: "ACTOR_CHILDREN",
            13: "ACTOR_CONSTRUCTION_VEHICLES",
            14: "ACTOR_DELIVERY_VEHICLES",
            15: "ACTOR_DISABLED_PERSONS",
            16: "ACTOR_EBIKES",
            17: "ACTOR_ELECTRIC_VEHICLES",
            18: "ACTOR_EMERGENCY_VEHICLES",
            19: "ACTOR_FERRY_USERS",
            20: "ACTOR_FORESTRY_VEHICLES",
            21: "ACTOR_HAZARDOUS_GOODS_VEHICLES",
            22: "ACTOR_HORSE_CARRIAGES",
            23: "ACTOR_HORSE_RIDERS",
            24: "ACTOR_INLINE_SKATERS",
            25: "ACTOR_MEDICAL_VEHICLES",
            26: "ACTOR_MILITARY_VEHICLES",
            27: "ACTOR_MOPEDS",
            28: "ACTOR_MOTORCYCLES",
            29: "ACTOR_MOTORIZED_MULTITRACK_VEHICLES",
            30: "ACTOR_OPERATIONAL_AND_UTILITY_VEHICLES",
            31: "ACTOR_PEDESTRIANS",
            32: "ACTOR_PUBLIC_TRANSPORT_VEHICLES",
            33: "ACTOR_RAILROAD_TRAFFIC",
            34: "ACTOR_RESIDENTS",
            35: "ACTOR_SLURRY_TRANSPORT",
            36: "ACTOR_TAXIS",
            37: "ACTOR_TRACTORS",
            38: "ACTOR_TRAILERS",
            39: "ACTOR_TRAMS",
            40: "ACTOR_TRUCKS",
            41: "ACTOR_TRUCKS_WITH_SEMITRAILERS",
            42: "ACTOR_TRUCKS_WITH_TRAILERS",
            43: "ACTOR_VEHICLES_WITH_GREEN_BADGES",
            44: "ACTOR_VEHICLES_WITH_RED_BADGES",
            45: "ACTOR_VEHICLES_WITH_YELLOW_BADGES",
            46: "ACTOR_WATER_POLLUTANT_VEHICLES",
            47: "ACTOR_WINTER_SPORTSPEOPLE",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "ACTOR_UNKNOWN": 0,
            "ACTOR_OTHER": 1,
            "ACTOR_NO_ACTOR": 2,
            "ACTOR_AGRICULTURAL_VEHICLES": 3,
            "ACTOR_BICYCLES": 4,
            "ACTOR_BUSES": 5,
            "ACTOR_CAMPERS": 6,
            "ACTOR_CARAVANS": 7,
            "ACTOR_CARS": 8,
            "ACTOR_CARS_WITH_CARAVANS": 9,
            "ACTOR_CARS_WITH_TRAILERS": 10,
            "ACTOR_CATTLE": 11,
            "ACTOR_CHILDREN": 12,
            "ACTOR_CONSTRUCTION_VEHICLES": 13,
            "ACTOR_DELIVERY_VEHICLES": 14,
            "ACTOR_DISABLED_PERSONS": 15,
            "ACTOR_EBIKES": 16,
            "ACTOR_ELECTRIC_VEHICLES": 17,
            "ACTOR_EMERGENCY_VEHICLES": 18,
            "ACTOR_FERRY_USERS": 19,
            "ACTOR_FORESTRY_VEHICLES": 20,
            "ACTOR_HAZARDOUS_GOODS_VEHICLES": 21,
            "ACTOR_HORSE_CARRIAGES": 22,
            "ACTOR_HORSE_RIDERS": 23,
            "ACTOR_INLINE_SKATERS": 24,
            "ACTOR_MEDICAL_VEHICLES": 25,
            "ACTOR_MILITARY_VEHICLES": 26,
            "ACTOR_MOPEDS": 27,
            "ACTOR_MOTORCYCLES": 28,
            "ACTOR_MOTORIZED_MULTITRACK_VEHICLES": 29,
            "ACTOR_OPERATIONAL_AND_UTILITY_VEHICLES": 30,
            "ACTOR_PEDESTRIANS": 31,
            "ACTOR_PUBLIC_TRANSPORT_VEHICLES": 32,
            "ACTOR_RAILROAD_TRAFFIC": 33,
            "ACTOR_RESIDENTS": 34,
            "ACTOR_SLURRY_TRANSPORT": 35,
            "ACTOR_TAXIS": 36,
            "ACTOR_TRACTORS": 37,
            "ACTOR_TRAILERS": 38,
            "ACTOR_TRAMS": 39,
            "ACTOR_TRUCKS": 40,
            "ACTOR_TRUCKS_WITH_SEMITRAILERS": 41,
            "ACTOR_TRUCKS_WITH_TRAILERS": 42,
            "ACTOR_VEHICLES_WITH_GREEN_BADGES": 43,
            "ACTOR_VEHICLES_WITH_RED_BADGES": 44,
            "ACTOR_VEHICLES_WITH_YELLOW_BADGES": 45,
            "ACTOR_WATER_POLLUTANT_VEHICLES": 46,
            "ACTOR_WINTER_SPORTSPEOPLE": 47,
        }


class TrafficSignSupplementarySignClassificationArrowDirection(betterproto2.Enum):
    """
    The direction to which the arrow points to
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_TRAFFICSIGN_PROTO_DESCRIPTOR.enum_types_by_name[
            "TrafficSign.SupplementarySign.Classification.Arrow.Direction"
        ]

    UNKNOWN = 0
    """
    Direction of sign is unknown (must not be used in ground
    truth).
    """

    OTHER = 1
    """
    Other (specified but known) direction.
    """

    NO_DIRECTION = 2
    """
    No arrow direction is specified.
    """

    DIRECT_0_DEG = 3
    """
    An arrow pointing straight ahead in the direction of
    driving.
    """

    DIRECT_45_DEG_RIGHT = 4
    """
    A straight arrow pointing 45 degrees to the right in the
    direction of driving.
    """

    DIRECT_45_DEG_LEFT = 5
    """
    A straight arrow pointing 45 degrees to the left in the
    direction of driving.
    """

    DIRECT_90_DEG_RIGHT = 6
    """
    A straight arrow pointing 90 degrees to the right in the
    direction of driving.
    """

    DIRECT_90_DEG_LEFT = 7
    """
    A straight arrow pointing 90 degrees to the left in the
    direction of driving.
    """

    DIRECT_135_DEG_RIGHT = 8
    """
    A straight arrow pointing 135 degrees to the right in the
    direction of driving.
    """

    DIRECT_135_DEG_LEFT = 9
    """
    A straight arrow pointing 135 degrees to the left in the
    direction of driving.
    """

    DIRECT_180_DEG = 10
    """
    A straight arrow pointing opposite to the direction of
    driving.
    """

    TURN_45_DEG_RIGHT = 11
    """
    A curved arrow pointing 45 degrees to the right in the
    direction of driving.
    """

    TURN_45_DEG_LEFT = 12
    """
    A curved arrow pointing 45 degrees to the left in the
    direction of driving.
    """

    TURN_90_DEG_RIGHT = 13
    """
    A curved arrow pointing 90 degrees to the right in the
    direction of driving.
    """

    TURN_90_DEG_LEFT = 14
    """
    A curved arrow pointing 90 degrees to the left in the
    direction of driving.
    """

    TURN_135_DEG_RIGHT = 15
    """
    A curved arrow pointing 135 degrees to the right in the
    direction of driving.
    """

    TURN_135_DEG_LEFT = 16
    """
    A curved arrow pointing 135 degrees to the left in the
    direction of driving.
    """

    TURN_180_DEG_RIGHT = 17
    """
    A u-turn arrow towards the right.
    """

    TURN_180_DEG_LEFT = 18
    """
    A u-turn arrow towards the left.
    """

    CIRCLE_0_DEG = 19
    """
    An arrow that includes a fraction of a circle and points
    forward in the direction of driving. Used typically for
    roundabouts.
    """

    CIRCLE_45_DEG_RIGHT = 20
    """
    An arrow that includes a fraction of a circle and points
    in 45 degrees to the right in the direction of driving.
    Used typically for roundabouts.
    """

    CIRCLE_45_DEG_LEFT = 21
    """
    An arrow that includes a fraction of a circle and points
    in 45 degrees to the left in the direction of driving.
    Used typically for roundabouts.
    """

    CIRCLE_90_DEG_RIGHT = 22
    """
    An arrow that includes a fraction of a circle and points
    in 90 degrees to the right in the direction of driving.
    Used typically for roundabouts.
    """

    CIRCLE_90_DEG_LEFT = 23
    """
    An arrow that includes a fraction of a circle and points
    in 90 degrees to the left in the direction of driving.
    Used typically for roundabouts.
    """

    CIRCLE_135_DEG_RIGHT = 24
    """
    An arrow that includes a fraction of a circle and points
    in 135 degrees to the right in the direction of driving.
    Used typically for roundabouts.
    """

    CIRCLE_135_DEG_LEFT = 25
    """
    An arrow that includes a fraction of a circle and points
    in 135 degrees to the left in the direction of driving.
    Used typically for roundabouts.
    """

    CIRCLE_180_DEG = 26
    """
    An arrow that includes a fraction of a circle and points
    in the opposite to the direction of driving. Can be used
    in detours in roundabouts.
    """

    KEEP_LEFT_TO_TURN_0_DEG = 27
    """
    An arrow that includes a fraction of a square and points
    forward in direction of driving. Can be used for detours
    where you have to use a separate left lane to drive
    ahead.
    """

    KEEP_RIGHT_TO_TURN_0_DEG = 28
    """
    An arrow that includes a fraction of a square and points
    forward in direction of driving. Can be used for detours
    where you have to use a separate right lane to drive
    ahead.
    """

    KEEP_LEFT_TO_TURN_90_DEG_RIGHT = 29
    """
    An arrow that includes a fraction of a square and points
    in 90 degrees to the right in direction of driving. Can
    be used for detours where you have to use a separate left
    lane to turn right.
    """

    KEEP_RIGHT_TO_TURN_90_DEG_LEFT = 30
    """
    An arrow that includes a fraction of a square and points
    in 90 degrees to the right in direction of driving. Can
    be used for detours where you have to use a separate
    right lane to turn left.
    """

    KEEP_LEFT_DRIVE_BACK_TO_TURN_90_DEG_RIGHT = 31
    """
    An arrow that includes a fraction of a square and points
    in 90 degrees to the right in direction of driving. Can
    be used for detours where you have to use a separate left
    lane and you have to drive back to turn right.
    """

    KEEP_RIGHT_DRIVE_BACK_TO_TURN_90_DEG_LEFT = 32
    """
    An arrow that includes a fraction of a square and points
    in 90 degrees to the right in direction of driving. Can
    be used for detours where you have to use a separate
    right lane and you have to drive back to turn left.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "DIRECTION_UNKNOWN",
            1: "DIRECTION_OTHER",
            2: "DIRECTION_NO_DIRECTION",
            3: "DIRECTION_DIRECT_0_DEG",
            4: "DIRECTION_DIRECT_45_DEG_RIGHT",
            5: "DIRECTION_DIRECT_45_DEG_LEFT",
            6: "DIRECTION_DIRECT_90_DEG_RIGHT",
            7: "DIRECTION_DIRECT_90_DEG_LEFT",
            8: "DIRECTION_DIRECT_135_DEG_RIGHT",
            9: "DIRECTION_DIRECT_135_DEG_LEFT",
            10: "DIRECTION_DIRECT_180_DEG",
            11: "DIRECTION_TURN_45_DEG_RIGHT",
            12: "DIRECTION_TURN_45_DEG_LEFT",
            13: "DIRECTION_TURN_90_DEG_RIGHT",
            14: "DIRECTION_TURN_90_DEG_LEFT",
            15: "DIRECTION_TURN_135_DEG_RIGHT",
            16: "DIRECTION_TURN_135_DEG_LEFT",
            17: "DIRECTION_TURN_180_DEG_RIGHT",
            18: "DIRECTION_TURN_180_DEG_LEFT",
            19: "DIRECTION_CIRCLE_0_DEG",
            20: "DIRECTION_CIRCLE_45_DEG_RIGHT",
            21: "DIRECTION_CIRCLE_45_DEG_LEFT",
            22: "DIRECTION_CIRCLE_90_DEG_RIGHT",
            23: "DIRECTION_CIRCLE_90_DEG_LEFT",
            24: "DIRECTION_CIRCLE_135_DEG_RIGHT",
            25: "DIRECTION_CIRCLE_135_DEG_LEFT",
            26: "DIRECTION_CIRCLE_180_DEG",
            27: "DIRECTION_KEEP_LEFT_TO_TURN_0_DEG",
            28: "DIRECTION_KEEP_RIGHT_TO_TURN_0_DEG",
            29: "DIRECTION_KEEP_LEFT_TO_TURN_90_DEG_RIGHT",
            30: "DIRECTION_KEEP_RIGHT_TO_TURN_90_DEG_LEFT",
            31: "DIRECTION_KEEP_LEFT_DRIVE_BACK_TO_TURN_90_DEG_RIGHT",
            32: "DIRECTION_KEEP_RIGHT_DRIVE_BACK_TO_TURN_90_DEG_LEFT",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "DIRECTION_UNKNOWN": 0,
            "DIRECTION_OTHER": 1,
            "DIRECTION_NO_DIRECTION": 2,
            "DIRECTION_DIRECT_0_DEG": 3,
            "DIRECTION_DIRECT_45_DEG_RIGHT": 4,
            "DIRECTION_DIRECT_45_DEG_LEFT": 5,
            "DIRECTION_DIRECT_90_DEG_RIGHT": 6,
            "DIRECTION_DIRECT_90_DEG_LEFT": 7,
            "DIRECTION_DIRECT_135_DEG_RIGHT": 8,
            "DIRECTION_DIRECT_135_DEG_LEFT": 9,
            "DIRECTION_DIRECT_180_DEG": 10,
            "DIRECTION_TURN_45_DEG_RIGHT": 11,
            "DIRECTION_TURN_45_DEG_LEFT": 12,
            "DIRECTION_TURN_90_DEG_RIGHT": 13,
            "DIRECTION_TURN_90_DEG_LEFT": 14,
            "DIRECTION_TURN_135_DEG_RIGHT": 15,
            "DIRECTION_TURN_135_DEG_LEFT": 16,
            "DIRECTION_TURN_180_DEG_RIGHT": 17,
            "DIRECTION_TURN_180_DEG_LEFT": 18,
            "DIRECTION_CIRCLE_0_DEG": 19,
            "DIRECTION_CIRCLE_45_DEG_RIGHT": 20,
            "DIRECTION_CIRCLE_45_DEG_LEFT": 21,
            "DIRECTION_CIRCLE_90_DEG_RIGHT": 22,
            "DIRECTION_CIRCLE_90_DEG_LEFT": 23,
            "DIRECTION_CIRCLE_135_DEG_RIGHT": 24,
            "DIRECTION_CIRCLE_135_DEG_LEFT": 25,
            "DIRECTION_CIRCLE_180_DEG": 26,
            "DIRECTION_KEEP_LEFT_TO_TURN_0_DEG": 27,
            "DIRECTION_KEEP_RIGHT_TO_TURN_0_DEG": 28,
            "DIRECTION_KEEP_LEFT_TO_TURN_90_DEG_RIGHT": 29,
            "DIRECTION_KEEP_RIGHT_TO_TURN_90_DEG_LEFT": 30,
            "DIRECTION_KEEP_LEFT_DRIVE_BACK_TO_TURN_90_DEG_RIGHT": 31,
            "DIRECTION_KEEP_RIGHT_DRIVE_BACK_TO_TURN_90_DEG_LEFT": 32,
        }


class TrafficSignSupplementarySignClassificationType(betterproto2.Enum):
    """
    Definition of supplementary sign types.

    For general supplementary signs use \\c #TYPE_TEXT.
    Supplementary signs with general space restrictions use \\c
    #TYPE_SPACE. Supplementary signs with general time restrictions
    use \\c #TYPE_TIME. Supplementary signs with displayed arrow
    directions use \\c #TYPE_ARROW. Supplementary signs constraint to
    one type of actors use \\c #TYPE_CONSTRAINED_TO. Supplementary
    signs that will exclude one type of actors use \\c #TYPE_EXCEPT.
    If supplementary signs combine contraints, restrictions, or plain
    text, \\c Type is used in descending order in the following
    sequence: \\c #TYPE_EXCEPT, \\c #TYPE_CONSTRAINED_TO, \\c
    #TYPE_ARROW, \\c #TYPE_TIME, \\c #TYPE_SPACE, \\c #TYPE_TEXT.

    \\attention Deprecated: A revision is planned for version 4.0.0 to
    replace the type enum with a more semantically defined enumeration,
    with the exact sign specification being relegated to the newly
    introduced 4-tupel traffic sign catalog specification as used in
    <a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE</a>.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_TRAFFICSIGN_PROTO_DESCRIPTOR.enum_types_by_name[
            "TrafficSign.SupplementarySign.Classification.Type"
        ]

    UNKNOWN = 0
    """
    Type of supplementary sign is unknown (must not be used in
    ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) type of supplementary sign.
    """

    NO_SIGN = 2
    """
    There is no supplementary sign (must not be used in ground
    truth).
    """

    TEXT = 41
    """
    Text sign.
    \\n
    Use it as a canvas for text-only signs:
    - Use \\c TrafficSignValue::value to indicate a numerical
    value indicated on the sign. Accompany this value with an
    indication of its unit of measure given by \\c
    TrafficSignValue::value_unit.
    - Use \\c TrafficSignValue::text to indicate a string of text
    indicated on the sign.

    The following table summarizes possible configurations for
    this kind of supplementary signs:

    <table cellspacing="0" cellpadding="0">
    <tr>
    <th>
    Image
    </th>
    <th>
    StVO-No.
    </th>
    <th>
    \\c TrafficSignValue::text
    </th>
    <th>
    Meaning and Remarks
    </th>
    </tr>
    <tr>
    <td>
    \\image html 1007-30.png
    </td>
    <td>
    StVO 1007-30  (StVO 2017)
    \\anchor OIL_TEXT
    </td>
    <td>
    &rdquo;&Ouml;lspur&rdquo;
    </td>
    <td>
    Trail of oil hazard.
    <br>
    \\note The identifier "StVO 1007-30" is currently used to
    denote the hazard of oil trails. Prior to the edition of
    2017 of the Catalog of Street Signs of the Federal Road
    Research Institute of Germany - BASt, it was used to denote a
    restriction of the validity of the traffic sign to snowy /
    icy conditions.
    See \\c #TYPE_SNOW.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1007-31.png
    </td>
    <td>
    StVO 1007-31
    </td>
    <td>
    "Rauch"
    </td>
    <td>
    Smoke hazard.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1007-32.png
    </td>
    <td>
    StVO 1007-32
    </td>
    <td>
    "Rollsplitt"
    </td>
    <td>
    Loose gravel hazard.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1007-33.png
    </td>
    <td>
    StVO 1007-33
    </td>
    <td>
    "Baustellenausfahrt"
    </td>
    <td>
    Construction site exit.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1007-34.png
    </td>
    <td>
    StVO 1007-34
    </td>
    <td>
    &rdquo;Stra&szlig;enschaden&rdquo;
    </td>
    <td>
    Damaged roadway.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1007-35.png
    </td>
    <td>
    StVO 1007-35
    </td>
    <td>
    "Verschmutzte Fahrbahn"
    </td>
    <td>
    Dirty roadway.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1007-36.png
    </td>
    <td>
    StVO 1007-36
    </td>
    <td>
    "Sprengarbeiten"
    </td>
    <td>
    Blasting.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1007-37.png
    </td>
    <td>
    StVO 1007-37
    </td>
    <td>
    "Ausfahrt"
    </td>
    <td>
    Exit.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1007-38.png
    </td>
    <td>
    StVO 1007-38
    </td>
    <td>
    "Baustellen verkehr"
    </td>
    <td>
    Construction vehicles traffic.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1007-39.png
    </td>
    <td>
    StVO 1007-39
    </td>
    <td>
    "fehlende Fahrbahnmarkierung"
    </td>
    <td>
    Missing lane marking.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1007-50.png
    </td>
    <td>
    StVO 1007-50
    \\anchor ACCIDENT_TEXT
    </td>
    <td>
    "Unfall"
    </td>
    <td>
    Accident hazard.
    <br>
    See \\c #TYPE_ACCIDENT
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1007-51.png
    </td>
    <td>
    StVO 1007-51
    </td>
    <td>
    "Hochwasser"
    </td>
    <td>
    Flood.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1007-52.png
    </td>
    <td>
    StVO 1007-52
    </td>
    <td>
    "neuer Fahrbahnbelag"
    </td>
    <td>
    New road surface.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1007-53.png
    </td>
    <td>
    StVO 1007-53
    </td>
    <td>
    "Spurrinnen"
    </td>
    <td>
    Wheel ruts.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1007-54.png
    </td>
    <td>
    StVO 1007-54
    </td>
    <td>
    "Linksabbieger"
    </td>
    <td>
    Left-turning drivers.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1007-57.png
    </td>
    <td>
    StVO 1007-57
    </td>
    <td>
    "Kuppe"
    </td>
    <td>
    Hilltop.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1007-58.png
    </td>
    <td>
    StVO 1007-58
    </td>
    <td>
    "Polizeikontrolle"
    </td>
    <td>
    Police check.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1007-60.png
    </td>
    <td>
    StVO 1007-60
    </td>
    <td>
    "Seitenstreifen nicht befahrbar"
    </td>
    <td>
    Side strips not passable.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1007-61.png
    </td>
    <td>
    StVO 1007-61
    </td>
    <td>
    "NEBEL"
    </td>
    <td>
    Restriction of the validity of the traffic sign to foggy.
    </td>
    <tr>
    <td>
    \\image html 1007-62.png
    </td>
    <td>
    StVO 1007-62
    </td>
    <td>
    "Zufahrt"
    </td>
    <td>
    Driveway.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1008-30.png
    </td>
    <td>
    StVO 1008-30
    </td>
    <td>
    &rdquo;Vorfahrt ge&auml;ndert&rdquo;
    </td>
    <td>
    Priority changed.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1008-31.png
    </td>
    <td>
    StVO 1008-31
    </td>
    <td>
    &rdquo;Verkehrsf&uuml;hrung ge&auml;ndert&rdquo;
    </td>
    <td>
    Routing changed.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1008-32.png
    </td>
    <td>
    StVO 1008-32
    </td>
    <td>
    "Industriegebiet Schienenfahrzeuge haben Vorweg"
    </td>
    <td>
    Industrial area (rail traffic has priority).
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1008-33.png
    </td>
    <td>
    StVO 1008-33
    </td>
    <td>
    "Hafengebiet Schienenfahrzeuge haben Vorweg"
    </td>
    <td>
    Port area (rail traffic has priority).
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1008-34.png
    </td>
    <td>
    StVO 1008-34
    </td>
    <td>
    &rdquo;keine Wendem&ouml;glichkeit&rdquo;
    </td>
    <td>
    No turning possibility.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1012-30n.png
    </td>
    <td>
    StVO 1012-30 (StVO 2017)
    </td>
    <td>
    "Ladezone"
    </td>
    <td>
    Loading zone.
    \\anchor LOADING_ZONE_TEXT
    \\note The identifier "StVO 1012-30" is currently used to
    denote a loading zone. Prior to the edition of 2017 of
    the Catalog of Street Signs of the Federal Road Research
    Institute of Germany - BASt, it was used to denote
    the beginning of the validity of regulation prescribed by
    the \\c MainSign.
    See [\\c Begin](\\ref BEGIN_TEXT).
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1012-30a.png
    </td>
    <td>
    StVO 1012-30
    </td>
    <td>
    "Anfang"
    </td>
    <td>
    Begin
    \\anchor BEGIN_TEXT
    \\note The identifier "StVO 1012-30" is currently used to
    denote a loading zone. Prior to the edition of 2017 of
    the Catalog of Street Signs of the Federal Road Research
    Institute of Germany - BASt, it was used to denote
    the beginning of the validity of regulation prescribed by
    the \\c MainSign.
    See [\\c Loading zone](\\ref LOADING_ZONE_TEXT).
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1012-31.png
    </td>
    <td>
    StVO 1012-31
    </td>
    <td>
    "Ende"
    </td>
    <td>
    End.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1012-34.png
    </td>
    <td>
    StVO 1012-34
    </td>
    <td>
    &rdquo;Gr&uuml;ne Welle bei XX km/h&rdquo;
    </td>
    <td>
    All green signals ("green wave") at certain speed.
    <br>
    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit (e.g. km/h) to indicate the
    speed.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1012-35.png
    </td>
    <td>
    StVO 1012-35
    </td>
    <td>
    "bei Rot hier halten"
    </td>
    <td>
    Stop at red light.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1012-36.png
    </td>
    <td>
    StVO 1012-36
    \\anchor NOISE_PROTECTION_TEXT
    </td>
    <td>
    &rdquo;L&auml;rmschutz&rdquo;
    </td>
    <td>
    Noise protection.
    <br>
    See also:
    [\\c Noise protection with time limit](\\ref NOISE_PROTECTION2)
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1012-37.png
    </td>
    <td>
    StVO 1012-37
    </td>
    <td>
    "Zuflussregelung"
    </td>
    <td>
    Inflow regulation.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1012-38.png
    </td>
    <td>
    StVO 1012-38
    </td>
    <td>
    "Nebenstrecke"
    </td>
    <td>
    Secondary route.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1012-50.png
    </td>
    <td>
    StVO 1012-50
    </td>
    <td>
    "Schule"
    </td>
    <td>
    School.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1012-51.png
    </td>
    <td>
    StVO 1012-51
    </td>
    <td>
    "Kindergarten"
    </td>
    <td>
    Kindergarten.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1012-52.png
    </td>
    <td>
    StVO 1012-52
    </td>
    <td>
    "Altenheim"
    </td>
    <td>
    Retirement home.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1012-53.png
    </td>
    <td>
    StVO 1012-53
    </td>
    <td>
    "Krankenhaus"
    </td>
    <td>
    Hospital.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1013-50.png
    </td>
    <td>
    StVO 1013-50
    </td>
    <td>
    "Seitenstreifen befahren"
    </td>
    <td>
    Driving on side stripes.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1013-51.png
    </td>
    <td>
    StVO 1013-51
    </td>
    <td>
    &rdquo;Seitenstreifen r&auml;umen&rdquo;
    </td>
    <td>
    Vacate side stripes.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1014-50.png
    </td>
    <td>
    StVO 1014-50
    </td>
    <td>
    A letter among B,C,D or E
    </td>
    <td>
    Tunnel category according to ADR agreement.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1028-31.png
    </td>
    <td>
    StVO 1028-31
    </td>
    <td>
    "bis Baustelle frei"
    </td>
    <td>
    Exception up to construction site.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1053-30.png
    </td>
    <td>
    StVO 1053-30
    </td>
    <td>
    &rdquo;Parken in gekennzeichneten Fl&auml;chen erlaubt&rdquo;
    </td>
    <td>
    Parking in marked areas allowed.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1053-31.png
    </td>
    <td>
    StVO 1053-31
    </td>
    <td>
    "mit Parkschein"
    </td>
    <td>
    With parking ticket.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1053-32.png
    </td>
    <td>
    StVO 1053-32
    </td>
    <td>
    &rdquo;geb&uuml;hrenpflichtig&rdquo;
    </td>
    <td>
    Fees apply.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1053-34.png
    </td>
    <td>
    StVO 1053-34
    </td>
    <td>
    "auf dem Seitenstreifen"
    </td>
    <td>
    On the shoulder.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1053-36.png
    </td>
    <td>
    StVO 1053-36
    </td>
    <td>
    "Durchgangsverkehr"
    </td>
    <td>
    Transit traffic.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1053-52.png
    </td>
    <td>
    StVO 1053-52
    </td>
    <td>
    &rdquo;nur innerhalb gekennzeichneter Parkfl&auml;chen&rdquo;
    </td>
    <td>
    Only within marked parking areas.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1053-53.png
    </td>
    <td>
    StVO 1053-53
    </td>
    <td>
    &rdquo;Parken mit Parkschein in gekennzeichneter
    fl&auml;chen&rdquo;
    </td>
    <td>
    Parking with parking permit in marked areas.
    </td>
    </tr>
    </table>
    """

    SPACE = 39
    """
    Text sign with distance indication.
    \\n
    Use it as a canvas for text signs that make reference to a
    point or area in space:
    - Use \\c TrafficSignValue::value to include the distance
    indicated in the sign. Accompany this value with an
    indication of its unit of measure given by \\c
    TrafficSignValue::value_unit (e.g. m),
    - Use \\c TrafficSignValue::text to indicate the sign's
    specific text,

    The following table summarizes possible configurations for
    this kind of supplementary signs:

    <table cellspacing="0" cellpadding="0">
    <tr>
    <th>
    Image
    </th>
    <th>
    StVO-No.
    </th>
    <th>
    \\c TrafficSignValue member(s)
    </th>
    <th>
    Meaning and Remarks
    </th>
    </tr>
    <tr>
    <td>
    \\image html 1004-32.png
    </td>
    <td>
    StVO 1004-32
    </td>
    <td>
    "STOP" + distance
    </td>
    <td>
    Stop in e.g. ... m
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1005-30.png
    </td>
    <td>
    StVO 1005-30
    </td>
    <td>
    &rdquo;Rei&szlig;verschluss erst in&rdquo; + distance
    </td>
    <td>
    Zipper merge in e.g. ... m
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1007-59.png
    </td>
    <td>
    StVO 1007-59
    </td>
    <td>
    "Ende Seitenstreifen in" + distance
    </td>
    <td>
    End of the side strip in e.g. ... m
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1013-52.png
    </td>
    <td>
    StVO 1013-52
    </td>
    <td>
    "Ende in" + distance
    </td>
    <td>
    End in .. m
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1028-33.png
    </td>
    <td>
    StVO 1028-33
    </td>
    <td>
    "Zufahrt bis frei" + distance or location
    </td>
    <td>
    Except up to ...
    <br>
    If there is a prohibition for all vehicles, the street can
    still be used up to a certain point. To indicate the point,
    use one of the following alternatives:
    - A numerical value described by \\c TrafficSignValue::value
    and \\c TrafficSignValue::value_unit (e.g. m) to indicate
    the point as a distance from the sign.
    - A text described by \\c TrafficSignValue::text in order to
    describe the point's location verbally, e.g. "Baugebiet ...".
    </td>
    </tr>
    </table>
    """

    TIME = 26
    """
    Text sign with time indication.
    \\n
    Use it as a canvas for text signs that make:
    reference to a point in time or a time range.
    - Use one or more \\c TrafficSignValue messages to include
    the times indicated in the sign. Accompany each value with an
    indication of its unit of measure given by \\c
    TrafficSignValue::value_unit, e.g. h.
    - For each \\c TrafficSignValue, \\c TrafficSignValue::value
    indicates the time elapsed since midnight every day.
    - Use the \\c TrafficSignValue::text member of the
    first \\c TrafficSignValue message to indicate the sign's
    specific text.

    \\note
    - Time interval need two \\c TrafficSignValue messages,
    one to indicate their start and one to indicate their end.
    - In case more than one time range is required, the
    \\c TrafficSignValue::value member of the first \\c
    TrafficSignValue message is interpreted as the beginning of
    the first interval, the \\c TrafficSignValue::value member of
    the second \\c TrafficSignValue message is interpreted as the
    end of the first interval, and so on.

    The following table summarizes possible configurations for
    this kind of supplementary signs:

    <table cellspacing="0" cellpadding="0">
    <tr>
    <th>
    Image
    </th>
    <th>
    StVO-No.
    </th>
    <th>
    \\c TrafficSignValue member(s)
    </th>
    <th>
    Meaning and Remarks
    </th>
    </tr>
    <tr>
    <td>
    \\image html 1040-30.png
    </td>
    <td>
    StVO 1040-30
    </td>
    <td>
    Time range
    </td>
    <td>
    Time range for validity of traffic sign.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1040-31.png
    </td>
    <td>
    StVO 1040-31
    \\anchor StVO_1040-31
    </td>
    <td>
    Two time ranges
    </td>
    <td>
    Time range for validity of traffic sign - two ranges.
    <br>
    For each time range, include a pair of \\c TrafficSignValue
    messages according to the [\\c rules above](\\ref TYPE_TIME).
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1040-34.png
    </td>
    <td>
    StVO 1040-34
    </td>
    <td>
    "ab" + Date + Time of the day
    </td>
    <td>
    Restricted from point in time.
    <br>
    - Use three \\c TrafficSignValue messages to indicate
    respectively the day of the month, the month of the year,
    and the hour of the day corresponding to the start of the
    restriction.
    - The first two \\c TrafficSignValue::value_unit should be
    set to \\c TrafficSignValue::UNIT_NO_UNIT.
    - For the last \\c TrafficSignValue, \\c
    TrafficSignValue::value indicates the time elapsed since
    midnight of the corresponding day, and \\c
    TrafficSignValue::value_unit indicates the unit this time is
    expressed in, e.g. in min.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1040-35.png
    </td>
    <td>
    StVO 1040-35
    \\anchor NOISE_PROTECTION2
    </td>
    <td>
    &rdquo;L&auml;rmschutz&rdquo; + time range
    </td>
    <td>
    Noise protection with time limit.
    <br>
    See [\\c Noise protection](\\ref NOISE_PROTECTION_TEXT).
    </tt>
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1040-36.png
    </td>
    <td>
    StVO 1040-36
    </td>
    <td>
    "Schulweg" + time range
    </td>
    <td>
    Way to or from school with time limit.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1042-30.png
    </td>
    <td>
    StVO 1042-30
    </td>
    <td>
    "werktags"
    </td>
    <td>
    Working days.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1042-31.png
    </td>
    <td>
    StVO 1042-31
    \\anchor StVO_1042-31
    </td>
    <td>
    "werktags" + time range
    </td>
    <td>
    Working days with time limit.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1042-32.png
    </td>
    <td>
    StVO 1042-32
    </td>
    <td>
    "werktags" + two time ranges
    </td>
    <td>
    Restricted to working days with two time intervals.
    <br>
    For each time range, include a pair of \\c TrafficSignValue
    messages according to the [\\c rules above](\\ref TYPE_TIME).
    <br>
    See also: [\\c Two time ranges](\\ref StVO_1040-31).
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1042-33.png
    </td>
    <td>
    StVO 1042-33
    </td>
    <td>
    "Mo-Fr" + time range
    </td>
    <td>
    Time range for validity of traffic sign with days of the
    week.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1042-34.png
    </td>
    <td>
    StVO 1042-34
    </td>
    <td>
    "Di,Do,Fr" + time range
    </td>
    <td>
    Tuesdays, Thursdays and Fridays with time limit.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1042-35.png
    </td>
    <td>
    StVO 1042-35
    </td>
    <td>
    "an Sonn- und Feiertagen" + time range
    </td>
    <td>
    Restricted times, Sundays and public holidays only.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1042-36.png
    </td>
    <td>
    StVO 1042-36
    </td>
    <td>
    &rdquo;Schulbus werktags au&szlig;er samstags&rdquo; + two
    time ranges
    </td>
    <td>
    School bus, restricted to daytimes
    <br>
    For each time range, include a pair of \\c
    TrafficSignValue messages according to the
    [\\c rules above](\\ref TYPE_TIME).
    <br>
    See also: [\\c Two time ranges](\\ref StVO_1040-31),
    [\\c Working days except Saturdays](\\ref StVO_1042-38).
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1042-37.png
    </td>
    <td>
    StVO 1042-37
    </td>
    <td>
    "Parken Sa und So erlaubt"
    </td>
    <td>
    Parking on Saturdays and Sundays allowed.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1042-38.png
    </td>
    <td>
    StVO 1042-38
    \\anchor StVO_1042-38
    </td>
    <td>
    &rdquo;werktags au&szlig;er samstags&rdquo;
    </td>
    <td>
    Working days except Saturdays.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1042-51.png
    </td>
    <td>
    StVO 1042-51
    </td>
    <td>
    "Sa und So"
    </td>
    <td>
    Saturdays and Sundays.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1042-53.png
    </td>
    <td>
    StVO 1042-53
    </td>
    <td>
    "werktags Schulweg" + time range
    </td>
    <td>
    Way to or from school with time limit on working days.
    <br>
    See also
    [\\c Working days with time limit](\\ref StVO_1042-31).
    </td>
    </tr>
    </table>
    """

    ARROW = 30
    """
    A supplementary sign showing a direction alone.
    \\n
    Use together with the message \\c Classification::arrow. The
    following signs can be built:
    <table cellspacing="0" cellpadding="0">
    <tr>
    <th>
    Image
    </th>
    <th>
    StVO-No.
    </th>
    <th>
    Meaning and Remarks
    </th>
    </tr>
    <tr>
    <td>
    \\image html 1000-13.png
    </td>
    <td>
    StVO 1000-13
    </td>
    <td>
    Detour sign, three-quarter circle.
    <br>
    Set \\c Classification::arrow to \\c
    Arrow::DIRECTION_CIRCLE_90_DEG_LEFT.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1000-23.png
    </td>
    <td>
    StVO 1000-23
    </td>
    <td>
    Detour sign, one-quarter circle.
    <br>
    Set \\c Classification::arrow to \\c
    Arrow::DIRECTION_CIRCLE_90_DEG_RIGHT.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1000-30.png
    </td>
    <td>
    StVO 1000-30
    </td>
    <td>
    Bidirectional traffic sideways.
    <br>
    Use two \\c Classification::arrow messages. Set one to \\c
    Arrow::DIRECTION_DIRECT_90_DEG_RIGHT and the other one to \\c
    Arrow::DIRECTION_DIRECT_90_DEG_LEFT.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1000-31.png
    </td>
    <td>
    StVO 1000-31
    </td>
    <td>
    Bidirectional traffic back and forth.
    <br>
    Use two \\c Classification::arrow messages. Set one to \\c
    Arrow::DIRECTION_DIRECT_0_DEG and the other one to \\c
    Arrow::DIRECTION_DIRECT_180_DEG.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1000-34.png
    </td>
    <td>
    StVO 1000-34
    </td>
    <td>
    Detour sign, semicircle.
    <br>
    Set \\c Classification::arrow to \\c
    Arrow::DIRECTION_CIRCLE_0_DEG.
    </td>
    </tr>
    </table>
    """

    CONSTRAINED_TO = 46
    """
    The list of traffic actors to which the main sign's
    regulation is constrained to.
    \\n
    Use as many members of the \\c Actor enumerator as needed to
    denote the related traffic actors.

    The following tables summarize possible configurations for
    this kind of supplementary signs:
    <table cellspacing="0" cellpadding="0">
    <tr>
    <th>
    Image
    </th>
    <th>
    StVO-No.
    </th>
    <th>
    \\c Actor
    </th>
    <th>
    Meaning and Remarks
    </th>
    </tr>
    <tr>
    <td>
    \\image html 1000-12.png
    </td>
    <td>
    StVO 1000-12
    </td>
    <td>
    \\c #ACTOR_PEDESTRIANS
    </td>
    <td>
    Use sidewalk on left side of roadway.
    <br>
    Set \\c Classification::arrow to \\c
    Arrow::DIRECTION_DIRECT_90_DEG_LEFT.
    </td>
    </tr>
    <tr>
    <td>
    <!--
    \\image html 1000-22.png
    -->
    </td>
    <td>
    StVO 1000-22
    </td>
    <td>
    \\c #ACTOR_PEDESTRIANS
    </td>
    <td>
    Use sidewalk on right side of roadway.
    <br>
    Set \\c Classification::arrow to \\c
    Arrow::DIRECTION_DIRECT_90_DEG_RIGHT.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1000-32.png
    </td>
    <td>
    StVO 1000-32
    </td>
    <td>
    \\c #ACTOR_BICYCLES
    </td>
    <td>
    Bidirectional traffic bicycles sideways.
    <br>
    Use two \\c Classification::arrow messages. Set one to \\c
    Arrow::DIRECTION_DIRECT_90_DEG_RIGHT and the other one to \\c
    Arrow::DIRECTION_DIRECT_90_DEG_LEFT.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1000-33.png
    </td>
    <td>
    StVO 1000-33
    </td>
    <td>
    \\c #ACTOR_BICYCLES
    </td>
    <td>
    Bidirectional traffic bicyclesback and forth.
    <br>
    Use two \\c Classification::arrow messages. Set one to \\c
    Arrow::DIRECTION_DIRECT_0_DEG and the other one to \\c
    Arrow::DIRECTION_DIRECT_180_DEG.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1010-50.png
    </td>
    <td>
    StVO 1010-50
    </td>
    <td>
    \\c #ACTOR_MOTORIZED_MULTITRACK_VEHICLES
    </td>
    <td>
    Motorized multi-track vehicles.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1010-51.png
    </td>
    <td>
    StVO 1010-51
    </td>
    <td>
    \\c #ACTOR_TRUCKS
    </td>
    <td>
    Trucks.
    \\note
    - In the German StVO, trucks are defined as motorized
    vehicles that are heavier than 3.5 t.
    - This supplementary sign also denotes the trucks' tractor
    units and trailers.
    - Cars and buses with a total weight superior to 3.5 t are
    not denoted by this. sign.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1010-52.png
    </td>
    <td>
    StVO 1010-52
    </td>
    <td>
    \\c #ACTOR_BICYCLES
    </td>
    <td>
    Bicycles.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1010-53.png
    </td>
    <td>
    StVO 1010-53
    </td>
    <td>
    \\c #ACTOR_PEDESTRIANS
    </td>
    <td>
    Pedestrians.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1010-54.png
    </td>
    <td>
    StVO 1010-54
    </td>
    <td>
    \\c #ACTOR_HORSE_RIDERS
    </td>
    <td>
    Horse riders.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1010-55.png
    </td>
    <td>
    StVO 1010-55
    </td>
    <td>
    \\c #ACTOR_CATTLE
    </td>
    <td>
    Cattles.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1010-56.png
    </td>
    <td>
    StVO 1010-56
    </td>
    <td>
    \\c #ACTOR_TRAMS
    </td>
    <td>
    Trams.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1010-57.png
    </td>
    <td>
    StVO 1010-57
    </td>
    <td>
    \\c #ACTOR_BUSES
    </td>
    <td>
    Buses.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1010-58.png
    </td>
    <td>
    StVO 1010-58
    </td>
    <td>
    \\c #ACTOR_CARS
    </td>
    <td>
    Passenger cars.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1010-59.png
    </td>
    <td>
    StVO 1010-59
    </td>
    <td>
    \\c #ACTOR_CARS_WITH_TRAILERS
    </td>
    <td>
    Passenger cars with trailers.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1010-60.png
    </td>
    <td>
    StVO 1010-60
    </td>
    <td>
    \\c #ACTOR_TRUCKS_WITH_TRAILERS
    </td>
    <td>
    Trucks with trailers.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1010-61.png
    </td>
    <td>
    StVO 1010-61
    </td>
    <td>
    \\c #ACTOR_TRACTORS
    </td>
    <td>
    Tractors.
    \\note In the German StVO, tractors are defined as motorized
    vehicles that are not allowed to, or cannot, drive faster
    than 25 km/h.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1010-62.png
    </td>
    <td>
    StVO 1010-62
    </td>
    <td>
    \\c #ACTOR_MOTORCYCLES
    </td>
    <td>
    Motorbikes.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1010-63.png
    </td>
    <td>
    StVO 1010-63
    </td>
    <td>
    \\c #ACTOR_MOPEDS
    </td>
    <td>
    Mopeds.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1010-64.png
    </td>
    <td>
    StVO 1010-64
    </td>
    <td>
    \\c #ACTOR_HORSE_CARRIAGES
    </td>
    <td>
    Horse carriages.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1010-65.png
    </td>
    <td>
    StVO 1010-65
    </td>
    <td>
    \\c #ACTOR_EBIKES
    </td>
    <td>
    E-bikes.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1010-66.png
    </td>
    <td>
    StVO 1010-66
    </td>
    <td>
    \\c #ACTOR_ELECTRIC_VEHICLES
    </td>
    <td>
    Electric vehicles.
    <br>
    See also: [\\c StVO 1050-33](\\ref EV_T).
    \\anchor EV_I
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1010-67.png
    </td>
    <td>
    StVO 1010-67
    </td>
    <td>
    \\c #ACTOR_CAMPERS
    </td>
    <td>
    Campers.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1012-32.png
    </td>
    <td>
    StVO 1012-32
    </td>
    <td>
    \\c #ACTOR_BICYCLES
    </td>
    <td>
    Cyclists must walk.
    <br>
    Set \\c TrafficSignValue::text as "absteigen".
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1049-11.png
    </td>
    <td>
    StVO 1049-11
    </td>
    <td>
    \\c #ACTOR_TRACTORS
    </td>
    <td>
    Overtaking of tractors allowed.
    <br>
    Set \\c TrafficSignValue::text as
    &rdquo;d&uuml;rfen &uuml;berholt werden&rdquo;.
    \\note In the German StVO, tractors are defined as motorized
    vehicles that are not allowed to, or cannot, drive faster
    than 25 km/h.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1050-30.png
    </td>
    <td>
    StVO 1050-30
    </td>
    <td>
    \\c #ACTOR_TAXIS
    </td>
    <td>
    Taxis.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1050-31.png
    </td>
    <td>
    StVO 1050-31
    </td>
    <td>
    \\c #ACTOR_TAXIS
    </td>
    <td>
    A number of taxis.
    <br>
    Use \\c TrafficSignValue::value to indicate the number of
    taxis. Set \\c TrafficSignValue::value_unit to \\c
    TrafficSignValue::UNIT_NO_UNIT.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1050-32.png
    </td>
    <td>
    StVO 1050-32
    </td>
    <td>
    \\c #ACTOR_ELECTRIC_VEHICLES
    </td>
    <td>
    Electric vehicles during the charging process.
    <br>
    Set \\c TrafficSignValue::text as &rdquo;w&auml;hrend des
    Ladevorgangs&rdquo;.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1050-33.png
    </td>
    <td>
    StVO 1050-33
    </td>
    <td>
    \\c #ACTOR_ELECTRIC_VEHICLES
    </td>
    <td>
    Electric vehicles.
    <br>
    See also: [\\c StVO 1010-66](\\ref EV_I).
    \\anchor EV_T
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1060-32.png
    </td>
    <td>
    StVO 1060-32
    </td>
    <td>
    Two actors \\c #ACTOR_BUSES and \\c #ACTOR_CARS_WITH_TRAILERS.
    </td>
    <td>
    Buses and cars with trailers.
    <br>
    Set \\c TrafficSignValue::text as "auch".
    </td>
    </tr>
    </table>

    Also, some of the German StVO traffic signs denoting traffic
    actors for which the main sign's regulation applies
    exclusively can be constructed.

    \\note
    In the German StVO, these signs typically include the word
    "Nur".

    <table cellspacing="0" ellpadding="0">
    <tr>
    <th>
    Image
    </th>
    <th>
    StVO-No.
    </th>
    <th>
    \\c
    Actor
    </th>
    <th>
    Meaning and Remarks
    </th>
    </tr>
    <tr>
    <td>
    \\image html 1044-10.png
    </td>
    <td>
    StVO 1044-10
    </td>
    <td>
    \\c #ACTOR_DISABLED_PERSONS
    </td>
    <td>
    Only disabled persons with an exceptional walking disability
    and blind persons.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1044-11.png
    </td>
    <td>
    StVO 1044-11
    </td>
    <td>
    \\c #ACTOR_DISABLED_PERSONS
    </td>
    <td>
    Only disabled persons with parking permit.
    <br>
    Set \\c TrafficSignValue::text as "mit Parkausweis
    Nr. XXXX".
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1044-12.png
    </td>
    <td>
    StVO 1044-12
    </td>
    <td>
    \\c#ACTOR_DISABLED_PERSONS
    </td>
    <td>
    Only disabled persons with an exceptional walking disability
    and blind persons, with number of parking places.
    <br>
    Use \\c TrafficSignValue::value to indicate the number of
    parking places. Set \\c TrafficSignValue::value_unit to \\c
    TrafficSignValue::UNIT_NO_UNIT. Set \\c
    TrafficSignValue::text as &rdquo;Parkst&auml;nde&rdquo;.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1044-30.png
    </td>
    <td>
    StVO 1044-30
    </td>
    <td>
    \\c #ACTOR_RESIDENTS
    </td>
    <td>
    Only residents with parking permit.
    <br>
    Set \\c TrafficSignValue::text as "mit Parkausweis Nr. XXXX".
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1048-14.png
    </td>
    <td>
    StVO 1048-14
    </td>
    <td>
    \\c #ACTOR_TRUCKS_WITH_SEMITRAILERS
    </td>
    <td>
    Only trucks with semi-trailers.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1048-15.png
    </td>
    <td>
    StVO 1048-15
    </td>
    <td>
    Two actors: one set to \\c #ACTOR_TRUCKS_WITH_SEMITRAILERS
    and the other one set to \\c #ACTOR_TRUCKS_WITH_TRAILERS.
    </td>
    <td>
    Only trucks with trailers and trucks with semi-trailers.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1048-18.png
    </td>
    <td>
    StVO 1048-18
    </td>
    <td>
    \\c #ACTOR_RAILROAD_TRAFFIC
    </td>
    <td>
    Only railroad traffic.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1048-20.png
    </td>
    <td>
    StVO 1048-20
    </td>
    <td>
    Two actors: one set to \\c #ACTOR_CARS_WITH_TRAILERS
    and the other one set to \\c #ACTOR_TRUCKS.
    </td>
    <td>
    Only trucks with trailers and trucks with semi-trailers.
    \\note
    - In the German StVO, trucks are defined as motorized
    vehicles that are heavier than 3.5 t.
    - This supplementary sign also denotes the trucks'
    tractor units and trailers.
    - This supplementary sign excludes passenger cars and
    buses.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1049-12.png
    </td>
    <td>
    StVO 1049-12
    </td>
    <td>
    \\c #ACTOR_MILITARY_VEHICLES
    </td>
    <td>
    Only military vehicles.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1049-13.png
    </td>
    <td>
    StVO 1049-13
    </td>
    <td>
    Three actors, set to respectively \\c #ACTOR_TRUCKS, \\c
    #ACTOR_BUSES and \\c #ACTOR_CARS_WITH_TRAILERS.
    </td>
    <td>
    Only trucks, buses, passenger cars with trailers.
    <br>
    \\note
    - In the German StVO, trucks are defined as motorized
    vehicles that are heavier than 3.5 t.
    - This supplementary sign also denotes the trucks' tractor
    units and trailers.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1052-30.png
    </td>
    <td>
    StVO 1052-30
    </td>
    <td>
    \\c #ACTOR_HAZARDOUS_GOODS_VEHICLES
    </td>
    <td>
    Only hazardous goods vehicles.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1052-31.png
    </td>
    <td>
    StVO 1052-31
    </td>
    <td>
    \\c #ACTOR_WATER_POLLUTANT_VEHICLES
    </td>
    <td>
    Only water pollutant vehicles.
    </td>
    </tr>
    </table>

    In addition, some of the German StVO supplementary signs
    with actors that receive an explicit allowance to use
    the street or the shoulder can be constructed:
    <table cellspacing="0" ellpadding="0">
    <tr>
    <th>
    Image
    </th>
    <th>
    StVO-No.
    </th>
    <th>
    \\c Actor
    </th>
    <th>
    Meaning and Remarks
    </th>
    </tr>
    <tr>
    <td>
    \\image html 1010-10.png
    </td>
    <td>
    StVO 1010-10
    </td>
    <td>
    \\c #ACTOR_CHILDREN
    </td>
    <td>
    Children playing on the road and shoulder allowed.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1010-11.png
    </td>
    <td>
    StVO 1010-11
    </td>
    <td>
    \\c #ACTOR_WINTER_SPORTSPEOPLE
    </td>
    <td>
    Winter sports allowed.
    <br>
    Use \\c TrafficSignValue::value to indicate the number
    of taxis.
    Set \\c TrafficSignValue::value_unit to \\c
    TrafficSignValue::UNIT_NO_UNIT.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1010-12.png
    </td>
    <td>
    StVO 1010-12
    </td>
    <td>
    \\c#ACTOR_TRAILERS
    </td>
    <td>
    Trailers allowed.
    \\note In the German StVO, this sign states that Trailers can
    park here without the usual two week temporal parking
    restriction.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1010-13.png
    </td>
    <td>
    StVO 1010-13
    </td>
    <td>
    \\c #ACTOR_CARAVANS
    </td>
    <td>
    Caravans allowed.
    \\note In the German StVO, this sign states that Caravans can
    park here without the usual two week temporal parking
    restriction.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1040-10.png
    </td>
    <td>
    StVO 1040-10
    </td>
    <td>
    \\c #ACTOR_WINTER_SPORTSPEOPLE
    </td>
    <td>
    Winter sports within time range allowed.
    <br>
    In order to indicate an allowance limited by a time period,
    use one \\c TrafficSignValue message to indicate its start and
    one \\c TrafficSignValue message to indicate its end. For
    each \\c TrafficSignValue, \\c TrafficSignValue::value
    indicates the time elapsed since midnight every day, and \\c
    TrafficSignValue::value_unit indicates the unit this time is
    expressed in, e.g. in min.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1007-55.png
    </td>
    <td>
    StVO 1007-55
    </td>
    <td>
    \\c #ACTOR_WINTER_SPORTSPEOPLE
    </td>
    <td>
    Ski run crosses.
    <br>
    Set \\c TrafficSignValue::text as "kreuzt".
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1007-56.png
    </td>
    <td>
    StVO 1007-56
    </td>
    <td>
    \\c #ACTOR_WINTER_SPORTSPEOPLE
    </td>
    <td>
    Ski trail.
    <br>
    Set \\c TrafficSignValue::text as "kreuzt".
    </td>
    </tr>
    </table>

    Finally, the signs
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 1006-30.png
    </td>
    <td>
    StVO
    1006-30
    </td>
    <td>
    \\c #ACTOR_CARS_WITH_CARAVANS
    </td>
    <td>
    Slide danger for car/caravan combinations under strong winds.
    <br>
    Set \\c TrafficSignValue::text as "Schleudergefahr".
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1012-33.png
    </td>
    <td>
    StVO
    1012-33
    </td>
    <td>
    \\c #ACTOR_MOPEDS
    </td>
    <td>
    No mopeds.
    <br>
    Set \\c TrafficSignValue::text as "keine".
    </td>
    </tr>
    </table>
    can be incorporated.
    """

    EXCEPT = 45
    """
    The list of traffic actors for which the main sign's
    regulation does not apply or have a special driving
    allowance.
    \\n
    Use as many members of the \\c Actor enumerator
    as needed to denote the excepted traffic actors:

    \\note
    In the German StVO, these signs include the word "frei".

    The following table summarizes possible configurations for
    this kind of supplementary signs:

    <table cellspacing="0" cellpadding="0">
    <tr>
    <th>
    Image
    </th>
    <th>
    StVO-No.
    </th>
    <th>
    \\c Actor
    </th>
    <th>
    Meaning and Remarks
    </th>
    </tr>
    <tr>
    <td>
    \\image html 1020-11.png
    </td>
    <td>
    StVO 1020-11
    </td>
    <td>
    \\c #ACTOR_DISABLED_PERSONS
    </td>
    <td>
    Except disabled persons with parking permit.
    <br>
    Set \\c TrafficSignValue::text as "mit Parkausweis Nr. XXXX".
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1020-12.png
    </td>
    <td>
    StVO 1020-12
    </td>
    <td>
    Two actors: one set to \\c #ACTOR_BICYCLES and the other one
    set to \\c #ACTOR_RESIDENTS.
    </td>
    <td>
    Except cyclists and residents.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1020-14.png
    </td>
    <td>
    StVO 1020-14
    </td>
    <td>
    \\c #ACTOR_WINTER_SPORTSPEOPLE
    </td>
    <td>
    Except winter sportspeople.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1020-30.png
    </td>
    <td>
    StVO 1020-30
    </td>
    <td>
    \\c #ACTOR_RESIDENTS
    </td>
    <td>
    Except residents.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1020-31.png
    </td>
    <td>
    StVO 1020-31
    </td>
    <td>
    \\c #ACTOR_RESIDENTS
    </td>
    <td>
    Except residents or free parking.
    </td>
    <br>
    Set \\c TrafficSignValue::text as "oder Parken".
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1020-32.png
    </td>
    <td>
    StVO 1020-32
    </td>
    <td>
    \\c #ACTOR_RESIDENTS
    </td>
    <td>
    Except residents with parking permit.
    <br>
    Set \\c TrafficSignValue::text as "mit Parkausweis Nr. XXXX".
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1022-10.png
    </td>
    <td>
    StVO 1022-10
    </td>
    <td>
    \\c #ACTOR_BICYCLES
    </td>
    <td>
    Except bicycles.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1022-11.png
    </td>
    <td>
    StVO 1022-11
    </td>
    <td>
    \\c #ACTOR_MOPEDS
    </td>
    <td>
    Except mopeds.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1022-12.png
    </td>
    <td>
    StVO 1022-12
    </td>
    <td>
    \\c #ACTOR_MOTORCYCLES
    </td>
    <td>
    Except motorcycles.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1022-13.png
    </td>
    <td>
    StVO 1022-13
    </td>
    <td>
    \\c #ACTOR_EBIKES
    </td>
    <td>
    Except e-bikes.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1022-14.png
    </td>
    <td>
    StVO 1022-14
    </td>
    <td>
    Two actors: one set to \\c #ACTOR_BICYCLES and the other one
    set to \\c #ACTOR_MOPEDS.
    </td>
    <td>
    Except bicycles and mopeds.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1022-15.png
    </td>
    <td>
    StVO 1022-15
    </td>
    <td>
    Two actors: one set to \\c #ACTOR_EBIKES and the other one
    set to \\c #ACTOR_MOPEDS.
    </td>
    <td>
    Except e-bikes and mopeds.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1024-10.png
    </td>
    <td>
    StVO 1024-10
    </td>
    <td>
    \\c #ACTOR_CARS
    </td>
    <td>
    Except passenger cars.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1024-11.png
    </td>
    <td>
    StVO 1024-11
    </td>
    <td>
    \\c #ACTOR_CARS_WITH_TRAILERS
    </td>
    <td>
    Except passenger cars with trailers.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1024-12.png
    </td>
    <td>
    StVO 1024-12
    </td>
    <td>
    \\c #ACTOR_TRUCKS
    </td>
    <td>
    Except trucks, their tractor unit and their trailers.
    \\note
    - In the German StVO, trucks are defined as motorized
    vehicles that are heavier than 3.5 t.
    - This supplementary sign also denotes the trucks' tractor
    units and trailers.
    - Cars and buses with a total weight superior to 3.5 t are
    not exempted of a rule by this sign.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1024-13.png
    </td>
    <td>
    StVO 1024-13
    </td>
    <td>
    \\c #ACTOR_TRUCKS_WITH_TRAILERS
    </td>
    <td>
    Except trucks with trailers.
    \\note
    - In the German StVO, trucks are defined as motorized
    vehicles that are heavier than 3.5 t.
    - This supplementary sign also denotes the trucks' tractor
    units and trailers.
    - Cars and buses with a total weight superior to 3.5 t are
    not exempted of a rule by this sign.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1024-14.png
    </td>
    <td>
    StVO 1024-14
    </td>
    <td>
    \\c #ACTOR_BUSES
    </td>
    <td>
    Except buses.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1024-15.png
    </td>
    <td>
    StVO 1024-15
    </td>
    <td>
    \\c #ACTOR_RAILROAD_TRAFFIC
    </td>
    <td>
    Except railroad traffic.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1024-16.png
    </td>
    <td>
    StVO 1024-16
    </td>
    <td>
    \\c #ACTOR_TRAMS
    </td>
    <td>
    Except trams.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1024-17.png
    </td>
    <td>
    StVO 1024-17
    </td>
    <td>
    \\c #ACTOR_TRACTORS
    </td>
    <td>
    Except tractors.
    \\note In the German StVO, tractors are defined as motorized
    vehicles that are not allowed to, or cannot, drive faster
    than 25 km/h.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1024-18.png
    </td>
    <td>
    StVO 1024-18
    </td>
    <td>
    \\c #ACTOR_HORSE_CARRIAGES
    </td>
    <td>
    Except horse carriages.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1024-19.png
    </td>
    <td>
    StVO 1024-19
    </td>
    <td>
    \\c #ACTOR_CAMPERS
    </td>
    <td>
    Except campers with a maximum allowed mass.
    <br>
    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit (e.g. t) to indicate the mass.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1024-20.png
    </td>
    <td>
    StVO 1024-20
    </td>
    <td>
    \\c #ACTOR_ELECTRIC_VEHICLES
    </td>
    <td>
    Except electric vehicles.
    <br>
    See also: [\\c StVO 1026-61](\\ref EV_EXCEPT_T).
    \\anchor EV_EXCEPT_I
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1026-31.png
    </td>
    <td>
    StVO 1026-31
    </td>
    <td>
    \\c #ACTOR_BUSES
    </td>
    <td>
    Except buses in occasional service.
    <br>
    Set \\c TrafficSignValue::text as "im Gelegenheitsverkehr".
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1026-32.png
    </td>
    <td>
    StVO 1026-32
    </td>
    <td>
    \\c #ACTOR_PUBLIC_TRANSPORT_VEHICLES
    </td>
    <td>
    Except public transport vehicles.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1026-33.png
    </td>
    <td>
    StVO 1026-33
    </td>
    <td>
    \\c #ACTOR_EMERGENCY_VEHICLES
    </td>
    <td>
    Except emergency vehicles.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1026-34.png
    </td>
    <td>
    StVO 1026-34
    </td>
    <td>
    \\c #ACTOR_MEDICAL_VEHICLES
    </td>
    <td>
    Except medical vehicles.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1026-35.png
    </td>
    <td>
    StVO 1026-35
    </td>
    <td>
    \\c #ACTOR_DELIVERY_VEHICLES
    </td>
    <td>
    Except delivery vehicles.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1026-36.png
    </td>
    <td>
    StVO 1026-36
    </td>
    <td>
    \\c #ACTOR_AGRICULTURAL_VEHICLES
    </td>
    <td>
    Except agricultural vehicles.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1026-37.png
    </td>
    <td>
    StVO 1026-37
    </td>
    <td>
    \\c #ACTOR_FORESTRY_VEHICLES
    </td>
    <td>
    Except forestry vehicles.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1026-38.png
    </td>
    <td>
    StVO 1026-38
    </td>
    <td>
    Two actors: one set to \\c #ACTOR_FORESTRY_VEHICLES and
    the other one set to \\c #ACTOR_AGRICULTURAL_VEHICLES.
    </td>
    <td>
    Except agricultural and forestry vehicles.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1026-39.png
    </td>
    <td>
    StVO 1026-39
    </td>
    <td>
    \\c #ACTOR_OPERATIONAL_AND_UTILITY_VEHICLES
    </td>
    <td>
    Except operational and utility vehicles.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1026-60.png
    </td>
    <td>
    StVO 1026-60
    </td>
    <td>
    \\c #ACTOR_ELECTRIC_VEHICLES
    </td>
    <td>
    Except electric vehicles during the charging process.
    <br>
    Set \\c TrafficSignValue::text as
    &rdquo;w&auml;hrend des Ladevorgangs&rdquo;
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1026-61.png
    </td>
    <td>
    StVO 1026-61
    </td>
    <td>
    \\c #ACTOR_ELECTRIC_VEHICLES
    </td>
    <td>
    Except electric vehicles.
    <br>
    See also: [\\c StVO 1024-20](\\ref EV_EXCEPT_I).
    \\anchor EV_EXCEPT_T
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1026-62.png
    </td>
    <td>
    StVO 1026-62
    </td>
    <td>
    \\c #ACTOR_SLURRY_TRANSPORT
    </td>
    <td>
    Except slurry transport.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1026-63.png
    </td>
    <td>
    StVO 1026-63
    </td>
    <td>
    \\c #ACTOR_EBIKES
    </td>
    <td>
    Except e-bikes.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1028-30.png
    </td>
    <td>
    StVO 1028-30
    </td>
    <td>
    \\c #ACTOR_CONSTRUCTION_VEHICLES
    </td>
    <td>
    Except construction vehicles.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1028-32.png
    </td>
    <td>
    StVO 1028-32
    </td>
    <td>
    \\c #ACTOR_RESIDENTS
    </td>
    <td>
    Exception for residents up to construction site.
    <br>
    Set \\c TrafficSignValue::text as "bis Baustelle"
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1028-34.png
    </td>
    <td>
    StVO 1028-34
    </td>
    <td>
    \\c #ACTOR_FERRY_USERS
    </td>
    <td>
    Except ferry users.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1031-50.png
    </td>
    <td>
    StVO 1031-50
    </td>
    <td>
    Three actors, set to respectively \\c
    #ACTOR_VEHICLES_WITH_RED_BADGES,
    \\c #ACTOR_VEHICLES_WITH_YELLOW_BADGES and \\c
    #ACTOR_VEHICLES_WITH_GREEN_BADGES
    </td>
    <td>
    Vehicles with red, yellow or green badges allowed
    \\note Exemption from traffic ban according to 40(1) of the
    Federal Immission Control Act.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1031-51.png
    </td>
    <td>
    StVO 1031-51
    </td>
    <td>
    Two actors, set to respectively \\c
    #ACTOR_VEHICLES_WITH_YELLOW_BADGES and \\c
    #ACTOR_VEHICLES_WITH_GREEN_BADGES
    </td>
    <td>
    Vehicles with yellow or green badges allowed
    \\note Exemption from traffic ban according to 40(1) of the
    Federal Immission Control Act.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1031-52.png
    </td>
    <td>
    StVO 1031-52
    </td>
    <td>
    \\c #ACTOR_VEHICLES_WITH_GREEN_BADGES
    </td>
    <td>
    Vehicles with green badges allowed
    \\note Exemption from traffic ban according to 40(1) of the
    Federal Immission Control Act.
    </td>
    </tr>
    </table>
    """

    VALID_FOR_DISTANCE = 3
    """
    Traffic sign is valid for a certain distance.
    <table border="0">
    <tr>
    <td>
    \\image html 1001-30.png "StVO 1001-30"
    <td>
    <!--
    \\image html 1001-31.png
    -->
    <td>
    <B>
    StVO 1001-31
    </B>
    <td>
    \\image html 1001-32.png "StVO 1001-32"
    <td>
    \\image html 1001-33.png "StVO 1001-33"
    <td>
    \\image html 1001-34.png "StVO 1001-34"
    <td>
    \\image html 1001-35.png "StVO 1001-35"
    </tr>
    </table>

    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit (e.g. m) to indicate the
    distance.
    """

    PRIORITY_ROAD_BOTTOM_LEFT_FOUR_WAY = 27
    """
    Priority road from bottom to left in the intersection.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 1002-10.png
    </td>
    <td>
    StVO 1002-10
    </td>
    </tr>
    </table>
    """

    PRIORITY_ROAD_TOP_LEFT_FOUR_WAY = 28
    """
    Priority road from top to left in the intersection.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td style="transform:scaleY(-1)">
    \\image html 1002-10.png
    </td>
    <td>
    StVO 1002-11
    </td>
    </tr>
    </table>
    """

    PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_STRAIGHT = 32
    """
    Priority road from bottom to left, junction from above.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 1002-12.png
    </td>
    <td>
    StVO 1002-12
    </td>
    </tr>
    </table>
    """

    PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_SIDEWAYS = 33
    """
    Priority road from bottom to left, junction from the right.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td style="transform:scaleX(-1) rotate(-90deg)">
    \\image html 1002-12.png
    </td>
    <td>
    StVO 1002-13
    </td>
    </tr>
    </table>
    """

    PRIORITY_ROAD_TOP_LEFT_THREE_WAY_STRAIGHT = 34
    """
    Priority road from top to left, junction from below.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td style="transform:scaleY(-1)">
    \\image html 1002-12.png
    </td>
    <td>
    StVO 1002-14
    </td>
    </tr>
    </table>
    """

    PRIORITY_ROAD_BOTTOM_RIGHT_FOUR_WAY = 29
    """
    Priority road from bottom to right in the intersection.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td style="transform:rotate(270deg)">
    \\image html 1002-10.png
    </td>
    <td>
    StVO 1002-20
    </td>
    </tr>
    </table>
    """

    PRIORITY_ROAD_TOP_RIGHT_FOUR_WAY = 31
    """
    Priority road from top to right in the intersection.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td style="transform:rotate(180deg)">
    \\image html 1002-10.png
    </td>
    <td>
    StVO 1002-21
    </td>
    </tr>
    </table>
    """

    PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_STRAIGHT = 35
    """
    Priority road from bottom to right, junction from above.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 1002-12.png
    </td>
    <td>
    StVO 1002-22
    </td>
    </tr>
    </table>
    """

    PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_SIDEWAY = 36
    """
    Priority road from bottom to right, junction from the left.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td style="transform:rotate(-90deg)">
    \\image html 1002-12.png
    </td>
    <td>
    StVO 1002-23
    </td>
    </tr>
    </table>
    """

    PRIORITY_ROAD_TOP_RIGHT_THREE_WAY_STRAIGHT = 37
    """
    Priority road from top to right, junction from below.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td style="transform:rotate(180deg)">
    \\image html 1002-12.png
    </td>
    <td>
    StVO 1002-24
    </td>
    </tr>
    </table>
    """

    VALID_IN_DISTANCE = 4
    """
    Distance to the start of validity of the traffic sign.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 1004-30.png "StVO 1004-30"
    <td>
    \\image html 1004-31.png "StVO 1004-31"
    </table>

    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit (e.g. m) to indicate the
    distance.

    \\note For OSI 4.0 compatibility use \\c #TYPE_SPACE instead.
    """

    STOP_IN = 25
    """
    Stop in e.g. .. m.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 1004-32.png
    </td>
    <td>
    StVO 1004-32
    </td>
    </table>

    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit (e.g. m) to indicate the
    distance.

    \\note For OSI 4.0 compatibility use \\c #TYPE_SPACE instead.
    """

    LEFT_ARROW = 11
    """
    Direction, left-pointing.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 1000-10.png
    </td>
    <td>
    StVO 1000-10
    </td>
    </tr>
    </table>

    \\note For OSI 4.0 compatibility use \\c #TYPE_ARROW instead.
    """

    LEFT_BEND_ARROW = 13
    """
    Direction of potential danger, left-pointing.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 1000-11.png
    </td>
    <td>
    StVO 1000-11
    </td>
    </tr>
    </table>

    \\note For OSI 4.0 compatibility use \\c #TYPE_ARROW instead.
    """

    RIGHT_ARROW = 12
    """
    Direction, right-pointing.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 1000-10.png
    </td>
    <td>
    StVO 1000-20
    </td>
    </tr>
    </table>

    \\note For OSI 4.0 compatibility use \\c #TYPE_ARROW instead.
    """

    RIGHT_BEND_ARROW = 14
    """
    Direction of potential danger, right-pointing.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td style="transform:scaleX(-1)">
    \\image html 1000-11.png
    </td>
    <td>
    StVO 1000-21
    </td>
    </tr>
    </table>

    \\note For OSI 4.0 compatibility use \\c #TYPE_ARROW instead.
    """

    ACCIDENT = 40
    """
    Accident hazard.
    <table border="0">
    <tr>
    <td>
    \\image html 1006-31.png
    </td>
    <td>
    StVO 1006-31
    </td>
    </tr>
    </table>

    See also: [\\c TYPE_TEXT](\\ref ACCIDENT_TEXT).
    """

    SNOW = 9
    """
    Restriction of the validity of the traffic sign to snowy /
    icy conditions.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    <!--
    \\image html 1007-30.png
    -->
    </td>
    <td>
    StVO 1007-30
    </td>
    </tr>
    </table>

    \\note The identifier "StVO 1007-30" was used to denote a
    restriction of the validity of the traffic sign to snowy /
    icy conditions until the edition of 2013 of the official
    Catalog of Street Signs of the Federal Road Research
    Institute of Germany - BASt. Since the edition corresponding
    to 2017, "StVO 1007-30" is used to denote the hazard of oil
    trails. See [\\c TYPE_OIL](\\ref OIL_TEXT).
    """

    FOG = 8
    """
    Restriction of the validity of the traffic sign to foggy
    conditions.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 1007-61.png
    </td>
    <td>
    StVO 1007-61
    </td>
    </tr>
    </table>

    \\note For OSI 4.0 compatibility use \\c #TYPE_TEXT instead.
    """

    ROLLING_HIGHWAY_INFORMATION = 48
    """
    Information on rolling highway.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 1010-14.png
    </td>
    <td>
    StVO 1010-14
    </td>
    </tr>
    </table>
    """

    SERVICES = 47
    """
    Information about services.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 1010-15.png
    </td>
    <td>
    StVO 1010-15
    </td>
    </tr>
    </table>
    """

    TIME_RANGE = 5
    """
    Time range for validity of traffic sign.
    <table border="0">
    <tr>
    <td>
    \\image html 1040-30.png "StVO 1040-30"
    <td>
    \\image html 1042-33.png "StVO 1042-33"
    </tr>
    </table>

    - Use one \\c TrafficSignValue message to indicate the start
    of the time range and one \\c TrafficSignValue message to
    indicate the end of the time range. For each \\c
    TrafficSignValue, \\c TrafficSignValue::value indicates
    the time elapsed since midnight each day, and \\c
    TrafficSignValue::value_unit indicates the unit this time is
    expressed in, e.g. in min.
    - If including start and end days of the week, include two
    additional \\c TrafficSignValue messages. For these messages,
    use \\c TrafficSignValue::value_unit as \\c
    TrafficSignValue::UNIT_NO_UNIT and \\c
    TrafficSignValue::value as an \\c integer from 1 to 7,
    where 1 denotes Monday and 7 denotes Sunday.

    \\note For OSI 4.0 compatibility use \\c #TYPE_TIME instead.
    """

    PARKING_DISC_TIME_RESTRICTION = 43
    """
    Parking disc restrictions.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 1040-32.png
    </td>
    <td>
    StVO 1040-32
    </td>
    <td>
    Parking disc restriction
    </td>
    <td>
    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit (e.g. min) to indicate the
    allowed duration of parking.
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1040-33.png
    </td>
    <td>
    StVO 1040-33
    </td>
    <td>
    Parking disc restriction for marked parking areas
    </td>
    <td>
    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit (e.g. min) to indicate the
    allowed duration of parking. Set \\c TrafficSignValue::text
    to &rdquo;in gekennzeichneten Fl&auml;chen&rdquo;.
    </td>
    </tr>
    </table>
    """

    WEIGHT = 6
    """
    Restriction of the validity of the traffic sign depending on
    the vehicle's weight.
    <table border="0">
    <tr>
    <td>
    \\image html 1053-33.png "StVO 1053-33"
    <td>
    \\image html 1053-37.png "StVO 1053-37"
    <td>
    \\image html 1060-33.png "StVO 1060-33"
    </tr>
    </table>

    Use \\c TrafficSignValue::value and \\c
    TrafficSignValue::value_unit (e.g. in t) to indicate the
    weight.
    """

    WET = 44
    """
    If "wet surface".
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 1053-35.png
    </td>
    <td>
    StVO 1053-35
    </td>
    </tr>
    </table>
    """

    PARKING_CONSTRAINT = 42
    """
    Parking constraints.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 1053-38.png
    </td>
    <td>
    StVO 1053-38
    </td>
    <td>
    pull in crosswise
    </td>
    </tr>
    <tr>
    <td>
    \\image html 1053-39.png
    </td>
    <td>
    StVO 1053-39
    </td>
    <td>
    pull in diagonally
    </td>
    </tr>
    </table>
    """

    NO_WAITING_SIDE_STRIPES = 38
    """
    No parking, also on verges/shoulder.
    <table cellspacing="0" cellpadding="0">
    <tr>
    <td>
    \\image html 1060-31.png
    </td>
    <td>
    StVO 1060-31
    </td>
    </tr>
    </table>
    """

    RAIN = 7
    """
    Restriction of the validity of the traffic sign to wet /
    rainy conditions.

    (No German StVO-Nr., Austrian StVO 1960 supplementary sign
    g).
    """

    SNOW_RAIN = 10
    """
    Combined restriction of the validity of the traffic sign to
    rainy or snowy conditions denoted by a single supplementary
    sign (instead of two signs of \\c #TYPE_RAIN and \\c #TYPE_SNOW
    respectively).

    (StVO -, Austria)
    """

    NIGHT = 19
    """
    Valid at night.
    """

    STOP_4_WAY = 21
    """
    Stop 4 way.
    """

    TRUCK = 15
    """
    Trucks.

    \\note For OSI 4.0 compatibility use the message \\c Actor
    instead.
    """

    TRACTORS_MAY_BE_PASSED = 16
    """
    Tractors may be passed.

    \\note For OSI 4.0 compatibility use the message \\c Actor
    instead.
    """

    HAZARDOUS = 17
    """
    Vehicles transporting hazardous goods.

    \\note For OSI 4.0 compatibility use the message \\c Actor
    instead.
    """

    TRAILER = 18
    """
    Trailers.

    \\note For OSI 4.0 compatibility use the message \\c Actor
    instead.
    """

    ZONE = 20
    """
    Zone.

    \\note For OSI 4.0 compatibility use the message \\c Actor
    instead.
    """

    MOTORCYCLE = 22
    """
    Motorcycles.

    \\note For OSI 4.0 compatibility use the message \\c Actor
    instead.
    """

    MOTORCYCLE_ALLOWED = 23
    """
    Motorcycles allowed.

    \\note For OSI 4.0 compatibility use the message \\c Actor
    instead.
    """

    CAR = 24
    """
    Cars.

    \\note For OSI 4.0 compatibility use the message \\c Actor
    instead.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "TYPE_UNKNOWN",
            1: "TYPE_OTHER",
            2: "TYPE_NO_SIGN",
            41: "TYPE_TEXT",
            39: "TYPE_SPACE",
            26: "TYPE_TIME",
            30: "TYPE_ARROW",
            46: "TYPE_CONSTRAINED_TO",
            45: "TYPE_EXCEPT",
            3: "TYPE_VALID_FOR_DISTANCE",
            27: "TYPE_PRIORITY_ROAD_BOTTOM_LEFT_FOUR_WAY",
            28: "TYPE_PRIORITY_ROAD_TOP_LEFT_FOUR_WAY",
            32: "TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_STRAIGHT",
            33: "TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_SIDEWAYS",
            34: "TYPE_PRIORITY_ROAD_TOP_LEFT_THREE_WAY_STRAIGHT",
            29: "TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_FOUR_WAY",
            31: "TYPE_PRIORITY_ROAD_TOP_RIGHT_FOUR_WAY",
            35: "TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_STRAIGHT",
            36: "TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_SIDEWAY",
            37: "TYPE_PRIORITY_ROAD_TOP_RIGHT_THREE_WAY_STRAIGHT",
            4: "TYPE_VALID_IN_DISTANCE",
            25: "TYPE_STOP_IN",
            11: "TYPE_LEFT_ARROW",
            13: "TYPE_LEFT_BEND_ARROW",
            12: "TYPE_RIGHT_ARROW",
            14: "TYPE_RIGHT_BEND_ARROW",
            40: "TYPE_ACCIDENT",
            9: "TYPE_SNOW",
            8: "TYPE_FOG",
            48: "TYPE_ROLLING_HIGHWAY_INFORMATION",
            47: "TYPE_SERVICES",
            5: "TYPE_TIME_RANGE",
            43: "TYPE_PARKING_DISC_TIME_RESTRICTION",
            6: "TYPE_WEIGHT",
            44: "TYPE_WET",
            42: "TYPE_PARKING_CONSTRAINT",
            38: "TYPE_NO_WAITING_SIDE_STRIPES",
            7: "TYPE_RAIN",
            10: "TYPE_SNOW_RAIN",
            19: "TYPE_NIGHT",
            21: "TYPE_STOP_4_WAY",
            15: "TYPE_TRUCK",
            16: "TYPE_TRACTORS_MAY_BE_PASSED",
            17: "TYPE_HAZARDOUS",
            18: "TYPE_TRAILER",
            20: "TYPE_ZONE",
            22: "TYPE_MOTORCYCLE",
            23: "TYPE_MOTORCYCLE_ALLOWED",
            24: "TYPE_CAR",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "TYPE_UNKNOWN": 0,
            "TYPE_OTHER": 1,
            "TYPE_NO_SIGN": 2,
            "TYPE_TEXT": 41,
            "TYPE_SPACE": 39,
            "TYPE_TIME": 26,
            "TYPE_ARROW": 30,
            "TYPE_CONSTRAINED_TO": 46,
            "TYPE_EXCEPT": 45,
            "TYPE_VALID_FOR_DISTANCE": 3,
            "TYPE_PRIORITY_ROAD_BOTTOM_LEFT_FOUR_WAY": 27,
            "TYPE_PRIORITY_ROAD_TOP_LEFT_FOUR_WAY": 28,
            "TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_STRAIGHT": 32,
            "TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_SIDEWAYS": 33,
            "TYPE_PRIORITY_ROAD_TOP_LEFT_THREE_WAY_STRAIGHT": 34,
            "TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_FOUR_WAY": 29,
            "TYPE_PRIORITY_ROAD_TOP_RIGHT_FOUR_WAY": 31,
            "TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_STRAIGHT": 35,
            "TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_SIDEWAY": 36,
            "TYPE_PRIORITY_ROAD_TOP_RIGHT_THREE_WAY_STRAIGHT": 37,
            "TYPE_VALID_IN_DISTANCE": 4,
            "TYPE_STOP_IN": 25,
            "TYPE_LEFT_ARROW": 11,
            "TYPE_LEFT_BEND_ARROW": 13,
            "TYPE_RIGHT_ARROW": 12,
            "TYPE_RIGHT_BEND_ARROW": 14,
            "TYPE_ACCIDENT": 40,
            "TYPE_SNOW": 9,
            "TYPE_FOG": 8,
            "TYPE_ROLLING_HIGHWAY_INFORMATION": 48,
            "TYPE_SERVICES": 47,
            "TYPE_TIME_RANGE": 5,
            "TYPE_PARKING_DISC_TIME_RESTRICTION": 43,
            "TYPE_WEIGHT": 6,
            "TYPE_WET": 44,
            "TYPE_PARKING_CONSTRAINT": 42,
            "TYPE_NO_WAITING_SIDE_STRIPES": 38,
            "TYPE_RAIN": 7,
            "TYPE_SNOW_RAIN": 10,
            "TYPE_NIGHT": 19,
            "TYPE_STOP_4_WAY": 21,
            "TYPE_TRUCK": 15,
            "TYPE_TRACTORS_MAY_BE_PASSED": 16,
            "TYPE_HAZARDOUS": 17,
            "TYPE_TRAILER": 18,
            "TYPE_ZONE": 20,
            "TYPE_MOTORCYCLE": 22,
            "TYPE_MOTORCYCLE_ALLOWED": 23,
            "TYPE_CAR": 24,
        }


class TrafficSignVariability(betterproto2.Enum):
    """
    Definition of the variability of a traffic sign.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_TRAFFICSIGN_PROTO_DESCRIPTOR.enum_types_by_name[
            "TrafficSign.Variability"
        ]

    UNKNOWN = 0
    """
    Variability type of sign is unknown (must not be used in ground
    truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) variability.
    """

    FIXED = 2
    """
    Sign that can change neither semantically nor positionally, e.g. a
    fixed, immutable, non-temporary traffic sign.
    """

    VARIABLE = 3
    """
    Sign that can change semantically and/or positionally, i.e. it is
    left unspecified in which way the sign may change.

    \\note This value represents a legacy definition. If possible, please
    use the more specific values below to indicate the exact nature of
    variability.
    """

    MOVABLE = 4
    """
    Sign that can change positionally but not semantically, e.g. a
    temporary, immutable traffic sign at construction site.
    """

    MUTABLE = 5
    """
    Sign that can change semantically but not positionally, e.g. a
    digital traffic sign on traffic sign gantry, or an analog prism
    sign.
    """

    MOVABLE_AND_MUTABLE = 6
    """
    Sign that can change both semantically and positionally, e.g. a
    temporary, digital traffic sign at a construction site, or a digital
    traffic sign attached to a road works vehicle.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "VARIABILITY_UNKNOWN",
            1: "VARIABILITY_OTHER",
            2: "VARIABILITY_FIXED",
            3: "VARIABILITY_VARIABLE",
            4: "VARIABILITY_MOVABLE",
            5: "VARIABILITY_MUTABLE",
            6: "VARIABILITY_MOVABLE_AND_MUTABLE",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "VARIABILITY_UNKNOWN": 0,
            "VARIABILITY_OTHER": 1,
            "VARIABILITY_FIXED": 2,
            "VARIABILITY_VARIABLE": 3,
            "VARIABILITY_MOVABLE": 4,
            "VARIABILITY_MUTABLE": 5,
            "VARIABILITY_MOVABLE_AND_MUTABLE": 6,
        }


class TrafficSignValueUnit(betterproto2.Enum):
    """
    Unit for values on traffic sign.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_TRAFFICSIGN_PROTO_DESCRIPTOR.enum_types_by_name[
            "TrafficSignValue.Unit"
        ]

    UNKNOWN = 0
    """
    Unit of the sign's value is unknown (must not be used in ground
    truth).
    """

    OTHER = 1
    """
    Other (unspecified but known) unit of the sign's value.
    """

    NO_UNIT = 2
    """
    Value without unit.
    """

    KILOMETER_PER_HOUR = 3
    """
    Velocity.
    Kilometers per hour.

    Unit: km/h
    """

    MILE_PER_HOUR = 4
    """
    Velocity.
    Miles per hour.

    Unit: mph
    """

    METER = 5
    """
    Length.
    Meter.

    Unit: m
    """

    KILOMETER = 6
    """
    Length.
    Kilometer.

    Unit: km
    """

    FEET = 7
    """
    Length.
    Feet.

    Unit: ft
    """

    MILE = 8
    """
    Length.
    Mile.

    Unit: mile
    """

    METRIC_TON = 9
    """
    Weight.
    Ton.

    Unit: t
    """

    LONG_TON = 10
    """
    Weight.
    Long ton UK 1,016.047 kg.

    Unit: tn. l.
    """

    SHORT_TON = 11
    """
    Weight.
    Short ton USA 907.1847 kg.

    Unit: tn. sh.
    """

    HOUR = 15
    """
    Time of day.
    Hours since midnight. Starting with 0.

    Unit: h
    """

    MINUTES = 12
    """
    Time of day.
    Minutes since last hour. Starting with 0.

    Unit: min
    """

    DAY_OF_MONTH = 16
    """
    Day of the month.
    Starting with 1.
    """

    DAY = 13
    """
    Day of the week.
    Days since Monday. Monday = 0; Tuesday = 1; ...

    \\note For consistency this field will be renamed to UNIT_DAY_OF_WEEK in v4.0.0 .
    """

    PERCENTAGE = 14
    """
    Percentage.
    Value.

    Unit: %
    """

    DURATION_DAY = 17
    """
    Duration in days.

    Unit: day
    """

    DURATION_HOUR = 18
    """
    Duration in hours.

    Unit: h
    """

    DURATION_MINUTE = 19
    """
    Duration in minutes.

    Unit: min
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "UNIT_UNKNOWN",
            1: "UNIT_OTHER",
            2: "UNIT_NO_UNIT",
            3: "UNIT_KILOMETER_PER_HOUR",
            4: "UNIT_MILE_PER_HOUR",
            5: "UNIT_METER",
            6: "UNIT_KILOMETER",
            7: "UNIT_FEET",
            8: "UNIT_MILE",
            9: "UNIT_METRIC_TON",
            10: "UNIT_LONG_TON",
            11: "UNIT_SHORT_TON",
            15: "UNIT_HOUR",
            12: "UNIT_MINUTES",
            16: "UNIT_DAY_OF_MONTH",
            13: "UNIT_DAY",
            14: "UNIT_PERCENTAGE",
            17: "UNIT_DURATION_DAY",
            18: "UNIT_DURATION_HOUR",
            19: "UNIT_DURATION_MINUTE",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "UNIT_UNKNOWN": 0,
            "UNIT_OTHER": 1,
            "UNIT_NO_UNIT": 2,
            "UNIT_KILOMETER_PER_HOUR": 3,
            "UNIT_MILE_PER_HOUR": 4,
            "UNIT_METER": 5,
            "UNIT_KILOMETER": 6,
            "UNIT_FEET": 7,
            "UNIT_MILE": 8,
            "UNIT_METRIC_TON": 9,
            "UNIT_LONG_TON": 10,
            "UNIT_SHORT_TON": 11,
            "UNIT_HOUR": 15,
            "UNIT_MINUTES": 12,
            "UNIT_DAY_OF_MONTH": 16,
            "UNIT_DAY": 13,
            "UNIT_PERCENTAGE": 14,
            "UNIT_DURATION_DAY": 17,
            "UNIT_DURATION_HOUR": 18,
            "UNIT_DURATION_MINUTE": 19,
        }


class UltrasonicSpecificObjectDataTrend(betterproto2.Enum):
    """

    Describes the general moving direction of the detection.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_SENSORSPECIFIC_PROTO_DESCRIPTOR.enum_types_by_name[
            "UltrasonicSpecificObjectData.Trend"
        ]

    UNKNOWN = 0
    """
    Unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known).
    """

    CONSTANT_APPROACHING = 2
    """
    Distance (object, sensor) is constant. The object has approached in
    the past before it was constant.
    """

    CONSTANT = 3
    """
    Distance (object, sensor) is constant. The object has departed in the
    past before it was constant or there is no history.
    """

    APPROACHING = 4
    """
    Distance (object, sensor) is decreasing.
    """

    DEPARTING = 5
    """
    Distance (object, sensor) is increasing.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "TREND_UNKNOWN",
            1: "TREND_OTHER",
            2: "TREND_CONSTANT_APPROACHING",
            3: "TREND_CONSTANT",
            4: "TREND_APPROACHING",
            5: "TREND_DEPARTING",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "TREND_UNKNOWN": 0,
            "TREND_OTHER": 1,
            "TREND_CONSTANT_APPROACHING": 2,
            "TREND_CONSTANT": 3,
            "TREND_APPROACHING": 4,
            "TREND_DEPARTING": 5,
        }


class UltrasonicSpecificObjectDataTrilaterationStatus(betterproto2.Enum):
    """

    This indicates if the object was calculated based on one or multiple
    sensors.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> EnumDescriptor:
        return OSI_SENSORSPECIFIC_PROTO_DESCRIPTOR.enum_types_by_name[
            "UltrasonicSpecificObjectData.TrilaterationStatus"
        ]

    UNKNOWN = 0
    """
    Unknown (must not be used in ground truth).
    """

    OTHER = 1
    """
    Other (unspecified but known).
    """

    NOT_TRILATERATED = 2
    """
    No trilateration used.
    """

    TRILATERATED = 3
    """
    Trilateration used.
    """

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "TRILATERATION_STATUS_UNKNOWN",
            1: "TRILATERATION_STATUS_OTHER",
            2: "TRILATERATION_STATUS_NOT_TRILATERATED",
            3: "TRILATERATION_STATUS_TRILATERATED",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "TRILATERATION_STATUS_UNKNOWN": 0,
            "TRILATERATION_STATUS_OTHER": 1,
            "TRILATERATION_STATUS_NOT_TRILATERATED": 2,
            "TRILATERATION_STATUS_TRILATERATED": 3,
        }


@dataclass(eq=False, repr=False)
class BaseMoving(betterproto2.Message):
    """

    \\brief The base attributes of an object that is moving.

    This includes the \\c MovingObject messages.

    \\image html OSI_BaseMoving.svg

    \\image html OSI_BaseMoving_Top.svg

    E.g. a vehicle is a base moving object.

    All coordinates and orientations from ground truth objects are relative to
    the global ground truth frame. All coordinates and orientations
    from detected objects are relative to the host vehicle frame
    (see: \\c MovingObject vehicle reference point).
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["BaseMoving"]

    dimension: "Dimension3D | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The 3D dimension of the moving object (its bounding box).

    \\note The \\c #dimension must completely enclose the geometry of the
    \\c BaseMoving with the exception of the side mirrors for vehicles.

    \\note The bounding box does NOT include side mirrors for vehicles.
    """

    position: "Vector3D | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The reference point for position and orientation: the center (x,y,z) of
    the bounding box.
    """

    orientation: "Orientation3D | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The relative orientation of the moving object w.r.t. its parent frame,
    noted in the parent frame. The orientation becomes global/absolute if
    the parent frame is inertial (all parent frames up to ground truth).

    \\f$ Origin_{\\text{base moving entity}} :=
    Rotation_{yaw,pitch,roll}( \\f$ \\c #orientation \\f$ )*
    (Origin_{\\text{parent coord system}} -
    \\f$ \\c #position \\f$ ) \\f$

    \\note There may be some constraints how to align the orientation w.r.t.
    to some stationary object's or entity's definition.
    """

    velocity: "Vector3D | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The relative velocity of the moving object w.r.t. the parent frame,
    noted in the parent frame. The velocity becomes global/absolute if
    the parent frame does is inertial (all parent frames up to ground truth).

    \\c #position \\f$ (t) := \\f$ \\c #position \\f$ (t-dt)+ \\f$ \\c #velocity \\f$
    *dt \\f$
    """

    acceleration: "Vector3D | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The relative acceleration of the moving object w.r.t. its parent frame,
    noted in the parent frame. The acceleration becomes global/absolute if
    the parent frame is inertial (all parent frames up to ground truth).

    \\c #position \\f$ (t) := \\f$ \\c #position \\f$ (t-dt)+ \\f$ \\c #velocity \\f$
    *dt+ \\f$ \\c #acceleration \\f$ /2*dt^2\\f$

    \\c #velocity \\f$ (t) := \\f$ \\c #velocity \\f$ (t-dt)+ \\f$ \\c #acceleration
    \\f$ *dt \\f$
    """

    orientation_rate: "Orientation3D | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The relative orientation rate of the moving object w.r.t. its parent
    frame and parent orientation rate in the center point of the bounding box
    (origin of the bounding box frame), noted in the parent frame.
    The orientation becomes global/absolute if the parent frame is inertial
    (all parent frames up to ground truth).

    \\c #orientation \\f$ .yaw(t) := \\f$ \\c #orientation_rate \\f$ .yaw(t) * dt
    + \\f$ \\c #orientation \\f$ .yaw(t-dt) \\f$

    \\c #orientation \\f$ .pitch(t) := \\f$ \\c #orientation_rate \\f$ .pitch(t) *
    dt + \\f$ \\c #orientation \\f$ .pitch(t-dt) \\f$

    \\c #orientation \\f$ .roll(t) := \\f$ \\c #orientation_rate \\f$ .roll(t) *
    dt + \\f$ \\c #orientation \\f$ .roll(t-dt)\\f$
    """

    orientation_acceleration: "Orientation3D | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The relative orientation acceleration of the moving object w.r.t. its
    parent frame and parent orientation acceleration in the center point of
    the bounding box (origin of the bounding box frame), noted in the parent
    frame. The orientation becomes global/absolute if the parent frame is
    inertial (all parent frames up to ground truth).

    \\c #orientation_rate \\f$ .yaw(t) := \\f$ \\c #orientation_acceleration \\f$
    .yaw(t) * dt + \\f$ \\c #orientation_rate \\f$ .yaw(t-dt) \\f$

    \\c #orientation_rate \\f$ .pitch(t) := \\f$ \\c #orientation_acceleration
    \\f$ .pitch(t) * dt
    + \\f$ \\c #orientation_rate \\f$ .pitch(t-dt) \\f$

    \\c #orientation_rate \\f$ .roll(t) := \\f$ \\c #orientation_acceleration \\f$
    .roll(t) * dt +
     \\f$ \\c #orientation_rate \\f$ .roll(t-dt) \\f$
    """

    base_polygon: "list[Vector2D]" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Usage as ground truth:
    The two dimensional (flat) contour of the object. This is an extension of
    the concept of a bounding box as defined by \\c Dimension3d. The contour
    is the projection of the object's outline onto the z-plane in the object
    frame (independent of its current position and orientation). The height
    is the same as the height of the bounding box.

    Usage as sensor data:
    The polygon describes the visible part of the object's contour.

    General definitions:
    The polygon is defined in the local object frame: x pointing forward and
    y to the left. The origin is the center of the bounding box.
    As ground truth, the polygon is closed by connecting the last with the
    first point. Therefore these two points must be different. The polygon
    must consist of at least three points. As sensor data, however, the
    polygon is open.
    The polygon is defined counter-clockwise.
    """

    bounding_box_section: "list[BoundingBox]" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Sub-divisions of the overall bounding box of the \\c BaseMoving object.

    The bounding box sections can include side mirrors, cargo, etc. for
    vehicles, as well as body-part sections for pedestrians. Note that for
    more precise pedestrian information \\c PedestrianAttributes can be used.

    \\note The bounding box sub-divisions can extend beyond the overall
    bounding box, however no actual geometry must reside outside of the
    overall bounding box, with the specific exception of the side mirrors.

    \\note If any sub-divisions are provided, then they must cover all
    occupied space of the overall bounding box. In other words, a consumer
    of this data is guaranteed that any part of the overall bounding box
    that is not covered by any sub-division is free of physical objects,
    and thus no collisions can occur there.
    """


default_message_pool.register_message("osi3", "BaseMoving", BaseMoving)


@dataclass(eq=False, repr=False)
class BaseStationary(betterproto2.Message):
    """

    \\brief The base attributes of a stationary object or entity.

    This includes the \\c StationaryObject , \\c TrafficSign ,
    \\c TrafficLight , \\c RoadMarking messages.

    \\image html OSI_BaseStationary.svg

    All coordinates and orientations from ground truth objects are relative to
    the global ground truth frame (see image). (All coordinates and orientations
    from detected objects are relative to the host vehicle frame (see:
    \\c Vehicle vehicle reference point).)
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["BaseStationary"]

    dimension: "Dimension3D | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The 3D dimensions of the stationary object (bounding box), e.g. a
    landmark.

    \\note The \\c #dimension must completely enclose the geometry of the
    \\c BaseStationary .
    """

    position: "Vector3D | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The reference point for position and orientation, i.e. the center (x,y,z)
    of the bounding box.
    """

    orientation: "Orientation3D | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The relative orientation of the stationary object w.r.t. its parent
    frame, noted in the parent frame. The orientation becomes global/absolute
    if the parent frame is inertial (all parent frames up to ground truth).

    \\f$ Origin_{\\text{base stationary entity}} :=
    Rotation_{yaw,pitch,roll}( \\f$ \\c #orientation \\f$ )*
    (Origin_{\\text{parent coord system}} -
    \\f$ \\c #position \\f$ )\\f$

    \\note There may be some constraints how to align the orientation w.r.t.
    to some stationary object's or entity's definition.
    """

    base_polygon: "list[Vector2D]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Usage as ground truth:
    The two dimensional (flat) contour of the object. This is an extension of
    the concept of a bounding box as defined by \\c Dimension3d. The contour
    is the projection of the object's outline onto the z-plane in the object
    frame (independent of its current position and orientation). The height
    is the same as the height of the bounding box.

    Usage as sensor data:
    The polygon describes the visible part of the object's contour.

    General definitions:
    The polygon is defined in the local object frame: x pointing forward and
    y to the left.
    The origin is the center of the bounding box.
    As ground truth, the polygon is closed by connecting the last with the
    first point. Therefore these two points must be different. The polygon
    must consist of at least three points.
    As sensor data, however, the polygon is open.
    The polygon is defined counter-clockwise.
    """

    bounding_box_section: "list[BoundingBox]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Sub-divisions of the overall bounding box of the \\c BaseStationary object.

    The bounding box sections can include separate parts on partially-opaque
    objects such as trees with a distinction between trunk and crown.

    \\note The bounding box sub-divisions can extend beyond the overall
    bounding box, however no actual geometry must reside outside of the
    overall bounding box.

    \\note If any sub-divisions are provided, then they must cover all
    occupied space of the overall bounding box. In other words, a consumer
    of this data is guaranteed that any part of the overall bounding box
    that is not covered by any sub-division is free of physical objects,
    and thus no collisions can occur there.
    """


default_message_pool.register_message("osi3", "BaseStationary", BaseStationary)


@dataclass(eq=False, repr=False)
class BoundingBox(betterproto2.Message):
    """
    \\brief A bounding box description.

    A bounding box representing a sub-section of its parent's overall
    dimension, either that of a \\c BaseMoving or \\c BaseStationary .

    The parent frame of the \\c BoundingBox is identical to the parent frame
    of the \\c MovingObject or \\c StationaryObject it is associated to. For
    example, if the parent object coordinates are given relative to the
    global coordinate system, then the \\c BoundingBox coordinates are also
    given relative to the global coordinate system.

    \\note The overall bounding box of the object is still defined using the
    dimension, position and orientation of the \\c BaseMoving or
    \\c BaseStationary .
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["BoundingBox"]

    dimension: "Dimension3D | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The 3D dimensions of the bounding box.
    """

    position: "Vector3D | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The 3D position of the bounding box. The position is the center
    of the bounding box and the pivot for the \\c dimension and \\c orientation.

    \\note The position should be within the same coordinate frame as
    its parent, not relative to coordinate frame of the parent object.
    The position becomes global/absolute if the parent frame is inertial
    (all parent frames up to ground truth).
    """

    orientation: "Orientation3D | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The 3D orientation of the bounding box.

    \\note The orientation should be within the same coordinate frame as
    its parent, not relative to the coordinate frame of the parent object.
    The orientation becomes global/absolute if the parent frame is inertial
    (all parent frames up to ground truth).
    """

    contained_object_type: "BoundingBoxType" = betterproto2.field(
        4, betterproto2.TYPE_ENUM, default_factory=lambda: BoundingBoxType(0)
    )
    """
    The type of object contained in the bounding box.
    """

    model_reference: "str" = betterproto2.field(5, betterproto2.TYPE_STRING)
    """
    Opaque reference of an associated 3D model of the bounding box.

    \\note It is implementation-specific how model_references are resolved to
    3d models. This means the coordinate system, model origin, and model
    orientation are also implementation-specific.
    """


default_message_pool.register_message("osi3", "BoundingBox", BoundingBox)


@dataclass(eq=False, repr=False)
class CameraDetection(betterproto2.Message):
    """

    \\brief Camera detection from the sensor.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_FEATUREDATA_PROTO_DESCRIPTOR.message_types_by_name["CameraDetection"]

    existence_probability: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Existence probability of the detection not based on history. Value does
    not depend on any past experience with similar detections.

    \\note Used as confidence measure where a low value means less confidence
    and a high value indicates strong confidence.

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 1
    \\endrules
    """

    object_id: "Identifier | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    ID of the detected object this detection is associated to.

    \\note ID = MAX(uint64) indicates no reference to an object.

    \\rules
    refers_to: DetectedObject
    \\endrules
    """

    time_difference: "Timestamp | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Difference to the base timestamp \\c
    SensorDetectionHeader::measurement_time.

    The timestamp of this detection :=
    \\c SensorDetectionHeader::measurement_time + \\c #time_difference.
    """

    image_shape_type: "CameraDetectionImageShapeType" = betterproto2.field(
        4,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: CameraDetectionImageShapeType(0),
    )
    """
    Definition of the image shape type of this detection.
    """

    shape_classification_background: "bool" = betterproto2.field(
        5, betterproto2.TYPE_BOOL
    )
    """
    The defined shape is background.
    The probability for this classification is at least
    \\c #shape_classification_probability.
    """

    shape_classification_foreground: "bool" = betterproto2.field(
        6, betterproto2.TYPE_BOOL
    )
    """
    The defined shape is foreground.
    The probability for this classification is at least
    \\c #shape_classification_probability.
    """

    shape_classification_flat: "bool" = betterproto2.field(7, betterproto2.TYPE_BOOL)
    """
    The defined shape is flat.
    The probability for this classification is at least
    \\c #shape_classification_probability.
    """

    shape_classification_upright: "bool" = betterproto2.field(8, betterproto2.TYPE_BOOL)
    """
    The defined shape is upright.
    The probability for this classification is at least
    \\c #shape_classification_probability.
    """

    shape_classification_ground: "bool" = betterproto2.field(9, betterproto2.TYPE_BOOL)
    """
    The defined shape is ground.
    The probability for this classification is at least
    \\c #shape_classification_probability.
    """

    shape_classification_sky: "bool" = betterproto2.field(10, betterproto2.TYPE_BOOL)
    """
    The defined shape is sky.
    The probability for this classification is at least
    \\c #shape_classification_probability.
    """

    shape_classification_vegetation: "bool" = betterproto2.field(
        11, betterproto2.TYPE_BOOL
    )
    """
    The defined shape is vegetation.
    The probability for this classification is at least
    \\c #shape_classification_probability.
    """

    shape_classification_road: "bool" = betterproto2.field(12, betterproto2.TYPE_BOOL)
    """
    The defined shape is a road.
    The probability for this classification is at least
    \\c #shape_classification_probability.
    """

    shape_classification_non_driving_lane: "bool" = betterproto2.field(
        13, betterproto2.TYPE_BOOL
    )
    """
    The defined shape is a non-driving lane (e.g. sidewalk).
    The probability for this classification is at least
    \\c #shape_classification_probability.
    """

    shape_classification_non_road: "bool" = betterproto2.field(
        14, betterproto2.TYPE_BOOL
    )
    """
    The defined shape is non-road (e.g. traffic island).
    The probability for this classification is at least
    \\c #shape_classification_probability.
    """

    shape_classification_stationary_object: "bool" = betterproto2.field(
        15, betterproto2.TYPE_BOOL
    )
    """
    The defined shape is a stationary object.
    The probability for this classification is at least
    \\c #shape_classification_probability.
    """

    shape_classification_moving_object: "bool" = betterproto2.field(
        16, betterproto2.TYPE_BOOL
    )
    """
    The defined shape is a possible moving object.
    The probability for this classification is at least
    \\c #shape_classification_probability.
    """

    shape_classification_landmark: "bool" = betterproto2.field(
        17, betterproto2.TYPE_BOOL
    )
    """
    The defined shape is a landmark.
    The probability for this classification is at least
    \\c #shape_classification_probability.
    """

    shape_classification_traffic_sign: "bool" = betterproto2.field(
        18, betterproto2.TYPE_BOOL
    )
    """
    The defined shape is a traffic sign.
    The probability for this classification is at least
    \\c #shape_classification_probability.
    """

    shape_classification_traffic_light: "bool" = betterproto2.field(
        19, betterproto2.TYPE_BOOL
    )
    """
    The defined shape is a traffic light.
    The probability for this classification is at least
    \\c #shape_classification_probability.
    """

    shape_classification_road_marking: "bool" = betterproto2.field(
        20, betterproto2.TYPE_BOOL
    )
    """
    The defined shape is a road marking sign.
    The probability for this classification is at least
    \\c #shape_classification_probability.
    """

    shape_classification_vehicle: "bool" = betterproto2.field(
        21, betterproto2.TYPE_BOOL
    )
    """
    The defined shape is a vehicle.
    The probability for this classification is at least
    \\c #shape_classification_probability.
    """

    shape_classification_pedestrian: "bool" = betterproto2.field(
        22, betterproto2.TYPE_BOOL
    )
    """
    The defined shape is a pedestrian.
    The probability for this classification is at least
    \\c #shape_classification_probability.
    """

    shape_classification_animal: "bool" = betterproto2.field(23, betterproto2.TYPE_BOOL)
    """
    The defined shape is an animal.
    The probability for this classification is at least
    \\c #shape_classification_probability.
    """

    shape_classification_pedestrian_front: "bool" = betterproto2.field(
        24, betterproto2.TYPE_BOOL
    )
    """
    The defined shape is a pedestrian seen by the sensor from the front.
    The probability for this classification is at least
    \\c #shape_classification_probability.
    """

    shape_classification_pedestrian_side: "bool" = betterproto2.field(
        25, betterproto2.TYPE_BOOL
    )
    """
    The defined shape is a pedestrian seen by the sensor from the side.
    The probability for this classification is at least
    \\c #shape_classification_probability.
    """

    shape_classification_pedestrian_rear: "bool" = betterproto2.field(
        26, betterproto2.TYPE_BOOL
    )
    """
    The defined shape is a pedestrian seen by the sensor from the rear.
    The probability for this classification is at least
    \\c #shape_classification_probability.
    """

    shape_classification_probability: "float" = betterproto2.field(
        27, betterproto2.TYPE_DOUBLE
    )
    """
    This probability defines the minimum probability for each selected
    shape classification.

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 1
    \\endrules
    """

    color: "CameraDetectionColor" = betterproto2.field(
        28, betterproto2.TYPE_ENUM, default_factory=lambda: CameraDetectionColor(0)
    )
    """
    The dominant color of the shape.

    \\attention DEPRECATED: This color enum will be removed in version
    4.0.0. Use the field \\c #color_description (\\c ColorDescription)
    instead.
    """

    color_probability: "float" = betterproto2.field(29, betterproto2.TYPE_DOUBLE)
    """
    The probability of the shape's color.

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 1
    \\endrules
    """

    ambiguity_id: "Identifier | None" = betterproto2.field(
        30, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    If one shape has different shape classifications and shape classification
    probability or color and color probability, all detections in this cycle
    have the same ambiguity ID.

    \\note ID = MAX(uint64) indicates no reference to an object.
    """

    first_point_index: "int" = betterproto2.field(31, betterproto2.TYPE_UINT32)
    """
    Index of the first point in the camera detection.
    """

    number_of_points: "int" = betterproto2.field(32, betterproto2.TYPE_UINT32)
    """
    Number of points which defines the shape.
    \\c #image_shape_type may restrict the number of possible values.

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    color_description: "ColorDescription | None" = betterproto2.field(
        33, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    
    The dominant color of the shape.
    """


default_message_pool.register_message("osi3", "CameraDetection", CameraDetection)


@dataclass(eq=False, repr=False)
class CameraDetectionData(betterproto2.Message):
    """

    \\brief Data from one camera sensor including a list of detections.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_FEATUREDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "CameraDetectionData"
        ]

    header: "SensorDetectionHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Header attributes of camera detection from one camera sensor.
    """

    specific_header: "CameraDetectionSpecificHeader | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Additional header attributes of camera detection from one camera sensor.
    """

    detection: "list[CameraDetection]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of camera detections.
    """

    point: "list[CameraPoint]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of points which are used by detections.
    """


default_message_pool.register_message(
    "osi3", "CameraDetectionData", CameraDetectionData
)


@dataclass(eq=False, repr=False)
class CameraDetectionSpecificHeader(betterproto2.Message):
    """

    \\brief Specific header extension for camera sensors.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_FEATUREDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "CameraDetectionSpecificHeader"
        ]

    number_of_valid_points: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)
    """
    The current number of points which all detections in the detections list
    refer.

    \\note This value has to be set if the list contains invalid points.

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """


default_message_pool.register_message(
    "osi3", "CameraDetectionSpecificHeader", CameraDetectionSpecificHeader
)


@dataclass(eq=False, repr=False)
class CameraPoint(betterproto2.Message):
    """

    \\brief Camera point from the sensor.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_FEATUREDATA_PROTO_DESCRIPTOR.message_types_by_name["CameraPoint"]

    existence_probability: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Existence probability of the point not based on history. Value does
    not depend on any past experience with similar points.

    \\note Used as confidence measure where a low value means less confidence
    and a high value indicates strong confidence.

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 1
    \\endrules
    """

    point: "Spherical3D | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Measured point referred by one camera detection given in spherical
    coordinates in the sensor coordinate system.
    """

    point_rmse: "Spherical3D | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Root mean squared error of the measured point.
    """


default_message_pool.register_message("osi3", "CameraPoint", CameraPoint)


@dataclass(eq=False, repr=False)
class CameraSensorView(betterproto2.Message):
    """

    \\brief Definition of the camera sensor view.

    Camera specific sensor view data.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORVIEW_PROTO_DESCRIPTOR.message_types_by_name["CameraSensorView"]

    view_configuration: "CameraSensorViewConfiguration | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Camera view configuration valid at the time the data was created.
    """

    image_data: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)
    """
    Raw image data.

    The raw image data in the memory layout specified by the camera    
    sensor input configuration. The pixel order is specified in 
    CameraSensorViewConfiguration.pixel_order with the 
    default value PIXEL_ORDER_DEFAULT (i.e. left-to-right, top-to-bottom).
    """


default_message_pool.register_message("osi3", "CameraSensorView", CameraSensorView)


@dataclass(eq=False, repr=False)
class CameraSensorViewConfiguration(betterproto2.Message):
    """

    \\brief The configuration settings for the Camera Sensor View to be provided
    by the environment simulation.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORVIEWCONFIGURATION_PROTO_DESCRIPTOR.message_types_by_name[
            "CameraSensorViewConfiguration"
        ]

    sensor_id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the sensor at host vehicle's mounting_position.

    This is the ID of the physical sensor, to be used in its detected
    features output; it is distinct from the ID of its virtual sensor.

    The ID is to be provided by the environment simulation, the sensor
    model is not in a position to provide a useful default value.
    """

    mounting_position: "MountingPosition | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The physical mounting position of the sensor (origin and orientation
    of the sensor coordinate system) given in vehicle coordinates [1].
    The physical position pertains to this detector individually, and
    governs the sensor-relative coordinates in features detected by this
    detector.

    \\arg \\b x-direction of sensor coordinate system: sensor viewing direction
    \\arg \\b z-direction of sensor coordinate system: sensor (up)
    \\arg \\b y-direction of sensor coordinate system: perpendicular to x and z
    right hand system

    \\par Reference:
    [1] DIN Deutsches Institut fuer Normung e. V. (2013). <em>DIN ISO 8855 Strassenfahrzeuge - Fahrzeugdynamik und Fahrverhalten - Begriffe</em>. (DIN ISO 8855:2013-11). Berlin, Germany.

    \\note The origin of vehicle's coordinate system in world frame is
    ( \\c MovingObject::base . \\c BaseMoving::position +
    Inverse_Rotation_yaw_pitch_roll( \\c MovingObject::base . \\c
    BaseMoving::orientation) * \\c
    MovingObject::VehicleAttributes::bbcenter_to_rear) . The orientation of
    the vehicle's coordinate system is equal to the orientation of the
    vehicle's bounding box \\c MovingObject::base . \\c
    BaseMoving::orientation. \\note A default position can be provided by the
    sensor model (e.g. to indicate the position the model was validated for),
    but this is optional; the environment simulation must provide a valid
    mounting position (based on the vehicle configuration) when setting the
    view configuration.
    """

    mounting_position_rmse: "MountingPosition | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The root mean squared error of the mounting position.
    """

    field_of_view_horizontal: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)
    """
    Field of View in horizontal orientation of the physical sensor.

    Viewing range: [- \\c #field_of_view_horizontal/2,  \\c
    #field_of_view_horizontal/2] azimuth in the sensor frame as defined in \\c
    Spherical3d.

    Unit: rad
    """

    field_of_view_vertical: "float" = betterproto2.field(5, betterproto2.TYPE_DOUBLE)
    """
    Field of View in vertical orientation of the physical sensor.

    Viewing range: [- \\c #field_of_view_vertical/2,  \\c
    #field_of_view_vertical/2] elevation in the sensor frame at zero azimuth
    as defined in \\c Spherical3d.

    Unit: rad
    """

    number_of_pixels_horizontal: "int" = betterproto2.field(6, betterproto2.TYPE_UINT32)
    """
    Number of pixels to produce across horizontal field of view.

    \\note This is a characteristic of the rendering engine of the
    environment simulation, not a direct characteristic of the sensor.

    \\rules
    is_greater_than_or_equal_to: 1
    \\endrules
    """

    number_of_pixels_vertical: "int" = betterproto2.field(7, betterproto2.TYPE_UINT32)
    """
    Number of pixels to produce across horizontal field of view.

    \\note This is a characteristic of the rendering engine of the
    environment simulation, not a direct characteristic of the sensor.

    \\rules
    is_greater_than_or_equal_to: 1
    \\endrules
    """

    channel_format: "list[CameraSensorViewConfigurationChannelFormat]" = (
        betterproto2.field(8, betterproto2.TYPE_ENUM, repeated=True)
    )
    """
    Format for image data (includes number, kind and format of channels).

    In the message provided by the sensor model, this field can
    be repeated and all values are acceptable to the model, with
    the most acceptable value being listed first, and the remaining
    values indicating alternatives in descending order of preference.

    In the message provided to the sensor model, this field must
    contain exactly one value, indicating the format of the image
    data being provided by the simulation environment - which must
    be one of the values the sensor model requested - or there
    must be no value, indicating that the simulation environment
    cannot provide image data in one of the requested formats.

    \\rules
    is_greater_than_or_equal_to: 1
    \\endrules
    """

    samples_per_pixel: "int" = betterproto2.field(9, betterproto2.TYPE_UINT32)
    """
    Number of samples per pixel.

    \\note This is a characteristic of the ray tracing engine of the
    environment simulation, not a direct characteristic of the sensor.

    \\rules
    is_greater_than_or_equal_to: 1
    \\endrules
    """

    max_number_of_interactions: "int" = betterproto2.field(10, betterproto2.TYPE_UINT32)
    """
    Maximum number of interactions to take into account.

    \\note This is a characteristic of the ray tracing engine of the
    environment simulation, not a direct characteristic of the sensor.

    \\rules
    is_greater_than_or_equal_to: 1
    \\endrules
    """

    wavelength_data: "list[WavelengthData]" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    In use-cases where a spectral ray-tracer is used, this message
    determines the range of the wavelength and its desired number
    of samples.
    """

    pixel_order: "CameraSensorViewConfigurationPixelOrder" = betterproto2.field(
        12,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: CameraSensorViewConfigurationPixelOrder(0),
    )
    """
    Indicates if and how the the pixel data is ordered

    The default value (PIXEL_ORDER_DEFAULT) indicates standard image
    pixel order (left-to-right, top-to-bottom). The other values can
    be used to indicate/request mirroring (right to left or bottom to top).

    \\note For rotations of the pixel data, use the camera coordinate system.
    """


default_message_pool.register_message(
    "osi3", "CameraSensorViewConfiguration", CameraSensorViewConfiguration
)


@dataclass(eq=False, repr=False)
class CameraSpecificObjectData(betterproto2.Message):
    """

    \\brief Message encapsulates all data for detected objects that is specific to
    camera sensors.

    currently no fields.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORSPECIFIC_PROTO_DESCRIPTOR.message_types_by_name[
            "CameraSpecificObjectData"
        ]

    pass


default_message_pool.register_message(
    "osi3", "CameraSpecificObjectData", CameraSpecificObjectData
)


@dataclass(eq=False, repr=False)
class ColorCmyk(betterproto2.Message):
    """

    \\brief CMYK colors model

    ColorCMYK provides values for cyan, magenta, yellow and key/black.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["ColorCMYK"]

    cyan: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Cyan ratio

    Range: [0,1]
    """

    magenta: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Magenta ratio

    Range: [0,1]
    """

    yellow: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    Yellow ratio

    Range: [0,1]
    """

    key: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)
    """
    Black ratio

    Range: [0,1]
    """


default_message_pool.register_message("osi3", "ColorCMYK", ColorCmyk)


@dataclass(eq=False, repr=False)
class ColorDescription(betterproto2.Message):
    """

    \\brief The description of a color within available color spaces.

    ColorDescription represents the visual, non-semantic appearance of an object, structure or feature within various available color spaces.

    Depending on the context, this may define the color of an object or structure a priori (e.g. GroundTruth objects)
    or describe a perceived color (e.g. CameraDetections).
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["ColorDescription"]

    grey: "ColorGrey | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Grayscale color model
    """

    rgb: "ColorRgb | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    RGB (Red, Green, Blue) color model
    """

    rgbir: "ColorRgbir | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    RGBIR (Red, Green, Blue, Infrared) color model
    """

    hsv: "ColorHsv | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    HSV (Hue, Saturation, Value) color model
    """

    luv: "ColorLuv | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    LUV (Luminance, U-coordinate, V-coordinate) color model
    """

    cmyk: "ColorCmyk | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    CMYK (Cyan, Magenta, Yellow, Key) color model
    """


default_message_pool.register_message("osi3", "ColorDescription", ColorDescription)


@dataclass(eq=False, repr=False)
class ColorGrey(betterproto2.Message):
    """

    \\brief Grayscale color model

    ColorGrey defines a grayscale.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["ColorGrey"]

    grey: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Definition of a grayscale

    Range: [0,1]
    """


default_message_pool.register_message("osi3", "ColorGrey", ColorGrey)


@dataclass(eq=False, repr=False)
class ColorHsv(betterproto2.Message):
    """

    \\brief HSV color model

    ColorHSV provides values for hue, saturation and value/brightness.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["ColorHSV"]

    hue: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Hue

    Unit: deg
    Range: [0,360[
    """

    saturation: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Saturation

    Range: [0,1]
    """

    value: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    Value

    Range: [0,1]
    """


default_message_pool.register_message("osi3", "ColorHSV", ColorHsv)


@dataclass(eq=False, repr=False)
class ColorLuv(betterproto2.Message):
    """

    \\brief LUV color model

    ColorLUV provides values for luminance, U- and V-coordinate.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["ColorLUV"]

    luminance: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Luminance

    Range: [0,1]
    """

    u: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    U-coordinate

    Range: [0,1]
    """

    v: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    V-Coordinate

    Range: [0,1]
    """


default_message_pool.register_message("osi3", "ColorLUV", ColorLuv)


@dataclass(eq=False, repr=False)
class ColorRgb(betterproto2.Message):
    """

    \\brief RGB color model

    ColorRGB provides values for red, green and blue.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["ColorRGB"]

    red: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Red ratio

    Range: [0,1]
    """

    green: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Green ratio

    Range: [0,1]
    """

    blue: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    Blue ratio

    Range: [0,1]
    """


default_message_pool.register_message("osi3", "ColorRGB", ColorRgb)


@dataclass(eq=False, repr=False)
class ColorRgbir(betterproto2.Message):
    """

    \\brief RGBIR color model

    ColorRGBIR provides values for red, green, blue and infrared.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["ColorRGBIR"]

    red: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Red ratio

    Range: [0,1]
    """

    green: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Green ratio

    Range: [0,1]
    """

    blue: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    Blue ratio

    Range: [0,1]
    """

    infrared: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)
    """
    Infrared

    Range: [0,1]
    """


default_message_pool.register_message("osi3", "ColorRGBIR", ColorRgbir)


@dataclass(eq=False, repr=False)
class DetectedEntityHeader(betterproto2.Message):
    """

    \\brief The header attributes of each detected entity.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "DetectedEntityHeader"
        ]

    measurement_time: "Timestamp | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Time stamp at which the measurement was taken (not the time at which it
    was processed or at which it is transmitted) in the global synchronized
    time.

    \\note See \\c SensorData::timestamp and \\c
    SensorData::last_measurement_time for detailed discussions on the
    semantics of time-related fields.
    """

    cycle_counter: "int" = betterproto2.field(2, betterproto2.TYPE_UINT64)
    """
    Continuous up counter to identify the cycle.
    """

    data_qualifier: "DetectedEntityHeaderDataQualifier" = betterproto2.field(
        3,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: DetectedEntityHeaderDataQualifier(0),
    )
    """
    Data Qualifier expresses to what extent the content of this event can be
    relied on.
    """


default_message_pool.register_message(
    "osi3", "DetectedEntityHeader", DetectedEntityHeader
)


@dataclass(eq=False, repr=False)
class DetectedItemHeader(betterproto2.Message):
    """

    \\brief The common information for a detected item as estimated by the
    sensor.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_DETECTEDOBJECT_PROTO_DESCRIPTOR.message_types_by_name[
            "DetectedItemHeader"
        ]

    tracking_id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Specific ID of the detected item as assigned by the sensor internally.
    Needs not to match with \\c #ground_truth_id.

    \\rules
    is_set
    \\endrules
    """

    ground_truth_id: "list[Identifier]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The ID of the original detected item in the ground truth.
    """

    existence_probability: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    The estimated probability that this detected item really exists, not
    based on history.

    \\note Use as confidence measure where a low value means less confidence
    and a high value indicates strong confidence.

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 1
    \\endrules
    """

    age: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)
    """
    The amount of time that this detected object has been continuously
    observed/tracked.

    \\note
    \\f$ Timestamp - Age := \\f$ 'point in time' when the object has
    been observed for the first time.

    Unit: s
    """

    measurement_state: "DetectedItemHeaderMeasurementState" = betterproto2.field(
        5,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: DetectedItemHeaderMeasurementState(0),
    )
    """
    The measurement state.
    """

    sensor_id: "list[Identifier]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of physical sensors which detected this detected item.

    If \\c SensorData has detected entities and all detections are missing,
    then e.g. the number of sensors can confirm the
    \\c #existence_probability.

    \\note This information can be determined via the detected entities'
    detections ( \\c ...Detection::object_id = 'this detected item' ) and
    the sensors (their IDs) to which these detections belong.
    """


default_message_pool.register_message("osi3", "DetectedItemHeader", DetectedItemHeader)


@dataclass(eq=False, repr=False)
class DetectedLane(betterproto2.Message):
    """

    \\brief A lane segment as detected by the sensor.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_DETECTEDLANE_PROTO_DESCRIPTOR.message_types_by_name["DetectedLane"]

    header: "DetectedItemHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Common information of one detected item.
    """

    candidate: "list[DetectedLaneCandidateLane]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of candidates for this lane as estimated by the sensor.
    """


default_message_pool.register_message("osi3", "DetectedLane", DetectedLane)


@dataclass(eq=False, repr=False)
class DetectedLaneCandidateLane(betterproto2.Message):
    """

    \\brief A candidate for a detected lane as estimated by the
    sensor.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_DETECTEDLANE_PROTO_DESCRIPTOR.message_types_by_name[
            "DetectedLane.CandidateLane"
        ]

    probability: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    The estimated probability that this candidate is the true value.

    \\note The sum of all \\c #probability must be one. This probability is
    given under the condition of
    \\c DetectedItemHeader::existence_probability.

    \\rules
    is_less_than_or_equal_to: 1
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    classification: "LaneClassification | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The classification of one lane that defines this candidate.

    \\note IDs, which are referenced in this message, usually
    reference to \\c DetectedXXX::tracking_id IDs.
    """


default_message_pool.register_message(
    "osi3", "DetectedLane.CandidateLane", DetectedLaneCandidateLane
)


@dataclass(eq=False, repr=False)
class DetectedLaneBoundary(betterproto2.Message):
    """

    \\brief A lane boundary segment as detected by the sensor.

    \\image html OSI_DetectedLaneBoundary.svg

    The parent frame of a detected lane boundary is the virtual sensor coordinate
    system.

    /note The virtual sensor coordinate system is relative to the vehicle coordinate
    system which has its origin in the center of the rear axle of the ego
    vehicle. This means if virtual sensor mounting position and orientation are
    set to (0,0,0) the virtual sensor coordinate system coincides with the
    vehicle coordinate system.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_DETECTEDLANE_PROTO_DESCRIPTOR.message_types_by_name[
            "DetectedLaneBoundary"
        ]

    header: "DetectedItemHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Common information of one detected item.
    """

    candidate: "list[DetectedLaneBoundaryCandidateLaneBoundary]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of candidates for this lane boundary as estimated by the
    sensor.
    """

    boundary_line: "list[LaneBoundaryBoundaryPoint]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of individual points defining the location of the lane boundary
    (as a list of segments).

    Since a \\c BoundaryPoint is part of a sequence, only the position
    attribute has to be set for each instance. All other values will be
    reused from the previous \\c BoundaryPoint in the sequence or set to
    default values if there is none or it was never set. For dashed lines,
    one \\c LaneBoundary::BoundaryPoint has to be at the start and another at
    the end of each dashed line segment. For Botts' dots lines, one \\c
    LaneBoundary::BoundaryPoint position has to define each Botts' dot.

    \\attention For \\c LaneBoundary::BoundaryPoint the same rules regarding
    maximum distance and approximation error apply as for \\c
    Lane::Classification::centerline.
    """

    boundary_line_rmse: "list[LaneBoundaryBoundaryPoint]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The root mean squared error of the \\c LaneBoundary::BoundaryPoint.
    Each \\c #candidate has the same \\c #boundary_line points and exact
    one \\c #boundary_line_rmse rmse confidence value is
    specified which is suitable for all candidates.
    """

    boundary_line_confidences: "list[float]" = betterproto2.field(
        5, betterproto2.TYPE_DOUBLE, repeated=True
    )
    """
    Confidence of the segments of the \\c LaneBoundary::BoundaryPoint.
    Each \\c #candidate has the same \\c #boundary_line points and exact
    one \\c #boundary_line_confidences confidence value is
    specified which is suitable for all candidates.

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 1
    \\endrules
    """

    color_description: "ColorDescription | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The visual color of the material of the lane boundary.

    \\note This does not represent the semantic classification but the visual
    appearance. For semantic classification of the lane boundary use the color
    field in \\c CandidateLaneBoundary::classification.
    """


default_message_pool.register_message(
    "osi3", "DetectedLaneBoundary", DetectedLaneBoundary
)


@dataclass(eq=False, repr=False)
class DetectedLaneBoundaryCandidateLaneBoundary(betterproto2.Message):
    """

    \\brief A candidate for a detected lane boundary as estimated by the
    sensor.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_DETECTEDLANE_PROTO_DESCRIPTOR.message_types_by_name[
            "DetectedLaneBoundary.CandidateLaneBoundary"
        ]

    probability: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    The estimated probability that this candidate is the true value.

    \\note The sum of all \\c #probability must be one. This probability is
    given under the condition of
    \\c DetectedItemHeader::existence_probability.

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 1
    \\endrules
    """

    classification: "LaneBoundaryClassification | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The classification of one lane boundary that defines this candidate.

    \\note IDs, which are referenced in this message, usually
    reference to \\c DetectedXXX::tracking_id IDs.
    """


default_message_pool.register_message(
    "osi3",
    "DetectedLaneBoundary.CandidateLaneBoundary",
    DetectedLaneBoundaryCandidateLaneBoundary,
)


@dataclass(eq=False, repr=False)
class DetectedMovingObject(betterproto2.Message):
    """

    \\brief Moving object in the environment as detected and perceived by the
    sensor.

    The parent frame of a detected moving object is the virtual sensor coordinate
    system.

    /note The virtual sensor coordinate system is relative to the vehicle coordinate
    system which has its origin in the center of the rear axle of the ego
    vehicle. This means if virtual sensor mounting position and orientation are
    set to (0,0,0) the virtual sensor coordinate system coincides with the
    vehicle coordinate system.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_DETECTEDOBJECT_PROTO_DESCRIPTOR.message_types_by_name[
            "DetectedMovingObject"
        ]

    header: "DetectedItemHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Common information of one detected item.
    """

    base: "BaseMoving | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The base parameters of the moving object.

    \\note The bounding box does NOT include mirrors for vehicles.
    \\note The height includes the ground_clearance. It always goes from the
    top to the ground.
    """

    base_rmse: "BaseMoving | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The root mean squared error of the base parameters of the detected
    moving object (e.g. car). \\c MovingObject::base has to be
    identical for all \\c #candidate moving objects.
    """

    reference_point: "DetectedMovingObjectReferencePoint" = betterproto2.field(
        4,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: DetectedMovingObjectReferencePoint(0),
    )
    """
    Reference point location specification of the sensor measurement
    (required to decouple sensor measurement, position and bounding box
    estimation) as used by the sensor (model).

    \\note Note that the value of this field has no impact on the value of
    object::position, which always references the center of the object /
    bounding box.
    """

    movement_state: "DetectedMovingObjectMovementState" = betterproto2.field(
        5,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: DetectedMovingObjectMovementState(0),
    )
    """
    Actual movement state w.r.t. the moving object history.
    """

    percentage_side_lane_left: "float" = betterproto2.field(6, betterproto2.TYPE_DOUBLE)
    """
    Percentage side lane left.

    Percentage value of the object width in the corresponding lane.

    \\note DEPRECATED: Use assigned_lane_percentage in MovingObjectClassification
    instead.

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 100
    \\endrules
    """

    percentage_side_lane_right: "float" = betterproto2.field(
        7, betterproto2.TYPE_DOUBLE
    )
    """
    Percentage side lane right.

    Percentage value of the object width in the corresponding lane.

    \\note DEPRECATED: Use assigned_lane_percentage in MovingObjectClassification
    instead.

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 100
    \\endrules
    """

    candidate: "list[DetectedMovingObjectCandidateMovingObject]" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of candidates for this moving object as estimated by the
    sensor (e.g. pedestrian, car).
    """

    color_description: "ColorDescription | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The dominating color of the material of the moving object.
    """

    radar_specifics: "RadarSpecificObjectData | None" = betterproto2.field(
        100, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Additional data that is specific to radar sensors.

    \\note Field needs not to be set if simulated sensor is not a radar
    sensor.
    """

    lidar_specifics: "LidarSpecificObjectData | None" = betterproto2.field(
        101, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Additional data that is specific to lidar sensors.

    \\note Field needs not to be set if simulated sensor is not a lidar
    sensor.
    """

    camera_specifics: "CameraSpecificObjectData | None" = betterproto2.field(
        102, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Additional data that is specific to camera sensors.

    \\note Field needs not to be set if simulated sensor is not a camera
    sensor.
    """

    ultrasonic_specifics: "UltrasonicSpecificObjectData | None" = betterproto2.field(
        103, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Additional data that is specific to ultrasonic sensors.

    \\note Field needs not to be set if simulated sensor is not an ultrasonic
    sensor.
    """


default_message_pool.register_message(
    "osi3", "DetectedMovingObject", DetectedMovingObject
)


@dataclass(eq=False, repr=False)
class DetectedMovingObjectCandidateMovingObject(betterproto2.Message):
    """

    \\brief A candidate for a detected moving object as estimated by the
    sensor.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_DETECTEDOBJECT_PROTO_DESCRIPTOR.message_types_by_name[
            "DetectedMovingObject.CandidateMovingObject"
        ]

    probability: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    The estimated probability that this candidate is the true value.

    \\note The sum of all \\c #probability must be one. This probability is
    given under the condition of
    \\c DetectedItemHeader::existence_probability.

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 1
    \\endrules
    """

    type: "MovingObjectType" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: MovingObjectType(0)
    )
    """
    The description of the moving object (e.g. car).
    """

    vehicle_classification: "MovingObjectVehicleClassification | None" = (
        betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Specific information about the classification of the vehicle.

    \\note This field is mandatory if the \\c CandidateMovingObject::type
    is \\c MovingObject::TYPE_VEHICLE .

    \\rules
    check_if this.type is_equal_to 2 else do_check is_set
    \\endrules
    """

    head_pose: "Orientation3D | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Pedestrian head pose for behavior prediction. Describes the head
    orientation w.r.t. the host vehicle orientation.
    The x-axis of the right-handed head frame is pointing along the
    pedestrian's straight ahead viewing direction (anterior), the y-axis lateral to the left,
    and the z-axis is pointing upwards (superior) [1].

    ``View_normal_base_coord_system =
    Inverse_Rotation(#head_pose)*Unit_vector_x``

    \\note This field is mandatory if the \\c CandidateMovingObject.type is
    \\c MovingObject::TYPE_PEDESTRIAN

    \\rules
    check_if this.type is_equal_to 3 else do_check is_set
    \\endrules

    \\par Reference:

    [1] Patton, K. T. & Thibodeau, G. A. (2015). <em>Anatomy & Physiology</em>. 9th Edition. Elsevier. Missouri, U.S.A. ISBN 978-0-323-34139-4. p. 1229.
    """

    upper_body_pose: "Orientation3D | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Pedestrian upper body pose for behavior prediction. Describes the
    upper body orientation w.r.t. the host vehicle orientation.
    The x-axis of the right-handed upper body frame is pointing along the
    pedestrian's upper body ventral (anterior) direction (i.e. usually
    pedestrian's intended moving direction), the y-axis lateral to the left,
    and the z-axis is pointing upwards (superior, to the pedestrian's head) [1].

    ``View_normal_base_coord_system =
    Inverse_Rotation(#upper_body_pose)*Unit_vector_x``

    \\note This field is mandatory if the \\c CandidateMovingObject::type
    is \\c MovingObject::TYPE_PEDESTRIAN

    \\rules
    check_if this.type is_equal_to 3 else do_check is_set
    \\endrules

    \\par Reference:
    [1] Patton, K. T. & Thibodeau, G. A. (2015). <em>Anatomy & Physiology</em>. 9th Edition. Elsevier. Missouri, U.S.A. ISBN 978-0-323-34139-4. p. 1229.
    """

    moving_object_classification: "MovingObjectMovingObjectClassification | None" = (
        betterproto2.field(6, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Specific information about the classification of a moving object.
    """


default_message_pool.register_message(
    "osi3",
    "DetectedMovingObject.CandidateMovingObject",
    DetectedMovingObjectCandidateMovingObject,
)


@dataclass(eq=False, repr=False)
class DetectedOccupant(betterproto2.Message):
    """

    \\brief A vehicle occupant as detected and perceived by an interior sensor.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_DETECTEDOCCUPANT_PROTO_DESCRIPTOR.message_types_by_name[
            "DetectedOccupant"
        ]

    header: "DetectedItemHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Common information of one detected item.
    """

    candidate: "list[DetectedOccupantCandidateOccupant]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of candidates for this occupant as estimated by the
    sensor.
    """


default_message_pool.register_message("osi3", "DetectedOccupant", DetectedOccupant)


@dataclass(eq=False, repr=False)
class DetectedOccupantCandidateOccupant(betterproto2.Message):
    """

    \\brief A candidate for a detected occupant as estimated by
    the sensor.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_DETECTEDOCCUPANT_PROTO_DESCRIPTOR.message_types_by_name[
            "DetectedOccupant.CandidateOccupant"
        ]

    probability: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    The estimated probability that this candidate is the true value.

    \\note The sum of all \\c #probability must be one. This probability is
    given under the condition of
    \\c DetectedItemHeader::existence_probability.

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 1
    \\endrules
    """

    classification: "OccupantClassification | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The detected vehicle occupant classification.

    \\note IDs, which are referenced in this message, usually
    reference to \\c DetectedXXX::tracking_id IDs.
    """


default_message_pool.register_message(
    "osi3", "DetectedOccupant.CandidateOccupant", DetectedOccupantCandidateOccupant
)


@dataclass(eq=False, repr=False)
class DetectedRoadMarking(betterproto2.Message):
    """

    \\brief A road marking in the environment as detected by the sensor.

    \\image html OSI_DetectedRoadMarking.svg

    The figure shows two STOP road markings (\\c
    DetectedRoadMarking::CandidateRoadMarking::classification). STOP \\c
    RoadMarking::Classification::type == \\c
    RoadMarking::Classification::TYPE_TEXTUAL_TRAFFIC_SIGN is marked, STOP \\c
    RoadMarking::Classification::type == \\c
    RoadMarking::Classification::TYPE_SYMBOLIC_TRAFFIC_SIGN is not marked.

    The parent frame of a detected road marking is the virtual sensor coordinate
    system.

    /note The virtual sensor coordinate system is relative to the vehicle coordinate
    system which has its origin in the center of the rear axle of the ego
    vehicle. This means if virtual sensor mounting position and orientation are
    set to (0,0,0) the virtual sensor coordinate system coincides with the
    vehicle coordinate system.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_DETECTEDROADMARKING_PROTO_DESCRIPTOR.message_types_by_name[
            "DetectedRoadMarking"
        ]

    header: "DetectedItemHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Common information of one detected item.
    """

    base: "BaseStationary | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The base parameters of the road marking.

    The orientation of the bounding box \\c #base
    \\c BaseStationary::orientation is defined as follows:
    The z-axis of the \\c BaseStationary::orientation is the vector from the
    'bottom' to the 'top' of the road marking's (i.e. painted traffic sign)
    2D image area.
    (Normally it is in the ground truth xy-plain.)
    The x-axis of the \\c BaseStationary::orientation is the view normal of
    the road marking's 2D image area.
    Normally this x-axis points to the sky.

    \\note If a valid unidirectional road marking is assigned to the host
    vehicle's current lane and the driving direction of the latter roughly
    matches the z-axis of the \\c #base \\c BaseStationary::orientation then
    the road marking is of relevance to (i.e. in effect for) the host
    vehicle.
    """

    base_rmse: "BaseStationary | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The root mean squared error of the base parameters of the detected
    road marking. \\c RoadMarking::base has to be identical for
    all \\c #candidate road markings.
    """

    candidate: "list[DetectedRoadMarkingCandidateRoadMarking]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of candidates for this road marking as estimated by the
    sensor.
    """

    color_description: "ColorDescription | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The visual color of the material of the road marking.

    \\note This does not represent the semantic classification but the visual
    appearance. For semantic classification of the road marking use the color
    field in \\c CandidateRoadMarking::classification.
    """


default_message_pool.register_message(
    "osi3", "DetectedRoadMarking", DetectedRoadMarking
)


@dataclass(eq=False, repr=False)
class DetectedRoadMarkingCandidateRoadMarking(betterproto2.Message):
    """

    \\brief A candidate for a detected road marking as estimated by the
    sensor.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_DETECTEDROADMARKING_PROTO_DESCRIPTOR.message_types_by_name[
            "DetectedRoadMarking.CandidateRoadMarking"
        ]

    probability: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    The estimated probability that this candidate is the true value.

    \\note The sum of all \\c #probability must be one. This probability is
    given under the condition of
    \\c DetectedItemHeader::existence_probability.

    \\rules
    is_less_than_or_equal_to: 1
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    classification: "RoadMarkingClassification | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The classification of the road marking.

    \\note IDs, which are referenced in this message, usually
    reference to \\c DetectedXXX::tracking_id IDs.
    """


default_message_pool.register_message(
    "osi3",
    "DetectedRoadMarking.CandidateRoadMarking",
    DetectedRoadMarkingCandidateRoadMarking,
)


@dataclass(eq=False, repr=False)
class DetectedStationaryObject(betterproto2.Message):
    """

    \\brief A stationary object (e.g. landmark) in the environment as detected by
    the sensor.

    \\image html OSI_DetectedStationaryObject.svg

    The parent frame of a detected stationary object is the virtual sensor
    coordinate system.

    /note The virtual sensor coordinate system is relative to the vehicle coordinate
    system which has its origin in the center of the rear axle of the ego
    vehicle. This means if virtual sensor mounting position and orientation are
    set to (0,0,0) the virtual sensor coordinate system coincides with the
    vehicle coordinate system.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_DETECTEDOBJECT_PROTO_DESCRIPTOR.message_types_by_name[
            "DetectedStationaryObject"
        ]

    header: "DetectedItemHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Common information of one detected item.
    """

    base: "BaseStationary | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The base parameters of the stationary object.
    """

    base_rmse: "BaseStationary | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The root mean squared error of the base parameters of the detected
    stationary object (e.g. landmark). \\c StationaryObject::base has to be
    identical for all \\c #candidate stationary objects.
    """

    candidate: "list[DetectedStationaryObjectCandidateStationaryObject]" = (
        betterproto2.field(4, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    A list of candidates for this stationary object as estimated by the
    sensor.
    """

    color_description: "ColorDescription | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The dominating color of the material of the structure.
    """

    radar_specifics: "RadarSpecificObjectData | None" = betterproto2.field(
        100, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Additional data that is specific to radar sensors.

    \\note Field needs not to be set if simulated sensor is not a radar
    sensor.
    """

    lidar_specifics: "LidarSpecificObjectData | None" = betterproto2.field(
        101, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Additional data that is specific to lidar sensors.

    \\note Field needs not to be set if simulated sensor is not a lidar
    sensor.
    """

    camera_specifics: "CameraSpecificObjectData | None" = betterproto2.field(
        102, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Additional data that is specific to camera sensors.

    \\note Field needs not to be set if simulated sensor is not a camera
    sensor.
    """

    ultrasonic_specifics: "UltrasonicSpecificObjectData | None" = betterproto2.field(
        103, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Additional data that is specific to ultrasonic sensors.

    \\note Field needs not to be set if simulated sensor is not an ultrasonic
    sensor.
    """


default_message_pool.register_message(
    "osi3", "DetectedStationaryObject", DetectedStationaryObject
)


@dataclass(eq=False, repr=False)
class DetectedStationaryObjectCandidateStationaryObject(betterproto2.Message):
    """

    \\brief A candidate for a detected stationary object as estimated
    by the sensor.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_DETECTEDOBJECT_PROTO_DESCRIPTOR.message_types_by_name[
            "DetectedStationaryObject.CandidateStationaryObject"
        ]

    probability: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    The estimated probability that this candidate is the true value.

    \\note The sum of all \\c #probability must be one. This probability is
    given under the condition of
    \\c DetectedItemHeader::existence_probability.

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 1
    \\endrules
    """

    classification: "StationaryObjectClassification | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The classification of the stationary object (e.g. landmark).
    """


default_message_pool.register_message(
    "osi3",
    "DetectedStationaryObject.CandidateStationaryObject",
    DetectedStationaryObjectCandidateStationaryObject,
)


@dataclass(eq=False, repr=False)
class DetectedTrafficLight(betterproto2.Message):
    """

    \\brief A traffic light in the environment as detected by the sensor.

    \\image html OSI_DetectedTrafficLight.svg

    One detected traffic light message defines a single 'bulb' and not a box of
    several bulbs, e.g. red, yellow, green are three separate detected traffic
    lights.

    The parent frame of a detected traffic light is the virtual sensor coordinate
    system.

    /note The virtual sensor coordinate system is relative to the vehicle coordinate
    system which has its origin in the center of the rear axle of the ego
    vehicle. This means if virtual sensor mounting position and orientation are
    set to (0,0,0) the virtual sensor coordinate system coincides with the
    vehicle coordinate system.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_DETECTEDTRAFFICLIGHT_PROTO_DESCRIPTOR.message_types_by_name[
            "DetectedTrafficLight"
        ]

    header: "DetectedItemHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Common information of one detected item.
    """

    base: "BaseStationary | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The base parameters of the traffic light.

    \\c BaseStationary::orientation x-axis is view normal of the traffic
    light's icon.
    """

    base_rmse: "BaseStationary | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The root mean squared error of the base parameters of the detected
    traffic light's geometry. \\c TrafficLight::base has to be identical
    for all \\c #candidate traffic lights.
    """

    candidate: "list[DetectedTrafficLightCandidateTrafficLight]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of candidates for this traffic light as estimated by the
    sensor.
    """

    color_description: "ColorDescription | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The visual color of the traffic light.

    \\note This does not represent the semantic classification but the visual
    appearance.  For semantic classification of the traffic light use the color
    field in \\c CandidateTrafficLight::classification.
    """


default_message_pool.register_message(
    "osi3", "DetectedTrafficLight", DetectedTrafficLight
)


@dataclass(eq=False, repr=False)
class DetectedTrafficLightCandidateTrafficLight(betterproto2.Message):
    """

    \\brief A candidate for a detected traffic light as estimated by
    the sensor.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_DETECTEDTRAFFICLIGHT_PROTO_DESCRIPTOR.message_types_by_name[
            "DetectedTrafficLight.CandidateTrafficLight"
        ]

    probability: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    The estimated probability that this candidate is the true value.

    \\note The sum of all \\c #probability must be one. This probability is
    given under the condition of
    \\c DetectedItemHeader::existence_probability.

    \\rules
    is_less_than_or_equal_to: 1
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    classification: "TrafficLightClassification | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The classification of one traffic light that define this candidate.

    \\note IDs, which are referenced in this message, usually
    reference to \\c DetectedXXX::tracking_id IDs.
    """


default_message_pool.register_message(
    "osi3",
    "DetectedTrafficLight.CandidateTrafficLight",
    DetectedTrafficLightCandidateTrafficLight,
)


@dataclass(eq=False, repr=False)
class DetectedTrafficSign(betterproto2.Message):
    """

    \\brief A traffic sign in the environment as detected by the sensor.

    \\image html OSI_DetectedSign.svg

    The parent frame of a detected traffic sign is the virtual sensor coordinate
    system.

    \\note The virtual sensor coordinate system is relative to the vehicle coordinate
    system which has its origin in the center of the rear axle of the ego
    vehicle. This means if virtual sensor mounting position and orientation are
    set to (0,0,0) the virtual sensor coordinate system coincides with the
    vehicle coordinate system.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_DETECTEDTRAFFICSIGN_PROTO_DESCRIPTOR.message_types_by_name[
            "DetectedTrafficSign"
        ]

    header: "DetectedItemHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Common information of one detected item.
    """

    main_sign: "DetectedTrafficSignDetectedMainSign | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The main sign as detected by the sensor.
    """

    supplementary_sign: "list[DetectedTrafficSignDetectedSupplementarySign]" = (
        betterproto2.field(3, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    A list of additional supplementary sign(s) as detected by the sensor.
    """


default_message_pool.register_message(
    "osi3", "DetectedTrafficSign", DetectedTrafficSign
)


@dataclass(eq=False, repr=False)
class DetectedTrafficSignDetectedMainSign(betterproto2.Message):
    """

    \\brief Candidates for a detected main sign as estimated by the sensor.

    \\image html OSI_DetectedMainSign.svg
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_DETECTEDTRAFFICSIGN_PROTO_DESCRIPTOR.message_types_by_name[
            "DetectedTrafficSign.DetectedMainSign"
        ]

    candidate: "list[DetectedTrafficSignDetectedMainSignCandidateMainSign]" = (
        betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    A list of candidates for this traffic sign as estimated by the
    sensor.

    \\note OSI uses singular instead of plural for repeated field names.
    """

    base: "BaseStationary | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The base parameters of the traffic sign.

    The orientation of the bounding box \\c #base
    ( \\c BaseStationary::orientation ) is defined as follows:

    The z-axis of the given \\c BaseStationary::orientation is the vector
    from the bottom to the top of the traffic sign's 2D image plate.
    (Normally it is equal to the ground truth z-axis.)

    The x-axis of the given \\c BaseStationary::orientation is view
    normal of the traffic sign's image.

    This x-axis points from the traffic sign's image in the direction
    from where a 'viewer' could see the traffic sign image.
    """

    base_rmse: "BaseStationary | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The root mean squared error of the base parameters of the detected
    traffic sign. \\c TrafficSign::MainSign::base has to be identical for
    all \\c #candidate traffic signs.
    """

    geometry: "DetectedTrafficSignDetectedMainSignGeometry" = betterproto2.field(
        4,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: DetectedTrafficSignDetectedMainSignGeometry(0),
    )
    """
    The estimated geometry of the traffic sign.
    """


default_message_pool.register_message(
    "osi3", "DetectedTrafficSign.DetectedMainSign", DetectedTrafficSignDetectedMainSign
)


@dataclass(eq=False, repr=False)
class DetectedTrafficSignDetectedMainSignCandidateMainSign(betterproto2.Message):
    """

    \\brief A candidate for a detected main sign as estimated by the
    sensor.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_DETECTEDTRAFFICSIGN_PROTO_DESCRIPTOR.message_types_by_name[
            "DetectedTrafficSign.DetectedMainSign.CandidateMainSign"
        ]

    probability: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    The estimated probability that this candidate is the true value.

    \\note The sum of all \\c #probability must be one. This
    probability is given under the condition of \\c
    DetectedItemHeader::existence_probability.

    \\rules
    is_less_than_or_equal_to: 1
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    classification: "TrafficSignMainSignClassification | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The classification of one main sign that defines this candidate.

    \\note IDs, which are referenced in this message, usually
    reference to \\c DetectedXXX::tracking_id IDs.
    """


default_message_pool.register_message(
    "osi3",
    "DetectedTrafficSign.DetectedMainSign.CandidateMainSign",
    DetectedTrafficSignDetectedMainSignCandidateMainSign,
)


@dataclass(eq=False, repr=False)
class DetectedTrafficSignDetectedSupplementarySign(betterproto2.Message):
    """

    \\brief Candidates for all detected supplementary signs of one traffic
    sign as estimated by the sensor.

    \\image html OSI_DetectedSupplementarySign.svg
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_DETECTEDTRAFFICSIGN_PROTO_DESCRIPTOR.message_types_by_name[
            "DetectedTrafficSign.DetectedSupplementarySign"
        ]

    candidate: "list[DetectedTrafficSignDetectedSupplementarySignCandidateSupplementarySign]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The definition of one of more supplementary signs that together
    define this candidate.

    \\note OSI uses singular instead of plural for repeated field names.
    """

    base: "BaseStationary | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The base parameters of the supplementary traffic sign.

    The orientation of the bounding box \\c SupplementarySign::base
    ( \\c BaseStationary::orientation ) is defined as follows:
    The z-axis of the given \\c BaseStationary::orientation is the vector
    from the bottom to the top of the supplementary traffic sign's 2D
    image plate. (Normally it is equal to the ground truth z-axis.) The
    x-axis of the given \\c BaseStationary::orientation is view normal of
    the supplementary traffic sign's image. This x-axis points from the
    supplementary traffic sign's image in the direction from where a
    'viewer' could see the supplementary traffic sign image.
    """

    base_rmse: "BaseStationary | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The root mean squared error of the base parameters of the detected
    supplementary traffic sign. \\c #candidate
    \\c TrafficSign::SupplementarySign::base has to be identical for all
    \\c #candidate supplementary traffic signs.
    """


default_message_pool.register_message(
    "osi3",
    "DetectedTrafficSign.DetectedSupplementarySign",
    DetectedTrafficSignDetectedSupplementarySign,
)


@dataclass(eq=False, repr=False)
class DetectedTrafficSignDetectedSupplementarySignCandidateSupplementarySign(
    betterproto2.Message
):
    """

    \\brief A candidate for a detected supplementary sign as estimated by
    the sensor.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_DETECTEDTRAFFICSIGN_PROTO_DESCRIPTOR.message_types_by_name[
            "DetectedTrafficSign.DetectedSupplementarySign.CandidateSupplementarySign"
        ]

    probability: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    The estimated probability that this candidate is the true value.

    \\note The sum of all \\c #probability must be one. This
    probability is given under the condition of \\c
    DetectedItemHeader::existence_probability.

    \\rules
    is_less_than_or_equal_to: 1
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    classification: "TrafficSignSupplementarySignClassification | None" = (
        betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    The classification of one of more supplementary signs that
    together define this candidate.

    \\note IDs, which are referenced in this message, usually
    reference to \\c DetectedXXX::tracking_id IDs.
    """


default_message_pool.register_message(
    "osi3",
    "DetectedTrafficSign.DetectedSupplementarySign.CandidateSupplementarySign",
    DetectedTrafficSignDetectedSupplementarySignCandidateSupplementarySign,
)


@dataclass(eq=False, repr=False)
class Dimension3D(betterproto2.Message):
    """

    \\brief The dimension of a 3D box, e.g. the size of a 3D bounding box or its
    uncertainties.

    \\image html OSI_Dimension3D.svg

    The dimensions are positive. Uncertainties are negative or positive.

    Dimension is defined in the specified reference coordinate frame along the
    x-axis (=length), y-axis (=width) and z-axis (=height).
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["Dimension3d"]

    length: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    The length of the box.

    Unit: m

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    width: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    The width of the box.

    Unit: m

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    height: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    The height of the box.

    Unit: m

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """


default_message_pool.register_message("osi3", "Dimension3d", Dimension3D)


@dataclass(eq=False, repr=False)
class EnvironmentalConditions(betterproto2.Message):
    """

    \\brief The conditions of the environment.

    Definition of light, weather conditions and other environmental conditions.

    \\note These conditions apply locally around the host vehicle.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_ENVIRONMENT_PROTO_DESCRIPTOR.message_types_by_name[
            "EnvironmentalConditions"
        ]

    ambient_illumination: "EnvironmentalConditionsAmbientIllumination" = (
        betterproto2.field(
            1,
            betterproto2.TYPE_ENUM,
            default_factory=lambda: EnvironmentalConditionsAmbientIllumination(0),
        )
    )
    """
    The ambient illumination of the environment.
    """

    time_of_day: "EnvironmentalConditionsTimeOfDay | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The time of day at the host vehicles location.
    """

    unix_timestamp: "int" = betterproto2.field(8, betterproto2.TYPE_INT64)
    """
    The unix timestamp describes the time and date at the host vehicle's
    location, referring to UTC.

    The Unix epoch (or Unix time or POSIX time or Unix timestamp) is
    the number of seconds that have elapsed since January 1, 1970
    (midnight UTC/GMT [1]), not counting leap seconds [2].
    Historically, the origin of UNIX system time was referred to as
    "00:00:00 GMT, January 1, 1970" [2]. Literally speaking the epoch
    is Unix time 0 (midnight 1/1/1970), but 'epoch' is often used as
    a synonym for 'Unix time'. Many Unix systems store epoch dates as
    a signed 32-bit integer, which might cause problems on January 19,
    2038 (known as the Year 2038 problem or Y2038).

    \\note You can convert the timestamp using the following [routines
    sorted by languages](https://www.epochconverter.com/#code).

    \\par References:
    [1] ITU Radiocommunication Assembly. (2002). <em>Recommendation  ITU-R  TF.460-6 Standard-frequency and time-signal emissions</em>. (Rec.  ITU-R  TF.460-6). Retrieved January 25, 2020, from http://www.itu.int/dms_pubrec/itu-r/rec/tf/R-REC-TF.460-6-200202-I!!PDF-E.pdf \\n
    [2] The Open Group. (2018). <em>POSIX.1-2017</em> The Open Group Base Specifications Issue 7, 2018 edition. IEEE Std 1003.1-2017 (Revision of IEEE Std 1003.1-2008). Retrieved January 25, 2020, from https://pubs.opengroup.org/onlinepubs/9699919799/xrat/contents.html
    """

    atmospheric_pressure: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    Atmospheric pressure in Pascal at z=0.0 in world frame (about 101325
    Pa).

    Unit: Pa

    \\rules
    is_greater_than_or_equal_to: 80000
    is_less_than_or_equal_to: 120000
    \\endrules
    """

    temperature: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)
    """
    Temperature in Kelvin at z=0.0 in world frame.

    Unit: K

    \\rules
    is_greater_than_or_equal_to: 170
    is_less_than_or_equal_to: 340
    \\endrules
    """

    relative_humidity: "float" = betterproto2.field(5, betterproto2.TYPE_DOUBLE)
    """
    Relative humidity in at z=0.0 in world frame.

    Note that physically more relevant measures, like absolute or specific
    humidity can be easily derived from relative_humidity, given that the
    temperature and atmospheric_pressure are known.

    Unit: %

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 100
    \\endrules
    """

    precipitation: "EnvironmentalConditionsPrecipitation" = betterproto2.field(
        6,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: EnvironmentalConditionsPrecipitation(0),
    )
    """
    Description of the precipitation.
    """

    fog: "EnvironmentalConditionsFog" = betterproto2.field(
        7, betterproto2.TYPE_ENUM, default_factory=lambda: EnvironmentalConditionsFog(0)
    )
    """
    Description of the fog.
    """

    source_reference: "list[ExternalReference]" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Optional external reference to the environmental condition sources.

    \\note For OpenDRIVE and OpenSCENARIO there is no direct counterpart.

    \\note For non-ASAM standards, it is implementation-specific how
          source_reference is resolved.

    \\note The value has to be repeated because one object may be derived
          from more than one origin source, for example, from a scenario file
          and from sensors.
    """

    clouds: "EnvironmentalConditionsCloudLayer | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Description of the clouds.
    """

    wind: "EnvironmentalConditionsWind | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Description of the wind.
    """

    sun: "EnvironmentalConditionsSun | None" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Description of the sun.
    """


default_message_pool.register_message(
    "osi3", "EnvironmentalConditions", EnvironmentalConditions
)


@dataclass(eq=False, repr=False)
class EnvironmentalConditionsCloudLayer(betterproto2.Message):
    """

    \\brief Description of a cloud layer.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_ENVIRONMENT_PROTO_DESCRIPTOR.message_types_by_name[
            "EnvironmentalConditions.CloudLayer"
        ]

    fractional_cloud_cover: "EnvironmentalConditionsCloudLayerFractionalCloudCover" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: EnvironmentalConditionsCloudLayerFractionalCloudCover(
            0
        ),
    )
    """
    Properties of a cloud layer given by fractional cloud cover levels.
    """


default_message_pool.register_message(
    "osi3", "EnvironmentalConditions.CloudLayer", EnvironmentalConditionsCloudLayer
)


@dataclass(eq=False, repr=False)
class EnvironmentalConditionsSun(betterproto2.Message):
    """

    \\brief Properties of the sun.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_ENVIRONMENT_PROTO_DESCRIPTOR.message_types_by_name[
            "EnvironmentalConditions.Sun"
        ]

    azimuth: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Azimuth of the sun, counted counterclockwise.
    0 pointing north. If north is not explicitly defined via \\c #osi3::GroundTruth::proj_string,
    then north is pointing in y-axis direction. The default orientation (x, y, z) is easting, northing, up [1].
    The point of observation is defined to be the global coordinate system's origin.

    \\note 0: north; +pi/2: west; pi: south, 3/2 pi: east.

    Unit: rad

    The preferred angular range is [0, 2pi].

    \\par References:
    [1] PROJ contributors. (2019). <em>PROJ coordinate transformation software library</em>. Open Source Geospatial Foundation. Retrieved January 25, 2019, from https://proj.org/usage/projections.html
    """

    elevation: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Solar elevation angle.
    The elevation angle is positive when the sun is above the xy-plane, negative when
    the sun is below the xy-plane.
    The point of observation is defined to be the global coordinate system's origin.

    \\note 0: xy-plane; +pi/2: zenith; -pi/2: nadir.

    Unit: rad

    The preferred angular range is [-pi/2, +pi/2].
    """

    intensity: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    Illuminance of the sun, direct sunlight is around 100000 lx.

    Unit: lx

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """


default_message_pool.register_message(
    "osi3", "EnvironmentalConditions.Sun", EnvironmentalConditionsSun
)


@dataclass(eq=False, repr=False)
class EnvironmentalConditionsTimeOfDay(betterproto2.Message):
    """

    \\brief The time of day at a specified location.

    \\note In general the global position of the parent frame should be
    obtainable in order to derive the local time.
    This information can be calculated from the \\c #unix_timestamp in
    combination with \\c #osi3::GroundTruth::proj_string and the position of
    the corresponding \\c #osi3::BaseStationary or \\c #osi3::BaseMoving .
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_ENVIRONMENT_PROTO_DESCRIPTOR.message_types_by_name[
            "EnvironmentalConditions.TimeOfDay"
        ]

    seconds_since_midnight: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)
    """
    The number of seconds in s that have passed since midnight local time.
    Used e.g. for determining the current state of the circadian rhythm
    of a driver.

    \\note No changes of daylight saving time or time zones are
    considered.

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than: 86400
    \\endrules
    """


default_message_pool.register_message(
    "osi3", "EnvironmentalConditions.TimeOfDay", EnvironmentalConditionsTimeOfDay
)


@dataclass(eq=False, repr=False)
class EnvironmentalConditionsWind(betterproto2.Message):
    """

    \\brief Defines wind properties.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_ENVIRONMENT_PROTO_DESCRIPTOR.message_types_by_name[
            "EnvironmentalConditions.Wind"
        ]

    origin_direction: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    The origin direction of the wind (not the target direction) in the ground/xy-plane of the
    world coordinate system. Corresponds to the heading/yaw angle, counted counterclockwise.
    0 pointing north. If north is not explicitly defined via \\c #osi3::GroundTruth::proj_string,
    then north is pointing in y-axis direction. The default orientation (x, y, z) is easting, northing, up [1].

    \\note 0: north; +pi/2: west; pi: south, 3/2 pi: east.

    Unit: rad

    The preferred angular range is [0, 2pi].

    \\par References:
    [1] PROJ contributors. (2019). <em>PROJ coordinate transformation software library</em>. Open Source Geospatial Foundation. Retrieved January 25, 2019, from https://proj.org/usage/projections.html
    """

    speed: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    The wind speed.

    Unit: m/s

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """


default_message_pool.register_message(
    "osi3", "EnvironmentalConditions.Wind", EnvironmentalConditionsWind
)


@dataclass(eq=False, repr=False)
class ExternalReference(betterproto2.Message):
    """
    \\brief References to external objects.

    The external reference is an optional recommendation to refer to objects defined outside of OSI.
    This could be other OpenX standards, 3rd-party standards or user-defined objects.

    \\note ExternalReference is optional and can be left empty.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["ExternalReference"]

    reference: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    The source of the external references.

    Defines the original source of an object as uniquely identifiable reference.
    In case of using \\c GroundTruth::map_reference or 
    \\c GroundTruth::model_reference, the reference can be left empty.
    If not otherwise required, an URI is suggested. The syntax should follow 
    \\link https://tools.ietf.org/html/rfc3986 RFC 3986\\endlink.
    """

    type: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)
    """
    The type of the external references.

    Mandatory value describing the type of the original source.

    For OpenX/ASAM standards it is specified as follows:
    - net.asam.opendrive
    - net.asam.openscenario

    For third-party standards and user-defined objects, 
    reverse domain name notation with lower-case type field
    is recommended to guarantee unique and interoperable identification.

    \\rules
    is_set
    \\endrules
    """

    identifier: "list[str]" = betterproto2.field(
        3, betterproto2.TYPE_STRING, repeated=True
    )
    """
    The external identifier reference value.

    The repeated string is chosen as a common description of the external
    identifier, because a variety of identifier types could be
    involved .

    For example, referencing a unique lane in OpenDRIVE requires the
    following identifiers:
    * RoadId: String
    * S-Value of LaneSection: Double
    * LaneId: Int

    \\note The detailed description of the identifiers and how they are 
          used for referencing external objects is given in the individual
          messages where the external identifier is used.

    \\see EnvironmentalConditions::source_reference
    \\see Lane::source_reference
    \\see LaneBoundary::source_reference
    \\see StationaryObject::source_reference
    \\see MovingObject::source_reference
    \\see RoadMarking::source_reference
    \\see TrafficLight::source_reference
    \\see TrafficSign::source_reference
    """


default_message_pool.register_message("osi3", "ExternalReference", ExternalReference)


@dataclass(eq=False, repr=False)
class FeatureData(betterproto2.Message):
    """

    \\brief Interface for sensor data containing information without a history
    in contrast to interpreted data after object hypothesis and tracking.

    All information regarding the environment is given with respect to the sensor
    coordinate system specified in \\c SensorDetectionHeader::mounting_position.
    When simulating multiple sensors, each sensor has an individual copy of
    \\c FeatureData in its own reference frame. This allows an independent
    treatment of the sensors.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_FEATUREDATA_PROTO_DESCRIPTOR.message_types_by_name["FeatureData"]

    version: "InterfaceVersion | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The interface version used by the sender (i.e. the simulation
    environment).
    """

    radar_sensor: "list[RadarDetectionData]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Radar detections for multiple radar sensors (sensor fusion).
    """

    lidar_sensor: "list[LidarDetectionData]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Lidar detections for multiple lidar sensors (sensor fusion).
    """

    ultrasonic_sensor: "list[UltrasonicDetectionData]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Ultrasonic detections for multiple ultrasonic sensors (sensor fusion).

    \\note Required for ultrasonic sensors: Detections will be send by the
    emitting ultrasonic sensor, including all indirect detections received
    by neighboring sensors.
    """

    camera_sensor: "list[CameraDetectionData]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Camera detections for multiple camera sensors (sensor fusion).
    """


default_message_pool.register_message("osi3", "FeatureData", FeatureData)


@dataclass(eq=False, repr=False)
class GenericSensorView(betterproto2.Message):
    """

    \\brief Definition of the generic sensor view.

    Generic sensor view data.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORVIEW_PROTO_DESCRIPTOR.message_types_by_name[
            "GenericSensorView"
        ]

    view_configuration: "GenericSensorViewConfiguration | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Generic view configuration valid at the time the data was created.
    """


default_message_pool.register_message("osi3", "GenericSensorView", GenericSensorView)


@dataclass(eq=False, repr=False)
class GenericSensorViewConfiguration(betterproto2.Message):
    """

    \\brief The configuration settings for the Generic Sensor View to be provided
    by the environment simulation.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORVIEWCONFIGURATION_PROTO_DESCRIPTOR.message_types_by_name[
            "GenericSensorViewConfiguration"
        ]

    sensor_id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the sensor at host vehicle's mounting_position.

    This is the ID of the physical sensor, to be used in its detected
    features output; it is distinct from the ID of its virtual sensor.

    The ID is to be provided by the environment simulation, the sensor
    model is not in a position to provide a useful default value.
    """

    mounting_position: "MountingPosition | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The physical mounting position of the sensor (origin and orientation
    of the sensor coordinate system) given in vehicle coordinates [1].
    The physical position pertains to this detector individually, and
    governs the sensor-relative coordinates in features detected by this
    detector.

    \\arg \\b x-direction of sensor coordinate system: sensor viewing direction
    \\arg \\b z-direction of sensor coordinate system: sensor (up)
    \\arg \\b y-direction of sensor coordinate system: perpendicular to x and z
    right hand system

    \\par Reference:
    [1] DIN Deutsches Institut fuer Normung e. V. (2013). <em>DIN ISO 8855 Strassenfahrzeuge - Fahrzeugdynamik und Fahrverhalten - Begriffe</em>. (DIN ISO 8855:2013-11). Berlin, Germany.

    \\note The origin of vehicle's coordinate system in world frame is
    ( \\c MovingObject::base . \\c BaseMoving::position +
    Inverse_Rotation_yaw_pitch_roll( \\c MovingObject::base . \\c
    BaseMoving::orientation) * \\c
    MovingObject::VehicleAttributes::bbcenter_to_rear) . The orientation of
    the vehicle's coordinate system is equal to the orientation of the
    vehicle's bounding box \\c MovingObject::base . \\c
    BaseMoving::orientation. \\note A default position can be provided by the
    sensor model (e.g. to indicate the position the model was validated for),
    but this is optional; the environment simulation must provide a valid
    mounting position (based on the vehicle configuration) when setting the
    view configuration.
    """

    mounting_position_rmse: "MountingPosition | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The root mean squared error of the mounting position.
    """

    field_of_view_horizontal: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)
    """
    Field of View in horizontal orientation of the physical sensor.

    Viewing range: [- \\c #field_of_view_horizontal/2,  \\c
    #field_of_view_horizontal/2] azimuth in the sensor frame as defined in \\c
    Spherical3d.

    Unit: rad
    """

    field_of_view_vertical: "float" = betterproto2.field(5, betterproto2.TYPE_DOUBLE)
    """
    Field of View in vertical orientation of the physical sensor.

    Viewing range: [- \\c #field_of_view_vertical/2,  \\c
    #field_of_view_vertical/2] elevation in the sensor frame at zero azimuth
    as defined in \\c Spherical3d.

    Unit: rad
    """


default_message_pool.register_message(
    "osi3", "GenericSensorViewConfiguration", GenericSensorViewConfiguration
)


@dataclass(eq=False, repr=False)
class GeodeticPosition(betterproto2.Message):
    """

    \\brief The geodetic position of an object, that is, the center of the 3D bounding box.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["GeodeticPosition"]

    longitude: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Longitude in decimal degrees regarding WGS84.

    Unit: Degree
    Range: [-180; 180]
    """

    latitude: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Latitude in decimal degrees regarding WGS84.

    Unit: Degree
    Range: [-90; 90]
    """

    altitude: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    Height above sea level regarding EGM96.

    Unit: m
    Range: [-300; 10000]
    """


default_message_pool.register_message("osi3", "GeodeticPosition", GeodeticPosition)


@dataclass(eq=False, repr=False)
class GroundTruth(betterproto2.Message):
    """

    \\brief The ground truth information from the simulation environment.

    This ground truth information is supposed to describe the whole simulated
    environment around any simulated vehicle. For each simulated host vehicle
    (there may be one or multiple), define an area around the vehicle which
    is greater than the combined field of views (FOV) of all obstructed sensors
    in the vehicle. The ground truth data is supposed to describe the convex
    hull of all such areas w.r.t. a global simulation coordinate system.

    The simulation coordinate system may change during the simulation if and
    only if all coordinates w.r.t. this coordinate system are also changed.

    The data has to be sent at a rate defined by the receiving partner. When
    sending, values with default values might be left default in order to improve
    performance.

    To provide a complete interface, all fields of all contained messages must be
    properly set unless specifically stated in the field's definition that the
    field may remain unset.

    In enums (e.g. types) the unknown (first / default) value is not allowed to
    be used in the ground truth interface.

    \\image html OSI_GroundTruth.svg "Ground Truth"
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_GROUNDTRUTH_PROTO_DESCRIPTOR.message_types_by_name["GroundTruth"]

    version: "InterfaceVersion | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The interface version used by the sender (i.e. the simulation
    environment).

    \\rules
    is_set
    \\endrules
    """

    timestamp: "Timestamp | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The data timestamp of the simulation environment. The zero time point is
    arbitrary but must be identical for all messages.
    Recommendation: Zero time point for start point of the simulation.

    \\note Zero time point does not need to coincide with the UNIX epoch.

    \\note For ground truth data this timestamp coincides both with the
    notional simulation time the data applies to and the time it was sent
    (there is no inherent latency for ground truth data, as opposed to
    sensor data).

    \\rules
    is_set
    \\endrules
    """

    host_vehicle_id: "Identifier | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the host vehicle object referencing to \\c MovingObject .

    \\note This ID has to be filled and is not optional!

    \\rules
    refers_to: MovingObject
    is_set
    \\endrules
    """

    stationary_object: "list[StationaryObject]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of stationary objects (excluding traffic signs and traffic
    lights).
    """

    moving_object: "list[MovingObject]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of all other moving objects including all (host) vehicles.
    """

    traffic_sign: "list[TrafficSign]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of traffic signs.
    """

    traffic_light: "list[TrafficLight]" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of traffic lights.
    """

    road_marking: "list[RoadMarking]" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of road surface markings (lane markings are excluded and
    defined as \\c LaneBoundary).
    """

    lane_boundary: "list[LaneBoundary]" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of lane boundaries.
    """

    lane: "list[Lane]" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of lanes forming a road network.
    """

    occupant: "list[Occupant]" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of passengers in the (host) vehicle(s).
    """

    environmental_conditions: "EnvironmentalConditions | None" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Conditions of the environment.
    """

    country_code: "int" = betterproto2.field(13, betterproto2.TYPE_UINT32)
    """
    The ISO country code in 3 digit numeric format according to:
    ISO Code 3166/1 [1].
    E.g. Germany = 276, USA = 840.

    \\par Reference:
    [1] ISO International Organization for Standardization. (2013). <em>ISO 3166-1 Codes for the representation of names of countries and their subdivisions - Part 1: Country codes</em>. (ISO 3166-1:2013). Geneva, Switzerland.

    \\rules
    is_iso_country_code
    \\endrules
    """

    proj_string: "str" = betterproto2.field(14, betterproto2.TYPE_STRING)
    """
    Projection string that allows to transform all coordinates in GroundTruth
    into a different cartographic projection after the \\c proj_frame_offset
    has been applied.

    The string follows the PROJ rules for projections [1].

    \\par Reference:
    [1] PROJ contributors. (2019). <em>PROJ coordinate transformation software library</em>. Open Source Geospatial Foundation. Retrieved January 25, 2019, from https://proj.org/usage/projections.html
    """

    map_reference: "str" = betterproto2.field(15, betterproto2.TYPE_STRING)
    """
    Opaque reference of a map.

    \\note Origin and orientation of the map have to coincide with the
    inertial coordinate frame of the ground truth.

    \\note It is implementation-specific how map_reference is resolved.
    """

    model_reference: "str" = betterproto2.field(16, betterproto2.TYPE_STRING)
    """
    Opaque reference of an associated 3D model.

    The model covers the static parts of the environment that are not
    provided as individual models referenced from ground truth objects
    like moving or stationary objects.

    \\note Origin and orientation of the model have to coincide with the
    inertial coordinate frame of the ground truth.

    \\note It is implementation-specific how model_references are resolved to
    3d models. The parts the world model contains are also implementation-specific.
    For example, the world model can either contain street geometries or
    derives street geometries automatically from a map reference.
    """

    reference_line: "list[ReferenceLine]" = betterproto2.field(
        17, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Reference lines used by LogicalLane
    """

    logical_lane_boundary: "list[LogicalLaneBoundary]" = betterproto2.field(
        18, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Logical lane boundaries used by LogicalLane
    """

    logical_lane: "list[LogicalLane]" = betterproto2.field(
        19, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Logical lanes used e.g. by traffic agents
    """

    proj_frame_offset: "GroundTruthProjFrameOffset | None" = betterproto2.field(
        20, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Coordinate frame offset to be used for PROJ transformations.
    """


default_message_pool.register_message("osi3", "GroundTruth", GroundTruth)


@dataclass(eq=False, repr=False)
class GroundTruthProjFrameOffset(betterproto2.Message):
    """

    \\brief Coordinate frame offset to transform from OSI's global coordinate
    system to a coordinate reference system to be used for given PROJ
    transformations.

    If an offset is defined, always apply the \\c proj_frame_offset on
    global OSI coordinates before applying any transformations defined in
    \\c proj_string.

    To apply the offset, global coordinates are first translated by the given
    positional offset (x,y,z). Then, the yaw angle is used to rotate around
    the new origin.

    The offset is applied on global OSI coordinates using an affine
    transformation with rotation around z-axis:

    xWorld = xOSI * cos(yaw) - yOSI * sin(yaw) + xOffset

    yWorld = xOSI * sin(yaw) + yOSI * cos(yaw) + yOffset

    zWorld = zOSI + zOffset

    If no yaw is provided (recommended), the formulas simplify to:

    xWorld = xOSI + xOffset

    yWorld = yOSI + yOffset

    zWorld = zOSI + zOffset
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_GROUNDTRUTH_PROTO_DESCRIPTOR.message_types_by_name[
            "GroundTruth.ProjFrameOffset"
        ]

    position: "Vector3D | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Positional offset for relocation of the coordinate frame.
    """

    yaw: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Yaw/heading angle for re-orientation of the coordinate frame around
    the z-axis.
    """


default_message_pool.register_message(
    "osi3", "GroundTruth.ProjFrameOffset", GroundTruthProjFrameOffset
)


@dataclass(eq=False, repr=False)
class HostVehicleData(betterproto2.Message):
    """
    \\brief Host vehicle data is about the perception of the vehicle about its own internal states.
    It captures the knowledge the vehicle has internally, which can differ from the actual or global truth for various reasons.
    This message can also be understood as an interface container for the signals of a rest bus simulation.

    It consists of different messages categorizing the vehicle in:
    Basics, powertrain, brake system, steering, wheels and localization.

    \\image html OSI_HostVehicle.svg
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_HOSTVEHICLEDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "HostVehicleData"
        ]

    version: "InterfaceVersion | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The interface version used by the sender.
    """

    timestamp: "Timestamp | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The timestamp of the host vehicle data. Zero time is arbitrary but must be
    identical for all messages. Zero time does not need to coincide with
    the unix epoch. Recommended is the starting time point of the
    simulation or measurement.

    \\note This is the point in time that the host vehicle data message becomes
    available as snapshot from the board net information.
    """

    host_vehicle_id: "Identifier | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the host vehicle in any associated GroundTruth data.
    """

    location: "BaseMoving | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Deprecated: Will be removed in next major release. Moved to vehicle_localization.
    Current estimated location based on GPS- and related navigation sensors.

    \\note Note that dimension and base_polygon need not be set.
    """

    location_rmse: "BaseMoving | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Deprecated: Will be removed in next major release. Moved to vehicle_localization.
    Current estimated location error based on GPS and related navigation
    sensors.

    \\note Note that dimension and base_polygon need not be set.
    """

    vehicle_basics: "HostVehicleDataVehicleBasics | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The basic parameters and overall states of the vehicle.
    """

    vehicle_powertrain: "HostVehicleDataVehiclePowertrain | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Interface regarding the powertrain.
    """

    vehicle_brake_system: "HostVehicleDataVehicleBrakeSystem | None" = (
        betterproto2.field(5, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Interface regarding the brake system.
    """

    vehicle_steering: "HostVehicleDataVehicleSteering | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Interface regarding the steering.
    """

    vehicle_wheels: "HostVehicleDataVehicleWheels | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Interface regarding the internal wheel states.
    """

    vehicle_localization: "HostVehicleDataVehicleLocalization | None" = (
        betterproto2.field(8, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Interface regarding the localization.
    """

    vehicle_automated_driving_function: "list[HostVehicleDataVehicleAutomatedDrivingFunction]" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    State of any automated driving functions.

    This can include:
     - information presented to the driver, for example, parking sensors
     - warnings raised by the vehicle, for example, forward collision warning
     - corrective action taken by the vehicle, for example, auto emergency braking
     - full level 4 self driving systems

    \\note OSI uses singular instead of plural for repeated field names.
    """

    vehicle_motion: "HostVehicleDataVehicleMotion | None" = betterproto2.field(
        13, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Interface regarding the vehicle motion.
    """

    route: "Route | None" = betterproto2.field(
        14, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Currently planned route of the vehicle
    """


default_message_pool.register_message("osi3", "HostVehicleData", HostVehicleData)


@dataclass(eq=False, repr=False)
class HostVehicleDataVehicleAutomatedDrivingFunction(betterproto2.Message):
    """

    \\brief State of one automated driving function on the host vehicle.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_HOSTVEHICLEDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "HostVehicleData.VehicleAutomatedDrivingFunction"
        ]

    name: "HostVehicleDataVehicleAutomatedDrivingFunctionName" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: HostVehicleDataVehicleAutomatedDrivingFunctionName(0),
    )
    """
    The particular driving function being reported about.
    """

    custom_name: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)
    """
    Custom driving function name.

    Only used if name is set to NAME_OTHER.
    """

    state: "HostVehicleDataVehicleAutomatedDrivingFunctionState" = betterproto2.field(
        3,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: HostVehicleDataVehicleAutomatedDrivingFunctionState(0),
    )
    """
    The state of the function.

    This is whether the function has actually been triggered, for
    example, a warning has been raised, or additional braking is
    in effect.
    """

    custom_state: "str" = betterproto2.field(4, betterproto2.TYPE_STRING)
    """
    Custom state.

    Only used if the state is set to STATE_OTHER.
    """

    driver_override: "HostVehicleDataVehicleAutomatedDrivingFunctionDriverOverride | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Whether, and how, the driver has overridden this function.
    """

    custom_detail: "list[KeyValuePair]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Custom detail.

    An opaque set of key-value pairs which capture any user specific
    details that may be relevant.  This could include details about
    how a warning was raised (dashboard, audible, etc.) or it could
    be about settings which would influence evaluation, such as
    sensitivity settings.
    """


default_message_pool.register_message(
    "osi3",
    "HostVehicleData.VehicleAutomatedDrivingFunction",
    HostVehicleDataVehicleAutomatedDrivingFunction,
)


@dataclass(eq=False, repr=False)
class HostVehicleDataVehicleAutomatedDrivingFunctionDriverOverride(
    betterproto2.Message
):
    """

    \\brief Driver override information

    Information about whether and how and driver may have overridden
    an automated driving function.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_HOSTVEHICLEDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "HostVehicleData.VehicleAutomatedDrivingFunction.DriverOverride"
        ]

    active: "bool" = betterproto2.field(1, betterproto2.TYPE_BOOL)
    """
    The feature has been overridden by a driver action.

    \\note If false, the rest of this message should be ignored.
    """

    override_reason: "list[HostVehicleDataVehicleAutomatedDrivingFunctionDriverOverrideReason]" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, repeated=True
    )
    """
    What driver inputs have caused the override.
    """


default_message_pool.register_message(
    "osi3",
    "HostVehicleData.VehicleAutomatedDrivingFunction.DriverOverride",
    HostVehicleDataVehicleAutomatedDrivingFunctionDriverOverride,
)


@dataclass(eq=False, repr=False)
class HostVehicleDataVehicleBasics(betterproto2.Message):
    """

    \\brief Base parameters and overall states of the vehicle.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_HOSTVEHICLEDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "HostVehicleData.VehicleBasics"
        ]

    curb_weight: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    The total mass of the vehicle (curb weight).

    Unit: kg

    \\par Reference:
    Paragraph 42 of the German Road Traffic Admission Regulations (StVZO).
    """

    operating_state: "HostVehicleDataVehicleBasicsOperatingState" = betterproto2.field(
        2,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: HostVehicleDataVehicleBasicsOperatingState(0),
    )
    """
    The operating state of the vehicle.
    """


default_message_pool.register_message(
    "osi3", "HostVehicleData.VehicleBasics", HostVehicleDataVehicleBasics
)


@dataclass(eq=False, repr=False)
class HostVehicleDataVehicleBrakeSystem(betterproto2.Message):
    """

    \\brief The focus here is on the description of the brake system.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_HOSTVEHICLEDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "HostVehicleData.VehicleBrakeSystem"
        ]

    pedal_position_brake: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Position of the brake pedal.
    Range: 0-1 (Unpressed - fully pressed)
    """


default_message_pool.register_message(
    "osi3", "HostVehicleData.VehicleBrakeSystem", HostVehicleDataVehicleBrakeSystem
)


@dataclass(eq=False, repr=False)
class HostVehicleDataVehicleLocalization(betterproto2.Message):
    """

    \\brief Current calculated and estimated location that can be based on GNSS and related navigation sensors.
    This message does not contain the individual sensor values of the sensor technology.

    This message contains the most accurate information the vehicle knows about its position
    available in the on-board network.
    Because of this the values can differ from the "true" values calculated out of
    GroundTruth::proj_string, GroundTruth::MovingObject::BaseMoving::position, GroundTruth::host_vehicle_id.

    This data uses the reference point coincident with the center (x,y,z) of the bounding box.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_HOSTVEHICLEDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "HostVehicleData.VehicleLocalization"
        ]

    position: "Vector3D | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Most accurate position information of the vehicle available in the on-board network
    measured in context to the global coordinate system.
    """

    orientation: "Orientation3D | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Most accurate orientation information of the vehicle available in the on-board network
    measured in context to the global coordinate system.
    """

    geodetic_position: "GeodeticPosition | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Most accurate geodetic information of the vehicle available in the on-board network.
    """


default_message_pool.register_message(
    "osi3", "HostVehicleData.VehicleLocalization", HostVehicleDataVehicleLocalization
)


@dataclass(eq=False, repr=False)
class HostVehicleDataVehicleMotion(betterproto2.Message):
    """

    \\brief Current calculated and estimated motion related information.

    This message contains the most accurate information the vehicle knows about its motion
    including vehicle dynamics and control related information available in the on-board network,
    which can differ from the "true" values calculated out of the ground truth.

    This data uses the reference point coincident with the middle (in x, y and z) of rear axle
    under neutral load conditions as defined in \\c MovingObject::VehicleAttributes::bbcenter_to_rear.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_HOSTVEHICLEDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "HostVehicleData.VehicleMotion"
        ]

    position: "Vector3D | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Most accurate position of the vehicle available in the on-board network
    measured in the cartesian global coordinate system.
    """

    orientation: "Orientation3D | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Most accurate orientation information of the vehicle available in the on-board network
    measured on the vehicle coordinate system in context of the global inertial system.
    """

    velocity: "Vector3D | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Most accurate velocity information of the vehicle, available in the on-board network
    measured on the vehicle coordinate system in context of the global inertial system.
    """

    orientation_rate: "Orientation3D | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Most accurate orientation rate of the vehicle, available in the on-board network
    measured on the vehicle coordinate system in context of the global inertial system.
    """

    acceleration: "Vector3D | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Most accurate acceleration information of the vehicle, available in the on-board network
    measured on the vehicle coordinate system in context of the global inertial system.
    """

    current_curvature: "float" = betterproto2.field(6, betterproto2.TYPE_DOUBLE)
    """
    Most accurate curvature currently followed by vehicle and available in the on-board network

    Unit: m^-1
    """


default_message_pool.register_message(
    "osi3", "HostVehicleData.VehicleMotion", HostVehicleDataVehicleMotion
)


@dataclass(eq=False, repr=False)
class HostVehicleDataVehiclePowertrain(betterproto2.Message):
    """

    \\brief State description of the powertrain.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_HOSTVEHICLEDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "HostVehicleData.VehiclePowertrain"
        ]

    pedal_position_acceleration: "float" = betterproto2.field(
        1, betterproto2.TYPE_DOUBLE
    )
    """
    Position of the acceleration pedal.
    Range: 0-1 (Unpressed - fully pressed)
    """

    pedal_position_clutch: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Position of the clutch pedal.
    Range: 0-1 (Unpressed - fully pressed)
    """

    gear_transmission: "int" = betterproto2.field(3, betterproto2.TYPE_INT32)
    """
    The actual gear of the transmission.
    For example, a gear lever can be on "D" and the transmission on "4", but not the
    other way around.

    The sign of this field is linked to the gear's mode as following:
    - zero: neutral position
    - positive: driving forward mode
    - negative: reverse mode (generally -1, but few vehicles have more than 1
      reverse mode gears)
    """

    motor: "list[HostVehicleDataVehiclePowertrainMotor]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Information about the motor(s).
    """


default_message_pool.register_message(
    "osi3", "HostVehicleData.VehiclePowertrain", HostVehicleDataVehiclePowertrain
)


@dataclass(eq=False, repr=False)
class HostVehicleDataVehiclePowertrainMotor(betterproto2.Message):
    """

    \\brief A description of the motor states.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_HOSTVEHICLEDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "HostVehicleData.VehiclePowertrain.Motor"
        ]

    type: "HostVehicleDataVehiclePowertrainMotorType" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: HostVehicleDataVehiclePowertrainMotorType(0),
    )
    """
    The type of the motor.
    """

    rpm: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Revolutions per minute of the motor.

    Unit: 1/min
    """

    torque: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    Torque of the motor.

    Unit: N*m
    """


default_message_pool.register_message(
    "osi3",
    "HostVehicleData.VehiclePowertrain.Motor",
    HostVehicleDataVehiclePowertrainMotor,
)


@dataclass(eq=False, repr=False)
class HostVehicleDataVehicleSteering(betterproto2.Message):
    """

    \\brief The focus here is on the description of the steering train.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_HOSTVEHICLEDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "HostVehicleData.VehicleSteering"
        ]

    vehicle_steering_wheel: "VehicleSteeringWheel | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Description of the steering wheel.
    """


default_message_pool.register_message(
    "osi3", "HostVehicleData.VehicleSteering", HostVehicleDataVehicleSteering
)


@dataclass(eq=False, repr=False)
class HostVehicleDataVehicleWheels(betterproto2.Message):
    """

    \\brief The focus here is on the description of internal wheel states.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_HOSTVEHICLEDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "HostVehicleData.VehicleWheels"
        ]

    wheel_data: "list[HostVehicleDataVehicleWheelsWheelData]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Description of each wheel.

    \\note OSI uses singular instead of plural for repeated field names.
    """


default_message_pool.register_message(
    "osi3", "HostVehicleData.VehicleWheels", HostVehicleDataVehicleWheels
)


@dataclass(eq=False, repr=False)
class HostVehicleDataVehicleWheelsWheelData(betterproto2.Message):
    """

    \\brief The focus here is on the description of internal wheel states.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_HOSTVEHICLEDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "HostVehicleData.VehicleWheels.WheelData"
        ]

    axle: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)
    """
    The axle which contains this wheel. A value of 0 represents the
    foremost axle of the vehicle, with higher numbers ascending
    towards the rearmost axle.
    """

    index: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)
    """
    The index of the wheel on the axle, counted in positive y- direction,
    that is, right-to-left.

    For example, on a standard 2-axle, 4-wheel car, the rear-right
    wheel would be (axle=1, index=0).
    This concept also works for twin tires.
    """

    rotation_rate: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    Rotation rate of the wheel based on the processed output of the hall sensor measurements at the wheel.
    The rotation rate around the y-axis with respect to the wheel's coordinate system.

    Unit: rad/s.

    The sign convention is defined using the right-hand rule.
    It is applied on the y-axis of the vehicle's reference system, that is, the center of bounding box.
    Counterclockwise is positive and clockwise is negative.

    \\image html OSI_RotationRate.svg
    \\note The vehicle's reference coordinate system is only used to determine the sign convention of the rotation rate.
    """

    slip: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)
    """
    Contains the longitudinal, measured slip of the tire.
    \\par References:
    [1] kfz-tech.de, Schlupf, Retrieved June 30, 2021, from https://www.kfz-tech.de/Biblio/Formelsammlung/Schlupf.htm

    Unit: %

    The sign convention is defined using the right-hand rule.
    It is applied on the y-axis of the vehicle's reference system, that is, the center of bounding box.
    Counterclockwise is positive and clockwise is negative.
    """


default_message_pool.register_message(
    "osi3",
    "HostVehicleData.VehicleWheels.WheelData",
    HostVehicleDataVehicleWheelsWheelData,
)


@dataclass(eq=False, repr=False)
class Identifier(betterproto2.Message):
    """

    \\brief A common identifier (ID), represented as an integer.

    Has to be unique among all simulated items at any given time. For ground
    truth, the identifier of an item (object, lane, sign, etc.) must remain
    stable over its lifetime. \\c Identifier values may be only be reused if the
    available address space is exhausted and the specific values have not been in
    use for several time steps. Sensor specific tracking IDs have no restrictions
    and should behave according to the sensor specifications.
    Purely simulation technical IDs, like sensor IDs, are not required to be
    unique among all simulated items, but rather unique within the context of the
    given message type.

    The value MAX(uint64) = 2^(64) -1 =
    0b1111111111111111111111111111111111111111111111111111111111111111 is
    reserved and indicates an invalid ID or error.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["Identifier"]

    value: "int" = betterproto2.field(1, betterproto2.TYPE_UINT64)
    """
    The value of the identifier.

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """


default_message_pool.register_message("osi3", "Identifier", Identifier)


@dataclass(eq=False, repr=False)
class InterfaceVersion(betterproto2.Message):
    """

    \\brief The interface version number.

    The field denoting the version number. This needs to be set by the
    sender to the actual OSI version that is to be sent.  Code wanting to
    access the version number of the OSI code base can access a FileOptions,
    which has the proper values, like this:

    \\code
    auto currentInterfaceVersion =
      InterfaceVersion::descriptor()->file()->options().GetExtension(current_interface_version);
    \\endcode

    If a message with all components set to the default value 0 is
    received, this indicates that either that the message was sent by
    a version 2.2.0 or earlier release, or that the sender did not
    properly set the version components prior to sending.

    Increments will happen as part of changes to the whole interface.
    The meaning of different InterfaceVersions is defined in the versioning chapter of the official OSI documentation.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_VERSION_PROTO_DESCRIPTOR.message_types_by_name["InterfaceVersion"]

    version_major: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)
    """
    Major version number.
    """

    version_minor: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)
    """
    Minor version number.
    """

    version_patch: "int" = betterproto2.field(3, betterproto2.TYPE_UINT32)
    """
    Patch version number.
    """


default_message_pool.register_message("osi3", "InterfaceVersion", InterfaceVersion)


@dataclass(eq=False, repr=False)
class KeyValuePair(betterproto2.Message):
    """

    \\brief Generic key-value pair structure

    A generic key-value pair structure which can be used to capture information
    which is opaque to the general OSI interface.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["KeyValuePair"]

    key: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    A generic string key.
    """

    value: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)
    """
    A generic string value.
    """


default_message_pool.register_message("osi3", "KeyValuePair", KeyValuePair)


@dataclass(eq=False, repr=False)
class Lane(betterproto2.Message):
    """

    \\brief A lane in the road network.

    A lane is part of a road and mainly characterized by its center line. It also
    knows about any adjacent lanes, antecessor and successor lanes.
    The following images will be referred to by later comments. The lane
    l4 in image HighwayExit is used  as reference if not mentioned otherwise.

    <table border=0>
    <tr>
    <td>
    \\image html OSI_Highway_Exit.svg "" width=550px
    <td>
    \\image html OSI_LaneIntersection.svg "" width=550px
    <tr>
    <td>
    \\image html OSI_Highway_Exit.jpg "HighwayExit" width=650px
    <td>
    \\image html OSI_LaneIntersection.jpg "Intersection" width=650px
    </table>

    \\note In the examples, the symbols l1, l2, ... and lb1, lb2, ...
    stand for the lane ids and lane boundary ids respectively, i.e. for
    integers (uint64). The symbols cl1, cl2, ... represent the
    osi3::Lane::Classification::centerline elements of the lanes with
    the respective ids.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_LANE_PROTO_DESCRIPTOR.message_types_by_name["Lane"]

    id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the lane.
    Example: l4 (see reference picture HighwayExit).

    \\note Note ID is global unique.

    \\rules
    is_globally_unique
    is_set
    \\endrules
    """

    classification: "LaneClassification | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The classification of the lane.
    """

    source_reference: "list[ExternalReference]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Optional external reference to the lane source.

    The external reference points to the source of the lane, if it is derived
    from one or more objects or external references.

    For example, to reference a lane defined in an OpenDRIVE map
    the items should be set as follows:
    * reference = URI to map, can remain empty if identical with definition
                  in \\c GroundTruth::map_reference
    * type = "net.asam.opendrive"
    * identifier[0] = id of t_road
    * identifier[1] = s of t_road_lanes_laneSection
    * identifier[2] = id of t_road_lanes_laneSection_left_lane,
                            t_road_lanes_laneSection_right_lane

    \\note For non-ASAM Standards, it is implementation-specific how
          source_reference is resolved.

    \\note The value has to be repeated, because one lane segment may be
          derived from more than one origin segment. Multiple sources
          may be added as reference as well, for example, a map and sensors.
    """


default_message_pool.register_message("osi3", "Lane", Lane)


@dataclass(eq=False, repr=False)
class LaneClassification(betterproto2.Message):
    """

    \\brief \\c Classification of a lane.

    <table border = 0>
    <tr>
    <td>
    \\anchor HighwayExit
    \\image html OSI_LaneClassification.jpg "HighwayExit" width=800px
    </td>
    <td>
    <table border=0>
    <tr>
    <td>
    <b>
    \\c Classification for lane l4 in image HighwayExit:
    </b>
    <tr>
    <td>
    \\c #type = \\c #TYPE_DRIVING
    <tr>
    <td>
    \\c #centerline = (cl4_1, cl4_2, cl4_3, cl4_4, cl4_5)
    <tr>
    <td>
    \\c #centerline_is_driving_direction = \\c true
    <tr>
    <td>
    \\c #is_host_vehicle_lane = \\c true
    <tr>
    <td>
    \\c #left_adjacent_lane_id = l3
    <tr>
    <td>
    \\c #right_adjacent_lane_id  = (l5,l6)
    <tr>
    <td>
    \\c #left_lane_boundary_id = lb5
    <tr>
    <td>
    \\c #right_lane_boundary_id = (lb9, lb6)
    </table>
    </td>
    </tr>
    <tr>
    <td>
    \\anchor Intersection
    \\image html OSI_LaneIntersection.jpg "Intersection" width=800px
    </td>
    <td>
    <table border=0>
    <tr>
    <td>
    <b>
    \\c Classification for lane l7 in image Intersection:
    </b>
    </td>
    </tr>
    <tr>
    <td>
    \\c #type = \\c #TYPE_INTERSECTION
    </td>
    </tr>
    <tr>
    <td>
    \\c #is_host_vehicle_lane = \\c false
    </td>
    </tr>
    <tr>
    <td>
    \\c #free_lane_boundary_id = lb11
    </td>
    </tr>
    <tr>
    <td>
    <border = 0>
    <tr>
    <td>
    \\c #lane_pairing = (
    <td>
    (l2,l1), (l2,l3), (l2,l5),
    <tr>
    <td>
    <td>
    (l4,l1), (l4,l3), (l4,l5),
    <tr>
    <td>
    <td>
    (l6,l1), (l6,l3), (l6,l5) )
    </table>
    </td>
    </tr>
    </table>
    </td>
    </tr>
    </table>

    \\note In the examples, the symbols l1, l2, ... and lb1, lb2, ...
    stand for the lane ids and lane boundary ids respectively, i.e. for
    integers (uint64). The symbols cl1, cl2, ... represent the
    osi3::Lane::Classification::centerline elements of the lanes with
    the respective ids. The symbols cl1_1, cl1_2, ... stand for
    \\c #osi3::Vector3d elements.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_LANE_PROTO_DESCRIPTOR.message_types_by_name["Lane.Classification"]

    type: "LaneClassificationType" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: LaneClassificationType(0)
    )
    """
    The type of the lane.

    Example: For l4 in image \\ref HighwayExit the \\c #type is \\c
    #TYPE_DRIVING.
    """

    is_host_vehicle_lane: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)
    """
    Indicates that the host vehicle travels on this particular lane.
    The host vehicle may travel on more than one lane at once. This does
    also apply for the \\c CandidateLane in the \\c DetectedLane .
    """

    centerline: "list[Vector3D]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The lane's center line (as a list of segments).

    The centerline describes the middle of the lane.

    \\image html OSI_LaneCenterline.svg "Centerline" width=500px

    Example: In image \\ref HighwayExit,
    the centerline of lane l4 (black line) is given by
    (cl4_1, cl4_2, cl4_3, cl4_4, cl4_5).

    \\image html OSI_LaneBoundaries_And_CenterLine.svg "Centerline" width=500px

    \\note 
    cl: center line
    lb: lane boundary

    \\attention The points describing the center line must be set in the 
    same ordering (ascending or descending) as the points describing the 
    lane boundaries. Example: If the points are deducted from a map format, 
    the order of points is recommended to be in line with the road coordinate 
    (e.g. s-coordinate in OpenDRIVE). 

    \\attention The points describing the center line might be set at
    arbitrary distances. When the points are pairwise linearly connected,
    the lateral distance to the real ideal line (as used by the
    simulation environment internally) must not exceed 5cm. As shown in
    the following image:

    \\image html line_approximation_error.svg "Approximation error"
    Approximation error green line.

    \\note The center line is the line that a typical vehicle follows more
    or less (depending on the situation, a little more to the left or
    right of the center line). The intended direction of travel on the
    lane is given by the direction defined by the sequence of points
    forming the \\c #centerline w.r.t. \\c
    #centerline_is_driving_direction.

    \\note The \\c #centerline is defined only for \\c #type =
    \\c #TYPE_DRIVING and if exactly one or no \\c #lane_pairing pair
    exists.

    \\note Intersections and non-driving lanes do not have a center line.
    A vehicle must calculate this individually and depending on the
    situation.
    """

    centerline_is_driving_direction: "bool" = betterproto2.field(
        4, betterproto2.TYPE_BOOL
    )
    """
    Definition of the intended driving direction.

    Defined and used for driving lanes.
    \\c true means driving direction is according to ascending storage
    order of center line points. \\c false means driving direction is
    according to descending storage order of center line points.

    Example: \\c #centerline_is_driving_direction = \\c true for lane l4
    and \\c #centerline_is_driving_direction = \\c false for lane l2 in
    image \\ref HighwayExit .

    \\note The \\c #centerline_is_driving_direction is defined for \\c #type
    = \\c #TYPE_DRIVING .
    """

    left_adjacent_lane_id: "list[Identifier]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of IDs of all lane segments that are directly adjacent to the
    lane on the left side (w.r.t. ascending order of centerline points
    and lane boundary points). Note that lengths of lane segments are 
    not synchronized and therefore there are multiple adjacent segments 
    if there is a split/merge point in the adjacent lane.

    Example: The lane l3 is the only left adjacent lane for lane l4
    in image \\ref HighwayExit.

    \\note The \\c #left_adjacent_lane_id is undefined for \\c #type =
    \\c #TYPE_INTERSECTION .

    \\note OSI uses singular instead of plural for repeated field names.

    \\rules
    check_if this.type is_different_to 4 else do_check is_set
    \\endrules
    """

    right_adjacent_lane_id: "list[Identifier]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of IDs of all lane segments that are directly adjacent to the
    lane on the right side (w.r.t. ascending order of centerline points
    and lane boundary points). Note that lengths of lane segments are 
    not synchronized and therefore there are multiple adjacent segments 
    if there is a split/merge point in the adjacent lane.

    Example: \\c #right_adjacent_lane_id = (l5, l6)
    for lane l4 in image \\ref HighwayExit.

    \\note The \\c #right_adjacent_lane_id is undefined for \\c #type =
    \\c #TYPE_INTERSECTION .

    \\note OSI uses singular instead of plural for repeated field names.

    \\rules
    check_if this.type is_different_to 4 else do_check is_set
    \\endrules
    """

    lane_pairing: "list[LaneClassificationLanePairing]" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The antecessor/successor lane pairings of this lane. There can be
    multiple pairings with the same antecessor and different successor
    lanes and vice versa. The antecessor lanes end in the same point that
    this lane starts from. The successor lanes start in the same point
    that this lane ends in.

    Example: See image \\ref Intersection.

    \\note OSI uses singular instead of plural for repeated field names.
    """

    right_lane_boundary_id: "list[Identifier]" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The right adjacent lane boundaries \\c #right_lane_boundary_id may
    only be shared with/as the left adjacent lane boundaries \\c
    #left_lane_boundary_id of the nearest right adjacent lane \\c
    #right_adjacent_lane_id.

    Example: \\c #right_lane_boundary_id =
    (lb9, lb6) for reference lane l4 in image \\ref HighwayExit.

    \\note Empty for intersections.

    \\note The \\c #right_lane_boundary_id is undefined for \\c #type =
    \\c #TYPE_INTERSECTION .

    \\note OSI uses singular instead of plural for repeated field names.

    \\note The boundary between adjacent lanes at different heights
          (e.g. a curb between a driving lane and a sidewalk)
          should not be shared, but modeled as two separate lane
          boundaries with individual ids. One for the upper, the
          other one for the lower lane.

    \\rules
    check_if this.type is_different_to 4 else do_check is_set
    \\endrules
    """

    left_lane_boundary_id: "list[Identifier]" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The left adjacent lane boundaries \\c #left_lane_boundary_id may only
    be shared with/as the right adjacent lane boundaries \\c
    #right_lane_boundary_id of the nearest left adjacent lane \\c
    #left_adjacent_lane_id.

    Example: \\c #left_lane_boundary_id = lb5 for lane l4 in image \\ref
    HighwayExit.

    \\note Empty for intersections.

    \\note The \\c #left_lane_boundary_id is undefined for \\c #type =
    \\c #TYPE_INTERSECTION .

    \\note OSI uses singular instead of plural for repeated field names.

    \\note The boundary between adjacent lanes at different heights
          (e.g. a curb between a driving lane and a sidewalk)
          should not be shared, but modeled as two separate lane
          boundaries with individual ids. One for the upper, the
          other one for the lower lane.

    \\rules
    check_if this.type is_different_to 4 else do_check is_set
    \\endrules
    """

    free_lane_boundary_id: "list[Identifier]" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The free boundaries which have no/unknown assignment to left/right.

    Example: \\c #free_lane_boundary_id = lb11 for lane l7 in image \\ref
    Intersection.

    \\note \\c Lane with \\c #type = \\c #TYPE_INTERSECTION use only free
    lane boundaries.

    \\note OSI uses singular instead of plural for repeated field names.

    \\rules
    check_if this.type is_different_to 4 else do_check is_set
    \\endrules
    """

    road_condition: "LaneClassificationRoadCondition | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The condition of the lane, e.g. influenced by weather.
    """

    subtype: "LaneClassificationSubtype" = betterproto2.field(
        12, betterproto2.TYPE_ENUM, default_factory=lambda: LaneClassificationSubtype(0)
    )
    """
    The subtype of the lane. 

    This subtype specifies a lane more concretely.
    """


default_message_pool.register_message("osi3", "Lane.Classification", LaneClassification)


@dataclass(eq=False, repr=False)
class LaneClassificationLanePairing(betterproto2.Message):
    """
    \\brief The lane ID pairings of antecessor and successor lanes.

    <table border = 0>
    <tr>
    <td>
    \\image html OSI_LaneIntersection.svg "" width=600px
    </td>
    <td>
    <table border=0>
    <tr>
    <td>
    <b>
    \\c LanePairing for lane l7:
    </b>
    </td>
    </tr>
    <tr>
    <td>
    <table border = 0>
    <tr>
    <td>
    (l2,l1), (l2,l3), (l2,l5),
    <tr>
    <td>
    (l4,l1), (l4,l3), (l4,l5),
    <tr>
    <td>
    (l6,l1), (l6,l3), (l6,l5)
    </table>
    </td>
    </tr>
    </table>
    </td>
    </tr>
    </table>

    \\note In the example, the symbols l1, l2, ... stand for the
    respective lane ids, i.e. for integers (uint64). The symbols cl1,
    cl2, ... represent the osi3::Lane::Classification::centerline
    elements of the lanes with the respective ids.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_LANE_PROTO_DESCRIPTOR.message_types_by_name[
            "Lane.Classification.LanePairing"
        ]

    antecessor_lane_id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The antecessor lane ID.

    \\rules
    refers_to: Lane
    \\endrules
    """

    successor_lane_id: "Identifier | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The successor lane ID.

    \\rules
    refers_to: Lane
    \\endrules
    """


default_message_pool.register_message(
    "osi3", "Lane.Classification.LanePairing", LaneClassificationLanePairing
)


@dataclass(eq=False, repr=False)
class LaneClassificationRoadCondition(betterproto2.Message):
    """

    \\brief The condition of the road surface.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_LANE_PROTO_DESCRIPTOR.message_types_by_name[
            "Lane.Classification.RoadCondition"
        ]

    surface_temperature: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    The temperature of the roads surface in Kelvin.

    Unit: K

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    surface_water_film: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    The height of the water film on top of the surface in mm.

    Unit: mm

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    surface_freezing_point: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    The temperature where the water on top of the surface would start
    to freeze or dew in Kelvin.

    Unit: K

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    surface_ice: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)
    """
    The percentage of ice covering the road.

    Unit: %

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    surface_roughness: "float" = betterproto2.field(5, betterproto2.TYPE_DOUBLE)
    """
    The coefficient representing the roughness or unevenness of the
    road. International Roughness Index (IRI) [1] values range from 0
    = smooth ground (equivalent to driving on a plate of glass) up to
    >
    20 mm/m (a very rough road).

    Estimated value ranges (IRI):
    0.0 mm/m absolutely perfect evenness
    0.3 -  1.8 mm/m airport runways and superhighways
    1.4 -  3.4 mm/m new pavements
    2.2 -  5.7 mm/m older pavements
    3.2 -  9.8 mm/m maintained unpaved roads
    4.0 - 11.0 mm/m damaged pavements
    8.0 - >
    20 mm/m rough unpaved roads

    Speed of normal use (IRI):
    30 km/h - 20   mm/m
    50 km/h - 14.5 mm/m
    60 km/h - 10.0 mm/m
    80 km/h -  8.5 mm/m
    100 km/h -  3.4 mm/m

    Road conditions (IRI);
    15 mm/m erosion gulleys and deep depressions
    11 mm/m frequent shallow depressions, some deep
    9 mm/m frequent minor depressions
    5 mm/m surface imperfections

    Unit: mm/m

    \\par Reference:
    [1] Sayers, M. W. & Karamihas, S. M. (1998). <em>Little Book of Profiling</em>. University of Michigan Transportation Research Institute. Retrieved January 25, 2020, from http://www.umtri.umich.edu/content/LittleBook98R.pdf pp. 45 ff.

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    surface_texture: "float" = betterproto2.field(6, betterproto2.TYPE_DOUBLE)
    """
    The surface texture or fine roughness

    Whereas the IRI-based roughness or unevenness measure only takes
    into account road wavelengths around 0.5 m - 100 m, the surface
    texture or fine roughness [1] measures only wavelengths below
    0.5 m. It is given as the standard height deviation of fine
    roughness

    Unit: m

    \\par Reference:
    [1] Schneider, R. (1998). <em>Modellierung der Wellenausbreitung fuer ein bildgebendes Kfz-Radar</em>. PhD thesis. Karlsruhe, Germany. Universitaet Karlsruhe, Fak. f. Elektrotechnik.
    """


default_message_pool.register_message(
    "osi3", "Lane.Classification.RoadCondition", LaneClassificationRoadCondition
)


@dataclass(eq=False, repr=False)
class LaneBoundary(betterproto2.Message):
    """

    \\brief A lane boundary defining the border of a lane.

    The left and right lane boundary define the width of the lane. Additionally,
    free markings can be defined, e.g. at construction sites. Free markings
    across multiple lanes may be defined multiple times for all affected lanes.

    \\image html OSI_LaneBoundary.svg "LaneBoundary" width=800px

    \\note In the example, the symbols l1, l2, ... and lb1, lb2, ...
    stand for the lane ids and lane boundary ids respectively, i.e. for
    integers (uint64). The symbols bp2_{i+1}, bp2_{i}, bp2_{i-1} stand
    for \\c #osi3::LaneBoundary::BoundaryPoint elements.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_LANE_PROTO_DESCRIPTOR.message_types_by_name["LaneBoundary"]

    id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the lane boundary.

    \\rules
    is_globally_unique
    \\endrules
    """

    boundary_line: "list[LaneBoundaryBoundaryPoint]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of individual points defining the location of the lane boundary
    (as a list of segments).

    Since a \\c BoundaryPoint is part of a sequence, only the position
    attribute has to be set for each instance. All other values will be
    reused from the previous \\c BoundaryPoint in the sequence or set to
    default values if there is none or it was never set.

    \\image html OSI_LaneBoundary.svg "" width=800px

    Example: The boundary_line of the \\c LaneBoundary with id lb2 is given by
    (bp2_1, ..., bp2_{i-1}, bp2_{i}, bp2_{i+1}, ...).

    \\attention The ordering of the points must be the same for all lane boundaries
    on one road (also for roads with two-way traffic) and also the center line(s). 
    Example: If the points are deducted from a map format, the order of points 
    is recommended to be in line with the road coordinate (e.g. s-coordinate in 
    OpenDRIVE). 

    \\note For dashed lines, one \\c BoundaryPoint has to be at the start and
    another at the end of each dashed line segment. The first
    \\c BoundaryPoint defines the beginning of the first dashed lane marking.
    The last \\c BoundaryPoint defines the end of the last dashed lane
    marking.
    \\note For Botts' dots lines, one \\c BoundaryPoint position has to define
    each Botts' dot.

    \\attention For \\c BoundaryPoint the same rule for the approximation
    error applies as for \\c Lane::Classification::centerline.

    \\rules
    first_element width is_equal_to 0.13
    first_element height is_equal_to 0.14
    last_element width is_equal_to 0.13
    last_element height is_equal_to 0.13
    \\endrules
    """

    classification: "LaneBoundaryClassification | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The classification of the lane boundary.
    """

    source_reference: "list[ExternalReference]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Optional external reference to the lane boundary source.

    \\note For OpenDRIVE, there is no direct possibility to reference the
          RoadMark, as there is no unique identifier in this sub-object.

    \\note For non-ASAM Standards, it is implementation-specific how
          source_reference is resolved.

    \\note The value has to be repeated because one object may be derived
          from more than one origin source, for example, from a scenario file
          and from sensors.
    """

    color_description: "ColorDescription | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The visual color of the material of the lane boundary.

    \\note This does not represent the semantic classification but the visual
    appearance. For semantic classification of the lane boundary use the color
    field in \\c Classification.
    """


default_message_pool.register_message("osi3", "LaneBoundary", LaneBoundary)


@dataclass(eq=False, repr=False)
class LaneBoundaryBoundaryPoint(betterproto2.Message):
    """

    \\brief A single point of a lane boundary.

    \\image html OSI_LaneBoundaries_And_CenterLine.svg "" width=800px

    \\note
    cl: center line
    lb: lane boundary

    \\image html OSI_LaneBoundary.svg "" width=800px

    The lane boundary point bp2_{i} is one of the points of lane boundary
    lb2.

    \\note In the example, the symbols l1, l2, ... and lb1, lb2, ...
    stand for the lane ids and lane boundary ids respectively, i.e. for
    integers (uint64). The symbols bp2_{i+1}, bp2_{i}, bp2_{i-1} stand
    for \\c #osi3::LaneBoundary::BoundaryPoint elements.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_LANE_PROTO_DESCRIPTOR.message_types_by_name[
            "LaneBoundary.BoundaryPoint"
        ]

    position: "Vector3D | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The position of the \\c BoundaryPoint.
    """

    width: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    The overall width of the lane boundary at the position of the
    \\c BoundaryPoint .
    Used for lines forming lane markings.

    \\image html OSI_LaneBoundaryWidth.svg "" width=600px

    \\note Field need not be set if it is defined previous.
    See \\c LaneBoundary.
    """

    height: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    The overall height of the lane boundary at the position of the
    \\c BoundaryPoint .
    Used for guard rails, curbstone, or similar.

    \\image html OSI_LaneBoundaryHeight.svg "" width=600px

    \\note Field need not be set if it is previously defined.

    \\note The boundary point height should not be used to model the boundary 
          between two adjacent lanes at different heights as a single, shared 
          boundary.
          Boundaries between adjacent lanes at different heights should be 
          modeled as two separate lane boundaries.

    See \\c LaneBoundary .
    """

    dash: "LaneBoundaryBoundaryPointDash" = betterproto2.field(
        4,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: LaneBoundaryBoundaryPointDash(0),
    )
    """
    Alternation of dashes in case of a dashed lane boundary. In
    context, this field gives information about the location of
    dashes on the boundary line.
    """


default_message_pool.register_message(
    "osi3", "LaneBoundary.BoundaryPoint", LaneBoundaryBoundaryPoint
)


@dataclass(eq=False, repr=False)
class LaneBoundaryClassification(betterproto2.Message):
    """

    \\brief \\c Classification of a lane boundary.

    <table border = 0>
    <tr>
    <td>
    <table border=0>
    <tr>
    <td>
    <b>
    Image Intersection
    </b>
    <tr>
    <td>
    <tr>
    <td>
    \\c Classification for lane boundaries lb2 and lb9:
    </td>
    </tr>
    <tr>
    <td>
    <table border = 0>
    <tr>
    <td>
    \\c #type = #TYPE_DASHED_LINE
    <tr>
    <td>
    \\c #color = #COLOR_WHITE
    <tr>
    </table>
    </td>
    </tr>
    <tr>
    <td>
    \\c Classification for lane boundaries lb1, lb3, lb4, lb7, lb8, lb10,
    lb11, lb12 and lb14:
    </td>
    </tr>
    <tr>
    <td>
    <table border = 0>
    <tr>
    <td>
    \\c #type = #TYPE_SOLID_LINE
    <tr>
    <td>
    \\c #color = #COLOR_WHITE
    <tr>
    </table>
    </td>
    </tr>
    <tr>
    <td>
    \\c Classification for lane boundaries lb5, lb6 and lb13:
    </td>
    </tr>
    <tr>
    <td>
    <table border = 0>
    <tr>
    <td>
    \\c #type = #TYPE_CURB
    </table>
    </td>
    </tr>
    </table>
    </td>
    <td>
    <table border=0>
    <tr>
    <td>
    \\image html OSI_LaneIntersection.svg "" width=500px
    </td>
    <tr>
    <td>
    \\image html OSI_LaneBoundaryClassification.jpg "" width=600px
    </td>
    </table>
    </td>
    </tr>
    </table>

    \\note In the example, the symbols l1, l2, ... and lb1, lb2, ...
    stand for the lane ids and lane boundary ids respectively, i.e. for
    integers (uint64). The symbols cl1, cl2, ... represent the
    osi3::Lane::Classification::centerline elements of the lanes with
    the respective ids.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_LANE_PROTO_DESCRIPTOR.message_types_by_name[
            "LaneBoundary.Classification"
        ]

    type: "LaneBoundaryClassificationType" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: LaneBoundaryClassificationType(0),
    )
    """
    The type of the lane boundary.
    """

    color: "LaneBoundaryClassificationColor" = betterproto2.field(
        2,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: LaneBoundaryClassificationColor(0),
    )
    """
    The semantic color of the lane boundary in case of lane markings.

    \\note The color types represent the semantic classification of
    lane markings only. They do not represent an actual visual appearance.
    """

    limiting_structure_id: "list[Identifier]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The ids of \\c StationaryObject which limit the corresponding lane.
    This field must be set if the \\c #type is set to
    \\c #TYPE_STRUCTURE

    \\rules
    refers_to: StationaryObject
    \\endrules
    """


default_message_pool.register_message(
    "osi3", "LaneBoundary.Classification", LaneBoundaryClassification
)


@dataclass(eq=False, repr=False)
class LidarDetection(betterproto2.Message):
    """

    \\brief A point or vertical line in a lidar point cloud.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_FEATUREDATA_PROTO_DESCRIPTOR.message_types_by_name["LidarDetection"]

    existence_probability: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Existence probability of the detection not based on history. Value does
    not depend on any past experience with similar detections.

    \\note Used as confidence measure where a low value means less confidence
    and a high value indicates strong confidence.

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 1
    \\endrules
    """

    object_id: "Identifier | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    ID of the detected object this detection is associated to.

    \\note ID = MAX(uint64) indicates no reference to an object.

    \\rules
    refers_to: DetectedObject
    \\endrules
    """

    position: "Spherical3D | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Measured position of the detection given in spherical coordinates in the
    sensor coordinate system.
    """

    position_rmse: "Spherical3D | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Root mean squared error of the measured position of the detection.
    """

    height: "float" = betterproto2.field(5, betterproto2.TYPE_DOUBLE)
    """
    The height value which is required when multiple scan points are
    vertically clustered. Only vertical clustering is allowed (z-axis).

    Unit: m

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    height_rmse: "float" = betterproto2.field(6, betterproto2.TYPE_DOUBLE)
    """
    Root mean squared error of the object height.

    Unit: m

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    intensity: "float" = betterproto2.field(7, betterproto2.TYPE_DOUBLE)
    """
    Intensity or equivalent value of the detection's echo.

    Unit: %

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 100
    \\endrules
    """

    free_space_probability: "float" = betterproto2.field(8, betterproto2.TYPE_DOUBLE)
    """
    The free space probability in the range [0.0, 1.0] from the origin of the
    sensor up to this detection, as given by the distance.

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 1
    \\endrules
    """

    classification: "DetectionClassification" = betterproto2.field(
        9, betterproto2.TYPE_ENUM, default_factory=lambda: DetectionClassification(0)
    )
    """
    Basic classification of the detection.
    """

    reflectivity: "float" = betterproto2.field(10, betterproto2.TYPE_DOUBLE)
    """
    Lambertian reflectivity.
    """

    echo_pulse_width: "float" = betterproto2.field(11, betterproto2.TYPE_DOUBLE)
    """
    Echo pulse width of the detection's echo.
    Several sensors output an echo pulse width instead of an intensity for each individual detection.
    The echo pulse is measured in m and measures the extent of the object parts or atmospheric particles that produce the echo.
    \\note For more details see [1] Fig. 7 and 8.
    \\note Fig. 7 shows an example where the two echos are reflected from the edges A-B and C-D.
    \\note Fig. 8 shows how the echo pulse width is measured as the range between the rising edge and the falling edge that crosses the intensity threshold.

    Unit: m

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules

    \\par Reference:
    [1] Rosenberger, P., Holder, M.F., Cianciaruso, N. et al. (2020). <em>Sequential lidar sensor system simulation: a modular approach for simulation-based safety validation of automated driving</em> Automotive Engine Technology 5, Fig 7, Fig 8. Retrieved May 10, 2021, from https://doi.org/10.1007/s41104-020-00066-x
    """

    radial_velocity: "float" = betterproto2.field(12, betterproto2.TYPE_DOUBLE)
    """
    Radial velocity of the detection positive in direction to the sensor.

    Unit: m/s
    """

    beam_id: "Identifier | None" = betterproto2.field(
        13, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    ID of the corresponding lidar beam.
    """


default_message_pool.register_message("osi3", "LidarDetection", LidarDetection)


@dataclass(eq=False, repr=False)
class LidarDetectionData(betterproto2.Message):
    """

    \\brief Data from one lidar sensor including a list of detections.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_FEATUREDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "LidarDetectionData"
        ]

    header: "SensorDetectionHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Header attributes of lidar detection from one lidar sensor.
    """

    detection: "list[LidarDetection]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of lidar detections.
    """


default_message_pool.register_message("osi3", "LidarDetectionData", LidarDetectionData)


@dataclass(eq=False, repr=False)
class LidarSensorView(betterproto2.Message):
    """

    \\brief Definition of the lidar sensor view.

    Lidar specific sensor view data.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORVIEW_PROTO_DESCRIPTOR.message_types_by_name["LidarSensorView"]

    view_configuration: "LidarSensorViewConfiguration | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Lidar view configuration valid at the time the data was created.
    """

    reflection: "list[LidarSensorViewReflection]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Ray tracing data.

    This field includes one entry for each ray, in left-to-right,
    top-to-bottom order (think of scan lines in a TV).
    """


default_message_pool.register_message("osi3", "LidarSensorView", LidarSensorView)


@dataclass(eq=False, repr=False)
class LidarSensorViewReflection(betterproto2.Message):
    """

    \\brief Definition of the lidar reflection.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORVIEW_PROTO_DESCRIPTOR.message_types_by_name[
            "LidarSensorView.Reflection"
        ]

    signal_strength: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Relative signal level of the reflection.

    This takes the signal losses due to scattering and absorption
    into account, and will, when multiplied by TX power yield the
    potential RX power (disregarding any other RX/TX losses).

    Unit: dB
    """

    time_of_flight: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Time of flight.

    This is the time of flight of the reflection, which is directly
    proportional to the distance traveled.

    Unit: s
    """

    doppler_shift: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    Doppler shift.

    Shift in frequency based on the specified TX frequency.

    Unit: Hz
    """

    normal_to_surface: "Vector3D | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    normal to surface angle.

    The normal of the transmitted beam to the object, road marking, etc.
    encounter. \\note data is in Lidar coordinate system

    Unit: unit vector
    """

    object_id: "Identifier | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    ID of the detected object this reflection is associated to.
    can be used for ray tracing debug

    \\note ID = MAX(uint64) indicates no reference to an object.
    """


default_message_pool.register_message(
    "osi3", "LidarSensorView.Reflection", LidarSensorViewReflection
)


@dataclass(eq=False, repr=False)
class LidarSensorViewConfiguration(betterproto2.Message):
    """

    \\brief The configuration settings for the Lidar Sensor View to be provided
    by the environment simulation.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORVIEWCONFIGURATION_PROTO_DESCRIPTOR.message_types_by_name[
            "LidarSensorViewConfiguration"
        ]

    sensor_id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the sensor at host vehicle's mounting_position.

    This is the ID of the physical sensor, to be used in its detected
    features output; it is distinct from the ID of its virtual sensor.

    The ID is to be provided by the environment simulation, the sensor
    model is not in a position to provide a useful default value.
    """

    mounting_position: "MountingPosition | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The physical mounting position of the sensor (origin and orientation
    of the sensor coordinate system) given in vehicle coordinates [1].
    The physical position pertains to this detector individually, and
    governs the sensor-relative coordinates in features detected by this
    detector.

    \\arg \\b x-direction of sensor coordinate system: sensor viewing direction
    \\arg \\b z-direction of sensor coordinate system: sensor (up)
    \\arg \\b y-direction of sensor coordinate system: perpendicular to x and z
    right hand system

    \\par Reference:
    [1] DIN Deutsches Institut fuer Normung e. V. (2013). <em>DIN ISO 8855 Strassenfahrzeuge - Fahrzeugdynamik und Fahrverhalten - Begriffe</em>. (DIN ISO 8855:2013-11). Berlin, Germany.

    \\note The origin of vehicle's coordinate system in world frame is
    ( \\c MovingObject::base . \\c BaseMoving::position +
    Inverse_Rotation_yaw_pitch_roll( \\c MovingObject::base . \\c
    BaseMoving::orientation) * \\c
    MovingObject::VehicleAttributes::bbcenter_to_rear) . The orientation of
    the vehicle's coordinate system is equal to the orientation of the
    vehicle's bounding box \\c MovingObject::base . \\c
    BaseMoving::orientation. \\note A default position can be provided by the
    sensor model (e.g. to indicate the position the model was validated for),
    but this is optional; the environment simulation must provide a valid
    mounting position (based on the vehicle configuration) when setting the
    view configuration.
    """

    mounting_position_rmse: "MountingPosition | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The root mean squared error of the mounting position.
    """

    field_of_view_horizontal: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)
    """
    Field of View in horizontal orientation of the physical sensor.

    Viewing range: [- \\c #field_of_view_horizontal/2,  \\c
    #field_of_view_horizontal/2] azimuth in the sensor frame as defined in \\c
    Spherical3d.

    Unit: rad
    """

    field_of_view_vertical: "float" = betterproto2.field(5, betterproto2.TYPE_DOUBLE)
    """
    Field of View in vertical orientation of the physical sensor.

    Viewing range: [- \\c #field_of_view_vertical/2,  \\c
    #field_of_view_vertical/2] elevation in the sensor frame at zero azimuth
    as defined in \\c Spherical3d.

    Unit: rad
    """

    number_of_rays_horizontal: "int" = betterproto2.field(6, betterproto2.TYPE_UINT32)
    """
    Number of rays to cast across horizontal field of view.

    \\note This is a characteristic of the ray tracing engine of the
    environment simulation, not a direct characteristic of the sensor.

    \\rules
    is_greater_than_or_equal_to: 1
    \\endrules
    """

    number_of_rays_vertical: "int" = betterproto2.field(7, betterproto2.TYPE_UINT32)
    """
    Number of rays to cast across vertical field of view.

    \\note This is a characteristic of the ray tracing engine of the
    environment simulation, not a direct characteristic of the sensor.

    \\rules
    is_greater_than_or_equal_to: 1
    \\endrules
    """

    max_number_of_interactions: "int" = betterproto2.field(8, betterproto2.TYPE_UINT32)
    """
    Maximum number of interactions to take into account.

    \\note This is a characteristic of the ray tracing engine of the
    environment simulation, not a direct characteristic of the sensor.

    \\rules
    is_greater_than_or_equal_to: 1
    \\endrules
    """

    emitter_frequency: "float" = betterproto2.field(9, betterproto2.TYPE_DOUBLE)
    """
    Emitter Frequency.

    This information can be used by a ray tracing engine to calculate
    doppler shift information and take into account differences in
    refraction and reflection. For doppler shift calculations the
    sensor model can of course always provide a nominal frequency and
    adjust the resulting doppler shift information to actual frequency
    through frequency adjustments. For material and geometry interaction
    purposes the frequency is also relevant.

    Unit: Hz

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    num_of_pixels: "int" = betterproto2.field(10, betterproto2.TYPE_UINT32)
    """
    Number of pixels in frame.

    This field includes the number of pixels in each frame

    \\rules
    is_greater_than_or_equal_to: 1
    \\endrules
    """

    directions: "list[Vector3D]" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Ray tracing data.

    The directions unit vectors describing the Lidar's raster transmission
    directions. Length is num_of_pixels \\note data is in Lidar's coordinate
    system
    """

    timings: "list[int]" = betterproto2.field(
        12, betterproto2.TYPE_UINT32, repeated=True
    )
    """
    Ray tracing data.

    The time offset in microseconds of every measurement from each frame
    timestamp. Length is num_of_pixels
    """


default_message_pool.register_message(
    "osi3", "LidarSensorViewConfiguration", LidarSensorViewConfiguration
)


@dataclass(eq=False, repr=False)
class LidarSpecificObjectData(betterproto2.Message):
    """

    \\brief Message encapsulates all data for detected objects that is specific to
    lidar sensors.

    currently no fields.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORSPECIFIC_PROTO_DESCRIPTOR.message_types_by_name[
            "LidarSpecificObjectData"
        ]

    pass


default_message_pool.register_message(
    "osi3", "LidarSpecificObjectData", LidarSpecificObjectData
)


@dataclass(eq=False, repr=False)
class LogicalDetection(betterproto2.Message):
    """

    \\brief A logical detection that could be based on multiple sensors and sensor types.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_LOGICALDETECTIONDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "LogicalDetection"
        ]

    existence_probability: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Existence probability of the logical detection

    \\note Use as confidence measure where a low value means less confidence
    and a high value indicates strong confidence.

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 1
    \\endrules
    """

    object_id: "Identifier | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    ID of the detected object this logical detection is associated to.

    \\note ID = MAX(uint64) indicates no reference to an object.

    \\rules
    refers_to: DetectedObject
    \\endrules
    """

    position: "Vector3D | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Measured position of the logical detection given in cartesian coordinates
    in the virtual sensor coordinate system.

    Unit: m
    """

    position_rmse: "Vector3D | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Root mean squared error of the measured position of the logical detection.
    """

    velocity: "Vector3D | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Velocity of the logical detection given in cartesian coordinates in the
    virtual sensor coordinate system.

    Unit: m/s
    """

    velocity_rmse: "Vector3D | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Root mean squared error of the logical detection's velocity.

    Unit: m/s

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    intensity: "float" = betterproto2.field(7, betterproto2.TYPE_DOUBLE)
    """
    Intensity or equivalent value of the logical detection's echo.

    Unit: %

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 100
    \\endrules
    """

    snr: "float" = betterproto2.field(8, betterproto2.TYPE_DOUBLE)
    """
    The signal to noise ratio (SNR) of the logical detection.

    Unit: dB
    """

    point_target_probability: "float" = betterproto2.field(9, betterproto2.TYPE_DOUBLE)
    """
    Describes the possibility whether more than one object may have led to
    this logical detection.

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 1
    \\endrules
    """

    sensor_id: "list[Identifier]" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The ID(s) of the sensor(s) that produced the detection(s) for transformation
    and - in case of multiple sensors - fusion into the single logical detection.

    \\note One logical detection can originate from multiple sensors.
    """

    classification: "LogicalDetectionClassification" = betterproto2.field(
        11,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: LogicalDetectionClassification(0),
    )
    """
    Basic classification of the logical detection.
    """

    echo_pulse_width: "float" = betterproto2.field(12, betterproto2.TYPE_DOUBLE)
    """
    Echo pulse width of the logical detection's echo.
    Several sensors output an echo pulse width instead of an intensity for each individual detection.
    The echo pulse is measured in m and measures the extent of the object parts or atmospheric particles that produce the echo.
    \\note For more details see [1] Fig. 7 and 8.
    \\note Fig. 7 shows an example where the two echos are reflected from the edges A-B and C-D.
    \\note Fig. 8 shows how the echo pulse width is measured as the range between the rising edge and the falling edge that crosses the intensity threshold.

    Unit: m

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules

    \\par Reference:
    [1] Rosenberger, P., Holder, M.F., Cianciaruso, N. et al. (2020). <em>Sequential lidar sensor system simulation: a modular approach for simulation-based safety validation of automated driving</em> Automotive Engine Technology 5, Fig 7, Fig 8. Retrieved May 10, 2021, from https://doi.org/10.1007/s41104-020-00066-x
    """


default_message_pool.register_message("osi3", "LogicalDetection", LogicalDetection)


@dataclass(eq=False, repr=False)
class LogicalDetectionData(betterproto2.Message):
    """

    \\brief Processed data from one or multiple sensors as a list of logical detections.
    Logical detections are derived from sensor detections in a logical model through processing steps like fusion filtering, tracking etc.

    All information is given with respect to the reference frame of the logical/virtual sensor
    \\c SensorView::mounting_position (e.g. center of rear axle of the ego car) in Cartesian coordinates.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_LOGICALDETECTIONDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "LogicalDetectionData"
        ]

    version: "InterfaceVersion | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The interface version used by the sender (i.e. the simulation
    environment).

    \\rules
    is_set
    \\endrules
    """

    header: "LogicalDetectionDataHeader | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Header attributes of fused detections from multiple sensors and sensor types.
    """

    logical_detection: "list[LogicalDetection]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Logical detections consisting of transformed (and potentially fused)
    detections from one or multiple sensors and sensor types.

    The parent frame of a logical detection is the virtual sensor coordinate
    system specified by \\c SensorView::mounting_position .

    /note The virtual sensor coordinate system is relative to the vehicle
    coordinate system which has its origin in the center of the rear axle of
    the ego vehicle. This means if virtual sensor mounting position and
    orientation are set to (0,0,0) the virtual sensor coordinate system
    coincides with the vehicle coordinate system.
    """


default_message_pool.register_message(
    "osi3", "LogicalDetectionData", LogicalDetectionData
)


@dataclass(eq=False, repr=False)
class LogicalDetectionDataHeader(betterproto2.Message):
    """

    \\brief The header attributes of each sensor's logical detections list.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_LOGICALDETECTIONDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "LogicalDetectionDataHeader"
        ]

    logical_detection_time: "Timestamp | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Time stamp at which the transformation and optional fusion was finished in the global synchronized time.

    \\note See \\c SensorData::timestamp and
    \\c SensorData::last_measurement_time for detailed discussions on the
    semantics of time-related fields.
    """

    data_qualifier: "LogicalDetectionDataHeaderDataQualifier" = betterproto2.field(
        2,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: LogicalDetectionDataHeaderDataQualifier(0),
    )
    """
    Data Qualifier expresses to what extent the content of this event can be
    relied on.
    """

    number_of_valid_logical_detections: "int" = betterproto2.field(
        3, betterproto2.TYPE_UINT32
    )
    """
    The current number of valid detections in the logical detections list.

    \\note This value has to be set if the list contains invalid logical detections.

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    sensor_id: "list[Identifier]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The ID(s) of the sensor(s) that produced the detections for transformation
    and - in case of multiple sensors - fusion into logical detections.
    """


default_message_pool.register_message(
    "osi3", "LogicalDetectionDataHeader", LogicalDetectionDataHeader
)


@dataclass(eq=False, repr=False)
class LogicalLane(betterproto2.Message):
    """

    \\brief A logical lane in the road network.

    A logical lane is part of a road. Compared to a physical lane (OSI type
    \\c Lane), its existence doesn't hinge on the existence of road markings. So
    e.g. a road with two driving directions but no road markings in-between
    would be presented as two \\link LogicalLane LogicalLanes\\endlink, but only
    one Lane. So one Lane can consist of multiple \\link LogicalLane
    LogicalLanes\\endlink. E.g. on intersections, each driving path is one
    LogicalLane, but the whole area is one \\c Lane of type \\link
    osi3::Lane::Classification::TYPE_INTERSECTION \\c TYPE_INTERSECTION \\endlink.

    Outside of intersections, logical lanes are constructed such that each point on
    the road belongs to at least one (typically: exactly one) logical lane. So
    there are no gaps between logical lanes, and no areas that don't belong to a
    logical lane.

    If OSI is generated from OpenDRIVE, then \\link LogicalLane
    LogicalLanes\\endlink map directly to OpenDRIVE lanes. However, it is allowed
    to merge multiple consecutive (in S direction) OpenDRIVE lanes with the same
    type into one OSI LogicalLane: if an OpenDRIVE lane has a single successor,
    which has the same lane type, and this successor has only one predecessor
    (so no lane merging or splitting) then the two lanes may be presented as one
    continuous LogicalLane. This may be done recursively.

    The \\link ReferenceLine reference line\\endlink pointed to by
    #reference_line_id defines an ST coordinate system for the lane. This ST
    coordinate system is used to describe positions on the lane.

    ## Example

    The example below shows two logical lanes on an intersection, with a focus
    on the left-turn lane (\\c l1):
    \\image html OSI_LogicalLane1.png "Two logical lanes on an intersection"

    Assumptions not shown in the image:
    - This is right-hand traffic (and thus vehicles on \\c l1 drive from the bottom
      to the left, vehicles on \\c l2 drive from right to left).
    - The yellow line is a ReferenceLine, defined starting at the bottom, and
      going to the left.

    Some features shown in the image relative to \\c l1:
    - The yellow line is the ReferenceLine of \\c l1 . The ReferenceLine can be
      shared with other lanes.  Because the ReferenceLine has the same direction
      as the driving direction of \\c l1 in this example,
      <code>#move_direction == #MOVE_DIRECTION_INCREASING_S</code>.
    - The red line marks the area where \\c l2 is left of
      \\c l1 - this info is recorded in #left_adjacent_lane of \\c l1.
    - The red area is the area where \\c l2 overlaps \\c l1. This is recorded in
      #overlapping_lane of \\c l1.

    The image below shows the same two lanes, but from the perspective of \\c l2:
    \\image html OSI_LogicalLane2.png "Two logical lanes on an intersection"

    Assumptions not shown in the image:
    - The yellow line is a ReferenceLine, defined starting at the right, going
      to the left.

    Some features shown in the image relative to \\c l2:
    - The yellow line is the ReferenceLine of \\c l2 . The ReferenceLine can be
      shared with other lanes.  Because the ReferenceLine has the same direction
      as the driving direction of \\c l2 in this example,
      <code>#move_direction == #MOVE_DIRECTION_INCREASING_S</code>.
    - The green line marks the area where \\c l1 is right of
      \\c l2 - this info is recorded in #right_adjacent_lane of \\c l2.
    - The red area is the area where \\c l1 overlaps \\c l2. This is recorded in
      #overlapping_lane of \\c l1.

    As can be seen in the images, the two highlighted lanes are neighbors for
    part of their length, but it makes no sense for them to have the same
    reference line, since they diverge significantly.

    Note: all the relations shown above are also defined outside of intersections.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_LOGICALLANE_PROTO_DESCRIPTOR.message_types_by_name["LogicalLane"]

    id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the logical lane.

    \\note Note ID is global unique.

    \\rules
    is_globally_unique
    \\endrules
    """

    type: "LogicalLaneType" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: LogicalLaneType(0)
    )
    """
    The type of the logical lane.
    """

    source_reference: "list[ExternalReference]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Optional external reference to the lane source.

    The external reference points to the source of the lane, if it is derived
    from one or more objects or external references.

    For example, to reference a lane defined in an OpenDRIVE map
    the items should be set as follows:
    * reference = URI to map, can remain empty if identical with definition
                  in \\c GroundTruth::map_reference
    * type = "net.asam.opendrive"
    * identifier[0] = id of t_road
    * identifier[1] = s of t_road_lanes_laneSection
    * identifier[2] = id of t_road_lanes_laneSection_left_lane,
                            t_road_lanes_laneSection_right_lane

    \\note For non-ASAM Standards, it is implementation-specific how
          source_reference is resolved.

    \\note The value has to be repeated, because one lane segment may be
          derived from more than one origin segment. Multiple sources
          may be added as reference as well, for example, a map and sensors.
    """

    physical_lane_reference: "list[LogicalLanePhysicalLaneReference]" = (
        betterproto2.field(4, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    Reference to the physical lanes this logical lane belongs to.

    This makes it possible to get detailed information on the physical lane
    properties, e.g. the visual colors of the boundaries, the road
    condition, etc..

    Note: a logical lane may consist of several physical lanes (in a row).
    At any one S position, a logical lane should only reference one physical
    lane. Several logical lanes may reference the same physical lane (see
    drawing below).

    Logical lanes should not extend beyond intersections. All logical lanes
    on intersections should end at the latest at the border of the
    intersection.

    Example:
    <pre>
    ---------------------------------
     l1                       l2
    ----------    l3        ---------
     l4                       l5
    ---------------------------------
    </pre>

    In this case, we have five physical lanes: l1, l2, l4 and l5 where a
    lane marking is present. And l3 is one lane covering the whole road
    (because no road marking is present).

    This would typically be presented as two logical lanes:
    - One encompassing l1, part of l3, and l2
    - The other encompassing l4, part of l3 and l5

    In this example, both logical lanes would reference l3. Their shared
    LogicalLaneBoundary would cut through the middle of l3.

    physical_lane_reference does not give any information how much of the
    area of a physical lane is covered by a logical lane.

    For LogicalLanes without a correspondence to a Lane.Classification.Subtype 
    (i.e. TYPE_MEDIAN, TYPE_CURB, TYPE_TRAM, TYPE_RAIL) this field has no value.

    \\rules
    refers_to: Lane
    \\endrules
    """

    reference_line_id: "Identifier | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The \\link ReferenceLine reference line\\endlink for this logical lane

    The reference line is used as a coordinate system on this lane.

    The reference line should roughly have the same shape as the lane, so
    that S coordinates continually increase/decrease along the lane. It is
    not required that the reference line has the same direction as the
    driving direction of the lane.

    Neighboring lanes (i.e. lanes that are neighbors and whose directions
    do not diverge significantly) are strongly encouraged to reference the
    same ReferenceLine, so that vehicles that are next to each other on
    neighboring lanes have comparable S positions.

    The S coordinate of the reference line makes it easy to find e.g. which
    object is next on a lane, using the LogicalLaneAssignment of the
    objects.

    The reference trajectory must be sampled such that there are no two
    positions on the lane more than 5cm apart with the same ST coordinate.

    \\rules
    refers_to: ReferenceLine
    \\endrules
    """

    start_s: "float" = betterproto2.field(6, betterproto2.TYPE_DOUBLE)
    """
    Start S position of the lane.

    Must be in range [\\c sStart,\\c sEnd] of the reference line.
    """

    end_s: "float" = betterproto2.field(7, betterproto2.TYPE_DOUBLE)
    """
    End S position of the lane.

    Must be in range [\\c sStart,\\c sEnd] of the reference line.

    Requirement: #end_s > #start_s
    """

    move_direction: "LogicalLaneMoveDirection" = betterproto2.field(
        8, betterproto2.TYPE_ENUM, default_factory=lambda: LogicalLaneMoveDirection(0)
    )
    """
    Definition of the intended driving direction.
    """

    right_adjacent_lane: "list[LogicalLaneLaneRelation]" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Lanes that are directly right of this lane, without gap or overlap.

    "Right" is in definition direction (not driving direction), so right lanes
    have smaller T coordinates.
    Entries must be ordered: first by #start_s, then by #end_s.

    The XY positions of the polyline generated by the LogicalLaneBoundaries
    of adjacent lanes must match up to a small error (5cm).
    Typically adjacent lanes will share a LogicalLaneBoundary, but this will
    not always be true. Examples: on intersections, it might be hard to generate
    data such that lanes that are adjacent for a short length share a
    LogicalLaneBoundary for this length; also different LogicalLaneBoundaries
    are needed if the lanes have different heights at their boundaries (e.g.
    road adjacent to a sidewalk).
    """

    left_adjacent_lane: "list[LogicalLaneLaneRelation]" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Lanes that are directly left of this lane, without gap or overlap.

    "Left" is in definition direction (not driving direction), so left lanes
    have larger T coordinates.
    Entries must be ordered: first by #start_s, then by #end_s.

    The XY positions of the polyline generated by the LogicalLaneBoundaries
    of adjacent lanes must match up to a small error (5cm).
    Typically adjacent lanes will share a LogicalLaneBoundary, but this will
    not always be true. Examples: on intersections, it might be hard to generate
    data such that lanes that are adjacent for a short length share a
    LogicalLaneBoundary for this length; also different LogicalLaneBoundaries
    are needed if the lanes have different heights at their boundaries (e.g.
    road adjacent to a sidewalk).
    """

    overlapping_lane: "list[LogicalLaneLaneRelation]" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Lanes that partially or completely overlap this lane.

    Only overlaps laterally larger than 5cm are considered overlaps for the
    purpose of this relation.

    This will typically contain a lot of entries on intersections, but might
    also be used outside of intersections (e.g. if a #TYPE_BIKING lane
    overlaps a #TYPE_NORMAL lane).

    Entries must be ordered: first by #start_s, then by #end_s.
    """

    right_boundary_id: "list[Identifier]" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Right boundary of this lane.

    References to LogicalLaneBoundary elements.
    All LogicalLaneBoundary elements referenced here must refer to the same
    ReferenceLine as this lane.
    The boundaries together must cover the whole length of the lane (the
    range \\[#start_s,#end_s\\]) without gap or overlap. The boundaries must be
    stored in ascending order, starting with the smallest S position.
    Consecutive boundaries must share a point: the last point of the
    previous boundary must be identical to the first point of the next
    boundary.

    Note: the referenced boundaries may have points outside of
    \\[#start_s,#end_s\\] (e.g. a boundary may extend beyond the end of a lane).

    Note: A curb is a type of LogicalLane and of LaneBoundary. 
    If LogicalLane.Type == TYPE_CURB, by convention this
    field references the respective LaneBoundary of TYPE_CURB
    identically to the left_boundary_id of this LogicalLane.

    \\rules
    refers_to: LogicalLaneBoundary
    \\endrules
    """

    left_boundary_id: "list[Identifier]" = betterproto2.field(
        13, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Left boundary of this lane.

    References to LogicalLaneBoundary elements.
    All LogicalLaneBoundary elements referenced here must refer to the same
    ReferenceLine as this lane.
    The boundaries together must cover the whole length of the lane (the
    range \\[#start_s,#end_s\\]) without gap or overlap. The boundaries must be
    stored in ascending order, starting with the smallest S position.
    Consecutive boundaries must share a point: the last point of the
    previous boundary must be identical to the first point of the next
    boundary.

    Note: the referenced boundaries may have points outside of
    \\[#start_s,#end_s\\] (e.g. a boundary may extend beyond the end of a lane).

    Note: A curb is a type of LogicalLane and of LaneBoundary. 
    If LogicalLane.Type == TYPE_CURB, by convention this
    field references the respective LaneBoundary of TYPE_CURB.
    identically to the right_boundary_id of this LogicalLane.    

    \\rules
    refers_to: LogicalLaneBoundary
    \\endrules
    """

    predecessor_lane: "list[LogicalLaneLaneConnection]" = betterproto2.field(
        14, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Lanes that directly are connected to this lane at the beginning.

    "Beginning" is relative to the reference line, so connections at #start_s.

    Lane predecessors and successors shall only be used to connect lanes if
    a physical connection at the beginning or end of both lanes exist. Both
    lanes have a non-zero width at the connection point and they are
    semantically connected.

    A lane may have several predecessors e.g. on intersections, or if a wide
    lane splits into two, or two merge into one.
    """

    successor_lane: "list[LogicalLaneLaneConnection]" = betterproto2.field(
        15, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Lanes that directly are connected to this lane at the end.

    "End" is relative to the reference line, so connections at #end_s.

    Lane predecessors and successors shall only be used to connect lanes if
    a physical connection at the beginning or end of both lanes exist. Both
    lanes have a non-zero width at the connection point and they are
    semantically connected.

    A lane may have several successors e.g. on intersections, or if a wide
    lane splits into two, or two merge into one.
    """

    street_name: "str" = betterproto2.field(16, betterproto2.TYPE_STRING)
    """
    Name of the street this lane belongs to.
    """

    traffic_rule: "list[LogicalLaneTrafficRule]" = betterproto2.field(
        17, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of traffic rules on the lane.
    """


default_message_pool.register_message("osi3", "LogicalLane", LogicalLane)


@dataclass(eq=False, repr=False)
class LogicalLaneLaneConnection(betterproto2.Message):
    """

    \\brief Connection to another lane (predecessor or successor)
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_LOGICALLANE_PROTO_DESCRIPTOR.message_types_by_name[
            "LogicalLane.LaneConnection"
        ]

    other_lane_id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Id of the other logical lane that is connected.

    \\rules
    refers_to: LogicalLane
    \\endrules
    """

    at_begin_of_other_lane: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)
    """
    If true: LaneConnection is at the beginning of the other lane
    If false: LaneConnection is a the end of the other lane
    """


default_message_pool.register_message(
    "osi3", "LogicalLane.LaneConnection", LogicalLaneLaneConnection
)


@dataclass(eq=False, repr=False)
class LogicalLaneLaneRelation(betterproto2.Message):
    """

    \\brief Relation of this lane to another logical lane
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_LOGICALLANE_PROTO_DESCRIPTOR.message_types_by_name[
            "LogicalLane.LaneRelation"
        ]

    other_lane_id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Id of the other logical lane.

    \\rules
    refers_to: LogicalLane
    \\endrules
    """

    start_s: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Start s position of the relation.
    """

    end_s: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    End s position of the relation.

    Requirement: #end_s > #start_s
    """

    start_s_other: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)
    """
    Start s position of the relation on the other lane.

    This is the same place as #start_s, but measured along the reference
    line of the other lane.
    """

    end_s_other: "float" = betterproto2.field(5, betterproto2.TYPE_DOUBLE)
    """
    End s position of the relation on the other lane.

    This is the same place as #end_s, but measured along the reference
    line of the other lane.

    Note: #end_s_other might be smaller than #start_s_other
    """


default_message_pool.register_message(
    "osi3", "LogicalLane.LaneRelation", LogicalLaneLaneRelation
)


@dataclass(eq=False, repr=False)
class LogicalLanePhysicalLaneReference(betterproto2.Message):
    """

    \\brief Reference to a physical lane.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_LOGICALLANE_PROTO_DESCRIPTOR.message_types_by_name[
            "LogicalLane.PhysicalLaneReference"
        ]

    physical_lane_id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Id of the physical lane referenced.

    \\rules
    refers_to: Lane
    \\endrules
    """

    start_s: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    S position on the logical lane where the physical lane starts.
    """

    end_s: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    S position on the logical lane where the physical lane ends.

    Requirement: #end_s > #start_s
    """


default_message_pool.register_message(
    "osi3", "LogicalLane.PhysicalLaneReference", LogicalLanePhysicalLaneReference
)


@dataclass(eq=False, repr=False)
class LogicalLaneTrafficRule(betterproto2.Message):
    """

    Describes traffic rules on a lane.
    The traffic rule can thereby be induced by regulations, traffic signs
    or by other means. If the modeled traffic rule is induced by a traffic sign
    the information should be identical with the respective traffic sign.

    Note: Every instance should be corresponding to only one specific rule.
    The type of the traffic rule should be set using the respective field.
    Additionally, every message should contain the traffic rule validity information
    and the respective field for the respective traffic rule type.
    In case of traffic rule (priority) conflicts for rules of the same type that
    can not be depicted using the traffic rule validity only the currently
    valid rule should be provided.

    Note: Each traffic rule corresponds to only one lane. If the traffic rule
    is also valid on adjacent/successor/predecessor lanes it needs to be
    specified for each lane individually.

    \\brief Logical Model of a traffic rule on a lane.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_LOGICALLANE_PROTO_DESCRIPTOR.message_types_by_name[
            "LogicalLane.TrafficRule"
        ]

    traffic_rule_type: "LogicalLaneTrafficRuleTrafficRuleType" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: LogicalLaneTrafficRuleTrafficRuleType(0),
    )
    """
    The type of the traffic rule.

    This specifies the type of the traffic rule to be modeled.
    Based on the type the respective message containing the information
    corresponding to the traffic rule should be filled.
    """

    traffic_rule_validity: "LogicalLaneTrafficRuleTrafficRuleValidity | None" = (
        betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    The validity information of the traffic rule.
    """

    speed_limit: "LogicalLaneTrafficRuleSpeedLimit | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Traffic rule information for traffic rule of type speed limit.
    """


default_message_pool.register_message(
    "osi3", "LogicalLane.TrafficRule", LogicalLaneTrafficRule
)


@dataclass(eq=False, repr=False)
class LogicalLaneTrafficRuleSpeedLimit(betterproto2.Message):
    """

    \\brief Speed limit on a lane.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_LOGICALLANE_PROTO_DESCRIPTOR.message_types_by_name[
            "LogicalLane.TrafficRule.SpeedLimit"
        ]

    speed_limit_value: "TrafficSignValue | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    
    The value of the speed limit.
    The unit field in the TrafficSignValue message may only be set to
    units associated with velocities and must not be UNKNOWN.

    Note: All speed limits are to be modeled this way, independent
    of how they are induced.
    """


default_message_pool.register_message(
    "osi3", "LogicalLane.TrafficRule.SpeedLimit", LogicalLaneTrafficRuleSpeedLimit
)


@dataclass(eq=False, repr=False)
class LogicalLaneTrafficRuleTrafficRuleValidity(betterproto2.Message):
    """

    \\brief Validity information for a traffic rule.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_LOGICALLANE_PROTO_DESCRIPTOR.message_types_by_name[
            "LogicalLane.TrafficRule.TrafficRuleValidity"
        ]

    start_s: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    
    The starting point of the traffic rule validity on the lane.
    Must be in range [\\c sStart,\\c sEnd] of the reference line.

    Note: The traffic rule applies only to traffic with notional
    direction of travel from the start_s coordinate towards
    the end_s coordinate. For unidirectional lanes this must
    match the direction of travel as specified by the
    move_direction field of the logical lane. For bidirectional
    lanes this allows the specification of separate rules for
    each direction of travel.
    """

    end_s: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    
    The ending point of the traffic rule validity on the lane.
    Must be in range [\\c sStart,\\c sEnd] of the reference line.
    """

    valid_for_type: "list[LogicalLaneTrafficRuleTrafficRuleValidityTypeValidity]" = (
        betterproto2.field(3, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    
    List of traffic participant types for which the speed limit is valid.
    If the traffic rule validity is independent of the vehicle type 
    the list should be empty.
    """


default_message_pool.register_message(
    "osi3",
    "LogicalLane.TrafficRule.TrafficRuleValidity",
    LogicalLaneTrafficRuleTrafficRuleValidity,
)


@dataclass(eq=False, repr=False)
class LogicalLaneTrafficRuleTrafficRuleValidityTypeValidity(betterproto2.Message):
    """

    \\brief Type of traffic participant for which a rule is valid.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_LOGICALLANE_PROTO_DESCRIPTOR.message_types_by_name[
            "LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity"
        ]

    type: "MovingObjectType" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: MovingObjectType(0)
    )
    """
    
    The type of object for which the traffic rule is valid.
    """

    vehicle_type: "MovingObjectVehicleClassificationType" = betterproto2.field(
        2,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: MovingObjectVehicleClassificationType(0),
    )
    """
    
    Vehicle classification type for traffic participants.

    Should be set to TYPE_UNKNOWN if type is not TYPE_VEHICLE
    or the rule is valid for all vehicle types.
    """

    vehicle_role: "MovingObjectVehicleClassificationRole" = betterproto2.field(
        3,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: MovingObjectVehicleClassificationRole(0),
    )
    """
    
    Role of traffic participant.

    Should be set to ROLE_UNKNOWN if type is not TYPE_VEHICLE
    or the rule is valid for all vehicle roles.
    """


default_message_pool.register_message(
    "osi3",
    "LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity",
    LogicalLaneTrafficRuleTrafficRuleValidityTypeValidity,
)


@dataclass(eq=False, repr=False)
class LogicalLaneAssignment(betterproto2.Message):
    """

    \\brief Assignment of an object to a logical lane

    An object is assigned to a logical lane if it overlaps the logical lane.
    Assignment happens even if the reference point is outside the lane, and only
    a part of the object overlaps (any object overlapping the lane more than 5cm
    has to be assigned to the lane).

    As an exception to this, \\c TrafficSign and \\c TrafficLight are assigned to
    a logical lane if they control traffic on that lane. For \\c TrafficSign and
    \\c TrafficLight , #s_position refers to the position where the sign or light
    is valid (e.g. where vehicles should stop in case of a red traffic light),
    not the physical position (where the sign or light is in the world).
    Typically, t_position and angle_to_lane do not have any meaning in this
    case, and will be 0.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name[
            "LogicalLaneAssignment"
        ]

    assigned_lane_id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    ID of the LogicalLane the object is assigned to.

    \\rules
    refers_to: LogicalLane
    \\endrules
    """

    s_position: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    S position of the object reference point on the lane, in the ST
    coordinate system of the lane.

    #s_position might be outside [s_start,s_end] of the lane (and even
    outside [startS,endS] of the reference line) if the reference point is
    outside the lane, but the object overlaps the lane or a TrafficSign or
    TrafficLight is assigned to a lane.
    """

    t_position: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    T position of the object reference point on the lane, in the ST
    coordinate system of the lane.
    """

    angle_to_lane: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)
    """
    Angle of the object relative to the lane.
    See the ReferenceLine description how the angle is calculated.

    Unit: rad
    """


default_message_pool.register_message(
    "osi3", "LogicalLaneAssignment", LogicalLaneAssignment
)


@dataclass(eq=False, repr=False)
class LogicalLaneBoundary(betterproto2.Message):
    """

    \\brief Boundary line of a LogicalLane

    Similar to a LaneBoundary, but with a reference line and ST positions.

    A logical lane boundary describes the boundary between two logical lanes. As
    such, there will always be exactly one logical lane boundary between two
    lanes at a given S position. Contrary to that, there can be 0 to N physical
    lane boundaries (i.e. type LaneBoundary) between two logical lanes at a
    given S position.

    If there are multiple physical lane boundaries at one S position between two
    lanes (think of a solid-broken marking, which would be described by two
    LaneBoundary objects, one for the solid lane marking, one for the broken lane
    marking), then the single LogicalLaneBoundary describing the boundary between
    two logical lanes should be between the physical boundaries.

    A logical lane boundary consists of a list of \\link LogicalBoundaryPoint
    LogicalBoundaryPoints\\endlink. Each point has a XYZ and an ST coordinate.
    The XYZ coordinates describe the position and height of the boundary in the
    world.

    Notes on design decisions:
    - The LogicalLaneBoundary has ST coordinates, and is thus a separate type
      from LaneBoundary.
      Advantages of this decision:
      - Calculations like getting the lane width at a position are easy, since
        one can just get the boundary points of the left and right boundary at
        the desired S position (via linear interpolation), and calculate the
        width from the two points. Also getting something like the distance to
        the lane border is very easy.
      - No centerline of the lane is necessary, since this can very easily be
        generated from the boundaries.
      Disadvantages of this decision:
      - %Lane boundaries cannot be shared with physical lanes. This results in
        more data needed. This can mostly be mitigated by only transmitting the
        lane boundaries during initialization (e.g. via the OSMP GroundTruthInit
        message).
    - The LogicalLaneBoundary contains all data directly which an agent model is
      likely to need. It does not include information normally only used by
      sensor models (e.g. the exact length of the color markings on the road).
      This information can be gotten from the physical lane referenced in the
      LogicalLane, if needed.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_LOGICALLANE_PROTO_DESCRIPTOR.message_types_by_name[
            "LogicalLaneBoundary"
        ]

    id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the lane boundary.

    \\rules
    is_globally_unique
    is_set
    \\endrules
    """

    boundary_line: "list[LogicalLaneBoundaryLogicalBoundaryPoint]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Points making up the lane boundary.

    The boundary must be defined in the same direction as the reference
    line. So S positions should increase along the line. Note that S
    positions will not always increase strictly monotonically.
    Example:
    <pre>
                   |---------\\
                   |          \\
     /---boundary--|           \\\\------------
    /
    ---------- reference line --------------
    </pre>
    At the place where the boundary suddenly increases, two points will have
    the same S coordinate.

    If the boundary approximates a curve (e.g. a cubic function in
    OpenDRIVE), the points must be chosen in a way that the lateral distance
    to the ideal line does not exceed 5cm. As shown in the following image:

    \\image html line_approximation_error.svg "Approximation error"
    Approximation error green line.

    The Z error (difference in Z height between #boundary_line and the
    "real" line) must not exceed 2cm. This is a stricter requirement than
    for errors in the XY plane, because Z differences between lanes
    influence driving very much.

    Note: if two lanes have different Z heights (e.g. a driving lane is
    beside a sidewalk, where the sidewalk is 10cm higher than the road),
    then these lanes cannot share a boundary, since their boundaries have
    different Z heights.
    """

    reference_line_id: "Identifier | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The reference line for this boundary.

    The reference line is used as a coordinate system for this boundary.
    All points of this LogicalLaneBoundary must have S coordinates in the
    range [\\c sStart,\\c sEnd].

    The reference line should roughly have the same shape as the boundary (so
    roughly parallel to the lane middle), so that S coordinates continually
    increase along the boundary.

    \\rules
    refers_to: ReferenceLine
    \\endrules
    """

    physical_boundary_id: "list[Identifier]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Reference to the physical lane boundary or boundaries that make up this
    logical boundary.

    Rules and notes:
    - This list is empty if there are no physical lane boundaries to delimit
      a lane.
    - In the common case, this will contain one physical boundary.
    - This list contains several lane boundaries if there are several physical
      lane boundaries at one S position (e.g. both a broken and a solid
      line).
    - If there are several lane boundaries, they must be listed in increasing
      T order (i.e. from right to left in reference line direction).
      Rationale: this makes it easier to determine e.g. rules on lane
      changes, which depend on the T order of the lanes.
    - Whenever physical lane boundaries begin or end, or switch their T
      position (if there are multiple physical lane boundaries), a new
      LogicalLaneBoundary must be created.
    - The referenced LaneBoundary objects may be longer than the
      LogicalLaneBoundary which references them, but must never be shorter.

    Example:
    <pre>
          Lane 1
     --------a------------------ - - - -c- - - -           ----&gt;
     \\- - - -b- - - -
          Lane -1
    </pre>

    This shows the boundary between lane 1 and lane -1, with the reference
    line going from left to right. First there is a solid-broken line (a and
    b), then there is only a solid line (a), then there is a broken line
    (c). There would be three LogicalLaneBoundary objects between Lane1 and
    Lane2: the first would reference first b and then a, the second would
    reference only a, and the third would reference c.

    \\rules
    refers_to: LaneBoundary
    \\endrules
    """

    passing_rule: "LogicalLaneBoundaryPassingRule" = betterproto2.field(
        5,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: LogicalLaneBoundaryPassingRule(0),
    )
    """
    The passing rules, insomuch as they can be determined just from road
    markings.
    """

    source_reference: "list[ExternalReference]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Optional external reference to the lane boundary source.

    \\note For OpenDRIVE, there is no direct possibility to reference the
          RoadMark, as there is no unique identifier in this sub-object.

    \\note For non-ASAM Standards, it is implementation-specific how
          source_reference is resolved.

    \\note The value has to be repeated because one object may be derived
          from more than one origin source, for example, from a scenario file
          and from sensors.
    """


default_message_pool.register_message(
    "osi3", "LogicalLaneBoundary", LogicalLaneBoundary
)


@dataclass(eq=False, repr=False)
class LogicalLaneBoundaryLogicalBoundaryPoint(betterproto2.Message):
    """

    \\brief A point on the boundary
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_LOGICALLANE_PROTO_DESCRIPTOR.message_types_by_name[
            "LogicalLaneBoundary.LogicalBoundaryPoint"
        ]

    position: "Vector3D | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The position of the \\c LaneBoundaryPoint.
    """

    s_position: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    S position of the LaneBoundaryPoint, measured along the parent's
    reference_line_id.
    """

    t_position: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    T position of the LaneBoundaryPoint, measured along the parent's
    reference_line_id.
    """


default_message_pool.register_message(
    "osi3",
    "LogicalLaneBoundary.LogicalBoundaryPoint",
    LogicalLaneBoundaryLogicalBoundaryPoint,
)


@dataclass(eq=False, repr=False)
class MapAsamOpenDrive(betterproto2.Message):
    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_MAPASAMOPENDRIVE_PROTO_DESCRIPTOR.message_types_by_name[
            "MapAsamOpenDrive"
        ]

    map_reference: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    open_drive_xml_content: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)


default_message_pool.register_message("osi3", "MapAsamOpenDrive", MapAsamOpenDrive)


@dataclass(eq=False, repr=False)
class MotionRequest(betterproto2.Message):
    """

    \\brief This message is intended as an interface between a
    motion-planning function and the actuator management.
    The motion-planning function can thereby be a representation of a
    highly-automated driving function, a human driving behavior model, etc.

    The motion-planning function can either send a desired future trajectory or a desired
    future state. The message can be defined by an additional variable.

    \\note The coordinate system is defined as right-handed.
    All coordinates and orientations are relative to the global coordinate system.
    The reference point of the vehicle is the middle of the rear axis.
    Units are m for positions, m/s for velocities, and m/s^2 for accelerations.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_MOTIONREQUEST_PROTO_DESCRIPTOR.message_types_by_name["MotionRequest"]

    version: "InterfaceVersion | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The interface version used by the sender (simulation environment).

    \\rules
    is_set
    \\endrules
    """

    timestamp: "Timestamp | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The data timestamp of the simulation environment.
    A reference to \\c Timestamp message.

    \\rules
    is_set
    \\endrules
    """

    motion_request_type: "MotionRequestMotionRequestType" = betterproto2.field(
        3,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: MotionRequestMotionRequestType(0),
    )
    """
    Define the type that is used to specify the motion request.
    This must be set. Additionally, the field corresponding to the specified 
    option must be set.
    """

    desired_state: "MotionRequestDesiredState | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Defines a desired state.
    If the output option is set to DESIRED_STATE, this field must be set.
    """

    desired_trajectory: "MotionRequestDesiredTrajectory | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Defines a desired trajectory.
    If the output option is set to DESIRED_TRAJECTORY, this field must be set.
    """


default_message_pool.register_message("osi3", "MotionRequest", MotionRequest)


@dataclass(eq=False, repr=False)
class MotionRequestDesiredState(betterproto2.Message):
    """
    \\brief The desired state is calculated by the function as a result of
    the motion planning stack.

    The actuator management is supposed to reach the desired state at the
    specified time.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_MOTIONREQUEST_PROTO_DESCRIPTOR.message_types_by_name[
            "MotionRequest.DesiredState"
        ]

    timestamp: "Timestamp | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    A reference to \\c Timestamp message.
    """

    position: "Vector3D | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Intended position to be reached in in x-, y-, and z-direction.
    """

    orientation: "Orientation3D | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Intended orientation to be reached containing yaw, pitch and roll angle.
    """

    velocity: "Vector3D | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Intended velocity to be reached in in x-, y-, and z-direction.

    Unit: m/s
    """

    acceleration: "Vector3D | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Intended acceleration to be reached in x-, y-, and z-direction.

    Unit: m/s^2
    """


default_message_pool.register_message(
    "osi3", "MotionRequest.DesiredState", MotionRequestDesiredState
)


@dataclass(eq=False, repr=False)
class MotionRequestDesiredTrajectory(betterproto2.Message):
    """
    \\brief Defined trajectory desired by the function.

    This trajectory is the result of the trajectory planning step in the function.
    The task of the actuator management is to follow this trajectory as closely as possible.
    The timestamps inside the trajectory must be defined in global simulation time.

    \\note The trajectory is kept as a separate message for future extensions.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_MOTIONREQUEST_PROTO_DESCRIPTOR.message_types_by_name[
            "MotionRequest.DesiredTrajectory"
        ]

    trajectory_point: "list[StatePoint]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The trajectory consists of intended position (x, y, and z) and
    orientation (yaw, pitch and roll) of intended state to be reached.
    A reference to \\c StatePoint message.

    \\note The position within the trajectory point references to the 
    middle point of the rear axis.
    """


default_message_pool.register_message(
    "osi3", "MotionRequest.DesiredTrajectory", MotionRequestDesiredTrajectory
)


@dataclass(eq=False, repr=False)
class MountingPosition(betterproto2.Message):
    """

    \\brief Specifies the mounting position of a sensor.

    Details are specified in each instance where \\c MountingPosition is used.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["MountingPosition"]

    position: "Vector3D | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Offset position relative to the specified reference coordinate system.
    """

    orientation: "Orientation3D | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Orientation offset relative to the specified reference coordinate system.

    \\f$ Origin_{sensor} :=
    Rotation_{yaw,pitch,roll}( \\f$ \\c #orientation \\f$
    )*(Origin_{\\text{reference coord system}}
    - \\f$ \\c #position \\f$ )\\f$
    """


default_message_pool.register_message("osi3", "MountingPosition", MountingPosition)


@dataclass(eq=False, repr=False)
class MovingObject(betterproto2.Message):
    """

    \\brief A simulated object that is either a vehicle or another
    moving object (animal, pedestrian, etc), but not a stationary
    object (\\c TrafficLight, \\c TrafficSign, or \\c StationaryObject).

    \\image html OSI_MovingObject.svg

    \\image html OSI_HostVehicle.svg

    \\note The fields \\c MovingObject::vehicle_attributes and \\c
    MovingObject::vehicle_classification have to be filled if the \\c
    MovingObject::Type is set to #TYPE_VEHICLE.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_OBJECT_PROTO_DESCRIPTOR.message_types_by_name["MovingObject"]

    id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the object.

    \\rules
    is_globally_unique
    is_set
    \\endrules
    """

    base: "BaseMoving | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The base parameters of the vehicle.

    \\note The bounding box does NOT include side mirrors for vehicles.
    \\note The height includes the ground_clearance. It always goes from the
    top to the ground.
    """

    type: "MovingObjectType" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: MovingObjectType(0)
    )
    """
    The type of the object.
    """

    assigned_lane_id: "list[Identifier]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The IDs of the lanes that this object is assigned to.

    \\note Might be multiple if the object is switching lanes or moving from
    one lane into another following lane.

    \\note DEPRECATED: Use assigned_lane_id in MovingObjectClassification
    instead.
    """

    vehicle_attributes: "MovingObjectVehicleAttributes | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Specific information about the vehicle.

    \\note This field is mandatory if the \\c #type is
    #TYPE_VEHICLE .

    \\rules
    check_if this.type is_equal_to 2 else do_check is_set
    \\endrules
    """

    vehicle_classification: "MovingObjectVehicleClassification | None" = (
        betterproto2.field(6, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Specific information about the classification of the vehicle.

    \\note This field is mandatory if the \\c #type is
    #TYPE_VEHICLE .

    \\rules
    check_if this.type is_equal_to 2 else do_check is_set
    \\endrules
    """

    model_reference: "str" = betterproto2.field(7, betterproto2.TYPE_STRING)
    """
    Opaque reference of an associated 3D model of the moving object.

    \\note It is implementation-specific how model_references are resolved to
    3d models.
    """

    future_trajectory: "list[StatePoint]" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The trajectory that this moving object expects to follow in the future.

    This is not externally perceivable information, rather this is to aid
    realistic simulation of traffic participants that are not under test.
    This information should not be made available to the stack under test.

    \\note Moving objects are not required to stick to this trajectory. It is
    indicative and equivalent to the output of a perception and prediction
    system.
    """

    moving_object_classification: "MovingObjectMovingObjectClassification | None" = (
        betterproto2.field(9, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Specific information about the classification of the vehicle.
    """

    source_reference: "list[ExternalReference]" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Optional external reference to the moving-object source

    The external reference points to the source of an moving object, if it
    is derived from an external sources like OpenSCENARIO.

    For example, to reference OpenSCENARIO entities of the type Vehicle or
    Pedestrian, which describe moving objects, the items should be set as
    follows:
    * reference = URI to the OpenSCENARIO File
    * type = "net.asam.openscenario"
    * identifier[0] = Entity-Type ("Vehicle" or "Pedestrian")
    * identifier[1] = name of Vehicle/Pedestrian in Entity

    \\note For non-ASAM Standards, it is implementation-specific how
          source_reference is resolved.

    \\note The value has to be repeated because one object may be derived
          from more than one origin source, for example, from a scenario file
          and from sensors.
    """

    color_description: "ColorDescription | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The dominating color of the material of the moving object.
    """

    pedestrian_attributes: "MovingObjectPedestrianAttributes | None" = (
        betterproto2.field(12, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Specific information about the pedestrian.

    \\note This field is mandatory if the \\c #type is
    #TYPE_PEDESTRIAN.

    \\rules
    check_if this.type is_equal_to 3 else do_check is_set
    \\endrules
    """


default_message_pool.register_message("osi3", "MovingObject", MovingObject)


@dataclass(eq=False, repr=False)
class MovingObjectMovingObjectClassification(betterproto2.Message):
    """

    \\brief Information for the classification of moving objects regarding
    \\c MovingObject (host or other).
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_OBJECT_PROTO_DESCRIPTOR.message_types_by_name[
            "MovingObject.MovingObjectClassification"
        ]

    assigned_lane_id: "list[Identifier]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The IDs of the lanes that this object is assigned to.

    \\note Might be multiple if the object is switching lanes or moving from
    one lane into another following lane.

    \\note OSI uses singular instead of plural for repeated field names.
    """

    assigned_lane_percentage: "list[float]" = betterproto2.field(
        2, betterproto2.TYPE_DOUBLE, repeated=True
    )
    """
    Percentage value of the object width in the corresponding lane.

    \\note Might be multiple if the object is switching lanes or moving from
    one lane into another following lane.

    \\note OSI uses singular instead of plural for repeated field names.
    """

    logical_lane_assignment: "list[LogicalLaneAssignment]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Assignment of this object to logical lanes.

    \\note OSI uses singular instead of plural for repeated field names.
    """


default_message_pool.register_message(
    "osi3",
    "MovingObject.MovingObjectClassification",
    MovingObjectMovingObjectClassification,
)


@dataclass(eq=False, repr=False)
class MovingObjectPedestrianAttributes(betterproto2.Message):
    """

    \\brief Additional pedestrian data in case the moving object is a human.

    This is an extension to the \\c MovingObject with additional information
    describing a pedestrian in more detail.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_OBJECT_PROTO_DESCRIPTOR.message_types_by_name[
            "MovingObject.PedestrianAttributes"
        ]

    bbcenter_to_root: "Vector3D | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Position offset from the center of the bounding box to the current position
    of the root point of the pedestrian skeleton model.
    """

    skeleton_bone: "list[MovingObjectPedestrianAttributesBone]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of all bones of the pedestrian.

    The number of bones may vary, based on the detail level of
    the pedestrian model used. For example, some simulators will not include
    detailed data about the hands of a pedestrian.

    \\note A bone of each type can be provided, or left out, depending
    on the desired level of detail, or available data. However, if a
    bone is defined, all bones in the chain from that bone back to
    the root point must be provided to create a complete chain.
    """


default_message_pool.register_message(
    "osi3", "MovingObject.PedestrianAttributes", MovingObjectPedestrianAttributes
)


@dataclass(eq=False, repr=False)
class MovingObjectPedestrianAttributesBone(betterproto2.Message):
    """

    \\brief Bones in the skeleton of the pedestrian.

    Each point represents a joint, or otherwise important point in the skeleton
    of a pedestrian. For example pelvis, knee or shoulder. The naming convention
    should be followed for identifying bones.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_OBJECT_PROTO_DESCRIPTOR.message_types_by_name[
            "MovingObject.PedestrianAttributes.Bone"
        ]

    type: "MovingObjectPedestrianAttributesBoneType" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: MovingObjectPedestrianAttributesBoneType(0),
    )
    """
    Bones are identified by their type, combined with which body side
    they are on.

    To properly identify the bones the pre-defined naming convention
    must be used.

    \\image html OSI_SkeletonNamingConvention.svg

    A bone's name, position, and orientation is defined by the end-point closer
    to the root. For example: the "LOWER_ARM_L" will define the point in the left
    elbow of the model.

    If a bone which is more than one layer detached from the
    root point is used, all bones between that bone and the root also
    need to be defined in order to create a complete chain!

    If information about bones are missing, they may be left empty.
    """

    position: "Vector3D | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Position of the bone.

    Reference System is the root, defined by bbcenter_to_root
    (\\c PedestrianAttributes::bbcenter_to_root).
    """

    orientation: "Orientation3D | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Orientation of the bone.

    Reference System is the root, defined by bbcenter_to_root
    (\\c PedestrianAttributes::bbcenter_to_root).
    """

    length: "float" = betterproto2.field(4, betterproto2.TYPE_FLOAT)
    """
    Length of the bone.

    Measured along its major axis.

    Unit: m
    """

    missing: "bool" = betterproto2.field(5, betterproto2.TYPE_BOOL)
    """
    Determines whether a bone is explicitly missing from the pedestrian model.

    In case a pedestrian has missing limbs this can be explicitly communicated
    by setting this boolean to TRUE.
    """

    velocity: "Vector3D | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The velocity of the bone.

    Reference System is the root, defined by bbcenter_to_root
    (\\c PedestrianAttributes::bbcenter_to_root).
    """

    orientation_rate: "Orientation3D | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The orientation rate of the bone.

    Reference System is the root, defined by bbcenter_to_root
    (\\c PedestrianAttributes::bbcenter_to_root).
    """


default_message_pool.register_message(
    "osi3",
    "MovingObject.PedestrianAttributes.Bone",
    MovingObjectPedestrianAttributesBone,
)


@dataclass(eq=False, repr=False)
class MovingObjectVehicleAttributes(betterproto2.Message):
    """

    \\brief The vehicle attributes for \\c MovingObject (host or other).

    This is an extension to the \\c MovingObject with additional attributes,
    such as type and lights. The origin of the rear (front) axis coordinate
    system in global coordinates is calculated as:
    \\c MovingObject::base . \\c BaseMoving::position + R * \\c
    MovingObject::VehicleAttributes::bbcenter_to_rear (front) for the host
    vehicle (R rotates from vehicle to world frame, i.e. inverse orientation
    of \\c MovingObject::base . \\c BaseMoving::orientation).

    For all vehicles, including host vehicles, the position given in
     \\c MovingObject::base . \\c BaseMoving::position points to the center of
     the vehicle's bounding box.

    The vehicle object coordinates are defined as x-axis is the direction
    from rear to front of the vehicle, y-axis corresponds to rear axle and
    z-axis points to vehicle ceiling [1]. The coordinate system is
    right-handed. Therefore the positive y-axis points to the left of the
    vehicle.

    \\par Reference:
    [1] DIN Deutsches Institut fuer Normung e. V. (2013). <em>DIN ISO 8855 Strassenfahrzeuge - Fahrzeugdynamik und Fahrverhalten - Begriffe</em>. (DIN ISO 8855:2013-11). Berlin, Germany.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_OBJECT_PROTO_DESCRIPTOR.message_types_by_name[
            "MovingObject.VehicleAttributes"
        ]

    driver_id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the driver of the (host) vehicle.

    \\note Field need not be set if host_vehicle is set to false or use
    value for non valid id.
    """

    radius_wheel: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Deprecated: Will be removed in next major release. Moved to WheelData.
    Median radius of the wheels measured from a center of the wheel
    including tire.

    Unit: m

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    number_wheels: "int" = betterproto2.field(3, betterproto2.TYPE_UINT32)
    """
    Number of independent wheels.

    \\rules
    is_greater_than_or_equal_to: 1
    \\endrules
    """

    bbcenter_to_rear: "Vector3D | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The vector pointing from the bounding box center point (\\c
    MovingObject::base . \\c BaseMoving::position) to the middle (in x, y
    and z) of the rear axle under neutral load conditions. In object
    coordinates.
    """

    bbcenter_to_front: "Vector3D | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The vector pointing from the bounding box center point (\\c
    MovingObject::base . \\c BaseMoving::position) to the middle (in x, y
    and z) of the front axle under neutral load conditions. In object
    coordinates.
    """

    ground_clearance: "float" = betterproto2.field(6, betterproto2.TYPE_DOUBLE)
    """
    Static minimal distance or space from the lowest point of the vehicle's
    body to the surface plane below it under neutral load conditions. This
    distance disregards, for example, driving-dynamic effects or
    road-surface effects. Can be useful to approximate the clearance area
    under a vehicle that a sensor can see through.
    \\note \\c ground_clearance is included in the bounding box height.
    """

    wheel_data: "list[MovingObjectVehicleAttributesWheelData]" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Description of each wheel.

    \\note OSI uses singular instead of plural for repeated field names.
    """

    steering_wheel_angle: "float" = betterproto2.field(8, betterproto2.TYPE_DOUBLE)
    """
    Angle of the steering wheel.
    Zero means the steering wheel is in its center position, a positive value
    means the steering wheel is turned to the left and a negative value
    means the steering wheel is turned to the right of the center position.

    Unit: rad
    """


default_message_pool.register_message(
    "osi3", "MovingObject.VehicleAttributes", MovingObjectVehicleAttributes
)


@dataclass(eq=False, repr=False)
class MovingObjectVehicleAttributesWheelData(betterproto2.Message):
    """
    \\brief Detailed wheel data.
    The focus is on the description of a wheel regarding the perceivable
    information from the outside.
    It is not intended to be used for dynamic calculations, for example.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_OBJECT_PROTO_DESCRIPTOR.message_types_by_name[
            "MovingObject.VehicleAttributes.WheelData"
        ]

    axle: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)
    """
    The axle which contains this wheel. A value of 0 represents the
    front-most axle of the vehicle with higher numbers incrementing
    towards the rear-most axle.
    """

    index: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)
    """
    The index of the wheel on the axle, counting in the direction
    of positive-y, that is, right-to-left.

    For example, on a standard 2-axle, 4-wheel car, the rear-right
    wheel would be (axle=1, index=0).
    This concept works also for twin tires.
    """

    position: "Vector3D | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    A vector pointing from the vehicle's reference system (center of bounding
    box) to the geometric center of the wheel.
    """

    wheel_radius: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)
    """
    Median radius of the wheel measured from the center of the wheel to
    the outer part of the tire.

    Unit: m
    """

    rim_radius: "float" = betterproto2.field(5, betterproto2.TYPE_DOUBLE)
    """
    Median radius of the rim measured from the center to the outer, visible part of the rim.

    Unit: m
    """

    width: "float" = betterproto2.field(6, betterproto2.TYPE_DOUBLE)
    """
    Median width of the tire.

    Unit: m
    """

    orientation: "Orientation3D | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Orientation of the wheel.

    The reference system is the vehicle frame (center of bounding box).
    """

    rotation_rate: "float" = betterproto2.field(8, betterproto2.TYPE_DOUBLE)
    """
    Rotation rate of the wheel.
    The rotation rate around the y-axis with respect to the wheel's coordinate system.

    Unit: rad/s.

    The sign convention is defined using the right-hand rule.
    It is applied on the y-axis of the vehicle's reference system (center of bounding box).
    Counterclockwise is positive and clockwise is negative.

    \\image html OSI_RotationRate.svg
    \\note The vehicle's reference coordinate system is only used to determine the sign convention of the rotation rate.
    """

    model_reference: "str" = betterproto2.field(9, betterproto2.TYPE_STRING)
    """
    Opaque reference of an associated 3D model of the wheel.

    \\note It is implementation-specific how model_references are resolved to
    3d models.
    """

    friction_coefficient: "float" = betterproto2.field(10, betterproto2.TYPE_DOUBLE)
    """
    The value describes the kinetic friction of the tire's contact point.
    If different friction coefficients due to more than one contact points are available,
    this value contains the average.

    Unit: Dimensionless

    \\par References:
    [1] Britannica, T. Editors of Encyclopaedia. (2020, June 24). <em>coefficient of friction</em>. Retrieved May 18, 2022, from https://www.britannica.com/science/coefficient-of-friction
    """


default_message_pool.register_message(
    "osi3",
    "MovingObject.VehicleAttributes.WheelData",
    MovingObjectVehicleAttributesWheelData,
)


@dataclass(eq=False, repr=False)
class MovingObjectVehicleClassification(betterproto2.Message):
    """

    \\brief Information for the classification of vehicles regarding
    \\c MovingObject (host or other).
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_OBJECT_PROTO_DESCRIPTOR.message_types_by_name[
            "MovingObject.VehicleClassification"
        ]

    type: "MovingObjectVehicleClassificationType" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: MovingObjectVehicleClassificationType(0),
    )
    """
    The type of the vehicle.
    """

    light_state: "MovingObjectVehicleClassificationLightState | None" = (
        betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    The light state of the vehicle.
    """

    has_trailer: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)
    """
    Flag defining whether the vehicle has an attached trailer.
    """

    trailer_id: "Identifier | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Id of the attached trailer.

    \\note Field need not be set if has_Trailer is set to false or use
    value for non valid id.

    \\rules
    check_if this.has_trailer is_equal_to true else do_check is_set
    \\endrules
    """

    role: "MovingObjectVehicleClassificationRole" = betterproto2.field(
        5,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: MovingObjectVehicleClassificationRole(0),
    )
    """
    The role of the vehicle.
    """


default_message_pool.register_message(
    "osi3", "MovingObject.VehicleClassification", MovingObjectVehicleClassification
)


@dataclass(eq=False, repr=False)
class MovingObjectVehicleClassificationLightState(betterproto2.Message):
    """

    \\brief The state of the lights of a vehicle.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_OBJECT_PROTO_DESCRIPTOR.message_types_by_name[
            "MovingObject.VehicleClassification.LightState"
        ]

    indicator_state: "MovingObjectVehicleClassificationLightStateIndicatorState" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: MovingObjectVehicleClassificationLightStateIndicatorState(
            0
        ),
    )
    """
    State of the object's indicators.
    """

    front_fog_light: "MovingObjectVehicleClassificationLightStateGenericLightState" = betterproto2.field(
        2,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: MovingObjectVehicleClassificationLightStateGenericLightState(
            0
        ),
    )
    """
    State of the front fog light.
    """

    rear_fog_light: "MovingObjectVehicleClassificationLightStateGenericLightState" = betterproto2.field(
        3,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: MovingObjectVehicleClassificationLightStateGenericLightState(
            0
        ),
    )
    """
    State of the rear fog light.
    """

    head_light: "MovingObjectVehicleClassificationLightStateGenericLightState" = betterproto2.field(
        4,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: MovingObjectVehicleClassificationLightStateGenericLightState(
            0
        ),
    )
    """
    State of the head lights.
    """

    high_beam: "MovingObjectVehicleClassificationLightStateGenericLightState" = betterproto2.field(
        5,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: MovingObjectVehicleClassificationLightStateGenericLightState(
            0
        ),
    )
    """
    State of the high beam.
    """

    reversing_light: "MovingObjectVehicleClassificationLightStateGenericLightState" = betterproto2.field(
        6,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: MovingObjectVehicleClassificationLightStateGenericLightState(
            0
        ),
    )
    """
    State of the reversing light.
    """

    brake_light_state: "MovingObjectVehicleClassificationLightStateBrakeLightState" = betterproto2.field(
        7,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: MovingObjectVehicleClassificationLightStateBrakeLightState(
            0
        ),
    )
    """
    State of the brake lights.
    """

    license_plate_illumination_rear: "MovingObjectVehicleClassificationLightStateGenericLightState" = betterproto2.field(
        8,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: MovingObjectVehicleClassificationLightStateGenericLightState(
            0
        ),
    )
    """
    State of the (rear) license plate illumination.
    """

    emergency_vehicle_illumination: "MovingObjectVehicleClassificationLightStateGenericLightState" = betterproto2.field(
        9,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: MovingObjectVehicleClassificationLightStateGenericLightState(
            0
        ),
    )
    """
    Lighting of emergency vehicles (ambulance, fire engine, police
    car, etc.). Must be set only if a vehicle is allowed to use this
    illumination type.
    """

    service_vehicle_illumination: "MovingObjectVehicleClassificationLightStateGenericLightState" = betterproto2.field(
        10,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: MovingObjectVehicleClassificationLightStateGenericLightState(
            0
        ),
    )
    """
    Lighting of service vehicles (snow removal, garbage truck, towing
    vehicle, slow or wide vehicle, etc.). Must be set only if a
    vehicle is allowed to use this illumination type.
    """


default_message_pool.register_message(
    "osi3",
    "MovingObject.VehicleClassification.LightState",
    MovingObjectVehicleClassificationLightState,
)


@dataclass(eq=False, repr=False)
class Occupant(betterproto2.Message):
    """

    \\brief An occupant of a host vehicle, especially the driver of the vehicle.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_OCCUPANT_PROTO_DESCRIPTOR.message_types_by_name["Occupant"]

    id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the driver.

    \\rules
    is_globally_unique
    \\endrules
    """

    classification: "OccupantClassification | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Specific information about the classification of the occupant.
    """

    source_reference: "list[ExternalReference]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    External reference to the occupant source.

    \\note For OpenDRIVE and OpenSCENARIO there is no direct counterpart.

    \\note For non-ASAM Standards, it is implementation-specific how
          source_reference is resolved.

    \\note The value has to be repeated because one object may be derived
          from more than one origin source, for example, from a scenario file
          and from sensors.
    """


default_message_pool.register_message("osi3", "Occupant", Occupant)


@dataclass(eq=False, repr=False)
class OccupantClassification(betterproto2.Message):
    """

    \\brief Information regarding the classification of the occupant.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_OCCUPANT_PROTO_DESCRIPTOR.message_types_by_name[
            "Occupant.Classification"
        ]

    is_driver: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)
    """
    Flag determining whether the person is the driver of the vehicle or a
    passenger.
    """

    seat: "OccupantClassificationSeat" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: OccupantClassificationSeat(0)
    )
    """
    Seat position of the vehicle occupant.
    """

    steering_control: "OccupantClassificationSteeringControl" = betterproto2.field(
        4,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: OccupantClassificationSteeringControl(0),
    )
    """
    Describes the state of the passenger's hands related to the steering
    wheel (mostly driver).
    """


default_message_pool.register_message(
    "osi3", "Occupant.Classification", OccupantClassification
)


@dataclass(eq=False, repr=False)
class Orientation3D(betterproto2.Message):
    """

    \\brief A 3D orientation, orientation rate or orientation acceleration (i.e.
    derivatives) or its uncertainties denoted in euler angles.

    Units are rad for orientation, rad/s for rates, and rad/s^2 for
    accelerations

    The coordinate system is defined as right-handed.
    For the sense of each rotation, the right-hand rule applies.

    The rotations are to be performed \\b yaw \\b first (around the z-axis),
    \\b pitch \\b second (around the new y-axis) and \\b roll \\b third (around the
    new x-axis) to follow the definition according to [1] (Tait-Bryan / Euler
    convention z-y'-x''). The preferred angular range is [-pi, pi] for roll
    and yaw and [-pi/2, pi/2] for pitch.

    Roll/Pitch are 0 if the objects xy-plane is parallel to its parent's
    xy-plane. Yaw is 0 if the object's local x-axis is parallel to its parent's
    x-axis.

    \\f$ Rotation_{yaw,pitch,roll} =
    Rotation_{yaw}*Rotation_{pitch}*Rotation_{roll} \\f$

    \\f$ vector_{global coord system} := Rotation_{yaw, pitch, roll} * vector_{local coord system} +local_{origin::position} \\f$

    \\attention This definition changed in OSI version 3.0.0. Previous OSI
    versions  (V2.xx) had an other definition.

    \\par Reference:
    [1] DIN Deutsches Institut fuer Normung e. V. (2013). <em>DIN ISO 8855 Strassenfahrzeuge - Fahrzeugdynamik und Fahrverhalten - Begriffe</em>. (DIN ISO 8855:2013-11). Berlin, Germany.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["Orientation3d"]

    roll: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    The roll angle/rate/acceleration.

    Unit: rad, rad/s, or rad/s^2
    """

    pitch: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    The pitch angle/rate/acceleration.

    Unit: rad, rad/s, or rad/s^2
    """

    yaw: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    The yaw angle/rate/acceleration.

    Unit: rad, rad/s, or rad/s^2
    """


default_message_pool.register_message("osi3", "Orientation3d", Orientation3D)


@dataclass(eq=False, repr=False)
class Pedalry(betterproto2.Message):
    """

    \\brief A description for the positions of the pedals.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["Pedalry"]

    pedal_position_acceleration: "float" = betterproto2.field(
        1, betterproto2.TYPE_DOUBLE
    )
    """
    Position of the acceleration pedal.
    Range: 0-1 (Unpressed - fully pressed)
    """

    pedal_position_brake: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Position of the brake pedal.
    Range: 0-1 (Unpressed - fully pressed)
    """

    pedal_position_clutch: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    Position of the clutch pedal.
    Range: 0-1 (Unpressed - fully pressed)
    """


default_message_pool.register_message("osi3", "Pedalry", Pedalry)


@dataclass(eq=False, repr=False)
class Polygon3D(betterproto2.Message):
    """

    \\brief Polygon in 3 dimensions

    A polygon in 3 dimensions which contains a list of vertices.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["Polygon3d"]

    vertex: "list[Vector3D]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of vertices
    """


default_message_pool.register_message("osi3", "Polygon3d", Polygon3D)


@dataclass(eq=False, repr=False)
class RadarDetection(betterproto2.Message):
    """

    \\brief A radar detection.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_FEATUREDATA_PROTO_DESCRIPTOR.message_types_by_name["RadarDetection"]

    existence_probability: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Existence probability of the detection not based on history. Value does
    not depend on any past experience with similar detections.

    \\note Use as confidence measure where a low value means less confidence
    and a high value indicates strong confidence.

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 1
    \\endrules
    """

    object_id: "Identifier | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    ID of the detected object this detection is associated to.

    \\note ID = MAX(uint64) indicates no reference to an object.

    \\rules
    refers_to: DetectedObject
    \\endrules
    """

    position: "Spherical3D | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Measured position of the detection given in spherical coordinates in the
    sensor coordinate system.
    """

    position_rmse: "Spherical3D | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Root mean squared error of the measured position of the detection.
    """

    radial_velocity: "float" = betterproto2.field(5, betterproto2.TYPE_DOUBLE)
    """
    Radial velocity of the detection positive in direction to the sensor.

    Unit: m/s
    """

    radial_velocity_rmse: "float" = betterproto2.field(6, betterproto2.TYPE_DOUBLE)
    """
    Root mean squared error of the object measured radial velocity.

    Unit: m/s

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    rcs: "float" = betterproto2.field(7, betterproto2.TYPE_DOUBLE)
    """
    The radar cross section (RCS) of the radar detection.

    Unit: dB m^2
    """

    snr: "float" = betterproto2.field(8, betterproto2.TYPE_DOUBLE)
    """
    The signal to noise ratio (SNR) of the radar detection.

    Unit: dB
    """

    point_target_probability: "float" = betterproto2.field(9, betterproto2.TYPE_DOUBLE)
    """
    Describes the possibility whether more than one object may have led to
    this detection.

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 1
    \\endrules
    """

    ambiguity_id: "Identifier | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Ambiguity Information:
    Each ambiguous measurement generates one Ambiguity ID. Ambiguity is
    indicated by an identical ambiguity ID.

    \\note Unambiguous measurements have the ambiguity ID 0.

    \\note Multiple separate detections, from e.g. a large object, do not
    necessarily on their own create any ambiguity. Therefore they do not
    usually share an ambiguity ID. They can however be ambiguous
    with other detections.
    """

    classification: "DetectionClassification" = betterproto2.field(
        11, betterproto2.TYPE_ENUM, default_factory=lambda: DetectionClassification(0)
    )
    """
    Basic classification of the detection.
    """


default_message_pool.register_message("osi3", "RadarDetection", RadarDetection)


@dataclass(eq=False, repr=False)
class RadarDetectionData(betterproto2.Message):
    """

    \\brief Data from one radar sensor including a list of detections.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_FEATUREDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "RadarDetectionData"
        ]

    header: "SensorDetectionHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Header attributes of radar detection from one radar sensor.
    """

    detection: "list[RadarDetection]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of radar detections constituting the radar detection list.
    """


default_message_pool.register_message("osi3", "RadarDetectionData", RadarDetectionData)


@dataclass(eq=False, repr=False)
class RadarSensorView(betterproto2.Message):
    """

    \\brief Definition of the radar sensor view.

    Radar specific sensor view data.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORVIEW_PROTO_DESCRIPTOR.message_types_by_name["RadarSensorView"]

    view_configuration: "RadarSensorViewConfiguration | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Radar view configuration valid at the time the data was created.
    """

    reflection: "list[RadarSensorViewReflection]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Ray tracing data.

    This field includes one entry for each ray, in left-to-right,
    top-to-bottom order (think of scan lines in a TV).
    """


default_message_pool.register_message("osi3", "RadarSensorView", RadarSensorView)


@dataclass(eq=False, repr=False)
class RadarSensorViewReflection(betterproto2.Message):
    """

    \\brief Definition of the radar reflection.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORVIEW_PROTO_DESCRIPTOR.message_types_by_name[
            "RadarSensorView.Reflection"
        ]

    signal_strength: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Relative signal level of the reflection.

    This takes the combined antenna diagram (losses in TX and RX)
    as well as the signal losses due to scattering and absorption
    into account, and will, when multiplied by TX power yield the
    actual RX power.

    Unit: dB
    """

    time_of_flight: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Time of flight.

    This is the time of flight of the reflection, which is directly
    proportional to the distance traveled.

    Unit: s
    """

    doppler_shift: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    Doppler shift.

    Shift in frequency based on the specified TX frequency.

    Unit: Hz
    """

    source_horizontal_angle: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)
    """
    TX horizontal angle (azimuth).

    Horizontal angle of incidence of the source of the reflection
    at the TX antenna.

    Unit: rad
    """

    source_vertical_angle: "float" = betterproto2.field(5, betterproto2.TYPE_DOUBLE)
    """
    TX vertical angle (elevation).

    Vertical angle of incidence of the source of the reflection
    at the TX antenna.

    Unit: rad
    """


default_message_pool.register_message(
    "osi3", "RadarSensorView.Reflection", RadarSensorViewReflection
)


@dataclass(eq=False, repr=False)
class RadarSensorViewConfiguration(betterproto2.Message):
    """

    \\brief The configuration settings for the Radar Sensor View to be provided
    by the environment simulation.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORVIEWCONFIGURATION_PROTO_DESCRIPTOR.message_types_by_name[
            "RadarSensorViewConfiguration"
        ]

    sensor_id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the sensor at host vehicle's mounting_position.

    This is the ID of the physical sensor, to be used in its detected
    features output; it is distinct from the ID of its virtual sensor.

    The ID is to be provided by the environment simulation, the sensor
    model is not in a position to provide a useful default value.
    """

    mounting_position: "MountingPosition | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The physical mounting position of the sensor (origin and orientation
    of the sensor coordinate system) given in vehicle coordinates [1].
    The physical position pertains to this detector individually, and
    governs the sensor-relative coordinates in features detected by this
    detector.

    \\arg \\b x-direction of sensor coordinate system: sensor viewing direction
    \\arg \\b z-direction of sensor coordinate system: sensor (up)
    \\arg \\b y-direction of sensor coordinate system: perpendicular to x and z
    right hand system

    \\par Reference:
    [1] DIN Deutsches Institut fuer Normung e. V. (2013). <em>DIN ISO 8855 Strassenfahrzeuge - Fahrzeugdynamik und Fahrverhalten - Begriffe</em>. (DIN ISO 8855:2013-11). Berlin, Germany.

    \\note The origin of vehicle's coordinate system in world frame is
    ( \\c MovingObject::base . \\c BaseMoving::position +
    Inverse_Rotation_yaw_pitch_roll( \\c MovingObject::base . \\c
    BaseMoving::orientation) * \\c
    MovingObject::VehicleAttributes::bbcenter_to_rear) . The orientation of
    the vehicle's coordinate system is equal to the orientation of the
    vehicle's bounding box \\c MovingObject::base . \\c
    BaseMoving::orientation. \\note A default position can be provided by the
    sensor model (e.g. to indicate the position the model was validated for),
    but this is optional; the environment simulation must provide a valid
    mounting position (based on the vehicle configuration) when setting the
    view configuration.
    """

    mounting_position_rmse: "MountingPosition | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The root mean squared error of the mounting position.
    """

    field_of_view_horizontal: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)
    """
    Field of View in horizontal orientation of the physical sensor.

    Viewing range: [- \\c #field_of_view_horizontal/2,  \\c
    #field_of_view_horizontal/2] azimuth in the sensor frame as defined in \\c
    Spherical3d.

    Unit: rad
    """

    field_of_view_vertical: "float" = betterproto2.field(5, betterproto2.TYPE_DOUBLE)
    """
    Field of View in vertical orientation of the physical sensor.

    Viewing range: [- \\c #field_of_view_vertical/2,  \\c
    #field_of_view_vertical/2] elevation in the sensor frame at zero azimuth
    as defined in \\c Spherical3d.

    Unit: rad
    """

    number_of_rays_horizontal: "int" = betterproto2.field(6, betterproto2.TYPE_UINT32)
    """
    Number of rays to cast across horizontal field of view (azimuth).

    \\note This is a characteristic of the ray tracing engine of the
    environment simulation, not a direct characteristic of the sensor.

    \\rules
    is_greater_than_or_equal_to: 1
    \\endrules
    """

    number_of_rays_vertical: "int" = betterproto2.field(7, betterproto2.TYPE_UINT32)
    """
    Number of rays to cast across vertical field of view (elevation).

    \\note This is a characteristic of the ray tracing engine of the
    environment simulation, not a direct characteristic of the sensor.

    \\rules
    is_greater_than_or_equal_to: 1
    \\endrules
    """

    max_number_of_interactions: "int" = betterproto2.field(8, betterproto2.TYPE_UINT32)
    """
    Maximum number of interactions to take into account.

    \\note This is a characteristic of the ray tracing engine of the
    environment simulation, not a direct characteristic of the sensor.

    \\rules
    is_greater_than_or_equal_to: 1
    \\endrules
    """

    emitter_frequency: "float" = betterproto2.field(9, betterproto2.TYPE_DOUBLE)
    """
    Emitter Frequency.

    This information can be used by a ray tracing engine to calculate
    doppler shift information and take into account differences in
    refraction and reflection. For doppler shift calculations the
    sensor model can of course always provide a nominal frequency and
    adjust the resulting doppler shift information to actual frequency
    through frequency adjustments. For material and geometry interaction
    purposes the frequency is also relevant.

    Unit: Hz

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    tx_antenna_diagram: "list[RadarSensorViewConfigurationAntennaDiagramEntry]" = (
        betterproto2.field(10, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    This represents the TX antenna diagram
    """

    rx_antenna_diagram: "list[RadarSensorViewConfigurationAntennaDiagramEntry]" = (
        betterproto2.field(11, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    This represents the RX antenna diagram
    """


default_message_pool.register_message(
    "osi3", "RadarSensorViewConfiguration", RadarSensorViewConfiguration
)


@dataclass(eq=False, repr=False)
class RadarSensorViewConfigurationAntennaDiagramEntry(betterproto2.Message):
    """

    \\brief The radar antenna diagram.

    \\note Rotation is defined analog Spherical3d
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORVIEWCONFIGURATION_PROTO_DESCRIPTOR.message_types_by_name[
            "RadarSensorViewConfiguration.AntennaDiagramEntry"
        ]

    horizontal_angle: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Horizontal deflection (azimuth) of entry in sensor/antenna
    coordinates.

    Unit: rad
    """

    vertical_angle: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Vertical deflection (elevation) of entry in sensor/antenna
    coordinates.

    Unit: rad
    """

    response: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    Response of antenna at this point (positive dB is gain,
    negative dB is attenuation).

    Unit: dB
    """


default_message_pool.register_message(
    "osi3",
    "RadarSensorViewConfiguration.AntennaDiagramEntry",
    RadarSensorViewConfigurationAntennaDiagramEntry,
)


@dataclass(eq=False, repr=False)
class RadarSpecificObjectData(betterproto2.Message):
    """

    \\brief Message encapsulates all data for detected objects that is specific to
    radar sensors.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORSPECIFIC_PROTO_DESCRIPTOR.message_types_by_name[
            "RadarSpecificObjectData"
        ]

    rcs: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    The radar cross section (RCS) of the detected object.

    Unit: dB m^2
    """


default_message_pool.register_message(
    "osi3", "RadarSpecificObjectData", RadarSpecificObjectData
)


@dataclass(eq=False, repr=False)
class ReferenceLine(betterproto2.Message):
    """

    \\brief A reference line for defining a non-Euclidean ST coordinate system

    A reference line is a 3D polyline, used for generating a non-Euclidean
    ST coordinate system.

    \\note This ST coordinate system is specific to OSI and not to be confused with
          similar definitions in other standards like OpenDRIVE or OpenSCENARIO 1.x.
          Nevertheless the goal of this definition is to approximate the source
          coordinates (e.g. OpenDRIVE).

    Notes on design decisions:
    - This is a polyline, and not some more complex curve. The advantage of a
      polyline is that it is very simple to generate from various map formats,
      and it is also easy to handle. The downside is that a polyline has no
      direct curvature, and even the angle is not continuous (only C0 smooth).
      In the author's experience, the benefits of a polyline outweigh the costs.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_REFERENCELINE_PROTO_DESCRIPTOR.message_types_by_name["ReferenceLine"]

    id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the reference line.

    \\note Note ID is global unique.

    \\rules
    is_globally_unique
    is_set
    \\endrules
    """

    type: "ReferenceLineType" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: ReferenceLineType(0)
    )
    """
    The type of the reference line.
    """

    poly_line: "list[ReferenceLineReferenceLinePoint]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Points comprising the polyline.

    At least two points must be given.
    The polyline is defined as the lines between consecutive points.
    Each point has an S coordinate. Other attributes might be set, depending
    on the type of the polyline (see Type).

    ## Rules on the S position

    There are a few requirements on the S position:
    - Later points in the list must have strictly larger S coordinates than
      earlier points.
    - For consecutive points, the S difference between them  must be at
      least as large as the 2D Euclidean distance between the points (2D
      distance == Euclidean distance between the points taking only X and Y
      into account).
    - The S distance between two points may be larger than the 2D Euclidean
      distance, but should be not much larger. It is allowed to be larger if
      the underlying reference line (e.g. in an OpenDRIVE map) is a curve,
      and thus the sampled reference line has a smaller length than the original
      curve.

    Together, these rules allow directly putting OpenDRIVE S coordinates
    into an OSI ReferenceLine.

    If the reference line approximates a curve (e.g. a clothoid in
    OpenDRIVE), the points must be chosen in a way that the lateral distance
    to the ideal line does not exceed 5cm. As shown in the following image:

    \\image html line_approximation_error.svg "Approximation error"
    Approximation error green line.

    Between two ReferenceLinePoints, both the world coordinate and the S
    coordinate is interpolated linearly. So each S value uniquely describes
    a point on the polyline.

    ## Extending the coordinate system infinitely

    For the purpose of this discussion, let's call the S position of the
    first point \\c sStart, and the S position of the last point \\c sEnd.

    For some purposes, S positions outside the normally defined range (i.e.
    outside [\\c sStart,\\c sEnd]) need to be defined. For this purpose, the
    first line of the polyline is infinitely extended in negative S
    direction.  Similarly, the last line of the polyline is infinitely
    extended beyond the last point. The S value of points outside [\\c
    sStart,\\c sEnd] is defined by the Euclidean 2D distance from the start
    or end point, respectively.  So if <code>sStart = 15</code>, and a point
    is on the line extended from the start position, with a 2D Euclidean
    distance of 10 from the first point, then it has an S position of 5.

    A point is "before" the reference line, if its s coordinate is < \\c sStart.
    A point is "after" the reference line, if its s coordinate is > \\c sEnd.

    ## Adding T coordinates

    To describe points that are not directly on the polyline, a T coordinate
    is added. T is the signed 2D distance between the point to describe (P)
    and a projected point (P_proj) on the polyline. There are two ways of
    defining this point, depending on the ReferenceLine::Type (see below).

    The T coordinate of the point in question is then defined as
    <code>hypot(P.X-P_proj.X,P.Y-P_proj.Y)</code>. The projected point P_proj
    might either be on a line segment or at an edge between two line segments.
    The distance is positive if the point is left of the polyline (in
    definition direction), negative if it is right of it. The S position of
    such a point outside the reference line is the same as the S value of the
    projected point on the polyline.

    ## Nearest point (TYPE_POLYLINE)

    The projection point is the nearest point on the polyline (this point might
    either be on a line segment or at an edge between two line segments).

    Notes:
    - The "nearest point on the polyline" is determined in 3D (even if the
      resulting T value is only the 2D distance), in order to choose the
      correct point for 3D curves (think reference lines for roads in parking
      decks).
    - If there are several "nearest points", the one with the smallest S
      coordinate on the polyline is chosen.

    Example:
    \\image html OSI_ReferenceLine1.svg "S, T calculation using nearest point"

    This shows a reference line (consisting of three points), and five points
    not on the reference line.

    - For \\c P1, the situation is clear, since there is exactly one nearest
      point on the polyline. The resulting ST coordinate uniquely maps back
      to \\c P1.
    - \\c P2 has multiple points "nearest points" on the polyline.
      As can be seen here, two  ST coordinates map to \\c P2 (red and gray
      dotted line).  Following the rules above, the one with the smallest S
      value is chosen (the red dotted line).
    - \\c P3 has a unique "nearest point" on the polyline. However, multiple
      points map to the same ST coordinate as that of \\c P3, e.g. \\c P4
      (drawn in gray).
    - Finally, \\c P5 shows how the reference line is extended infinitely for
      points that are "outside" the reference line.

    ## T axis definition (TYPE_POLYLINE_WITH_T_AXIS)

    The T axes of the two ReferenceLinePoints of each ReferenceLine segment
    define a sector (or strip if parallel) of the plane. A point is associated
    with the segment if it lies within this sector. For points being
    associated with multiple segments, the actual segment to consider is
    determined by the shortest 3D Euclidean distance between the point and the
    segments in question.

    The T axis (projecting axis) is the line going through P and the
    intersection point (I). I is defined as the intersection of both
    T axes of two consecutive ReferenceLinePoints (see example and
    image below for illustration).

    Special cases:
    1. If both T axes of the consecutive ReferenceLinePoint are parallel (so
       no intersection point exists), the resulting T axis orientation is equal
       to the T axis of these ReferenceLinePoints.
    2. For the extended lines outside the defined range the projection axis is
       parallel to the T axis of the respective end point.

    ## Rules on the T axis

    For the T axis at a specific ReferenceLinePoint the following rules apply:
    - The T axis shall be close to the angle bisector (to the left in S
      direction) of the neighboring ReferenceLine segments.
    - Small deviations from the angle bisector are allowed (e.g. to represent
      the T axis of OpenDRIVE, which is perpendicular to the OpenDRIVE
      reference line).
    - The T axis must be located inside the sectors spanned by rotating the
      normal of one neighboring ReferenceLine segment into the normal of the
      other ReferenceLine segment on the shortest way.
    - The T axis in the first and the last point of a ReferenceLine has to be
      perpendicular to the first and last segment of the ReferenceLine,
      respectively.

    Example:
    \\image html OSI_ReferenceLine2.svg "S, T calculation using T axis"

    This shows a reference line (consisting of three points \\c R0, \\c R1 and
    \\c R2) and two points (\\c P1 and \\c P2) not part of the reference line.

    Calculation of ST for \\c P1:
    - Calculate the intersection point \\c I of the T axes of \\c R0 and \\c R1.
    - As \\c P1 lies in the sector defined by these T axes it is considered part
      of the reference line section between \\c R0 and \\c R1.
    - The point \\c P1 is projected onto the line segment [\\c R0, \\c R1] via the
      straight line through \\c I (by calculating the intersection of the line
      segment and the projection axis), resulting in point \\c P1_proj.
      If the T axes are parallel, projection is applied in the direction of
      these axes.
    - The S coordinate of \\c P1 is the S coordinate of \\c P1_proj
    - The T coordinate of \\c P1 is the signed Euclidean distance to \\c P1_proj.

    Calculation of \\c P2 follows the same pattern.

    ## Defining angles

    Sometimes an angle to a reference line is needed. This shall be defined
    as follows:
    First the projected point on the polyline is determined, as described
    below. If this point is on a line segment, then the angle is calculated
    relative to the line segment on which the reference point lays.
    If the projected point is at the edge between line segments, then the
    angle of the following line shall be chosen.

    ## Converting between world coordinates and ST coordinates

    The above rules define an ST coordinate system across the whole XY plane.
    Every XY position has an ST coordinate, but not necessarily a unique ST
    coordinate.

    The sampling of the polyline must be chosen such that the error
    when converting coordinates is "small enough". The exact needed
    precision is defined for each user, where the reference line is
    referenced.

    ## Creating reference lines

    When OSI is generated from OpenDRIVE, typically the reference lines will
    be taken directly from the road reference lines in OpenDRIVE, and
    sampled according to the accuracy requirements outlined above.

    Other map formats may not have reference lines, so they will have to be
    synthesized by the tool generating OSI data. A few guidelines on this
    process:

    - The reference line should follow the road
    - It is preferable to have the reference line in the center of the road
      (e.g. on a highway, it should be in the middle between the two driving
      directions). Rationale: this makes S differences better approximate
      Euclidean distances, compared to having the reference line at one side
      of a curvy road.

    ## Various notes

    Notes on OpenDRIVE compatibility:
    Ideally, one would want the polyline to be fully compatible with
    OpenDRIVE, so that calculations done for OpenDRIVE directly match those
    in OSI. There are a few difficulties with this:
    - The T coordinate is nearly the same as for OpenDRIVE, but
      unfortunately not perfectly. In OpenDRIVE, if the road is tilted using
      superelevation, then the t coordinate system is tilted along, so the T
      coordinate is no longer calculated in the XY plane (as proposed for
      OSI). It doesn't seem feasible to implement the same tilting for OSI,
      so simulation tools will have to consider superelevation and convert
      the T coordinate accordingly: <code>t_OSI = t_OpenDRIVE *
      cos(alpha)</code>, where alpha is the superelevation angle.
    - The angle will not be perfectly the same, due to the use of line
      segments in OSI, and curves in OpenDRIVE. In the authors opinion, the
      difference will be negligible if the #poly_line is suitably sampled.

    Notes on design decisions:
    - The S coordinate is included directly, both for OpenDRIVE
      compatibility, and to speed up calculations.
    - The rules on S coordinates (e.g. the calculation in 2D space) are
      there to ensure OpenDRIVE compatibility.
    - The rules on T coordinates are there to ensure OpenDRIVE compatibility
      for lanes without superelevation, and to make it easier to convert
      between OSI and OpenDRIVE in case superelevation is present.
    """


default_message_pool.register_message("osi3", "ReferenceLine", ReferenceLine)


@dataclass(eq=False, repr=False)
class ReferenceLineReferenceLinePoint(betterproto2.Message):
    """

    \\brief A point on the reference line
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_REFERENCELINE_PROTO_DESCRIPTOR.message_types_by_name[
            "ReferenceLine.ReferenceLinePoint"
        ]

    world_position: "Vector3D | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    A world position
    """

    s_position: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    S position on the reference line
    """

    t_axis_yaw: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    Yaw angle of the T axis in the world coordinate system

    When converting from formats like OpenDRIVE, the yaw angle is equal to
    the angle of the normal to the reference line in the sampled point.

    Also see image "S, T coordinates" at #poly_line for reference.

    \\note This field is only set if the type of the reference line is
          TYPE_POLYLINE_WITH_T_AXIS.
    """


default_message_pool.register_message(
    "osi3", "ReferenceLine.ReferenceLinePoint", ReferenceLineReferenceLinePoint
)


@dataclass(eq=False, repr=False)
class RoadMarking(betterproto2.Message):
    """

    \\brief A road surface marking.

    \\image html OSI_RoadMarking.svg

    The figure shows two STOP road markings. STOP \\c
    RoadMarking::Classification::type == \\c
    RoadMarking::Classification::TYPE_TEXTUAL_TRAFFIC_SIGN is marked, STOP \\c
    RoadMarking::Classification::type == \\c
    RoadMarking::Classification::TYPE_SYMBOLIC_TRAFFIC_SIGN is not marked.

    All coordinates and orientations are relative to the global ground truth
    coordinate system.

    Lane markings are excluded and defined as \\c LaneBoundary messages
    as part of \\c Lane.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_ROADMARKING_PROTO_DESCRIPTOR.message_types_by_name["RoadMarking"]

    id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the road marking.

    \\rules
    is_set
    \\endrules
    """

    base: "BaseStationary | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The base parameters of the road marking.

    The orientation of the bounding box \\c #base
    \\c BaseStationary::orientation is defined as follows:
    The z-axis of the \\c BaseStationary::orientation is the vector from the
    'bottom' to the 'top' of the road marking's (i.e. painted traffic sign)
    2D image area.
    (Normally it is in the ground truth xy-plain.)
    The x-axis of the \\c BaseStationary::orientation is the view normal of
    the road marking's 2D image area.
    Normally this x-axis points to the sky.

    \\note If a valid unidirectional road marking is assigned to the host
    vehicle's current lane and the driving direction of the latter roughly
    matches the z-axis of the \\c #base \\c BaseStationary::orientation then
    the road marking is of relevance to (i.e. in effect for) the host
    vehicle.
    """

    classification: "RoadMarkingClassification | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The classification data for the road marking.
    """

    source_reference: "list[ExternalReference]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Optional external reference to the road-marking source.

    The external reference points to the source of the surface marking, if it
    is derived from one or more objects or external references. An example
    here is the reference to the signal defined in a OpenDRIVE map.

    For example, to reference a signal defined in an OpenDRIVE map
    the items should be set as follows:
    * reference = URI to map, can remain empty if identical with definition
                  in \\c GroundTruth::map_reference
    * type = "net.asam.opendrive"
    * identifier[0] = id of t_road_signals_signal

    \\note With OpenDRIVE, surface markings can also be defined as objects.
          In this case, the associated object is usually referenced within
          OpenDRIVE using the reference t_road_signals_signal_reference.
          An additional reference to the object is therefore not necessary.

    \\note For non-ASAM Standards, it is implementation-specific how
          source_reference is resolved.

    \\note The value has to be repeated, because one lane segment may be
          derived from more than one origin segment. Multiple sources
          may be added as reference as well, for example, a map and sensors.
    """

    color_description: "ColorDescription | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The visual color of the material of the road marking.

    \\note This does not represent the semantic classification but the visual
    appearance. For semantic classification of the road marking use the color
    field in \\c Classification.
    """


default_message_pool.register_message("osi3", "RoadMarking", RoadMarking)


@dataclass(eq=False, repr=False)
class RoadMarkingClassification(betterproto2.Message):
    """

    \\brief \\c Classification data for a road surface marking.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_ROADMARKING_PROTO_DESCRIPTOR.message_types_by_name[
            "RoadMarking.Classification"
        ]

    type: "RoadMarkingClassificationType" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: RoadMarkingClassificationType(0),
    )
    """
    The type of the road marking.
    """

    traffic_main_sign_type: "TrafficSignMainSignClassificationType" = (
        betterproto2.field(
            2,
            betterproto2.TYPE_ENUM,
            default_factory=lambda: TrafficSignMainSignClassificationType(0),
        )
    )
    """
    Traffic sign as road marking (color image, monochrome image or
    character string).

    \\note Field is set if ( \\c #type == \\c #TYPE_PAINTED_TRAFFIC_SIGN or
    \\c #TYPE_SYMBOLIC_TRAFFIC_SIGN or \\c #TYPE_TEXTUAL_TRAFFIC_SIGN ).

    \\note Field need not be set (or set to \\c #TYPE_OTHER)
    if road marking type (\\c #type) does not require it.

    \\attention Deprecated: A revision is planned for version 4.0.0 to
    replace the type enum with a more semantically defined enumeration,
    with the exact sign specification being relegated to the newly
    introduced 4-tupel traffic sign catalog specification as used in
    <a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE</a>.

    \\rules
    check_if this.type is_greater_than_or_equal_to 2 else do_check is_set
    check_if this.type is_less_than_or_equal_to 4 else do_check is_set
    \\endrules
    """

    monochrome_color: "RoadMarkingClassificationColor" = betterproto2.field(
        3,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: RoadMarkingClassificationColor(0),
    )
    """
    The semantic monochrome color of the road marking.

    \\note The color types represent the semantic color classification of
    road markings only. They do not represent an actual visual appearance.

    \\note Field need not be set (or set to \\c #COLOR_OTHER)
    if road marking type does not require it (e.g. for \\c #type ==
    \\c #TYPE_PAINTED_TRAFFIC_SIGN).

    \\rules
    check_if this.type is_equal_to 2 else do_check is_set
    check_if this.monochrome_color is_equal_to 1 else do_check is_set
    \\endrules
    """

    value: "TrafficSignValue | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Additional value associated with the road marking, e.g. value of the
    speed limit.

    \\note Field need not be set if road marking type does not require it.

    \\note OSI 3 uses \\c #value_text and not \\c TrafficSignValue for
    simple chars.
    """

    value_text: "str" = betterproto2.field(5, betterproto2.TYPE_STRING)
    """
    Additional text value as road marking, e.g. BUS, TAXI etc.

    \\note Field need not be set if road marking type does not require it.
    """

    assigned_lane_id: "list[Identifier]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The ID(s) of the lane(s) that the road marking is assigned to.
    May be multiple if the road marking goes across multiple lanes.

    \\note OSI uses singular instead of plural for repeated field names.

    \\rules
    refers_to: Lane
    \\endrules
    """

    is_out_of_service: "bool" = betterproto2.field(7, betterproto2.TYPE_BOOL)
    """
    Boolean flag to indicate that the road marking is taken out of service.
    This can be achieved by visibly crossing the road marking with stripes,
    or completely covering a road marking making it not visible.

    \\image html OSI_RoadMaking_is_out_of_service.jpg width=800px
    """

    country: "str" = betterproto2.field(8, betterproto2.TYPE_STRING)
    """
    Country specification of the traffic sign catalog specification
    that identifies the actual traffic sign. This is part of the
    4-tupel traffic sign catalog specification as used in
    <a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE</a>.

    Country is specified using the ISO 3166-1, alpha-2 code
    https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2, or the
    special OpenDRIVE country for generic signs.<br>

    \\rules
    check_if this.type is_greater_than_or_equal_to 2 else do_check is_set
    check_if this.type is_less_than_or_equal_to 4 else do_check is_set
    \\endrules
    """

    country_revision: "str" = betterproto2.field(9, betterproto2.TYPE_STRING)
    """
    Revision specification of the traffic sign catalog specification
    that identifies the actual traffic sign. This is part of the
    4-tupel traffic sign catalog specification as used in
    <a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE</a>.

    The year the traffic rules came into force. <br>
    e.g. "2017"

    \\note Field is set if ( \\c #type == \\c #TYPE_PAINTED_TRAFFIC_SIGN or
    \\c #TYPE_SYMBOLIC_TRAFFIC_SIGN or \\c #TYPE_TEXTUAL_TRAFFIC_SIGN ).

    \\note Field need not be set (or set to \\c #TYPE_OTHER)
    if road marking type (\\c #type) does not require it.

    \\rules
    check_if this.type is_greater_than_or_equal_to 2 else do_check is_set
    check_if this.type is_less_than_or_equal_to 4 else do_check is_set
    \\endrules
    """

    code: "str" = betterproto2.field(10, betterproto2.TYPE_STRING)
    """
    Code specification of the traffic sign catalog specification
    that identifies the actual traffic sign. This is part of the
    4-tupel traffic sign catalog specification as used in
    <a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE</a>.

    Code identifier according to country and country revision,
    corresponds to the type field of OpenDRIVE. <br>
    code is only unique in combination with #country and #country_revision.  <br>
    e.g. http://www.vzkat.de/2017/VzKat.htm

    \\note Field is set if ( \\c #type == \\c #TYPE_PAINTED_TRAFFIC_SIGN or
    \\c #TYPE_SYMBOLIC_TRAFFIC_SIGN or \\c #TYPE_TEXTUAL_TRAFFIC_SIGN ).

    \\note Field need not be set (or set to \\c #TYPE_OTHER)
    if road marking type (\\c #type) does not require it.

    \\rules
    check_if this.type is_greater_than_or_equal_to 2 else do_check is_set
    check_if this.type is_less_than_or_equal_to 4 else do_check is_set
    \\endrules
    """

    sub_code: "str" = betterproto2.field(11, betterproto2.TYPE_STRING)
    """
    Sub-code specification of the traffic sign catalog specification
    that identifies the actual traffic sign. This is part of the
    4-tupel traffic sign catalog specification as used in
    <a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE</a>.

    Sub-code identifier according to country, country revision and code,
    corresponds to the subtype field of OpenDRIVE. <br>
    sub_code is only unique in combination with #country, #country_revision,
    and #code.  <br>
    e.g. http://www.vzkat.de/2017/VzKat.htm

    \\note Field is set if ( \\c #type == \\c #TYPE_PAINTED_TRAFFIC_SIGN or
    \\c #TYPE_SYMBOLIC_TRAFFIC_SIGN or \\c #TYPE_TEXTUAL_TRAFFIC_SIGN ).

    \\note Field need not be set (or set to \\c #TYPE_OTHER)
    if road marking type (\\c #type) does not require it.

    \\rules
    check_if this.type is_greater_than_or_equal_to 2 else do_check is_set
    check_if this.type is_less_than_or_equal_to 4 else do_check is_set
    \\endrules
    """

    logical_lane_assignment: "list[LogicalLaneAssignment]" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Assignment of this object to logical lanes.

    \\note OSI uses singular instead of plural for repeated field names.
    """


default_message_pool.register_message(
    "osi3", "RoadMarking.Classification", RoadMarkingClassification
)


@dataclass(eq=False, repr=False)
class Route(betterproto2.Message):
    """

    \\brief A route in the road network

    A route is an e.g. planned or suggested path for an agent to travel from one
    location to another within the road network. It is composed of a list of route
    segments, which form a continuous path through the road network and should be
    traversed in the order they are listed.
    The route allows the simulation environment to provide agents with high level
    path information, similar to that of a map or a navigation system, without the
    need for the agent model to perform complex path planning on its own. This
    allows for an efficient control of the agent's general direction, while
    simultaneously giving it enough freedom on how to traverse the path.

    ## Example

    The example below shows the \\link Route route\\endlink of a vehicle.

    \\image html OSI_Planned_Route.png "Route" width=850px

    The route is composed of three \\link RouteSegment route segments\\endlink RS1-3,
    each indicated by a yellow outline. Two of the route segments
    (RS2 and RS3) only contain a single \\link LogicalLaneSegment logical lane segment\\endlink
    (highlighted in blue), while RS1 is composed of three
    logical lane segments (green, blue and red).
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_ROUTE_PROTO_DESCRIPTOR.message_types_by_name["Route"]

    route_id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The unique id of the route.

    \\note This field is mandatory.

    \\note This id must be unique within all route messages exchanged with
    one traffic participant.

    \\rules
    is_set
    \\endrules
    """

    route_segment: "list[RouteRouteSegment]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Route segments that form the route of an agent.

    Consecutive segments should be connected without gaps, meaning that the
    two of them should form a continuous area.
    """


default_message_pool.register_message("osi3", "Route", Route)


@dataclass(eq=False, repr=False)
class RouteLogicalLaneSegment(betterproto2.Message):
    """

    \\brief A segment of a logical lane.

    \\note The LogicalLaneSegment allows that start_s > end_s.
    If start_s < end_s, then the traffic agent should traverse the
    segment in the logical lane's reference line definition direction.
    If end_s > start_s, then the traffic agent should traverse the
    segment in the opposite of the logical lane's reference line
    definition direction.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_ROUTE_PROTO_DESCRIPTOR.message_types_by_name[
            "Route.LogicalLaneSegment"
        ]

    logical_lane_id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the logical lane this segment belongs to.

    \\rules
    refers_to: LogicalLane
    \\endrules
    """

    start_s: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    S position on the logical lane where the segment starts.
    """

    end_s: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    S position on the logical lane where the segment ends.
    """


default_message_pool.register_message(
    "osi3", "Route.LogicalLaneSegment", RouteLogicalLaneSegment
)


@dataclass(eq=False, repr=False)
class RouteRouteSegment(betterproto2.Message):
    """

    \\brief A segment of a route.

    A route segment describes a segment of a traffic agent's route through the
    logical lanes of the road network.

    Each time there is a successor-predecessor relation between the logical
    lanes along the route (i.e. a logical lane ends, and is continued by another
    logical lane, e.g. at a junction border), a new RouteSegment starts. The
    RouteSegment then lists the logical lane segments that can be used to
    travel through this space of the road.

    Together, the listed logical lane segments should form a continuous area,
    where the traffic agent can move freely. These will mostly be parallel
    lanes, though lanes may overlap (e.g. if one lane splits into two on a
    junction). In general, the logical lane segments in a RouteSegment will
    have the same length, though there are exceptions (e.g. if a lane
    widening occurs, the newly appearing lane will have a shorter length).

    Typically a route segment will be either
    - a set of parallel lanes between two junctions, or
    - parallel lanes on an intersection with the same driving direction

    ## Example

    Consider the \\link RouteSegment route segment\\endlink between two intersections,
    shown in the image below.

    \\image html OSI_Route_Segment.png "RouteSegment" width=850px

    In the example, a single route segment RS with three
    \\link LogicalLaneSegment logical lane segments\\endlink LL1, LL2 and LL3 is
    shown. The segments are indicated by the green, blue and red highlighted areas,
    one for each underlying logical lane The starting
    s-position of each segment is indicated by the yellow dotted line and the s- prefix
    (note that the start of LL2 lies further to the left, outside of the image),
    while the ending s-position of all segments is shown by the yellow dotted line e-RS.

    As it can be seen in the example, all logical lane segments are parallel,
    but two of them are opening at a later position, so their starting
    s-positions will be different.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_ROUTE_PROTO_DESCRIPTOR.message_types_by_name["Route.RouteSegment"]

    lane_segment: "list[RouteLogicalLaneSegment]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Logical lane segments that form a route segment.

    The logical lane segments of a route segment should be connected without
    gaps, meaning that, together, the lane segments should form a continuous
    area.
    """


default_message_pool.register_message("osi3", "Route.RouteSegment", RouteRouteSegment)


@dataclass(eq=False, repr=False)
class SensorData(betterproto2.Message):
    """

    \\brief The sensor information derived from \\c GroundTruth and processed by
    sensor-models.

    The sensor information is supposed to imitate the output of real sensors.
    All information regarding the environment is given with respect to
    the virtual sensor coordinate system specified in
    \\c SensorData::mounting_position, except for feature data, which is given
    with respect to the physical sensor coordinate system specified in the
    corresponding physical sensor's coordinate system.

    When simulating multiple distinct sensors, each sensor can produce an
    individual copy of the \\c SensorData interface. This allows an independent
    treatment of the sensors.

    Sensor fusion models can consolidate multiple \\c SensorData interfaces into
    one consolidated \\c SensorData interface.  This can happen either in
    separate logical models, consuming and producing \\c SensorData interfaces,
    or it can happen as part of a combined sensor/logical model, that consumes
    \\c SensorView interfaces and directly produces one consolidated \\c SensorData
    output.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORDATA_PROTO_DESCRIPTOR.message_types_by_name["SensorData"]

    version: "InterfaceVersion | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The interface version used by the sender.

    \\rules
    is_set
    \\endrules
    """

    timestamp: "Timestamp | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The timestamp of the sensor data. Zero time is arbitrary but must be
    identical for all messages. Zero time does not need to coincide with
    the unix epoch. Recommended is the starting time point of the
    simulation.

    \\note This is the point in time that the sensor data message becomes
    available to the rest of the system (i.e. the driving functions), so
    it corresponds with the sending time and thus takes the latency of
    internal processing of the sensor into account. Latencies of bus
    communications, etc., that occur after the sensor output have to be
    applied on top of this, if needed.

    The time that the actual measurement was performed (which will usually
    correspond with the timestamp of the \\c GroundTruth the sensor model
    processed to arrive at these results) can be found in the additional
    field \\c SensorData::last_measurement_time.

    For an ideal zero latency sensor the two timestamps would be the same
    and would correspond with the timestamp from the current \\c GroundTruth
    message.

    For a sensor model that does not know its own internal latencies (e.g.
    a dumb sensor with no internal time concept), the two timestamps might
    also be identical, but delayed from the \\c GroundTruth timestamp.

    \\rules
    is_set
    \\endrules
    """

    host_vehicle_location: "BaseMoving | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The sensors estimated location of the host vehicle

    \\note This value is only set by sensors that are able to
    provide an own estimation of the host vehicle location.
    \\note Note that dimension and base_polygon need not be set.
    \\note The parent frame of \\c host_vehicle_location is the sensor frame.
    """

    host_vehicle_location_rmse: "BaseMoving | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The sensors estimated location error of the host vehicle

    \\note This value is only set by sensors that are able to
    provide an own estimation of the host vehicle location.
    \\note Note that dimension and base_polygon need not be set.
    \\note The parent frame of \\c host_vehicle_location_rmse is the sensor
    frame.
    """

    sensor_id: "Identifier | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the sensor at host vehicle's mounting_position.

    This is the ID of the virtual sensor, to be used in its detected
    object output; it is distinct from the IDs of its physical detectors,
    which are used in the detected features.

    \\rules
    is_set
    \\endrules
    """

    mounting_position: "MountingPosition | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The virtual mounting position of the sensor (origin and orientation
    of the sensor coordinate system) given in vehicle coordinates [1].
    The virtual position pertains to the sensor as a whole, regardless
    of the actual position of individual physical detectors, and governs
    the sensor-relative coordinates in detected objects of the sensor
    as a whole.  Individual features detected by individual physical
    detectors are governed by the actual physical mounting positions
    of the detectors, as indicated in the technology-specific sub-views
    and sub-view configurations.

    \\arg \\b x-direction of sensor coordinate system: sensor viewing direction
    \\arg \\b z-direction of sensor coordinate system: sensor (up)
    \\arg \\b y-direction of sensor coordinate system: perpendicular to x and z
    right hand system

    \\par Reference:
    [1] DIN Deutsches Institut fuer Normung e. V. (2013). <em>DIN ISO 8855 Strassenfahrzeuge - Fahrzeugdynamik und Fahrverhalten - Begriffe</em>. (DIN ISO 8855:2013-11). Berlin, Germany.

    \\note This field is usually static during the simulation.
    \\note The origin of vehicle's coordinate system in world frame is
    ( \\c MovingObject::base . \\c BaseMoving::position +
    Inverse_Rotation_yaw_pitch_roll( \\c MovingObject::base . \\c
    BaseMoving::orientation) * \\c
    MovingObject::VehicleAttributes::bbcenter_to_rear) . The orientation of
    the vehicle's coordinate system is equal to the orientation of the
    vehicle's bounding box \\c MovingObject::base . \\c
    BaseMoving::orientation.

    \\rules
    is_set
    \\endrules
    """

    mounting_position_rmse: "MountingPosition | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The root mean squared error of the mounting position.
    """

    sensor_view: "list[SensorView]" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Sensor view w.r.t. the sensor coordinate system

    This provides a copy of the \\c SensorView data received by the sensor
    for reference purposes.  For complex sensors or logic models this
    can be multiple copies.
    """

    last_measurement_time: "Timestamp | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The timestamp of the last real-world measurement (e.g. GT input) that
    this set of sensor data takes into account. This in effect is the last
    time instance of reality the measurements correspond to. See field
    \\c SensorData::timestamp for a detailed discussion. This value is also
    the upper bound to the \\c DetectedEntityHeader::measurement_time and the
    feature data \\c SensorDetectionHeader::measurement_time fields.
    """

    stationary_object_header: "DetectedEntityHeader | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    General information about the \\c DetectedStationaryObject .
    """

    stationary_object: "list[DetectedStationaryObject]" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of stationary objects (e.g. landmarks) detected by the sensor.
    """

    moving_object_header: "DetectedEntityHeader | None" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    General information about the \\c DetectedMovingObject .
    """

    moving_object: "list[DetectedMovingObject]" = betterproto2.field(
        13, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of moving objects detected by the sensor as perceived by
    the sensor.
    """

    traffic_sign_header: "DetectedEntityHeader | None" = betterproto2.field(
        14, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    General information about the \\c DetectedTrafficSign .
    """

    traffic_sign: "list[DetectedTrafficSign]" = betterproto2.field(
        15, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of traffic signs detected by the sensor.
    """

    traffic_light_header: "DetectedEntityHeader | None" = betterproto2.field(
        16, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    General information about the \\c DetectedTrafficLight .
    """

    traffic_light: "list[DetectedTrafficLight]" = betterproto2.field(
        17, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of traffic lights detected by the sensor.
    """

    road_marking_header: "DetectedEntityHeader | None" = betterproto2.field(
        18, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    General information about the \\c DetectedRoadMarking .
    """

    road_marking: "list[DetectedRoadMarking]" = betterproto2.field(
        19, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of road markings detected by the sensor.
    This excludes lane boundary markings.
    """

    lane_boundary_header: "DetectedEntityHeader | None" = betterproto2.field(
        20, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    General information about the \\c DetectedLaneBoundary .
    """

    lane_boundary: "list[DetectedLaneBoundary]" = betterproto2.field(
        21, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of lane boundary markings detected by the sensor.
    """

    lane_header: "DetectedEntityHeader | None" = betterproto2.field(
        22, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    General information about the \\c DetectedLane .
    """

    lane: "list[DetectedLane]" = betterproto2.field(
        23, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of lanes detected by the sensor
    """

    occupant_header: "DetectedEntityHeader | None" = betterproto2.field(
        24, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    General information about the \\c DetectedOccupant .
    """

    occupant: "list[DetectedOccupant]" = betterproto2.field(
        25, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of occupants of the host vehicle
    """

    feature_data: "FeatureData | None" = betterproto2.field(
        26, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Low level feature data interface.

    Low Level feature data is optionally provided by sensor models that
    model sensors giving access to this low level data, i.e. data prior to
    object hypothesis and tracking.
    """

    logical_detection_data: "LogicalDetectionData | None" = betterproto2.field(
        27, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Logical detection data interface.

    Logical detection data are provided by a transformation
    (and optional sensor fusion)
    performed by a sensor model or a logical model
    that fuses multiple sensors and/or sensor types
    into a single reference frame
    of the so called logical/virtual sensor.
    Therefore, all information is given with respect to
    the reference frame of the logical/virtual sensor
    \\c SensorView::mounting_position (e.g. center of rear axle of the ego car)
    in cartesian coordinates.
    """

    virtual_detection_area: "SensorDataVirtualDetectionArea | None" = (
        betterproto2.field(28, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Virtual detection area of the sensor
    """

    system_time: "Timestamp | None" = betterproto2.field(
        29, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The system time of the modeled source of the sensor data, given
    in UTC (Unix Epoch timestamp).

    The system time can be used to transmit the internal time of the
    simulated component that supplies the sensor data, which might
    not coincide with the simulation time as transmitted in the
    timestamp field. Example use cases include recorded data traces
    or the simulation of time synchronization mechanisms and errors.
    """


default_message_pool.register_message("osi3", "SensorData", SensorData)


@dataclass(eq=False, repr=False)
class SensorDataVirtualDetectionArea(betterproto2.Message):
    """

    \\brief Virtual detection area of a sensor

    The virtual detection area describes the nominal area the sensor is capable of covering
    in its current operating mode, without taking occlusion or other statistical effects into account.
    This information can be used for visualization or other development purposes as a rough guide
    to nominal sensor performance.

    It is described by a set of polygons in cartesian coordinates as a pragmatic approximation for
    the rough shapes expected.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "SensorData.VirtualDetectionArea"
        ]

    polygon: "list[Polygon3D]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of polygons. Each polygon represents a surface of the virtual detection area
    and is given with respect to the virtual sensor coordinate system.
    """


default_message_pool.register_message(
    "osi3", "SensorData.VirtualDetectionArea", SensorDataVirtualDetectionArea
)


@dataclass(eq=False, repr=False)
class SensorDataSeries(betterproto2.Message):
    """

    \\brief (Time) Series of \\c SensorData messages that may be used for data
    recording or internal buffering by some sensor models.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_DATARECORDING_PROTO_DESCRIPTOR.message_types_by_name[
            "SensorDataSeries"
        ]

    sensor_data: "list[SensorData]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of sensor data messages for subsequent time steps.
    """


default_message_pool.register_message("osi3", "SensorDataSeries", SensorDataSeries)


@dataclass(eq=False, repr=False)
class SensorDataSeriesList(betterproto2.Message):
    """

    \\brief List of sensors where each element contains a time series of
    \\c SensorData messages.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_DATARECORDING_PROTO_DESCRIPTOR.message_types_by_name[
            "SensorDataSeriesList"
        ]

    sensor: "list[SensorDataSeries]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of sensor data for multiple sensors at subsequent time steps.
    """


default_message_pool.register_message(
    "osi3", "SensorDataSeriesList", SensorDataSeriesList
)


@dataclass(eq=False, repr=False)
class SensorDetectionHeader(betterproto2.Message):
    """

    \\brief The header attributes of each sensor's detection list.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_FEATUREDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "SensorDetectionHeader"
        ]

    measurement_time: "Timestamp | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Time stamp at which the measurement was taken (not the time at which it
    was processed or at which it is transmitted) in the global synchronized
    time.

    \\note See \\c SensorData::timestamp and
    \\c SensorData::last_measurement_time for detailed discussions on the
    semantics of time-related fields.
    """

    cycle_counter: "int" = betterproto2.field(2, betterproto2.TYPE_UINT64)
    """
    Monotonous counter to identify the exact cycle.
    In general the detection function is called periodically and
    \\c #cycle_counter corresponds to the number of periods.

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    mounting_position: "MountingPosition | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The physical mounting position of the sensor (origin and orientation of
    the sensor frame). Both origin and orientation are given in and with
    respect to the host vehicle coordinate system [1].

    The sensor frame's x-axis is pointing in the central viewing direction of
    the sensor. It is the angle bisector of the sensor's horizontal and
    vertical field of view. The terms horizontal and vertical must be
    understood as names for the two principal planes of the sensor's field of
    view (relative to the sensor frame's orientation), which do not have to
    be horizontal or vertical in the strict sense of being parallel or
    perpendicular to the local gravitational vector. The horizontal field
    of view defines the sensor frame's xy-plane and the vertical field
    of view defines the xz-plane. The sensor frame is right-handed and the
    z-axis is pointing in an upward direction.

    The sensor frame uses cartesian coordinates. The sensor frame's origin is
    identical to sensor detection frame's origin. Detections are defined in
    the sensor detection frame which uses e.g. spherical coordinates.

    \\par Reference:
    [1] DIN Deutsches Institut fuer Normung e. V. (2013). <em>DIN ISO 8855 Strassenfahrzeuge - Fahrzeugdynamik und Fahrverhalten - Begriffe</em>. (DIN ISO 8855:2013-11). Berlin, Germany.

    \\rules
    is_set
    \\endrules
    """

    mounting_position_rmse: "MountingPosition | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The origin/orientation of the sensor frame represents the current
    mounting pose to the best knowledge of the sensor. The estimation of the
    6D pose given by the calibration. The uncertainty of this estimation is
    given with the corresponding 6D root mean squared error. The estimation
    of the current origin does not include effects due to short-time
    dynamics, such as pitch angles from braking, but includes long-time
    calibration values, such as pitch angles from luggage in the trunk.
    """

    data_qualifier: "SensorDetectionHeaderDataQualifier" = betterproto2.field(
        5,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: SensorDetectionHeaderDataQualifier(0),
    )
    """
    Data Qualifier expresses to what extent the content of this event can be
    relied on.
    """

    number_of_valid_detections: "int" = betterproto2.field(6, betterproto2.TYPE_UINT32)
    """
    The current number of valid detections in the detections list.

    \\note This value has to be set if the list contains invalid detections.

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    sensor_id: "Identifier | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the sensor at host vehicle's \\c #mounting_position.

    This ID can equal \\c SensorData::sensor_id, if \\c SensorData holds only
    data from one sensor/sensor model.

    \\rules
    is_set
    \\endrules
    """

    extended_qualifier: "SensorDetectionHeaderExtendedQualifier" = betterproto2.field(
        8,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: SensorDetectionHeaderExtendedQualifier(0),
    )
    """
    The extended qualifier describes the reason (not the effect) why the
    event data qualifier, \\c #data_qualifier, is reduced or not available.
    """


default_message_pool.register_message(
    "osi3", "SensorDetectionHeader", SensorDetectionHeader
)


@dataclass(eq=False, repr=False)
class SensorView(betterproto2.Message):
    """

    \\brief The sensor view is derived from \\c GroundTruth and used as
    input to sensor models.

    The sensor view information is supposed to provide input to sensor
    models for simulation of actual real sensors.
    All information regarding the environment is given with respect to
    the virtual sensor coordinate system specified in
    \\c SensorView::mounting_position, except for the individual physical
    technology-specific data, which is given with respect to the physical
    sensor coordinate system specified in the corresponding physical sensor's
    \\c #mounting_position, and the \\c #global_ground_truth, which is given in
    global coordinates.

    When simulating multiple distinct sensors, each sensor can consume an
    individual copy of the \\c SensorView interface. This allows an independent
    treatment of the sensors.

    Alternatively combined sensor models can also consume one combined
    \\c SensorView, with either combined or separate \\c SensorData outputs,
    depending on model architecture.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORVIEW_PROTO_DESCRIPTOR.message_types_by_name["SensorView"]

    version: "InterfaceVersion | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The interface version used by the sender (simulation environment).

    \\rules
    is_set
    \\endrules
    """

    timestamp: "Timestamp | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The data timestamp of the simulation environment. Zero time is arbitrary
    but must be identical for all messages. Zero time does not need to
    coincide with the UNIX epoch. Recommended is the starting time point of
    the simulation.

    \\note For sensor view data this timestamp coincides both with the
    notional simulation time the data applies to and the time it was sent
    (there is no inherent latency for sensor view data, as opposed to
    sensor data).

    \\rules
    is_set
    \\endrules
    """

    sensor_id: "Identifier | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the sensor at host vehicle's \\c #mounting_position.

    This is the ID of the virtual sensor, to be used in its detected
    object output; it is distinct from the IDs of its physical detectors,
    which are used in the detected features.

    \\rules
    is_set
    \\endrules
    """

    mounting_position: "MountingPosition | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The virtual mounting position of the sensor (origin and orientation of
    the sensor frame). Both origin and orientation are given in and with
    respect to the host vehicle coordinate system [1].

    The virtual position pertains to the sensor as a whole, regardless of the
    actual position of individual physical detectors, and governs the
    sensor-relative coordinates in detected objects of the sensor as a whole.
    Individual features detected by individual physical detectors are
    governed by the actual physical mounting positions of the detectors, as
    indicated in the technology-specific sub-views and sub-view
    configurations.

    \\arg \\b x-direction of sensor coordinate system: sensor viewing direction
    \\arg \\b z-direction of sensor coordinate system: sensor (up)
    \\arg \\b y-direction of sensor coordinate system: perpendicular to x and z
    right hand system

    \\par Reference:
    [1] DIN Deutsches Institut fuer Normung e. V. (2013). <em>DIN ISO 8855 Strassenfahrzeuge - Fahrzeugdynamik und Fahrverhalten - Begriffe</em>. (DIN ISO 8855:2013-11). Berlin, Germany.

    \\note This field is usually static during the simulation.
    \\note The origin of vehicle's coordinate system in world frame is
    ( \\c MovingObject::base . \\c BaseMoving::position +
    Inverse_Rotation_yaw_pitch_roll( \\c MovingObject::base . \\c
    BaseMoving::orientation) * \\c
    MovingObject::VehicleAttributes::bbcenter_to_rear) . The orientation of
    the vehicle's coordinate system is equal to the orientation of the
    vehicle's bounding box \\c MovingObject::base . \\c
    BaseMoving::orientation.

    \\rules
    is_set
    \\endrules
    """

    mounting_position_rmse: "MountingPosition | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The root mean squared error of the mounting position.
    """

    host_vehicle_data: "HostVehicleData | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Host vehicle data.

    Host vehicle data is data that the host vehicle knows about itself,
    e.g. from location sensors, internal sensors and ECU bus data, etc.,
    that is made available to sensors as input.
    """

    global_ground_truth: "GroundTruth | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Ground truth w.r.t. global coordinate system.

    This is the ground truth that is provided to the sensor model by the
    simulation environment. It may be filtered as per the requirements of
    the sensor model as expressed by the \\c SensorViewConfiguration
    message(s) that where exchanged during the simulation initialization
    phase.

    \\note The host vehicle is always contained in the ground truth provided,
    regardless of any filtering. The ground truth MUST contain at least as
    much of the ground truth data, as is requested by the sensor model, but
    MAY always contain more data, since the filtering is intended only as
    an optimization mechanism, not as a replacement of a proper sensor
    field of view modeling.
    """

    host_vehicle_id: "Identifier | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the host vehicle in the \\c #global_ground_truth data.

    \\rules
    refers_to: 'MovingObject'
    is_set
    \\endrules
    """

    generic_sensor_view: "list[GenericSensorView]" = betterproto2.field(
        1000, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Generic SensorView(s).
    """

    radar_sensor_view: "list[RadarSensorView]" = betterproto2.field(
        1001, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Radar-specific SensorView(s).
    """

    lidar_sensor_view: "list[LidarSensorView]" = betterproto2.field(
        1002, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Lidar-specific SensorView(s).
    """

    camera_sensor_view: "list[CameraSensorView]" = betterproto2.field(
        1003, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Camera-specific SensorView(s).
    """

    ultrasonic_sensor_view: "list[UltrasonicSensorView]" = betterproto2.field(
        1004, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Ultrasonic-specific SensorView(s).
    """


default_message_pool.register_message("osi3", "SensorView", SensorView)


@dataclass(eq=False, repr=False)
class SensorViewConfiguration(betterproto2.Message):
    """

    \\brief The configuration settings for the \\c SensorView to be provided
    by the environment simulation.

    This message can be provided by the sensor model to the environment
    simulation, in which case it describes the input configuration that
    is desired by the sensor model. In response the environment simulation
    will configure the input and provide a new message of this type, which
    describes the actual configuration that it is going to employ. The two
    can and will differ, when either the environment simulation does not
    support a given requested configuration, and/or when the requested
    configuration allowed for multiple alternatives, in which case the set
    configuration will only contain the alternative chosen.

    It should be noted that this message is not intended to provide for
    parametrization of a generic sensor model, but rather for the automatic
    configuration of an environment simulation in order to supply the
    necessary input to it, depending on its actual configuration.
    Mechanisms to parametrize sensor models are currently packaging-specific,
    i.e. they depend on the packaging mechanism chosen:  For FMU-packaging
    the parametrization can be implemented using normal FMU parameters,
    and the requested \\c SensorViewConfiguration can depend on those parameter
    values by being defined as a calculatedParameter.

    The sensor-technology specific configurations are intended to allow
    sensor models to use useful sensor modeling base capabilities of the
    environment simulation (e.g. ray tracing engines, camera/lens image
    generation), which need configuration by the sensor model to supply
    suitable data. The specified details are not directly related to
    sensor details, but rather provide the necessary base machinery
    setup so that the data provided is suitable to model the sensor to
    a sufficient degree of fidelity internally. For example the number
    of rays parameters for the Lidar configuration does not match one to
    one with the number of laser rays a lidar sensor might cast, but
    rather specifies the number of rays being cast by a ray
    casting/tracing engine, which might be many more than the physical
    rays being cast at any point in time.

    This also implies that for sensors that have dynamically varying
    characteristics (e.g. switching between wide and narrow focus,
    switching update rates, etc.), the basic approach is to specify
    the maximum amount of data needed at all times here, and internally
    select the data that is needed at any point in time.

    In order to optimize the workload and bandwidth needed for sensor
    simulation, OSI packaging mechanisms can specify the ability to
    exchange \\c SensorViewConfiguration messages not only prior to
    simulation startup, but also dynamically during simulation runs,
    thereby allowing dynamic input configuration switching to only
    request data that is needed in the current sensor mode. However
    this is more or less only a resource optimization strategy, and
    since providing fine-grained information like this can reveal
    internal characteristics of the sensor and/or sensor model, will
    not always be the preferred approach for reasons of IP protection.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORVIEWCONFIGURATION_PROTO_DESCRIPTOR.message_types_by_name[
            "SensorViewConfiguration"
        ]

    version: "InterfaceVersion | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The interface version used by the sender (simulation environment).

    \\rules
    is_set
    \\endrules
    """

    sensor_id: "Identifier | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the sensor at host vehicle's mounting_position.

    This is the ID of the virtual sensor, to be used in its detected
    object output; it is distinct from the IDs of its physical detectors,
    which are used in the detected features.

    The ID is to be provided by the environment simulation, the sensor
    model is not in a position to provide a useful default value.

    \\rules
    is_set
    \\endrules
    """

    mounting_position: "MountingPosition | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The virtual mounting position of the sensor (origin and orientation
    of the sensor coordinate system) given in vehicle coordinates [1].
    The virtual position pertains to the sensor as a whole, regardless
    of the actual position of individual physical detectors, and governs
    the sensor-relative coordinates in detected objects of the sensor
    as a whole. Individual features detected by individual physical
    detectors are governed by the actual physical mounting positions
    of the detectors, as indicated in the technology-specific sub-views
    and sub-view configurations.

    \\arg \\b x-direction of sensor coordinate system: sensor viewing direction
    \\arg \\b z-direction of sensor coordinate system: sensor (up)
    \\arg \\b y-direction of sensor coordinate system: perpendicular to x and z
    right hand system

    \\par Reference:
    [1] DIN Deutsches Institut fuer Normung e. V. (2013). <em>DIN ISO 8855 Strassenfahrzeuge - Fahrzeugdynamik und Fahrverhalten - Begriffe</em>. (DIN ISO 8855:2013-11). Berlin, Germany.

    \\note The origin of vehicle's coordinate system in world frame is
    ( \\c MovingObject::base . \\c BaseMoving::position +
    Inverse_Rotation_yaw_pitch_roll( \\c MovingObject::base . \\c
    BaseMoving::orientation) * \\c
    MovingObject::VehicleAttributes::bbcenter_to_rear) . The orientation of
    the vehicle's coordinate system is equal to the orientation of the
    vehicle's bounding box \\c MovingObject::base . \\c
    BaseMoving::orientation. \\note A default position can be provided by the
    sensor model (e.g. to indicate the position the model was validated for),
    but this is optional; the environment simulation must provide a valid
    mounting position (based on the vehicle configuration) when setting the
    view configuration.
    """

    mounting_position_rmse: "MountingPosition | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The root mean squared error of the mounting position.
    """

    field_of_view_horizontal: "float" = betterproto2.field(5, betterproto2.TYPE_DOUBLE)
    """
    Field of View in horizontal orientation of the sensor.

    This determines the limit of the cone of interest of ground truth
    that the simulation environment has to provide.
    Viewing range: [- \\c #field_of_view_horizontal/2,  \\c
    #field_of_view_horizontal/2] azimuth in the sensor frame as defined in \\c
    Spherical3d.

    Unit: rad
    """

    field_of_view_vertical: "float" = betterproto2.field(6, betterproto2.TYPE_DOUBLE)
    """
    Field of View in vertical orientation of the sensor.

    This determines the limit of the cone of interest of ground truth
    that the simulation environment has to provide.
    Viewing range: [- \\c #field_of_view_vertical/2,  \\c
    #field_of_view_vertical/2] elevation in the sensor frame at zero azimuth
    as defined in \\c Spherical3d.

    Unit: rad
    """

    range: "float" = betterproto2.field(7, betterproto2.TYPE_DOUBLE)
    """
    Maximum range of the sensor

    This determines the limit of the cone of interest of ground truth
    that the simulation environment has to provide.

    Unit: m

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    update_cycle_time: "Timestamp | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The update cycle time of the sensor model.

    This specifies the rate at which the sensor model is provided with
    new input data.

    Unit: s
    \\note In the case of FMU packaging this will correspond to the
    communication step size.
    """

    update_cycle_offset: "Timestamp | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Initial update cycle offset of the sensor model.

    This specifies the initial offset (i.e. initial delay) of the
    sensor model update cycle that the simulation should take into
    account. It is defined against a simulation start time of 0:
    i.e. an initial offset of 0.008s would mean, that the initial
    update of sensor input data to the model should occur at 0+0.008s,
    and then update_cycle_time after that, etc. If the simulation
    start time of the simulation is non-zero, then the offset still
    has to be interpreted against a 0 start time, and not simply
    added on top of the start time: e.g. if the simulation starts at
    0.030s, and the update cycle time is 0.020s, then the first
    update to the sensor input should happen at 0.048s, or 0.018s
    after simulation start. This convention is needed to ensure
    stable phase position of the offset in the case of changing
    simulation start times, e.g. for partial re-simulation.

    Unit: s
    """

    simulation_start_time: "Timestamp | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Simulation Start time

    This specifies the simulation start time that the Simulation
    has chosen. This field has no defined meaning if provided by
    the sensor model.

    Unit: s
    """

    omit_static_information: "bool" = betterproto2.field(11, betterproto2.TYPE_BOOL)
    """
    Omit Static Information

    This flag specifies whether \\c GroundTruth information that
    was already provided using a GroundTruthInit parameter (e.g. <a href="https://opensimulationinterface.github.io/osi-antora-generator/asamosi/latest/sensor-model/spec/ground_truth_init_parameters.html">OSMP GroundTruthInit</a>)
    at initialization time shall be omitted from the \\c SensorView
    ground truth information.

    Setting the \\c #omit_static_information field allows a clear split
    between the dynamic simulation data, which is contained in ground truth
    messages with the \\c #omit_static_information flag, and the static
    simulation data, which is contained in the (OSMP) GroundTruthInit.
    """

    generic_sensor_view_configuration: "list[GenericSensorViewConfiguration]" = (
        betterproto2.field(1000, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    Generic Sensor View Configuration(s).
    """

    radar_sensor_view_configuration: "list[RadarSensorViewConfiguration]" = (
        betterproto2.field(1001, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    Radar-specific Sensor View Configuration(s).
    """

    lidar_sensor_view_configuration: "list[LidarSensorViewConfiguration]" = (
        betterproto2.field(1002, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    Lidar-specific Sensor View Configuration(s).
    """

    camera_sensor_view_configuration: "list[CameraSensorViewConfiguration]" = (
        betterproto2.field(1003, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    Camera-specific Sensor View Configuration(s).
    """

    ultrasonic_sensor_view_configuration: "list[UltrasonicSensorViewConfiguration]" = (
        betterproto2.field(1004, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    Ultrasonic-specific Sensor View Configuration(s).
    """


default_message_pool.register_message(
    "osi3", "SensorViewConfiguration", SensorViewConfiguration
)


@dataclass(eq=False, repr=False)
class SpatialSignalStrength(betterproto2.Message):
    """

    \\brief Definition of a spatial signal strength distribution
    for an emitting / transmitting / receiving entity
    with a horizontal and a vertical angle
    and the corresponding signal strength in dBm (decibels per milliwatt).
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name[
            "SpatialSignalStrength"
        ]

    horizontal_angle: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Horizontal angle (azimuth) of emission / transmission / reception
    in the entity's coordinate system.

    Unit: rad
    """

    vertical_angle: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Vertical angle (elevation) of emission / transmission / reception
    in the entity's coordinate system.

    Unit: rad
    """

    signal_strength: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    Emitted / transmitted /received signal strength
    of the emitting / transmitting / receiving entity
    at the previously defined horizontal and
    vertical angle for one specific wavelength.
    The value for the signal strength
    is given in dBm (decibels per milliwatt).

    Unit: dBm
    """


default_message_pool.register_message(
    "osi3", "SpatialSignalStrength", SpatialSignalStrength
)


@dataclass(eq=False, repr=False)
class Spherical3D(betterproto2.Message):
    """

    \\brief A spherical representation for a point or vector in 3D space.

    Used e.g., for low level representations of radar detections.

    Azimuth and elevation are defined as the rotations that would have to be
    applied to the local frame (e.g sensor frame definition in
    \\c SensorDetectionHeader) to make its x-axis point towards the referenced
    point or to align it with the referenced vector. The rotations are to be
    performed \\b azimuth \\b first (around the z-axis) and \\b elevation \\b second
    (around the new y-axis) to follow the definition of \\c Orientation3d. For the
    sense of each rotation, the right-hand rule applies.

    \\f$ vector_{cartesian} :=
    Rotation( \\f$ \\c #elevation \\f$ )*Rotation( \\f$ \\c #azimuth \\f$ )*
    (Unit_{vector_x}* \\f$ \\c #distance \\f$ ) \\f$
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["Spherical3d"]

    distance: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    The radial distance.

    Unit: m

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    azimuth: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    The azimuth (horizontal) angle.

    Unit: rad
    """

    elevation: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    The elevation (vertical) angle.

    Unit: rad
    """


default_message_pool.register_message("osi3", "Spherical3d", Spherical3D)


@dataclass(eq=False, repr=False)
class StatePoint(betterproto2.Message):
    """

    \\brief The StatePoint definition

    A reference to a time and pose.  Typically used in a repeated field to define
    a trajectory.

    \\note The StatePoint definition does not define mandatory fields.
    The context defines how and what fields are used.  For example, in some cases
    only the pose variables are relevant and the timestamp is ignored.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["StatePoint"]

    timestamp: "Timestamp | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The timestamp of a StatePoint.

    \\note Zero time does not need to coincide with the UNIX epoch.
    """

    position: "Vector3D | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Position in the global coordinate system.

    \\note Remark: The definition of the reference point follows the
    specification of the \\c BaseMoving message, if not specified otherwise
    in the message the StatePoint is used in.
    """

    orientation: "Orientation3D | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Orientation in the global coordinate system.
    """


default_message_pool.register_message("osi3", "StatePoint", StatePoint)


@dataclass(eq=False, repr=False)
class StationaryObject(betterproto2.Message):
    """

    \\brief A simulated object that is neither a moving object (vehicle or
    \\c MovingObject e.g. pedestrian, animal, or vehicle) nor a traffic related
    object (\\c TrafficLight, \\c TrafficSign).

    \\image html OSI_BaseStationary.svg

    \\c StationaryObject excludes traffic lights, traffic signs and road marking
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_OBJECT_PROTO_DESCRIPTOR.message_types_by_name["StationaryObject"]

    id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the object.

    \\rules
    is_globally_unique
    is_set
    \\endrules
    """

    base: "BaseStationary | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The base parameters of the stationary object.
    """

    classification: "StationaryObjectClassification | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The classification of the stationary object.
    """

    model_reference: "str" = betterproto2.field(4, betterproto2.TYPE_STRING)
    """
    Opaque reference of an associated 3D model of the stationary object.

    \\note It is implementation-specific how model_references are resolved to
    3d models.
    """

    source_reference: "list[ExternalReference]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    External reference to the stationary-object source.

    The external reference points to the source of a stationary object, if it
    is derived from an external sources like OpenDRIVE or OpenSCENARIO.

    For example, to reference an object defined in an OpenDRIVE map
    the items should be set as follows:
    * reference = URI to map, can remain empty if identical with definition
                  in \\c GroundTruth::map_reference
    * type = "net.asam.opendrive"
    * identifier[0] = "object" for t_road_objects_object and
                      "bridge" for t_road_objects_bridge
    * identifier[1] = id of t_road_objects_object or t_road_objects_bridge

    For example, to reference OpenSCENARIO entities of the type MiscObject,
    which describe partly stationary objects, the items should be set as
    follows:
    * reference = URI to the OpenSCENARIO File
    * type = "net.asam.openscenario"
    * identifier[0] = Entity-Type ("MiscObject")
    * identifier[1] = name of MiscObject in Entity

    \\note The following rule, described in OpenDRIVE, also applies:
    * Objects derived from OpenSCENARIO shall not be mixed with objects
      described in OpenDRIVE.

    \\note For non-ASAM Standards, it is implementation-specific how
          source_reference is resolved.

    \\note The value has to be repeated because one object may be derived
          from more than one origin source, for example, from a scenario file
          and from sensors.
    """

    color_description: "ColorDescription | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The dominating color of the material of the structure.
    """


default_message_pool.register_message("osi3", "StationaryObject", StationaryObject)


@dataclass(eq=False, repr=False)
class StationaryObjectClassification(betterproto2.Message):
    """

    \\brief Classification data for a stationary object.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_OBJECT_PROTO_DESCRIPTOR.message_types_by_name[
            "StationaryObject.Classification"
        ]

    type: "StationaryObjectClassificationType" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: StationaryObjectClassificationType(0),
    )
    """
    The type of the object.
    """

    material: "StationaryObjectClassificationMaterial" = betterproto2.field(
        2,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: StationaryObjectClassificationMaterial(0),
    )
    """
    The dominating material of the structure.
    """

    density: "StationaryObjectClassificationDensity" = betterproto2.field(
        3,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: StationaryObjectClassificationDensity(0),
    )
    """
    The dominating density of the material of the structure.
    """

    color: "StationaryObjectClassificationColor" = betterproto2.field(
        4,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: StationaryObjectClassificationColor(0),
    )
    """
    The dominating color of the material of the structure.

    \\attention DEPRECATED: This color enum will be removed in version
    4.0.0. Use the field \\c #color_description (\\c ColorDescription) of
    \\c StationaryObject instead.
    """

    emitting_structure_attribute: "StationaryObjectClassificationEmittingStructureAttribute | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The attributes of the emitting structure if stationary object is classified as such.
    """

    assigned_lane_id: "list[Identifier]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The IDs of the lanes that the object is assigned to.

    \\note Might be multiple IDs if the object stretches over multiple lanes.

    \\note OSI uses singular instead of plural for repeated field names.
    """

    assigned_lane_percentage: "list[float]" = betterproto2.field(
        7, betterproto2.TYPE_DOUBLE, repeated=True
    )
    """
    Percentage values of the object width in the corresponding lane.

    \\note Might be multiple percentages if the object stretches over multiple lanes.

    \\note OSI uses singular instead of plural for repeated field names.
    """

    logical_lane_assignment: "list[LogicalLaneAssignment]" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Assignment of this object to logical lanes.

    \\note OSI uses singular instead of plural for repeated field names.
    """


default_message_pool.register_message(
    "osi3", "StationaryObject.Classification", StationaryObjectClassification
)


@dataclass(eq=False, repr=False)
class StationaryObjectClassificationEmittingStructureAttribute(betterproto2.Message):
    """

    \\brief Attributes of type emitting structure. The horizontal_angle and the vertical_angle in
    emitted_spatial_intensity are symmetrical across the normal, which is defined by the mounting position
    of the emitting structure.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_OBJECT_PROTO_DESCRIPTOR.message_types_by_name[
            "StationaryObject.Classification.EmittingStructureAttribute"
        ]

    wavelength_data: "list[WavelengthData]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    This message determines the range of the emitted wavelength and its
    desired number of samples.
    """

    emitted_spatial_signal_strength: "list[SpatialSignalStrength]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Spatial signal strength distribution of the emitted electromagnetic wave.
    For every sample in wavelength_data an emitted_spatial_signal_strength has to be defined.

    \\note emitted_spatial_signal_strength.size() = WavelengthData.samples_number.size()
    """


default_message_pool.register_message(
    "osi3",
    "StationaryObject.Classification.EmittingStructureAttribute",
    StationaryObjectClassificationEmittingStructureAttribute,
)


@dataclass(eq=False, repr=False)
class StreamingUpdate(betterproto2.Message):
    """

    \\brief The streaming update interface enables simulation entities to send
    partial updates to other modules that favor performance (especially latency)
    over data completeness/consistency (e.g. visualization applications).

    Static and/or non-relevant objects can be omitted as required for the
    specific use case. Adding an object's unique id to the repeated field \\c
    obsolete_id indicates that it will no longer be updated from then on.

    \\note The receiver of partial streaming update messages can only rely on the
    most up-to-date information at the corresponding timestamp. E.g. omitting
    objects does not indicate static behavior but it may be sufficient for the
    use case to update certain objects at a later point in time.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_STREAMINGUPDATE_PROTO_DESCRIPTOR.message_types_by_name[
            "StreamingUpdate"
        ]

    version: "InterfaceVersion | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The interface version used by the sender.

    \\rules
    is_set
    \\endrules
    """

    timestamp: "Timestamp | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The data timestamp where the information of contained objects is calculated. 

    Zero time is arbitrary but must be identical for all messages. 
    Zero time does not need to coincide with the UNIX epoch. 
    Recommended is the starting time point of the simulation.

    \\rules
    is_set
    \\endrules
    """

    stationary_object_update: "list[StationaryObject]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of stationary objects (excluding traffic signs and traffic
    lights).
    """

    moving_object_update: "list[MovingObject]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of moving objects. 
    """

    traffic_sign_update: "list[TrafficSign]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of traffic signs.
    """

    traffic_light_update: "list[TrafficLight]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of traffic lights.
    """

    environmental_conditions_update: "EnvironmentalConditions | None" = (
        betterproto2.field(7, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Conditions of the environment.
    """

    host_vehicle_data_update: "list[HostVehicleData]" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Host vehicle data.

    Host vehicle data is data that the host vehicle knows about itself,
    e.g. from location sensors, internal sensors and ECU bus data, etc.,
    that is made available to sensors as input.

    The ID inside this message allows an association to moving object data.
    """

    obsolete_id: "list[Identifier]" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Entities that will no longer be updated, because they are considered
    obsolete by the sender.

    \\note IDs are globally unique.
    """


default_message_pool.register_message("osi3", "StreamingUpdate", StreamingUpdate)


@dataclass(eq=False, repr=False)
class Timestamp(betterproto2.Message):
    """

    \\brief A timestamp.

    Names and types of fields are chosen in accordance to
    google/protobuf/timestamp.proto to allow a possible switch in the future.
    There is no definition of the zero point in time neither it is the Unix
    epoch. A simulation may start at the zero point in time but it is not
    mandatory.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["Timestamp"]

    seconds: "int" = betterproto2.field(1, betterproto2.TYPE_INT64)
    """
    The number of seconds since the start of e.g. the simulation / system /
    vehicle.

    Unit: s

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    nanos: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)
    """
    The number of nanoseconds since the start of the last second.

    Range: [0, 999.999.999]

    Unit: ns

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 999999999
    \\endrules
    """


default_message_pool.register_message("osi3", "Timestamp", Timestamp)


@dataclass(eq=False, repr=False)
class TrafficAction(betterproto2.Message):
    """

    \\brief Atomic traffic actions to be performed.

    The transmitted commands are the atomic traffic actions described by
    this message.

    \\note This message is notionally a multiple choice selection, that is, only
    certain combinations of atomic traffic actions shall be transmitted within
    certain time intervals, for example, for plausibility reasons. The restrictions
    regarding that are not part of this message, yet are seen as a task of the
    scenario description, for example, OpenSCENARIO.

    \\note All traffic actions are sent only once just before they are about
    to start. This is also true, if their execution is expected to
    take simulation time. To inform the traffic participant
    model that certain actions must or shall be terminated, there are
    explicit actions nested inside this message (AbortActionsAction,
    EndActionsAction), which hold a reference to the respective actions.
    Furthermore, there exists a \\c TrafficCommandUpdate message for the
    traffic participant to report back on potentially dismissed actions.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICCOMMAND_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficAction"
        ]

    follow_trajectory_action: "TrafficActionFollowTrajectoryAction | None" = (
        betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    A FollowTrajectoryAction.
    """

    follow_path_action: "TrafficActionFollowPathAction | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    A FollowPathAction.
    """

    acquire_global_position_action: "TrafficActionAcquireGlobalPositionAction | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    An AcquireGlobalPositionAction.
    """

    lane_change_action: "TrafficActionLaneChangeAction | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    A LaneChangeAction.
    """

    speed_action: "TrafficActionSpeedAction | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    A SpeedAction.
    """

    abort_actions_action: "TrafficActionAbortActionsAction | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    An AbortActionsAction.
    """

    end_actions_action: "TrafficActionEndActionsAction | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    An EndActionsAction.
    """

    custom_action: "TrafficActionCustomAction | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    A CustomAction.
    """

    longitudinal_distance_action: "TrafficActionLongitudinalDistanceAction | None" = (
        betterproto2.field(9, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    A LongitudinalDistanceAction.
    """

    lane_offset_action: "TrafficActionLaneOffsetAction | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    A LaneOffsetAction.
    """

    lateral_distance_action: "TrafficActionLateralDistanceAction | None" = (
        betterproto2.field(11, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    A LateralDistanceAction.
    """

    teleport_action: "TrafficActionTeleportAction | None" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    A TeleportAction.
    """


default_message_pool.register_message("osi3", "TrafficAction", TrafficAction)


@dataclass(eq=False, repr=False)
class TrafficActionAbortActionsAction(betterproto2.Message):
    """
    \\brief AbortActionsAction.

    This action tells a traffic participant that it should immediately
    abort the execution of other actions referenced within this action.
    In contrast to the EndActionsAction this action forces a hard
    termination of the referenced actions.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICCOMMAND_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficAction.AbortActionsAction"
        ]

    action_header: "TrafficActionActionHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The action header
    """

    target_action_id: "list[Identifier]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Actions which must be aborted immediately.

    These fields hold the action ids of the actions that must be 
    aborted immediately. 
    """


default_message_pool.register_message(
    "osi3", "TrafficAction.AbortActionsAction", TrafficActionAbortActionsAction
)


@dataclass(eq=False, repr=False)
class TrafficActionAcquireGlobalPositionAction(betterproto2.Message):
    """

    \\brief Acquire global position action.

    This action assigns a route to a traffic participant. The route
    assigned will be the shortest route (along roads or satisfying any
    other constraints a traffic participant is operating under) between
    the traffic participant's current position and the position specified.

    As with all routing actions, the exact way this route is achieved is
    under the control of the traffic participant model.

    \\note This action is aligned with the AcquirePositionAction of
    OpenSCENARIO 1.0 using a WorldPosition position argument.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICCOMMAND_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficAction.AcquireGlobalPositionAction"
        ]

    action_header: "TrafficActionActionHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The action header.
    """

    position: "Vector3D | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Position in the global coordinate system.

    The position refers to the center (x,y,z) of the bounding box.

    \\note Remark: The definition of the reference point follows the
    specification of the \\c BaseMoving message.
    """

    orientation: "Orientation3D | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Orientation in the global coordinate system.

    This is optional. If no orientation is given, the end orientation
    is under control of the traffic participant.
    """


default_message_pool.register_message(
    "osi3",
    "TrafficAction.AcquireGlobalPositionAction",
    TrafficActionAcquireGlobalPositionAction,
)


@dataclass(eq=False, repr=False)
class TrafficActionActionHeader(betterproto2.Message):
    """

    \\brief The action header
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICCOMMAND_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficAction.ActionHeader"
        ]

    action_id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The unique id of the action.

    \\note This field is mandatory.

    \\note This id must be unique within all traffic command
    messages exchanged with one traffic participant.

    \\rules
    is_set
    \\endrules
    """


default_message_pool.register_message(
    "osi3", "TrafficAction.ActionHeader", TrafficActionActionHeader
)


@dataclass(eq=False, repr=False)
class TrafficActionCustomAction(betterproto2.Message):
    """

    \\brief Custom Action.

    This action assigns a custom command to a traffic participant.
    The syntax and semantics of this action is implementation defined.
    It is entirely up to each individual traffic participant which
    custom commands it supports, if any, and how they must be phrased.

    \\note This action is aligned with CustomCommandAction of OpenSCENARIO 1.0
    providing a customizable user defined action.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICCOMMAND_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficAction.CustomAction"
        ]

    action_header: "TrafficActionActionHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The Action Header.
    """

    command: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)
    """
    The custom command given to the traffic participant. Used to convey a specific instruction
    (for example, "exit_highway"), or event (for example, "left_indicator_activated").

    \\note This corresponds to the content of the OpenSCENARIO 1.0 CustomCommandAction field.
    """

    command_type: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)
    """
    The type of the custom command given to the traffic participant. Can be used to simplify
    how commands are grouped. For example, the command_type could be "sensor_failure" and the
    command value could be "front_right_camera".  This avoids long commands, like
    "sensor_failure: front_right_camera".

    \\note This corresponds to the "type" attribute of the OpenSCENARIO 1.0 CustomCommandAction.
    """


default_message_pool.register_message(
    "osi3", "TrafficAction.CustomAction", TrafficActionCustomAction
)


@dataclass(eq=False, repr=False)
class TrafficActionDynamicConstraints(betterproto2.Message):
    """
    \\brief DynamicConstraints

    This message is used in Longitudinal and Lateral Distance Actions as
    constraints on the TrafficParticipant not allowing them to exceed/drop below
    certain speeds/acceleration levels.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICCOMMAND_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficAction.DynamicConstraints"
        ]

    max_acceleration: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Maximum acceleration the distance controller is allowed to use for keeping distance. 

    Unit: m/s^2
    """

    max_deceleration: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Maximum deceleration the distance controller is allowed to use for keeping distance. 

    Unit: m/s^2
    """

    max_speed: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    Maximum speed the distance controller is allowed to use for keeping distance. 

    Unit: m/s
    """


default_message_pool.register_message(
    "osi3", "TrafficAction.DynamicConstraints", TrafficActionDynamicConstraints
)


@dataclass(eq=False, repr=False)
class TrafficActionEndActionsAction(betterproto2.Message):
    """
    \\brief End actions action.

    This action tells a traffic participant that the execution of the
    referenced actions is regarded as successfully performed. The
    termination of the referenced actions is allowed to be performed
    gracefully.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICCOMMAND_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficAction.EndActionsAction"
        ]

    action_header: "TrafficActionActionHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The action header
    """

    target_action_id: "list[Identifier]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Actions which are regarded as successfully executed.

    These fields hold the action ids of the actions that are regarded 
    as successfully executed and shall be terminated gracefully.
    """


default_message_pool.register_message(
    "osi3", "TrafficAction.EndActionsAction", TrafficActionEndActionsAction
)


@dataclass(eq=False, repr=False)
class TrafficActionFollowPathAction(betterproto2.Message):
    """

    \\brief Follow path action.

    Controls a traffic participant to follow a path using vertices. It
    specifies the motion in space independent of time.

    \\note The StatePoint messages in path_point only requires a specified
    position field. The orientation can be set optionally. Any
    timestamp StatePoint values are ignored.

    \\note This action is aligned with the FollowTrajectoryAction of
    OpenSCENARIO 1.0 using a 3/6D trajectory with shape Polyline.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICCOMMAND_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficAction.FollowPathAction"
        ]

    action_header: "TrafficActionActionHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The action header
    """

    path_point: "list[StatePoint]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of path StatePoints

    Set the position fields for all path points.
    The timestamp field are not required and ignored.
    The orientation fields can be set depending on the constrain_orientation
    field being true.

    \\note OSI uses singular instead of plural for repeated field names.
    """

    constrain_orientation: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)
    """
    Constrain the orientation of the traffic participant as specified
    by the path points.

    This boolean flag defines whether orientation values supplied in 
    the path points shall be used to constrain the orientation
    of the traffic participant or not.
    """

    following_mode: "TrafficActionFollowingMode" = betterproto2.field(
        4, betterproto2.TYPE_ENUM, default_factory=lambda: TrafficActionFollowingMode(0)
    )
    """
    Specify the following mode that should be employed in executing
    the path.
    """


default_message_pool.register_message(
    "osi3", "TrafficAction.FollowPathAction", TrafficActionFollowPathAction
)


@dataclass(eq=False, repr=False)
class TrafficActionFollowTrajectoryAction(betterproto2.Message):
    """

    \\brief Follow trajectory action.

    Controls a traffic participant to follow a trajectory using vertices
    with timings. It specifies the motion in space as a function of time.

    \\note The StatePoint messages in trajectory_point requires a
    specified timestamp.

    \\note This action is aligned with the FollowTrajectoryAction of
    OpenSCENARIO 1.0 using a 4/7D trajectory with shape Polyline.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICCOMMAND_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficAction.FollowTrajectoryAction"
        ]

    action_header: "TrafficActionActionHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The action header.
    """

    trajectory_point: "list[StatePoint]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of trajectory StatePoints.

    Set the timestamp fields and position fields for all 
    trajectory points. The orientation fields can be set
    depending on the constrain_orientation field being true.

    \\note OSI uses singular instead of plural for repeated field names.
    """

    constrain_orientation: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)
    """
    Constrain the orientation of the traffic participant as specified
    by the trajectory points.

    This boolean flag defines whether orientation values supplied in 
    the trajectory points (if any) shall be used to constrain the
    orientation of the traffic participant or not.
    """

    following_mode: "TrafficActionFollowingMode" = betterproto2.field(
        4, betterproto2.TYPE_ENUM, default_factory=lambda: TrafficActionFollowingMode(0)
    )
    """
    Specify the following mode that should be employed in executing
    the trajectory.
    """


default_message_pool.register_message(
    "osi3", "TrafficAction.FollowTrajectoryAction", TrafficActionFollowTrajectoryAction
)


@dataclass(eq=False, repr=False)
class TrafficActionLaneChangeAction(betterproto2.Message):
    """

    \\brief Lane change action.

    This action assigns a lane change to a traffic participant. The fields
    of this message enable different levels of constraint for the traffic
    participant depending on the use case. In case the constraints are
    supposed to be small, the dynamics shape or even the duration and
    the distance for the lane change can be omitted.

    \\note This action is aligned with LaneChangeAction of OpenSCENARIO 1.0
    defining the targeted lane and optionally the parametrization of the
    lane change.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICCOMMAND_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficAction.LaneChangeAction"
        ]

    action_header: "TrafficActionActionHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The action header.
    """

    relative_target_lane: "int" = betterproto2.field(2, betterproto2.TYPE_INT32)
    """
    Targeted lane relative to the current lane.

    Convention: +1 means to the right, -1 means to the left.
    """

    dynamics_shape: "TrafficActionDynamicsShape" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TrafficActionDynamicsShape(0)
    )
    """
    Specified shape of the lane change action. 
    If the shape is unspecified (enum value 0), the shape of the 
    lane change is open to the traffic participant model. 
    """

    duration: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)
    """
    Duration of the lane change.

    A value of 0.0 (the default value) imposes no constraint
    on the duration, unless the dynamics shape is a step function,
    where an immediate step is effected.

    Unit: s
    """

    distance: "float" = betterproto2.field(5, betterproto2.TYPE_DOUBLE)
    """
    Distance of the lane change.

    A value of 0.0 (the default value) imposes no constraint
    on the distance, unless the dynamics shape is a step function,
    where an immediate step is effected.

    Unit: m
    """


default_message_pool.register_message(
    "osi3", "TrafficAction.LaneChangeAction", TrafficActionLaneChangeAction
)


@dataclass(eq=False, repr=False)
class TrafficActionLaneOffsetAction(betterproto2.Message):
    """
    \\brief Lane Offset Action

    This action assigns a targeted lane offset to a traffic participant.
    The action can be constrained by specifying the dynamics shape of the
    lateral transition profile.

    \\note This action is aligned with LaneOffsetAction of OpenSCENARIO 1.0.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICCOMMAND_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficAction.LaneOffsetAction"
        ]

    action_header: "TrafficActionActionHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The Action Header
    """

    target_lane_offset: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Targeted lane offset in meters relative to the centerline of the
    current traffic participant's lane. Positive values mean left of the centerline, 
    negative values mean right of the centerline. 

    Unit: m
    """

    dynamics_shape: "TrafficActionDynamicsShape" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TrafficActionDynamicsShape(0)
    )
    """
    Specified transition shape of reaching the lane offset. 
    If the shape is unspecified (enum value 0), the shape of the 
    transition is open to the traffic participant model. 
    """


default_message_pool.register_message(
    "osi3", "TrafficAction.LaneOffsetAction", TrafficActionLaneOffsetAction
)


@dataclass(eq=False, repr=False)
class TrafficActionLateralDistanceAction(betterproto2.Message):
    """
    \\brief Lateral Distance Action

    The action tells the (host) traffic participant to reach a certain lateral distance relative to
    a target traffic participant. The lateral distance is defined along an imaginative perpendicular line
    with respect to the centerline of the current (host) traffic participant's lane.
    The interpolation strategy between centerline points for calculating that distance along the imaginative
    perpendicular line is open to the traffic participant modeler.

    \\note This action is aligned with LateralDistanceAction of OpenSCENARIO 1.0
    defining the reference traffic participant and the distance.

    \\note Limitation: This concept currently only works for lanes with a centerline, i.e. for lanes
    of TYPE_DRIVING, not for lanes of TYPE_NONDRIVING or TYPE_INTERSECTION.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICCOMMAND_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficAction.LateralDistanceAction"
        ]

    action_header: "TrafficActionActionHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Action Header of the message
    """

    target_traffic_participant_id: "Identifier | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Id of the reference entity the lateral distance shall be kept to.
    """

    distance: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    Lateral distance value. 

    Unit: m
    """

    freespace: "bool" = betterproto2.field(4, betterproto2.TYPE_BOOL)
    """
    Determine the measurement of lateral distance between the traffic
    participant receiving this action and the reference traffic
    participant. 
    True: Lateral distance is measured using the distance between closest bounding box points.
    False: Lateral distance is measured using the distance between the center of each object's bounding box.
    """

    follow: "bool" = betterproto2.field(5, betterproto2.TYPE_BOOL)
    """
    Define whether the traffic participant should only reach the distance once 
    or if it should also keep the distance after having reached it.
    True: the traffic participant shall approach the reference participant
    and follow with the distance specified until the action is aborted (communicate with AbortActionsAction).
    False: the action ends as soon as the traffic participant has reached
    the specified distance (communicate with EndActionsAction).
    """

    dynamic_constraints: "TrafficActionDynamicConstraints | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Parameter that assigns either unlimited dynamics (if omitted) 
    or limited maxAcceleration/maxDeceleration/maxSpeed to the action.
    """


default_message_pool.register_message(
    "osi3", "TrafficAction.LateralDistanceAction", TrafficActionLateralDistanceAction
)


@dataclass(eq=False, repr=False)
class TrafficActionLongitudinalDistanceAction(betterproto2.Message):
    """
    \\brief Longitudinal Distance Action

    The action tells the (host) traffic participant to reach a certain longitudinal distance
    relative to a target traffic participant. The longitudinal distance is defined as the distance
    along the centerline of the lane, on which the (host) traffic participant is currently located.
    The interpolation strategy between centerline points for calculating
    that distance along the centerline is open to the traffic participant modeler.

    \\note This action is aligned with LongitudinalDistanceAction of OpenSCENARIO 1.0
    defining the reference traffic participant and the distance.

    \\note Limitation: This concept currently only works for lanes with a centerline, i.e. for lanes
    of TYPE_DRIVING, not for lanes of TYPE_NONDRIVING or TYPE_INTERSECTION.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICCOMMAND_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficAction.LongitudinalDistanceAction"
        ]

    action_header: "TrafficActionActionHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Action Header of the message
    """

    target_traffic_participant_id: "Identifier | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Unique Id of the reference traffic participant to which the distance is defined.
    """

    distance: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    The distance to reach along the lane

    Unit: m
    """

    freespace: "bool" = betterproto2.field(4, betterproto2.TYPE_BOOL)
    """
    Determine the measurement of longitudinal distance between the traffic
    participant receiving this action and the reference traffic
    participant. 
    True: Longitudinal distance is measured using the distance between closest bounding box points.
    False: Longitudinal distance is measured using the distance between the center of each object's bounding box.
    """

    follow: "bool" = betterproto2.field(5, betterproto2.TYPE_BOOL)
    """
    Define whether the traffic participant should only reach the distance once 
    or if it should also keep the distance after having reached it.
    True: the traffic participant shall approach the reference participant
    and follow with the distance specified until the action is aborted (communicate with AbortActionsAction).
    False: the action ends as soon as the traffic participant has reached
    the specified distance (communicate with EndActionsAction).
    """

    dynamic_constraints: "TrafficActionDynamicConstraints | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Parameter that assigns either unlimited dynamics (if omitted) 
    or limited maxAcceleration/maxDeceleration/maxSpeed to the action.
    """


default_message_pool.register_message(
    "osi3",
    "TrafficAction.LongitudinalDistanceAction",
    TrafficActionLongitudinalDistanceAction,
)


@dataclass(eq=False, repr=False)
class TrafficActionSpeedAction(betterproto2.Message):
    """

    \\brief Speed action.

    This action assigns a targeted speed to a traffic participant.
    The action can be constrained by specifying the dynamics
    shape or even the duration and the distance of the acceleration /
    deceleration process.

    \\note This action is aligned with SpeedAction of OpenSCENARIO 1.0
    defining the targeted speed and optionally the parametrization of the
    speed transition.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICCOMMAND_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficAction.SpeedAction"
        ]

    action_header: "TrafficActionActionHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The action header
    """

    absolute_target_speed: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Targeted absolute speed.
    """

    dynamics_shape: "TrafficActionDynamicsShape" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: TrafficActionDynamicsShape(0)
    )
    """
    Specified transition shape of the speed change action. 
    If the shape is unspecified (enum value 0), the shape of the 
    speed change is open to the traffic participant model. 
    """

    duration: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)
    """
    Duration of the speed change.

    A value of 0.0 (the default value) imposes no constraint
    on the duration, unless the dynamics shape is a step function,
    where an immediate step is effected.

    Unit: s
    """

    distance: "float" = betterproto2.field(5, betterproto2.TYPE_DOUBLE)
    """
    Distance of the speed change.

    A value of 0.0 (the default value) imposes no constraint
    on the distance, unless the dynamics shape is a step function,
    where an immediate step is effected.

    Unit: m
    """


default_message_pool.register_message(
    "osi3", "TrafficAction.SpeedAction", TrafficActionSpeedAction
)


@dataclass(eq=False, repr=False)
class TrafficActionTeleportAction(betterproto2.Message):
    """
    \\brief Teleport Action

    This Action allows to immediately place a traffic participant to
    another position.

    \\note This action is aligned with the TeleportAction of
    OpenSCENARIO 1.0 using a WorldPosition position argument.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICCOMMAND_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficAction.TeleportAction"
        ]

    action_header: "TrafficActionActionHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The Action Header
    """

    position: "Vector3D | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Position in the global coordinate system.

    The position refers to the center (x,y,z) of the bounding box.

    \\note Remark: The definition of the reference point follows the
    specification of the \\c BaseMoving message.
    """

    orientation: "Orientation3D | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Orientation in the global coordinate system.

    This is optional, if no orientation is given, the end orientation
    is under control of the traffic participant.
    """


default_message_pool.register_message(
    "osi3", "TrafficAction.TeleportAction", TrafficActionTeleportAction
)


@dataclass(eq=False, repr=False)
class TrafficCommand(betterproto2.Message):
    """

    \\brief The scenario engine provides control commands in the traffic command
    message to traffic participant models. The control commands are based on
    the scenario.

    \\note This interface is currently just a placeholder and will be
    changed in experimental ways to support basic scenario execution.
    In the future this interface shall be aligned with the level of
    atomic actions as described in OpenSCENARIO 1.0 or later.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICCOMMAND_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficCommand"
        ]

    version: "InterfaceVersion | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The interface version used by the sender (scenario engine).

    \\rules
    is_set
    \\endrules
    """

    timestamp: "Timestamp | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The data timestamp of the simulation environment. Zero time is arbitrary
    but must be identical for all messages. Zero time does not need to
    coincide with the UNIX epoch. It is recommended to use zero timestamp as 
    the starting time point of the simulation.

    \\note For traffic command data the timestamp coincides both with
    the notional simulation time the data applies to and the time it was sent
    There is no inherent latency for traffic command data, as opposed
    to sensor data.

    \\rules
    is_set
    \\endrules
    """

    traffic_participant_id: "Identifier | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of this traffic participant.

    \\rules
    is_set
    \\endrules
    """

    action: "list[TrafficAction]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Commanded traffic action(s) if any.

    \\note If more than one action is supplied in one command message
    all actions are executed in parallel.
    """


default_message_pool.register_message("osi3", "TrafficCommand", TrafficCommand)


@dataclass(eq=False, repr=False)
class TrafficCommandUpdate(betterproto2.Message):
    """

    \\brief This message enables the traffic participant model to send updates
    to the scenario engine about the execution of its received \\c TrafficCommand input.
    While traffic actions are usually executed successfully by the traffic participant,
    there may be actions which the traffic participant is not able to execute
    either for capability or situation-specific reasons.

    This message allows a traffic participant to send feedback if an action
    cannot happen as requested by the \\c TrafficCommand. Currently, it is out of
    scope to standardize the exact reason for non-executability or failed execution
    because the reason can have multiple explanations. The responsibility for deciding
    about successful or unsuccessful scenario execution lies fully on the side of the
    scenario engine.

    \\note This interface is currently just a placeholder and could be
    changed in experimental ways to support semantics of upcoming OpenSCENARIO
    versions.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICCOMMANDUPDATE_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficCommandUpdate"
        ]

    version: "InterfaceVersion | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The interface version used by the sender (traffic participant model).

    \\rules
    is_set
    \\endrules
    """

    timestamp: "Timestamp | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The data timestamp of the simulation environment. Zero time is arbitrary
    but must be identical for all messages. Zero time does not need to
    coincide with the UNIX epoch. It is recommended to use zero timestamp as 
    the starting time point of the simulation.

    \\rules
    is_set
    \\endrules
    """

    traffic_participant_id: "Identifier | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of this traffic participant which must coincide with a prior sent ID, cf.
    \\c TrafficCommand::traffic_participant_id.

    \\rules
    is_set
    \\endrules
    """

    dismissed_action: "list[TrafficCommandUpdateDismissedAction]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Actions which a traffic participant dismisses and which are not yet ended or 
    aborted by the scenario engine (via a \\c TrafficCommand::action.end_actions_action or a 
    \\c TrafficCommand::action.abort_actions_action). 
    Thus, the valid time interval for this action is after the \\c TrafficCommand::timestamp
    for the respective action, which tells a traffic participant to perform an action, has 
    been sent, but must not be after a \\c TrafficCommand::timestamp of the respective End-Actions-Action 
    or Abort-Actions-Action, which tells a traffic participant to end or abort that action. 

    Furthermore, a \\c TrafficCommand::action.end_actions_action or a 
    \\c TrafficCommand::action.abort_actions_action must not be sent after this action 
    (the \\c TrafficCommandUpdate::dismissed_action) for a respective action has been sent.

    \\note If more than one dismissed action is supplied it means that
    multiple actions are regarded as dismissed.
    """


default_message_pool.register_message(
    "osi3", "TrafficCommandUpdate", TrafficCommandUpdate
)


@dataclass(eq=False, repr=False)
class TrafficCommandUpdateDismissedAction(betterproto2.Message):
    """

    \\brief Action which a traffic participant dismisses.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICCOMMANDUPDATE_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficCommandUpdate.DismissedAction"
        ]

    dismissed_action_id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Dismissed traffic action id from the perspective of this traffic participant, if any.

    \\note A dismissed traffic action id identifies a \\c TrafficCommand::action which cannot be executed or 
    completed by the traffic participant. This field must have the same value as the 
    \\c ActionHeader::action_id of a prior sent \\c TrafficCommand and must correspond
    to the same traffic participant.
    """

    failure_reason: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)
    """
    Information about the reason of failure.

    \\note This is a custom, informal string without a standardized meaning. 
    """


default_message_pool.register_message(
    "osi3", "TrafficCommandUpdate.DismissedAction", TrafficCommandUpdateDismissedAction
)


@dataclass(eq=False, repr=False)
class TrafficLight(betterproto2.Message):
    """

    \\brief A traffic light.

    \\image html OSI_TrafficLight.svg

    One traffic light message defines a single 'bulb' and not a box of several
    bulbs, e.g. red, yellow, green are three separate traffic lights.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICLIGHT_PROTO_DESCRIPTOR.message_types_by_name["TrafficLight"]

    id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the traffic light.

    \\rules
    is_globally_unique
    is_set
    \\endrules
    """

    base: "BaseStationary | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The base parameters of the traffic light.

    \\c BaseStationary::orientation x-axis is view normal of the traffic
    light's icon.
    """

    classification: "TrafficLightClassification | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The classification data for the traffic light.
    """

    model_reference: "str" = betterproto2.field(4, betterproto2.TYPE_STRING)
    """
    Opaque reference of an associated 3D model of the traffic light.

    \\note It is implementation-specific how model_references are resolved to
    3d models.
    """

    source_reference: "list[ExternalReference]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Optional external reference to the traffic light source.

    The external reference points to the source of the traffic light, if it 
    is derived from one or more objects or external references.

    For example, to reference a signal defined in an OpenDRIVE map
    the items should be set as follows:
    * reference = URI to map, can remain empty if identical with definition
                  in \\c GroundTruth::map_reference
    * type = "net.asam.opendrive"
    * identifier[0] = id of t_road_signals_signal

    \\note For non-ASAM Standards, it is implementation-specific how
          source_reference is resolved.

    \\note The value has to be repeated, because one lane segment may be
          derived from more than one origin segment. Multiple sources
          may be added as reference as well, for example, a map and sensors.
    """

    color_description: "ColorDescription | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The visual color of the traffic light.

    \\note This does not represent the semantic classification but the visual
    appearance.  For semantic classification of the traffic light use the color
    field in \\c Classification.
    """


default_message_pool.register_message("osi3", "TrafficLight", TrafficLight)


@dataclass(eq=False, repr=False)
class TrafficLightClassification(betterproto2.Message):
    """

    \\brief \\c Classification data for a traffic light.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICLIGHT_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficLight.Classification"
        ]

    color: "TrafficLightClassificationColor" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: TrafficLightClassificationColor(0),
    )
    """
    The semantic color of the traffic light.

    \\note The color types represent the semantic color classification of a 
    traffic light only. They do not represent an actual visual appearance.

    \\note If the color of the traffic light is known (from history or
    geometrical arrangement) and the state \\c #mode is
    \\c #MODE_OFF then \\c #color could remain unchanged.
    If traffic light displays images in different colors and traffic
    light is off ( \\c #mode =  \\c #MODE_OFF), then \\c #color = \\c
    #COLOR_OTHER .
    """

    icon: "TrafficLightClassificationIcon" = betterproto2.field(
        2,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: TrafficLightClassificationIcon(0),
    )
    """
    The icon of the traffic light.
    """

    mode: "TrafficLightClassificationMode" = betterproto2.field(
        3,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: TrafficLightClassificationMode(0),
    )
    """
    The operating mode of the traffic light.
    """

    counter: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)
    """
    The value of the countdown counter.
    Unit: % or s

    \\note Set value only if traffic light bulb is a countdown counter.

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    assigned_lane_id: "list[Identifier]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The IDs of the lanes that the traffic light is assigned to.
    Might be multiple if the traffic light is valid for multiple driving
    lanes.

    \\note OSI uses singular instead of plural for repeated field names.

    \\rules
    refers_to: Lane
    \\endrules
    """

    is_out_of_service: "bool" = betterproto2.field(6, betterproto2.TYPE_BOOL)
    """
    Boolean flag to indicate that the traffic light is taken out of service.
    This can be achieved by visibly crossing the light, covering it completely
    or switching the traffic light off.
    """

    logical_lane_assignment: "list[LogicalLaneAssignment]" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Assignment of this object to logical lanes.

    \\note OSI uses singular instead of plural for repeated field names.
    """


default_message_pool.register_message(
    "osi3", "TrafficLight.Classification", TrafficLightClassification
)


@dataclass(eq=False, repr=False)
class TrafficSign(betterproto2.Message):
    """

    \\brief A traffic sign.

    All coordinates and orientations are relative to the global ground truth
    coordinate system.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICSIGN_PROTO_DESCRIPTOR.message_types_by_name["TrafficSign"]

    id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the traffic sign.

    \\rules
    is_globally_unique
    is_set
    \\endrules
    """

    main_sign: "TrafficSignMainSign | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Main sign, e.g. speed limit 30 km/h
    """

    supplementary_sign: "list[TrafficSignSupplementarySign]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Additional supplementary signs, e.g. time limits, modifying the traffic
    sign.
    """

    source_reference: "list[ExternalReference]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Optional external reference to the traffic sign source.

    The external reference point to the source of the traffic sign, if it is
    derived from one or more objects or external references.

    For example, to reference a signal defined in an OpenDRIVE map
    the items should be set as follows:
    * reference = URI to map, can remain empty if identical with definition
                  in \\c GroundTruth::map_reference
    * type = "net.asam.opendrive"
    * identifier[0] = id of t_road_signals_signal

    \\note For non-ASAM Standards, it is implementation-specific how
          source_reference is resolved.

    \\note If an individual identification of MainSign and SupplementarySign
          is necessary, this should be done via multiple individual
          entries of this source_reference.

    \\note The value has to be repeated, because one lane segment may be
          derived from more than one origin segment. Multiple sources
          may be added as reference as well, for example, a map and sensors.
    """


default_message_pool.register_message("osi3", "TrafficSign", TrafficSign)


@dataclass(eq=False, repr=False)
class TrafficSignMainSign(betterproto2.Message):
    """

    \\brief Main sign of the traffic sign.

    \\image html OSI_MainSign.svg
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICSIGN_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficSign.MainSign"
        ]

    base: "BaseStationary | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The base parameters of the traffic sign.

    The orientation of the bounding box \\c #base
    ( \\c BaseStationary::orientation ) is defined as follows:
    The z-axis of the given \\c BaseStationary::orientation is the vector
    from the bottom to the top of the traffic sign's 2D image plate.
    (Normally it is equal to the ground truth z-axis.)
    The x-axis of the given \\c BaseStationary::orientation is view
    normal of the traffic sign's image.
    This x-axis points from the traffic sign's image in the direction
    from where a 'viewer' could see the traffic sign image.
    """

    classification: "TrafficSignMainSignClassification | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The classification of the traffic sign.
    """

    model_reference: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)
    """
    Opaque reference of an associated 3D model of the traffic sign.

    \\note It is implementation-specific how model_references are resolved to
    3d models.
    """


default_message_pool.register_message(
    "osi3", "TrafficSign.MainSign", TrafficSignMainSign
)


@dataclass(eq=False, repr=False)
class TrafficSignMainSignClassification(betterproto2.Message):
    """

    \\brief \\c Classification data for a traffic sign.

    \\image html OSI_DirectionScope.svg

    When constructing a \\c MainSign, consider the use of the following
    members:
    - In order to include numerical values indicated in the sign,
    use \\c TrafficSignValue::value. Accompany this value with an
    indication of its unit of measure given by \\c
    TrafficSignValue::value_unit.
    - In order to include strings of text indicated in the sign,
    use \\c TrafficSignValue::text. The interpretation of this text is
    left to a user-defined procedure.
    - Some traffic signs exist in two variants that have a similar
    semantic meaning and the property that the one results from flipping
    the other one around the vertical axis. The optional member \\c
    #vertically_mirrored has been provided to enable an explicit choice
    between both variants.
    - For signs in which an arrow symbol is included to constraint their
    scope, the \\c #direction_scope member has been provided to indicate
    the direction of the arrow from the perspective of a viewer standing
    right in front of the sign and looking straight towards it.

    \\note The definition of the sign types is thought to be independent
    of the country, even if the images used in this documentation are
    based on the German Road Traffic Regulations (StVO).
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICSIGN_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficSign.MainSign.Classification"
        ]

    variability: "TrafficSignVariability" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: TrafficSignVariability(0)
    )
    """
    This value indicates if a sign is static or dynamic regarding its
    content (e.g., electronic sign bridge) and/or regarding its  
    position on the road.
    """

    type: "TrafficSignMainSignClassificationType" = betterproto2.field(
        2,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: TrafficSignMainSignClassificationType(0),
    )
    """
    The type of the traffic sign.

    \\attention Deprecated: A revision is planned for version 4.0.0 to
    replace the type enum with a more semantically defined enumeration,
    with the exact sign specification being relegated to the newly
    introduced 4-tupel traffic sign catalog specification as used in
    <a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE</a>.
    """

    value: "TrafficSignValue | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Additional value associated with the traffic sign, e.g. value of
    the speed limit.

    \\note Field need not be set if traffic sign type does not require
    it.
    """

    direction_scope: "TrafficSignMainSignClassificationDirectionScope" = (
        betterproto2.field(
            4,
            betterproto2.TYPE_ENUM,
            default_factory=lambda: TrafficSignMainSignClassificationDirectionScope(0),
        )
    )
    """
    Some traffic signs have an additional arrow symbol as an
    additional constraint for their scope (e.g. no parking to the
    right). The arrow direction is given relative to the sign's 2D
    image plane, i.e. as a viewer standing right in front of the sign
    and looking straight towards it would interpret the arrow.

    The definition for left and right is according to the following
    temporarily constructed right-handed local coordinate system:
    Set z-axis to match the z-axis of the ground truth coordinate
    system. Set x-axis to the view normal of the traffic sign's image
    (\\c #base \\c BaseStationary::orientation x-axis).
    Right: direction of the local coordinate system's positive
    y-axis. Left: opposite direction of the local coordinate system's
    y-axis i.e. negative y-axis',

    \\note If a traffic sign image is on the ground (there is no
    definition for right or left). Normally, this is a road marking
    and not a traffic sign. Actual traffic signs lying on the ground
    might have been intentionally unmounted and, hence, not be in
    effect.

    \\attention Deprecated: A revision is planned for version 4.0.0 to
    replace the type enum with a more semantically defined enumeration,
    with the exact sign specification being relegated to the newly
    introduced 4-tupel traffic sign catalog specification as used in
    <a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE</a>.
    """

    assigned_lane_id: "list[Identifier]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The IDs of the lanes that the sign is assigned to.
    May be multiple if the sign is valid for multiple lanes.

    \\note OSI uses singular instead of plural for repeated field
    names.

    \\rules
    refers_to: Lane
    \\endrules
    """

    vertically_mirrored: "bool" = betterproto2.field(6, betterproto2.TYPE_BOOL)
    """
    Some traffic signs exist in two variants that have
    a similar semantic meaning but differ in that the symbol
    of the one corresponds to the specular reflection of the
    other with respect to the vertical axis.
    For some scenarios it might be relevant to choose the
    reflected version of a reference sign. This can be done
    by setting the \\c #vertically_mirrored boolean to \\c true.
    As for every boolean in the protocol buffers language, the
    default value of \\c #vertically_mirrored is \\c false.

    \\attention Deprecated: A revision is planned for version 4.0.0 to
    replace the type enum with a more semantically defined enumeration,
    with the exact sign specification being relegated to the newly
    introduced 4-tupel traffic sign catalog specification as used in
    <a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE</a>.
    """

    is_out_of_service: "bool" = betterproto2.field(7, betterproto2.TYPE_BOOL)
    """
    Boolean flag to indicate that a traffic sign is taken out of service.
    This can be achieved by visibly crossing the sign or covering it completely.
    """

    country: "str" = betterproto2.field(8, betterproto2.TYPE_STRING)
    """
    Country specification of the traffic sign catalog specification
    that identifies the actual traffic sign. This is part of the
    4-tupel traffic sign catalog specification as used in
    <a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE</a>.

    Country is specified using the ISO 3166-1, alpha-2 code
    https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2, or the
    special OpenDRIVE country for generic signs.<br>
    """

    country_revision: "str" = betterproto2.field(9, betterproto2.TYPE_STRING)
    """
    Revision specification of the traffic sign catalog specification
    that identifies the actual traffic sign. This is part of the
    4-tupel traffic sign catalog specification as used in
    <a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE</a>.

    The year the traffic rules came into force. <br>
    e.g. "2017"
    """

    code: "str" = betterproto2.field(10, betterproto2.TYPE_STRING)
    """
    Code specification of the traffic sign catalog specification
    that identifies the actual traffic sign. This is part of the
    4-tupel traffic sign catalog specification as used in
    <a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE</a>.

    Code identifier according to country and country revision,
    corresponds to the type field of OpenDRIVE. <br>
    code is only unique in combination with #country and #country_revision.  <br>
    e.g. http://www.vzkat.de/2017/VzKat.htm
    """

    sub_code: "str" = betterproto2.field(11, betterproto2.TYPE_STRING)
    """
    Sub-code specification of the traffic sign catalog specification
    that identifies the actual traffic sign. This is part of the
    4-tupel traffic sign catalog specification as used in
    <a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE</a>.

    Sub-code identifier according to country, country revision and code,
    corresponds to the subtype field of OpenDRIVE. <br>
    sub_code is only unique in combination with #country, #country_revision,
    and #code.  <br>
    e.g. http://www.vzkat.de/2017/VzKat.htm
    """

    logical_lane_assignment: "list[LogicalLaneAssignment]" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Assignment of this object to logical lanes.

    \\note OSI uses singular instead of plural for repeated field
    names.
    """


default_message_pool.register_message(
    "osi3", "TrafficSign.MainSign.Classification", TrafficSignMainSignClassification
)


@dataclass(eq=False, repr=False)
class TrafficSignSupplementarySign(betterproto2.Message):
    """

    \\brief Additional supplementary sign modifying the main sign.

    \\image html OSI_SupplementarySign.svg
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICSIGN_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficSign.SupplementarySign"
        ]

    base: "BaseStationary | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The base parameters of the supplementary traffic sign.

    The orientation of the bounding box \\c SupplementarySign::base
    ( \\c BaseStationary::orientation ) is defined as follows:
    The z-axis of the given \\c BaseStationary::orientation is the vector
    from the bottom to the top of the supplementary traffic sign's 2D
    image plate. (Normally it is equal to the ground truth z-axis.) The
    x-axis of the given \\c BaseStationary::orientation is view normal of
    the supplementary traffic sign's image. This x-axis points from the
    supplementary traffic sign's image in the direction from where a
    'viewer' could see the supplementary traffic sign image.
    """

    classification: "TrafficSignSupplementarySignClassification | None" = (
        betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    The classification of the supplementary traffic sign.
    """

    model_reference: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)
    """
    Opaque reference of an associated 3D model of the supplementary traffic sign.

    \\note It is implementation-specific how model_references are resolved to
    3d models.
    """


default_message_pool.register_message(
    "osi3", "TrafficSign.SupplementarySign", TrafficSignSupplementarySign
)


@dataclass(eq=False, repr=False)
class TrafficSignSupplementarySignClassification(betterproto2.Message):
    """

    \\brief \\c Classification data for a supplementary traffic sign.

    When constructing a \\c SupplementarySign, consider the use of the
    following members:
    - In order to include numerical values indicated in the sign,
    use \\c TrafficSignValue::value. Accompany this value with an
    indication of its unit of measure given by \\c
    TrafficSignValue::value_unit.
    - In order to include strings of text indicated in the sign,
    use \\c TrafficSignValue::text. The interpretation of this text is
    left to a user-defined procedure.

    \\note The definition of the sign types is thought to be independent
    of the country, even if the images used in this documentation are
    based on the German Road Traffic Regulations (StVO).
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICSIGN_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficSign.SupplementarySign.Classification"
        ]

    variability: "TrafficSignVariability" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: TrafficSignVariability(0)
    )
    """
    Variability.
    """

    type: "TrafficSignSupplementarySignClassificationType" = betterproto2.field(
        2,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: TrafficSignSupplementarySignClassificationType(0),
    )
    """
    Type of the supplementary sign.

    \\attention Deprecated: A revision is planned for version 4.0.0 to
    replace the type enum with a more semantically defined enumeration,
    with the exact sign specification being relegated to the newly
    introduced 4-tupel traffic sign catalog specification as used in
    <a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE</a>.
    """

    value: "list[TrafficSignValue]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Additional value(s) associated with the traffic sign, e.g.
    length, mass or starting time in time range.

    \\note Field need not be set if traffic sign type does not require
    it.

    \\note OSI uses singular instead of plural for repeated field
    names.
    """

    assigned_lane_id: "list[Identifier]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The IDs of the lanes that the sign is assigned to.
    May be multiple if the sign is valid for multiple lanes.

    \\note OSI uses singular instead of plural for repeated field
    names.

    \\rules
    refers_to: Lane
    \\endrules
    """

    actor: "list[TrafficSignSupplementarySignClassificationActor]" = betterproto2.field(
        5, betterproto2.TYPE_ENUM, repeated=True
    )
    """
    This enumerator indicates a traffic actor (e.g.
    bikes, cars, trucks and so on), that the supplementary sign
    makes reference to.

    \\attention Deprecated: A revision is planned for version 4.0.0 to
    replace the type enum with a more semantically defined enumeration,
    with the exact sign specification being relegated to the newly
    introduced 4-tupel traffic sign catalog specification as used in
    <a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE</a>.
    """

    arrow: "list[TrafficSignSupplementarySignClassificationArrow]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A direction arrow shown on the supplementary sign.

    \\attention Deprecated: A revision is planned for version 4.0.0 to
    replace the type enum with a more semantically defined enumeration,
    with the exact sign specification being relegated to the newly
    introduced 4-tupel traffic sign catalog specification as used in
    <a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE</a>.
    """

    is_out_of_service: "bool" = betterproto2.field(7, betterproto2.TYPE_BOOL)
    """
    Boolean flag to indicate that the supplementary traffic sign is taken out of service.
    This can be achieved by visibly crossing the sign or covering it completely.
    """

    country: "str" = betterproto2.field(8, betterproto2.TYPE_STRING)
    """
    Country specification of the traffic sign catalog specification
    that identifies the actual traffic sign. This is part of the
    4-tupel traffic sign catalog specification as used in
    <a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE</a>.

    Country is specified using the ISO 3166-1, alpha-2 code
    https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2, or the
    special OpenDRIVE country for generic signs.<br>
    """

    country_revision: "str" = betterproto2.field(9, betterproto2.TYPE_STRING)
    """
    Revision specification of the traffic sign catalog specification
    that identifies the actual traffic sign. This is part of the
    4-tupel traffic sign catalog specification as used in
    <a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE</a>.

    The year the traffic rules came into force. <br>
    e.g. "2017"
    """

    code: "str" = betterproto2.field(10, betterproto2.TYPE_STRING)
    """
    Code specification of the traffic sign catalog specification
    that identifies the actual traffic sign. This is part of the
    4-tupel traffic sign catalog specification as used in
    <a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE</a>.

    Code identifier according to country and country revision,
    corresponds to the type field of OpenDRIVE. <br>
    code is only unique in combination with #country and #country_revision.  <br>
    e.g. http://www.vzkat.de/2017/VzKat.htm
    """

    sub_code: "str" = betterproto2.field(11, betterproto2.TYPE_STRING)
    """
    Sub-code specification of the traffic sign catalog specification
    that identifies the actual traffic sign. This is part of the
    4-tupel traffic sign catalog specification as used in
    <a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE</a>.

    Sub-code identifier according to country, country revision and code,
    corresponds to the subtype field of OpenDRIVE. <br>
    sub_code is only unique in combination with #country, #country_revision,
    and #code.  <br>
    e.g. http://www.vzkat.de/2017/VzKat.htm
    """

    logical_lane_assignment: "list[LogicalLaneAssignment]" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Assignment of this object to logical lanes.

    \\note OSI uses singular instead of plural for repeated field
    names.
    """


default_message_pool.register_message(
    "osi3",
    "TrafficSign.SupplementarySign.Classification",
    TrafficSignSupplementarySignClassification,
)


@dataclass(eq=False, repr=False)
class TrafficSignSupplementarySignClassificationArrow(betterproto2.Message):
    """

    \\brief An arrow denoting a direction shown on the traffic sign.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICSIGN_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficSign.SupplementarySign.Classification.Arrow"
        ]

    lane_id: "list[Identifier]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The IDs of the lanes the arrow applies to

    \\rules
    refers_to: Lane
    \\endrules
    """

    direction: "list[TrafficSignSupplementarySignClassificationArrowDirection]" = (
        betterproto2.field(2, betterproto2.TYPE_ENUM, repeated=True)
    )
    """
    The direction to which the arrow points to
    """


default_message_pool.register_message(
    "osi3",
    "TrafficSign.SupplementarySign.Classification.Arrow",
    TrafficSignSupplementarySignClassificationArrow,
)


@dataclass(eq=False, repr=False)
class TrafficSignValue(betterproto2.Message):
    """

    \\brief Additional value associated with a traffic sign or road marking,
    its unit and its text. The interpretation of this text is left to a
    user-defined procedure
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICSIGN_PROTO_DESCRIPTOR.message_types_by_name[
            "TrafficSignValue"
        ]

    value: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Additional value associated with a traffic sign or road marking,
    e.g. value of a speed limit.
    """

    value_unit: "TrafficSignValueUnit" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: TrafficSignValueUnit(0)
    )
    """
    Unit for additional value.
    """

    text: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)
    """
    Text associated with a sign, e.g. the name of a location whose distance
    to the sign is indicated therein. The interpretation of this text is
    left to a user-defined procedure.
    """


default_message_pool.register_message("osi3", "TrafficSignValue", TrafficSignValue)


@dataclass(eq=False, repr=False)
class TrafficUpdate(betterproto2.Message):
    """

    \\brief The traffic update message is provided by traffic participant
    models to provide updates to their position, state and future
    trajectory back to the simulation environment. The message is
    designed to update data of exactly one traffic participant,
    optionally with an attached trailer.

    \\note For reasons of convenience and consistency, the updated
    information is provided as a MovingObject.  Certain fields of this
    sub-message are not required to be set and will be ignored by the
    simulation environment, because they are static information.
    Instead of creating a separate message type for only the non-static
    information, re-use existing message.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_TRAFFICUPDATE_PROTO_DESCRIPTOR.message_types_by_name["TrafficUpdate"]

    version: "InterfaceVersion | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The interface version used by the sender (traffic participant model).

    \\rules
    is_set
    \\endrules
    """

    timestamp: "Timestamp | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The data timestamp of the simulation environment. Zero time is arbitrary
    but must be identical for all messages. Zero time does not need to
    coincide with the UNIX epoch. Recommended is the starting time point of
    the simulation.

    \\note For moving object update data the timestamp coincides both with
    the notional simulation time the data applies to and the time it was sent.
    There is no inherent latency for moving object update data, as opposed
    to sensor data.

    \\rules
    is_set
    \\endrules
    """

    update: "list[MovingObject]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Updated traffic participant data

    \\note It is not expected that static fields are populated. If they
    are, they may be ignored by the receiver of this message, for example, dimensions,
    or vehicle category.  All dynamic fields should be populated where known,
    for example, velocity, light states, or future trajectory.

    \\note The field is repeated because it is possible to have a trailer attached to
    a vehicle, see MovingObject::VehicleClassification::has_trailer and
    MovingObject::VehicleClassification::trailer_id. 
    """

    internal_state: "list[HostVehicleData]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Internal state for each vehicle.

    This is an optional field as internal state may not be known or relevant,
    for example, a trailer might not have any internal state.
    It is also allowed to only specify internal_state for a subset of the
    objects referenced in the update.

    \\note This covers any information which cannot be externally perceived
    and therefore cannot be included in messages available in ground truth.

    \\note The id field from this should match the id in the update field
    above where the same vehicle is being referenced.
    """


default_message_pool.register_message("osi3", "TrafficUpdate", TrafficUpdate)


@dataclass(eq=False, repr=False)
class UltrasonicDetection(betterproto2.Message):
    """

    \\brief Ultrasonic detection from the sensor (same sensor as sender and
    receiver).

    Direct detections:

    Sending: Ultrasonic Sensor ID 1

    Receiving: Ultrasonic Sensor ID 1

    \\image html OSI_USSensor_direct.svg

    \\note Direct detections lie on circles with the sensor as center.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_FEATUREDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "UltrasonicDetection"
        ]

    existence_probability: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Existence probability of the detection not based on history. Value does
    not depend on any past experience with similar detections.

    \\note Used as confidence measure where a low value means less confidence
    and a high value indicates strong confidence.

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 1
    \\endrules
    """

    object_id: "Identifier | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    ID of the detected object this detection is associated to.

    \\note ID = MAX(uint64) indicates no reference to an object.

    \\rules
    refers_to: DetectedObject
    \\endrules
    """

    distance: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    Measured distance (radius) of the detection.

    Unit: m

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """


default_message_pool.register_message(
    "osi3", "UltrasonicDetection", UltrasonicDetection
)


@dataclass(eq=False, repr=False)
class UltrasonicDetectionData(betterproto2.Message):
    """

    \\brief Data from one ultrasonic sensor including a list of detections.
    This list is generated by the sending ultrasonic sensor. Indirectly received
    signals from other ultrasonic sensors are included in this message.

    Direct detections:

    Sending: Ultrasonic Sensor ID 1

    Receiving:
    - Direct: Ultrasonic Sensor ID 1
    - Indirect: Ultrasonic Sensor ID 2 and 3

    \\image html OSI_USSensor.svg

    \\note Direct detections lie on circles with the sending sensor as center.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_FEATUREDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "UltrasonicDetectionData"
        ]

    header: "SensorDetectionHeader | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Header attributes of ultrasonic detection from one ultrasonic sensor.
    """

    specific_header: "UltrasonicDetectionSpecificHeader | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Additional header attributes of ultrasonic detection from one ultrasonic
    sensor.
    """

    detection: "list[UltrasonicDetection]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of ultrasonic detections.
    """

    indirect_detection: "list[UltrasonicIndirectDetection]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of ultrasonic indirect detections (sender and receiver sensors are
    not the same).
    """


default_message_pool.register_message(
    "osi3", "UltrasonicDetectionData", UltrasonicDetectionData
)


@dataclass(eq=False, repr=False)
class UltrasonicDetectionSpecificHeader(betterproto2.Message):
    """

    \\brief Specific header extension for ultrasonic sensors.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_FEATUREDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "UltrasonicDetectionSpecificHeader"
        ]

    max_range: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Maximal range of the ultrasonic sensor.

    Unit: m
    """

    number_of_valid_indirect_detections: "int" = betterproto2.field(
        2, betterproto2.TYPE_UINT32
    )
    """
    The current number of valid indirect detections in the detections list.
    The detections are measured by a virtual sensor (i.e. sender and
    receiver are different sensors).

    \\note This value has to be set if the list contains invalid detections.
    """


default_message_pool.register_message(
    "osi3", "UltrasonicDetectionSpecificHeader", UltrasonicDetectionSpecificHeader
)


@dataclass(eq=False, repr=False)
class UltrasonicIndirectDetection(betterproto2.Message):
    """

    \\brief Ultrasonic detection received by another ultrasonic sensor (different
    sensors as sender and receiver).

    Indirect detections:

    Sending: Ultrasonic Sensor ID 1

    Receiving: Ultrasonic Sensor ID 2 and 3

    \\image html OSI_USSensor_indirect.svg

    \\note Indirect detections lie on ellipses with the sending resp. receiving
    sensor in the focal points.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_FEATUREDATA_PROTO_DESCRIPTOR.message_types_by_name[
            "UltrasonicIndirectDetection"
        ]

    existence_probability: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Existence probability of the detection not based on history. Value does
    not depend on any past experience with similar detections.

    \\note Used as confidence measure where a low value means less confidence
    and a high value indicates strong confidence.

    \\rules
    is_greater_than_or_equal_to: 0
    is_less_than_or_equal_to: 1
    \\endrules
    """

    object_id: "Identifier | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    ID of the detected object this detection is associated to.

    \\note ID = MAX(uint64) indicates no reference to an object.

    \\rules
    refers_to: DetectedObject
    \\endrules
    """

    ellipsoid_radial: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    First parameter b of an ellipsoid equation.

    Unit: m
    """

    ellipsoid_axial: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)
    """
    Second parameter b of an ellipsoid equation.

    Unit: m
    """

    receiver_id: "Identifier | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the sensor's receiver. Sender ID is stored in the header \\c
    SensorDetectionHeader.
    """

    receiver_origin: "Vector3D | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The vector to the receiver's origin in sending ultrasonic sensor frame.
    The vector is also the direction of \\c #ellipsoid_axial.
    """


default_message_pool.register_message(
    "osi3", "UltrasonicIndirectDetection", UltrasonicIndirectDetection
)


@dataclass(eq=False, repr=False)
class UltrasonicSensorView(betterproto2.Message):
    """

    \\brief Definition of the ultrasonic sensor view.

    Ultrasonic specific sensor view data.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORVIEW_PROTO_DESCRIPTOR.message_types_by_name[
            "UltrasonicSensorView"
        ]

    view_configuration: "UltrasonicSensorViewConfiguration | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Ultrasonic view configuration valid at the time the data was created.
    """


default_message_pool.register_message(
    "osi3", "UltrasonicSensorView", UltrasonicSensorView
)


@dataclass(eq=False, repr=False)
class UltrasonicSensorViewConfiguration(betterproto2.Message):
    """

    \\brief The configuration settings for the Ultrasonic Sensor View to be
    provided by the environment simulation.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORVIEWCONFIGURATION_PROTO_DESCRIPTOR.message_types_by_name[
            "UltrasonicSensorViewConfiguration"
        ]

    sensor_id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the sensor at host vehicle's mounting_position.

    This is the ID of the physical sensor, to be used in its detected
    features output; it is distinct from the ID of its virtual sensor.

    The ID is to be provided by the environment simulation, the sensor
    model is not in a position to provide a useful default value.
    """

    mounting_position: "MountingPosition | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The physical mounting position of the sensor (origin and orientation
    of the sensor coordinate system) given in vehicle coordinates [1].
    The physical position pertains to this detector individually, and
    governs the sensor-relative coordinates in features detected by this
    detector.

    \\arg \\b x-direction of sensor coordinate system: sensor viewing direction
    \\arg \\b z-direction of sensor coordinate system: sensor (up)
    \\arg \\b y-direction of sensor coordinate system: perpendicular to x and z
    right hand system

    \\par Reference:
    [1] DIN Deutsches Institut fuer Normung e. V. (2013). <em>DIN ISO 8855 Strassenfahrzeuge - Fahrzeugdynamik und Fahrverhalten - Begriffe</em>. (DIN ISO 8855:2013-11). Berlin, Germany.

    \\note The origin of vehicle's coordinate system in world frame is
    ( \\c MovingObject::base . \\c BaseMoving::position +
    Inverse_Rotation_yaw_pitch_roll( \\c MovingObject::base . \\c
    BaseMoving::orientation) * \\c
    MovingObject::VehicleAttributes::bbcenter_to_rear) . The orientation of
    the vehicle's coordinate system is equal to the orientation of the
    vehicle's bounding box \\c MovingObject::base . \\c
    BaseMoving::orientation. \\note A default position can be provided by the
    sensor model (e.g. to indicate the position the model was validated for),
    but this is optional; the environment simulation must provide a valid
    mounting position (based on the vehicle configuration) when setting the
    view configuration.
    """

    mounting_position_rmse: "MountingPosition | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The root mean squared error of the mounting position.
    """

    field_of_view_horizontal: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)
    """
    Field of View in horizontal orientation of the physical sensor.

    Viewing range: [- \\c #field_of_view_horizontal/2,  \\c
    #field_of_view_horizontal/2] azimuth in the sensor frame as defined in \\c
    Spherical3d.

    Unit: rad
    """

    field_of_view_vertical: "float" = betterproto2.field(5, betterproto2.TYPE_DOUBLE)
    """
    Field of View in vertical orientation of the physical sensor.

    Viewing range: [- \\c #field_of_view_vertical/2,  \\c
    #field_of_view_vertical/2] elevation in the sensor frame at zero azimuth
    as defined in \\c Spherical3d.

    Unit: rad
    """


default_message_pool.register_message(
    "osi3", "UltrasonicSensorViewConfiguration", UltrasonicSensorViewConfiguration
)


@dataclass(eq=False, repr=False)
class UltrasonicSpecificObjectData(betterproto2.Message):
    """

    \\brief Message encapsulates all data for detected objects that is specific to
    ultrasonic sensors.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORSPECIFIC_PROTO_DESCRIPTOR.message_types_by_name[
            "UltrasonicSpecificObjectData"
        ]

    maximum_measurement_distance_sensor: "float" = betterproto2.field(
        1, betterproto2.TYPE_DOUBLE
    )
    """
    Maximum measured distance from one sensor which leads to the calculation
    of this object.

    Unit: m

    \\rules
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    probability: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    This value indicates the probability height for the classification in the
    calculated object.

    Unit: %

    \\rules
    is_less_than_or_equal_to: 1
    is_greater_than_or_equal_to: 0
    \\endrules
    """

    trilateration_status: "UltrasonicSpecificObjectDataTrilaterationStatus" = (
        betterproto2.field(
            3,
            betterproto2.TYPE_ENUM,
            default_factory=lambda: UltrasonicSpecificObjectDataTrilaterationStatus(0),
        )
    )
    """
    This indicates if the detection was calculated based on one or multiple
    sensors.
    """

    trend: "UltrasonicSpecificObjectDataTrend" = betterproto2.field(
        4,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: UltrasonicSpecificObjectDataTrend(0),
    )
    """
    Describes the general moving direction of the detection.
    """

    signalway: "list[UltrasonicSpecificObjectDataSignalway]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Ultrasonic signalway. Sender to receiver.

    \\note This information can also be derived from the corresponding \\c
    UltrasonicDetection. \\c UltrasonicDetection refer to DetectedXXX by \\c
    UltrasonicDetection::object_id.
    """


default_message_pool.register_message(
    "osi3", "UltrasonicSpecificObjectData", UltrasonicSpecificObjectData
)


@dataclass(eq=False, repr=False)
class UltrasonicSpecificObjectDataSignalway(betterproto2.Message):
    """

    \\brief Message encapsulates all data for detected objects that is
    specific to ultrasonic sensors.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_SENSORSPECIFIC_PROTO_DESCRIPTOR.message_types_by_name[
            "UltrasonicSpecificObjectData.Signalway"
        ]

    sender_id: "Identifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the ultrasonic sensor's sender.
    """

    receiver_id: "Identifier | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The ID of the ultrasonic sensor's receiver.
    """


default_message_pool.register_message(
    "osi3",
    "UltrasonicSpecificObjectData.Signalway",
    UltrasonicSpecificObjectDataSignalway,
)


@dataclass(eq=False, repr=False)
class Vector2D(betterproto2.Message):
    """

    \\brief A cartesian 2D vector for positions, velocities or accelerations or
    its uncertainties.

    Units are m for positions, m/s for velocities, and m/s^2 for
    accelerations.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["Vector2d"]

    x: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    The x-coordinate.

    Unit: m, m/s, or m/s^2
    """

    y: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    The y-coordinate.

    Unit: m, m/s, or m/s^2
    """


default_message_pool.register_message("osi3", "Vector2d", Vector2D)


@dataclass(eq=False, repr=False)
class Vector3D(betterproto2.Message):
    """

    \\brief A cartesian 3D vector for positions, velocities or accelerations or
    its uncertainties.

    The coordinate system is defined as right-handed.

    Units are m for positions, m/s for velocities, and m/s^2 for
    accelerations.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["Vector3d"]

    x: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    The x-coordinate.

    Unit: m, m/s, or m/s^2
    """

    y: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    The y-coordinate.

    Unit: m, m/s, or m/s^2
    """

    z: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    The z-coordinate.

    Unit: m, m/s, or m/s^2
    """


default_message_pool.register_message("osi3", "Vector3d", Vector3D)


@dataclass(eq=False, repr=False)
class VehicleSteeringWheel(betterproto2.Message):
    """

    \\brief A description of the steering wheel.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["VehicleSteeringWheel"]

    angle: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    Angle of the steering wheel. 
    Zero means the steering wheel is in its center position. A positive value
    means the steering wheel is turned to the left. A negative value
    means the steering wheel is turned to the right of the center position.

    Unit: rad
    """

    angular_speed: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Angular speed of the steering wheel. 
    Zero means the steering wheel stays in its position. A positive value
    means the steering wheel is turned to the left. A negative value
    means the steering wheel is turned to the right.

    Unit: rad/s
    """

    torque: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    Torque of the steering wheel to the hand.
    Zero means there is no force from the steering wheel to the hand of the driver.
    A positive value means that the steering wheel would turn to the left without driver intervention.
    A negative value means that the steering wheel would turn to the right without driver intervention.

    Unit: N*m
    """


default_message_pool.register_message(
    "osi3", "VehicleSteeringWheel", VehicleSteeringWheel
)


@dataclass(eq=False, repr=False)
class WavelengthData(betterproto2.Message):
    """

    \\brief Detailed WavelengthRange message.

    Defines the start (minimum) and the end (maximum) values of the wavelength.
    Additionally, the number of samples within this range is defined in this message.
    """

    @betterproto2.staticproperty
    @staticmethod
    def DESCRIPTOR() -> Descriptor:
        return OSI_COMMON_PROTO_DESCRIPTOR.message_types_by_name["WavelengthData"]

    start: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    The start, or the minimum wavelength value.

    Unit: m
    """

    end: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    The end, or the maximum wavelength value.

    Unit: m
    """

    samples_number: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    Number of samples to be considered within the defined wavelength range.
    The number of samples includes the start and the end values that are defined in this message, starting from the "start" value.
    \\note This defines the number of wavelengths to be computed during simulation, not to be confused with samples_per_pixel.
    """


default_message_pool.register_message("osi3", "WavelengthData", WavelengthData)


OSI_VERSION_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b"\n\x11osi_version.proto\x12\x04osi3\x1a google/protobuf/descriptor.proto\"\x81\x01\n\x10InterfaceVersion\x12#\n\rversion_major\x18\x01 \x01(\rR\x0cversionMajor\x12#\n\rversion_minor\x18\x02 \x01(\rR\x0cversionMinor\x12#\n\rversion_patch\x18\x03 \x01(\rR\x0cversionPatch:r\n\x19current_interface_version\x18\xe8\xf8\x04 \x01(\x0b2\x16.osi3.InterfaceVersion\x12\x1c.google.protobuf.FileOptionsR\x17currentInterfaceVersionB\x0cH\x01\xc2\xc6'\x06\x08\x03\x10\x07\x18\x00"
)
OSI_COMMON_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x10osi_common.proto\x12\x04osi3"4\n\x08Vector3d\x12\x0c\n\x01x\x18\x01 \x01(\x01R\x01x\x12\x0c\n\x01y\x18\x02 \x01(\x01R\x01y\x12\x0c\n\x01z\x18\x03 \x01(\x01R\x01z"&\n\x08Vector2d\x12\x0c\n\x01x\x18\x01 \x01(\x01R\x01x\x12\x0c\n\x01y\x18\x02 \x01(\x01R\x01y";\n\tTimestamp\x12\x18\n\x07seconds\x18\x01 \x01(\x03R\x07seconds\x12\x14\n\x05nanos\x18\x02 \x01(\rR\x05nanos"S\n\x0bDimension3d\x12\x16\n\x06length\x18\x01 \x01(\x01R\x06length\x12\x14\n\x05width\x18\x02 \x01(\x01R\x05width\x12\x16\n\x06height\x18\x03 \x01(\x01R\x06height"K\n\rOrientation3d\x12\x12\n\x04roll\x18\x01 \x01(\x01R\x04roll\x12\x14\n\x05pitch\x18\x02 \x01(\x01R\x05pitch\x12\x10\n\x03yaw\x18\x03 \x01(\x01R\x03yaw""\n\nIdentifier\x12\x14\n\x05value\x18\x01 \x01(\x04R\x05value"e\n\x11ExternalReference\x12\x1c\n\treference\x18\x01 \x01(\tR\treference\x12\x12\n\x04type\x18\x02 \x01(\tR\x04type\x12\x1e\n\nidentifier\x18\x03 \x03(\tR\nidentifier"u\n\x10MountingPosition\x12*\n\x08position\x18\x01 \x01(\x0b2\x0e.osi3.Vector3dR\x08position\x125\n\x0borientation\x18\x02 \x01(\x0b2\x13.osi3.Orientation3dR\x0borientation"a\n\x0bSpherical3d\x12\x1a\n\x08distance\x18\x01 \x01(\x01R\x08distance\x12\x18\n\x07azimuth\x18\x02 \x01(\x01R\x07azimuth\x12\x1c\n\televation\x18\x03 \x01(\x01R\televation"\xb5\x01\n\x15LogicalLaneAssignment\x12:\n\x10assigned_lane_id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x0eassignedLaneId\x12\x1d\n\ns_position\x18\x02 \x01(\x01R\tsPosition\x12\x1d\n\nt_position\x18\x03 \x01(\x01R\ttPosition\x12"\n\rangle_to_lane\x18\x04 \x01(\x01R\x0bangleToLane"\xac\x03\n\x0bBoundingBox\x12/\n\tdimension\x18\x01 \x01(\x0b2\x11.osi3.Dimension3dR\tdimension\x12*\n\x08position\x18\x02 \x01(\x0b2\x0e.osi3.Vector3dR\x08position\x125\n\x0borientation\x18\x03 \x01(\x0b2\x13.osi3.Orientation3dR\x0borientation\x12J\n\x15contained_object_type\x18\x04 \x01(\x0e2\x16.osi3.BoundingBox.TypeR\x13containedObjectType\x12\'\n\x0fmodel_reference\x18\x05 \x01(\tR\x0emodelReference"\x93\x01\n\x04Type\x12\x0e\n\x0cTYPE_UNKNOWN\x12\x0e\n\nTYPE_OTHER\x10\x01\x12\x17\n\x13TYPE_BASE_STRUCTURE\x10\x02\x12\x1d\n\x19TYPE_PROTRUDING_STRUCTURE\x10\x03\x12\x0e\n\nTYPE_CARGO\x10\x04\x12\r\n\tTYPE_DOOR\x10\x05\x12\x14\n\x10TYPE_SIDE_MIRROR\x10\x06"\x9c\x02\n\x0eBaseStationary\x12/\n\tdimension\x18\x01 \x01(\x0b2\x11.osi3.Dimension3dR\tdimension\x12*\n\x08position\x18\x02 \x01(\x0b2\x0e.osi3.Vector3dR\x08position\x125\n\x0borientation\x18\x03 \x01(\x0b2\x13.osi3.Orientation3dR\x0borientation\x121\n\x0cbase_polygon\x18\x04 \x03(\x0b2\x0e.osi3.Vector2dR\x0bbasePolygon\x12C\n\x14bounding_box_section\x18\x05 \x03(\x0b2\x11.osi3.BoundingBoxR\x12boundingBoxSection"\x88\x04\n\nBaseMoving\x12/\n\tdimension\x18\x01 \x01(\x0b2\x11.osi3.Dimension3dR\tdimension\x12*\n\x08position\x18\x02 \x01(\x0b2\x0e.osi3.Vector3dR\x08position\x125\n\x0borientation\x18\x03 \x01(\x0b2\x13.osi3.Orientation3dR\x0borientation\x12*\n\x08velocity\x18\x04 \x01(\x0b2\x0e.osi3.Vector3dR\x08velocity\x122\n\x0cacceleration\x18\x05 \x01(\x0b2\x0e.osi3.Vector3dR\x0cacceleration\x12>\n\x10orientation_rate\x18\x06 \x01(\x0b2\x13.osi3.Orientation3dR\x0forientationRate\x12N\n\x18orientation_acceleration\x18\x08 \x01(\x0b2\x13.osi3.Orientation3dR\x17orientationAcceleration\x121\n\x0cbase_polygon\x18\x07 \x03(\x0b2\x0e.osi3.Vector2dR\x0bbasePolygon\x12C\n\x14bounding_box_section\x18\t \x03(\x0b2\x11.osi3.BoundingBoxR\x12boundingBoxSection"\x9e\x01\n\nStatePoint\x12-\n\ttimestamp\x18\x01 \x01(\x0b2\x0f.osi3.TimestampR\ttimestamp\x12*\n\x08position\x18\x02 \x01(\x0b2\x0e.osi3.Vector3dR\x08position\x125\n\x0borientation\x18\x03 \x01(\x0b2\x13.osi3.Orientation3dR\x0borientation"_\n\x0eWavelengthData\x12\x14\n\x05start\x18\x01 \x01(\x01R\x05start\x12\x10\n\x03end\x18\x02 \x01(\x01R\x03end\x12%\n\x0esamples_number\x18\x03 \x01(\x01R\rsamplesNumber"\x92\x01\n\x15SpatialSignalStrength\x12)\n\x10horizontal_angle\x18\x01 \x01(\x01R\x0fhorizontalAngle\x12%\n\x0evertical_angle\x18\x02 \x01(\x01R\rverticalAngle\x12\'\n\x0fsignal_strength\x18\x03 \x01(\x01R\x0esignalStrength"\xea\x01\n\x10ColorDescription\x12#\n\x04grey\x18\x01 \x01(\x0b2\x0f.osi3.ColorGreyR\x04grey\x12 \n\x03rgb\x18\x02 \x01(\x0b2\x0e.osi3.ColorRGBR\x03rgb\x12&\n\x05rgbir\x18\x03 \x01(\x0b2\x10.osi3.ColorRGBIRR\x05rgbir\x12 \n\x03hsv\x18\x04 \x01(\x0b2\x0e.osi3.ColorHSVR\x03hsv\x12 \n\x03luv\x18\x05 \x01(\x0b2\x0e.osi3.ColorLUVR\x03luv\x12#\n\x04cmyk\x18\x06 \x01(\x0b2\x0f.osi3.ColorCMYKR\x04cmyk"\x1f\n\tColorGrey\x12\x12\n\x04grey\x18\x01 \x01(\x01R\x04grey"F\n\x08ColorRGB\x12\x10\n\x03red\x18\x01 \x01(\x01R\x03red\x12\x14\n\x05green\x18\x02 \x01(\x01R\x05green\x12\x12\n\x04blue\x18\x03 \x01(\x01R\x04blue"d\n\nColorRGBIR\x12\x10\n\x03red\x18\x01 \x01(\x01R\x03red\x12\x14\n\x05green\x18\x02 \x01(\x01R\x05green\x12\x12\n\x04blue\x18\x03 \x01(\x01R\x04blue\x12\x1a\n\x08infrared\x18\x04 \x01(\x01R\x08infrared"R\n\x08ColorHSV\x12\x10\n\x03hue\x18\x01 \x01(\x01R\x03hue\x12\x1e\n\nsaturation\x18\x02 \x01(\x01R\nsaturation\x12\x14\n\x05value\x18\x03 \x01(\x01R\x05value"D\n\x08ColorLUV\x12\x1c\n\tluminance\x18\x01 \x01(\x01R\tluminance\x12\x0c\n\x01u\x18\x02 \x01(\x01R\x01u\x12\x0c\n\x01v\x18\x03 \x01(\x01R\x01v"c\n\tColorCMYK\x12\x12\n\x04cyan\x18\x01 \x01(\x01R\x04cyan\x12\x18\n\x07magenta\x18\x02 \x01(\x01R\x07magenta\x12\x16\n\x06yellow\x18\x03 \x01(\x01R\x06yellow\x12\x10\n\x03key\x18\x04 \x01(\x01R\x03key"\xaf\x01\n\x07Pedalry\x12>\n\x1bpedal_position_acceleration\x18\x01 \x01(\x01R\x19pedalPositionAcceleration\x120\n\x14pedal_position_brake\x18\x02 \x01(\x01R\x12pedalPositionBrake\x122\n\x15pedal_position_clutch\x18\x03 \x01(\x01R\x13pedalPositionClutch"i\n\x14VehicleSteeringWheel\x12\x14\n\x05angle\x18\x01 \x01(\x01R\x05angle\x12#\n\rangular_speed\x18\x02 \x01(\x01R\x0cangularSpeed\x12\x16\n\x06torque\x18\x03 \x01(\x01R\x06torque"h\n\x10GeodeticPosition\x12\x1c\n\tlongitude\x18\x01 \x01(\x01R\tlongitude\x12\x1a\n\x08latitude\x18\x02 \x01(\x01R\x08latitude\x12\x1a\n\x08altitude\x18\x03 \x01(\x01R\x08altitude"6\n\x0cKeyValuePair\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value"3\n\tPolygon3d\x12&\n\x06vertex\x18\x01 \x03(\x0b2\x0e.osi3.Vector3dR\x06vertexB\x02H\x01'
)
OSI_TRAFFICCOMMAND_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x18osi_trafficcommand.proto\x12\x04osi3\x1a\x11osi_version.proto\x1a\x10osi_common.proto"\xe6\x01\n\x0eTrafficCommand\x120\n\x07version\x18\x01 \x01(\x0b2\x16.osi3.InterfaceVersionR\x07version\x12-\n\ttimestamp\x18\x02 \x01(\x0b2\x0f.osi3.TimestampR\ttimestamp\x12F\n\x16traffic_participant_id\x18\x03 \x01(\x0b2\x10.osi3.IdentifierR\x14trafficParticipantId\x12+\n\x06action\x18\x04 \x03(\x0b2\x13.osi3.TrafficActionR\x06action"\x9f"\n\rTrafficAction\x12d\n\x18follow_trajectory_action\x18\x01 \x01(\x0b2*.osi3.TrafficAction.FollowTrajectoryActionR\x16followTrajectoryAction\x12R\n\x12follow_path_action\x18\x02 \x01(\x0b2$.osi3.TrafficAction.FollowPathActionR\x10followPathAction\x12t\n\x1eacquire_global_position_action\x18\x03 \x01(\x0b2/.osi3.TrafficAction.AcquireGlobalPositionActionR\x1bacquireGlobalPositionAction\x12R\n\x12lane_change_action\x18\x04 \x01(\x0b2$.osi3.TrafficAction.LaneChangeActionR\x10laneChangeAction\x12B\n\x0cspeed_action\x18\x05 \x01(\x0b2\x1f.osi3.TrafficAction.SpeedActionR\x0bspeedAction\x12X\n\x14abort_actions_action\x18\x06 \x01(\x0b2&.osi3.TrafficAction.AbortActionsActionR\x12abortActionsAction\x12R\n\x12end_actions_action\x18\x07 \x01(\x0b2$.osi3.TrafficAction.EndActionsActionR\x10endActionsAction\x12E\n\rcustom_action\x18\x08 \x01(\x0b2 .osi3.TrafficAction.CustomActionR\x0ccustomAction\x12p\n\x1clongitudinal_distance_action\x18\t \x01(\x0b2..osi3.TrafficAction.LongitudinalDistanceActionR\x1alongitudinalDistanceAction\x12R\n\x12lane_offset_action\x18\n \x01(\x0b2$.osi3.TrafficAction.LaneOffsetActionR\x10laneOffsetAction\x12a\n\x17lateral_distance_action\x18\x0b \x01(\x0b2).osi3.TrafficAction.LateralDistanceActionR\x15lateralDistanceAction\x12K\n\x0fteleport_action\x18\x0c \x01(\x0b2".osi3.TrafficAction.TeleportActionR\x0eteleportAction\x1a=\n\x0cActionHeader\x12-\n\taction_id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x08actionId\x1a\x87\x01\n\x12DynamicConstraints\x12)\n\x10max_acceleration\x18\x01 \x01(\x01R\x0fmaxAcceleration\x12)\n\x10max_deceleration\x18\x02 \x01(\x01R\x0fmaxDeceleration\x12\x1b\n\tmax_speed\x18\x03 \x01(\x01R\x08maxSpeed\x1a\x9b\x02\n\x16FollowTrajectoryAction\x12E\n\raction_header\x18\x01 \x01(\x0b2 .osi3.TrafficAction.ActionHeaderR\x0cactionHeader\x12;\n\x10trajectory_point\x18\x02 \x03(\x0b2\x10.osi3.StatePointR\x0ftrajectoryPoint\x123\n\x15constrain_orientation\x18\x03 \x01(\x08R\x14constrainOrientation\x12H\n\x0efollowing_mode\x18\x04 \x01(\x0e2!.osi3.TrafficAction.FollowingModeR\rfollowingMode\x1a\x89\x02\n\x10FollowPathAction\x12E\n\raction_header\x18\x01 \x01(\x0b2 .osi3.TrafficAction.ActionHeaderR\x0cactionHeader\x12/\n\npath_point\x18\x02 \x03(\x0b2\x10.osi3.StatePointR\tpathPoint\x123\n\x15constrain_orientation\x18\x03 \x01(\x08R\x14constrainOrientation\x12H\n\x0efollowing_mode\x18\x04 \x01(\x0e2!.osi3.TrafficAction.FollowingModeR\rfollowingMode\x1a\xc7\x01\n\x1bAcquireGlobalPositionAction\x12E\n\raction_header\x18\x01 \x01(\x0b2 .osi3.TrafficAction.ActionHeaderR\x0cactionHeader\x12*\n\x08position\x18\x02 \x01(\x0b2\x0e.osi3.Vector3dR\x08position\x125\n\x0borientation\x18\x03 \x01(\x0b2\x13.osi3.Orientation3dR\x0borientation\x1a\x8d\x02\n\x10LaneChangeAction\x12E\n\raction_header\x18\x01 \x01(\x0b2 .osi3.TrafficAction.ActionHeaderR\x0cactionHeader\x120\n\x14relative_target_lane\x18\x02 \x01(\x05R\x12relativeTargetLane\x12H\n\x0edynamics_shape\x18\x03 \x01(\x0e2!.osi3.TrafficAction.DynamicsShapeR\rdynamicsShape\x12\x1a\n\x08duration\x18\x04 \x01(\x01R\x08duration\x12\x1a\n\x08distance\x18\x05 \x01(\x01R\x08distance\x1a\x8a\x02\n\x0bSpeedAction\x12E\n\raction_header\x18\x01 \x01(\x0b2 .osi3.TrafficAction.ActionHeaderR\x0cactionHeader\x122\n\x15absolute_target_speed\x18\x02 \x01(\x01R\x13absoluteTargetSpeed\x12H\n\x0edynamics_shape\x18\x03 \x01(\x0e2!.osi3.TrafficAction.DynamicsShapeR\rdynamicsShape\x12\x1a\n\x08duration\x18\x04 \x01(\x01R\x08duration\x12\x1a\n\x08distance\x18\x05 \x01(\x01R\x08distance\x1a\x97\x01\n\x12AbortActionsAction\x12E\n\raction_header\x18\x01 \x01(\x0b2 .osi3.TrafficAction.ActionHeaderR\x0cactionHeader\x12:\n\x10target_action_id\x18\x02 \x03(\x0b2\x10.osi3.IdentifierR\x0etargetActionId\x1a\x95\x01\n\x10EndActionsAction\x12E\n\raction_header\x18\x01 \x01(\x0b2 .osi3.TrafficAction.ActionHeaderR\x0cactionHeader\x12:\n\x10target_action_id\x18\x02 \x03(\x0b2\x10.osi3.IdentifierR\x0etargetActionId\x1a\x92\x01\n\x0cCustomAction\x12E\n\raction_header\x18\x01 \x01(\x0b2 .osi3.TrafficAction.ActionHeaderR\x0cactionHeader\x12\x18\n\x07command\x18\x02 \x01(\tR\x07command\x12!\n\x0ccommand_type\x18\x03 \x01(\tR\x0bcommandType\x1a\xe3\x02\n\x1aLongitudinalDistanceAction\x12E\n\raction_header\x18\x01 \x01(\x0b2 .osi3.TrafficAction.ActionHeaderR\x0cactionHeader\x12S\n\x1dtarget_traffic_participant_id\x18\x02 \x01(\x0b2\x10.osi3.IdentifierR\x1atargetTrafficParticipantId\x12\x1a\n\x08distance\x18\x03 \x01(\x01R\x08distance\x12\x1c\n\tfreespace\x18\x04 \x01(\x08R\tfreespace\x12\x16\n\x06follow\x18\x05 \x01(\x08R\x06follow\x12W\n\x13dynamic_constraints\x18\x06 \x01(\x0b2&.osi3.TrafficAction.DynamicConstraintsR\x12dynamicConstraints\x1a\xde\x02\n\x15LateralDistanceAction\x12E\n\raction_header\x18\x01 \x01(\x0b2 .osi3.TrafficAction.ActionHeaderR\x0cactionHeader\x12S\n\x1dtarget_traffic_participant_id\x18\x02 \x01(\x0b2\x10.osi3.IdentifierR\x1atargetTrafficParticipantId\x12\x1a\n\x08distance\x18\x03 \x01(\x01R\x08distance\x12\x1c\n\tfreespace\x18\x04 \x01(\x08R\tfreespace\x12\x16\n\x06follow\x18\x05 \x01(\x08R\x06follow\x12W\n\x13dynamic_constraints\x18\x06 \x01(\x0b2&.osi3.TrafficAction.DynamicConstraintsR\x12dynamicConstraints\x1a\xd1\x01\n\x10LaneOffsetAction\x12E\n\raction_header\x18\x01 \x01(\x0b2 .osi3.TrafficAction.ActionHeaderR\x0cactionHeader\x12,\n\x12target_lane_offset\x18\x02 \x01(\x01R\x10targetLaneOffset\x12H\n\x0edynamics_shape\x18\x03 \x01(\x0e2!.osi3.TrafficAction.DynamicsShapeR\rdynamicsShape\x1a\xba\x01\n\x0eTeleportAction\x12E\n\raction_header\x18\x01 \x01(\x0b2 .osi3.TrafficAction.ActionHeaderR\x0cactionHeader\x12*\n\x08position\x18\x02 \x01(\x0b2\x0e.osi3.Vector3dR\x08position\x125\n\x0borientation\x18\x03 \x01(\x0b2\x13.osi3.Orientation3dR\x0borientation"E\n\rFollowingMode\x12\x19\n\x17FOLLOWING_MODE_POSITION\x12\x19\n\x15FOLLOWING_MODE_FOLLOW\x10\x01"\x9a\x01\n\rDynamicsShape\x12\x1c\n\x1aDYNAMICS_SHAPE_UNSPECIFIED\x12\x19\n\x15DYNAMICS_SHAPE_LINEAR\x10\x01\x12\x18\n\x14DYNAMICS_SHAPE_CUBIC\x10\x02\x12\x1d\n\x19DYNAMICS_SHAPE_SINUSOIDAL\x10\x03\x12\x17\n\x13DYNAMICS_SHAPE_STEP\x10\x04B\x02H\x01'
)
OSI_TRAFFICLIGHT_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x16osi_trafficlight.proto\x12\x04osi3\x1a\x10osi_common.proto"\xb6\x0c\n\x0cTrafficLight\x12 \n\x02id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x02id\x12(\n\x04base\x18\x02 \x01(\x0b2\x14.osi3.BaseStationaryR\x04base\x12I\n\x0eclassification\x18\x03 \x01(\x0b2!.osi3.TrafficLight.ClassificationR\x0eclassification\x12\'\n\x0fmodel_reference\x18\x04 \x01(\tR\x0emodelReference\x12B\n\x10source_reference\x18\x05 \x03(\x0b2\x17.osi3.ExternalReferenceR\x0fsourceReference\x12C\n\x11color_description\x18\x06 \x01(\x0b2\x16.osi3.ColorDescriptionR\x10colorDescription\x1a\xdc\t\n\x0eClassification\x12=\n\x05color\x18\x01 \x01(\x0e2\'.osi3.TrafficLight.Classification.ColorR\x05color\x12:\n\x04icon\x18\x02 \x01(\x0e2&.osi3.TrafficLight.Classification.IconR\x04icon\x12:\n\x04mode\x18\x03 \x01(\x0e2&.osi3.TrafficLight.Classification.ModeR\x04mode\x12\x18\n\x07counter\x18\x04 \x01(\x01R\x07counter\x12:\n\x10assigned_lane_id\x18\x05 \x03(\x0b2\x10.osi3.IdentifierR\x0eassignedLaneId\x12)\n\x11is_out_of_service\x18\x06 \x01(\x08R\x0eisOutOfService\x12S\n\x17logical_lane_assignment\x18\x07 \x03(\x0b2\x1b.osi3.LogicalLaneAssignmentR\x15logicalLaneAssignment"|\n\x05Color\x12\x0f\n\rCOLOR_UNKNOWN\x12\x0f\n\x0bCOLOR_OTHER\x10\x01\x12\r\n\tCOLOR_RED\x10\x02\x12\x10\n\x0cCOLOR_YELLOW\x10\x03\x12\x0f\n\x0bCOLOR_GREEN\x10\x04\x12\x0e\n\nCOLOR_BLUE\x10\x05\x12\x0f\n\x0bCOLOR_WHITE\x10\x06"\xcf\x04\n\x04Icon\x12\x0e\n\x0cICON_UNKNOWN\x12\x0e\n\nICON_OTHER\x10\x01\x12\r\n\tICON_NONE\x10\x02\x12\x1d\n\x19ICON_ARROW_STRAIGHT_AHEAD\x10\x03\x12\x13\n\x0fICON_ARROW_LEFT\x10\x04\x12\x18\n\x14ICON_ARROW_DIAG_LEFT\x10\x05\x12"\n\x1eICON_ARROW_STRAIGHT_AHEAD_LEFT\x10\x06\x12\x14\n\x10ICON_ARROW_RIGHT\x10\x07\x12\x19\n\x15ICON_ARROW_DIAG_RIGHT\x10\x08\x12#\n\x1fICON_ARROW_STRAIGHT_AHEAD_RIGHT\x10\t\x12\x19\n\x15ICON_ARROW_LEFT_RIGHT\x10\n\x12\x13\n\x0fICON_ARROW_DOWN\x10\x0b\x12\x18\n\x14ICON_ARROW_DOWN_LEFT\x10\x0c\x12\x19\n\x15ICON_ARROW_DOWN_RIGHT\x10\r\x12\x14\n\x10ICON_ARROW_CROSS\x10\x0e\x12\x13\n\x0fICON_PEDESTRIAN\x10\x0f\x12\r\n\tICON_WALK\x10\x10\x12\x12\n\x0eICON_DONT_WALK\x10\x11\x12\x10\n\x0cICON_BICYCLE\x10\x12\x12\x1f\n\x1bICON_PEDESTRIAN_AND_BICYCLE\x10\x13\x12\x1a\n\x16ICON_COUNTDOWN_SECONDS\x10\x14\x12\x1a\n\x16ICON_COUNTDOWN_PERCENT\x10\x15\x12\r\n\tICON_TRAM\x10\x16\x12\x0c\n\x08ICON_BUS\x10\x17\x12\x15\n\x11ICON_BUS_AND_TRAM\x10\x18"m\n\x04Mode\x12\x0e\n\x0cMODE_UNKNOWN\x12\x0e\n\nMODE_OTHER\x10\x01\x12\x0c\n\x08MODE_OFF\x10\x02\x12\x11\n\rMODE_CONSTANT\x10\x03\x12\x11\n\rMODE_FLASHING\x10\x04\x12\x11\n\rMODE_COUNTING\x10\x05B\x02H\x01'
)
OSI_OBJECT_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x10osi_object.proto\x12\x04osi3\x1a\x10osi_common.proto"\x97\x11\n\x10StationaryObject\x12 \n\x02id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x02id\x12(\n\x04base\x18\x02 \x01(\x0b2\x14.osi3.BaseStationaryR\x04base\x12M\n\x0eclassification\x18\x03 \x01(\x0b2%.osi3.StationaryObject.ClassificationR\x0eclassification\x12\'\n\x0fmodel_reference\x18\x04 \x01(\tR\x0emodelReference\x12B\n\x10source_reference\x18\x05 \x03(\x0b2\x17.osi3.ExternalReferenceR\x0fsourceReference\x12C\n\x11color_description\x18\x06 \x01(\x0b2\x16.osi3.ColorDescriptionR\x10colorDescription\x1a\xb5\x0e\n\x0eClassification\x12>\n\x04type\x18\x01 \x01(\x0e2*.osi3.StationaryObject.Classification.TypeR\x04type\x12J\n\x08material\x18\x02 \x01(\x0e2..osi3.StationaryObject.Classification.MaterialR\x08material\x12G\n\x07density\x18\x03 \x01(\x0e2-.osi3.StationaryObject.Classification.DensityR\x07density\x12A\n\x05color\x18\x04 \x01(\x0e2+.osi3.StationaryObject.Classification.ColorR\x05color\x12\x82\x01\n\x1cemitting_structure_attribute\x18\x05 \x01(\x0b2@.osi3.StationaryObject.Classification.EmittingStructureAttributeR\x1aemittingStructureAttribute\x12:\n\x10assigned_lane_id\x18\x06 \x03(\x0b2\x10.osi3.IdentifierR\x0eassignedLaneId\x128\n\x18assigned_lane_percentage\x18\x07 \x03(\x01R\x16assignedLanePercentage\x12S\n\x17logical_lane_assignment\x18\x08 \x03(\x0b2\x1b.osi3.LogicalLaneAssignmentR\x15logicalLaneAssignment\x1a\xbf\x01\n\x1aEmittingStructureAttribute\x12=\n\x0fwavelength_data\x18\x01 \x03(\x0b2\x14.osi3.WavelengthDataR\x0ewavelengthData\x12b\n\x1femitted_spatial_signal_strength\x18\x03 \x03(\x0b2\x1b.osi3.SpatialSignalStrengthR\x1cemittedSpatialSignalStrength"\xa6\x03\n\x04Type\x12\x0e\n\x0cTYPE_UNKNOWN\x12\x0e\n\nTYPE_OTHER\x10\x01\x12\x0f\n\x0bTYPE_BRIDGE\x10\x02\x12\x11\n\rTYPE_BUILDING\x10\x03\x12\r\n\tTYPE_POLE\x10\x04\x12\x0e\n\nTYPE_PYLON\x10\x05\x12\x13\n\x0fTYPE_DELINEATOR\x10\x06\x12\r\n\tTYPE_TREE\x10\x07\x12\x10\n\x0cTYPE_BARRIER\x10\x08\x12\x13\n\x0fTYPE_VEGETATION\x10\t\x12\x12\n\x0eTYPE_CURBSTONE\x10\n\x12\r\n\tTYPE_WALL\x10\x0b\x12\x1b\n\x17TYPE_VERTICAL_STRUCTURE\x10\x0c\x12\x1e\n\x1aTYPE_RECTANGULAR_STRUCTURE\x10\r\x12\x1b\n\x17TYPE_OVERHEAD_STRUCTURE\x10\x0e\x12\x1d\n\x19TYPE_REFLECTIVE_STRUCTURE\x10\x0f\x12"\n\x1eTYPE_CONSTRUCTION_SITE_ELEMENT\x10\x10\x12\x13\n\x0fTYPE_SPEED_BUMP\x10\x11\x12\x1b\n\x17TYPE_EMITTING_STRUCTURE\x10\x12"\xd7\x01\n\x08Material\x12\x12\n\x10MATERIAL_UNKNOWN\x12\x12\n\x0eMATERIAL_OTHER\x10\x01\x12\x11\n\rMATERIAL_WOOD\x10\x02\x12\x14\n\x10MATERIAL_PLASTIC\x10\x03\x12\x15\n\x11MATERIAL_CONCRETE\x10\x04\x12\x12\n\x0eMATERIAL_METAL\x10\x05\x12\x12\n\x0eMATERIAL_STONE\x10\x06\x12\x12\n\x0eMATERIAL_GLASS\x10\x07\x12\x11\n\rMATERIAL_GLAS\x10\x07\x12\x10\n\x0cMATERIAL_MUD\x10\x08\x1a\x02\x10\x01"\x9d\x01\n\x07Density\x12\x11\n\x0fDENSITY_UNKNOWN\x12\x11\n\rDENSITY_OTHER\x10\x01\x12\x11\n\rDENSITY_SOLID\x10\x02\x12\x16\n\x12DENSITY_SMALL_MESH\x10\x03\x12\x17\n\x13DENSITY_MEDIAN_MESH\x10\x04\x12\x16\n\x12DENSITY_LARGE_MESH\x10\x05\x12\x10\n\x0cDENSITY_OPEN\x10\x06"\xd5\x01\n\x05Color\x12\x0f\n\rCOLOR_UNKNOWN\x12\x0f\n\x0bCOLOR_OTHER\x10\x01\x12\x10\n\x0cCOLOR_YELLOW\x10\x02\x12\x0f\n\x0bCOLOR_GREEN\x10\x03\x12\x0e\n\nCOLOR_BLUE\x10\x04\x12\x10\n\x0cCOLOR_VIOLET\x10\x05\x12\r\n\tCOLOR_RED\x10\x06\x12\x10\n\x0cCOLOR_ORANGE\x10\x07\x12\x0f\n\x0bCOLOR_BLACK\x10\x08\x12\x0e\n\nCOLOR_GRAY\x10\t\x12\x0e\n\nCOLOR_GREY\x10\t\x12\x0f\n\x0bCOLOR_WHITE\x10\n\x1a\x02\x10\x01"\xf9+\n\x0cMovingObject\x12 \n\x02id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x02id\x12$\n\x04base\x18\x02 \x01(\x0b2\x10.osi3.BaseMovingR\x04base\x12+\n\x04type\x18\x03 \x01(\x0e2\x17.osi3.MovingObject.TypeR\x04type\x12:\n\x10assigned_lane_id\x18\x04 \x03(\x0b2\x10.osi3.IdentifierR\x0eassignedLaneId\x12S\n\x12vehicle_attributes\x18\x05 \x01(\x0b2$.osi3.MovingObject.VehicleAttributesR\x11vehicleAttributes\x12_\n\x16vehicle_classification\x18\x06 \x01(\x0b2(.osi3.MovingObject.VehicleClassificationR\x15vehicleClassification\x12\'\n\x0fmodel_reference\x18\x07 \x01(\tR\x0emodelReference\x12=\n\x11future_trajectory\x18\x08 \x03(\x0b2\x10.osi3.StatePointR\x10futureTrajectory\x12o\n\x1cmoving_object_classification\x18\t \x01(\x0b2-.osi3.MovingObject.MovingObjectClassificationR\x1amovingObjectClassification\x12B\n\x10source_reference\x18\n \x03(\x0b2\x17.osi3.ExternalReferenceR\x0fsourceReference\x12C\n\x11color_description\x18\x0b \x01(\x0b2\x16.osi3.ColorDescriptionR\x10colorDescription\x12\\\n\x15pedestrian_attributes\x18\x0c \x01(\x0b2\'.osi3.MovingObject.PedestrianAttributesR\x14pedestrianAttributes\x1a\xa0\x06\n\x11VehicleAttributes\x12-\n\tdriver_id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x08driverId\x12!\n\x0cradius_wheel\x18\x02 \x01(\x01R\x0bradiusWheel\x12#\n\rnumber_wheels\x18\x03 \x01(\rR\x0cnumberWheels\x128\n\x10bbcenter_to_rear\x18\x04 \x01(\x0b2\x0e.osi3.Vector3dR\x0ebbcenterToRear\x12:\n\x11bbcenter_to_front\x18\x05 \x01(\x0b2\x0e.osi3.Vector3dR\x0fbbcenterToFront\x12)\n\x10ground_clearance\x18\x06 \x01(\x01R\x0fgroundClearance\x12M\n\nwheel_data\x18\x07 \x03(\x0b2..osi3.MovingObject.VehicleAttributes.WheelDataR\twheelData\x120\n\x14steering_wheel_angle\x18\x08 \x01(\x01R\x12steeringWheelAngle\x1a\xf1\x02\n\tWheelData\x12\x12\n\x04axle\x18\x01 \x01(\rR\x04axle\x12\x14\n\x05index\x18\x02 \x01(\rR\x05index\x12*\n\x08position\x18\x03 \x01(\x0b2\x0e.osi3.Vector3dR\x08position\x12!\n\x0cwheel_radius\x18\x04 \x01(\x01R\x0bwheelRadius\x12\x1d\n\nrim_radius\x18\x05 \x01(\x01R\trimRadius\x12\x14\n\x05width\x18\x06 \x01(\x01R\x05width\x125\n\x0borientation\x18\x07 \x01(\x0b2\x13.osi3.Orientation3dR\x0borientation\x12#\n\rrotation_rate\x18\x08 \x01(\x01R\x0crotationRate\x12\'\n\x0fmodel_reference\x18\t \x01(\tR\x0emodelReference\x121\n\x14friction_coefficient\x18\n \x01(\x01R\x13frictionCoefficient\x1a\xe7\x01\n\x1aMovingObjectClassification\x12:\n\x10assigned_lane_id\x18\x01 \x03(\x0b2\x10.osi3.IdentifierR\x0eassignedLaneId\x128\n\x18assigned_lane_percentage\x18\x02 \x03(\x01R\x16assignedLanePercentage\x12S\n\x17logical_lane_assignment\x18\x03 \x03(\x0b2\x1b.osi3.LogicalLaneAssignmentR\x15logicalLaneAssignment\x1a\xbd\x15\n\x15VehicleClassification\x12A\n\x04type\x18\x01 \x01(\x0e2-.osi3.MovingObject.VehicleClassification.TypeR\x04type\x12T\n\x0blight_state\x18\x02 \x01(\x0b23.osi3.MovingObject.VehicleClassification.LightStateR\nlightState\x12\x1f\n\x0bhas_trailer\x18\x03 \x01(\x08R\nhasTrailer\x12/\n\ntrailer_id\x18\x04 \x01(\x0b2\x10.osi3.IdentifierR\ttrailerId\x12A\n\x04role\x18\x05 \x01(\x0e2-.osi3.MovingObject.VehicleClassification.RoleR\x04role\x1a\x8b\x0e\n\nLightState\x12k\n\x0findicator_state\x18\x01 \x01(\x0e2B.osi3.MovingObject.VehicleClassification.LightState.IndicatorStateR\x0eindicatorState\x12m\n\x0ffront_fog_light\x18\x02 \x01(\x0e2E.osi3.MovingObject.VehicleClassification.LightState.GenericLightStateR\rfrontFogLight\x12k\n\x0erear_fog_light\x18\x03 \x01(\x0e2E.osi3.MovingObject.VehicleClassification.LightState.GenericLightStateR\x0crearFogLight\x12d\n\nhead_light\x18\x04 \x01(\x0e2E.osi3.MovingObject.VehicleClassification.LightState.GenericLightStateR\theadLight\x12b\n\thigh_beam\x18\x05 \x01(\x0e2E.osi3.MovingObject.VehicleClassification.LightState.GenericLightStateR\x08highBeam\x12n\n\x0freversing_light\x18\x06 \x01(\x0e2E.osi3.MovingObject.VehicleClassification.LightState.GenericLightStateR\x0ereversingLight\x12o\n\x11brake_light_state\x18\x07 \x01(\x0e2C.osi3.MovingObject.VehicleClassification.LightState.BrakeLightStateR\x0fbrakeLightState\x12\x8c\x01\n\x1flicense_plate_illumination_rear\x18\x08 \x01(\x0e2E.osi3.MovingObject.VehicleClassification.LightState.GenericLightStateR\x1clicensePlateIlluminationRear\x12\x8b\x01\n\x1eemergency_vehicle_illumination\x18\t \x01(\x0e2E.osi3.MovingObject.VehicleClassification.LightState.GenericLightStateR\x1cemergencyVehicleIllumination\x12\x87\x01\n\x1cservice_vehicle_illumination\x18\n \x01(\x0e2E.osi3.MovingObject.VehicleClassification.LightState.GenericLightStateR\x1aserviceVehicleIllumination"\xb1\x01\n\x0eIndicatorState\x12\x19\n\x17INDICATOR_STATE_UNKNOWN\x12\x19\n\x15INDICATOR_STATE_OTHER\x10\x01\x12\x17\n\x13INDICATOR_STATE_OFF\x10\x02\x12\x18\n\x14INDICATOR_STATE_LEFT\x10\x03\x12\x19\n\x15INDICATOR_STATE_RIGHT\x10\x04\x12\x1b\n\x17INDICATOR_STATE_WARNING\x10\x05"\x88\x02\n\x11GenericLightState\x12\x1d\n\x1bGENERIC_LIGHT_STATE_UNKNOWN\x12\x1d\n\x19GENERIC_LIGHT_STATE_OTHER\x10\x01\x12\x1b\n\x17GENERIC_LIGHT_STATE_OFF\x10\x02\x12\x1a\n\x16GENERIC_LIGHT_STATE_ON\x10\x03\x12%\n!GENERIC_LIGHT_STATE_FLASHING_BLUE\x10\x04\x12-\n)GENERIC_LIGHT_STATE_FLASHING_BLUE_AND_RED\x10\x05\x12&\n"GENERIC_LIGHT_STATE_FLASHING_AMBER\x10\x06"\xa2\x01\n\x0fBrakeLightState\x12\x1b\n\x19BRAKE_LIGHT_STATE_UNKNOWN\x12\x1b\n\x17BRAKE_LIGHT_STATE_OTHER\x10\x01\x12\x19\n\x15BRAKE_LIGHT_STATE_OFF\x10\x02\x12\x1c\n\x18BRAKE_LIGHT_STATE_NORMAL\x10\x03\x12\x1c\n\x18BRAKE_LIGHT_STATE_STRONG\x10\x04"\xf9\x02\n\x04Type\x12\x0e\n\x0cTYPE_UNKNOWN\x12\x0e\n\nTYPE_OTHER\x10\x01\x12\x12\n\x0eTYPE_SMALL_CAR\x10\x02\x12\x14\n\x10TYPE_COMPACT_CAR\x10\x03\x12\x0c\n\x08TYPE_CAR\x10\x04\x12\x13\n\x0fTYPE_MEDIUM_CAR\x10\x04\x12\x13\n\x0fTYPE_LUXURY_CAR\x10\x05\x12\x15\n\x11TYPE_DELIVERY_VAN\x10\x06\x12\x14\n\x10TYPE_HEAVY_TRUCK\x10\x07\x12\x14\n\x10TYPE_SEMITRACTOR\x10\x10\x12\x14\n\x10TYPE_SEMITRAILER\x10\x08\x12\x10\n\x0cTYPE_TRAILER\x10\t\x12\x12\n\x0eTYPE_MOTORBIKE\x10\n\x12\x10\n\x0cTYPE_BICYCLE\x10\x0b\x12\x0c\n\x08TYPE_BUS\x10\x0c\x12\r\n\tTYPE_TRAM\x10\r\x12\x0e\n\nTYPE_TRAIN\x10\x0e\x12\x13\n\x0fTYPE_WHEELCHAIR\x10\x0f\x12\x18\n\x14TYPE_STANDUP_SCOOTER\x10\x11\x1a\x02\x10\x01"\xeb\x01\n\x04Role\x12\x0e\n\x0cROLE_UNKNOWN\x12\x0e\n\nROLE_OTHER\x10\x01\x12\x0e\n\nROLE_CIVIL\x10\x02\x12\x12\n\x0eROLE_AMBULANCE\x10\x03\x12\r\n\tROLE_FIRE\x10\x04\x12\x0f\n\x0bROLE_POLICE\x10\x05\x12\x19\n\x15ROLE_PUBLIC_TRANSPORT\x10\x06\x12\x18\n\x14ROLE_ROAD_ASSISTANCE\x10\x07\x12\x1b\n\x17ROLE_GARBAGE_COLLECTION\x10\x08\x12\x1a\n\x16ROLE_ROAD_CONSTRUCTION\x10\t\x12\x11\n\rROLE_MILITARY\x10\n\x1a\x94\x07\n\x14PedestrianAttributes\x128\n\x10bbcenter_to_root\x18\x01 \x01(\x0b2\x0e.osi3.Vector3dR\x0ebbcenterToRoot\x12Q\n\rskeleton_bone\x18\x02 \x03(\x0b2,.osi3.MovingObject.PedestrianAttributes.BoneR\x0cskeletonBone\x1a\xee\x05\n\x04Bone\x12E\n\x04type\x18\x01 \x01(\x0e21.osi3.MovingObject.PedestrianAttributes.Bone.TypeR\x04type\x12*\n\x08position\x18\x02 \x01(\x0b2\x0e.osi3.Vector3dR\x08position\x125\n\x0borientation\x18\x03 \x01(\x0b2\x13.osi3.Orientation3dR\x0borientation\x12\x16\n\x06length\x18\x04 \x01(\x02R\x06length\x12\x18\n\x07missing\x18\x05 \x01(\x08R\x07missing\x12*\n\x08velocity\x18\x06 \x01(\x0b2\x0e.osi3.Vector3dR\x08velocity\x12>\n\x10orientation_rate\x18\x07 \x01(\x0b2\x13.osi3.Orientation3dR\x0forientationRate"\x9d\x03\n\x04Type\x12\x0b\n\tTYPE_ROOT\x12\x0c\n\x08TYPE_HIP\x10\x01\x12\x14\n\x10TYPE_LOWER_SPINE\x10\x02\x12\x14\n\x10TYPE_UPPER_SPINE\x10\x03\x12\r\n\tTYPE_NECK\x10\x04\x12\r\n\tTYPE_HEAD\x10\x05\x12\x13\n\x0fTYPE_SHOULDER_L\x10\x06\x12\x13\n\x0fTYPE_SHOULDER_R\x10\x07\x12\x14\n\x10TYPE_UPPER_ARM_L\x10\x08\x12\x14\n\x10TYPE_UPPER_ARM_R\x10\t\x12\x14\n\x10TYPE_LOWER_ARM_L\x10\n\x12\x14\n\x10TYPE_LOWER_ARM_R\x10\x0b\x12\x14\n\x10TYPE_FULL_HAND_L\x10\x0c\x12\x14\n\x10TYPE_FULL_HAND_R\x10\r\x12\x14\n\x10TYPE_UPPER_LEG_L\x10\x0e\x12\x14\n\x10TYPE_UPPER_LEG_R\x10\x0f\x12\x14\n\x10TYPE_LOWER_LEG_L\x10\x10\x12\x14\n\x10TYPE_LOWER_LEG_R\x10\x11\x12\x14\n\x10TYPE_FULL_FOOT_L\x10\x12\x12\x14\n\x10TYPE_FULL_FOOT_R\x10\x13"^\n\x04Type\x12\x0e\n\x0cTYPE_UNKNOWN\x12\x0e\n\nTYPE_OTHER\x10\x01\x12\x10\n\x0cTYPE_VEHICLE\x10\x02\x12\x13\n\x0fTYPE_PEDESTRIAN\x10\x03\x12\x0f\n\x0bTYPE_ANIMAL\x10\x04B\x02H\x01'
)
OSI_SENSORSPECIFIC_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x18osi_sensorspecific.proto\x12\x04osi3\x1a\x10osi_common.proto"+\n\x17RadarSpecificObjectData\x12\x10\n\x03rcs\x18\x01 \x01(\x01R\x03rcs"\x19\n\x17LidarSpecificObjectData"\x1a\n\x18CameraSpecificObjectData"\xab\x06\n\x1cUltrasonicSpecificObjectData\x12M\n#maximum_measurement_distance_sensor\x18\x01 \x01(\x01R maximumMeasurementDistanceSensor\x12 \n\x0bprobability\x18\x02 \x01(\x01R\x0bprobability\x12i\n\x14trilateration_status\x18\x03 \x01(\x0e26.osi3.UltrasonicSpecificObjectData.TrilaterationStatusR\x13trilaterationStatus\x12>\n\x05trend\x18\x04 \x01(\x0e2(.osi3.UltrasonicSpecificObjectData.TrendR\x05trend\x12J\n\tsignalway\x18\x05 \x03(\x0b2,.osi3.UltrasonicSpecificObjectData.SignalwayR\tsignalway\x1am\n\tSignalway\x12-\n\tsender_id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x08senderId\x121\n\x0breceiver_id\x18\x02 \x01(\x0b2\x10.osi3.IdentifierR\nreceiverId"\xa7\x01\n\x13TrilaterationStatus\x12\x1e\n\x1cTRILATERATION_STATUS_UNKNOWN\x12\x1e\n\x1aTRILATERATION_STATUS_OTHER\x10\x01\x12)\n%TRILATERATION_STATUS_NOT_TRILATERATED\x10\x02\x12%\n!TRILATERATION_STATUS_TRILATERATED\x10\x03"\x89\x01\n\x05Trend\x12\x0f\n\rTREND_UNKNOWN\x12\x0f\n\x0bTREND_OTHER\x10\x01\x12\x1e\n\x1aTREND_CONSTANT_APPROACHING\x10\x02\x12\x12\n\x0eTREND_CONSTANT\x10\x03\x12\x15\n\x11TREND_APPROACHING\x10\x04\x12\x13\n\x0fTREND_DEPARTING\x10\x05B\x02H\x01'
)
OSI_DETECTEDOBJECT_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x18osi_detectedobject.proto\x12\x04osi3\x1a\x10osi_common.proto\x1a\x10osi_object.proto\x1a\x18osi_sensorspecific.proto"\xdf\x03\n\x12DetectedItemHeader\x121\n\x0btracking_id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\ntrackingId\x128\n\x0fground_truth_id\x18\x02 \x03(\x0b2\x10.osi3.IdentifierR\rgroundTruthId\x123\n\x15existence_probability\x18\x03 \x01(\x01R\x14existenceProbability\x12\x10\n\x03age\x18\x04 \x01(\x01R\x03age\x12V\n\x11measurement_state\x18\x05 \x01(\x0e2).osi3.DetectedItemHeader.MeasurementStateR\x10measurementState\x12-\n\tsensor_id\x18\x06 \x03(\x0b2\x10.osi3.IdentifierR\x08sensorId"\x8d\x01\n\x10MeasurementState\x12\x1b\n\x19MEASUREMENT_STATE_UNKNOWN\x12\x1b\n\x17MEASUREMENT_STATE_OTHER\x10\x01\x12\x1e\n\x1aMEASUREMENT_STATE_MEASURED\x10\x02\x12\x1f\n\x1bMEASUREMENT_STATE_PREDICTED\x10\x03"\x87\x06\n\x18DetectedStationaryObject\x120\n\x06header\x18\x01 \x01(\x0b2\x18.osi3.DetectedItemHeaderR\x06header\x12(\n\x04base\x18\x02 \x01(\x0b2\x14.osi3.BaseStationaryR\x04base\x121\n\tbase_rmse\x18\x03 \x01(\x0b2\x14.osi3.BaseStationaryR\x08baseRmse\x12V\n\tcandidate\x18\x04 \x03(\x0b28.osi3.DetectedStationaryObject.CandidateStationaryObjectR\tcandidate\x12C\n\x11color_description\x18\x05 \x01(\x0b2\x16.osi3.ColorDescriptionR\x10colorDescription\x12F\n\x0fradar_specifics\x18d \x01(\x0b2\x1d.osi3.RadarSpecificObjectDataR\x0eradarSpecifics\x12F\n\x0flidar_specifics\x18e \x01(\x0b2\x1d.osi3.LidarSpecificObjectDataR\x0elidarSpecifics\x12I\n\x10camera_specifics\x18f \x01(\x0b2\x1e.osi3.CameraSpecificObjectDataR\x0fcameraSpecifics\x12U\n\x14ultrasonic_specifics\x18g \x01(\x0b2".osi3.UltrasonicSpecificObjectDataR\x13ultrasonicSpecifics\x1a\x8c\x01\n\x19CandidateStationaryObject\x12 \n\x0bprobability\x18\x01 \x01(\x01R\x0bprobability\x12M\n\x0eclassification\x18\x02 \x01(\x0b2%.osi3.StationaryObject.ClassificationR\x0eclassification"\xb2\x0e\n\x14DetectedMovingObject\x120\n\x06header\x18\x01 \x01(\x0b2\x18.osi3.DetectedItemHeaderR\x06header\x12$\n\x04base\x18\x02 \x01(\x0b2\x10.osi3.BaseMovingR\x04base\x12-\n\tbase_rmse\x18\x03 \x01(\x0b2\x10.osi3.BaseMovingR\x08baseRmse\x12R\n\x0freference_point\x18\x04 \x01(\x0e2).osi3.DetectedMovingObject.ReferencePointR\x0ereferencePoint\x12O\n\x0emovement_state\x18\x05 \x01(\x0e2(.osi3.DetectedMovingObject.MovementStateR\rmovementState\x129\n\x19percentage_side_lane_left\x18\x06 \x01(\x01R\x16percentageSideLaneLeft\x12;\n\x1apercentage_side_lane_right\x18\x07 \x01(\x01R\x17percentageSideLaneRight\x12N\n\tcandidate\x18\x08 \x03(\x0b20.osi3.DetectedMovingObject.CandidateMovingObjectR\tcandidate\x12C\n\x11color_description\x18\t \x01(\x0b2\x16.osi3.ColorDescriptionR\x10colorDescription\x12F\n\x0fradar_specifics\x18d \x01(\x0b2\x1d.osi3.RadarSpecificObjectDataR\x0eradarSpecifics\x12F\n\x0flidar_specifics\x18e \x01(\x0b2\x1d.osi3.LidarSpecificObjectDataR\x0elidarSpecifics\x12I\n\x10camera_specifics\x18f \x01(\x0b2\x1e.osi3.CameraSpecificObjectDataR\x0fcameraSpecifics\x12U\n\x14ultrasonic_specifics\x18g \x01(\x0b2".osi3.UltrasonicSpecificObjectDataR\x13ultrasonicSpecifics\x1a\xa7\x03\n\x15CandidateMovingObject\x12 \n\x0bprobability\x18\x01 \x01(\x01R\x0bprobability\x12+\n\x04type\x18\x02 \x01(\x0e2\x17.osi3.MovingObject.TypeR\x04type\x12_\n\x16vehicle_classification\x18\x03 \x01(\x0b2(.osi3.MovingObject.VehicleClassificationR\x15vehicleClassification\x120\n\thead_pose\x18\x04 \x01(\x0b2\x13.osi3.Orientation3dR\x08headPose\x12;\n\x0fupper_body_pose\x18\x05 \x01(\x0b2\x13.osi3.Orientation3dR\rupperBodyPose\x12o\n\x1cmoving_object_classification\x18\x06 \x01(\x0b2-.osi3.MovingObject.MovingObjectClassificationR\x1amovingObjectClassification"\xe8\x02\n\x0eReferencePoint\x12\x19\n\x17REFERENCE_POINT_UNKNOWN\x12\x19\n\x15REFERENCE_POINT_OTHER\x10\x01\x12\x1a\n\x16REFERENCE_POINT_CENTER\x10\x02\x12\x1f\n\x1bREFERENCE_POINT_MIDDLE_LEFT\x10\x03\x12 \n\x1cREFERENCE_POINT_MIDDLE_RIGHT\x10\x04\x12\x1f\n\x1bREFERENCE_POINT_REAR_MIDDLE\x10\x05\x12\x1d\n\x19REFERENCE_POINT_REAR_LEFT\x10\x06\x12\x1e\n\x1aREFERENCE_POINT_REAR_RIGHT\x10\x07\x12 \n\x1cREFERENCE_POINT_FRONT_MIDDLE\x10\x08\x12\x1e\n\x1aREFERENCE_POINT_FRONT_LEFT\x10\t\x12\x1f\n\x1bREFERENCE_POINT_FRONT_RIGHT\x10\n"\x99\x01\n\rMovementState\x12\x18\n\x16MOVEMENT_STATE_UNKNOWN\x12\x18\n\x14MOVEMENT_STATE_OTHER\x10\x01\x12\x1d\n\x19MOVEMENT_STATE_STATIONARY\x10\x02\x12\x19\n\x15MOVEMENT_STATE_MOVING\x10\x03\x12\x1a\n\x16MOVEMENT_STATE_STOPPED\x10\x04B\x02H\x01'
)
OSI_DETECTEDTRAFFICLIGHT_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x1eosi_detectedtrafficlight.proto\x12\x04osi3\x1a\x10osi_common.proto\x1a\x16osi_trafficlight.proto\x1a\x18osi_detectedobject.proto"\xc1\x03\n\x14DetectedTrafficLight\x120\n\x06header\x18\x01 \x01(\x0b2\x18.osi3.DetectedItemHeaderR\x06header\x12(\n\x04base\x18\x02 \x01(\x0b2\x14.osi3.BaseStationaryR\x04base\x121\n\tbase_rmse\x18\x03 \x01(\x0b2\x14.osi3.BaseStationaryR\x08baseRmse\x12N\n\tcandidate\x18\x04 \x03(\x0b20.osi3.DetectedTrafficLight.CandidateTrafficLightR\tcandidate\x12C\n\x11color_description\x18\x05 \x01(\x0b2\x16.osi3.ColorDescriptionR\x10colorDescription\x1a\x84\x01\n\x15CandidateTrafficLight\x12 \n\x0bprobability\x18\x01 \x01(\x01R\x0bprobability\x12I\n\x0eclassification\x18\x02 \x01(\x0b2!.osi3.TrafficLight.ClassificationR\x0eclassificationB\x02H\x01'
)
OSI_TRAFFICSIGN_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x15osi_trafficsign.proto\x12\x04osi3\x1a\x10osi_common.proto"\x8a\x04\n\x10TrafficSignValue\x12\x14\n\x05value\x18\x01 \x01(\x01R\x05value\x12:\n\nvalue_unit\x18\x02 \x01(\x0e2\x1b.osi3.TrafficSignValue.UnitR\tvalueUnit\x12\x12\n\x04text\x18\x03 \x01(\tR\x04text"\x8f\x03\n\x04Unit\x12\x0e\n\x0cUNIT_UNKNOWN\x12\x0e\n\nUNIT_OTHER\x10\x01\x12\x10\n\x0cUNIT_NO_UNIT\x10\x02\x12\x1b\n\x17UNIT_KILOMETER_PER_HOUR\x10\x03\x12\x16\n\x12UNIT_MILE_PER_HOUR\x10\x04\x12\x0e\n\nUNIT_METER\x10\x05\x12\x12\n\x0eUNIT_KILOMETER\x10\x06\x12\r\n\tUNIT_FEET\x10\x07\x12\r\n\tUNIT_MILE\x10\x08\x12\x13\n\x0fUNIT_METRIC_TON\x10\t\x12\x11\n\rUNIT_LONG_TON\x10\n\x12\x12\n\x0eUNIT_SHORT_TON\x10\x0b\x12\r\n\tUNIT_HOUR\x10\x0f\x12\x10\n\x0cUNIT_MINUTES\x10\x0c\x12\x15\n\x11UNIT_DAY_OF_MONTH\x10\x10\x12\x0c\n\x08UNIT_DAY\x10\r\x12\x13\n\x0fUNIT_PERCENTAGE\x10\x0e\x12\x15\n\x11UNIT_DURATION_DAY\x10\x11\x12\x16\n\x12UNIT_DURATION_HOUR\x10\x12\x12\x18\n\x14UNIT_DURATION_MINUTE\x10\x13"\xe3k\n\x0bTrafficSign\x12 \n\x02id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x02id\x127\n\tmain_sign\x18\x02 \x01(\x0b2\x1a.osi3.TrafficSign.MainSignR\x08mainSign\x12R\n\x12supplementary_sign\x18\x03 \x03(\x0b2#.osi3.TrafficSign.SupplementarySignR\x11supplementarySign\x12B\n\x10source_reference\x18\x04 \x03(\x0b2\x17.osi3.ExternalReferenceR\x0fsourceReference\x1a\xdbB\n\x08MainSign\x12(\n\x04base\x18\x01 \x01(\x0b2\x14.osi3.BaseStationaryR\x04base\x12Q\n\x0eclassification\x18\x02 \x01(\x0b2).osi3.TrafficSign.MainSign.ClassificationR\x0eclassification\x12\'\n\x0fmodel_reference\x18\x03 \x01(\tR\x0emodelReference\x1a\xa8A\n\x0eClassification\x12?\n\x0bvariability\x18\x01 \x01(\x0e2\x1d.osi3.TrafficSign.VariabilityR\x0bvariability\x12B\n\x04type\x18\x02 \x01(\x0e2..osi3.TrafficSign.MainSign.Classification.TypeR\x04type\x12,\n\x05value\x18\x03 \x01(\x0b2\x16.osi3.TrafficSignValueR\x05value\x12a\n\x0fdirection_scope\x18\x04 \x01(\x0e28.osi3.TrafficSign.MainSign.Classification.DirectionScopeR\x0edirectionScope\x12:\n\x10assigned_lane_id\x18\x05 \x03(\x0b2\x10.osi3.IdentifierR\x0eassignedLaneId\x12/\n\x13vertically_mirrored\x18\x06 \x01(\x08R\x12verticallyMirrored\x12)\n\x11is_out_of_service\x18\x07 \x01(\x08R\x0eisOutOfService\x12\x18\n\x07country\x18\x08 \x01(\tR\x07country\x12)\n\x10country_revision\x18\t \x01(\tR\x0fcountryRevision\x12\x12\n\x04code\x18\n \x01(\tR\x04code\x12\x19\n\x08sub_code\x18\x0b \x01(\tR\x07subCode\x12S\n\x17logical_lane_assignment\x18\x0c \x03(\x0b2\x1b.osi3.LogicalLaneAssignmentR\x15logicalLaneAssignment"\xde:\n\x04Type\x12\x0e\n\x0cTYPE_UNKNOWN\x12\x0e\n\nTYPE_OTHER\x10\x01\x12\x14\n\x10TYPE_DANGER_SPOT\x10\x02\x12\x17\n\x13TYPE_ZEBRA_CROSSING\x10W\x12\x0f\n\x0bTYPE_FLIGHT\x10n\x12\x10\n\x0bTYPE_CATTLE\x10\xc8\x01\x12\x16\n\x11TYPE_HORSE_RIDERS\x10\xc5\x01\x12\x14\n\x0fTYPE_AMPHIBIANS\x10\xbc\x01\x12\x16\n\x12TYPE_FALLING_ROCKS\x10`\x12\x14\n\x10TYPE_SNOW_OR_ICE\x10^\x12\x15\n\x11TYPE_LOOSE_GRAVEL\x10a\x12\x12\n\x0eTYPE_WATERSIDE\x10f\x12\x13\n\x0eTYPE_CLEARANCE\x10\xd2\x01\x12\x17\n\x13TYPE_MOVABLE_BRIDGE\x10e\x12,\n(TYPE_RIGHT_BEFORE_LEFT_NEXT_INTERSECTION\x10\x03\x12\x12\n\x0eTYPE_TURN_LEFT\x10\x04\x12\x13\n\x0fTYPE_TURN_RIGHT\x10\x05\x12\x19\n\x15TYPE_DOUBLE_TURN_LEFT\x10\x06\x12\x1a\n\x16TYPE_DOUBLE_TURN_RIGHT\x10\x07\x12\x17\n\x13TYPE_HILL_DOWNWARDS\x10\x08\x12\x15\n\x11TYPE_HILL_UPWARDS\x10\t\x12\x14\n\x10TYPE_UNEVEN_ROAD\x10]\x12#\n\x1fTYPE_ROAD_SLIPPERY_WET_OR_DIRTY\x10_\x12\x13\n\x0fTYPE_SIDE_WINDS\x10b\x12\x17\n\x13TYPE_ROAD_NARROWING\x10\n\x12\x1d\n\x19TYPE_ROAD_NARROWING_RIGHT\x10\x0c\x12\x1c\n\x18TYPE_ROAD_NARROWING_LEFT\x10\x0b\x12\x13\n\x0fTYPE_ROAD_WORKS\x10\r\x12\x17\n\x13TYPE_TRAFFIC_QUEUES\x10d\x12\x18\n\x14TYPE_TWO_WAY_TRAFFIC\x10\x0e\x12 \n\x1cTYPE_ATTENTION_TRAFFIC_LIGHT\x10\x0f\x12\x14\n\x10TYPE_PEDESTRIANS\x10g\x12\x1a\n\x16TYPE_CHILDREN_CROSSING\x10j\x12\x14\n\x10TYPE_CYCLE_ROUTE\x10k\x12\x16\n\x12TYPE_DEER_CROSSING\x10m\x12 \n\x1bTYPE_UNGATED_LEVEL_CROSSING\x10\x90\x01\x12\x1e\n\x1aTYPE_LEVEL_CROSSING_MARKER\x10p\x12"\n\x1dTYPE_RAILWAY_TRAFFIC_PRIORITY\x10\x87\x01\x12\x11\n\rTYPE_GIVE_WAY\x10\x10\x12\r\n\tTYPE_STOP\x10\x11\x12\'\n#TYPE_PRIORITY_TO_OPPOSITE_DIRECTION\x10\x12\x123\n/TYPE_PRIORITY_TO_OPPOSITE_DIRECTION_UPSIDE_DOWN\x10\x13\x12\x1d\n\x19TYPE_PRESCRIBED_LEFT_TURN\x10\x14\x12\x1e\n\x1aTYPE_PRESCRIBED_RIGHT_TURN\x10\x15\x12\x1c\n\x18TYPE_PRESCRIBED_STRAIGHT\x10\x16\x12\x1d\n\x19TYPE_PRESCRIBED_RIGHT_WAY\x10\x18\x12\x1c\n\x18TYPE_PRESCRIBED_LEFT_WAY\x10\x17\x12+\n\'TYPE_PRESCRIBED_RIGHT_TURN_AND_STRAIGHT\x10\x1a\x12*\n&TYPE_PRESCRIBED_LEFT_TURN_AND_STRAIGHT\x10\x19\x12,\n(TYPE_PRESCRIBED_LEFT_TURN_AND_RIGHT_TURN\x10\x1b\x125\n1TYPE_PRESCRIBED_LEFT_TURN_RIGHT_TURN_AND_STRAIGHT\x10\x1c\x12\x13\n\x0fTYPE_ROUNDABOUT\x10\x1d\x12\x14\n\x10TYPE_ONEWAY_LEFT\x10\x1e\x12\x15\n\x11TYPE_ONEWAY_RIGHT\x10\x1f\x12\x12\n\x0eTYPE_PASS_LEFT\x10 \x12\x13\n\x0fTYPE_PASS_RIGHT\x10!\x12$\n\x1fTYPE_SIDE_LANE_OPEN_FOR_TRAFFIC\x10\x80\x01\x12&\n!TYPE_SIDE_LANE_CLOSED_FOR_TRAFFIC\x10\x81\x01\x12\'\n"TYPE_SIDE_LANE_CLOSING_FOR_TRAFFIC\x10\x82\x01\x12\x12\n\rTYPE_BUS_STOP\x10\x89\x01\x12\x14\n\x0fTYPE_TAXI_STAND\x10\x8a\x01\x12\x17\n\x12TYPE_BICYCLES_ONLY\x10\x91\x01\x12\x1b\n\x16TYPE_HORSE_RIDERS_ONLY\x10\x92\x01\x12\x1a\n\x15TYPE_PEDESTRIANS_ONLY\x10\x93\x01\x12*\n%TYPE_BICYCLES_PEDESTRIANS_SHARED_ONLY\x10\x94\x01\x122\n-TYPE_BICYCLES_PEDESTRIANS_SEPARATED_LEFT_ONLY\x10\x95\x01\x123\n.TYPE_BICYCLES_PEDESTRIANS_SEPARATED_RIGHT_ONLY\x10\x96\x01\x12\x1f\n\x1aTYPE_PEDESTRIAN_ZONE_BEGIN\x10\x97\x01\x12\x1d\n\x18TYPE_PEDESTRIAN_ZONE_END\x10\x98\x01\x12\x1c\n\x17TYPE_BICYCLE_ROAD_BEGIN\x10\x99\x01\x12\x1a\n\x15TYPE_BICYCLE_ROAD_END\x10\x9a\x01\x12\x11\n\rTYPE_BUS_LANE\x10"\x12\x17\n\x13TYPE_BUS_LANE_BEGIN\x10#\x12\x15\n\x11TYPE_BUS_LANE_END\x10$\x12\x17\n\x13TYPE_ALL_PROHIBITED\x10%\x12(\n$TYPE_MOTORIZED_MULTITRACK_PROHIBITED\x10&\x12\x1a\n\x16TYPE_TRUCKS_PROHIBITED\x10\'\x12\x1c\n\x18TYPE_BICYCLES_PROHIBITED\x10(\x12\x1f\n\x1bTYPE_MOTORCYCLES_PROHIBITED\x10)\x12\x1b\n\x16TYPE_MOPEDS_PROHIBITED\x10\x9b\x01\x12!\n\x1cTYPE_HORSE_RIDERS_PROHIBITED\x10\x9c\x01\x12$\n\x1fTYPE_HORSE_CARRIAGES_PROHIBITED\x10\x9d\x01\x12\x1b\n\x16TYPE_CATTLE_PROHIBITED\x10\x9e\x01\x12\x1a\n\x15TYPE_BUSES_PROHIBITED\x10\x9f\x01\x12\x19\n\x14TYPE_CARS_PROHIBITED\x10\xa0\x01\x12"\n\x1dTYPE_CARS_TRAILERS_PROHIBITED\x10\xa1\x01\x12$\n\x1fTYPE_TRUCKS_TRAILERS_PROHIBITED\x10\xa2\x01\x12\x1d\n\x18TYPE_TRACTORS_PROHIBITED\x10\xa3\x01\x12\x1f\n\x1bTYPE_PEDESTRIANS_PROHIBITED\x10*\x12"\n\x1eTYPE_MOTOR_VEHICLES_PROHIBITED\x10+\x12-\n(TYPE_HAZARDOUS_GOODS_VEHICLES_PROHIBITED\x10\xa4\x01\x12)\n$TYPE_OVER_WEIGHT_VEHICLES_PROHIBITED\x10\xa5\x01\x12.\n)TYPE_VEHICLES_AXLE_OVER_WEIGHT_PROHIBITED\x10\xa6\x01\x12*\n%TYPE_VEHICLES_EXCESS_WIDTH_PROHIBITED\x10\xa7\x01\x12+\n&TYPE_VEHICLES_EXCESS_HEIGHT_PROHIBITED\x10\xa8\x01\x12+\n&TYPE_VEHICLES_EXCESS_LENGTH_PROHIBITED\x10\xa9\x01\x12\x15\n\x11TYPE_DO_NOT_ENTER\x10,\x12\x1e\n\x19TYPE_SNOW_CHAINS_REQUIRED\x10\xaa\x01\x12-\n(TYPE_WATER_POLLUTANT_VEHICLES_PROHIBITED\x10\xab\x01\x12!\n\x1dTYPE_ENVIRONMENTAL_ZONE_BEGIN\x10-\x12\x1f\n\x1bTYPE_ENVIRONMENTAL_ZONE_END\x10.\x12\x17\n\x13TYPE_NO_U_TURN_LEFT\x10/\x12\x18\n\x14TYPE_NO_U_TURN_RIGHT\x100\x12\x1f\n\x1bTYPE_PRESCRIBED_U_TURN_LEFT\x101\x12 \n\x1cTYPE_PRESCRIBED_U_TURN_RIGHT\x102\x12$\n TYPE_MINIMUM_DISTANCE_FOR_TRUCKS\x103\x12\x1a\n\x16TYPE_SPEED_LIMIT_BEGIN\x104\x12\x1f\n\x1bTYPE_SPEED_LIMIT_ZONE_BEGIN\x105\x12\x1d\n\x19TYPE_SPEED_LIMIT_ZONE_END\x106\x12\x1c\n\x18TYPE_MINIMUM_SPEED_BEGIN\x107\x12\x1d\n\x19TYPE_OVERTAKING_BAN_BEGIN\x108\x12(\n$TYPE_OVERTAKING_BAN_FOR_TRUCKS_BEGIN\x109\x12\x18\n\x14TYPE_SPEED_LIMIT_END\x10:\x12\x1a\n\x16TYPE_MINIMUM_SPEED_END\x10;\x12\x1b\n\x17TYPE_OVERTAKING_BAN_END\x10<\x12&\n"TYPE_OVERTAKING_BAN_FOR_TRUCKS_END\x10=\x12\x1d\n\x19TYPE_ALL_RESTRICTIONS_END\x10>\x12\x14\n\x10TYPE_NO_STOPPING\x10?\x12\x13\n\x0fTYPE_NO_PARKING\x10@\x12\x1e\n\x1aTYPE_NO_PARKING_ZONE_BEGIN\x10A\x12\x1c\n\x18TYPE_NO_PARKING_ZONE_END\x10B\x12\'\n#TYPE_RIGHT_OF_WAY_NEXT_INTERSECTION\x10C\x12\x1b\n\x17TYPE_RIGHT_OF_WAY_BEGIN\x10D\x12\x19\n\x15TYPE_RIGHT_OF_WAY_END\x10E\x12)\n%TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION\x10F\x125\n1TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION_UPSIDE_DOWN\x10G\x12\x13\n\x0fTYPE_TOWN_BEGIN\x10H\x12\x11\n\rTYPE_TOWN_END\x10I\x12\x14\n\x10TYPE_CAR_PARKING\x10J\x12\x1f\n\x1bTYPE_CAR_PARKING_ZONE_BEGIN\x10K\x12\x1d\n\x19TYPE_CAR_PARKING_ZONE_END\x10L\x12$\n\x1fTYPE_SIDEWALK_HALF_PARKING_LEFT\x10\xac\x01\x12%\n TYPE_SIDEWALK_HALF_PARKING_RIGHT\x10\xad\x01\x12\x1f\n\x1aTYPE_SIDEWALK_PARKING_LEFT\x10\xae\x01\x12 \n\x1bTYPE_SIDEWALK_PARKING_RIGHT\x10\xaf\x01\x122\n-TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_LEFT\x10\xb0\x01\x123\n.TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_RIGHT\x10\xb1\x01\x12-\n(TYPE_SIDEWALK_PERPENDICULAR_PARKING_LEFT\x10\xb2\x01\x12.\n)TYPE_SIDEWALK_PERPENDICULAR_PARKING_RIGHT\x10\xb3\x01\x12\x1c\n\x18TYPE_LIVING_STREET_BEGIN\x10M\x12\x1a\n\x16TYPE_LIVING_STREET_END\x10N\x12\x0f\n\x0bTYPE_TUNNEL\x10O\x12 \n\x1cTYPE_EMERGENCY_STOPPING_LEFT\x10P\x12!\n\x1dTYPE_EMERGENCY_STOPPING_RIGHT\x10Q\x12\x16\n\x12TYPE_HIGHWAY_BEGIN\x10R\x12\x14\n\x10TYPE_HIGHWAY_END\x10S\x12\x19\n\x15TYPE_EXPRESSWAY_BEGIN\x10T\x12\x17\n\x13TYPE_EXPRESSWAY_END\x10U\x12\x1c\n\x17TYPE_NAMED_HIGHWAY_EXIT\x10\xb7\x01\x12\x1f\n\x1aTYPE_NAMED_EXPRESSWAY_EXIT\x10\xb8\x01\x12\x19\n\x14TYPE_NAMED_ROAD_EXIT\x10\xb9\x01\x12\x15\n\x11TYPE_HIGHWAY_EXIT\x10V\x12\x19\n\x14TYPE_EXPRESSWAY_EXIT\x10\xba\x01\x12\x17\n\x12TYPE_ONEWAY_STREET\x10\xbb\x01\x12\x19\n\x14TYPE_CROSSING_GUARDS\x10\xbd\x01\x12\x11\n\x0cTYPE_DEADEND\x10\xbe\x01\x12-\n(TYPE_DEADEND_EXCLUDING_DESIGNATED_ACTORS\x10\xbf\x01\x12\x1b\n\x16TYPE_FIRST_AID_STATION\x10\xc2\x01\x12\x18\n\x13TYPE_POLICE_STATION\x10\xc3\x01\x12\x13\n\x0eTYPE_TELEPHONE\x10\xc4\x01\x12\x19\n\x14TYPE_FILLING_STATION\x10\xc6\x01\x12\x0f\n\nTYPE_HOTEL\x10\xc9\x01\x12\r\n\x08TYPE_INN\x10\xca\x01\x12\x0f\n\nTYPE_KIOSK\x10\xcb\x01\x12\x10\n\x0bTYPE_TOILET\x10\xcc\x01\x12\x10\n\x0bTYPE_CHAPEL\x10\xcd\x01\x12\x16\n\x11TYPE_TOURIST_INFO\x10\xce\x01\x12\x18\n\x13TYPE_REPAIR_SERVICE\x10\xcf\x01\x12\x1e\n\x19TYPE_PEDESTRIAN_UNDERPASS\x10\xd0\x01\x12\x1b\n\x16TYPE_PEDESTRIAN_BRIDGE\x10\xd1\x01\x12\x16\n\x11TYPE_CAMPER_PLACE\x10\xd5\x01\x12$\n\x1fTYPE_ADVISORY_SPEED_LIMIT_BEGIN\x10\xd6\x01\x12"\n\x1dTYPE_ADVISORY_SPEED_LIMIT_END\x10\xd7\x01\x12\x14\n\x0fTYPE_PLACE_NAME\x10\xd8\x01\x12\x1c\n\x17TYPE_TOURIST_ATTRACTION\x10\xd9\x01\x12\x17\n\x12TYPE_TOURIST_ROUTE\x10\xda\x01\x12\x16\n\x11TYPE_TOURIST_AREA\x10\xdb\x01\x12.\n)TYPE_SHOULDER_NOT_PASSABLE_MOTOR_VEHICLES\x10\xdc\x01\x12)\n$TYPE_SHOULDER_UNSAFE_TRUCKS_TRACTORS\x10\xdd\x01\x12\x14\n\x0fTYPE_TOLL_BEGIN\x10\xde\x01\x12\x12\n\rTYPE_TOLL_END\x10\xdf\x01\x12\x13\n\x0eTYPE_TOLL_ROAD\x10\xe0\x01\x12\x11\n\x0cTYPE_CUSTOMS\x10\xe1\x01\x12#\n\x1eTYPE_INTERNATIONAL_BORDER_INFO\x10\xe2\x01\x12\x1e\n\x19TYPE_STREETLIGHT_RED_BAND\x10\xe3\x01\x12&\n!TYPE_FEDERAL_HIGHWAY_ROUTE_NUMBER\x10\xe4\x01\x12\x1e\n\x19TYPE_HIGHWAY_ROUTE_NUMBER\x10\xe5\x01\x12$\n\x1fTYPE_HIGHWAY_INTERCHANGE_NUMBER\x10\xe6\x01\x12\x1f\n\x1aTYPE_EUROPEAN_ROUTE_NUMBER\x10\xe7\x01\x12(\n#TYPE_FEDERAL_HIGHWAY_DIRECTION_LEFT\x10\xe8\x01\x12)\n$TYPE_FEDERAL_HIGHWAY_DIRECTION_RIGHT\x10\xe9\x01\x12%\n TYPE_PRIMARY_ROAD_DIRECTION_LEFT\x10\xea\x01\x12&\n!TYPE_PRIMARY_ROAD_DIRECTION_RIGHT\x10\xeb\x01\x12\'\n"TYPE_SECONDARY_ROAD_DIRECTION_LEFT\x10\xec\x01\x12(\n#TYPE_SECONDARY_ROAD_DIRECTION_RIGHT\x10\xed\x01\x12*\n%TYPE_DIRECTION_DESIGNATED_ACTORS_LEFT\x10\xee\x01\x12+\n&TYPE_DIRECTION_DESIGNATED_ACTORS_RIGHT\x10\xef\x01\x12#\n\x1eTYPE_ROUTING_DESIGNATED_ACTORS\x10\xf0\x01\x12#\n\x1eTYPE_DIRECTION_TO_HIGHWAY_LEFT\x10\x8f\x01\x12#\n\x1fTYPE_DIRECTION_TO_HIGHWAY_RIGHT\x10l\x12,\n(TYPE_DIRECTION_TO_LOCAL_DESTINATION_LEFT\x10\x7f\x12.\n)TYPE_DIRECTION_TO_LOCAL_DESTINATION_RIGHT\x10\x88\x01\x12 \n\x1cTYPE_CONSOLIDATED_DIRECTIONS\x10v\x12\x14\n\x10TYPE_STREET_NAME\x10w\x12"\n\x1eTYPE_DIRECTION_PREANNOUNCEMENT\x10x\x12.\n*TYPE_DIRECTION_PREANNOUNCEMENT_LANE_CONFIG\x10y\x122\n.TYPE_DIRECTION_PREANNOUNCEMENT_HIGHWAY_ENTRIES\x10z\x12\x1d\n\x19TYPE_HIGHWAY_ANNOUNCEMENT\x10{\x12 \n\x1cTYPE_OTHER_ROAD_ANNOUNCEMENT\x10|\x12(\n$TYPE_HIGHWAY_ANNOUNCEMENT_TRUCK_STOP\x10}\x12+\n\'TYPE_HIGHWAY_PREANNOUNCEMENT_DIRECTIONS\x10~\x12\x12\n\x0eTYPE_POLE_EXIT\x10X\x12 \n\x1bTYPE_HIGHWAY_DISTANCE_BOARD\x10\xb4\x01\x12\x15\n\x10TYPE_DETOUR_LEFT\x10\xb5\x01\x12\x16\n\x11TYPE_DETOUR_RIGHT\x10\xb6\x01\x12\x19\n\x14TYPE_NUMBERED_DETOUR\x10\x83\x01\x12\x16\n\x11TYPE_DETOUR_BEGIN\x10\x84\x01\x12\x14\n\x0fTYPE_DETOUR_END\x10\x85\x01\x12\x1e\n\x19TYPE_DETOUR_ROUTING_BOARD\x10\x86\x01\x12\x18\n\x14TYPE_OPTIONAL_DETOUR\x10o\x12!\n\x1cTYPE_OPTIONAL_DETOUR_ROUTING\x10\xc7\x01\x12\x1e\n\x19TYPE_ROUTE_RECOMMENDATION\x10\xd3\x01\x12"\n\x1dTYPE_ROUTE_RECOMMENDATION_END\x10\xd4\x01\x12\'\n"TYPE_ANNOUNCE_LANE_TRANSITION_LEFT\x10\xc0\x01\x12(\n#TYPE_ANNOUNCE_LANE_TRANSITION_RIGHT\x10\xc1\x01\x12 \n\x1cTYPE_ANNOUNCE_RIGHT_LANE_END\x10Z\x12\x1f\n\x1bTYPE_ANNOUNCE_LEFT_LANE_END\x10Y\x12"\n\x1eTYPE_ANNOUNCE_RIGHT_LANE_BEGIN\x10s\x12!\n\x1dTYPE_ANNOUNCE_LEFT_LANE_BEGIN\x10t\x12$\n TYPE_ANNOUNCE_LANE_CONSOLIDATION\x10u\x12\x1b\n\x16TYPE_DETOUR_CITY_BLOCK\x10\x8e\x01\x12\x0e\n\tTYPE_GATE\x10\x8d\x01\x12\x15\n\x11TYPE_POLE_WARNING\x10[\x12\x16\n\x11TYPE_TRAFFIC_CONE\x10\x8c\x01\x12\x1d\n\x18TYPE_MOBILE_LANE_CLOSURE\x10\x8b\x01\x12\x17\n\x13TYPE_REFLECTOR_POST\x10r\x12"\n\x1eTYPE_DIRECTIONAL_BOARD_WARNING\x10q\x12\x16\n\x12TYPE_GUIDING_PLATE\x10h\x12\x1d\n\x19TYPE_GUIDING_PLATE_WEDGES\x10i\x12\x17\n\x13TYPE_PARKING_HAZARD\x10c\x12"\n\x1eTYPE_TRAFFIC_LIGHT_GREEN_ARROW\x10\\"\xbd\x01\n\x0eDirectionScope\x12\x19\n\x17DIRECTION_SCOPE_UNKNOWN\x12\x19\n\x15DIRECTION_SCOPE_OTHER\x10\x01\x12 \n\x1cDIRECTION_SCOPE_NO_DIRECTION\x10\x02\x12\x18\n\x14DIRECTION_SCOPE_LEFT\x10\x03\x12\x19\n\x15DIRECTION_SCOPE_RIGHT\x10\x04\x12\x1e\n\x1aDIRECTION_SCOPE_LEFT_RIGHT\x10\x05\x1a\xbc%\n\x11SupplementarySign\x12(\n\x04base\x18\x01 \x01(\x0b2\x14.osi3.BaseStationaryR\x04base\x12Z\n\x0eclassification\x18\x02 \x01(\x0b22.osi3.TrafficSign.SupplementarySign.ClassificationR\x0eclassification\x12\'\n\x0fmodel_reference\x18\x03 \x01(\tR\x0emodelReference\x1a\xf7#\n\x0eClassification\x12?\n\x0bvariability\x18\x01 \x01(\x0e2\x1d.osi3.TrafficSign.VariabilityR\x0bvariability\x12K\n\x04type\x18\x02 \x01(\x0e27.osi3.TrafficSign.SupplementarySign.Classification.TypeR\x04type\x12,\n\x05value\x18\x03 \x03(\x0b2\x16.osi3.TrafficSignValueR\x05value\x12:\n\x10assigned_lane_id\x18\x04 \x03(\x0b2\x10.osi3.IdentifierR\x0eassignedLaneId\x12N\n\x05actor\x18\x05 \x03(\x0e28.osi3.TrafficSign.SupplementarySign.Classification.ActorR\x05actor\x12N\n\x05arrow\x18\x06 \x03(\x0b28.osi3.TrafficSign.SupplementarySign.Classification.ArrowR\x05arrow\x12)\n\x11is_out_of_service\x18\x07 \x01(\x08R\x0eisOutOfService\x12\x18\n\x07country\x18\x08 \x01(\tR\x07country\x12)\n\x10country_revision\x18\t \x01(\tR\x0fcountryRevision\x12\x12\n\x04code\x18\n \x01(\tR\x04code\x12\x19\n\x08sub_code\x18\x0b \x01(\tR\x07subCode\x12S\n\x17logical_lane_assignment\x18\x0c \x03(\x0b2\x1b.osi3.LogicalLaneAssignmentR\x15logicalLaneAssignment\x1a\xa3\n\n\x05Arrow\x12)\n\x07lane_id\x18\x01 \x03(\x0b2\x10.osi3.IdentifierR\x06laneId\x12`\n\tdirection\x18\x02 \x03(\x0e2B.osi3.TrafficSign.SupplementarySign.Classification.Arrow.DirectionR\tdirection"\x8c\t\n\tDirection\x12\x13\n\x11DIRECTION_UNKNOWN\x12\x13\n\x0fDIRECTION_OTHER\x10\x01\x12\x1a\n\x16DIRECTION_NO_DIRECTION\x10\x02\x12\x1a\n\x16DIRECTION_DIRECT_0_DEG\x10\x03\x12!\n\x1dDIRECTION_DIRECT_45_DEG_RIGHT\x10\x04\x12 \n\x1cDIRECTION_DIRECT_45_DEG_LEFT\x10\x05\x12!\n\x1dDIRECTION_DIRECT_90_DEG_RIGHT\x10\x06\x12 \n\x1cDIRECTION_DIRECT_90_DEG_LEFT\x10\x07\x12"\n\x1eDIRECTION_DIRECT_135_DEG_RIGHT\x10\x08\x12!\n\x1dDIRECTION_DIRECT_135_DEG_LEFT\x10\t\x12\x1c\n\x18DIRECTION_DIRECT_180_DEG\x10\n\x12\x1f\n\x1bDIRECTION_TURN_45_DEG_RIGHT\x10\x0b\x12\x1e\n\x1aDIRECTION_TURN_45_DEG_LEFT\x10\x0c\x12\x1f\n\x1bDIRECTION_TURN_90_DEG_RIGHT\x10\r\x12\x1e\n\x1aDIRECTION_TURN_90_DEG_LEFT\x10\x0e\x12 \n\x1cDIRECTION_TURN_135_DEG_RIGHT\x10\x0f\x12\x1f\n\x1bDIRECTION_TURN_135_DEG_LEFT\x10\x10\x12 \n\x1cDIRECTION_TURN_180_DEG_RIGHT\x10\x11\x12\x1f\n\x1bDIRECTION_TURN_180_DEG_LEFT\x10\x12\x12\x1a\n\x16DIRECTION_CIRCLE_0_DEG\x10\x13\x12!\n\x1dDIRECTION_CIRCLE_45_DEG_RIGHT\x10\x14\x12 \n\x1cDIRECTION_CIRCLE_45_DEG_LEFT\x10\x15\x12!\n\x1dDIRECTION_CIRCLE_90_DEG_RIGHT\x10\x16\x12 \n\x1cDIRECTION_CIRCLE_90_DEG_LEFT\x10\x17\x12"\n\x1eDIRECTION_CIRCLE_135_DEG_RIGHT\x10\x18\x12!\n\x1dDIRECTION_CIRCLE_135_DEG_LEFT\x10\x19\x12\x1c\n\x18DIRECTION_CIRCLE_180_DEG\x10\x1a\x12%\n!DIRECTION_KEEP_LEFT_TO_TURN_0_DEG\x10\x1b\x12&\n"DIRECTION_KEEP_RIGHT_TO_TURN_0_DEG\x10\x1c\x12,\n(DIRECTION_KEEP_LEFT_TO_TURN_90_DEG_RIGHT\x10\x1d\x12,\n(DIRECTION_KEEP_RIGHT_TO_TURN_90_DEG_LEFT\x10\x1e\x127\n3DIRECTION_KEEP_LEFT_DRIVE_BACK_TO_TURN_90_DEG_RIGHT\x10\x1f\x127\n3DIRECTION_KEEP_RIGHT_DRIVE_BACK_TO_TURN_90_DEG_LEFT\x10 "\xb3\n\n\x04Type\x12\x0e\n\x0cTYPE_UNKNOWN\x12\x0e\n\nTYPE_OTHER\x10\x01\x12\x10\n\x0cTYPE_NO_SIGN\x10\x02\x12\r\n\tTYPE_TEXT\x10)\x12\x0e\n\nTYPE_SPACE\x10\'\x12\r\n\tTYPE_TIME\x10\x1a\x12\x0e\n\nTYPE_ARROW\x10\x1e\x12\x17\n\x13TYPE_CONSTRAINED_TO\x10.\x12\x0f\n\x0bTYPE_EXCEPT\x10-\x12\x1b\n\x17TYPE_VALID_FOR_DISTANCE\x10\x03\x12+\n\'TYPE_PRIORITY_ROAD_BOTTOM_LEFT_FOUR_WAY\x10\x1b\x12(\n$TYPE_PRIORITY_ROAD_TOP_LEFT_FOUR_WAY\x10\x1c\x125\n1TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_STRAIGHT\x10 \x125\n1TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_SIDEWAYS\x10!\x122\n.TYPE_PRIORITY_ROAD_TOP_LEFT_THREE_WAY_STRAIGHT\x10"\x12,\n(TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_FOUR_WAY\x10\x1d\x12)\n%TYPE_PRIORITY_ROAD_TOP_RIGHT_FOUR_WAY\x10\x1f\x126\n2TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_STRAIGHT\x10#\x125\n1TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_SIDEWAY\x10$\x123\n/TYPE_PRIORITY_ROAD_TOP_RIGHT_THREE_WAY_STRAIGHT\x10%\x12\x1a\n\x16TYPE_VALID_IN_DISTANCE\x10\x04\x12\x10\n\x0cTYPE_STOP_IN\x10\x19\x12\x13\n\x0fTYPE_LEFT_ARROW\x10\x0b\x12\x18\n\x14TYPE_LEFT_BEND_ARROW\x10\r\x12\x14\n\x10TYPE_RIGHT_ARROW\x10\x0c\x12\x19\n\x15TYPE_RIGHT_BEND_ARROW\x10\x0e\x12\x11\n\rTYPE_ACCIDENT\x10(\x12\r\n\tTYPE_SNOW\x10\t\x12\x0c\n\x08TYPE_FOG\x10\x08\x12$\n TYPE_ROLLING_HIGHWAY_INFORMATION\x100\x12\x11\n\rTYPE_SERVICES\x10/\x12\x13\n\x0fTYPE_TIME_RANGE\x10\x05\x12&\n"TYPE_PARKING_DISC_TIME_RESTRICTION\x10+\x12\x0f\n\x0bTYPE_WEIGHT\x10\x06\x12\x0c\n\x08TYPE_WET\x10,\x12\x1b\n\x17TYPE_PARKING_CONSTRAINT\x10*\x12 \n\x1cTYPE_NO_WAITING_SIDE_STRIPES\x10&\x12\r\n\tTYPE_RAIN\x10\x07\x12\x12\n\x0eTYPE_SNOW_RAIN\x10\n\x12\x0e\n\nTYPE_NIGHT\x10\x13\x12\x13\n\x0fTYPE_STOP_4_WAY\x10\x15\x12\x0e\n\nTYPE_TRUCK\x10\x0f\x12\x1f\n\x1bTYPE_TRACTORS_MAY_BE_PASSED\x10\x10\x12\x12\n\x0eTYPE_HAZARDOUS\x10\x11\x12\x10\n\x0cTYPE_TRAILER\x10\x12\x12\r\n\tTYPE_ZONE\x10\x14\x12\x13\n\x0fTYPE_MOTORCYCLE\x10\x16\x12\x1b\n\x17TYPE_MOTORCYCLE_ALLOWED\x10\x17\x12\x0c\n\x08TYPE_CAR\x10\x18"\xfc\t\n\x05Actor\x12\x0f\n\rACTOR_UNKNOWN\x12\x0f\n\x0bACTOR_OTHER\x10\x01\x12\x12\n\x0eACTOR_NO_ACTOR\x10\x02\x12\x1f\n\x1bACTOR_AGRICULTURAL_VEHICLES\x10\x03\x12\x12\n\x0eACTOR_BICYCLES\x10\x04\x12\x0f\n\x0bACTOR_BUSES\x10\x05\x12\x11\n\rACTOR_CAMPERS\x10\x06\x12\x12\n\x0eACTOR_CARAVANS\x10\x07\x12\x0e\n\nACTOR_CARS\x10\x08\x12\x1c\n\x18ACTOR_CARS_WITH_CARAVANS\x10\t\x12\x1c\n\x18ACTOR_CARS_WITH_TRAILERS\x10\n\x12\x10\n\x0cACTOR_CATTLE\x10\x0b\x12\x12\n\x0eACTOR_CHILDREN\x10\x0c\x12\x1f\n\x1bACTOR_CONSTRUCTION_VEHICLES\x10\r\x12\x1b\n\x17ACTOR_DELIVERY_VEHICLES\x10\x0e\x12\x1a\n\x16ACTOR_DISABLED_PERSONS\x10\x0f\x12\x10\n\x0cACTOR_EBIKES\x10\x10\x12\x1b\n\x17ACTOR_ELECTRIC_VEHICLES\x10\x11\x12\x1c\n\x18ACTOR_EMERGENCY_VEHICLES\x10\x12\x12\x15\n\x11ACTOR_FERRY_USERS\x10\x13\x12\x1b\n\x17ACTOR_FORESTRY_VEHICLES\x10\x14\x12"\n\x1eACTOR_HAZARDOUS_GOODS_VEHICLES\x10\x15\x12\x19\n\x15ACTOR_HORSE_CARRIAGES\x10\x16\x12\x16\n\x12ACTOR_HORSE_RIDERS\x10\x17\x12\x18\n\x14ACTOR_INLINE_SKATERS\x10\x18\x12\x1a\n\x16ACTOR_MEDICAL_VEHICLES\x10\x19\x12\x1b\n\x17ACTOR_MILITARY_VEHICLES\x10\x1a\x12\x10\n\x0cACTOR_MOPEDS\x10\x1b\x12\x15\n\x11ACTOR_MOTORCYCLES\x10\x1c\x12\'\n#ACTOR_MOTORIZED_MULTITRACK_VEHICLES\x10\x1d\x12*\n&ACTOR_OPERATIONAL_AND_UTILITY_VEHICLES\x10\x1e\x12\x15\n\x11ACTOR_PEDESTRIANS\x10\x1f\x12#\n\x1fACTOR_PUBLIC_TRANSPORT_VEHICLES\x10 \x12\x1a\n\x16ACTOR_RAILROAD_TRAFFIC\x10!\x12\x13\n\x0fACTOR_RESIDENTS\x10"\x12\x1a\n\x16ACTOR_SLURRY_TRANSPORT\x10#\x12\x0f\n\x0bACTOR_TAXIS\x10$\x12\x12\n\x0eACTOR_TRACTORS\x10%\x12\x12\n\x0eACTOR_TRAILERS\x10&\x12\x0f\n\x0bACTOR_TRAMS\x10\'\x12\x10\n\x0cACTOR_TRUCKS\x10(\x12"\n\x1eACTOR_TRUCKS_WITH_SEMITRAILERS\x10)\x12\x1e\n\x1aACTOR_TRUCKS_WITH_TRAILERS\x10*\x12$\n ACTOR_VEHICLES_WITH_GREEN_BADGES\x10+\x12"\n\x1eACTOR_VEHICLES_WITH_RED_BADGES\x10,\x12%\n!ACTOR_VEHICLES_WITH_YELLOW_BADGES\x10-\x12"\n\x1eACTOR_WATER_POLLUTANT_VEHICLES\x10.\x12\x1d\n\x19ACTOR_WINTER_SPORTSPEOPLE\x10/"\xc3\x01\n\x0bVariability\x12\x15\n\x13VARIABILITY_UNKNOWN\x12\x15\n\x11VARIABILITY_OTHER\x10\x01\x12\x15\n\x11VARIABILITY_FIXED\x10\x02\x12\x18\n\x14VARIABILITY_VARIABLE\x10\x03\x12\x17\n\x13VARIABILITY_MOVABLE\x10\x04\x12\x17\n\x13VARIABILITY_MUTABLE\x10\x05\x12#\n\x1fVARIABILITY_MOVABLE_AND_MUTABLE\x10\x06B\x02H\x01'
)
OSI_DETECTEDTRAFFICSIGN_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x1dosi_detectedtrafficsign.proto\x12\x04osi3\x1a\x10osi_common.proto\x1a\x15osi_trafficsign.proto\x1a\x18osi_detectedobject.proto"\xd8\n\n\x13DetectedTrafficSign\x120\n\x06header\x18\x01 \x01(\x0b2\x18.osi3.DetectedItemHeaderR\x06header\x12G\n\tmain_sign\x18\x02 \x01(\x0b2*.osi3.DetectedTrafficSign.DetectedMainSignR\x08mainSign\x12b\n\x12supplementary_sign\x18\x03 \x03(\x0b23.osi3.DetectedTrafficSign.DetectedSupplementarySignR\x11supplementarySign\x1a\xdb\x05\n\x10DetectedMainSign\x12Z\n\tcandidate\x18\x01 \x03(\x0b2<.osi3.DetectedTrafficSign.DetectedMainSign.CandidateMainSignR\tcandidate\x12(\n\x04base\x18\x02 \x01(\x0b2\x14.osi3.BaseStationaryR\x04base\x121\n\tbase_rmse\x18\x03 \x01(\x0b2\x14.osi3.BaseStationaryR\x08baseRmse\x12O\n\x08geometry\x18\x04 \x01(\x0e23.osi3.DetectedTrafficSign.DetectedMainSign.GeometryR\x08geometry\x1a\x88\x01\n\x11CandidateMainSign\x12 \n\x0bprobability\x18\x01 \x01(\x01R\x0bprobability\x12Q\n\x0eclassification\x18\x02 \x01(\x0b2).osi3.TrafficSign.MainSign.ClassificationR\x0eclassification"\xb1\x02\n\x08Geometry\x12\x12\n\x10GEOMETRY_UNKNOWN\x12\x12\n\x0eGEOMETRY_OTHER\x10\x01\x12\x13\n\x0fGEOMETRY_CIRCLE\x10\x02\x12\x19\n\x15GEOMETRY_TRIANGLE_TOP\x10\x03\x12\x1a\n\x16GEOMETRY_TRIANGLE_DOWN\x10\x04\x12\x13\n\x0fGEOMETRY_SQUARE\x10\x05\x12\x11\n\rGEOMETRY_POLE\x10\x06\x12\x16\n\x12GEOMETRY_RECTANGLE\x10\x07\x12\x12\n\x0eGEOMETRY_PLATE\x10\x08\x12\x14\n\x10GEOMETRY_DIAMOND\x10\t\x12\x17\n\x13GEOMETRY_ARROW_LEFT\x10\n\x12\x18\n\x14GEOMETRY_ARROW_RIGHT\x10\x0b\x12\x14\n\x10GEOMETRY_OCTAGON\x10\x0c\x1a\x83\x03\n\x19DetectedSupplementarySign\x12l\n\tcandidate\x18\x01 \x03(\x0b2N.osi3.DetectedTrafficSign.DetectedSupplementarySign.CandidateSupplementarySignR\tcandidate\x12(\n\x04base\x18\x02 \x01(\x0b2\x14.osi3.BaseStationaryR\x04base\x121\n\tbase_rmse\x18\x03 \x01(\x0b2\x14.osi3.BaseStationaryR\x08baseRmse\x1a\x9a\x01\n\x1aCandidateSupplementarySign\x12 \n\x0bprobability\x18\x01 \x01(\x01R\x0bprobability\x12Z\n\x0eclassification\x18\x02 \x01(\x0b22.osi3.TrafficSign.SupplementarySign.ClassificationR\x0eclassificationB\x02H\x01'
)
OSI_ROADMARKING_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x15osi_roadmarking.proto\x12\x04osi3\x1a\x10osi_common.proto\x1a\x15osi_trafficsign.proto"\xa0\n\n\x0bRoadMarking\x12 \n\x02id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x02id\x12(\n\x04base\x18\x02 \x01(\x0b2\x14.osi3.BaseStationaryR\x04base\x12H\n\x0eclassification\x18\x03 \x01(\x0b2 .osi3.RoadMarking.ClassificationR\x0eclassification\x12B\n\x10source_reference\x18\x04 \x03(\x0b2\x17.osi3.ExternalReferenceR\x0fsourceReference\x12C\n\x11color_description\x18\x05 \x01(\x0b2\x16.osi3.ColorDescriptionR\x10colorDescription\x1a\xf1\x07\n\x0eClassification\x129\n\x04type\x18\x01 \x01(\x0e2%.osi3.RoadMarking.Classification.TypeR\x04type\x12c\n\x16traffic_main_sign_type\x18\x02 \x01(\x0e2..osi3.TrafficSign.MainSign.Classification.TypeR\x13trafficMainSignType\x12Q\n\x10monochrome_color\x18\x03 \x01(\x0e2&.osi3.RoadMarking.Classification.ColorR\x0fmonochromeColor\x12,\n\x05value\x18\x04 \x01(\x0b2\x16.osi3.TrafficSignValueR\x05value\x12\x1d\n\nvalue_text\x18\x05 \x01(\tR\tvalueText\x12:\n\x10assigned_lane_id\x18\x06 \x03(\x0b2\x10.osi3.IdentifierR\x0eassignedLaneId\x12)\n\x11is_out_of_service\x18\x07 \x01(\x08R\x0eisOutOfService\x12\x18\n\x07country\x18\x08 \x01(\tR\x07country\x12)\n\x10country_revision\x18\t \x01(\tR\x0fcountryRevision\x12\x12\n\x04code\x18\n \x01(\tR\x04code\x12\x19\n\x08sub_code\x18\x0b \x01(\tR\x07subCode\x12S\n\x17logical_lane_assignment\x18\x0c \x03(\x0b2\x1b.osi3.LogicalLaneAssignmentR\x15logicalLaneAssignment"\xcb\x01\n\x04Type\x12\x0e\n\x0cTYPE_UNKNOWN\x12\x0e\n\nTYPE_OTHER\x10\x01\x12\x1d\n\x19TYPE_PAINTED_TRAFFIC_SIGN\x10\x02\x12\x1e\n\x1aTYPE_SYMBOLIC_TRAFFIC_SIGN\x10\x03\x12\x1d\n\x19TYPE_TEXTUAL_TRAFFIC_SIGN\x10\x04\x12\x17\n\x13TYPE_GENERIC_SYMBOL\x10\x05\x12\x15\n\x11TYPE_GENERIC_LINE\x10\x06\x12\x15\n\x11TYPE_GENERIC_TEXT\x10\x07"\xa0\x01\n\x05Color\x12\x0f\n\rCOLOR_UNKNOWN\x12\x0f\n\x0bCOLOR_OTHER\x10\x01\x12\x0f\n\x0bCOLOR_WHITE\x10\x02\x12\x10\n\x0cCOLOR_YELLOW\x10\x03\x12\x0e\n\nCOLOR_BLUE\x10\x05\x12\r\n\tCOLOR_RED\x10\x06\x12\x0f\n\x0bCOLOR_GREEN\x10\x07\x12\x10\n\x0cCOLOR_VIOLET\x10\x08\x12\x10\n\x0cCOLOR_ORANGE\x10\tB\x02H\x01'
)
OSI_DETECTEDROADMARKING_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x1dosi_detectedroadmarking.proto\x12\x04osi3\x1a\x10osi_common.proto\x1a\x15osi_roadmarking.proto\x1a\x18osi_detectedobject.proto"\xbc\x03\n\x13DetectedRoadMarking\x120\n\x06header\x18\x01 \x01(\x0b2\x18.osi3.DetectedItemHeaderR\x06header\x12(\n\x04base\x18\x02 \x01(\x0b2\x14.osi3.BaseStationaryR\x04base\x121\n\tbase_rmse\x18\x03 \x01(\x0b2\x14.osi3.BaseStationaryR\x08baseRmse\x12L\n\tcandidate\x18\x04 \x03(\x0b2..osi3.DetectedRoadMarking.CandidateRoadMarkingR\tcandidate\x12C\n\x11color_description\x18\x05 \x01(\x0b2\x16.osi3.ColorDescriptionR\x10colorDescription\x1a\x82\x01\n\x14CandidateRoadMarking\x12 \n\x0bprobability\x18\x01 \x01(\x01R\x0bprobability\x12H\n\x0eclassification\x18\x02 \x01(\x0b2 .osi3.RoadMarking.ClassificationR\x0eclassificationB\x02H\x01'
)
OSI_ROUTE_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x0fosi_route.proto\x12\x04osi3\x1a\x10osi_common.proto"\xc4\x02\n\x05Route\x12+\n\x08route_id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x07routeId\x12=\n\rroute_segment\x18\x02 \x03(\x0b2\x18.osi3.Route.RouteSegmentR\x0crouteSegment\x1a|\n\x12LogicalLaneSegment\x128\n\x0flogical_lane_id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\rlogicalLaneId\x12\x17\n\x07start_s\x18\x02 \x01(\x01R\x06startS\x12\x13\n\x05end_s\x18\x03 \x01(\x01R\x04endS\x1aQ\n\x0cRouteSegment\x12A\n\x0clane_segment\x18\x01 \x03(\x0b2\x1e.osi3.Route.LogicalLaneSegmentR\x0blaneSegmentB\x02H\x01'
)
OSI_MOTIONREQUEST_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x17osi_motionrequest.proto\x12\x04osi3\x1a\x10osi_common.proto\x1a\x11osi_version.proto"\x97\x06\n\rMotionRequest\x120\n\x07version\x18\x01 \x01(\x0b2\x16.osi3.InterfaceVersionR\x07version\x12-\n\ttimestamp\x18\x02 \x01(\x0b2\x0f.osi3.TimestampR\ttimestamp\x12U\n\x13motion_request_type\x18\x03 \x01(\x0e2%.osi3.MotionRequest.MotionRequestTypeR\x11motionRequestType\x12E\n\rdesired_state\x18\x04 \x01(\x0b2 .osi3.MotionRequest.DesiredStateR\x0cdesiredState\x12T\n\x12desired_trajectory\x18\x05 \x01(\x0b2%.osi3.MotionRequest.DesiredTrajectoryR\x11desiredTrajectory\x1a\x80\x02\n\x0cDesiredState\x12-\n\ttimestamp\x18\x01 \x01(\x0b2\x0f.osi3.TimestampR\ttimestamp\x12*\n\x08position\x18\x02 \x01(\x0b2\x0e.osi3.Vector3dR\x08position\x125\n\x0borientation\x18\x03 \x01(\x0b2\x13.osi3.Orientation3dR\x0borientation\x12*\n\x08velocity\x18\x04 \x01(\x0b2\x0e.osi3.Vector3dR\x08velocity\x122\n\x0cacceleration\x18\x05 \x01(\x0b2\x0e.osi3.Vector3dR\x0cacceleration\x1aP\n\x11DesiredTrajectory\x12;\n\x10trajectory_point\x18\x01 \x03(\x0b2\x10.osi3.StatePointR\x0ftrajectoryPoint"\\\n\x11MotionRequestType\x12#\n!MOTION_REQUEST_TYPE_DESIRED_STATE\x12"\n\x1eMOTION_REQUEST_TYPE_TRAJECTORY\x10\x01B\x02H\x01'
)
OSI_ENVIRONMENT_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x15osi_environment.proto\x12\x04osi3\x1a\x10osi_common.proto"\x8e\x13\n\x17EnvironmentalConditions\x12d\n\x14ambient_illumination\x18\x01 \x01(\x0e21.osi3.EnvironmentalConditions.AmbientIlluminationR\x13ambientIllumination\x12G\n\x0btime_of_day\x18\x02 \x01(\x0b2\'.osi3.EnvironmentalConditions.TimeOfDayR\ttimeOfDay\x12%\n\x0eunix_timestamp\x18\x08 \x01(\x03R\runixTimestamp\x121\n\x14atmospheric_pressure\x18\x03 \x01(\x01R\x13atmosphericPressure\x12 \n\x0btemperature\x18\x04 \x01(\x01R\x0btemperature\x12+\n\x11relative_humidity\x18\x05 \x01(\x01R\x10relativeHumidity\x12Q\n\rprecipitation\x18\x06 \x01(\x0e2+.osi3.EnvironmentalConditions.PrecipitationR\rprecipitation\x123\n\x03fog\x18\x07 \x01(\x0e2!.osi3.EnvironmentalConditions.FogR\x03fog\x12B\n\x10source_reference\x18\t \x03(\x0b2\x17.osi3.ExternalReferenceR\x0fsourceReference\x12@\n\x06clouds\x18\n \x01(\x0b2(.osi3.EnvironmentalConditions.CloudLayerR\x06clouds\x126\n\x04wind\x18\x0b \x01(\x0b2".osi3.EnvironmentalConditions.WindR\x04wind\x123\n\x03sun\x18\x0c \x01(\x0b2!.osi3.EnvironmentalConditions.SunR\x03sun\x1aA\n\tTimeOfDay\x124\n\x16seconds_since_midnight\x18\x01 \x01(\rR\x14secondsSinceMidnight\x1a\xe6\x04\n\nCloudLayer\x12s\n\x16fractional_cloud_cover\x18\x01 \x01(\x0e2=.osi3.EnvironmentalConditions.CloudLayer.FractionalCloudCoverR\x14fractionalCloudCover"\xe2\x03\n\x14FractionalCloudCover\x12 \n\x1eFRACTIONAL_CLOUD_COVER_UNKNOWN\x12 \n\x1cFRACTIONAL_CLOUD_COVER_OTHER\x10\x01\x12%\n!FRACTIONAL_CLOUD_COVER_ZERO_OKTAS\x10\x02\x12$\n FRACTIONAL_CLOUD_COVER_ONE_OKTAS\x10\x03\x12$\n FRACTIONAL_CLOUD_COVER_TWO_OKTAS\x10\x04\x12&\n"FRACTIONAL_CLOUD_COVER_THREE_OKTAS\x10\x05\x12%\n!FRACTIONAL_CLOUD_COVER_FOUR_OKTAS\x10\x06\x12%\n!FRACTIONAL_CLOUD_COVER_FIVE_OKTAS\x10\x07\x12$\n FRACTIONAL_CLOUD_COVER_SIX_OKTAS\x10\x08\x12&\n"FRACTIONAL_CLOUD_COVER_SEVEN_OKTAS\x10\t\x12&\n"FRACTIONAL_CLOUD_COVER_EIGHT_OKTAS\x10\n\x12\'\n#FRACTIONAL_CLOUD_COVER_SKY_OBSCURED\x10\x0b\x1aG\n\x04Wind\x12)\n\x10origin_direction\x18\x01 \x01(\x01R\x0foriginDirection\x12\x14\n\x05speed\x18\x02 \x01(\x01R\x05speed\x1a[\n\x03Sun\x12\x18\n\x07azimuth\x18\x01 \x01(\x01R\x07azimuth\x12\x1c\n\televation\x18\x02 \x01(\x01R\televation\x12\x1c\n\tintensity\x18\x03 \x01(\x01R\tintensity"\xfe\x01\n\rPrecipitation\x12\x17\n\x15PRECIPITATION_UNKNOWN\x12\x17\n\x13PRECIPITATION_OTHER\x10\x01\x12\x16\n\x12PRECIPITATION_NONE\x10\x02\x12\x1c\n\x18PRECIPITATION_VERY_LIGHT\x10\x03\x12\x17\n\x13PRECIPITATION_LIGHT\x10\x04\x12\x1a\n\x16PRECIPITATION_MODERATE\x10\x05\x12\x17\n\x13PRECIPITATION_HEAVY\x10\x06\x12\x1c\n\x18PRECIPITATION_VERY_HEAVY\x10\x07\x12\x19\n\x15PRECIPITATION_EXTREME\x10\x08"\xcb\x01\n\x03Fog\x12\r\n\x0bFOG_UNKNOWN\x12\r\n\tFOG_OTHER\x10\x01\x12\x1c\n\x18FOG_EXCELLENT_VISIBILITY\x10\x02\x12\x17\n\x13FOG_GOOD_VISIBILITY\x10\x03\x12\x1b\n\x17FOG_MODERATE_VISIBILITY\x10\x04\x12\x17\n\x13FOG_POOR_VISIBILITY\x10\x05\x12\x0c\n\x08FOG_MIST\x10\x06\x12\r\n\tFOG_LIGHT\x10\x07\x12\r\n\tFOG_THICK\x10\x08\x12\r\n\tFOG_DENSE\x10\t"\xfe\x02\n\x13AmbientIllumination\x12\x1e\n\x1cAMBIENT_ILLUMINATION_UNKNOWN\x12\x1e\n\x1aAMBIENT_ILLUMINATION_OTHER\x10\x01\x12\x1f\n\x1bAMBIENT_ILLUMINATION_LEVEL1\x10\x02\x12\x1f\n\x1bAMBIENT_ILLUMINATION_LEVEL2\x10\x03\x12\x1f\n\x1bAMBIENT_ILLUMINATION_LEVEL3\x10\x04\x12\x1f\n\x1bAMBIENT_ILLUMINATION_LEVEL4\x10\x05\x12\x1f\n\x1bAMBIENT_ILLUMINATION_LEVEL5\x10\x06\x12\x1f\n\x1bAMBIENT_ILLUMINATION_LEVEL6\x10\x07\x12\x1f\n\x1bAMBIENT_ILLUMINATION_LEVEL7\x10\x08\x12\x1f\n\x1bAMBIENT_ILLUMINATION_LEVEL8\x10\t\x12\x1f\n\x1bAMBIENT_ILLUMINATION_LEVEL9\x10\nB\x02H\x01'
)
OSI_LANE_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x0eosi_lane.proto\x12\x04osi3\x1a\x10osi_common.proto"\xa7\x0e\n\x04Lane\x12 \n\x02id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x02id\x12A\n\x0eclassification\x18\x02 \x01(\x0b2\x19.osi3.Lane.ClassificationR\x0eclassification\x12B\n\x10source_reference\x18\x03 \x03(\x0b2\x17.osi3.ExternalReferenceR\x0fsourceReference\x1a\xf5\x0c\n\x0eClassification\x122\n\x04type\x18\x01 \x01(\x0e2\x1e.osi3.Lane.Classification.TypeR\x04type\x12/\n\x14is_host_vehicle_lane\x18\x02 \x01(\x08R\x11isHostVehicleLane\x12.\n\ncenterline\x18\x03 \x03(\x0b2\x0e.osi3.Vector3dR\ncenterline\x12E\n\x1fcenterline_is_driving_direction\x18\x04 \x01(\x08R\x1ccenterlineIsDrivingDirection\x12C\n\x15left_adjacent_lane_id\x18\x05 \x03(\x0b2\x10.osi3.IdentifierR\x12leftAdjacentLaneId\x12E\n\x16right_adjacent_lane_id\x18\x06 \x03(\x0b2\x10.osi3.IdentifierR\x13rightAdjacentLaneId\x12H\n\x0clane_pairing\x18\x07 \x03(\x0b2%.osi3.Lane.Classification.LanePairingR\x0blanePairing\x12E\n\x16right_lane_boundary_id\x18\x08 \x03(\x0b2\x10.osi3.IdentifierR\x13rightLaneBoundaryId\x12C\n\x15left_lane_boundary_id\x18\t \x03(\x0b2\x10.osi3.IdentifierR\x12leftLaneBoundaryId\x12C\n\x15free_lane_boundary_id\x18\n \x03(\x0b2\x10.osi3.IdentifierR\x12freeLaneBoundaryId\x12N\n\x0eroad_condition\x18\x0b \x01(\x0b2\'.osi3.Lane.Classification.RoadConditionR\rroadCondition\x12;\n\x07subtype\x18\x0c \x01(\x0e2!.osi3.Lane.Classification.SubtypeR\x07subtype\x1a\x9b\x02\n\rRoadCondition\x12/\n\x13surface_temperature\x18\x01 \x01(\x01R\x12surfaceTemperature\x12,\n\x12surface_water_film\x18\x02 \x01(\x01R\x10surfaceWaterFilm\x124\n\x16surface_freezing_point\x18\x03 \x01(\x01R\x14surfaceFreezingPoint\x12\x1f\n\x0bsurface_ice\x18\x04 \x01(\x01R\nsurfaceIce\x12+\n\x11surface_roughness\x18\x05 \x01(\x01R\x10surfaceRoughness\x12\'\n\x0fsurface_texture\x18\x06 \x01(\x01R\x0esurfaceTexture\x1a\x8b\x01\n\x0bLanePairing\x12>\n\x12antecessor_lane_id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x10antecessorLaneId\x12<\n\x11successor_lane_id\x18\x02 \x01(\x0b2\x10.osi3.IdentifierR\x0fsuccessorLaneId"d\n\x04Type\x12\x0e\n\x0cTYPE_UNKNOWN\x12\x0e\n\nTYPE_OTHER\x10\x01\x12\x10\n\x0cTYPE_DRIVING\x10\x02\x12\x13\n\x0fTYPE_NONDRIVING\x10\x03\x12\x15\n\x11TYPE_INTERSECTION\x10\x04"\xc0\x02\n\x07Subtype\x12\x11\n\x0fSUBTYPE_UNKNOWN\x12\x11\n\rSUBTYPE_OTHER\x10\x01\x12\x12\n\x0eSUBTYPE_NORMAL\x10\x02\x12\x12\n\x0eSUBTYPE_BIKING\x10\x03\x12\x14\n\x10SUBTYPE_SIDEWALK\x10\x04\x12\x13\n\x0fSUBTYPE_PARKING\x10\x05\x12\x10\n\x0cSUBTYPE_STOP\x10\x06\x12\x16\n\x12SUBTYPE_RESTRICTED\x10\x07\x12\x12\n\x0eSUBTYPE_BORDER\x10\x08\x12\x14\n\x10SUBTYPE_SHOULDER\x10\t\x12\x10\n\x0cSUBTYPE_EXIT\x10\n\x12\x11\n\rSUBTYPE_ENTRY\x10\x0b\x12\x12\n\x0eSUBTYPE_ONRAMP\x10\x0c\x12\x13\n\x0fSUBTYPE_OFFRAMP\x10\r\x12\x1a\n\x16SUBTYPE_CONNECTINGRAMP\x10\x0e"\xa4\n\n\x0cLaneBoundary\x12 \n\x02id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x02id\x12E\n\rboundary_line\x18\x02 \x03(\x0b2 .osi3.LaneBoundary.BoundaryPointR\x0cboundaryLine\x12I\n\x0eclassification\x18\x03 \x01(\x0b2!.osi3.LaneBoundary.ClassificationR\x0eclassification\x12B\n\x10source_reference\x18\x04 \x03(\x0b2\x17.osi3.ExternalReferenceR\x0fsourceReference\x12C\n\x11color_description\x18\x05 \x01(\x0b2\x16.osi3.ColorDescriptionR\x10colorDescription\x1a\x8b\x02\n\rBoundaryPoint\x12*\n\x08position\x18\x01 \x01(\x0b2\x0e.osi3.Vector3dR\x08position\x12\x14\n\x05width\x18\x02 \x01(\x01R\x05width\x12\x16\n\x06height\x18\x03 \x01(\x01R\x06height\x129\n\x04dash\x18\x04 \x01(\x0e2%.osi3.LaneBoundary.BoundaryPoint.DashR\x04dash"e\n\x04Dash\x12\x0e\n\x0cDASH_UNKNOWN\x12\x0e\n\nDASH_OTHER\x10\x01\x12\x0e\n\nDASH_START\x10\x02\x12\x11\n\rDASH_CONTINUE\x10\x03\x12\x0c\n\x08DASH_END\x10\x04\x12\x0c\n\x08DASH_GAP\x10\x05\x1a\xc8\x05\n\x0eClassification\x12:\n\x04type\x18\x01 \x01(\x0e2&.osi3.LaneBoundary.Classification.TypeR\x04type\x12=\n\x05color\x18\x02 \x01(\x0e2\'.osi3.LaneBoundary.Classification.ColorR\x05color\x12D\n\x15limiting_structure_id\x18\x03 \x03(\x0b2\x10.osi3.IdentifierR\x13limitingStructureId"\xc1\x02\n\x04Type\x12\x0e\n\x0cTYPE_UNKNOWN\x12\x0e\n\nTYPE_OTHER\x10\x01\x12\x10\n\x0cTYPE_NO_LINE\x10\x02\x12\x13\n\x0fTYPE_SOLID_LINE\x10\x03\x12\x14\n\x10TYPE_DASHED_LINE\x10\x04\x12\x13\n\x0fTYPE_BOTTS_DOTS\x10\x05\x12\x12\n\x0eTYPE_ROAD_EDGE\x10\x06\x12\x12\n\x0eTYPE_SNOW_EDGE\x10\x07\x12\x13\n\x0fTYPE_GRASS_EDGE\x10\x08\x12\x14\n\x10TYPE_GRAVEL_EDGE\x10\t\x12\x12\n\x0eTYPE_SOIL_EDGE\x10\n\x12\x13\n\x0fTYPE_GUARD_RAIL\x10\x0b\x12\r\n\tTYPE_CURB\x10\x0c\x12\x12\n\x0eTYPE_STRUCTURE\x10\r\x12\x10\n\x0cTYPE_BARRIER\x10\x0e\x12\x16\n\x12TYPE_SOUND_BARRIER\x10\x0f"\xb0\x01\n\x05Color\x12\x0f\n\rCOLOR_UNKNOWN\x12\x0f\n\x0bCOLOR_OTHER\x10\x01\x12\x0e\n\nCOLOR_NONE\x10\x02\x12\x0f\n\x0bCOLOR_WHITE\x10\x03\x12\x10\n\x0cCOLOR_YELLOW\x10\x04\x12\r\n\tCOLOR_RED\x10\x05\x12\x0e\n\nCOLOR_BLUE\x10\x06\x12\x0f\n\x0bCOLOR_GREEN\x10\x07\x12\x10\n\x0cCOLOR_VIOLET\x10\x08\x12\x10\n\x0cCOLOR_ORANGE\x10\tB\x02H\x01'
)
OSI_DETECTEDLANE_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x16osi_detectedlane.proto\x12\x04osi3\x1a\x0eosi_lane.proto\x1a\x18osi_detectedobject.proto\x1a\x10osi_common.proto"\xf6\x01\n\x0cDetectedLane\x120\n\x06header\x18\x01 \x01(\x0b2\x18.osi3.DetectedItemHeaderR\x06header\x12>\n\tcandidate\x18\x02 \x03(\x0b2 .osi3.DetectedLane.CandidateLaneR\tcandidate\x1at\n\rCandidateLane\x12 \n\x0bprobability\x18\x01 \x01(\x01R\x0bprobability\x12A\n\x0eclassification\x18\x02 \x01(\x0b2\x19.osi3.Lane.ClassificationR\x0eclassification"\xb7\x04\n\x14DetectedLaneBoundary\x120\n\x06header\x18\x01 \x01(\x0b2\x18.osi3.DetectedItemHeaderR\x06header\x12N\n\tcandidate\x18\x02 \x03(\x0b20.osi3.DetectedLaneBoundary.CandidateLaneBoundaryR\tcandidate\x12E\n\rboundary_line\x18\x03 \x03(\x0b2 .osi3.LaneBoundary.BoundaryPointR\x0cboundaryLine\x12N\n\x12boundary_line_rmse\x18\x04 \x03(\x0b2 .osi3.LaneBoundary.BoundaryPointR\x10boundaryLineRmse\x12:\n\x19boundary_line_confidences\x18\x05 \x03(\x01R\x17boundaryLineConfidences\x12C\n\x11color_description\x18\x06 \x01(\x0b2\x16.osi3.ColorDescriptionR\x10colorDescription\x1a\x84\x01\n\x15CandidateLaneBoundary\x12 \n\x0bprobability\x18\x01 \x01(\x01R\x0bprobability\x12I\n\x0eclassification\x18\x02 \x01(\x0b2!.osi3.LaneBoundary.ClassificationR\x0eclassificationB\x02H\x01'
)
OSI_OCCUPANT_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x12osi_occupant.proto\x12\x04osi3\x1a\x10osi_common.proto"\xdc\x06\n\x08Occupant\x12 \n\x02id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x02id\x12E\n\x0eclassification\x18\x02 \x01(\x0b2\x1d.osi3.Occupant.ClassificationR\x0eclassification\x12B\n\x10source_reference\x18\x03 \x03(\x0b2\x17.osi3.ExternalReferenceR\x0fsourceReference\x1a\xa2\x05\n\x0eClassification\x12\x1b\n\tis_driver\x18\x02 \x01(\x08R\x08isDriver\x126\n\x04seat\x18\x03 \x01(\x0e2".osi3.Occupant.Classification.SeatR\x04seat\x12X\n\x10steering_control\x18\x04 \x01(\x0e2-.osi3.Occupant.Classification.SteeringControlR\x0fsteeringControl"\xf5\x01\n\x04Seat\x12\x0e\n\x0cSEAT_UNKNOWN\x12\x0e\n\nSEAT_OTHER\x10\x01\x12\x13\n\x0fSEAT_FRONT_LEFT\x10\x02\x12\x14\n\x10SEAT_FRONT_RIGHT\x10\x03\x12\x15\n\x11SEAT_FRONT_MIDDLE\x10\x04\x12\x12\n\x0eSEAT_BACK_LEFT\x10\x05\x12\x13\n\x0fSEAT_BACK_RIGHT\x10\x06\x12\x14\n\x10SEAT_BACK_MIDDLE\x10\x07\x12\x17\n\x13SEAT_THIRD_ROW_LEFT\x10\x08\x12\x18\n\x14SEAT_THIRD_ROW_RIGHT\x10\t\x12\x19\n\x15SEAT_THIRD_ROW_MIDDLE\x10\n"\xe8\x01\n\x0fSteeringControl\x12\x1a\n\x18STEERING_CONTROL_UNKNOWN\x12\x1a\n\x16STEERING_CONTROL_OTHER\x10\x01\x12\x1c\n\x18STEERING_CONTROL_NO_HAND\x10\x02\x12\x1d\n\x19STEERING_CONTROL_ONE_HAND\x10\x03\x12\x1f\n\x1bSTEERING_CONTROL_BOTH_HANDS\x10\x04\x12\x1e\n\x1aSTEERING_CONTROL_LEFT_HAND\x10\x05\x12\x1f\n\x1bSTEERING_CONTROL_RIGHT_HAND\x10\x06B\x02H\x01'
)
OSI_DETECTEDOCCUPANT_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x1aosi_detectedoccupant.proto\x12\x04osi3\x1a\x12osi_occupant.proto\x1a\x18osi_detectedobject.proto"\x8a\x02\n\x10DetectedOccupant\x120\n\x06header\x18\x01 \x01(\x0b2\x18.osi3.DetectedItemHeaderR\x06header\x12F\n\tcandidate\x18\x02 \x03(\x0b2(.osi3.DetectedOccupant.CandidateOccupantR\tcandidate\x1a|\n\x11CandidateOccupant\x12 \n\x0bprobability\x18\x01 \x01(\x01R\x0bprobability\x12E\n\x0eclassification\x18\x02 \x01(\x0b2\x1d.osi3.Occupant.ClassificationR\x0eclassificationB\x02H\x01'
)
OSI_LOGICALLANE_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x15osi_logicallane.proto\x12\x04osi3\x1a\x10osi_common.proto\x1a\x10osi_object.proto\x1a\x15osi_trafficsign.proto"\xdb\x05\n\x13LogicalLaneBoundary\x12 \n\x02id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x02id\x12S\n\rboundary_line\x18\x02 \x03(\x0b2..osi3.LogicalLaneBoundary.LogicalBoundaryPointR\x0cboundaryLine\x12<\n\x11reference_line_id\x18\x03 \x01(\x0b2\x10.osi3.IdentifierR\x0freferenceLineId\x12B\n\x14physical_boundary_id\x18\x04 \x03(\x0b2\x10.osi3.IdentifierR\x12physicalBoundaryId\x12H\n\x0cpassing_rule\x18\x05 \x01(\x0e2%.osi3.LogicalLaneBoundary.PassingRuleR\x0bpassingRule\x12B\n\x10source_reference\x18\x06 \x03(\x0b2\x17.osi3.ExternalReferenceR\x0fsourceReference\x1a\x80\x01\n\x14LogicalBoundaryPoint\x12*\n\x08position\x18\x01 \x01(\x0b2\x0e.osi3.Vector3dR\x08position\x12\x1d\n\ns_position\x18\x02 \x01(\x01R\tsPosition\x12\x1d\n\nt_position\x18\x03 \x01(\x01R\ttPosition"\xb9\x01\n\x0bPassingRule\x12\x16\n\x14PASSING_RULE_UNKNOWN\x12\x16\n\x12PASSING_RULE_OTHER\x10\x01\x12\x1d\n\x19PASSING_RULE_NONE_ALLOWED\x10\x02\x12\x1d\n\x19PASSING_RULE_INCREASING_T\x10\x03\x12\x1d\n\x19PASSING_RULE_DECREASING_T\x10\x04\x12\x1d\n\x19PASSING_RULE_BOTH_ALLOWED\x10\x05"\xf4\x15\n\x0bLogicalLane\x12 \n\x02id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x02id\x12*\n\x04type\x18\x02 \x01(\x0e2\x16.osi3.LogicalLane.TypeR\x04type\x12B\n\x10source_reference\x18\x03 \x03(\x0b2\x17.osi3.ExternalReferenceR\x0fsourceReference\x12_\n\x17physical_lane_reference\x18\x04 \x03(\x0b2\'.osi3.LogicalLane.PhysicalLaneReferenceR\x15physicalLaneReference\x12<\n\x11reference_line_id\x18\x05 \x01(\x0b2\x10.osi3.IdentifierR\x0freferenceLineId\x12\x17\n\x07start_s\x18\x06 \x01(\x01R\x06startS\x12\x13\n\x05end_s\x18\x07 \x01(\x01R\x04endS\x12F\n\x0emove_direction\x18\x08 \x01(\x0e2\x1f.osi3.LogicalLane.MoveDirectionR\rmoveDirection\x12N\n\x13right_adjacent_lane\x18\t \x03(\x0b2\x1e.osi3.LogicalLane.LaneRelationR\x11rightAdjacentLane\x12L\n\x12left_adjacent_lane\x18\n \x03(\x0b2\x1e.osi3.LogicalLane.LaneRelationR\x10leftAdjacentLane\x12I\n\x10overlapping_lane\x18\x0b \x03(\x0b2\x1e.osi3.LogicalLane.LaneRelationR\x0foverlappingLane\x12<\n\x11right_boundary_id\x18\x0c \x03(\x0b2\x10.osi3.IdentifierR\x0frightBoundaryId\x12:\n\x10left_boundary_id\x18\r \x03(\x0b2\x10.osi3.IdentifierR\x0eleftBoundaryId\x12K\n\x10predecessor_lane\x18\x0e \x03(\x0b2 .osi3.LogicalLane.LaneConnectionR\x0fpredecessorLane\x12G\n\x0esuccessor_lane\x18\x0f \x03(\x0b2 .osi3.LogicalLane.LaneConnectionR\rsuccessorLane\x12\x1f\n\x0bstreet_name\x18\x10 \x01(\tR\nstreetName\x12@\n\x0ctraffic_rule\x18\x11 \x03(\x0b2\x1d.osi3.LogicalLane.TrafficRuleR\x0btrafficRule\x1a\x81\x01\n\x15PhysicalLaneReference\x12:\n\x10physical_lane_id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x0ephysicalLaneId\x12\x17\n\x07start_s\x18\x02 \x01(\x01R\x06startS\x12\x13\n\x05end_s\x18\x03 \x01(\x01R\x04endS\x1az\n\x0eLaneConnection\x124\n\rother_lane_id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x0botherLaneId\x122\n\x16at_begin_of_other_lane\x18\x02 \x01(\x08R\x12atBeginOfOtherLane\x1a\xb6\x01\n\x0cLaneRelation\x124\n\rother_lane_id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x0botherLaneId\x12\x17\n\x07start_s\x18\x02 \x01(\x01R\x06startS\x12\x13\n\x05end_s\x18\x03 \x01(\x01R\x04endS\x12"\n\rstart_s_other\x18\x04 \x01(\x01R\x0bstartSOther\x12\x1e\n\x0bend_s_other\x18\x05 \x01(\x01R\tendSOther\x1a\xae\x06\n\x0bTrafficRule\x12Y\n\x11traffic_rule_type\x18\x01 \x01(\x0e2-.osi3.LogicalLane.TrafficRule.TrafficRuleTypeR\x0ftrafficRuleType\x12e\n\x15traffic_rule_validity\x18\x02 \x01(\x0b21.osi3.LogicalLane.TrafficRule.TrafficRuleValidityR\x13trafficRuleValidity\x12I\n\x0bspeed_limit\x18\x03 \x01(\x0b2(.osi3.LogicalLane.TrafficRule.SpeedLimitR\nspeedLimit\x1a\x8b\x03\n\x13TrafficRuleValidity\x12\x17\n\x07start_s\x18\x01 \x01(\x01R\x06startS\x12\x13\n\x05end_s\x18\x02 \x01(\x01R\x04endS\x12d\n\x0evalid_for_type\x18\x03 \x03(\x0b2>.osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidityR\x0cvalidForType\x1a\xdf\x01\n\x0cTypeValidity\x12+\n\x04type\x18\x01 \x01(\x0e2\x17.osi3.MovingObject.TypeR\x04type\x12P\n\x0cvehicle_type\x18\x02 \x01(\x0e2-.osi3.MovingObject.VehicleClassification.TypeR\x0bvehicleType\x12P\n\x0cvehicle_role\x18\x03 \x01(\x0e2-.osi3.MovingObject.VehicleClassification.RoleR\x0bvehicleRole\x1aP\n\nSpeedLimit\x12B\n\x11speed_limit_value\x18\x01 \x01(\x0b2\x16.osi3.TrafficSignValueR\x0fspeedLimitValue"2\n\x0fTrafficRuleType\x12\x1f\n\x1dTRAFFIC_RULE_TYPE_SPEED_LIMIT"\xce\x02\n\x04Type\x12\x0e\n\x0cTYPE_UNKNOWN\x12\x0e\n\nTYPE_OTHER\x10\x01\x12\x0f\n\x0bTYPE_NORMAL\x10\x02\x12\x0f\n\x0bTYPE_BIKING\x10\x03\x12\x11\n\rTYPE_SIDEWALK\x10\x04\x12\x10\n\x0cTYPE_PARKING\x10\x05\x12\r\n\tTYPE_STOP\x10\x06\x12\x13\n\x0fTYPE_RESTRICTED\x10\x07\x12\x0f\n\x0bTYPE_BORDER\x10\x08\x12\x11\n\rTYPE_SHOULDER\x10\t\x12\r\n\tTYPE_EXIT\x10\n\x12\x0e\n\nTYPE_ENTRY\x10\x0b\x12\x0f\n\x0bTYPE_ONRAMP\x10\x0c\x12\x10\n\x0cTYPE_OFFRAMP\x10\r\x12\x17\n\x13TYPE_CONNECTINGRAMP\x10\x0e\x12\x0f\n\x0bTYPE_MEDIAN\x10\x0f\x12\r\n\tTYPE_CURB\x10\x10\x12\r\n\tTYPE_RAIL\x10\x11\x12\r\n\tTYPE_TRAM\x10\x12"\xa6\x01\n\rMoveDirection\x12\x18\n\x16MOVE_DIRECTION_UNKNOWN\x12\x18\n\x14MOVE_DIRECTION_OTHER\x10\x01\x12\x1f\n\x1bMOVE_DIRECTION_INCREASING_S\x10\x02\x12\x1f\n\x1bMOVE_DIRECTION_DECREASING_S\x10\x03\x12\x1f\n\x1bMOVE_DIRECTION_BOTH_ALLOWED\x10\x04B\x02H\x01'
)
OSI_REFERENCELINE_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x17osi_referenceline.proto\x12\x04osi3\x1a\x10osi_common.proto"\xe7\x02\n\rReferenceLine\x12 \n\x02id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x02id\x12,\n\x04type\x18\x03 \x01(\x0e2\x18.osi3.ReferenceLine.TypeR\x04type\x12C\n\tpoly_line\x18\x02 \x03(\x0b2&.osi3.ReferenceLine.ReferenceLinePointR\x08polyLine\x1a\x88\x01\n\x12ReferenceLinePoint\x125\n\x0eworld_position\x18\x01 \x01(\x0b2\x0e.osi3.Vector3dR\rworldPosition\x12\x1d\n\ns_position\x18\x02 \x01(\x01R\tsPosition\x12\x1c\n\nt_axis_yaw\x18\x03 \x01(\x01R\x08tAxisYaw"6\n\x04Type\x12\x0f\n\rTYPE_POLYLINE\x12\x1d\n\x19TYPE_POLYLINE_WITH_T_AXIS\x10\x01B\x02H\x01'
)
OSI_GROUNDTRUTH_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b"\n\x15osi_groundtruth.proto\x12\x04osi3\x1a\x11osi_version.proto\x1a\x10osi_common.proto\x1a\x15osi_environment.proto\x1a\x15osi_trafficsign.proto\x1a\x16osi_trafficlight.proto\x1a\x15osi_roadmarking.proto\x1a\x0eosi_lane.proto\x1a\x15osi_logicallane.proto\x1a\x17osi_referenceline.proto\x1a\x10osi_object.proto\x1a\x12osi_occupant.proto\"\x9d\t\n\x0bGroundTruth\x120\n\x07version\x18\x01 \x01(\x0b2\x16.osi3.InterfaceVersionR\x07version\x12-\n\ttimestamp\x18\x02 \x01(\x0b2\x0f.osi3.TimestampR\ttimestamp\x128\n\x0fhost_vehicle_id\x18\x03 \x01(\x0b2\x10.osi3.IdentifierR\rhostVehicleId\x12C\n\x11stationary_object\x18\x04 \x03(\x0b2\x16.osi3.StationaryObjectR\x10stationaryObject\x127\n\rmoving_object\x18\x05 \x03(\x0b2\x12.osi3.MovingObjectR\x0cmovingObject\x124\n\x0ctraffic_sign\x18\x06 \x03(\x0b2\x11.osi3.TrafficSignR\x0btrafficSign\x127\n\rtraffic_light\x18\x07 \x03(\x0b2\x12.osi3.TrafficLightR\x0ctrafficLight\x124\n\x0croad_marking\x18\x08 \x03(\x0b2\x11.osi3.RoadMarkingR\x0broadMarking\x127\n\rlane_boundary\x18\t \x03(\x0b2\x12.osi3.LaneBoundaryR\x0claneBoundary\x12\x1e\n\x04lane\x18\n \x03(\x0b2\n.osi3.LaneR\x04lane\x12*\n\x08occupant\x18\x0b \x03(\x0b2\x0e.osi3.OccupantR\x08occupant\x12X\n\x18environmental_conditions\x18\x0c \x01(\x0b2\x1d.osi3.EnvironmentalConditionsR\x17environmentalConditions\x12!\n\x0ccountry_code\x18\r \x01(\rR\x0bcountryCode\x12\x1f\n\x0bproj_string\x18\x0e \x01(\tR\nprojString\x12#\n\rmap_reference\x18\x0f \x01(\tR\x0cmapReference\x12'\n\x0fmodel_reference\x18\x10 \x01(\tR\x0emodelReference\x12:\n\x0ereference_line\x18\x11 \x03(\x0b2\x13.osi3.ReferenceLineR\rreferenceLine\x12M\n\x15logical_lane_boundary\x18\x12 \x03(\x0b2\x19.osi3.LogicalLaneBoundaryR\x13logicalLaneBoundary\x124\n\x0clogical_lane\x18\x13 \x03(\x0b2\x11.osi3.LogicalLaneR\x0blogicalLane\x12M\n\x11proj_frame_offset\x18\x14 \x01(\x0b2!.osi3.GroundTruth.ProjFrameOffsetR\x0fprojFrameOffset\x1aO\n\x0fProjFrameOffset\x12*\n\x08position\x18\x01 \x01(\x0b2\x0e.osi3.Vector3dR\x08position\x12\x10\n\x03yaw\x18\x02 \x01(\x01R\x03yawB\x02H\x01"
)
OSI_SENSORVIEWCONFIGURATION_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n!osi_sensorviewconfiguration.proto\x12\x04osi3\x1a\x10osi_common.proto\x1a\x11osi_version.proto"\xc0\t\n\x17SensorViewConfiguration\x120\n\x07version\x18\x01 \x01(\x0b2\x16.osi3.InterfaceVersionR\x07version\x12-\n\tsensor_id\x18\x02 \x01(\x0b2\x10.osi3.IdentifierR\x08sensorId\x12C\n\x11mounting_position\x18\x03 \x01(\x0b2\x16.osi3.MountingPositionR\x10mountingPosition\x12L\n\x16mounting_position_rmse\x18\x04 \x01(\x0b2\x16.osi3.MountingPositionR\x14mountingPositionRmse\x127\n\x18field_of_view_horizontal\x18\x05 \x01(\x01R\x15fieldOfViewHorizontal\x123\n\x16field_of_view_vertical\x18\x06 \x01(\x01R\x13fieldOfViewVertical\x12\x14\n\x05range\x18\x07 \x01(\x01R\x05range\x12;\n\x11update_cycle_time\x18\x08 \x01(\x0b2\x0f.osi3.TimestampR\x0fupdateCycleTime\x12?\n\x13update_cycle_offset\x18\t \x01(\x0b2\x0f.osi3.TimestampR\x11updateCycleOffset\x12C\n\x15simulation_start_time\x18\n \x01(\x0b2\x0f.osi3.TimestampR\x13simulationStartTime\x126\n\x17omit_static_information\x18\x0b \x01(\x08R\x15omitStaticInformation\x12p\n!generic_sensor_view_configuration\x18\xe8\x07 \x03(\x0b2$.osi3.GenericSensorViewConfigurationR\x1egenericSensorViewConfiguration\x12j\n\x1fradar_sensor_view_configuration\x18\xe9\x07 \x03(\x0b2".osi3.RadarSensorViewConfigurationR\x1cradarSensorViewConfiguration\x12j\n\x1flidar_sensor_view_configuration\x18\xea\x07 \x03(\x0b2".osi3.LidarSensorViewConfigurationR\x1clidarSensorViewConfiguration\x12m\n camera_sensor_view_configuration\x18\xeb\x07 \x03(\x0b2#.osi3.CameraSensorViewConfigurationR\x1dcameraSensorViewConfiguration\x12y\n$ultrasonic_sensor_view_configuration\x18\xec\x07 \x03(\x0b2\'.osi3.UltrasonicSensorViewConfigurationR!ultrasonicSensorViewConfiguration"\xd0\x02\n\x1eGenericSensorViewConfiguration\x12-\n\tsensor_id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x08sensorId\x12C\n\x11mounting_position\x18\x02 \x01(\x0b2\x16.osi3.MountingPositionR\x10mountingPosition\x12L\n\x16mounting_position_rmse\x18\x03 \x01(\x0b2\x16.osi3.MountingPositionR\x14mountingPositionRmse\x127\n\x18field_of_view_horizontal\x18\x04 \x01(\x01R\x15fieldOfViewHorizontal\x123\n\x16field_of_view_vertical\x18\x05 \x01(\x01R\x13fieldOfViewVertical"\xfc\x06\n\x1cRadarSensorViewConfiguration\x12-\n\tsensor_id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x08sensorId\x12C\n\x11mounting_position\x18\x02 \x01(\x0b2\x16.osi3.MountingPositionR\x10mountingPosition\x12L\n\x16mounting_position_rmse\x18\x03 \x01(\x0b2\x16.osi3.MountingPositionR\x14mountingPositionRmse\x127\n\x18field_of_view_horizontal\x18\x04 \x01(\x01R\x15fieldOfViewHorizontal\x123\n\x16field_of_view_vertical\x18\x05 \x01(\x01R\x13fieldOfViewVertical\x129\n\x19number_of_rays_horizontal\x18\x06 \x01(\rR\x16numberOfRaysHorizontal\x125\n\x17number_of_rays_vertical\x18\x07 \x01(\rR\x14numberOfRaysVertical\x12;\n\x1amax_number_of_interactions\x18\x08 \x01(\rR\x17maxNumberOfInteractions\x12+\n\x11emitter_frequency\x18\t \x01(\x01R\x10emitterFrequency\x12d\n\x12tx_antenna_diagram\x18\n \x03(\x0b26.osi3.RadarSensorViewConfiguration.AntennaDiagramEntryR\x10txAntennaDiagram\x12d\n\x12rx_antenna_diagram\x18\x0b \x03(\x0b26.osi3.RadarSensorViewConfiguration.AntennaDiagramEntryR\x10rxAntennaDiagram\x1a\x83\x01\n\x13AntennaDiagramEntry\x12)\n\x10horizontal_angle\x18\x01 \x01(\x01R\x0fhorizontalAngle\x12%\n\x0evertical_angle\x18\x02 \x01(\x01R\rverticalAngle\x12\x1a\n\x08response\x18\x03 \x01(\x01R\x08response"\x98\x05\n\x1cLidarSensorViewConfiguration\x12-\n\tsensor_id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x08sensorId\x12C\n\x11mounting_position\x18\x02 \x01(\x0b2\x16.osi3.MountingPositionR\x10mountingPosition\x12L\n\x16mounting_position_rmse\x18\x03 \x01(\x0b2\x16.osi3.MountingPositionR\x14mountingPositionRmse\x127\n\x18field_of_view_horizontal\x18\x04 \x01(\x01R\x15fieldOfViewHorizontal\x123\n\x16field_of_view_vertical\x18\x05 \x01(\x01R\x13fieldOfViewVertical\x129\n\x19number_of_rays_horizontal\x18\x06 \x01(\rR\x16numberOfRaysHorizontal\x125\n\x17number_of_rays_vertical\x18\x07 \x01(\rR\x14numberOfRaysVertical\x12;\n\x1amax_number_of_interactions\x18\x08 \x01(\rR\x17maxNumberOfInteractions\x12+\n\x11emitter_frequency\x18\t \x01(\x01R\x10emitterFrequency\x12"\n\rnum_of_pixels\x18\n \x01(\rR\x0bnumOfPixels\x12.\n\ndirections\x18\x0b \x03(\x0b2\x0e.osi3.Vector3dR\ndirections\x12\x18\n\x07timings\x18\x0c \x03(\rR\x07timings"\xab\x0e\n\x1dCameraSensorViewConfiguration\x12-\n\tsensor_id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x08sensorId\x12C\n\x11mounting_position\x18\x02 \x01(\x0b2\x16.osi3.MountingPositionR\x10mountingPosition\x12L\n\x16mounting_position_rmse\x18\x03 \x01(\x0b2\x16.osi3.MountingPositionR\x14mountingPositionRmse\x127\n\x18field_of_view_horizontal\x18\x04 \x01(\x01R\x15fieldOfViewHorizontal\x123\n\x16field_of_view_vertical\x18\x05 \x01(\x01R\x13fieldOfViewVertical\x12=\n\x1bnumber_of_pixels_horizontal\x18\x06 \x01(\rR\x18numberOfPixelsHorizontal\x129\n\x19number_of_pixels_vertical\x18\x07 \x01(\rR\x16numberOfPixelsVertical\x12X\n\x0echannel_format\x18\x08 \x03(\x0e21.osi3.CameraSensorViewConfiguration.ChannelFormatR\rchannelFormat\x12*\n\x11samples_per_pixel\x18\t \x01(\rR\x0fsamplesPerPixel\x12;\n\x1amax_number_of_interactions\x18\n \x01(\rR\x17maxNumberOfInteractions\x12=\n\x0fwavelength_data\x18\x0b \x03(\x0b2\x14.osi3.WavelengthDataR\x0ewavelengthData\x12O\n\x0bpixel_order\x18\x0c \x01(\x0e2..osi3.CameraSensorViewConfiguration.PixelOrderR\npixelOrder"\x88\x01\n\nPixelOrder\x12\x15\n\x13PIXEL_ORDER_DEFAULT\x12\x15\n\x11PIXEL_ORDER_OTHER\x10\x01\x12%\n!PIXEL_ORDER_RIGHT_LEFT_TOP_BOTTOM\x10\x02\x12%\n!PIXEL_ORDER_LEFT_RIGHT_BOTTOM_TOP\x10\x03"\x81\x07\n\rChannelFormat\x12\x18\n\x16CHANNEL_FORMAT_UNKNOWN\x12\x18\n\x14CHANNEL_FORMAT_OTHER\x10\x01\x12\x1e\n\x1aCHANNEL_FORMAT_MONO_U8_LIN\x10\x02\x12\x1f\n\x1bCHANNEL_FORMAT_MONO_U16_LIN\x10\x03\x12\x1f\n\x1bCHANNEL_FORMAT_MONO_U32_LIN\x10\x04\x12\x1f\n\x1bCHANNEL_FORMAT_MONO_F32_LIN\x10\x05\x12\x1d\n\x19CHANNEL_FORMAT_RGB_U8_LIN\x10\x06\x12\x1e\n\x1aCHANNEL_FORMAT_RGB_U16_LIN\x10\x07\x12\x1e\n\x1aCHANNEL_FORMAT_RGB_U32_LIN\x10\x08\x12\x1e\n\x1aCHANNEL_FORMAT_RGB_F32_LIN\x10\t\x12$\n CHANNEL_FORMAT_BAYER_BGGR_U8_LIN\x10\n\x12%\n!CHANNEL_FORMAT_BAYER_BGGR_U16_LIN\x10\x0b\x12%\n!CHANNEL_FORMAT_BAYER_BGGR_U32_LIN\x10\x0c\x12%\n!CHANNEL_FORMAT_BAYER_BGGR_F32_LIN\x10\r\x12$\n CHANNEL_FORMAT_BAYER_RGGB_U8_LIN\x10\x0e\x12%\n!CHANNEL_FORMAT_BAYER_RGGB_U16_LIN\x10\x0f\x12%\n!CHANNEL_FORMAT_BAYER_RGGB_U32_LIN\x10\x10\x12%\n!CHANNEL_FORMAT_BAYER_RGGB_F32_LIN\x10\x11\x12\x1e\n\x1aCHANNEL_FORMAT_RCCC_U8_LIN\x10\x12\x12\x1f\n\x1bCHANNEL_FORMAT_RCCC_U16_LIN\x10\x13\x12\x1f\n\x1bCHANNEL_FORMAT_RCCC_U32_LIN\x10\x14\x12\x1f\n\x1bCHANNEL_FORMAT_RCCC_F32_LIN\x10\x15\x12\x1e\n\x1aCHANNEL_FORMAT_RCCB_U8_LIN\x10\x16\x12\x1f\n\x1bCHANNEL_FORMAT_RCCB_U16_LIN\x10\x17\x12\x1f\n\x1bCHANNEL_FORMAT_RCCB_U32_LIN\x10\x18\x12\x1f\n\x1bCHANNEL_FORMAT_RCCB_F32_LIN\x10\x19"\xd3\x02\n!UltrasonicSensorViewConfiguration\x12-\n\tsensor_id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x08sensorId\x12C\n\x11mounting_position\x18\x02 \x01(\x0b2\x16.osi3.MountingPositionR\x10mountingPosition\x12L\n\x16mounting_position_rmse\x18\x03 \x01(\x0b2\x16.osi3.MountingPositionR\x14mountingPositionRmse\x127\n\x18field_of_view_horizontal\x18\x04 \x01(\x01R\x15fieldOfViewHorizontal\x123\n\x16field_of_view_vertical\x18\x05 \x01(\x01R\x13fieldOfViewVerticalB\x02H\x01'
)
OSI_HOSTVEHICLEDATA_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x19osi_hostvehicledata.proto\x12\x04osi3\x1a\x11osi_version.proto\x1a\x10osi_common.proto\x1a\x0fosi_route.proto"\xa7"\n\x0fHostVehicleData\x120\n\x07version\x18\t \x01(\x0b2\x16.osi3.InterfaceVersionR\x07version\x12-\n\ttimestamp\x18\n \x01(\x0b2\x0f.osi3.TimestampR\ttimestamp\x128\n\x0fhost_vehicle_id\x18\x0b \x01(\x0b2\x10.osi3.IdentifierR\rhostVehicleId\x12,\n\x08location\x18\x01 \x01(\x0b2\x10.osi3.BaseMovingR\x08location\x125\n\rlocation_rmse\x18\x02 \x01(\x0b2\x10.osi3.BaseMovingR\x0clocationRmse\x12J\n\x0evehicle_basics\x18\x03 \x01(\x0b2#.osi3.HostVehicleData.VehicleBasicsR\rvehicleBasics\x12V\n\x12vehicle_powertrain\x18\x04 \x01(\x0b2\'.osi3.HostVehicleData.VehiclePowertrainR\x11vehiclePowertrain\x12Z\n\x14vehicle_brake_system\x18\x05 \x01(\x0b2(.osi3.HostVehicleData.VehicleBrakeSystemR\x12vehicleBrakeSystem\x12P\n\x10vehicle_steering\x18\x06 \x01(\x0b2%.osi3.HostVehicleData.VehicleSteeringR\x0fvehicleSteering\x12J\n\x0evehicle_wheels\x18\x07 \x01(\x0b2#.osi3.HostVehicleData.VehicleWheelsR\rvehicleWheels\x12\\\n\x14vehicle_localization\x18\x08 \x01(\x0b2).osi3.HostVehicleData.VehicleLocalizationR\x13vehicleLocalization\x12\x82\x01\n"vehicle_automated_driving_function\x18\x0c \x03(\x0b25.osi3.HostVehicleData.VehicleAutomatedDrivingFunctionR\x1fvehicleAutomatedDrivingFunction\x12J\n\x0evehicle_motion\x18\r \x01(\x0b2#.osi3.HostVehicleData.VehicleMotionR\rvehicleMotion\x12!\n\x05route\x18\x0e \x01(\x0b2\x0b.osi3.RouteR\x05route\x1a\x8c\x03\n\rVehicleBasics\x12\x1f\n\x0bcurb_weight\x18\x01 \x01(\x01R\ncurbWeight\x12[\n\x0foperating_state\x18\x02 \x01(\x0e22.osi3.HostVehicleData.VehicleBasics.OperatingStateR\x0eoperatingState"\xfc\x01\n\x0eOperatingState\x12\x19\n\x17OPERATING_STATE_UNKNOWN\x12\x19\n\x15OPERATING_STATE_OTHER\x10\x01\x12\x19\n\x15OPERATING_STATE_SLEEP\x10\x02\x12\x1b\n\x17OPERATING_STATE_STANDBY\x10\x03\x12\x1c\n\x18OPERATING_STATE_BOARDING\x10\x04\x12!\n\x1dOPERATING_STATE_ENTERTAINMENT\x10\x05\x12\x1b\n\x17OPERATING_STATE_DRIVING\x10\x06\x12\x1e\n\x1aOPERATING_STATE_DIAGNOSTIC\x10\x07\x1a\xd0\x03\n\x11VehiclePowertrain\x12>\n\x1bpedal_position_acceleration\x18\x01 \x01(\x01R\x19pedalPositionAcceleration\x122\n\x15pedal_position_clutch\x18\x02 \x01(\x01R\x13pedalPositionClutch\x12+\n\x11gear_transmission\x18\x03 \x01(\x05R\x10gearTransmission\x12C\n\x05motor\x18\x04 \x03(\x0b2-.osi3.HostVehicleData.VehiclePowertrain.MotorR\x05motor\x1a\xd4\x01\n\x05Motor\x12F\n\x04type\x18\x01 \x01(\x0e22.osi3.HostVehicleData.VehiclePowertrain.Motor.TypeR\x04type\x12\x10\n\x03rpm\x18\x02 \x01(\x01R\x03rpm\x12\x16\n\x06torque\x18\x03 \x01(\x01R\x06torque"Y\n\x04Type\x12\x0e\n\x0cTYPE_UNKNOWN\x12\x0e\n\nTYPE_OTHER\x10\x01\x12\r\n\tTYPE_OTTO\x10\x02\x12\x0f\n\x0bTYPE_DIESEL\x10\x03\x12\x11\n\rTYPE_ELECTRIC\x10\x04\x1aF\n\x12VehicleBrakeSystem\x120\n\x14pedal_position_brake\x18\x01 \x01(\x01R\x12pedalPositionBrake\x1ac\n\x0fVehicleSteering\x12P\n\x16vehicle_steering_wheel\x18\x01 \x01(\x0b2\x1a.osi3.VehicleSteeringWheelR\x14vehicleSteeringWheel\x1a\xcd\x01\n\rVehicleWheels\x12L\n\nwheel_data\x18\x01 \x03(\x0b2-.osi3.HostVehicleData.VehicleWheels.WheelDataR\twheelData\x1an\n\tWheelData\x12\x12\n\x04axle\x18\x01 \x01(\rR\x04axle\x12\x14\n\x05index\x18\x02 \x01(\rR\x05index\x12#\n\rrotation_rate\x18\x03 \x01(\x01R\x0crotationRate\x12\x12\n\x04slip\x18\x04 \x01(\x01R\x04slip\x1a\xbd\x01\n\x13VehicleLocalization\x12*\n\x08position\x18\x01 \x01(\x0b2\x0e.osi3.Vector3dR\x08position\x125\n\x0borientation\x18\x02 \x01(\x0b2\x13.osi3.Orientation3dR\x0borientation\x12C\n\x11geodetic_position\x18\x03 \x01(\x0b2\x16.osi3.GeodeticPositionR\x10geodeticPosition\x1a\xbf\x02\n\rVehicleMotion\x12*\n\x08position\x18\x01 \x01(\x0b2\x0e.osi3.Vector3dR\x08position\x125\n\x0borientation\x18\x02 \x01(\x0b2\x13.osi3.Orientation3dR\x0borientation\x12*\n\x08velocity\x18\x03 \x01(\x0b2\x0e.osi3.Vector3dR\x08velocity\x12>\n\x10orientation_rate\x18\x04 \x01(\x0b2\x13.osi3.Orientation3dR\x0forientationRate\x122\n\x0cacceleration\x18\x05 \x01(\x0b2\x0e.osi3.Vector3dR\x0cacceleration\x12+\n\x11current_curvature\x18\x06 \x01(\x01R\x10currentCurvature\x1a\xc2\x0c\n\x1fVehicleAutomatedDrivingFunction\x12N\n\x04name\x18\x01 \x01(\x0e2:.osi3.HostVehicleData.VehicleAutomatedDrivingFunction.NameR\x04name\x12\x1f\n\x0bcustom_name\x18\x02 \x01(\tR\ncustomName\x12Q\n\x05state\x18\x03 \x01(\x0e2;.osi3.HostVehicleData.VehicleAutomatedDrivingFunction.StateR\x05state\x12!\n\x0ccustom_state\x18\x04 \x01(\tR\x0bcustomState\x12m\n\x0fdriver_override\x18\x05 \x01(\x0b2D.osi3.HostVehicleData.VehicleAutomatedDrivingFunction.DriverOverrideR\x0edriverOverride\x127\n\rcustom_detail\x18\x06 \x03(\x0b2\x12.osi3.KeyValuePairR\x0ccustomDetail\x1a\xd9\x01\n\x0eDriverOverride\x12\x16\n\x06active\x18\x01 \x01(\x08R\x06active\x12t\n\x0foverride_reason\x18\x02 \x03(\x0e2K.osi3.HostVehicleData.VehicleAutomatedDrivingFunction.DriverOverride.ReasonR\x0eoverrideReason"9\n\x06Reason\x12\x14\n\x12REASON_BRAKE_PEDAL\x12\x19\n\x15REASON_STEERING_INPUT\x10\x01"\xa3\x06\n\x04Name\x12\x0e\n\x0cNAME_UNKNOWN\x12\x0e\n\nNAME_OTHER\x10\x01\x12\x1b\n\x17NAME_BLIND_SPOT_WARNING\x10\x02\x12"\n\x1eNAME_FORWARD_COLLISION_WARNING\x10\x03\x12\x1f\n\x1bNAME_LANE_DEPARTURE_WARNING\x10\x04\x12"\n\x1eNAME_PARKING_COLLISION_WARNING\x10\x05\x12#\n\x1fNAME_REAR_CROSS_TRAFFIC_WARNING\x10\x06\x12$\n NAME_AUTOMATIC_EMERGENCY_BRAKING\x10\x07\x12%\n!NAME_AUTOMATIC_EMERGENCY_STEERING\x10\x08\x12,\n(NAME_REVERSE_AUTOMATIC_EMERGENCY_BRAKING\x10\t\x12 \n\x1cNAME_ADAPTIVE_CRUISE_CONTROL\x10\n\x12\x1c\n\x18NAME_LANE_KEEPING_ASSIST\x10\x0b\x12"\n\x1eNAME_ACTIVE_DRIVING_ASSISTANCE\x10\x0c\x12\x16\n\x12NAME_BACKUP_CAMERA\x10\r\x12\x1d\n\x19NAME_SURROUND_VIEW_CAMERA\x10\x0e\x12"\n\x1eNAME_ACTIVE_PARKING_ASSISTANCE\x10\x0f\x12"\n\x1eNAME_REMOTE_PARKING_ASSISTANCE\x10\x10\x12\x1b\n\x17NAME_TRAILER_ASSISTANCE\x10\x11\x12\x1d\n\x19NAME_AUTOMATIC_HIGH_BEAMS\x10\x12\x12\x1a\n\x16NAME_DRIVER_MONITORING\x10\x13\x12\x18\n\x14NAME_HEAD_UP_DISPLAY\x10\x14\x12\x15\n\x11NAME_NIGHT_VISION\x10\x15\x12\x16\n\x12NAME_URBAN_DRIVING\x10\x16\x12\x1a\n\x16NAME_HIGHWAY_AUTOPILOT\x10\x17\x12\x17\n\x13NAME_CRUISE_CONTROL\x10\x18\x12\x1c\n\x18NAME_SPEED_LIMIT_CONTROL\x10\x19"\x8d\x01\n\x05State\x12\x0f\n\rSTATE_UNKNOWN\x12\x0f\n\x0bSTATE_OTHER\x10\x01\x12\x11\n\rSTATE_ERRORED\x10\x02\x12\x15\n\x11STATE_UNAVAILABLE\x10\x03\x12\x13\n\x0fSTATE_AVAILABLE\x10\x04\x12\x11\n\rSTATE_STANDBY\x10\x05\x12\x10\n\x0cSTATE_ACTIVE\x10\x06B\x02H\x01'
)
OSI_SENSORVIEW_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x14osi_sensorview.proto\x12\x04osi3\x1a\x11osi_version.proto\x1a\x10osi_common.proto\x1a\x15osi_groundtruth.proto\x1a!osi_sensorviewconfiguration.proto\x1a\x19osi_hostvehicledata.proto"\xdb\x06\n\nSensorView\x120\n\x07version\x18\x01 \x01(\x0b2\x16.osi3.InterfaceVersionR\x07version\x12-\n\ttimestamp\x18\x02 \x01(\x0b2\x0f.osi3.TimestampR\ttimestamp\x12-\n\tsensor_id\x18\x03 \x01(\x0b2\x10.osi3.IdentifierR\x08sensorId\x12C\n\x11mounting_position\x18\x04 \x01(\x0b2\x16.osi3.MountingPositionR\x10mountingPosition\x12L\n\x16mounting_position_rmse\x18\x05 \x01(\x0b2\x16.osi3.MountingPositionR\x14mountingPositionRmse\x12A\n\x11host_vehicle_data\x18\x06 \x01(\x0b2\x15.osi3.HostVehicleDataR\x0fhostVehicleData\x12A\n\x13global_ground_truth\x18\x07 \x01(\x0b2\x11.osi3.GroundTruthR\x11globalGroundTruth\x128\n\x0fhost_vehicle_id\x18\x08 \x01(\x0b2\x10.osi3.IdentifierR\rhostVehicleId\x12H\n\x13generic_sensor_view\x18\xe8\x07 \x03(\x0b2\x17.osi3.GenericSensorViewR\x11genericSensorView\x12B\n\x11radar_sensor_view\x18\xe9\x07 \x03(\x0b2\x15.osi3.RadarSensorViewR\x0fradarSensorView\x12B\n\x11lidar_sensor_view\x18\xea\x07 \x03(\x0b2\x15.osi3.LidarSensorViewR\x0flidarSensorView\x12E\n\x12camera_sensor_view\x18\xeb\x07 \x03(\x0b2\x16.osi3.CameraSensorViewR\x10cameraSensorView\x12Q\n\x16ultrasonic_sensor_view\x18\xec\x07 \x03(\x0b2\x1a.osi3.UltrasonicSensorViewR\x14ultrasonicSensorView"h\n\x11GenericSensorView\x12S\n\x12view_configuration\x18\x01 \x01(\x0b2$.osi3.GenericSensorViewConfigurationR\x11viewConfiguration"\x95\x03\n\x0fRadarSensorView\x12Q\n\x12view_configuration\x18\x01 \x01(\x0b2".osi3.RadarSensorViewConfigurationR\x11viewConfiguration\x12@\n\nreflection\x18\x02 \x03(\x0b2 .osi3.RadarSensorView.ReflectionR\nreflection\x1a\xec\x01\n\nReflection\x12\'\n\x0fsignal_strength\x18\x01 \x01(\x01R\x0esignalStrength\x12$\n\x0etime_of_flight\x18\x02 \x01(\x01R\x0ctimeOfFlight\x12#\n\rdoppler_shift\x18\x03 \x01(\x01R\x0cdopplerShift\x126\n\x17source_horizontal_angle\x18\x04 \x01(\x01R\x15sourceHorizontalAngle\x122\n\x15source_vertical_angle\x18\x05 \x01(\x01R\x13sourceVerticalAngle"\x94\x03\n\x0fLidarSensorView\x12Q\n\x12view_configuration\x18\x01 \x01(\x0b2".osi3.LidarSensorViewConfigurationR\x11viewConfiguration\x12@\n\nreflection\x18\x02 \x03(\x0b2 .osi3.LidarSensorView.ReflectionR\nreflection\x1a\xeb\x01\n\nReflection\x12\'\n\x0fsignal_strength\x18\x01 \x01(\x01R\x0esignalStrength\x12$\n\x0etime_of_flight\x18\x02 \x01(\x01R\x0ctimeOfFlight\x12#\n\rdoppler_shift\x18\x03 \x01(\x01R\x0cdopplerShift\x12:\n\x11normal_to_surface\x18\x05 \x01(\x0b2\x0e.osi3.Vector3dR\x0fnormalToSurface\x12-\n\tobject_id\x18\x06 \x01(\x0b2\x10.osi3.IdentifierR\x08objectId"\x85\x01\n\x10CameraSensorView\x12R\n\x12view_configuration\x18\x01 \x01(\x0b2#.osi3.CameraSensorViewConfigurationR\x11viewConfiguration\x12\x1d\n\nimage_data\x18\x02 \x01(\x0cR\timageData"n\n\x14UltrasonicSensorView\x12V\n\x12view_configuration\x18\x01 \x01(\x0b2\'.osi3.UltrasonicSensorViewConfigurationR\x11viewConfigurationB\x02H\x01'
)
OSI_FEATUREDATA_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x15osi_featuredata.proto\x12\x04osi3\x1a\x11osi_version.proto\x1a\x10osi_common.proto"\xc5\x02\n\x0bFeatureData\x120\n\x07version\x18\x01 \x01(\x0b2\x16.osi3.InterfaceVersionR\x07version\x12;\n\x0cradar_sensor\x18\x02 \x03(\x0b2\x18.osi3.RadarDetectionDataR\x0bradarSensor\x12;\n\x0clidar_sensor\x18\x03 \x03(\x0b2\x18.osi3.LidarDetectionDataR\x0blidarSensor\x12J\n\x11ultrasonic_sensor\x18\x04 \x03(\x0b2\x1d.osi3.UltrasonicDetectionDataR\x10ultrasonicSensor\x12>\n\rcamera_sensor\x18\x05 \x03(\x0b2\x19.osi3.CameraDetectionDataR\x0ccameraSensor"\xf2\n\n\x15SensorDetectionHeader\x12:\n\x10measurement_time\x18\x01 \x01(\x0b2\x0f.osi3.TimestampR\x0fmeasurementTime\x12#\n\rcycle_counter\x18\x02 \x01(\x04R\x0ccycleCounter\x12C\n\x11mounting_position\x18\x03 \x01(\x0b2\x16.osi3.MountingPositionR\x10mountingPosition\x12L\n\x16mounting_position_rmse\x18\x04 \x01(\x0b2\x16.osi3.MountingPositionR\x14mountingPositionRmse\x12P\n\x0edata_qualifier\x18\x05 \x01(\x0e2).osi3.SensorDetectionHeader.DataQualifierR\rdataQualifier\x12;\n\x1anumber_of_valid_detections\x18\x06 \x01(\rR\x17numberOfValidDetections\x12-\n\tsensor_id\x18\x07 \x01(\x0b2\x10.osi3.IdentifierR\x08sensorId\x12\\\n\x12extended_qualifier\x18\x08 \x01(\x0e2-.osi3.SensorDetectionHeader.ExtendedQualifierR\x11extendedQualifier"\x8b\x02\n\rDataQualifier\x12\x18\n\x16DATA_QUALIFIER_UNKNOWN\x12\x18\n\x14DATA_QUALIFIER_OTHER\x10\x01\x12\x1c\n\x18DATA_QUALIFIER_AVAILABLE\x10\x02\x12$\n DATA_QUALIFIER_AVAILABLE_REDUCED\x10\x03\x12 \n\x1cDATA_QUALIFIER_NOT_AVAILABLE\x10\x04\x12\x1c\n\x18DATA_QUALIFIER_BLINDNESS\x10\x05\x12&\n"DATA_QUALIFIER_TEMPORARY_AVAILABLE\x10\x06\x12\x1a\n\x16DATA_QUALIFIER_INVALID\x10\x07"\xba\x04\n\x11ExtendedQualifier\x12\x1c\n\x1aEXTENDED_QUALIFIER_UNKNOWN\x12\x1c\n\x18EXTENDED_QUALIFIER_OTHER\x10\x01\x12,\n(EXTENDED_QUALIFIER_NORMAL_OPERATION_MODE\x10\x02\x12\'\n#EXTENDED_QUALIFIER_POWER_UP_OR_DOWN\x10\x03\x12,\n(EXTENDED_QUALIFIER_SENSOR_NOT_CALIBRATED\x10\x04\x12%\n!EXTENDED_QUALIFIER_SENSOR_BLOCKED\x10\x05\x12(\n$EXTENDED_QUALIFIER_SENSOR_MISALIGNED\x10\x06\x129\n5EXTENDED_QUALIFIER_BAD_SENSOR_ENVIRONMENTAL_CONDITION\x10\x07\x12,\n(EXTENDED_QUALIFIER_REDUCED_FIELD_OF_VIEW\x10\x08\x12*\n&EXTENDED_QUALIFIER_INPUT_NOT_AVAILABLE\x10\t\x12&\n"EXTENDED_QUALIFIER_INTERNAL_REASON\x10\n\x12+\n\'EXTENDED_QUALIFIER_EXTERNAL_DISTURBANCE\x10\x0b\x12)\n%EXTENDED_QUALIFIER_BEGINNING_BLOCKAGE\x10\x0c"}\n\x12RadarDetectionData\x123\n\x06header\x18\x01 \x01(\x0b2\x1b.osi3.SensorDetectionHeaderR\x06header\x122\n\tdetection\x18\x02 \x03(\x0b2\x14.osi3.RadarDetectionR\tdetection"\x90\x04\n\x0eRadarDetection\x123\n\x15existence_probability\x18\x01 \x01(\x01R\x14existenceProbability\x12-\n\tobject_id\x18\x02 \x01(\x0b2\x10.osi3.IdentifierR\x08objectId\x12-\n\x08position\x18\x03 \x01(\x0b2\x11.osi3.Spherical3dR\x08position\x126\n\rposition_rmse\x18\x04 \x01(\x0b2\x11.osi3.Spherical3dR\x0cpositionRmse\x12\'\n\x0fradial_velocity\x18\x05 \x01(\x01R\x0eradialVelocity\x120\n\x14radial_velocity_rmse\x18\x06 \x01(\x01R\x12radialVelocityRmse\x12\x10\n\x03rcs\x18\x07 \x01(\x01R\x03rcs\x12\x10\n\x03snr\x18\x08 \x01(\x01R\x03snr\x128\n\x18point_target_probability\x18\t \x01(\x01R\x16pointTargetProbability\x123\n\x0cambiguity_id\x18\n \x01(\x0b2\x10.osi3.IdentifierR\x0bambiguityId\x12E\n\x0eclassification\x18\x0b \x01(\x0e2\x1d.osi3.DetectionClassificationR\x0eclassification"}\n\x12LidarDetectionData\x123\n\x06header\x18\x01 \x01(\x0b2\x1b.osi3.SensorDetectionHeaderR\x06header\x122\n\tdetection\x18\x02 \x03(\x0b2\x14.osi3.LidarDetectionR\tdetection"\xd1\x04\n\x0eLidarDetection\x123\n\x15existence_probability\x18\x01 \x01(\x01R\x14existenceProbability\x12-\n\tobject_id\x18\x02 \x01(\x0b2\x10.osi3.IdentifierR\x08objectId\x12-\n\x08position\x18\x03 \x01(\x0b2\x11.osi3.Spherical3dR\x08position\x126\n\rposition_rmse\x18\x04 \x01(\x0b2\x11.osi3.Spherical3dR\x0cpositionRmse\x12\x16\n\x06height\x18\x05 \x01(\x01R\x06height\x12\x1f\n\x0bheight_rmse\x18\x06 \x01(\x01R\nheightRmse\x12\x1c\n\tintensity\x18\x07 \x01(\x01R\tintensity\x124\n\x16free_space_probability\x18\x08 \x01(\x01R\x14freeSpaceProbability\x12E\n\x0eclassification\x18\t \x01(\x0e2\x1d.osi3.DetectionClassificationR\x0eclassification\x12"\n\x0creflectivity\x18\n \x01(\x01R\x0creflectivity\x12(\n\x10echo_pulse_width\x18\x0b \x01(\x01R\x0eechoPulseWidth\x12\'\n\x0fradial_velocity\x18\x0c \x01(\x01R\x0eradialVelocity\x12)\n\x07beam_id\x18\r \x01(\x0b2\x10.osi3.IdentifierR\x06beamId"\x8e\x01\n!UltrasonicDetectionSpecificHeader\x12\x1b\n\tmax_range\x18\x01 \x01(\x01R\x08maxRange\x12L\n#number_of_valid_indirect_detections\x18\x02 \x01(\rR\x1fnumberOfValidIndirectDetections"\xab\x02\n\x17UltrasonicDetectionData\x123\n\x06header\x18\x01 \x01(\x0b2\x1b.osi3.SensorDetectionHeaderR\x06header\x12P\n\x0fspecific_header\x18\x03 \x01(\x0b2\'.osi3.UltrasonicDetectionSpecificHeaderR\x0especificHeader\x127\n\tdetection\x18\x02 \x03(\x0b2\x19.osi3.UltrasonicDetectionR\tdetection\x12P\n\x12indirect_detection\x18\x04 \x03(\x0b2!.osi3.UltrasonicIndirectDetectionR\x11indirectDetection"\x95\x01\n\x13UltrasonicDetection\x123\n\x15existence_probability\x18\x01 \x01(\x01R\x14existenceProbability\x12-\n\tobject_id\x18\x02 \x01(\x0b2\x10.osi3.IdentifierR\x08objectId\x12\x1a\n\x08distance\x18\x03 \x01(\x01R\x08distance"\xc1\x02\n\x1bUltrasonicIndirectDetection\x123\n\x15existence_probability\x18\x01 \x01(\x01R\x14existenceProbability\x12-\n\tobject_id\x18\x02 \x01(\x0b2\x10.osi3.IdentifierR\x08objectId\x12)\n\x10ellipsoid_radial\x18\x03 \x01(\x01R\x0fellipsoidRadial\x12\'\n\x0fellipsoid_axial\x18\x04 \x01(\x01R\x0eellipsoidAxial\x121\n\x0breceiver_id\x18\x05 \x01(\x0b2\x10.osi3.IdentifierR\nreceiverId\x127\n\x0freceiver_origin\x18\x06 \x01(\x0b2\x0e.osi3.Vector3dR\x0ereceiverOrigin"T\n\x1dCameraDetectionSpecificHeader\x123\n\x16number_of_valid_points\x18\x01 \x01(\rR\x13numberOfValidPoints"\xf6\x01\n\x13CameraDetectionData\x123\n\x06header\x18\x01 \x01(\x0b2\x1b.osi3.SensorDetectionHeaderR\x06header\x12L\n\x0fspecific_header\x18\x03 \x01(\x0b2#.osi3.CameraDetectionSpecificHeaderR\x0especificHeader\x123\n\tdetection\x18\x02 \x03(\x0b2\x15.osi3.CameraDetectionR\tdetection\x12\'\n\x05point\x18\x04 \x03(\x0b2\x11.osi3.CameraPointR\x05point"\x8e\x15\n\x0fCameraDetection\x123\n\x15existence_probability\x18\x01 \x01(\x01R\x14existenceProbability\x12-\n\tobject_id\x18\x02 \x01(\x0b2\x10.osi3.IdentifierR\x08objectId\x128\n\x0ftime_difference\x18\x03 \x01(\x0b2\x0f.osi3.TimestampR\x0etimeDifference\x12N\n\x10image_shape_type\x18\x04 \x01(\x0e2$.osi3.CameraDetection.ImageShapeTypeR\x0eimageShapeType\x12F\n\x1fshape_classification_background\x18\x05 \x01(\x08R\x1dshapeClassificationBackground\x12F\n\x1fshape_classification_foreground\x18\x06 \x01(\x08R\x1dshapeClassificationForeground\x12:\n\x19shape_classification_flat\x18\x07 \x01(\x08R\x17shapeClassificationFlat\x12@\n\x1cshape_classification_upright\x18\x08 \x01(\x08R\x1ashapeClassificationUpright\x12>\n\x1bshape_classification_ground\x18\t \x01(\x08R\x19shapeClassificationGround\x128\n\x18shape_classification_sky\x18\n \x01(\x08R\x16shapeClassificationSky\x12F\n\x1fshape_classification_vegetation\x18\x0b \x01(\x08R\x1dshapeClassificationVegetation\x12:\n\x19shape_classification_road\x18\x0c \x01(\x08R\x17shapeClassificationRoad\x12P\n%shape_classification_non_driving_lane\x18\r \x01(\x08R!shapeClassificationNonDrivingLane\x12A\n\x1dshape_classification_non_road\x18\x0e \x01(\x08R\x1ashapeClassificationNonRoad\x12S\n&shape_classification_stationary_object\x18\x0f \x01(\x08R#shapeClassificationStationaryObject\x12K\n"shape_classification_moving_object\x18\x10 \x01(\x08R\x1fshapeClassificationMovingObject\x12B\n\x1dshape_classification_landmark\x18\x11 \x01(\x08R\x1bshapeClassificationLandmark\x12I\n!shape_classification_traffic_sign\x18\x12 \x01(\x08R\x1eshapeClassificationTrafficSign\x12K\n"shape_classification_traffic_light\x18\x13 \x01(\x08R\x1fshapeClassificationTrafficLight\x12I\n!shape_classification_road_marking\x18\x14 \x01(\x08R\x1eshapeClassificationRoadMarking\x12@\n\x1cshape_classification_vehicle\x18\x15 \x01(\x08R\x1ashapeClassificationVehicle\x12F\n\x1fshape_classification_pedestrian\x18\x16 \x01(\x08R\x1dshapeClassificationPedestrian\x12>\n\x1bshape_classification_animal\x18\x17 \x01(\x08R\x19shapeClassificationAnimal\x12Q\n%shape_classification_pedestrian_front\x18\x18 \x01(\x08R"shapeClassificationPedestrianFront\x12O\n$shape_classification_pedestrian_side\x18\x19 \x01(\x08R!shapeClassificationPedestrianSide\x12O\n$shape_classification_pedestrian_rear\x18\x1a \x01(\x08R!shapeClassificationPedestrianRear\x12H\n shape_classification_probability\x18\x1b \x01(\x01R\x1eshapeClassificationProbability\x121\n\x05color\x18\x1c \x01(\x0e2\x1b.osi3.CameraDetection.ColorR\x05color\x12+\n\x11color_probability\x18\x1d \x01(\x01R\x10colorProbability\x123\n\x0cambiguity_id\x18\x1e \x01(\x0b2\x10.osi3.IdentifierR\x0bambiguityId\x12*\n\x11first_point_index\x18\x1f \x01(\rR\x0ffirstPointIndex\x12(\n\x10number_of_points\x18  \x01(\rR\x0enumberOfPoints\x12C\n\x11color_description\x18! \x01(\x0b2\x16.osi3.ColorDescriptionR\x10colorDescription"\xeb\x01\n\x05Color\x12\x0f\n\rCOLOR_UNKNOWN\x12\x0f\n\x0bCOLOR_OTHER\x10\x01\x12\x0f\n\x0bCOLOR_BLACK\x10\x02\x12\x0e\n\nCOLOR_GRAY\x10\x03\x12\x0e\n\nCOLOR_GREY\x10\x03\x12\x0f\n\x0bCOLOR_WHITE\x10\x04\x12\x10\n\x0cCOLOR_YELLOW\x10\x05\x12\x10\n\x0cCOLOR_ORANGE\x10\x06\x12\r\n\tCOLOR_RED\x10\x07\x12\x10\n\x0cCOLOR_VIOLET\x10\x08\x12\x0e\n\nCOLOR_BLUE\x10\t\x12\x0f\n\x0bCOLOR_GREEN\x10\n\x12\x14\n\x10COLOR_REFLECTIVE\x10\x0b\x1a\x02\x10\x01"\xfb\x01\n\x0eImageShapeType\x12\x1a\n\x18IMAGE_SHAPE_TYPE_UNKNOWN\x12\x1a\n\x16IMAGE_SHAPE_TYPE_OTHER\x10\x01\x12\x1a\n\x16IMAGE_SHAPE_TYPE_POINT\x10\x02\x12\x18\n\x14IMAGE_SHAPE_TYPE_BOX\x10\x03\x12\x1c\n\x18IMAGE_SHAPE_TYPE_ELLIPSE\x10\x04\x12\x1c\n\x18IMAGE_SHAPE_TYPE_POLYGON\x10\x05\x12\x1d\n\x19IMAGE_SHAPE_TYPE_POLYLINE\x10\x06\x12 \n\x1cIMAGE_SHAPE_TYPE_POINT_CLOUD\x10\x07"\x9d\x01\n\x0bCameraPoint\x123\n\x15existence_probability\x18\x01 \x01(\x01R\x14existenceProbability\x12\'\n\x05point\x18\x02 \x01(\x0b2\x11.osi3.Spherical3dR\x05point\x120\n\npoint_rmse\x18\x03 \x01(\x0b2\x11.osi3.Spherical3dR\tpointRmse*\x84\x02\n\x17DetectionClassification\x12"\n DETECTION_CLASSIFICATION_UNKNOWN\x12"\n\x1eDETECTION_CLASSIFICATION_OTHER\x10\x01\x12$\n DETECTION_CLASSIFICATION_INVALID\x10\x02\x12$\n DETECTION_CLASSIFICATION_CLUTTER\x10\x03\x12)\n%DETECTION_CLASSIFICATION_OVERDRIVABLE\x10\x04\x12*\n&DETECTION_CLASSIFICATION_UNDERDRIVABLE\x10\x05B\x02H\x01'
)
OSI_LOGICALDETECTIONDATA_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x1eosi_logicaldetectiondata.proto\x12\x04osi3\x1a\x11osi_version.proto\x1a\x10osi_common.proto"\xc7\x01\n\x14LogicalDetectionData\x120\n\x07version\x18\x01 \x01(\x0b2\x16.osi3.InterfaceVersionR\x07version\x128\n\x06header\x18\x02 \x01(\x0b2 .osi3.LogicalDetectionDataHeaderR\x06header\x12C\n\x11logical_detection\x18\x03 \x03(\x0b2\x16.osi3.LogicalDetectionR\x10logicalDetection"\xc3\x04\n\x1aLogicalDetectionDataHeader\x12E\n\x16logical_detection_time\x18\x01 \x01(\x0b2\x0f.osi3.TimestampR\x14logicalDetectionTime\x12U\n\x0edata_qualifier\x18\x02 \x01(\x0e2..osi3.LogicalDetectionDataHeader.DataQualifierR\rdataQualifier\x12J\n"number_of_valid_logical_detections\x18\x03 \x01(\rR\x1enumberOfValidLogicalDetections\x12-\n\tsensor_id\x18\x04 \x03(\x0b2\x10.osi3.IdentifierR\x08sensorId"\x8b\x02\n\rDataQualifier\x12\x18\n\x16DATA_QUALIFIER_UNKNOWN\x12\x18\n\x14DATA_QUALIFIER_OTHER\x10\x01\x12\x1c\n\x18DATA_QUALIFIER_AVAILABLE\x10\x02\x12$\n DATA_QUALIFIER_AVAILABLE_REDUCED\x10\x03\x12 \n\x1cDATA_QUALIFIER_NOT_AVAILABLE\x10\x04\x12\x1c\n\x18DATA_QUALIFIER_BLINDNESS\x10\x05\x12&\n"DATA_QUALIFIER_TEMPORARY_AVAILABLE\x10\x06\x12\x1a\n\x16DATA_QUALIFIER_INVALID\x10\x07"\xc9\x04\n\x10LogicalDetection\x123\n\x15existence_probability\x18\x01 \x01(\x01R\x14existenceProbability\x12-\n\tobject_id\x18\x02 \x01(\x0b2\x10.osi3.IdentifierR\x08objectId\x12*\n\x08position\x18\x03 \x01(\x0b2\x0e.osi3.Vector3dR\x08position\x123\n\rposition_rmse\x18\x04 \x01(\x0b2\x0e.osi3.Vector3dR\x0cpositionRmse\x12*\n\x08velocity\x18\x05 \x01(\x0b2\x0e.osi3.Vector3dR\x08velocity\x123\n\rvelocity_rmse\x18\x06 \x01(\x0b2\x0e.osi3.Vector3dR\x0cvelocityRmse\x12\x1c\n\tintensity\x18\x07 \x01(\x01R\tintensity\x12\x10\n\x03snr\x18\x08 \x01(\x01R\x03snr\x128\n\x18point_target_probability\x18\t \x01(\x01R\x16pointTargetProbability\x12-\n\tsensor_id\x18\n \x03(\x0b2\x10.osi3.IdentifierR\x08sensorId\x12L\n\x0eclassification\x18\x0b \x01(\x0e2$.osi3.LogicalDetectionClassificationR\x0eclassification\x12(\n\x10echo_pulse_width\x18\x0c \x01(\x01R\x0eechoPulseWidth*\xbb\x02\n\x1eLogicalDetectionClassification\x12*\n(LOGICAL_DETECTION_CLASSIFICATION_UNKNOWN\x12*\n&LOGICAL_DETECTION_CLASSIFICATION_OTHER\x10\x01\x12,\n(LOGICAL_DETECTION_CLASSIFICATION_INVALID\x10\x02\x12,\n(LOGICAL_DETECTION_CLASSIFICATION_CLUTTER\x10\x03\x121\n-LOGICAL_DETECTION_CLASSIFICATION_OVERDRIVABLE\x10\x04\x122\n.LOGICAL_DETECTION_CLASSIFICATION_UNDERDRIVABLE\x10\x05B\x02H\x01'
)
OSI_SENSORDATA_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x14osi_sensordata.proto\x12\x04osi3\x1a\x11osi_version.proto\x1a\x10osi_common.proto\x1a\x1dosi_detectedtrafficsign.proto\x1a\x1eosi_detectedtrafficlight.proto\x1a\x1dosi_detectedroadmarking.proto\x1a\x16osi_detectedlane.proto\x1a\x18osi_detectedobject.proto\x1a\x1aosi_detectedoccupant.proto\x1a\x14osi_sensorview.proto\x1a\x15osi_featuredata.proto\x1a\x1eosi_logicaldetectiondata.proto"\xba\x03\n\x14DetectedEntityHeader\x12:\n\x10measurement_time\x18\x01 \x01(\x0b2\x0f.osi3.TimestampR\x0fmeasurementTime\x12#\n\rcycle_counter\x18\x02 \x01(\x04R\x0ccycleCounter\x12O\n\x0edata_qualifier\x18\x03 \x01(\x0e2(.osi3.DetectedEntityHeader.DataQualifierR\rdataQualifier"\xef\x01\n\rDataQualifier\x12\x18\n\x16DATA_QUALIFIER_UNKNOWN\x12\x18\n\x14DATA_QUALIFIER_OTHER\x10\x01\x12\x1c\n\x18DATA_QUALIFIER_AVAILABLE\x10\x02\x12$\n DATA_QUALIFIER_AVAILABLE_REDUCED\x10\x03\x12 \n\x1cDATA_QUALIFIER_NOT_AVAILABLE\x10\x04\x12\x1c\n\x18DATA_QUALIFIER_BLINDNESS\x10\x05\x12&\n"DATA_QUALIFIER_TEMPORARY_AVAILABLE\x10\x06"\xd8\x0f\n\nSensorData\x120\n\x07version\x18\x01 \x01(\x0b2\x16.osi3.InterfaceVersionR\x07version\x12-\n\ttimestamp\x18\x02 \x01(\x0b2\x0f.osi3.TimestampR\ttimestamp\x12D\n\x15host_vehicle_location\x18\x03 \x01(\x0b2\x10.osi3.BaseMovingR\x13hostVehicleLocation\x12M\n\x1ahost_vehicle_location_rmse\x18\x04 \x01(\x0b2\x10.osi3.BaseMovingR\x17hostVehicleLocationRmse\x12-\n\tsensor_id\x18\x05 \x01(\x0b2\x10.osi3.IdentifierR\x08sensorId\x12C\n\x11mounting_position\x18\x06 \x01(\x0b2\x16.osi3.MountingPositionR\x10mountingPosition\x12L\n\x16mounting_position_rmse\x18\x07 \x01(\x0b2\x16.osi3.MountingPositionR\x14mountingPositionRmse\x121\n\x0bsensor_view\x18\x08 \x03(\x0b2\x10.osi3.SensorViewR\nsensorView\x12C\n\x15last_measurement_time\x18\t \x01(\x0b2\x0f.osi3.TimestampR\x13lastMeasurementTime\x12T\n\x18stationary_object_header\x18\n \x01(\x0b2\x1a.osi3.DetectedEntityHeaderR\x16stationaryObjectHeader\x12K\n\x11stationary_object\x18\x0b \x03(\x0b2\x1e.osi3.DetectedStationaryObjectR\x10stationaryObject\x12L\n\x14moving_object_header\x18\x0c \x01(\x0b2\x1a.osi3.DetectedEntityHeaderR\x12movingObjectHeader\x12?\n\rmoving_object\x18\r \x03(\x0b2\x1a.osi3.DetectedMovingObjectR\x0cmovingObject\x12J\n\x13traffic_sign_header\x18\x0e \x01(\x0b2\x1a.osi3.DetectedEntityHeaderR\x11trafficSignHeader\x12<\n\x0ctraffic_sign\x18\x0f \x03(\x0b2\x19.osi3.DetectedTrafficSignR\x0btrafficSign\x12L\n\x14traffic_light_header\x18\x10 \x01(\x0b2\x1a.osi3.DetectedEntityHeaderR\x12trafficLightHeader\x12?\n\rtraffic_light\x18\x11 \x03(\x0b2\x1a.osi3.DetectedTrafficLightR\x0ctrafficLight\x12J\n\x13road_marking_header\x18\x12 \x01(\x0b2\x1a.osi3.DetectedEntityHeaderR\x11roadMarkingHeader\x12<\n\x0croad_marking\x18\x13 \x03(\x0b2\x19.osi3.DetectedRoadMarkingR\x0broadMarking\x12L\n\x14lane_boundary_header\x18\x14 \x01(\x0b2\x1a.osi3.DetectedEntityHeaderR\x12laneBoundaryHeader\x12?\n\rlane_boundary\x18\x15 \x03(\x0b2\x1a.osi3.DetectedLaneBoundaryR\x0claneBoundary\x12;\n\x0blane_header\x18\x16 \x01(\x0b2\x1a.osi3.DetectedEntityHeaderR\nlaneHeader\x12&\n\x04lane\x18\x17 \x03(\x0b2\x12.osi3.DetectedLaneR\x04lane\x12C\n\x0foccupant_header\x18\x18 \x01(\x0b2\x1a.osi3.DetectedEntityHeaderR\x0eoccupantHeader\x122\n\x08occupant\x18\x19 \x03(\x0b2\x16.osi3.DetectedOccupantR\x08occupant\x124\n\x0cfeature_data\x18\x1a \x01(\x0b2\x11.osi3.FeatureDataR\x0bfeatureData\x12P\n\x16logical_detection_data\x18\x1b \x01(\x0b2\x1a.osi3.LogicalDetectionDataR\x14logicalDetectionData\x12[\n\x16virtual_detection_area\x18\x1c \x01(\x0b2%.osi3.SensorData.VirtualDetectionAreaR\x14virtualDetectionArea\x120\n\x0bsystem_time\x18\x1d \x01(\x0b2\x0f.osi3.TimestampR\nsystemTime\x1aA\n\x14VirtualDetectionArea\x12)\n\x07polygon\x18\x01 \x03(\x0b2\x0f.osi3.Polygon3dR\x07polygonB\x02H\x01'
)
OSI_TRAFFICUPDATE_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x17osi_trafficupdate.proto\x12\x04osi3\x1a\x11osi_version.proto\x1a\x10osi_common.proto\x1a\x10osi_object.proto\x1a\x19osi_hostvehicledata.proto"\xda\x01\n\rTrafficUpdate\x120\n\x07version\x18\x01 \x01(\x0b2\x16.osi3.InterfaceVersionR\x07version\x12-\n\ttimestamp\x18\x02 \x01(\x0b2\x0f.osi3.TimestampR\ttimestamp\x12*\n\x06update\x18\x03 \x03(\x0b2\x12.osi3.MovingObjectR\x06update\x12<\n\x0einternal_state\x18\x04 \x03(\x0b2\x15.osi3.HostVehicleDataR\rinternalStateB\x02H\x01'
)
OSI_STREAMINGUPDATE_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x19osi_streamingupdate.proto\x12\x04osi3\x1a\x11osi_version.proto\x1a\x10osi_common.proto\x1a\x15osi_environment.proto\x1a\x10osi_object.proto\x1a\x15osi_trafficsign.proto\x1a\x16osi_trafficlight.proto\x1a\x19osi_hostvehicledata.proto"\xfd\x04\n\x0fStreamingUpdate\x120\n\x07version\x18\x01 \x01(\x0b2\x16.osi3.InterfaceVersionR\x07version\x12-\n\ttimestamp\x18\x02 \x01(\x0b2\x0f.osi3.TimestampR\ttimestamp\x12P\n\x18stationary_object_update\x18\x03 \x03(\x0b2\x16.osi3.StationaryObjectR\x16stationaryObjectUpdate\x12D\n\x14moving_object_update\x18\x04 \x03(\x0b2\x12.osi3.MovingObjectR\x12movingObjectUpdate\x12A\n\x13traffic_sign_update\x18\x05 \x03(\x0b2\x11.osi3.TrafficSignR\x11trafficSignUpdate\x12D\n\x14traffic_light_update\x18\x06 \x03(\x0b2\x12.osi3.TrafficLightR\x12trafficLightUpdate\x12e\n\x1fenvironmental_conditions_update\x18\x07 \x01(\x0b2\x1d.osi3.EnvironmentalConditionsR\x1denvironmentalConditionsUpdate\x12N\n\x18host_vehicle_data_update\x18\x08 \x03(\x0b2\x15.osi3.HostVehicleDataR\x15hostVehicleDataUpdate\x121\n\x0bobsolete_id\x18\t \x03(\x0b2\x10.osi3.IdentifierR\nobsoleteIdB\x02H\x01'
)
OSI_TRAFFICCOMMANDUPDATE_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x1eosi_trafficcommandupdate.proto\x12\x04osi3\x1a\x11osi_version.proto\x1a\x10osi_common.proto"\x92\x03\n\x14TrafficCommandUpdate\x120\n\x07version\x18\x01 \x01(\x0b2\x16.osi3.InterfaceVersionR\x07version\x12-\n\ttimestamp\x18\x02 \x01(\x0b2\x0f.osi3.TimestampR\ttimestamp\x12F\n\x16traffic_participant_id\x18\x03 \x01(\x0b2\x10.osi3.IdentifierR\x14trafficParticipantId\x12U\n\x10dismissed_action\x18\x04 \x03(\x0b2*.osi3.TrafficCommandUpdate.DismissedActionR\x0fdismissedAction\x1az\n\x0fDismissedAction\x12@\n\x13dismissed_action_id\x18\x01 \x01(\x0b2\x10.osi3.IdentifierR\x11dismissedActionId\x12%\n\x0efailure_reason\x18\x02 \x01(\tR\rfailureReasonB\x02H\x01'
)
OSI_DATARECORDING_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x17osi_datarecording.proto\x12\x04osi3\x1a\x14osi_sensordata.proto"E\n\x10SensorDataSeries\x121\n\x0bsensor_data\x18\x01 \x03(\x0b2\x10.osi3.SensorDataR\nsensorData"F\n\x14SensorDataSeriesList\x12.\n\x06sensor\x18\x01 \x03(\x0b2\x16.osi3.SensorDataSeriesR\x06sensorB\x02H\x01'
)
OSI_MAPASAMOPENDRIVE_PROTO_DESCRIPTOR = default_google_proto_descriptor_pool.AddSerializedFile(
    b'\n\x1aosi_mapasamopendrive.proto\x12\x04osi3"l\n\x10MapAsamOpenDrive\x12#\n\rmap_reference\x18\x01 \x01(\tR\x0cmapReference\x123\n\x16open_drive_xml_content\x18\x02 \x01(\tR\x13openDriveXmlContentB\x02H\x01'
)
