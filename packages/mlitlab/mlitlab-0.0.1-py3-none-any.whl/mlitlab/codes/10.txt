
# !pip install numpy pandas matplotlib seaborn scikit-learn scipy
import pandas as pd
from sklearn.svm import SVC
import matplotlib.pyplot as plt
import numpy as np

# Dataset
data = {
    'Weight': [150, 170, 120, 180, 140, 130, 200],
    'Color_Score': [0.80, 0.65, 0.90, 0.60, 0.85, 0.88, 0.55],
    'Fruit': ['Apple', 'Orange', 'Banana', 'Orange', 'Apple', 'Banana', 'Orange']
}
df = pd.DataFrame(data)
# Mapping the 'Fruit' column to numerical labels for the existing structure to run
fruit_mapping = {'Apple': 0, 'Orange': 1, 'Banana': 2}
df['Fruit_Encoded'] = df['Fruit'].map(fruit_mapping)
df['Result'] = df['Fruit'].map({'Apple':0, 'Orange':1, 'Banana':1}) # Treat Banana as 1 for binary plot compatibility


X = df[['Weight', 'Color_Score']] # Use the new feature names
y = df['Result'] # Use the new encoded target

for kernelName in ['linear','poly']:
    svm_model = SVC(kernel=kernelName, C=1.0)
    svm_model.fit(X, y)

    plt.figure() # Added to create a new figure for each kernel
    plt.scatter(X['Weight'], X['Color_Score'], c=y, cmap='bwr', s=100) # Use new features for scatter plot

    if kernelName == 'linear': # ONLY calculate and plot the linear boundary for the 'linear' kernel
        w = svm_model.coef_[0]
        b = svm_model.intercept_[0]
        x_vals = np.array([X['Weight'].min()-10, X['Weight'].max()+10]) # Adjusted range for Weight
        y_vals = -(w[0]/w[1])*x_vals - b/w[1]
        plt.plot(x_vals, y_vals, 'k--')

    plt.xlabel('Weight') # Change x-label
    plt.ylabel('Color_Score') # Change y-label
    plt.title(f'SVM Classification ({kernelName} Kernel)') # Modified title to include kernel name
    plt.show()

