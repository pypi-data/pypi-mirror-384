import requests
import sseclient
import json
from typing import Generator
# coding: utf-8

"""
    Kestra EE

    All API operations, except for Superadmin-only endpoints, require a tenant identifier in the HTTP path.<br/> Endpoints designated as Superadmin-only are not tenant-scoped.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictBool, StrictBytes, StrictInt, StrictStr
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated
from kestrapy.models.bulk_response import BulkResponse
from kestrapy.models.delete_executions_by_query_request import DeleteExecutionsByQueryRequest
from kestrapy.models.event_execution import EventExecution
from kestrapy.models.event_execution_status_event import EventExecutionStatusEvent
from kestrapy.models.execution import Execution
from kestrapy.models.execution_controller_api_validate_execution_inputs_response import ExecutionControllerApiValidateExecutionInputsResponse
from kestrapy.models.execution_controller_eval_result import ExecutionControllerEvalResult
from kestrapy.models.execution_controller_execution_response import ExecutionControllerExecutionResponse
from kestrapy.models.execution_controller_last_execution_response import ExecutionControllerLastExecutionResponse
from kestrapy.models.execution_controller_set_labels_by_ids_request import ExecutionControllerSetLabelsByIdsRequest
from kestrapy.models.execution_controller_state_request import ExecutionControllerStateRequest
from kestrapy.models.execution_controller_webhook_response import ExecutionControllerWebhookResponse
from kestrapy.models.execution_repository_interface_flow_filter import ExecutionRepositoryInterfaceFlowFilter
from kestrapy.models.file_metas import FileMetas
from kestrapy.models.flow_for_execution import FlowForExecution
from kestrapy.models.flow_graph import FlowGraph
from kestrapy.models.flow_scope import FlowScope
from kestrapy.models.label import Label
from kestrapy.models.paged_results_execution import PagedResultsExecution
from kestrapy.models.paged_results_task_run import PagedResultsTaskRun
from kestrapy.models.query_filter import QueryFilter
from kestrapy.models.state_type import StateType

from kestrapy.api_client import ApiClient, RequestSerialized
from kestrapy.api_response import ApiResponse
from kestrapy.rest import RESTResponseType


class ExecutionsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_execution(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        wait: Annotated[StrictBool, Field(description="If the server will wait the end of the execution")],
        tenant: StrictStr,
        labels: Annotated[Optional[List[StrictStr]], Field(description="The labels as a list of 'key:value'")] = None,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision or latest if null")] = None,
        schedule_date: Annotated[Optional[datetime], Field(description="Schedule the flow on a specific date")] = None,
        breakpoints: Annotated[Optional[StrictStr], Field(description="Set a list of breakpoints at specific tasks 'id.value', separated by a coma.")] = None,
        kind: Annotated[Optional[Any], Field(description="Specific execution kind")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ExecutionControllerExecutionResponse:
        """Create a new execution for a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
        :param id: The flow id (required)
        :type id: str
        :param wait: If the server will wait the end of the execution (required)
        :type wait: bool
        :param tenant: (required)
        :type tenant: str
        :param labels: The labels as a list of 'key:value'
        :type labels: List[str]
        :param revision: The flow revision or latest if null
        :type revision: int
        :param schedule_date: Schedule the flow on a specific date
        :type schedule_date: datetime
        :param breakpoints: Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
        :type breakpoints: str
        :param kind: Specific execution kind
        :type kind: ExecutionKind
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_execution_serialize(
            namespace=namespace,
            id=id,
            wait=wait,
            tenant=tenant,
            labels=labels,
            revision=revision,
            schedule_date=schedule_date,
            breakpoints=breakpoints,
            kind=kind,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '409': None,
            '200': "ExecutionControllerExecutionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_execution_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        wait: Annotated[StrictBool, Field(description="If the server will wait the end of the execution")],
        tenant: StrictStr,
        labels: Annotated[Optional[List[StrictStr]], Field(description="The labels as a list of 'key:value'")] = None,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision or latest if null")] = None,
        schedule_date: Annotated[Optional[datetime], Field(description="Schedule the flow on a specific date")] = None,
        breakpoints: Annotated[Optional[StrictStr], Field(description="Set a list of breakpoints at specific tasks 'id.value', separated by a coma.")] = None,
        kind: Annotated[Optional[Any], Field(description="Specific execution kind")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ExecutionControllerExecutionResponse]:
        """Create a new execution for a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
        :param id: The flow id (required)
        :type id: str
        :param wait: If the server will wait the end of the execution (required)
        :type wait: bool
        :param tenant: (required)
        :type tenant: str
        :param labels: The labels as a list of 'key:value'
        :type labels: List[str]
        :param revision: The flow revision or latest if null
        :type revision: int
        :param schedule_date: Schedule the flow on a specific date
        :type schedule_date: datetime
        :param breakpoints: Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
        :type breakpoints: str
        :param kind: Specific execution kind
        :type kind: ExecutionKind
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_execution_serialize(
            namespace=namespace,
            id=id,
            wait=wait,
            tenant=tenant,
            labels=labels,
            revision=revision,
            schedule_date=schedule_date,
            breakpoints=breakpoints,
            kind=kind,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '409': None,
            '200': "ExecutionControllerExecutionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_execution_without_preload_content(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        wait: Annotated[StrictBool, Field(description="If the server will wait the end of the execution")],
        tenant: StrictStr,
        labels: Annotated[Optional[List[StrictStr]], Field(description="The labels as a list of 'key:value'")] = None,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision or latest if null")] = None,
        schedule_date: Annotated[Optional[datetime], Field(description="Schedule the flow on a specific date")] = None,
        breakpoints: Annotated[Optional[StrictStr], Field(description="Set a list of breakpoints at specific tasks 'id.value', separated by a coma.")] = None,
        kind: Annotated[Optional[Any], Field(description="Specific execution kind")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create a new execution for a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
        :param id: The flow id (required)
        :type id: str
        :param wait: If the server will wait the end of the execution (required)
        :type wait: bool
        :param tenant: (required)
        :type tenant: str
        :param labels: The labels as a list of 'key:value'
        :type labels: List[str]
        :param revision: The flow revision or latest if null
        :type revision: int
        :param schedule_date: Schedule the flow on a specific date
        :type schedule_date: datetime
        :param breakpoints: Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
        :type breakpoints: str
        :param kind: Specific execution kind
        :type kind: ExecutionKind
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_execution_serialize(
            namespace=namespace,
            id=id,
            wait=wait,
            tenant=tenant,
            labels=labels,
            revision=revision,
            schedule_date=schedule_date,
            breakpoints=breakpoints,
            kind=kind,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '409': None,
            '200': "ExecutionControllerExecutionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_execution_serialize(
        self,
        namespace,
        id,
        wait,
        tenant,
        labels,
        revision,
        schedule_date,
        breakpoints,
        kind,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'labels': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if id is not None:
            _path_params['id'] = id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if labels is not None:
            
            _query_params.append(('labels', labels))
            
        if wait is not None:
            
            _query_params.append(('wait', wait))
            
        if revision is not None:
            
            _query_params.append(('revision', revision))
            
        if schedule_date is not None:
            if isinstance(schedule_date, datetime):
                _query_params.append(
                    (
                        'scheduleDate',
                        schedule_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('scheduleDate', schedule_date))
            
        if breakpoints is not None:
            
            _query_params.append(('breakpoints', breakpoints))
            
        if kind is not None:
            
            _query_params.append(('kind', kind.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{namespace}/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        delete_logs: Annotated[StrictBool, Field(description="Whether to delete execution logs")],
        delete_metrics: Annotated[StrictBool, Field(description="Whether to delete execution metrics")],
        delete_storage: Annotated[StrictBool, Field(description="Whether to delete execution files in the internal storage")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param delete_logs: Whether to delete execution logs (required)
        :type delete_logs: bool
        :param delete_metrics: Whether to delete execution metrics (required)
        :type delete_metrics: bool
        :param delete_storage: Whether to delete execution files in the internal storage (required)
        :type delete_storage: bool
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_execution_serialize(
            execution_id=execution_id,
            delete_logs=delete_logs,
            delete_metrics=delete_metrics,
            delete_storage=delete_storage,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        delete_logs: Annotated[StrictBool, Field(description="Whether to delete execution logs")],
        delete_metrics: Annotated[StrictBool, Field(description="Whether to delete execution metrics")],
        delete_storage: Annotated[StrictBool, Field(description="Whether to delete execution files in the internal storage")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param delete_logs: Whether to delete execution logs (required)
        :type delete_logs: bool
        :param delete_metrics: Whether to delete execution metrics (required)
        :type delete_metrics: bool
        :param delete_storage: Whether to delete execution files in the internal storage (required)
        :type delete_storage: bool
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_execution_serialize(
            execution_id=execution_id,
            delete_logs=delete_logs,
            delete_metrics=delete_metrics,
            delete_storage=delete_storage,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_execution_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        delete_logs: Annotated[StrictBool, Field(description="Whether to delete execution logs")],
        delete_metrics: Annotated[StrictBool, Field(description="Whether to delete execution metrics")],
        delete_storage: Annotated[StrictBool, Field(description="Whether to delete execution files in the internal storage")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param delete_logs: Whether to delete execution logs (required)
        :type delete_logs: bool
        :param delete_metrics: Whether to delete execution metrics (required)
        :type delete_metrics: bool
        :param delete_storage: Whether to delete execution files in the internal storage (required)
        :type delete_storage: bool
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_execution_serialize(
            execution_id=execution_id,
            delete_logs=delete_logs,
            delete_metrics=delete_metrics,
            delete_storage=delete_storage,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_execution_serialize(
        self,
        execution_id,
        delete_logs,
        delete_metrics,
        delete_storage,
        tenant,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if delete_logs is not None:
            
            _query_params.append(('deleteLogs', delete_logs))
            
        if delete_metrics is not None:
            
            _query_params.append(('deleteMetrics', delete_metrics))
            
        if delete_storage is not None:
            
            _query_params.append(('deleteStorage', delete_storage))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v1/{tenant}/executions/{executionId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_executions_by_ids(
        self,
        delete_logs: Annotated[StrictBool, Field(description="Whether to delete execution logs")],
        delete_metrics: Annotated[StrictBool, Field(description="Whether to delete execution metrics")],
        delete_storage: Annotated[StrictBool, Field(description="Whether to delete execution files in the internal storage")],
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The execution id")],
        include_non_terminated: Annotated[Optional[StrictBool], Field(description="Whether to delete non-terminated executions")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BulkResponse:
        """Delete a list of executions


        :param delete_logs: Whether to delete execution logs (required)
        :type delete_logs: bool
        :param delete_metrics: Whether to delete execution metrics (required)
        :type delete_metrics: bool
        :param delete_storage: Whether to delete execution files in the internal storage (required)
        :type delete_storage: bool
        :param tenant: (required)
        :type tenant: str
        :param request_body: The execution id (required)
        :type request_body: List[str]
        :param include_non_terminated: Whether to delete non-terminated executions
        :type include_non_terminated: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_executions_by_ids_serialize(
            delete_logs=delete_logs,
            delete_metrics=delete_metrics,
            delete_storage=delete_storage,
            tenant=tenant,
            request_body=request_body,
            include_non_terminated=include_non_terminated,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_executions_by_ids_with_http_info(
        self,
        delete_logs: Annotated[StrictBool, Field(description="Whether to delete execution logs")],
        delete_metrics: Annotated[StrictBool, Field(description="Whether to delete execution metrics")],
        delete_storage: Annotated[StrictBool, Field(description="Whether to delete execution files in the internal storage")],
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The execution id")],
        include_non_terminated: Annotated[Optional[StrictBool], Field(description="Whether to delete non-terminated executions")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BulkResponse]:
        """Delete a list of executions


        :param delete_logs: Whether to delete execution logs (required)
        :type delete_logs: bool
        :param delete_metrics: Whether to delete execution metrics (required)
        :type delete_metrics: bool
        :param delete_storage: Whether to delete execution files in the internal storage (required)
        :type delete_storage: bool
        :param tenant: (required)
        :type tenant: str
        :param request_body: The execution id (required)
        :type request_body: List[str]
        :param include_non_terminated: Whether to delete non-terminated executions
        :type include_non_terminated: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_executions_by_ids_serialize(
            delete_logs=delete_logs,
            delete_metrics=delete_metrics,
            delete_storage=delete_storage,
            tenant=tenant,
            request_body=request_body,
            include_non_terminated=include_non_terminated,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_executions_by_ids_without_preload_content(
        self,
        delete_logs: Annotated[StrictBool, Field(description="Whether to delete execution logs")],
        delete_metrics: Annotated[StrictBool, Field(description="Whether to delete execution metrics")],
        delete_storage: Annotated[StrictBool, Field(description="Whether to delete execution files in the internal storage")],
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The execution id")],
        include_non_terminated: Annotated[Optional[StrictBool], Field(description="Whether to delete non-terminated executions")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete a list of executions


        :param delete_logs: Whether to delete execution logs (required)
        :type delete_logs: bool
        :param delete_metrics: Whether to delete execution metrics (required)
        :type delete_metrics: bool
        :param delete_storage: Whether to delete execution files in the internal storage (required)
        :type delete_storage: bool
        :param tenant: (required)
        :type tenant: str
        :param request_body: The execution id (required)
        :type request_body: List[str]
        :param include_non_terminated: Whether to delete non-terminated executions
        :type include_non_terminated: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_executions_by_ids_serialize(
            delete_logs=delete_logs,
            delete_metrics=delete_metrics,
            delete_storage=delete_storage,
            tenant=tenant,
            request_body=request_body,
            include_non_terminated=include_non_terminated,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_executions_by_ids_serialize(
        self,
        delete_logs,
        delete_metrics,
        delete_storage,
        tenant,
        request_body,
        include_non_terminated,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if include_non_terminated is not None:
            
            _query_params.append(('includeNonTerminated', include_non_terminated))
            
        if delete_logs is not None:
            
            _query_params.append(('deleteLogs', delete_logs))
            
        if delete_metrics is not None:
            
            _query_params.append(('deleteMetrics', delete_metrics))
            
        if delete_storage is not None:
            
            _query_params.append(('deleteStorage', delete_storage))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v1/{tenant}/executions/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_executions_by_query(
        self,
        delete_logs: Annotated[StrictBool, Field(description="Whether to delete execution logs")],
        delete_metrics: Annotated[StrictBool, Field(description="Whether to delete execution metrics")],
        delete_storage: Annotated[StrictBool, Field(description="Whether to delete execution files in the internal storage")],
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        include_non_terminated: Annotated[Optional[StrictBool], Field(description="Whether to delete non-terminated executions")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Delete executions filter by query parameters


        :param delete_logs: Whether to delete execution logs (required)
        :type delete_logs: bool
        :param delete_metrics: Whether to delete execution metrics (required)
        :type delete_metrics: bool
        :param delete_storage: Whether to delete execution files in the internal storage (required)
        :type delete_storage: bool
        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param include_non_terminated: Whether to delete non-terminated executions
        :type include_non_terminated: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_executions_by_query_serialize(
            delete_logs=delete_logs,
            delete_metrics=delete_metrics,
            delete_storage=delete_storage,
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            include_non_terminated=include_non_terminated,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_executions_by_query_with_http_info(
        self,
        delete_logs: Annotated[StrictBool, Field(description="Whether to delete execution logs")],
        delete_metrics: Annotated[StrictBool, Field(description="Whether to delete execution metrics")],
        delete_storage: Annotated[StrictBool, Field(description="Whether to delete execution files in the internal storage")],
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        include_non_terminated: Annotated[Optional[StrictBool], Field(description="Whether to delete non-terminated executions")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Delete executions filter by query parameters


        :param delete_logs: Whether to delete execution logs (required)
        :type delete_logs: bool
        :param delete_metrics: Whether to delete execution metrics (required)
        :type delete_metrics: bool
        :param delete_storage: Whether to delete execution files in the internal storage (required)
        :type delete_storage: bool
        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param include_non_terminated: Whether to delete non-terminated executions
        :type include_non_terminated: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_executions_by_query_serialize(
            delete_logs=delete_logs,
            delete_metrics=delete_metrics,
            delete_storage=delete_storage,
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            include_non_terminated=include_non_terminated,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_executions_by_query_without_preload_content(
        self,
        delete_logs: Annotated[StrictBool, Field(description="Whether to delete execution logs")],
        delete_metrics: Annotated[StrictBool, Field(description="Whether to delete execution metrics")],
        delete_storage: Annotated[StrictBool, Field(description="Whether to delete execution files in the internal storage")],
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        include_non_terminated: Annotated[Optional[StrictBool], Field(description="Whether to delete non-terminated executions")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete executions filter by query parameters


        :param delete_logs: Whether to delete execution logs (required)
        :type delete_logs: bool
        :param delete_metrics: Whether to delete execution metrics (required)
        :type delete_metrics: bool
        :param delete_storage: Whether to delete execution files in the internal storage (required)
        :type delete_storage: bool
        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param include_non_terminated: Whether to delete non-terminated executions
        :type include_non_terminated: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_executions_by_query_serialize(
            delete_logs=delete_logs,
            delete_metrics=delete_metrics,
            delete_storage=delete_storage,
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            include_non_terminated=include_non_terminated,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_executions_by_query_serialize(
        self,
        delete_logs,
        delete_metrics,
        delete_storage,
        tenant,
        delete_executions_by_query_request,
        q,
        scope,
        namespace,
        flow_id,
        start_date,
        end_date,
        time_range,
        state,
        labels,
        trigger_execution_id,
        child_filter,
        include_non_terminated,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'scope': 'csv',
            'state': 'csv',
            'labels': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if q is not None:
            
            _query_params.append(('q', q))
            
        if scope is not None:
            
            _query_params.append(('scope', scope))
            
        if namespace is not None:
            
            _query_params.append(('namespace', namespace))
            
        if flow_id is not None:
            
            _query_params.append(('flowId', flow_id))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'startDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'endDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('endDate', end_date))
            
        if time_range is not None:
            
            _query_params.append(('timeRange', time_range))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if labels is not None:
            
            _query_params.append(('labels', labels))
            
        if trigger_execution_id is not None:
            
            _query_params.append(('triggerExecutionId', trigger_execution_id))
            
        if child_filter is not None:
            
            _query_params.append(('childFilter', child_filter.value))
            
        if include_non_terminated is not None:
            
            _query_params.append(('includeNonTerminated', include_non_terminated))
            
        if delete_logs is not None:
            
            _query_params.append(('deleteLogs', delete_logs))
            
        if delete_metrics is not None:
            
            _query_params.append(('deleteMetrics', delete_metrics))
            
        if delete_storage is not None:
            
            _query_params.append(('deleteStorage', delete_storage))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if delete_executions_by_query_request is not None:
            _body_params = delete_executions_by_query_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v1/{tenant}/executions/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def download_file_from_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        path: Annotated[StrictStr, Field(description="The internal storage uri")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """Download file for an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param path: The internal storage uri (required)
        :type path: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._download_file_from_execution_serialize(
            execution_id=execution_id,
            path=path,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def download_file_from_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        path: Annotated[StrictStr, Field(description="The internal storage uri")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """Download file for an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param path: The internal storage uri (required)
        :type path: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._download_file_from_execution_serialize(
            execution_id=execution_id,
            path=path,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def download_file_from_execution_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        path: Annotated[StrictStr, Field(description="The internal storage uri")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Download file for an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param path: The internal storage uri (required)
        :type path: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._download_file_from_execution_serialize(
            execution_id=execution_id,
            path=path,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _download_file_from_execution_serialize(
        self,
        execution_id,
        path,
        tenant,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if path is not None:
            
            _query_params.append(('path', path))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/octet-stream'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/{executionId}/file',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def eval_task_run_expression(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        task_run_id: Annotated[StrictStr, Field(description="The taskrun id")],
        tenant: StrictStr,
        body: Annotated[StrictStr, Field(description="The Pebble expression that should be evaluated")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ExecutionControllerEvalResult:
        """Evaluate a variable expression for this taskrun


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param task_run_id: The taskrun id (required)
        :type task_run_id: str
        :param tenant: (required)
        :type tenant: str
        :param body: The Pebble expression that should be evaluated (required)
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._eval_task_run_expression_serialize(
            execution_id=execution_id,
            task_run_id=task_run_id,
            tenant=tenant,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExecutionControllerEvalResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def eval_task_run_expression_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        task_run_id: Annotated[StrictStr, Field(description="The taskrun id")],
        tenant: StrictStr,
        body: Annotated[StrictStr, Field(description="The Pebble expression that should be evaluated")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ExecutionControllerEvalResult]:
        """Evaluate a variable expression for this taskrun


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param task_run_id: The taskrun id (required)
        :type task_run_id: str
        :param tenant: (required)
        :type tenant: str
        :param body: The Pebble expression that should be evaluated (required)
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._eval_task_run_expression_serialize(
            execution_id=execution_id,
            task_run_id=task_run_id,
            tenant=tenant,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExecutionControllerEvalResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def eval_task_run_expression_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        task_run_id: Annotated[StrictStr, Field(description="The taskrun id")],
        tenant: StrictStr,
        body: Annotated[StrictStr, Field(description="The Pebble expression that should be evaluated")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Evaluate a variable expression for this taskrun


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param task_run_id: The taskrun id (required)
        :type task_run_id: str
        :param tenant: (required)
        :type tenant: str
        :param body: The Pebble expression that should be evaluated (required)
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._eval_task_run_expression_serialize(
            execution_id=execution_id,
            task_run_id=task_run_id,
            tenant=tenant,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExecutionControllerEvalResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _eval_task_run_expression_serialize(
        self,
        execution_id,
        task_run_id,
        tenant,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if task_run_id is not None:
            _path_params['taskRunId'] = task_run_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'text/plain'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/eval/{taskRunId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def follow_dependencies_executions(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        destination_only: Annotated[StrictBool, Field(description="If true, list only destination dependencies, otherwise list also source dependencies")],
        expand_all: Annotated[StrictBool, Field(description="If true, expand all dependencies recursively")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EventExecutionStatusEvent:
        """Follow all execution dependencies executions


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param destination_only: If true, list only destination dependencies, otherwise list also source dependencies (required)
        :type destination_only: bool
        :param expand_all: If true, expand all dependencies recursively (required)
        :type expand_all: bool
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._follow_dependencies_executions_serialize(
            execution_id=execution_id,
            destination_only=destination_only,
            expand_all=expand_all,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EventExecutionStatusEvent",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def follow_dependencies_executions_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        destination_only: Annotated[StrictBool, Field(description="If true, list only destination dependencies, otherwise list also source dependencies")],
        expand_all: Annotated[StrictBool, Field(description="If true, expand all dependencies recursively")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EventExecutionStatusEvent]:
        """Follow all execution dependencies executions


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param destination_only: If true, list only destination dependencies, otherwise list also source dependencies (required)
        :type destination_only: bool
        :param expand_all: If true, expand all dependencies recursively (required)
        :type expand_all: bool
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._follow_dependencies_executions_serialize(
            execution_id=execution_id,
            destination_only=destination_only,
            expand_all=expand_all,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EventExecutionStatusEvent",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def follow_dependencies_executions_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        destination_only: Annotated[StrictBool, Field(description="If true, list only destination dependencies, otherwise list also source dependencies")],
        expand_all: Annotated[StrictBool, Field(description="If true, expand all dependencies recursively")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Follow all execution dependencies executions


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param destination_only: If true, list only destination dependencies, otherwise list also source dependencies (required)
        :type destination_only: bool
        :param expand_all: If true, expand all dependencies recursively (required)
        :type expand_all: bool
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._follow_dependencies_executions_serialize(
            execution_id=execution_id,
            destination_only=destination_only,
            expand_all=expand_all,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EventExecutionStatusEvent",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _follow_dependencies_executions_serialize(
        self,
        execution_id,
        destination_only,
        expand_all,
        tenant,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if destination_only is not None:
            
            _query_params.append(('destinationOnly', destination_only))
            
        if expand_all is not None:
            
            _query_params.append(('expandAll', expand_all))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/event-stream'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/{executionId}/follow-dependencies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def follow_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EventExecution:
        """Follow an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._follow_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EventExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def follow_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EventExecution]:
        """Follow an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._follow_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EventExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def follow_execution_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Follow an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._follow_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EventExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _follow_execution_serialize(
        self,
        execution_id,
        tenant,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/event-stream'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/{executionId}/follow',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def force_run_by_ids(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BulkResponse:
        """Force run a list of executions


        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._force_run_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def force_run_by_ids_with_http_info(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BulkResponse]:
        """Force run a list of executions


        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._force_run_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def force_run_by_ids_without_preload_content(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Force run a list of executions


        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._force_run_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _force_run_by_ids_serialize(
        self,
        tenant,
        request_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/force-run/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def force_run_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Execution:
        """Force run an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._force_run_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def force_run_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Execution]:
        """Force run an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._force_run_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def force_run_execution_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Force run an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._force_run_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _force_run_execution_serialize(
        self,
        execution_id,
        tenant,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/force-run',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def force_run_executions_by_query(
        self,
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Force run executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._force_run_executions_by_query_serialize(
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def force_run_executions_by_query_with_http_info(
        self,
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Force run executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._force_run_executions_by_query_serialize(
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def force_run_executions_by_query_without_preload_content(
        self,
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Force run executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._force_run_executions_by_query_serialize(
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _force_run_executions_by_query_serialize(
        self,
        tenant,
        delete_executions_by_query_request,
        q,
        scope,
        namespace,
        flow_id,
        start_date,
        end_date,
        time_range,
        state,
        labels,
        trigger_execution_id,
        child_filter,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'scope': 'csv',
            'state': 'csv',
            'labels': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if q is not None:
            
            _query_params.append(('q', q))
            
        if scope is not None:
            
            _query_params.append(('scope', scope))
            
        if namespace is not None:
            
            _query_params.append(('namespace', namespace))
            
        if flow_id is not None:
            
            _query_params.append(('flowId', flow_id))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'startDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'endDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('endDate', end_date))
            
        if time_range is not None:
            
            _query_params.append(('timeRange', time_range))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if labels is not None:
            
            _query_params.append(('labels', labels))
            
        if trigger_execution_id is not None:
            
            _query_params.append(('triggerExecutionId', trigger_execution_id))
            
        if child_filter is not None:
            
            _query_params.append(('childFilter', child_filter.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if delete_executions_by_query_request is not None:
            _body_params = delete_executions_by_query_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/force-run/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Execution:
        """Get an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Execution]:
        """Get an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_execution_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_execution_serialize(
        self,
        execution_id,
        tenant,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/{executionId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_execution_flow_graph(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        subflows: Annotated[Optional[List[StrictStr]], Field(description="The subflow tasks to display")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FlowGraph:
        """Generate a graph for an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param subflows: The subflow tasks to display
        :type subflows: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_execution_flow_graph_serialize(
            execution_id=execution_id,
            tenant=tenant,
            subflows=subflows,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowGraph",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_execution_flow_graph_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        subflows: Annotated[Optional[List[StrictStr]], Field(description="The subflow tasks to display")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FlowGraph]:
        """Generate a graph for an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param subflows: The subflow tasks to display
        :type subflows: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_execution_flow_graph_serialize(
            execution_id=execution_id,
            tenant=tenant,
            subflows=subflows,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowGraph",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_execution_flow_graph_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        subflows: Annotated[Optional[List[StrictStr]], Field(description="The subflow tasks to display")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Generate a graph for an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param subflows: The subflow tasks to display
        :type subflows: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_execution_flow_graph_serialize(
            execution_id=execution_id,
            tenant=tenant,
            subflows=subflows,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowGraph",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_execution_flow_graph_serialize(
        self,
        execution_id,
        tenant,
        subflows,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'subflows': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if subflows is not None:
            
            _query_params.append(('subflows', subflows))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/{executionId}/graph',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_file_metadatas_from_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        path: Annotated[StrictStr, Field(description="The internal storage uri")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FileMetas:
        """Get file meta information for an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param path: The internal storage uri (required)
        :type path: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_file_metadatas_from_execution_serialize(
            execution_id=execution_id,
            path=path,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileMetas",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_file_metadatas_from_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        path: Annotated[StrictStr, Field(description="The internal storage uri")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FileMetas]:
        """Get file meta information for an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param path: The internal storage uri (required)
        :type path: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_file_metadatas_from_execution_serialize(
            execution_id=execution_id,
            path=path,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileMetas",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_file_metadatas_from_execution_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        path: Annotated[StrictStr, Field(description="The internal storage uri")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get file meta information for an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param path: The internal storage uri (required)
        :type path: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_file_metadatas_from_execution_serialize(
            execution_id=execution_id,
            path=path,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileMetas",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_file_metadatas_from_execution_serialize(
        self,
        execution_id,
        path,
        tenant,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if path is not None:
            
            _query_params.append(('path', path))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/{executionId}/file/metas',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_flow_from_execution(
        self,
        namespace: Annotated[StrictStr, Field(description="The namespace of the flow")],
        flow_id: Annotated[StrictStr, Field(description="The flow id")],
        tenant: StrictStr,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FlowForExecution:
        """Get flow information's for an execution


        :param namespace: The namespace of the flow (required)
        :type namespace: str
        :param flow_id: The flow id (required)
        :type flow_id: str
        :param tenant: (required)
        :type tenant: str
        :param revision: The flow revision
        :type revision: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_flow_from_execution_serialize(
            namespace=namespace,
            flow_id=flow_id,
            tenant=tenant,
            revision=revision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowForExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_flow_from_execution_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The namespace of the flow")],
        flow_id: Annotated[StrictStr, Field(description="The flow id")],
        tenant: StrictStr,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FlowForExecution]:
        """Get flow information's for an execution


        :param namespace: The namespace of the flow (required)
        :type namespace: str
        :param flow_id: The flow id (required)
        :type flow_id: str
        :param tenant: (required)
        :type tenant: str
        :param revision: The flow revision
        :type revision: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_flow_from_execution_serialize(
            namespace=namespace,
            flow_id=flow_id,
            tenant=tenant,
            revision=revision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowForExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_flow_from_execution_without_preload_content(
        self,
        namespace: Annotated[StrictStr, Field(description="The namespace of the flow")],
        flow_id: Annotated[StrictStr, Field(description="The flow id")],
        tenant: StrictStr,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get flow information's for an execution


        :param namespace: The namespace of the flow (required)
        :type namespace: str
        :param flow_id: The flow id (required)
        :type flow_id: str
        :param tenant: (required)
        :type tenant: str
        :param revision: The flow revision
        :type revision: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_flow_from_execution_serialize(
            namespace=namespace,
            flow_id=flow_id,
            tenant=tenant,
            revision=revision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowForExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_flow_from_execution_serialize(
        self,
        namespace,
        flow_id,
        tenant,
        revision,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if flow_id is not None:
            _path_params['flowId'] = flow_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if revision is not None:
            
            _query_params.append(('revision', revision))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/flows/{namespace}/{flowId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_flow_from_execution_by_id(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution that you want flow informations")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FlowForExecution:
        """Get flow information's for an execution


        :param execution_id: The execution that you want flow informations (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_flow_from_execution_by_id_serialize(
            execution_id=execution_id,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowForExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_flow_from_execution_by_id_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution that you want flow informations")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FlowForExecution]:
        """Get flow information's for an execution


        :param execution_id: The execution that you want flow informations (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_flow_from_execution_by_id_serialize(
            execution_id=execution_id,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowForExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_flow_from_execution_by_id_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution that you want flow informations")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get flow information's for an execution


        :param execution_id: The execution that you want flow informations (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_flow_from_execution_by_id_serialize(
            execution_id=execution_id,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowForExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_flow_from_execution_by_id_serialize(
        self,
        execution_id,
        tenant,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/{executionId}/flow',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_latest_executions(
        self,
        tenant: StrictStr,
        execution_repository_interface_flow_filter: List[ExecutionRepositoryInterfaceFlowFilter],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ExecutionControllerLastExecutionResponse]:
        """Get the latest execution for given flows


        :param tenant: (required)
        :type tenant: str
        :param execution_repository_interface_flow_filter: (required)
        :type execution_repository_interface_flow_filter: List[ExecutionRepositoryInterfaceFlowFilter]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_latest_executions_serialize(
            tenant=tenant,
            execution_repository_interface_flow_filter=execution_repository_interface_flow_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ExecutionControllerLastExecutionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_latest_executions_with_http_info(
        self,
        tenant: StrictStr,
        execution_repository_interface_flow_filter: List[ExecutionRepositoryInterfaceFlowFilter],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ExecutionControllerLastExecutionResponse]]:
        """Get the latest execution for given flows


        :param tenant: (required)
        :type tenant: str
        :param execution_repository_interface_flow_filter: (required)
        :type execution_repository_interface_flow_filter: List[ExecutionRepositoryInterfaceFlowFilter]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_latest_executions_serialize(
            tenant=tenant,
            execution_repository_interface_flow_filter=execution_repository_interface_flow_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ExecutionControllerLastExecutionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_latest_executions_without_preload_content(
        self,
        tenant: StrictStr,
        execution_repository_interface_flow_filter: List[ExecutionRepositoryInterfaceFlowFilter],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the latest execution for given flows


        :param tenant: (required)
        :type tenant: str
        :param execution_repository_interface_flow_filter: (required)
        :type execution_repository_interface_flow_filter: List[ExecutionRepositoryInterfaceFlowFilter]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_latest_executions_serialize(
            tenant=tenant,
            execution_repository_interface_flow_filter=execution_repository_interface_flow_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ExecutionControllerLastExecutionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_latest_executions_serialize(
        self,
        tenant,
        execution_repository_interface_flow_filter,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ExecutionRepositoryInterfaceFlowFilter': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if execution_repository_interface_flow_filter is not None:
            _body_params = execution_repository_interface_flow_filter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/latest',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def kill_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        is_on_kill_cascade: Annotated[StrictBool, Field(description="Specifies whether killing the execution also kill all subflow executions.")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Kill an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param is_on_kill_cascade: Specifies whether killing the execution also kill all subflow executions. (required)
        :type is_on_kill_cascade: bool
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._kill_execution_serialize(
            execution_id=execution_id,
            is_on_kill_cascade=is_on_kill_cascade,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': None,
            '409': None,
            '404': None,
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def kill_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        is_on_kill_cascade: Annotated[StrictBool, Field(description="Specifies whether killing the execution also kill all subflow executions.")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Kill an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param is_on_kill_cascade: Specifies whether killing the execution also kill all subflow executions. (required)
        :type is_on_kill_cascade: bool
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._kill_execution_serialize(
            execution_id=execution_id,
            is_on_kill_cascade=is_on_kill_cascade,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': None,
            '409': None,
            '404': None,
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def kill_execution_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        is_on_kill_cascade: Annotated[StrictBool, Field(description="Specifies whether killing the execution also kill all subflow executions.")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Kill an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param is_on_kill_cascade: Specifies whether killing the execution also kill all subflow executions. (required)
        :type is_on_kill_cascade: bool
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._kill_execution_serialize(
            execution_id=execution_id,
            is_on_kill_cascade=is_on_kill_cascade,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': None,
            '409': None,
            '404': None,
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _kill_execution_serialize(
        self,
        execution_id,
        is_on_kill_cascade,
        tenant,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if is_on_kill_cascade is not None:
            
            _query_params.append(('isOnKillCascade', is_on_kill_cascade))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v1/{tenant}/executions/{executionId}/kill',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def kill_executions_by_ids(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BulkResponse:
        """Kill a list of executions


        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._kill_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def kill_executions_by_ids_with_http_info(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BulkResponse]:
        """Kill a list of executions


        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._kill_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def kill_executions_by_ids_without_preload_content(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Kill a list of executions


        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._kill_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _kill_executions_by_ids_serialize(
        self,
        tenant,
        request_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v1/{tenant}/executions/kill/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def kill_executions_by_query(
        self,
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Kill executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._kill_executions_by_query_serialize(
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def kill_executions_by_query_with_http_info(
        self,
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Kill executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._kill_executions_by_query_serialize(
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def kill_executions_by_query_without_preload_content(
        self,
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Kill executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._kill_executions_by_query_serialize(
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _kill_executions_by_query_serialize(
        self,
        tenant,
        delete_executions_by_query_request,
        q,
        scope,
        namespace,
        flow_id,
        start_date,
        end_date,
        time_range,
        state,
        labels,
        trigger_execution_id,
        child_filter,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'scope': 'csv',
            'state': 'csv',
            'labels': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if q is not None:
            
            _query_params.append(('q', q))
            
        if scope is not None:
            
            _query_params.append(('scope', scope))
            
        if namespace is not None:
            
            _query_params.append(('namespace', namespace))
            
        if flow_id is not None:
            
            _query_params.append(('flowId', flow_id))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'startDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'endDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('endDate', end_date))
            
        if time_range is not None:
            
            _query_params.append(('timeRange', time_range))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if labels is not None:
            
            _query_params.append(('labels', labels))
            
        if trigger_execution_id is not None:
            
            _query_params.append(('triggerExecutionId', trigger_execution_id))
            
        if child_filter is not None:
            
            _query_params.append(('childFilter', child_filter.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if delete_executions_by_query_request is not None:
            _body_params = delete_executions_by_query_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v1/{tenant}/executions/kill/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_executable_distinct_namespaces(
        self,
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[str]:
        """Get all namespaces that have executable flows


        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_executable_distinct_namespaces_serialize(
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_executable_distinct_namespaces_with_http_info(
        self,
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[str]]:
        """Get all namespaces that have executable flows


        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_executable_distinct_namespaces_serialize(
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_executable_distinct_namespaces_without_preload_content(
        self,
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all namespaces that have executable flows


        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_executable_distinct_namespaces_serialize(
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_executable_distinct_namespaces_serialize(
        self,
        tenant,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/namespaces',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_flow_executions_by_namespace(
        self,
        namespace: Annotated[StrictStr, Field(description="The namespace")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[FlowForExecution]:
        """Get all flow ids for a namespace. Data returned are FlowForExecution containing minimal information about a Flow for when you are allowed to executing but not reading.


        :param namespace: The namespace (required)
        :type namespace: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_flow_executions_by_namespace_serialize(
            namespace=namespace,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FlowForExecution]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_flow_executions_by_namespace_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The namespace")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[FlowForExecution]]:
        """Get all flow ids for a namespace. Data returned are FlowForExecution containing minimal information about a Flow for when you are allowed to executing but not reading.


        :param namespace: The namespace (required)
        :type namespace: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_flow_executions_by_namespace_serialize(
            namespace=namespace,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FlowForExecution]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_flow_executions_by_namespace_without_preload_content(
        self,
        namespace: Annotated[StrictStr, Field(description="The namespace")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all flow ids for a namespace. Data returned are FlowForExecution containing minimal information about a Flow for when you are allowed to executing but not reading.


        :param namespace: The namespace (required)
        :type namespace: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_flow_executions_by_namespace_serialize(
            namespace=namespace,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FlowForExecution]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_flow_executions_by_namespace_serialize(
        self,
        namespace,
        tenant,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/namespaces/{namespace}/flows',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def pause_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Pause a running execution.


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pause_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '409': None,
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def pause_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Pause a running execution.


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pause_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '409': None,
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def pause_execution_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Pause a running execution.


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pause_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '409': None,
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _pause_execution_serialize(
        self,
        execution_id,
        tenant,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/pause',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def pause_executions_by_ids(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BulkResponse:
        """Pause a list of running executions


        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pause_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def pause_executions_by_ids_with_http_info(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BulkResponse]:
        """Pause a list of running executions


        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pause_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def pause_executions_by_ids_without_preload_content(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Pause a list of running executions


        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pause_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _pause_executions_by_ids_serialize(
        self,
        tenant,
        request_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/pause/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def pause_executions_by_query(
        self,
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Pause executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pause_executions_by_query_serialize(
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def pause_executions_by_query_with_http_info(
        self,
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Pause executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pause_executions_by_query_serialize(
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def pause_executions_by_query_without_preload_content(
        self,
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Pause executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pause_executions_by_query_serialize(
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _pause_executions_by_query_serialize(
        self,
        tenant,
        delete_executions_by_query_request,
        q,
        scope,
        namespace,
        flow_id,
        start_date,
        end_date,
        time_range,
        state,
        labels,
        trigger_execution_id,
        child_filter,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'scope': 'csv',
            'state': 'csv',
            'labels': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if q is not None:
            
            _query_params.append(('q', q))
            
        if scope is not None:
            
            _query_params.append(('scope', scope))
            
        if namespace is not None:
            
            _query_params.append(('namespace', namespace))
            
        if flow_id is not None:
            
            _query_params.append(('flowId', flow_id))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'startDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'endDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('endDate', end_date))
            
        if time_range is not None:
            
            _query_params.append(('timeRange', time_range))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if labels is not None:
            
            _query_params.append(('labels', labels))
            
        if trigger_execution_id is not None:
            
            _query_params.append(('triggerExecutionId', trigger_execution_id))
            
        if child_filter is not None:
            
            _query_params.append(('childFilter', child_filter.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if delete_executions_by_query_request is not None:
            _body_params = delete_executions_by_query_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/pause/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def preview_file_from_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        path: Annotated[StrictStr, Field(description="The internal storage uri")],
        max_rows: Annotated[StrictInt, Field(description="The max row returns")],
        encoding: Annotated[StrictStr, Field(description="The file encoding as Java charset name. Defaults to UTF-8")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Get file preview for an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param path: The internal storage uri (required)
        :type path: str
        :param max_rows: The max row returns (required)
        :type max_rows: int
        :param encoding: The file encoding as Java charset name. Defaults to UTF-8 (required)
        :type encoding: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._preview_file_from_execution_serialize(
            execution_id=execution_id,
            path=path,
            max_rows=max_rows,
            encoding=encoding,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def preview_file_from_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        path: Annotated[StrictStr, Field(description="The internal storage uri")],
        max_rows: Annotated[StrictInt, Field(description="The max row returns")],
        encoding: Annotated[StrictStr, Field(description="The file encoding as Java charset name. Defaults to UTF-8")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Get file preview for an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param path: The internal storage uri (required)
        :type path: str
        :param max_rows: The max row returns (required)
        :type max_rows: int
        :param encoding: The file encoding as Java charset name. Defaults to UTF-8 (required)
        :type encoding: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._preview_file_from_execution_serialize(
            execution_id=execution_id,
            path=path,
            max_rows=max_rows,
            encoding=encoding,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def preview_file_from_execution_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        path: Annotated[StrictStr, Field(description="The internal storage uri")],
        max_rows: Annotated[StrictInt, Field(description="The max row returns")],
        encoding: Annotated[StrictStr, Field(description="The file encoding as Java charset name. Defaults to UTF-8")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get file preview for an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param path: The internal storage uri (required)
        :type path: str
        :param max_rows: The max row returns (required)
        :type max_rows: int
        :param encoding: The file encoding as Java charset name. Defaults to UTF-8 (required)
        :type encoding: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._preview_file_from_execution_serialize(
            execution_id=execution_id,
            path=path,
            max_rows=max_rows,
            encoding=encoding,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _preview_file_from_execution_serialize(
        self,
        execution_id,
        path,
        max_rows,
        encoding,
        tenant,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if path is not None:
            
            _query_params.append(('path', path))
            
        if max_rows is not None:
            
            _query_params.append(('maxRows', max_rows))
            
        if encoding is not None:
            
            _query_params.append(('encoding', encoding))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/{executionId}/file/preview',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def replay_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="the original execution id to clone")],
        tenant: StrictStr,
        task_run_id: Annotated[Optional[StrictStr], Field(description="The taskrun id")] = None,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision to use for new execution")] = None,
        breakpoints: Annotated[Optional[StrictStr], Field(description="Set a list of breakpoints at specific tasks 'id.value', separated by a coma.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Execution:
        """Create a new execution from an old one and start it from a specified task run id


        :param execution_id: the original execution id to clone (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param task_run_id: The taskrun id
        :type task_run_id: str
        :param revision: The flow revision to use for new execution
        :type revision: int
        :param breakpoints: Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
        :type breakpoints: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._replay_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            task_run_id=task_run_id,
            revision=revision,
            breakpoints=breakpoints,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def replay_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="the original execution id to clone")],
        tenant: StrictStr,
        task_run_id: Annotated[Optional[StrictStr], Field(description="The taskrun id")] = None,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision to use for new execution")] = None,
        breakpoints: Annotated[Optional[StrictStr], Field(description="Set a list of breakpoints at specific tasks 'id.value', separated by a coma.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Execution]:
        """Create a new execution from an old one and start it from a specified task run id


        :param execution_id: the original execution id to clone (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param task_run_id: The taskrun id
        :type task_run_id: str
        :param revision: The flow revision to use for new execution
        :type revision: int
        :param breakpoints: Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
        :type breakpoints: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._replay_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            task_run_id=task_run_id,
            revision=revision,
            breakpoints=breakpoints,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def replay_execution_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="the original execution id to clone")],
        tenant: StrictStr,
        task_run_id: Annotated[Optional[StrictStr], Field(description="The taskrun id")] = None,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision to use for new execution")] = None,
        breakpoints: Annotated[Optional[StrictStr], Field(description="Set a list of breakpoints at specific tasks 'id.value', separated by a coma.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create a new execution from an old one and start it from a specified task run id


        :param execution_id: the original execution id to clone (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param task_run_id: The taskrun id
        :type task_run_id: str
        :param revision: The flow revision to use for new execution
        :type revision: int
        :param breakpoints: Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
        :type breakpoints: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._replay_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            task_run_id=task_run_id,
            revision=revision,
            breakpoints=breakpoints,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _replay_execution_serialize(
        self,
        execution_id,
        tenant,
        task_run_id,
        revision,
        breakpoints,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if task_run_id is not None:
            
            _query_params.append(('taskRunId', task_run_id))
            
        if revision is not None:
            
            _query_params.append(('revision', revision))
            
        if breakpoints is not None:
            
            _query_params.append(('breakpoints', breakpoints))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/replay',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def replay_execution_withinputs(
        self,
        execution_id: Annotated[StrictStr, Field(description="the original execution id to clone")],
        tenant: StrictStr,
        task_run_id: Annotated[Optional[StrictStr], Field(description="The taskrun id")] = None,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision to use for new execution")] = None,
        breakpoints: Annotated[Optional[StrictStr], Field(description="Set a list of breakpoints at specific tasks 'id.value', separated by a coma.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Execution:
        """Create a new execution from an old one and start it from a specified task run id


        :param execution_id: the original execution id to clone (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param task_run_id: The taskrun id
        :type task_run_id: str
        :param revision: The flow revision to use for new execution
        :type revision: int
        :param breakpoints: Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
        :type breakpoints: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._replay_execution_withinputs_serialize(
            execution_id=execution_id,
            tenant=tenant,
            task_run_id=task_run_id,
            revision=revision,
            breakpoints=breakpoints,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def replay_execution_withinputs_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="the original execution id to clone")],
        tenant: StrictStr,
        task_run_id: Annotated[Optional[StrictStr], Field(description="The taskrun id")] = None,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision to use for new execution")] = None,
        breakpoints: Annotated[Optional[StrictStr], Field(description="Set a list of breakpoints at specific tasks 'id.value', separated by a coma.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Execution]:
        """Create a new execution from an old one and start it from a specified task run id


        :param execution_id: the original execution id to clone (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param task_run_id: The taskrun id
        :type task_run_id: str
        :param revision: The flow revision to use for new execution
        :type revision: int
        :param breakpoints: Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
        :type breakpoints: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._replay_execution_withinputs_serialize(
            execution_id=execution_id,
            tenant=tenant,
            task_run_id=task_run_id,
            revision=revision,
            breakpoints=breakpoints,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def replay_execution_withinputs_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="the original execution id to clone")],
        tenant: StrictStr,
        task_run_id: Annotated[Optional[StrictStr], Field(description="The taskrun id")] = None,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision to use for new execution")] = None,
        breakpoints: Annotated[Optional[StrictStr], Field(description="Set a list of breakpoints at specific tasks 'id.value', separated by a coma.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create a new execution from an old one and start it from a specified task run id


        :param execution_id: the original execution id to clone (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param task_run_id: The taskrun id
        :type task_run_id: str
        :param revision: The flow revision to use for new execution
        :type revision: int
        :param breakpoints: Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
        :type breakpoints: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._replay_execution_withinputs_serialize(
            execution_id=execution_id,
            tenant=tenant,
            task_run_id=task_run_id,
            revision=revision,
            breakpoints=breakpoints,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _replay_execution_withinputs_serialize(
        self,
        execution_id,
        tenant,
        task_run_id,
        revision,
        breakpoints,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if task_run_id is not None:
            
            _query_params.append(('taskRunId', task_run_id))
            
        if revision is not None:
            
            _query_params.append(('revision', revision))
            
        if breakpoints is not None:
            
            _query_params.append(('breakpoints', breakpoints))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/replay-with-inputs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def replay_executions_by_ids(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        latest_revision: Annotated[Optional[StrictBool], Field(description="If latest revision should be used")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BulkResponse:
        """Create new executions from old ones. Keep the flow revision


        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param latest_revision: If latest revision should be used
        :type latest_revision: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._replay_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
            latest_revision=latest_revision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def replay_executions_by_ids_with_http_info(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        latest_revision: Annotated[Optional[StrictBool], Field(description="If latest revision should be used")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BulkResponse]:
        """Create new executions from old ones. Keep the flow revision


        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param latest_revision: If latest revision should be used
        :type latest_revision: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._replay_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
            latest_revision=latest_revision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def replay_executions_by_ids_without_preload_content(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        latest_revision: Annotated[Optional[StrictBool], Field(description="If latest revision should be used")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create new executions from old ones. Keep the flow revision


        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param latest_revision: If latest revision should be used
        :type latest_revision: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._replay_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
            latest_revision=latest_revision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _replay_executions_by_ids_serialize(
        self,
        tenant,
        request_body,
        latest_revision,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if latest_revision is not None:
            
            _query_params.append(('latestRevision', latest_revision))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/replay/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def replay_executions_by_query(
        self,
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        latest_revision: Annotated[Optional[StrictBool], Field(description="If latest revision should be used")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Create new executions from old ones filter by query parameters. Keep the flow revision


        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param latest_revision: If latest revision should be used
        :type latest_revision: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._replay_executions_by_query_serialize(
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            latest_revision=latest_revision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def replay_executions_by_query_with_http_info(
        self,
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        latest_revision: Annotated[Optional[StrictBool], Field(description="If latest revision should be used")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Create new executions from old ones filter by query parameters. Keep the flow revision


        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param latest_revision: If latest revision should be used
        :type latest_revision: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._replay_executions_by_query_serialize(
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            latest_revision=latest_revision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def replay_executions_by_query_without_preload_content(
        self,
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        latest_revision: Annotated[Optional[StrictBool], Field(description="If latest revision should be used")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create new executions from old ones filter by query parameters. Keep the flow revision


        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param latest_revision: If latest revision should be used
        :type latest_revision: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._replay_executions_by_query_serialize(
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            latest_revision=latest_revision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _replay_executions_by_query_serialize(
        self,
        tenant,
        delete_executions_by_query_request,
        q,
        scope,
        namespace,
        flow_id,
        start_date,
        end_date,
        time_range,
        state,
        labels,
        trigger_execution_id,
        child_filter,
        latest_revision,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'scope': 'csv',
            'state': 'csv',
            'labels': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if q is not None:
            
            _query_params.append(('q', q))
            
        if scope is not None:
            
            _query_params.append(('scope', scope))
            
        if namespace is not None:
            
            _query_params.append(('namespace', namespace))
            
        if flow_id is not None:
            
            _query_params.append(('flowId', flow_id))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'startDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'endDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('endDate', end_date))
            
        if time_range is not None:
            
            _query_params.append(('timeRange', time_range))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if labels is not None:
            
            _query_params.append(('labels', labels))
            
        if trigger_execution_id is not None:
            
            _query_params.append(('triggerExecutionId', trigger_execution_id))
            
        if child_filter is not None:
            
            _query_params.append(('childFilter', child_filter.value))
            
        if latest_revision is not None:
            
            _query_params.append(('latestRevision', latest_revision))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if delete_executions_by_query_request is not None:
            _body_params = delete_executions_by_query_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/replay/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def restart_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision to use for new execution")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Execution:
        """Restart a new execution from an old one


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param revision: The flow revision to use for new execution
        :type revision: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._restart_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            revision=revision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def restart_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision to use for new execution")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Execution]:
        """Restart a new execution from an old one


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param revision: The flow revision to use for new execution
        :type revision: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._restart_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            revision=revision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def restart_execution_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision to use for new execution")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Restart a new execution from an old one


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param revision: The flow revision to use for new execution
        :type revision: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._restart_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            revision=revision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _restart_execution_serialize(
        self,
        execution_id,
        tenant,
        revision,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if revision is not None:
            
            _query_params.append(('revision', revision))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/restart',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def restart_executions_by_ids(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BulkResponse:
        """Restart a list of executions


        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._restart_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def restart_executions_by_ids_with_http_info(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BulkResponse]:
        """Restart a list of executions


        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._restart_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def restart_executions_by_ids_without_preload_content(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Restart a list of executions


        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._restart_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _restart_executions_by_ids_serialize(
        self,
        tenant,
        request_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/restart/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def restart_executions_by_query(
        self,
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Restart executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._restart_executions_by_query_serialize(
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def restart_executions_by_query_with_http_info(
        self,
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Restart executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._restart_executions_by_query_serialize(
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def restart_executions_by_query_without_preload_content(
        self,
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Restart executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._restart_executions_by_query_serialize(
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _restart_executions_by_query_serialize(
        self,
        tenant,
        delete_executions_by_query_request,
        q,
        scope,
        namespace,
        flow_id,
        start_date,
        end_date,
        time_range,
        state,
        labels,
        trigger_execution_id,
        child_filter,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'scope': 'csv',
            'state': 'csv',
            'labels': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if q is not None:
            
            _query_params.append(('q', q))
            
        if scope is not None:
            
            _query_params.append(('scope', scope))
            
        if namespace is not None:
            
            _query_params.append(('namespace', namespace))
            
        if flow_id is not None:
            
            _query_params.append(('flowId', flow_id))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'startDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'endDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('endDate', end_date))
            
        if time_range is not None:
            
            _query_params.append(('timeRange', time_range))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if labels is not None:
            
            _query_params.append(('labels', labels))
            
        if trigger_execution_id is not None:
            
            _query_params.append(('triggerExecutionId', trigger_execution_id))
            
        if child_filter is not None:
            
            _query_params.append(('childFilter', child_filter.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if delete_executions_by_query_request is not None:
            _body_params = delete_executions_by_query_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/restart/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def resume_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Resume a paused execution.


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resume_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '409': None,
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resume_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Resume a paused execution.


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resume_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '409': None,
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def resume_execution_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Resume a paused execution.


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resume_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '409': None,
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _resume_execution_serialize(
        self,
        execution_id,
        tenant,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/resume',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def resume_execution_from_breakpoint(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        breakpoints: Annotated[Optional[StrictStr], Field(description="\"Set a list of breakpoints at specific tasks 'id.value', separated by a coma.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Resume an execution from a breakpoint (in the 'BREAKPOINT' state).


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param breakpoints: \"Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
        :type breakpoints: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resume_execution_from_breakpoint_serialize(
            execution_id=execution_id,
            tenant=tenant,
            breakpoints=breakpoints,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '409': None,
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resume_execution_from_breakpoint_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        breakpoints: Annotated[Optional[StrictStr], Field(description="\"Set a list of breakpoints at specific tasks 'id.value', separated by a coma.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Resume an execution from a breakpoint (in the 'BREAKPOINT' state).


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param breakpoints: \"Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
        :type breakpoints: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resume_execution_from_breakpoint_serialize(
            execution_id=execution_id,
            tenant=tenant,
            breakpoints=breakpoints,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '409': None,
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def resume_execution_from_breakpoint_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        breakpoints: Annotated[Optional[StrictStr], Field(description="\"Set a list of breakpoints at specific tasks 'id.value', separated by a coma.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Resume an execution from a breakpoint (in the 'BREAKPOINT' state).


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param breakpoints: \"Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
        :type breakpoints: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resume_execution_from_breakpoint_serialize(
            execution_id=execution_id,
            tenant=tenant,
            breakpoints=breakpoints,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '409': None,
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _resume_execution_from_breakpoint_serialize(
        self,
        execution_id,
        tenant,
        breakpoints,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if breakpoints is not None:
            
            _query_params.append(('breakpoints', breakpoints))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/resume-from-breakpoint',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def resume_executions_by_ids(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BulkResponse:
        """Resume a list of paused executions


        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resume_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resume_executions_by_ids_with_http_info(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BulkResponse]:
        """Resume a list of paused executions


        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resume_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def resume_executions_by_ids_without_preload_content(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Resume a list of paused executions


        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resume_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _resume_executions_by_ids_serialize(
        self,
        tenant,
        request_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/resume/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def resume_executions_by_query(
        self,
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Resume executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resume_executions_by_query_serialize(
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resume_executions_by_query_with_http_info(
        self,
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Resume executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resume_executions_by_query_serialize(
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def resume_executions_by_query_without_preload_content(
        self,
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Resume executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resume_executions_by_query_serialize(
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _resume_executions_by_query_serialize(
        self,
        tenant,
        delete_executions_by_query_request,
        q,
        scope,
        namespace,
        flow_id,
        start_date,
        end_date,
        time_range,
        state,
        labels,
        trigger_execution_id,
        child_filter,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'scope': 'csv',
            'state': 'csv',
            'labels': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if q is not None:
            
            _query_params.append(('q', q))
            
        if scope is not None:
            
            _query_params.append(('scope', scope))
            
        if namespace is not None:
            
            _query_params.append(('namespace', namespace))
            
        if flow_id is not None:
            
            _query_params.append(('flowId', flow_id))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'startDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'endDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('endDate', end_date))
            
        if time_range is not None:
            
            _query_params.append(('timeRange', time_range))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if labels is not None:
            
            _query_params.append(('labels', labels))
            
        if trigger_execution_id is not None:
            
            _query_params.append(('triggerExecutionId', trigger_execution_id))
            
        if child_filter is not None:
            
            _query_params.append(('childFilter', child_filter.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if delete_executions_by_query_request is not None:
            _body_params = delete_executions_by_query_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/resume/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_executions(
        self,
        page: Annotated[int, Field(strict=True, ge=1, description="The current page")],
        size: Annotated[int, Field(strict=True, ge=1, description="The current page size")],
        tenant: StrictStr,
        sort: Annotated[Optional[List[StrictStr]], Field(description="The sort of current page")] = None,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PagedResultsExecution:
        """Search for executions


        :param page: The current page (required)
        :type page: int
        :param size: The current page size (required)
        :type size: int
        :param tenant: (required)
        :type tenant: str
        :param sort: The sort of current page
        :type sort: List[str]
        :param filters: Filters
        :type filters: List[QueryFilter]
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_executions_serialize(
            page=page,
            size=size,
            tenant=tenant,
            sort=sort,
            filters=filters,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedResultsExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_executions_with_http_info(
        self,
        page: Annotated[int, Field(strict=True, ge=1, description="The current page")],
        size: Annotated[int, Field(strict=True, ge=1, description="The current page size")],
        tenant: StrictStr,
        sort: Annotated[Optional[List[StrictStr]], Field(description="The sort of current page")] = None,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PagedResultsExecution]:
        """Search for executions


        :param page: The current page (required)
        :type page: int
        :param size: The current page size (required)
        :type size: int
        :param tenant: (required)
        :type tenant: str
        :param sort: The sort of current page
        :type sort: List[str]
        :param filters: Filters
        :type filters: List[QueryFilter]
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_executions_serialize(
            page=page,
            size=size,
            tenant=tenant,
            sort=sort,
            filters=filters,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedResultsExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_executions_without_preload_content(
        self,
        page: Annotated[int, Field(strict=True, ge=1, description="The current page")],
        size: Annotated[int, Field(strict=True, ge=1, description="The current page size")],
        tenant: StrictStr,
        sort: Annotated[Optional[List[StrictStr]], Field(description="The sort of current page")] = None,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search for executions


        :param page: The current page (required)
        :type page: int
        :param size: The current page size (required)
        :type size: int
        :param tenant: (required)
        :type tenant: str
        :param sort: The sort of current page
        :type sort: List[str]
        :param filters: Filters
        :type filters: List[QueryFilter]
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_executions_serialize(
            page=page,
            size=size,
            tenant=tenant,
            sort=sort,
            filters=filters,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedResultsExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_executions_serialize(
        self,
        page,
        size,
        tenant,
        sort,
        filters,
        q,
        scope,
        namespace,
        flow_id,
        start_date,
        end_date,
        time_range,
        state,
        labels,
        trigger_execution_id,
        child_filter,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'csv',
            'filters': 'csv',
            'scope': 'csv',
            'state': 'csv',
            'labels': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if scope is not None:
            
            _query_params.append(('scope', scope))
            
        if namespace is not None:
            
            _query_params.append(('namespace', namespace))
            
        if flow_id is not None:
            
            _query_params.append(('flowId', flow_id))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'startDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'endDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('endDate', end_date))
            
        if time_range is not None:
            
            _query_params.append(('timeRange', time_range))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if labels is not None:
            
            _query_params.append(('labels', labels))
            
        if trigger_execution_id is not None:
            
            _query_params.append(('triggerExecutionId', trigger_execution_id))
            
        if child_filter is not None:
            
            _query_params.append(('childFilter', child_filter.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_executions_by_flow_id(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        flow_id: Annotated[StrictStr, Field(description="The flow id")],
        page: Annotated[int, Field(strict=True, ge=1, description="The current page")],
        size: Annotated[int, Field(strict=True, ge=1, description="The current page size")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PagedResultsExecution:
        """Search for executions for a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
        :param flow_id: The flow id (required)
        :type flow_id: str
        :param page: The current page (required)
        :type page: int
        :param size: The current page size (required)
        :type size: int
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_executions_by_flow_id_serialize(
            namespace=namespace,
            flow_id=flow_id,
            page=page,
            size=size,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedResultsExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_executions_by_flow_id_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        flow_id: Annotated[StrictStr, Field(description="The flow id")],
        page: Annotated[int, Field(strict=True, ge=1, description="The current page")],
        size: Annotated[int, Field(strict=True, ge=1, description="The current page size")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PagedResultsExecution]:
        """Search for executions for a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
        :param flow_id: The flow id (required)
        :type flow_id: str
        :param page: The current page (required)
        :type page: int
        :param size: The current page size (required)
        :type size: int
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_executions_by_flow_id_serialize(
            namespace=namespace,
            flow_id=flow_id,
            page=page,
            size=size,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedResultsExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_executions_by_flow_id_without_preload_content(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        flow_id: Annotated[StrictStr, Field(description="The flow id")],
        page: Annotated[int, Field(strict=True, ge=1, description="The current page")],
        size: Annotated[int, Field(strict=True, ge=1, description="The current page size")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search for executions for a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
        :param flow_id: The flow id (required)
        :type flow_id: str
        :param page: The current page (required)
        :type page: int
        :param size: The current page size (required)
        :type size: int
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_executions_by_flow_id_serialize(
            namespace=namespace,
            flow_id=flow_id,
            page=page,
            size=size,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedResultsExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_executions_by_flow_id_serialize(
        self,
        namespace,
        flow_id,
        page,
        size,
        tenant,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if namespace is not None:
            
            _query_params.append(('namespace', namespace))
            
        if flow_id is not None:
            
            _query_params.append(('flowId', flow_id))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_task_run(
        self,
        page: Annotated[int, Field(strict=True, ge=1, description="The current page")],
        size: Annotated[int, Field(strict=True, ge=1, description="The current page size")],
        tenant: StrictStr,
        sort: Annotated[Optional[List[StrictStr]], Field(description="The sort of current page")] = None,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PagedResultsTaskRun:
        """Search for taskruns, only available with the Elasticsearch repository


        :param page: The current page (required)
        :type page: int
        :param size: The current page size (required)
        :type size: int
        :param tenant: (required)
        :type tenant: str
        :param sort: The sort of current page
        :type sort: List[str]
        :param filters: Filters
        :type filters: List[QueryFilter]
        :param q: A string filter
        :type q: str
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_task_run_serialize(
            page=page,
            size=size,
            tenant=tenant,
            sort=sort,
            filters=filters,
            q=q,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedResultsTaskRun",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_task_run_with_http_info(
        self,
        page: Annotated[int, Field(strict=True, ge=1, description="The current page")],
        size: Annotated[int, Field(strict=True, ge=1, description="The current page size")],
        tenant: StrictStr,
        sort: Annotated[Optional[List[StrictStr]], Field(description="The sort of current page")] = None,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PagedResultsTaskRun]:
        """Search for taskruns, only available with the Elasticsearch repository


        :param page: The current page (required)
        :type page: int
        :param size: The current page size (required)
        :type size: int
        :param tenant: (required)
        :type tenant: str
        :param sort: The sort of current page
        :type sort: List[str]
        :param filters: Filters
        :type filters: List[QueryFilter]
        :param q: A string filter
        :type q: str
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_task_run_serialize(
            page=page,
            size=size,
            tenant=tenant,
            sort=sort,
            filters=filters,
            q=q,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedResultsTaskRun",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_task_run_without_preload_content(
        self,
        page: Annotated[int, Field(strict=True, ge=1, description="The current page")],
        size: Annotated[int, Field(strict=True, ge=1, description="The current page size")],
        tenant: StrictStr,
        sort: Annotated[Optional[List[StrictStr]], Field(description="The sort of current page")] = None,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search for taskruns, only available with the Elasticsearch repository


        :param page: The current page (required)
        :type page: int
        :param size: The current page size (required)
        :type size: int
        :param tenant: (required)
        :type tenant: str
        :param sort: The sort of current page
        :type sort: List[str]
        :param filters: Filters
        :type filters: List[QueryFilter]
        :param q: A string filter
        :type q: str
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_task_run_serialize(
            page=page,
            size=size,
            tenant=tenant,
            sort=sort,
            filters=filters,
            q=q,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedResultsTaskRun",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_task_run_serialize(
        self,
        page,
        size,
        tenant,
        sort,
        filters,
        q,
        namespace,
        flow_id,
        start_date,
        end_date,
        time_range,
        state,
        labels,
        trigger_execution_id,
        child_filter,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'csv',
            'filters': 'csv',
            'state': 'csv',
            'labels': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if namespace is not None:
            
            _query_params.append(('namespace', namespace))
            
        if flow_id is not None:
            
            _query_params.append(('flowId', flow_id))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'startDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'endDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('endDate', end_date))
            
        if time_range is not None:
            
            _query_params.append(('timeRange', time_range))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if labels is not None:
            
            _query_params.append(('labels', labels))
            
        if trigger_execution_id is not None:
            
            _query_params.append(('triggerExecutionId', trigger_execution_id))
            
        if child_filter is not None:
            
            _query_params.append(('childFilter', child_filter.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/taskruns/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def set_labels_on_terminated_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        label: Annotated[List[Label], Field(description="The labels to add to the execution")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Add or update labels of a terminated execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param label: The labels to add to the execution (required)
        :type label: List[Label]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._set_labels_on_terminated_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            label=label,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '404': None,
            '400': None,
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def set_labels_on_terminated_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        label: Annotated[List[Label], Field(description="The labels to add to the execution")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Add or update labels of a terminated execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param label: The labels to add to the execution (required)
        :type label: List[Label]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._set_labels_on_terminated_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            label=label,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '404': None,
            '400': None,
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def set_labels_on_terminated_execution_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        label: Annotated[List[Label], Field(description="The labels to add to the execution")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Add or update labels of a terminated execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param label: The labels to add to the execution (required)
        :type label: List[Label]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._set_labels_on_terminated_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            label=label,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '404': None,
            '400': None,
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _set_labels_on_terminated_execution_serialize(
        self,
        execution_id,
        tenant,
        label,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'Label': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if label is not None:
            _body_params = label


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/labels',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def set_labels_on_terminated_executions_by_ids(
        self,
        tenant: StrictStr,
        execution_controller_set_labels_by_ids_request: Annotated[ExecutionControllerSetLabelsByIdsRequest, Field(description="The request containing a list of labels and a list of executions")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BulkResponse:
        """Set labels on a list of executions


        :param tenant: (required)
        :type tenant: str
        :param execution_controller_set_labels_by_ids_request: The request containing a list of labels and a list of executions (required)
        :type execution_controller_set_labels_by_ids_request: ExecutionControllerSetLabelsByIdsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._set_labels_on_terminated_executions_by_ids_serialize(
            tenant=tenant,
            execution_controller_set_labels_by_ids_request=execution_controller_set_labels_by_ids_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def set_labels_on_terminated_executions_by_ids_with_http_info(
        self,
        tenant: StrictStr,
        execution_controller_set_labels_by_ids_request: Annotated[ExecutionControllerSetLabelsByIdsRequest, Field(description="The request containing a list of labels and a list of executions")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BulkResponse]:
        """Set labels on a list of executions


        :param tenant: (required)
        :type tenant: str
        :param execution_controller_set_labels_by_ids_request: The request containing a list of labels and a list of executions (required)
        :type execution_controller_set_labels_by_ids_request: ExecutionControllerSetLabelsByIdsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._set_labels_on_terminated_executions_by_ids_serialize(
            tenant=tenant,
            execution_controller_set_labels_by_ids_request=execution_controller_set_labels_by_ids_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def set_labels_on_terminated_executions_by_ids_without_preload_content(
        self,
        tenant: StrictStr,
        execution_controller_set_labels_by_ids_request: Annotated[ExecutionControllerSetLabelsByIdsRequest, Field(description="The request containing a list of labels and a list of executions")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Set labels on a list of executions


        :param tenant: (required)
        :type tenant: str
        :param execution_controller_set_labels_by_ids_request: The request containing a list of labels and a list of executions (required)
        :type execution_controller_set_labels_by_ids_request: ExecutionControllerSetLabelsByIdsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._set_labels_on_terminated_executions_by_ids_serialize(
            tenant=tenant,
            execution_controller_set_labels_by_ids_request=execution_controller_set_labels_by_ids_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _set_labels_on_terminated_executions_by_ids_serialize(
        self,
        tenant,
        execution_controller_set_labels_by_ids_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if execution_controller_set_labels_by_ids_request is not None:
            _body_params = execution_controller_set_labels_by_ids_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/labels/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def set_labels_on_terminated_executions_by_query(
        self,
        tenant: StrictStr,
        label: Annotated[List[Label], Field(description="The labels to add to the execution")],
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Set label on executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
        :param label: The labels to add to the execution (required)
        :type label: List[Label]
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._set_labels_on_terminated_executions_by_query_serialize(
            tenant=tenant,
            label=label,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def set_labels_on_terminated_executions_by_query_with_http_info(
        self,
        tenant: StrictStr,
        label: Annotated[List[Label], Field(description="The labels to add to the execution")],
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Set label on executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
        :param label: The labels to add to the execution (required)
        :type label: List[Label]
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._set_labels_on_terminated_executions_by_query_serialize(
            tenant=tenant,
            label=label,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def set_labels_on_terminated_executions_by_query_without_preload_content(
        self,
        tenant: StrictStr,
        label: Annotated[List[Label], Field(description="The labels to add to the execution")],
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Set label on executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
        :param label: The labels to add to the execution (required)
        :type label: List[Label]
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._set_labels_on_terminated_executions_by_query_serialize(
            tenant=tenant,
            label=label,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _set_labels_on_terminated_executions_by_query_serialize(
        self,
        tenant,
        label,
        q,
        scope,
        namespace,
        flow_id,
        start_date,
        end_date,
        time_range,
        state,
        labels,
        trigger_execution_id,
        child_filter,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'scope': 'csv',
            'state': 'csv',
            'labels': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if q is not None:
            
            _query_params.append(('q', q))
            
        if scope is not None:
            
            _query_params.append(('scope', scope))
            
        if namespace is not None:
            
            _query_params.append(('namespace', namespace))
            
        if flow_id is not None:
            
            _query_params.append(('flowId', flow_id))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'startDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'endDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('endDate', end_date))
            
        if time_range is not None:
            
            _query_params.append(('timeRange', time_range))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if labels is not None:
            
            _query_params.append(('labels', labels))
            
        if trigger_execution_id is not None:
            
            _query_params.append(('triggerExecutionId', trigger_execution_id))
            
        if child_filter is not None:
            
            _query_params.append(('childFilter', child_filter.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if label is not None:
            _body_params = label


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/labels/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def trigger_execution(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        wait: Annotated[StrictBool, Field(description="If the server will wait the end of the execution")],
        tenant: StrictStr,
        labels: Annotated[Optional[List[StrictStr]], Field(description="The labels as a list of 'key:value'")] = None,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision or latest if null")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ExecutionControllerExecutionResponse]:
        """Trigger a new execution for a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
        :param id: The flow id (required)
        :type id: str
        :param wait: If the server will wait the end of the execution (required)
        :type wait: bool
        :param tenant: (required)
        :type tenant: str
        :param labels: The labels as a list of 'key:value'
        :type labels: List[str]
        :param revision: The flow revision or latest if null
        :type revision: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trigger_execution_serialize(
            namespace=namespace,
            id=id,
            wait=wait,
            tenant=tenant,
            labels=labels,
            revision=revision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '409': None,
            '200': "List[ExecutionControllerExecutionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def trigger_execution_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        wait: Annotated[StrictBool, Field(description="If the server will wait the end of the execution")],
        tenant: StrictStr,
        labels: Annotated[Optional[List[StrictStr]], Field(description="The labels as a list of 'key:value'")] = None,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision or latest if null")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ExecutionControllerExecutionResponse]]:
        """Trigger a new execution for a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
        :param id: The flow id (required)
        :type id: str
        :param wait: If the server will wait the end of the execution (required)
        :type wait: bool
        :param tenant: (required)
        :type tenant: str
        :param labels: The labels as a list of 'key:value'
        :type labels: List[str]
        :param revision: The flow revision or latest if null
        :type revision: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trigger_execution_serialize(
            namespace=namespace,
            id=id,
            wait=wait,
            tenant=tenant,
            labels=labels,
            revision=revision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '409': None,
            '200': "List[ExecutionControllerExecutionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def trigger_execution_without_preload_content(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        wait: Annotated[StrictBool, Field(description="If the server will wait the end of the execution")],
        tenant: StrictStr,
        labels: Annotated[Optional[List[StrictStr]], Field(description="The labels as a list of 'key:value'")] = None,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision or latest if null")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Trigger a new execution for a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
        :param id: The flow id (required)
        :type id: str
        :param wait: If the server will wait the end of the execution (required)
        :type wait: bool
        :param tenant: (required)
        :type tenant: str
        :param labels: The labels as a list of 'key:value'
        :type labels: List[str]
        :param revision: The flow revision or latest if null
        :type revision: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trigger_execution_serialize(
            namespace=namespace,
            id=id,
            wait=wait,
            tenant=tenant,
            labels=labels,
            revision=revision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '409': None,
            '200': "List[ExecutionControllerExecutionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _trigger_execution_serialize(
        self,
        namespace,
        id,
        wait,
        tenant,
        labels,
        revision,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'labels': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if id is not None:
            _path_params['id'] = id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if labels is not None:
            
            _query_params.append(('labels', labels))
            
        if wait is not None:
            
            _query_params.append(('wait', wait))
            
        if revision is not None:
            
            _query_params.append(('revision', revision))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/trigger/{namespace}/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def trigger_execution_by_get_webhook(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        key: Annotated[StrictStr, Field(description="The webhook trigger uid")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ExecutionControllerWebhookResponse:
        """Trigger a new execution by GET webhook trigger


        :param namespace: The flow namespace (required)
        :type namespace: str
        :param id: The flow id (required)
        :type id: str
        :param key: The webhook trigger uid (required)
        :type key: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trigger_execution_by_get_webhook_serialize(
            namespace=namespace,
            id=id,
            key=key,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExecutionControllerWebhookResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def trigger_execution_by_get_webhook_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        key: Annotated[StrictStr, Field(description="The webhook trigger uid")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ExecutionControllerWebhookResponse]:
        """Trigger a new execution by GET webhook trigger


        :param namespace: The flow namespace (required)
        :type namespace: str
        :param id: The flow id (required)
        :type id: str
        :param key: The webhook trigger uid (required)
        :type key: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trigger_execution_by_get_webhook_serialize(
            namespace=namespace,
            id=id,
            key=key,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExecutionControllerWebhookResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def trigger_execution_by_get_webhook_without_preload_content(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        key: Annotated[StrictStr, Field(description="The webhook trigger uid")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Trigger a new execution by GET webhook trigger


        :param namespace: The flow namespace (required)
        :type namespace: str
        :param id: The flow id (required)
        :type id: str
        :param key: The webhook trigger uid (required)
        :type key: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trigger_execution_by_get_webhook_serialize(
            namespace=namespace,
            id=id,
            key=key,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExecutionControllerWebhookResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _trigger_execution_by_get_webhook_serialize(
        self,
        namespace,
        id,
        key,
        tenant,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if id is not None:
            _path_params['id'] = id
        if key is not None:
            _path_params['key'] = key
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/webhook/{namespace}/{id}/{key}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def trigger_execution_by_post_webhook(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        key: Annotated[StrictStr, Field(description="The webhook trigger uid")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ExecutionControllerWebhookResponse:
        """Trigger a new execution by POST webhook trigger


        :param namespace: The flow namespace (required)
        :type namespace: str
        :param id: The flow id (required)
        :type id: str
        :param key: The webhook trigger uid (required)
        :type key: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trigger_execution_by_post_webhook_serialize(
            namespace=namespace,
            id=id,
            key=key,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExecutionControllerWebhookResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def trigger_execution_by_post_webhook_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        key: Annotated[StrictStr, Field(description="The webhook trigger uid")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ExecutionControllerWebhookResponse]:
        """Trigger a new execution by POST webhook trigger


        :param namespace: The flow namespace (required)
        :type namespace: str
        :param id: The flow id (required)
        :type id: str
        :param key: The webhook trigger uid (required)
        :type key: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trigger_execution_by_post_webhook_serialize(
            namespace=namespace,
            id=id,
            key=key,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExecutionControllerWebhookResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def trigger_execution_by_post_webhook_without_preload_content(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        key: Annotated[StrictStr, Field(description="The webhook trigger uid")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Trigger a new execution by POST webhook trigger


        :param namespace: The flow namespace (required)
        :type namespace: str
        :param id: The flow id (required)
        :type id: str
        :param key: The webhook trigger uid (required)
        :type key: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trigger_execution_by_post_webhook_serialize(
            namespace=namespace,
            id=id,
            key=key,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExecutionControllerWebhookResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _trigger_execution_by_post_webhook_serialize(
        self,
        namespace,
        id,
        key,
        tenant,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if id is not None:
            _path_params['id'] = id
        if key is not None:
            _path_params['key'] = key
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/webhook/{namespace}/{id}/{key}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def trigger_execution_by_put_webhook(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        key: Annotated[StrictStr, Field(description="The webhook trigger uid")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ExecutionControllerWebhookResponse:
        """Trigger a new execution by PUT webhook trigger


        :param namespace: The flow namespace (required)
        :type namespace: str
        :param id: The flow id (required)
        :type id: str
        :param key: The webhook trigger uid (required)
        :type key: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trigger_execution_by_put_webhook_serialize(
            namespace=namespace,
            id=id,
            key=key,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExecutionControllerWebhookResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def trigger_execution_by_put_webhook_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        key: Annotated[StrictStr, Field(description="The webhook trigger uid")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ExecutionControllerWebhookResponse]:
        """Trigger a new execution by PUT webhook trigger


        :param namespace: The flow namespace (required)
        :type namespace: str
        :param id: The flow id (required)
        :type id: str
        :param key: The webhook trigger uid (required)
        :type key: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trigger_execution_by_put_webhook_serialize(
            namespace=namespace,
            id=id,
            key=key,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExecutionControllerWebhookResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def trigger_execution_by_put_webhook_without_preload_content(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        key: Annotated[StrictStr, Field(description="The webhook trigger uid")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Trigger a new execution by PUT webhook trigger


        :param namespace: The flow namespace (required)
        :type namespace: str
        :param id: The flow id (required)
        :type id: str
        :param key: The webhook trigger uid (required)
        :type key: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trigger_execution_by_put_webhook_serialize(
            namespace=namespace,
            id=id,
            key=key,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExecutionControllerWebhookResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _trigger_execution_by_put_webhook_serialize(
        self,
        namespace,
        id,
        key,
        tenant,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if id is not None:
            _path_params['id'] = id
        if key is not None:
            _path_params['key'] = key
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/v1/{tenant}/executions/webhook/{namespace}/{id}/{key}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def unqueue_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        state: Annotated[StateType, Field(description="The new state of the execution")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Execution:
        """Unqueue an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param state: The new state of the execution (required)
        :type state: StateType
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._unqueue_execution_serialize(
            execution_id=execution_id,
            state=state,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def unqueue_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        state: Annotated[StateType, Field(description="The new state of the execution")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Execution]:
        """Unqueue an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param state: The new state of the execution (required)
        :type state: StateType
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._unqueue_execution_serialize(
            execution_id=execution_id,
            state=state,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def unqueue_execution_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        state: Annotated[StateType, Field(description="The new state of the execution")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Unqueue an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param state: The new state of the execution (required)
        :type state: StateType
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._unqueue_execution_serialize(
            execution_id=execution_id,
            state=state,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _unqueue_execution_serialize(
        self,
        execution_id,
        state,
        tenant,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if state is not None:
            
            _query_params.append(('state', state.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/unqueue',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def unqueue_executions_by_ids(
        self,
        state: Annotated[StateType, Field(description="The new state of the unqueued executions")],
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BulkResponse:
        """Unqueue a list of executions


        :param state: The new state of the unqueued executions (required)
        :type state: StateType
        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._unqueue_executions_by_ids_serialize(
            state=state,
            tenant=tenant,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def unqueue_executions_by_ids_with_http_info(
        self,
        state: Annotated[StateType, Field(description="The new state of the unqueued executions")],
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BulkResponse]:
        """Unqueue a list of executions


        :param state: The new state of the unqueued executions (required)
        :type state: StateType
        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._unqueue_executions_by_ids_serialize(
            state=state,
            tenant=tenant,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def unqueue_executions_by_ids_without_preload_content(
        self,
        state: Annotated[StateType, Field(description="The new state of the unqueued executions")],
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Unqueue a list of executions


        :param state: The new state of the unqueued executions (required)
        :type state: StateType
        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._unqueue_executions_by_ids_serialize(
            state=state,
            tenant=tenant,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _unqueue_executions_by_ids_serialize(
        self,
        state,
        tenant,
        request_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if state is not None:
            
            _query_params.append(('state', state.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/unqueue/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def unqueue_executions_by_query(
        self,
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        new_state: Annotated[Optional[Any], Field(description="The new state of the unqueued executions")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Unqueue executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param new_state: The new state of the unqueued executions
        :type new_state: StateType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._unqueue_executions_by_query_serialize(
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            new_state=new_state,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def unqueue_executions_by_query_with_http_info(
        self,
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        new_state: Annotated[Optional[Any], Field(description="The new state of the unqueued executions")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Unqueue executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param new_state: The new state of the unqueued executions
        :type new_state: StateType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._unqueue_executions_by_query_serialize(
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            new_state=new_state,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def unqueue_executions_by_query_without_preload_content(
        self,
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        new_state: Annotated[Optional[Any], Field(description="The new state of the unqueued executions")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Unqueue executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param new_state: The new state of the unqueued executions
        :type new_state: StateType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._unqueue_executions_by_query_serialize(
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            new_state=new_state,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _unqueue_executions_by_query_serialize(
        self,
        tenant,
        delete_executions_by_query_request,
        q,
        scope,
        namespace,
        flow_id,
        start_date,
        end_date,
        time_range,
        state,
        labels,
        trigger_execution_id,
        child_filter,
        new_state,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'scope': 'csv',
            'state': 'csv',
            'labels': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if q is not None:
            
            _query_params.append(('q', q))
            
        if scope is not None:
            
            _query_params.append(('scope', scope))
            
        if namespace is not None:
            
            _query_params.append(('namespace', namespace))
            
        if flow_id is not None:
            
            _query_params.append(('flowId', flow_id))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'startDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'endDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('endDate', end_date))
            
        if time_range is not None:
            
            _query_params.append(('timeRange', time_range))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if labels is not None:
            
            _query_params.append(('labels', labels))
            
        if trigger_execution_id is not None:
            
            _query_params.append(('triggerExecutionId', trigger_execution_id))
            
        if child_filter is not None:
            
            _query_params.append(('childFilter', child_filter.value))
            
        if new_state is not None:
            
            _query_params.append(('newState', new_state.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if delete_executions_by_query_request is not None:
            _body_params = delete_executions_by_query_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/unqueue/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_execution_status(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        status: Annotated[StateType, Field(description="The new state of the execution")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Execution:
        """Change the state of an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param status: The new state of the execution (required)
        :type status: StateType
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_execution_status_serialize(
            execution_id=execution_id,
            status=status,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_execution_status_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        status: Annotated[StateType, Field(description="The new state of the execution")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Execution]:
        """Change the state of an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param status: The new state of the execution (required)
        :type status: StateType
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_execution_status_serialize(
            execution_id=execution_id,
            status=status,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_execution_status_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        status: Annotated[StateType, Field(description="The new state of the execution")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Change the state of an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param status: The new state of the execution (required)
        :type status: StateType
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_execution_status_serialize(
            execution_id=execution_id,
            status=status,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_execution_status_serialize(
        self,
        execution_id,
        status,
        tenant,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if status is not None:
            
            _query_params.append(('status', status.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/change-status',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_executions_status_by_ids(
        self,
        new_status: Annotated[StateType, Field(description="The new state of the executions")],
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BulkResponse:
        """Change executions state by id


        :param new_status: The new state of the executions (required)
        :type new_status: StateType
        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_executions_status_by_ids_serialize(
            new_status=new_status,
            tenant=tenant,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_executions_status_by_ids_with_http_info(
        self,
        new_status: Annotated[StateType, Field(description="The new state of the executions")],
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BulkResponse]:
        """Change executions state by id


        :param new_status: The new state of the executions (required)
        :type new_status: StateType
        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_executions_status_by_ids_serialize(
            new_status=new_status,
            tenant=tenant,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_executions_status_by_ids_without_preload_content(
        self,
        new_status: Annotated[StateType, Field(description="The new state of the executions")],
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Change executions state by id


        :param new_status: The new state of the executions (required)
        :type new_status: StateType
        :param tenant: (required)
        :type tenant: str
        :param request_body: The list of executions id (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_executions_status_by_ids_serialize(
            new_status=new_status,
            tenant=tenant,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_executions_status_by_ids_serialize(
        self,
        new_status,
        tenant,
        request_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if new_status is not None:
            
            _query_params.append(('newStatus', new_status.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/change-status/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_executions_status_by_query(
        self,
        new_status: Annotated[StateType, Field(description="The new state of the executions")],
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BulkResponse:
        """Change executions state by query parameters


        :param new_status: The new state of the executions (required)
        :type new_status: StateType
        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_executions_status_by_query_serialize(
            new_status=new_status,
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_executions_status_by_query_with_http_info(
        self,
        new_status: Annotated[StateType, Field(description="The new state of the executions")],
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BulkResponse]:
        """Change executions state by query parameters


        :param new_status: The new state of the executions (required)
        :type new_status: StateType
        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_executions_status_by_query_serialize(
            new_status=new_status,
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_executions_status_by_query_without_preload_content(
        self,
        new_status: Annotated[StateType, Field(description="The new state of the executions")],
        tenant: StrictStr,
        delete_executions_by_query_request: DeleteExecutionsByQueryRequest,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        scope: Annotated[Optional[List[FlowScope]], Field(description="The scope of the executions to include")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        flow_id: Annotated[Optional[StrictStr], Field(description="A flow id filter")] = None,
        start_date: Annotated[Optional[datetime], Field(description="The start datetime")] = None,
        end_date: Annotated[Optional[datetime], Field(description="The end datetime")] = None,
        time_range: Annotated[Optional[StrictStr], Field(description="A time range filter relative to the current time")] = None,
        state: Annotated[Optional[List[StateType]], Field(description="A state filter")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="A labels filter as a list of 'key:value'")] = None,
        trigger_execution_id: Annotated[Optional[StrictStr], Field(description="The trigger execution id")] = None,
        child_filter: Annotated[Optional[Any], Field(description="A execution child filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Change executions state by query parameters


        :param new_status: The new state of the executions (required)
        :type new_status: StateType
        :param tenant: (required)
        :type tenant: str
        :param delete_executions_by_query_request: (required)
        :type delete_executions_by_query_request: DeleteExecutionsByQueryRequest
        :param q: A string filter
        :type q: str
        :param scope: The scope of the executions to include
        :type scope: List[FlowScope]
        :param namespace: A namespace filter prefix
        :type namespace: str
        :param flow_id: A flow id filter
        :type flow_id: str
        :param start_date: The start datetime
        :type start_date: datetime
        :param end_date: The end datetime
        :type end_date: datetime
        :param time_range: A time range filter relative to the current time
        :type time_range: str
        :param state: A state filter
        :type state: List[StateType]
        :param labels: A labels filter as a list of 'key:value'
        :type labels: List[str]
        :param trigger_execution_id: The trigger execution id
        :type trigger_execution_id: str
        :param child_filter: A execution child filter
        :type child_filter: ExecutionRepositoryInterfaceChildFilter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_executions_status_by_query_serialize(
            new_status=new_status,
            tenant=tenant,
            delete_executions_by_query_request=delete_executions_by_query_request,
            q=q,
            scope=scope,
            namespace=namespace,
            flow_id=flow_id,
            start_date=start_date,
            end_date=end_date,
            time_range=time_range,
            state=state,
            labels=labels,
            trigger_execution_id=trigger_execution_id,
            child_filter=child_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_executions_status_by_query_serialize(
        self,
        new_status,
        tenant,
        delete_executions_by_query_request,
        q,
        scope,
        namespace,
        flow_id,
        start_date,
        end_date,
        time_range,
        state,
        labels,
        trigger_execution_id,
        child_filter,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'scope': 'csv',
            'state': 'csv',
            'labels': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if q is not None:
            
            _query_params.append(('q', q))
            
        if scope is not None:
            
            _query_params.append(('scope', scope))
            
        if namespace is not None:
            
            _query_params.append(('namespace', namespace))
            
        if flow_id is not None:
            
            _query_params.append(('flowId', flow_id))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'startDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'endDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('endDate', end_date))
            
        if time_range is not None:
            
            _query_params.append(('timeRange', time_range))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if labels is not None:
            
            _query_params.append(('labels', labels))
            
        if trigger_execution_id is not None:
            
            _query_params.append(('triggerExecutionId', trigger_execution_id))
            
        if child_filter is not None:
            
            _query_params.append(('childFilter', child_filter.value))
            
        if new_status is not None:
            
            _query_params.append(('newStatus', new_status.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if delete_executions_by_query_request is not None:
            _body_params = delete_executions_by_query_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/change-status/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_task_run_state(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        execution_controller_state_request: Annotated[ExecutionControllerStateRequest, Field(description="the taskRun id and state to apply")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Execution:
        """Change state for a taskrun in an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param execution_controller_state_request: the taskRun id and state to apply (required)
        :type execution_controller_state_request: ExecutionControllerStateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_task_run_state_serialize(
            execution_id=execution_id,
            tenant=tenant,
            execution_controller_state_request=execution_controller_state_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_task_run_state_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        execution_controller_state_request: Annotated[ExecutionControllerStateRequest, Field(description="the taskRun id and state to apply")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Execution]:
        """Change state for a taskrun in an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param execution_controller_state_request: the taskRun id and state to apply (required)
        :type execution_controller_state_request: ExecutionControllerStateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_task_run_state_serialize(
            execution_id=execution_id,
            tenant=tenant,
            execution_controller_state_request=execution_controller_state_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_task_run_state_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        execution_controller_state_request: Annotated[ExecutionControllerStateRequest, Field(description="the taskRun id and state to apply")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Change state for a taskrun in an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param execution_controller_state_request: the taskRun id and state to apply (required)
        :type execution_controller_state_request: ExecutionControllerStateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_task_run_state_serialize(
            execution_id=execution_id,
            tenant=tenant,
            execution_controller_state_request=execution_controller_state_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_task_run_state_serialize(
        self,
        execution_id,
        tenant,
        execution_controller_state_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if execution_controller_state_request is not None:
            _body_params = execution_controller_state_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/state',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def validate_new_execution_inputs(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        labels: Annotated[List[StrictStr], Field(description="The labels as a list of 'key:value'")],
        tenant: StrictStr,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision or latest if null")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ExecutionControllerApiValidateExecutionInputsResponse]:
        """Validate the creation of a new execution for a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
        :param id: The flow id (required)
        :type id: str
        :param labels: The labels as a list of 'key:value' (required)
        :type labels: List[str]
        :param tenant: (required)
        :type tenant: str
        :param revision: The flow revision or latest if null
        :type revision: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._validate_new_execution_inputs_serialize(
            namespace=namespace,
            id=id,
            labels=labels,
            tenant=tenant,
            revision=revision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '409': None,
            '200': "List[ExecutionControllerApiValidateExecutionInputsResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def validate_new_execution_inputs_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        labels: Annotated[List[StrictStr], Field(description="The labels as a list of 'key:value'")],
        tenant: StrictStr,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision or latest if null")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ExecutionControllerApiValidateExecutionInputsResponse]]:
        """Validate the creation of a new execution for a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
        :param id: The flow id (required)
        :type id: str
        :param labels: The labels as a list of 'key:value' (required)
        :type labels: List[str]
        :param tenant: (required)
        :type tenant: str
        :param revision: The flow revision or latest if null
        :type revision: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._validate_new_execution_inputs_serialize(
            namespace=namespace,
            id=id,
            labels=labels,
            tenant=tenant,
            revision=revision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '409': None,
            '200': "List[ExecutionControllerApiValidateExecutionInputsResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def validate_new_execution_inputs_without_preload_content(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        labels: Annotated[List[StrictStr], Field(description="The labels as a list of 'key:value'")],
        tenant: StrictStr,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision or latest if null")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Validate the creation of a new execution for a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
        :param id: The flow id (required)
        :type id: str
        :param labels: The labels as a list of 'key:value' (required)
        :type labels: List[str]
        :param tenant: (required)
        :type tenant: str
        :param revision: The flow revision or latest if null
        :type revision: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._validate_new_execution_inputs_serialize(
            namespace=namespace,
            id=id,
            labels=labels,
            tenant=tenant,
            revision=revision,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '409': None,
            '200': "List[ExecutionControllerApiValidateExecutionInputsResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _validate_new_execution_inputs_serialize(
        self,
        namespace,
        id,
        labels,
        tenant,
        revision,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'labels': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if id is not None:
            _path_params['id'] = id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if labels is not None:
            
            _query_params.append(('labels', labels))
            
        if revision is not None:
            
            _query_params.append(('revision', revision))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{namespace}/{id}/validate',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def validate_resume_execution_inputs(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ExecutionControllerApiValidateExecutionInputsResponse]:
        """Validate inputs to resume a paused execution.


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._validate_resume_execution_inputs_serialize(
            execution_id=execution_id,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '409': None,
            '200': "List[ExecutionControllerApiValidateExecutionInputsResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def validate_resume_execution_inputs_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ExecutionControllerApiValidateExecutionInputsResponse]]:
        """Validate inputs to resume a paused execution.


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._validate_resume_execution_inputs_serialize(
            execution_id=execution_id,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '409': None,
            '200': "List[ExecutionControllerApiValidateExecutionInputsResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def validate_resume_execution_inputs_without_preload_content(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Validate inputs to resume a paused execution.


        :param execution_id: The execution id (required)
        :type execution_id: str
        :param tenant: (required)
        :type tenant: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._validate_resume_execution_inputs_serialize(
            execution_id=execution_id,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '409': None,
            '200': "List[ExecutionControllerApiValidateExecutionInputsResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _validate_resume_execution_inputs_serialize(
        self,
        execution_id,
        tenant,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/resume/validate',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


    def follow_execution_sse(
            self,
            execution_id: Annotated[StrictStr, Field(description="The execution id")],
            tenant: StrictStr,
            _request_timeout: Optional[Union[float, Tuple[float, float]]] = None,
            _request_auth: Optional[Dict[StrictStr, Any]] = None,
            _content_type: Optional[StrictStr] = None,
            _headers: Optional[Dict[StrictStr, Any]] = None,
            _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Generator[Dict[str, Any], None, None]:
        """
        Follow an execution using SSE.

        This method establishes a persistent connection and yields
        EventExecution objects as they are streamed from the server,
        allowing to follow an execution in realtime.
        """

        _method, final_url, header_params, _body, _post_params = self._follow_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        header_params['Accept'] = 'text/event-stream'

        try:
            response = requests.get(
                final_url,
                headers=header_params,
                stream=True,
                timeout=_request_timeout
            )

            response.raise_for_status()

            client = sseclient.SSEClient(response)

            for event in client.events():
                if event.data is None or event.data == "":
                    continue

                yield json.loads(event.data)

        except requests.exceptions.RequestException as e:
            print(f"SSE connection failed: {e}")
            raise e
