

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import platform

# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_breez_sdk_bindings_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_breez_sdk_bindings_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_breez_sdk_bindings_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))
class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = itertools.count()

    def insert(self, obj):
        with self._lock:
            handle = next(self._counter)
            self._map[handle] = obj
            return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError("_UniffiHandleMap.get: Invalid handle")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError("_UniffiHandleMap.remove: Invalid handle")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("breez_sdk_bindings")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 26
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_breez_sdk_bindings_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_breez_sdk_bindings_checksum_func_connect() != 2295:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_func_default_config() != 38312:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_func_mnemonic_to_seed() != 19340:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_func_parse_input() != 46630:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_func_parse_invoice() != 64045:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_func_service_health_check() != 1079:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_func_set_log_stream() != 25613:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_func_static_backup() != 34455:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_backup() != 36004:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_backup_status() != 51417:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_buy_bitcoin() != 36346:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_check_message() != 43483:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_claim_reverse_swap() != 5979:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_close_lsp_channels() != 37352:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_configure_node() != 40371:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_connect_lsp() != 41822:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_disconnect() != 25385:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_execute_dev_command() != 16243:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_fetch_fiat_rates() != 38513:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_fetch_lsp_info() != 40985:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_fetch_reverse_swap_fees() != 56465:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_generate_diagnostic_data() != 22880:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_in_progress_onchain_payments() != 39619:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_in_progress_swap() != 64161:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_list_fiat_currencies() != 54166:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_list_lsps() != 30571:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_list_payments() != 44520:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_list_refundables() != 53017:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_list_swaps() != 14075:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_lnurl_auth() != 23740:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_lsp_id() != 53031:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_lsp_info() != 38310:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_node_credentials() != 5169:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_node_info() != 17807:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_onchain_payment_limits() != 58677:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_open_channel_fee() != 65044:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_pay_lnurl() != 59900:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_pay_onchain() != 34167:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_payment_by_hash() != 8063:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_prepare_onchain_payment() != 38151:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_prepare_redeem_onchain_funds() != 23808:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_prepare_refund() != 19067:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_receive_onchain() != 38436:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_receive_payment() != 65361:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_recommended_fees() != 46238:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_redeem_onchain_funds() != 25372:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_redeem_swap() != 31523:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_refund() != 28853:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_register_webhook() != 51745:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_report_issue() != 20233:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_rescan_swaps() != 30273:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_send_payment() != 21112:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_send_spontaneous_payment() != 62139:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_set_payment_metadata() != 64161:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_sign_message() != 27140:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_sync() != 37323:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_unregister_webhook() != 13931:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_withdraw_lnurl() != 44837:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_eventlistener_on_event() != 53633:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_bindings_checksum_method_logstream_log() != 5129:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
_UNIFFI_CALLBACK_INTERFACE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFuture(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_FREE),
    ]
class _UniffiForeignFutureStructU8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU8,
)
class _UniffiForeignFutureStructI8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI8,
)
class _UniffiForeignFutureStructU16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU16,
)
class _UniffiForeignFutureStructI16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI16,
)
class _UniffiForeignFutureStructU32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU32,
)
class _UniffiForeignFutureStructI32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI32,
)
class _UniffiForeignFutureStructU64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU64,
)
class _UniffiForeignFutureStructI64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI64,
)
class _UniffiForeignFutureStructF32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_float),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF32,
)
class _UniffiForeignFutureStructF64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_double),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF64,
)
class _UniffiForeignFutureStructPointer(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_void_p),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_POINTER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructPointer,
)
class _UniffiForeignFutureStructRustBuffer(ctypes.Structure):
    _fields_ = [
        ("return_value", _UniffiRustBuffer),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructRustBuffer,
)
class _UniffiForeignFutureStructVoid(ctypes.Structure):
    _fields_ = [
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructVoid,
)
_UNIFFI_CALLBACK_INTERFACE_EVENT_LISTENER_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_LOG_STREAM_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
class _UniffiVTableCallbackInterfaceEventListener(ctypes.Structure):
    _fields_ = [
        ("on_event", _UNIFFI_CALLBACK_INTERFACE_EVENT_LISTENER_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceLogStream(ctypes.Structure):
    _fields_ = [
        ("log", _UNIFFI_CALLBACK_INTERFACE_LOG_STREAM_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
_UniffiLib.uniffi_breez_sdk_bindings_fn_clone_blockingbreezservices.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_clone_blockingbreezservices.restype = ctypes.c_void_p
_UniffiLib.uniffi_breez_sdk_bindings_fn_free_blockingbreezservices.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_free_blockingbreezservices.restype = None
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_backup.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_backup.restype = None
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_backup_status.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_backup_status.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_buy_bitcoin.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_buy_bitcoin.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_check_message.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_check_message.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_claim_reverse_swap.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_claim_reverse_swap.restype = None
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_close_lsp_channels.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_close_lsp_channels.restype = None
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_configure_node.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_configure_node.restype = None
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_connect_lsp.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_connect_lsp.restype = None
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_disconnect.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_disconnect.restype = None
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_execute_dev_command.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_execute_dev_command.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_fetch_fiat_rates.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_fetch_fiat_rates.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_fetch_lsp_info.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_fetch_lsp_info.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_fetch_reverse_swap_fees.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_fetch_reverse_swap_fees.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_generate_diagnostic_data.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_generate_diagnostic_data.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_in_progress_onchain_payments.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_in_progress_onchain_payments.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_in_progress_swap.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_in_progress_swap.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_list_fiat_currencies.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_list_fiat_currencies.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_list_lsps.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_list_lsps.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_list_payments.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_list_payments.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_list_refundables.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_list_refundables.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_list_swaps.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_list_swaps.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_lnurl_auth.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_lnurl_auth.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_lsp_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_lsp_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_lsp_info.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_lsp_info.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_node_credentials.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_node_credentials.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_node_info.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_node_info.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_onchain_payment_limits.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_onchain_payment_limits.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_open_channel_fee.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_open_channel_fee.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_pay_lnurl.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_pay_lnurl.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_pay_onchain.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_pay_onchain.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_payment_by_hash.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_payment_by_hash.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_prepare_onchain_payment.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_prepare_onchain_payment.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_prepare_redeem_onchain_funds.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_prepare_redeem_onchain_funds.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_prepare_refund.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_prepare_refund.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_receive_onchain.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_receive_onchain.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_receive_payment.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_receive_payment.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_recommended_fees.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_recommended_fees.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_redeem_onchain_funds.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_redeem_onchain_funds.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_redeem_swap.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_redeem_swap.restype = None
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_refund.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_refund.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_register_webhook.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_register_webhook.restype = None
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_report_issue.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_report_issue.restype = None
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_rescan_swaps.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_rescan_swaps.restype = None
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_send_payment.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_send_payment.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_send_spontaneous_payment.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_send_spontaneous_payment.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_set_payment_metadata.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_set_payment_metadata.restype = None
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_sign_message.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_sign_message.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_sync.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_sync.restype = None
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_unregister_webhook.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_unregister_webhook.restype = None
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_withdraw_lnurl.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_withdraw_lnurl.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_init_callback_vtable_eventlistener.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceEventListener),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_init_callback_vtable_eventlistener.restype = None
_UniffiLib.uniffi_breez_sdk_bindings_fn_init_callback_vtable_logstream.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceLogStream),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_init_callback_vtable_logstream.restype = None
_UniffiLib.uniffi_breez_sdk_bindings_fn_func_connect.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_func_connect.restype = ctypes.c_void_p
_UniffiLib.uniffi_breez_sdk_bindings_fn_func_default_config.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_func_default_config.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_func_mnemonic_to_seed.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_func_mnemonic_to_seed.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_func_parse_input.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_func_parse_input.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_func_parse_invoice.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_func_parse_invoice.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_func_service_health_check.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_func_service_health_check.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_bindings_fn_func_set_log_stream.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_func_set_log_stream.restype = None
_UniffiLib.uniffi_breez_sdk_bindings_fn_func_static_backup.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_bindings_fn_func_static_backup.restype = _UniffiRustBuffer
_UniffiLib.ffi_breez_sdk_bindings_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_bindings_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_breez_sdk_bindings_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_bindings_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_breez_sdk_bindings_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_bindings_rustbuffer_free.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_bindings_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_u8.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_u8.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_i8.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_i8.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_u16.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_u16.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_i16.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_i16.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_u32.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_u32.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_i32.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_i32.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_u64.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_u64.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_i64.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_i64.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_f32.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_f32.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_f64.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_f64.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_pointer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_pointer.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_pointer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_poll_void.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_cancel_void.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_free_void.restype = None
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_bindings_rust_future_complete_void.restype = None
_UniffiLib.uniffi_breez_sdk_bindings_checksum_func_connect.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_func_connect.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_func_default_config.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_func_default_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_func_mnemonic_to_seed.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_func_mnemonic_to_seed.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_func_parse_input.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_func_parse_input.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_func_parse_invoice.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_func_parse_invoice.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_func_service_health_check.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_func_service_health_check.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_func_set_log_stream.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_func_set_log_stream.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_func_static_backup.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_func_static_backup.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_backup.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_backup.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_backup_status.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_backup_status.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_buy_bitcoin.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_buy_bitcoin.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_check_message.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_check_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_claim_reverse_swap.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_claim_reverse_swap.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_close_lsp_channels.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_close_lsp_channels.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_configure_node.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_configure_node.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_connect_lsp.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_connect_lsp.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_disconnect.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_disconnect.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_execute_dev_command.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_execute_dev_command.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_fetch_fiat_rates.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_fetch_fiat_rates.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_fetch_lsp_info.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_fetch_lsp_info.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_fetch_reverse_swap_fees.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_fetch_reverse_swap_fees.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_generate_diagnostic_data.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_generate_diagnostic_data.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_in_progress_onchain_payments.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_in_progress_onchain_payments.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_in_progress_swap.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_in_progress_swap.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_list_fiat_currencies.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_list_fiat_currencies.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_list_lsps.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_list_lsps.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_list_payments.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_list_payments.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_list_refundables.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_list_refundables.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_list_swaps.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_list_swaps.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_lnurl_auth.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_lnurl_auth.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_lsp_id.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_lsp_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_lsp_info.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_lsp_info.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_node_credentials.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_node_credentials.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_node_info.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_node_info.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_onchain_payment_limits.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_onchain_payment_limits.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_open_channel_fee.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_open_channel_fee.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_pay_lnurl.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_pay_lnurl.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_pay_onchain.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_pay_onchain.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_payment_by_hash.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_payment_by_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_prepare_onchain_payment.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_prepare_onchain_payment.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_prepare_redeem_onchain_funds.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_prepare_redeem_onchain_funds.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_prepare_refund.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_prepare_refund.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_receive_onchain.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_receive_onchain.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_receive_payment.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_receive_payment.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_recommended_fees.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_recommended_fees.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_redeem_onchain_funds.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_redeem_onchain_funds.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_redeem_swap.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_redeem_swap.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_refund.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_refund.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_register_webhook.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_register_webhook.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_report_issue.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_report_issue.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_rescan_swaps.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_rescan_swaps.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_send_payment.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_send_payment.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_send_spontaneous_payment.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_send_spontaneous_payment.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_set_payment_metadata.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_set_payment_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_sign_message.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_sign_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_sync.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_sync.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_unregister_webhook.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_unregister_webhook.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_withdraw_lnurl.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_blockingbreezservices_withdraw_lnurl.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_eventlistener_on_event.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_eventlistener_on_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_logstream_log.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_bindings_checksum_method_logstream_log.restype = ctypes.c_uint16
_UniffiLib.ffi_breez_sdk_bindings_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_breez_sdk_bindings_uniffi_contract_version.restype = ctypes.c_uint32

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)

# Public interface members begin here.


class _UniffiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write(value, buf):
        buf.write_u8(value)

class _UniffiConverterUInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u16"
    VALUE_MIN = 0
    VALUE_MAX = 2**16

    @staticmethod
    def read(buf):
        return buf.read_u16()

    @staticmethod
    def write(value, buf):
        buf.write_u16(value)

class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiConverterInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i64"
    VALUE_MIN = -2**63
    VALUE_MAX = 2**63

    @staticmethod
    def read(buf):
        return buf.read_i64()

    @staticmethod
    def write(value, buf):
        buf.write_i64(value)

class _UniffiConverterDouble(_UniffiConverterPrimitiveFloat):
    @staticmethod
    def read(buf):
        return buf.read_double()

    @staticmethod
    def write(value, buf):
        buf.write_double(value)

class _UniffiConverterBool:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()



class BlockingBreezServicesProtocol(typing.Protocol):
    def backup(self, ):
        raise NotImplementedError
    def backup_status(self, ):
        raise NotImplementedError
    def buy_bitcoin(self, req: "BuyBitcoinRequest"):
        raise NotImplementedError
    def check_message(self, req: "CheckMessageRequest"):
        raise NotImplementedError
    def claim_reverse_swap(self, lockup_address: "str"):
        raise NotImplementedError
    def close_lsp_channels(self, ):
        raise NotImplementedError
    def configure_node(self, req: "ConfigureNodeRequest"):
        raise NotImplementedError
    def connect_lsp(self, lsp_id: "str"):
        raise NotImplementedError
    def disconnect(self, ):
        raise NotImplementedError
    def execute_dev_command(self, command: "str"):
        raise NotImplementedError
    def fetch_fiat_rates(self, ):
        raise NotImplementedError
    def fetch_lsp_info(self, lsp_id: "str"):
        raise NotImplementedError
    def fetch_reverse_swap_fees(self, req: "ReverseSwapFeesRequest"):
        raise NotImplementedError
    def generate_diagnostic_data(self, ):
        raise NotImplementedError
    def in_progress_onchain_payments(self, ):
        raise NotImplementedError
    def in_progress_swap(self, ):
        raise NotImplementedError
    def list_fiat_currencies(self, ):
        raise NotImplementedError
    def list_lsps(self, ):
        raise NotImplementedError
    def list_payments(self, req: "ListPaymentsRequest"):
        raise NotImplementedError
    def list_refundables(self, ):
        raise NotImplementedError
    def list_swaps(self, req: "ListSwapsRequest"):
        raise NotImplementedError
    def lnurl_auth(self, req_data: "LnUrlAuthRequestData"):
        raise NotImplementedError
    def lsp_id(self, ):
        raise NotImplementedError
    def lsp_info(self, ):
        raise NotImplementedError
    def node_credentials(self, ):
        raise NotImplementedError
    def node_info(self, ):
        raise NotImplementedError
    def onchain_payment_limits(self, ):
        raise NotImplementedError
    def open_channel_fee(self, req: "OpenChannelFeeRequest"):
        raise NotImplementedError
    def pay_lnurl(self, req: "LnUrlPayRequest"):
        raise NotImplementedError
    def pay_onchain(self, req: "PayOnchainRequest"):
        raise NotImplementedError
    def payment_by_hash(self, hash: "str"):
        raise NotImplementedError
    def prepare_onchain_payment(self, req: "PrepareOnchainPaymentRequest"):
        raise NotImplementedError
    def prepare_redeem_onchain_funds(self, req: "PrepareRedeemOnchainFundsRequest"):
        raise NotImplementedError
    def prepare_refund(self, req: "PrepareRefundRequest"):
        raise NotImplementedError
    def receive_onchain(self, req: "ReceiveOnchainRequest"):
        raise NotImplementedError
    def receive_payment(self, req: "ReceivePaymentRequest"):
        raise NotImplementedError
    def recommended_fees(self, ):
        raise NotImplementedError
    def redeem_onchain_funds(self, req: "RedeemOnchainFundsRequest"):
        raise NotImplementedError
    def redeem_swap(self, swap_address: "str"):
        raise NotImplementedError
    def refund(self, req: "RefundRequest"):
        raise NotImplementedError
    def register_webhook(self, webhook_url: "str"):
        raise NotImplementedError
    def report_issue(self, req: "ReportIssueRequest"):
        raise NotImplementedError
    def rescan_swaps(self, ):
        raise NotImplementedError
    def send_payment(self, req: "SendPaymentRequest"):
        raise NotImplementedError
    def send_spontaneous_payment(self, req: "SendSpontaneousPaymentRequest"):
        raise NotImplementedError
    def set_payment_metadata(self, hash: "str",metadata: "str"):
        raise NotImplementedError
    def sign_message(self, req: "SignMessageRequest"):
        raise NotImplementedError
    def sync(self, ):
        raise NotImplementedError
    def unregister_webhook(self, webhook_url: "str"):
        raise NotImplementedError
    def withdraw_lnurl(self, request: "LnUrlWithdrawRequest"):
        raise NotImplementedError


class BlockingBreezServices:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_bindings_fn_free_blockingbreezservices, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_bindings_fn_clone_blockingbreezservices, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def backup(self, ) -> None:
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_backup,self._uniffi_clone_pointer(),)






    def backup_status(self, ) -> "BackupStatus":
        return _UniffiConverterTypeBackupStatus.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_backup_status,self._uniffi_clone_pointer(),)
        )





    def buy_bitcoin(self, req: "BuyBitcoinRequest") -> "BuyBitcoinResponse":
        _UniffiConverterTypeBuyBitcoinRequest.check_lower(req)
        
        return _UniffiConverterTypeBuyBitcoinResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeReceiveOnchainError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_buy_bitcoin,self._uniffi_clone_pointer(),
        _UniffiConverterTypeBuyBitcoinRequest.lower(req))
        )





    def check_message(self, req: "CheckMessageRequest") -> "CheckMessageResponse":
        _UniffiConverterTypeCheckMessageRequest.check_lower(req)
        
        return _UniffiConverterTypeCheckMessageResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_check_message,self._uniffi_clone_pointer(),
        _UniffiConverterTypeCheckMessageRequest.lower(req))
        )





    def claim_reverse_swap(self, lockup_address: "str") -> None:
        _UniffiConverterString.check_lower(lockup_address)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_claim_reverse_swap,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(lockup_address))






    def close_lsp_channels(self, ) -> None:
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_close_lsp_channels,self._uniffi_clone_pointer(),)






    def configure_node(self, req: "ConfigureNodeRequest") -> None:
        _UniffiConverterTypeConfigureNodeRequest.check_lower(req)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_configure_node,self._uniffi_clone_pointer(),
        _UniffiConverterTypeConfigureNodeRequest.lower(req))






    def connect_lsp(self, lsp_id: "str") -> None:
        _UniffiConverterString.check_lower(lsp_id)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_connect_lsp,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(lsp_id))






    def disconnect(self, ) -> None:
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_disconnect,self._uniffi_clone_pointer(),)






    def execute_dev_command(self, command: "str") -> "str":
        _UniffiConverterString.check_lower(command)
        
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_execute_dev_command,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(command))
        )





    def fetch_fiat_rates(self, ) -> "typing.List[Rate]":
        return _UniffiConverterSequenceTypeRate.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_fetch_fiat_rates,self._uniffi_clone_pointer(),)
        )





    def fetch_lsp_info(self, lsp_id: "str") -> "typing.Optional[LspInformation]":
        _UniffiConverterString.check_lower(lsp_id)
        
        return _UniffiConverterOptionalTypeLspInformation.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_fetch_lsp_info,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(lsp_id))
        )





    def fetch_reverse_swap_fees(self, req: "ReverseSwapFeesRequest") -> "ReverseSwapPairInfo":
        _UniffiConverterTypeReverseSwapFeesRequest.check_lower(req)
        
        return _UniffiConverterTypeReverseSwapPairInfo.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_fetch_reverse_swap_fees,self._uniffi_clone_pointer(),
        _UniffiConverterTypeReverseSwapFeesRequest.lower(req))
        )





    def generate_diagnostic_data(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_generate_diagnostic_data,self._uniffi_clone_pointer(),)
        )





    def in_progress_onchain_payments(self, ) -> "typing.List[ReverseSwapInfo]":
        return _UniffiConverterSequenceTypeReverseSwapInfo.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_in_progress_onchain_payments,self._uniffi_clone_pointer(),)
        )





    def in_progress_swap(self, ) -> "typing.Optional[SwapInfo]":
        return _UniffiConverterOptionalTypeSwapInfo.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_in_progress_swap,self._uniffi_clone_pointer(),)
        )





    def list_fiat_currencies(self, ) -> "typing.List[FiatCurrency]":
        return _UniffiConverterSequenceTypeFiatCurrency.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_list_fiat_currencies,self._uniffi_clone_pointer(),)
        )





    def list_lsps(self, ) -> "typing.List[LspInformation]":
        return _UniffiConverterSequenceTypeLspInformation.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_list_lsps,self._uniffi_clone_pointer(),)
        )





    def list_payments(self, req: "ListPaymentsRequest") -> "typing.List[Payment]":
        _UniffiConverterTypeListPaymentsRequest.check_lower(req)
        
        return _UniffiConverterSequenceTypePayment.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_list_payments,self._uniffi_clone_pointer(),
        _UniffiConverterTypeListPaymentsRequest.lower(req))
        )





    def list_refundables(self, ) -> "typing.List[SwapInfo]":
        return _UniffiConverterSequenceTypeSwapInfo.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_list_refundables,self._uniffi_clone_pointer(),)
        )





    def list_swaps(self, req: "ListSwapsRequest") -> "typing.List[SwapInfo]":
        _UniffiConverterTypeListSwapsRequest.check_lower(req)
        
        return _UniffiConverterSequenceTypeSwapInfo.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_list_swaps,self._uniffi_clone_pointer(),
        _UniffiConverterTypeListSwapsRequest.lower(req))
        )





    def lnurl_auth(self, req_data: "LnUrlAuthRequestData") -> "LnUrlCallbackStatus":
        _UniffiConverterTypeLnUrlAuthRequestData.check_lower(req_data)
        
        return _UniffiConverterTypeLnUrlCallbackStatus.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeLnUrlAuthError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_lnurl_auth,self._uniffi_clone_pointer(),
        _UniffiConverterTypeLnUrlAuthRequestData.lower(req_data))
        )





    def lsp_id(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_lsp_id,self._uniffi_clone_pointer(),)
        )





    def lsp_info(self, ) -> "LspInformation":
        return _UniffiConverterTypeLspInformation.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_lsp_info,self._uniffi_clone_pointer(),)
        )





    def node_credentials(self, ) -> "typing.Optional[NodeCredentials]":
        return _UniffiConverterOptionalTypeNodeCredentials.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_node_credentials,self._uniffi_clone_pointer(),)
        )





    def node_info(self, ) -> "NodeState":
        return _UniffiConverterTypeNodeState.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_node_info,self._uniffi_clone_pointer(),)
        )





    def onchain_payment_limits(self, ) -> "OnchainPaymentLimitsResponse":
        return _UniffiConverterTypeOnchainPaymentLimitsResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_onchain_payment_limits,self._uniffi_clone_pointer(),)
        )





    def open_channel_fee(self, req: "OpenChannelFeeRequest") -> "OpenChannelFeeResponse":
        _UniffiConverterTypeOpenChannelFeeRequest.check_lower(req)
        
        return _UniffiConverterTypeOpenChannelFeeResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_open_channel_fee,self._uniffi_clone_pointer(),
        _UniffiConverterTypeOpenChannelFeeRequest.lower(req))
        )





    def pay_lnurl(self, req: "LnUrlPayRequest") -> "LnUrlPayResult":
        _UniffiConverterTypeLnUrlPayRequest.check_lower(req)
        
        return _UniffiConverterTypeLnUrlPayResult.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeLnUrlPayError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_pay_lnurl,self._uniffi_clone_pointer(),
        _UniffiConverterTypeLnUrlPayRequest.lower(req))
        )





    def pay_onchain(self, req: "PayOnchainRequest") -> "PayOnchainResponse":
        _UniffiConverterTypePayOnchainRequest.check_lower(req)
        
        return _UniffiConverterTypePayOnchainResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSendOnchainError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_pay_onchain,self._uniffi_clone_pointer(),
        _UniffiConverterTypePayOnchainRequest.lower(req))
        )





    def payment_by_hash(self, hash: "str") -> "typing.Optional[Payment]":
        _UniffiConverterString.check_lower(hash)
        
        return _UniffiConverterOptionalTypePayment.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_payment_by_hash,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(hash))
        )





    def prepare_onchain_payment(self, req: "PrepareOnchainPaymentRequest") -> "PrepareOnchainPaymentResponse":
        _UniffiConverterTypePrepareOnchainPaymentRequest.check_lower(req)
        
        return _UniffiConverterTypePrepareOnchainPaymentResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSendOnchainError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_prepare_onchain_payment,self._uniffi_clone_pointer(),
        _UniffiConverterTypePrepareOnchainPaymentRequest.lower(req))
        )





    def prepare_redeem_onchain_funds(self, req: "PrepareRedeemOnchainFundsRequest") -> "PrepareRedeemOnchainFundsResponse":
        _UniffiConverterTypePrepareRedeemOnchainFundsRequest.check_lower(req)
        
        return _UniffiConverterTypePrepareRedeemOnchainFundsResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeRedeemOnchainError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_prepare_redeem_onchain_funds,self._uniffi_clone_pointer(),
        _UniffiConverterTypePrepareRedeemOnchainFundsRequest.lower(req))
        )





    def prepare_refund(self, req: "PrepareRefundRequest") -> "PrepareRefundResponse":
        _UniffiConverterTypePrepareRefundRequest.check_lower(req)
        
        return _UniffiConverterTypePrepareRefundResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_prepare_refund,self._uniffi_clone_pointer(),
        _UniffiConverterTypePrepareRefundRequest.lower(req))
        )





    def receive_onchain(self, req: "ReceiveOnchainRequest") -> "SwapInfo":
        _UniffiConverterTypeReceiveOnchainRequest.check_lower(req)
        
        return _UniffiConverterTypeSwapInfo.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeReceiveOnchainError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_receive_onchain,self._uniffi_clone_pointer(),
        _UniffiConverterTypeReceiveOnchainRequest.lower(req))
        )





    def receive_payment(self, req: "ReceivePaymentRequest") -> "ReceivePaymentResponse":
        _UniffiConverterTypeReceivePaymentRequest.check_lower(req)
        
        return _UniffiConverterTypeReceivePaymentResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeReceivePaymentError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_receive_payment,self._uniffi_clone_pointer(),
        _UniffiConverterTypeReceivePaymentRequest.lower(req))
        )





    def recommended_fees(self, ) -> "RecommendedFees":
        return _UniffiConverterTypeRecommendedFees.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_recommended_fees,self._uniffi_clone_pointer(),)
        )





    def redeem_onchain_funds(self, req: "RedeemOnchainFundsRequest") -> "RedeemOnchainFundsResponse":
        _UniffiConverterTypeRedeemOnchainFundsRequest.check_lower(req)
        
        return _UniffiConverterTypeRedeemOnchainFundsResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeRedeemOnchainError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_redeem_onchain_funds,self._uniffi_clone_pointer(),
        _UniffiConverterTypeRedeemOnchainFundsRequest.lower(req))
        )





    def redeem_swap(self, swap_address: "str") -> None:
        _UniffiConverterString.check_lower(swap_address)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_redeem_swap,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(swap_address))






    def refund(self, req: "RefundRequest") -> "RefundResponse":
        _UniffiConverterTypeRefundRequest.check_lower(req)
        
        return _UniffiConverterTypeRefundResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_refund,self._uniffi_clone_pointer(),
        _UniffiConverterTypeRefundRequest.lower(req))
        )





    def register_webhook(self, webhook_url: "str") -> None:
        _UniffiConverterString.check_lower(webhook_url)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_register_webhook,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(webhook_url))






    def report_issue(self, req: "ReportIssueRequest") -> None:
        _UniffiConverterTypeReportIssueRequest.check_lower(req)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_report_issue,self._uniffi_clone_pointer(),
        _UniffiConverterTypeReportIssueRequest.lower(req))






    def rescan_swaps(self, ) -> None:
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_rescan_swaps,self._uniffi_clone_pointer(),)






    def send_payment(self, req: "SendPaymentRequest") -> "SendPaymentResponse":
        _UniffiConverterTypeSendPaymentRequest.check_lower(req)
        
        return _UniffiConverterTypeSendPaymentResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSendPaymentError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_send_payment,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSendPaymentRequest.lower(req))
        )





    def send_spontaneous_payment(self, req: "SendSpontaneousPaymentRequest") -> "SendPaymentResponse":
        _UniffiConverterTypeSendSpontaneousPaymentRequest.check_lower(req)
        
        return _UniffiConverterTypeSendPaymentResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSendPaymentError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_send_spontaneous_payment,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSendSpontaneousPaymentRequest.lower(req))
        )





    def set_payment_metadata(self, hash: "str",metadata: "str") -> None:
        _UniffiConverterString.check_lower(hash)
        
        _UniffiConverterString.check_lower(metadata)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_set_payment_metadata,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(hash),
        _UniffiConverterString.lower(metadata))






    def sign_message(self, req: "SignMessageRequest") -> "SignMessageResponse":
        _UniffiConverterTypeSignMessageRequest.check_lower(req)
        
        return _UniffiConverterTypeSignMessageResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_sign_message,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSignMessageRequest.lower(req))
        )





    def sync(self, ) -> None:
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_sync,self._uniffi_clone_pointer(),)






    def unregister_webhook(self, webhook_url: "str") -> None:
        _UniffiConverterString.check_lower(webhook_url)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_unregister_webhook,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(webhook_url))






    def withdraw_lnurl(self, request: "LnUrlWithdrawRequest") -> "LnUrlWithdrawResult":
        _UniffiConverterTypeLnUrlWithdrawRequest.check_lower(request)
        
        return _UniffiConverterTypeLnUrlWithdrawResult.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeLnUrlWithdrawError,_UniffiLib.uniffi_breez_sdk_bindings_fn_method_blockingbreezservices_withdraw_lnurl,self._uniffi_clone_pointer(),
        _UniffiConverterTypeLnUrlWithdrawRequest.lower(request))
        )






class _UniffiConverterTypeBlockingBreezServices:

    @staticmethod
    def lift(value: int):
        return BlockingBreezServices._make_instance_(value)

    @staticmethod
    def check_lower(value: BlockingBreezServices):
        if not isinstance(value, BlockingBreezServices):
            raise TypeError("Expected BlockingBreezServices instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: BlockingBreezServicesProtocol):
        if not isinstance(value, BlockingBreezServices):
            raise TypeError("Expected BlockingBreezServices instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: BlockingBreezServicesProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class AesSuccessActionDataDecrypted:
    description: "str"
    plaintext: "str"
    def __init__(self, *, description: "str", plaintext: "str"):
        self.description = description
        self.plaintext = plaintext

    def __str__(self):
        return "AesSuccessActionDataDecrypted(description={}, plaintext={})".format(self.description, self.plaintext)

    def __eq__(self, other):
        if self.description != other.description:
            return False
        if self.plaintext != other.plaintext:
            return False
        return True

class _UniffiConverterTypeAesSuccessActionDataDecrypted(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AesSuccessActionDataDecrypted(
            description=_UniffiConverterString.read(buf),
            plaintext=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.description)
        _UniffiConverterString.check_lower(value.plaintext)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.description, buf)
        _UniffiConverterString.write(value.plaintext, buf)


class BackupFailedData:
    error: "str"
    def __init__(self, *, error: "str"):
        self.error = error

    def __str__(self):
        return "BackupFailedData(error={})".format(self.error)

    def __eq__(self, other):
        if self.error != other.error:
            return False
        return True

class _UniffiConverterTypeBackupFailedData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BackupFailedData(
            error=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.error)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.error, buf)


class BackupStatus:
    backed_up: "bool"
    last_backup_time: "typing.Optional[int]"
    def __init__(self, *, backed_up: "bool", last_backup_time: "typing.Optional[int]"):
        self.backed_up = backed_up
        self.last_backup_time = last_backup_time

    def __str__(self):
        return "BackupStatus(backed_up={}, last_backup_time={})".format(self.backed_up, self.last_backup_time)

    def __eq__(self, other):
        if self.backed_up != other.backed_up:
            return False
        if self.last_backup_time != other.last_backup_time:
            return False
        return True

class _UniffiConverterTypeBackupStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BackupStatus(
            backed_up=_UniffiConverterBool.read(buf),
            last_backup_time=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBool.check_lower(value.backed_up)
        _UniffiConverterOptionalUInt64.check_lower(value.last_backup_time)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.backed_up, buf)
        _UniffiConverterOptionalUInt64.write(value.last_backup_time, buf)


class BitcoinAddressData:
    address: "str"
    network: "Network"
    amount_sat: "typing.Optional[int]"
    label: "typing.Optional[str]"
    message: "typing.Optional[str]"
    def __init__(self, *, address: "str", network: "Network", amount_sat: "typing.Optional[int]", label: "typing.Optional[str]", message: "typing.Optional[str]"):
        self.address = address
        self.network = network
        self.amount_sat = amount_sat
        self.label = label
        self.message = message

    def __str__(self):
        return "BitcoinAddressData(address={}, network={}, amount_sat={}, label={}, message={})".format(self.address, self.network, self.amount_sat, self.label, self.message)

    def __eq__(self, other):
        if self.address != other.address:
            return False
        if self.network != other.network:
            return False
        if self.amount_sat != other.amount_sat:
            return False
        if self.label != other.label:
            return False
        if self.message != other.message:
            return False
        return True

class _UniffiConverterTypeBitcoinAddressData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BitcoinAddressData(
            address=_UniffiConverterString.read(buf),
            network=_UniffiConverterTypeNetwork.read(buf),
            amount_sat=_UniffiConverterOptionalUInt64.read(buf),
            label=_UniffiConverterOptionalString.read(buf),
            message=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.address)
        _UniffiConverterTypeNetwork.check_lower(value.network)
        _UniffiConverterOptionalUInt64.check_lower(value.amount_sat)
        _UniffiConverterOptionalString.check_lower(value.label)
        _UniffiConverterOptionalString.check_lower(value.message)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.address, buf)
        _UniffiConverterTypeNetwork.write(value.network, buf)
        _UniffiConverterOptionalUInt64.write(value.amount_sat, buf)
        _UniffiConverterOptionalString.write(value.label, buf)
        _UniffiConverterOptionalString.write(value.message, buf)


class BuyBitcoinRequest:
    provider: "BuyBitcoinProvider"
    opening_fee_params: "typing.Optional[OpeningFeeParams]"
    redirect_url: "typing.Optional[str]"
    def __init__(self, *, provider: "BuyBitcoinProvider", opening_fee_params: "typing.Optional[OpeningFeeParams]" = _DEFAULT, redirect_url: "typing.Optional[str]" = _DEFAULT):
        self.provider = provider
        if opening_fee_params is _DEFAULT:
            self.opening_fee_params = None
        else:
            self.opening_fee_params = opening_fee_params
        if redirect_url is _DEFAULT:
            self.redirect_url = None
        else:
            self.redirect_url = redirect_url

    def __str__(self):
        return "BuyBitcoinRequest(provider={}, opening_fee_params={}, redirect_url={})".format(self.provider, self.opening_fee_params, self.redirect_url)

    def __eq__(self, other):
        if self.provider != other.provider:
            return False
        if self.opening_fee_params != other.opening_fee_params:
            return False
        if self.redirect_url != other.redirect_url:
            return False
        return True

class _UniffiConverterTypeBuyBitcoinRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BuyBitcoinRequest(
            provider=_UniffiConverterTypeBuyBitcoinProvider.read(buf),
            opening_fee_params=_UniffiConverterOptionalTypeOpeningFeeParams.read(buf),
            redirect_url=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeBuyBitcoinProvider.check_lower(value.provider)
        _UniffiConverterOptionalTypeOpeningFeeParams.check_lower(value.opening_fee_params)
        _UniffiConverterOptionalString.check_lower(value.redirect_url)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeBuyBitcoinProvider.write(value.provider, buf)
        _UniffiConverterOptionalTypeOpeningFeeParams.write(value.opening_fee_params, buf)
        _UniffiConverterOptionalString.write(value.redirect_url, buf)


class BuyBitcoinResponse:
    url: "str"
    opening_fee_params: "typing.Optional[OpeningFeeParams]"
    def __init__(self, *, url: "str", opening_fee_params: "typing.Optional[OpeningFeeParams]"):
        self.url = url
        self.opening_fee_params = opening_fee_params

    def __str__(self):
        return "BuyBitcoinResponse(url={}, opening_fee_params={})".format(self.url, self.opening_fee_params)

    def __eq__(self, other):
        if self.url != other.url:
            return False
        if self.opening_fee_params != other.opening_fee_params:
            return False
        return True

class _UniffiConverterTypeBuyBitcoinResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BuyBitcoinResponse(
            url=_UniffiConverterString.read(buf),
            opening_fee_params=_UniffiConverterOptionalTypeOpeningFeeParams.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.url)
        _UniffiConverterOptionalTypeOpeningFeeParams.check_lower(value.opening_fee_params)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.url, buf)
        _UniffiConverterOptionalTypeOpeningFeeParams.write(value.opening_fee_params, buf)


class CheckMessageRequest:
    message: "str"
    pubkey: "str"
    signature: "str"
    def __init__(self, *, message: "str", pubkey: "str", signature: "str"):
        self.message = message
        self.pubkey = pubkey
        self.signature = signature

    def __str__(self):
        return "CheckMessageRequest(message={}, pubkey={}, signature={})".format(self.message, self.pubkey, self.signature)

    def __eq__(self, other):
        if self.message != other.message:
            return False
        if self.pubkey != other.pubkey:
            return False
        if self.signature != other.signature:
            return False
        return True

class _UniffiConverterTypeCheckMessageRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CheckMessageRequest(
            message=_UniffiConverterString.read(buf),
            pubkey=_UniffiConverterString.read(buf),
            signature=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.message)
        _UniffiConverterString.check_lower(value.pubkey)
        _UniffiConverterString.check_lower(value.signature)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.message, buf)
        _UniffiConverterString.write(value.pubkey, buf)
        _UniffiConverterString.write(value.signature, buf)


class CheckMessageResponse:
    is_valid: "bool"
    def __init__(self, *, is_valid: "bool"):
        self.is_valid = is_valid

    def __str__(self):
        return "CheckMessageResponse(is_valid={})".format(self.is_valid)

    def __eq__(self, other):
        if self.is_valid != other.is_valid:
            return False
        return True

class _UniffiConverterTypeCheckMessageResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CheckMessageResponse(
            is_valid=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBool.check_lower(value.is_valid)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.is_valid, buf)


class ClosedChannelPaymentDetails:
    state: "ChannelState"
    funding_txid: "str"
    short_channel_id: "typing.Optional[str]"
    closing_txid: "typing.Optional[str]"
    def __init__(self, *, state: "ChannelState", funding_txid: "str", short_channel_id: "typing.Optional[str]", closing_txid: "typing.Optional[str]"):
        self.state = state
        self.funding_txid = funding_txid
        self.short_channel_id = short_channel_id
        self.closing_txid = closing_txid

    def __str__(self):
        return "ClosedChannelPaymentDetails(state={}, funding_txid={}, short_channel_id={}, closing_txid={})".format(self.state, self.funding_txid, self.short_channel_id, self.closing_txid)

    def __eq__(self, other):
        if self.state != other.state:
            return False
        if self.funding_txid != other.funding_txid:
            return False
        if self.short_channel_id != other.short_channel_id:
            return False
        if self.closing_txid != other.closing_txid:
            return False
        return True

class _UniffiConverterTypeClosedChannelPaymentDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ClosedChannelPaymentDetails(
            state=_UniffiConverterTypeChannelState.read(buf),
            funding_txid=_UniffiConverterString.read(buf),
            short_channel_id=_UniffiConverterOptionalString.read(buf),
            closing_txid=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeChannelState.check_lower(value.state)
        _UniffiConverterString.check_lower(value.funding_txid)
        _UniffiConverterOptionalString.check_lower(value.short_channel_id)
        _UniffiConverterOptionalString.check_lower(value.closing_txid)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeChannelState.write(value.state, buf)
        _UniffiConverterString.write(value.funding_txid, buf)
        _UniffiConverterOptionalString.write(value.short_channel_id, buf)
        _UniffiConverterOptionalString.write(value.closing_txid, buf)


class Config:
    breezserver: "str"
    chainnotifier_url: "str"
    mempoolspace_url: "typing.Optional[str]"
    working_dir: "str"
    network: "Network"
    payment_timeout_sec: "int"
    default_lsp_id: "typing.Optional[str]"
    api_key: "typing.Optional[str]"
    maxfee_percent: "float"
    exemptfee_msat: "int"
    node_config: "NodeConfig"
    def __init__(self, *, breezserver: "str", chainnotifier_url: "str", mempoolspace_url: "typing.Optional[str]", working_dir: "str", network: "Network", payment_timeout_sec: "int", default_lsp_id: "typing.Optional[str]", api_key: "typing.Optional[str]", maxfee_percent: "float", exemptfee_msat: "int", node_config: "NodeConfig"):
        self.breezserver = breezserver
        self.chainnotifier_url = chainnotifier_url
        self.mempoolspace_url = mempoolspace_url
        self.working_dir = working_dir
        self.network = network
        self.payment_timeout_sec = payment_timeout_sec
        self.default_lsp_id = default_lsp_id
        self.api_key = api_key
        self.maxfee_percent = maxfee_percent
        self.exemptfee_msat = exemptfee_msat
        self.node_config = node_config

    def __str__(self):
        return "Config(breezserver={}, chainnotifier_url={}, mempoolspace_url={}, working_dir={}, network={}, payment_timeout_sec={}, default_lsp_id={}, api_key={}, maxfee_percent={}, exemptfee_msat={}, node_config={})".format(self.breezserver, self.chainnotifier_url, self.mempoolspace_url, self.working_dir, self.network, self.payment_timeout_sec, self.default_lsp_id, self.api_key, self.maxfee_percent, self.exemptfee_msat, self.node_config)

    def __eq__(self, other):
        if self.breezserver != other.breezserver:
            return False
        if self.chainnotifier_url != other.chainnotifier_url:
            return False
        if self.mempoolspace_url != other.mempoolspace_url:
            return False
        if self.working_dir != other.working_dir:
            return False
        if self.network != other.network:
            return False
        if self.payment_timeout_sec != other.payment_timeout_sec:
            return False
        if self.default_lsp_id != other.default_lsp_id:
            return False
        if self.api_key != other.api_key:
            return False
        if self.maxfee_percent != other.maxfee_percent:
            return False
        if self.exemptfee_msat != other.exemptfee_msat:
            return False
        if self.node_config != other.node_config:
            return False
        return True

class _UniffiConverterTypeConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Config(
            breezserver=_UniffiConverterString.read(buf),
            chainnotifier_url=_UniffiConverterString.read(buf),
            mempoolspace_url=_UniffiConverterOptionalString.read(buf),
            working_dir=_UniffiConverterString.read(buf),
            network=_UniffiConverterTypeNetwork.read(buf),
            payment_timeout_sec=_UniffiConverterUInt32.read(buf),
            default_lsp_id=_UniffiConverterOptionalString.read(buf),
            api_key=_UniffiConverterOptionalString.read(buf),
            maxfee_percent=_UniffiConverterDouble.read(buf),
            exemptfee_msat=_UniffiConverterUInt64.read(buf),
            node_config=_UniffiConverterTypeNodeConfig.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.breezserver)
        _UniffiConverterString.check_lower(value.chainnotifier_url)
        _UniffiConverterOptionalString.check_lower(value.mempoolspace_url)
        _UniffiConverterString.check_lower(value.working_dir)
        _UniffiConverterTypeNetwork.check_lower(value.network)
        _UniffiConverterUInt32.check_lower(value.payment_timeout_sec)
        _UniffiConverterOptionalString.check_lower(value.default_lsp_id)
        _UniffiConverterOptionalString.check_lower(value.api_key)
        _UniffiConverterDouble.check_lower(value.maxfee_percent)
        _UniffiConverterUInt64.check_lower(value.exemptfee_msat)
        _UniffiConverterTypeNodeConfig.check_lower(value.node_config)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.breezserver, buf)
        _UniffiConverterString.write(value.chainnotifier_url, buf)
        _UniffiConverterOptionalString.write(value.mempoolspace_url, buf)
        _UniffiConverterString.write(value.working_dir, buf)
        _UniffiConverterTypeNetwork.write(value.network, buf)
        _UniffiConverterUInt32.write(value.payment_timeout_sec, buf)
        _UniffiConverterOptionalString.write(value.default_lsp_id, buf)
        _UniffiConverterOptionalString.write(value.api_key, buf)
        _UniffiConverterDouble.write(value.maxfee_percent, buf)
        _UniffiConverterUInt64.write(value.exemptfee_msat, buf)
        _UniffiConverterTypeNodeConfig.write(value.node_config, buf)


class ConfigureNodeRequest:
    close_to_address: "typing.Optional[str]"
    def __init__(self, *, close_to_address: "typing.Optional[str]"):
        self.close_to_address = close_to_address

    def __str__(self):
        return "ConfigureNodeRequest(close_to_address={})".format(self.close_to_address)

    def __eq__(self, other):
        if self.close_to_address != other.close_to_address:
            return False
        return True

class _UniffiConverterTypeConfigureNodeRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ConfigureNodeRequest(
            close_to_address=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.close_to_address)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.close_to_address, buf)


class ConnectRequest:
    config: "Config"
    seed: "typing.List[int]"
    restore_only: "typing.Optional[bool]"
    def __init__(self, *, config: "Config", seed: "typing.List[int]", restore_only: "typing.Optional[bool]" = _DEFAULT):
        self.config = config
        self.seed = seed
        if restore_only is _DEFAULT:
            self.restore_only = None
        else:
            self.restore_only = restore_only

    def __str__(self):
        return "ConnectRequest(config={}, seed={}, restore_only={})".format(self.config, self.seed, self.restore_only)

    def __eq__(self, other):
        if self.config != other.config:
            return False
        if self.seed != other.seed:
            return False
        if self.restore_only != other.restore_only:
            return False
        return True

class _UniffiConverterTypeConnectRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ConnectRequest(
            config=_UniffiConverterTypeConfig.read(buf),
            seed=_UniffiConverterSequenceUInt8.read(buf),
            restore_only=_UniffiConverterOptionalBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeConfig.check_lower(value.config)
        _UniffiConverterSequenceUInt8.check_lower(value.seed)
        _UniffiConverterOptionalBool.check_lower(value.restore_only)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeConfig.write(value.config, buf)
        _UniffiConverterSequenceUInt8.write(value.seed, buf)
        _UniffiConverterOptionalBool.write(value.restore_only, buf)


class CurrencyInfo:
    name: "str"
    fraction_size: "int"
    spacing: "typing.Optional[int]"
    symbol: "typing.Optional[Symbol]"
    uniq_symbol: "typing.Optional[Symbol]"
    localized_name: "typing.List[LocalizedName]"
    locale_overrides: "typing.List[LocaleOverrides]"
    def __init__(self, *, name: "str", fraction_size: "int", spacing: "typing.Optional[int]", symbol: "typing.Optional[Symbol]", uniq_symbol: "typing.Optional[Symbol]", localized_name: "typing.List[LocalizedName]", locale_overrides: "typing.List[LocaleOverrides]"):
        self.name = name
        self.fraction_size = fraction_size
        self.spacing = spacing
        self.symbol = symbol
        self.uniq_symbol = uniq_symbol
        self.localized_name = localized_name
        self.locale_overrides = locale_overrides

    def __str__(self):
        return "CurrencyInfo(name={}, fraction_size={}, spacing={}, symbol={}, uniq_symbol={}, localized_name={}, locale_overrides={})".format(self.name, self.fraction_size, self.spacing, self.symbol, self.uniq_symbol, self.localized_name, self.locale_overrides)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.fraction_size != other.fraction_size:
            return False
        if self.spacing != other.spacing:
            return False
        if self.symbol != other.symbol:
            return False
        if self.uniq_symbol != other.uniq_symbol:
            return False
        if self.localized_name != other.localized_name:
            return False
        if self.locale_overrides != other.locale_overrides:
            return False
        return True

class _UniffiConverterTypeCurrencyInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CurrencyInfo(
            name=_UniffiConverterString.read(buf),
            fraction_size=_UniffiConverterUInt32.read(buf),
            spacing=_UniffiConverterOptionalUInt32.read(buf),
            symbol=_UniffiConverterOptionalTypeSymbol.read(buf),
            uniq_symbol=_UniffiConverterOptionalTypeSymbol.read(buf),
            localized_name=_UniffiConverterSequenceTypeLocalizedName.read(buf),
            locale_overrides=_UniffiConverterSequenceTypeLocaleOverrides.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterUInt32.check_lower(value.fraction_size)
        _UniffiConverterOptionalUInt32.check_lower(value.spacing)
        _UniffiConverterOptionalTypeSymbol.check_lower(value.symbol)
        _UniffiConverterOptionalTypeSymbol.check_lower(value.uniq_symbol)
        _UniffiConverterSequenceTypeLocalizedName.check_lower(value.localized_name)
        _UniffiConverterSequenceTypeLocaleOverrides.check_lower(value.locale_overrides)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterUInt32.write(value.fraction_size, buf)
        _UniffiConverterOptionalUInt32.write(value.spacing, buf)
        _UniffiConverterOptionalTypeSymbol.write(value.symbol, buf)
        _UniffiConverterOptionalTypeSymbol.write(value.uniq_symbol, buf)
        _UniffiConverterSequenceTypeLocalizedName.write(value.localized_name, buf)
        _UniffiConverterSequenceTypeLocaleOverrides.write(value.locale_overrides, buf)


class FiatCurrency:
    id: "str"
    info: "CurrencyInfo"
    def __init__(self, *, id: "str", info: "CurrencyInfo"):
        self.id = id
        self.info = info

    def __str__(self):
        return "FiatCurrency(id={}, info={})".format(self.id, self.info)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.info != other.info:
            return False
        return True

class _UniffiConverterTypeFiatCurrency(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FiatCurrency(
            id=_UniffiConverterString.read(buf),
            info=_UniffiConverterTypeCurrencyInfo.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterTypeCurrencyInfo.check_lower(value.info)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterTypeCurrencyInfo.write(value.info, buf)


class GreenlightCredentials:
    developer_key: "typing.List[int]"
    developer_cert: "typing.List[int]"
    def __init__(self, *, developer_key: "typing.List[int]", developer_cert: "typing.List[int]"):
        self.developer_key = developer_key
        self.developer_cert = developer_cert

    def __str__(self):
        return "GreenlightCredentials(developer_key={}, developer_cert={})".format(self.developer_key, self.developer_cert)

    def __eq__(self, other):
        if self.developer_key != other.developer_key:
            return False
        if self.developer_cert != other.developer_cert:
            return False
        return True

class _UniffiConverterTypeGreenlightCredentials(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GreenlightCredentials(
            developer_key=_UniffiConverterSequenceUInt8.read(buf),
            developer_cert=_UniffiConverterSequenceUInt8.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceUInt8.check_lower(value.developer_key)
        _UniffiConverterSequenceUInt8.check_lower(value.developer_cert)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceUInt8.write(value.developer_key, buf)
        _UniffiConverterSequenceUInt8.write(value.developer_cert, buf)


class GreenlightDeviceCredentials:
    device: "typing.List[int]"
    def __init__(self, *, device: "typing.List[int]"):
        self.device = device

    def __str__(self):
        return "GreenlightDeviceCredentials(device={})".format(self.device)

    def __eq__(self, other):
        if self.device != other.device:
            return False
        return True

class _UniffiConverterTypeGreenlightDeviceCredentials(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GreenlightDeviceCredentials(
            device=_UniffiConverterSequenceUInt8.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceUInt8.check_lower(value.device)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceUInt8.write(value.device, buf)


class GreenlightNodeConfig:
    partner_credentials: "typing.Optional[GreenlightCredentials]"
    invite_code: "typing.Optional[str]"
    def __init__(self, *, partner_credentials: "typing.Optional[GreenlightCredentials]", invite_code: "typing.Optional[str]"):
        self.partner_credentials = partner_credentials
        self.invite_code = invite_code

    def __str__(self):
        return "GreenlightNodeConfig(partner_credentials={}, invite_code={})".format(self.partner_credentials, self.invite_code)

    def __eq__(self, other):
        if self.partner_credentials != other.partner_credentials:
            return False
        if self.invite_code != other.invite_code:
            return False
        return True

class _UniffiConverterTypeGreenlightNodeConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GreenlightNodeConfig(
            partner_credentials=_UniffiConverterOptionalTypeGreenlightCredentials.read(buf),
            invite_code=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalTypeGreenlightCredentials.check_lower(value.partner_credentials)
        _UniffiConverterOptionalString.check_lower(value.invite_code)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeGreenlightCredentials.write(value.partner_credentials, buf)
        _UniffiConverterOptionalString.write(value.invite_code, buf)


class InvoicePaidDetails:
    payment_hash: "str"
    bolt11: "str"
    payment: "typing.Optional[Payment]"
    def __init__(self, *, payment_hash: "str", bolt11: "str", payment: "typing.Optional[Payment]"):
        self.payment_hash = payment_hash
        self.bolt11 = bolt11
        self.payment = payment

    def __str__(self):
        return "InvoicePaidDetails(payment_hash={}, bolt11={}, payment={})".format(self.payment_hash, self.bolt11, self.payment)

    def __eq__(self, other):
        if self.payment_hash != other.payment_hash:
            return False
        if self.bolt11 != other.bolt11:
            return False
        if self.payment != other.payment:
            return False
        return True

class _UniffiConverterTypeInvoicePaidDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return InvoicePaidDetails(
            payment_hash=_UniffiConverterString.read(buf),
            bolt11=_UniffiConverterString.read(buf),
            payment=_UniffiConverterOptionalTypePayment.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.payment_hash)
        _UniffiConverterString.check_lower(value.bolt11)
        _UniffiConverterOptionalTypePayment.check_lower(value.payment)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.payment_hash, buf)
        _UniffiConverterString.write(value.bolt11, buf)
        _UniffiConverterOptionalTypePayment.write(value.payment, buf)


class ListPaymentsRequest:
    filters: "typing.Optional[typing.List[PaymentTypeFilter]]"
    metadata_filters: "typing.Optional[typing.List[MetadataFilter]]"
    from_timestamp: "typing.Optional[int]"
    to_timestamp: "typing.Optional[int]"
    include_failures: "typing.Optional[bool]"
    offset: "typing.Optional[int]"
    limit: "typing.Optional[int]"
    def __init__(self, *, filters: "typing.Optional[typing.List[PaymentTypeFilter]]" = _DEFAULT, metadata_filters: "typing.Optional[typing.List[MetadataFilter]]" = _DEFAULT, from_timestamp: "typing.Optional[int]" = _DEFAULT, to_timestamp: "typing.Optional[int]" = _DEFAULT, include_failures: "typing.Optional[bool]" = _DEFAULT, offset: "typing.Optional[int]" = _DEFAULT, limit: "typing.Optional[int]" = _DEFAULT):
        if filters is _DEFAULT:
            self.filters = None
        else:
            self.filters = filters
        if metadata_filters is _DEFAULT:
            self.metadata_filters = None
        else:
            self.metadata_filters = metadata_filters
        if from_timestamp is _DEFAULT:
            self.from_timestamp = None
        else:
            self.from_timestamp = from_timestamp
        if to_timestamp is _DEFAULT:
            self.to_timestamp = None
        else:
            self.to_timestamp = to_timestamp
        if include_failures is _DEFAULT:
            self.include_failures = None
        else:
            self.include_failures = include_failures
        if offset is _DEFAULT:
            self.offset = None
        else:
            self.offset = offset
        if limit is _DEFAULT:
            self.limit = None
        else:
            self.limit = limit

    def __str__(self):
        return "ListPaymentsRequest(filters={}, metadata_filters={}, from_timestamp={}, to_timestamp={}, include_failures={}, offset={}, limit={})".format(self.filters, self.metadata_filters, self.from_timestamp, self.to_timestamp, self.include_failures, self.offset, self.limit)

    def __eq__(self, other):
        if self.filters != other.filters:
            return False
        if self.metadata_filters != other.metadata_filters:
            return False
        if self.from_timestamp != other.from_timestamp:
            return False
        if self.to_timestamp != other.to_timestamp:
            return False
        if self.include_failures != other.include_failures:
            return False
        if self.offset != other.offset:
            return False
        if self.limit != other.limit:
            return False
        return True

class _UniffiConverterTypeListPaymentsRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ListPaymentsRequest(
            filters=_UniffiConverterOptionalSequenceTypePaymentTypeFilter.read(buf),
            metadata_filters=_UniffiConverterOptionalSequenceTypeMetadataFilter.read(buf),
            from_timestamp=_UniffiConverterOptionalInt64.read(buf),
            to_timestamp=_UniffiConverterOptionalInt64.read(buf),
            include_failures=_UniffiConverterOptionalBool.read(buf),
            offset=_UniffiConverterOptionalUInt32.read(buf),
            limit=_UniffiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalSequenceTypePaymentTypeFilter.check_lower(value.filters)
        _UniffiConverterOptionalSequenceTypeMetadataFilter.check_lower(value.metadata_filters)
        _UniffiConverterOptionalInt64.check_lower(value.from_timestamp)
        _UniffiConverterOptionalInt64.check_lower(value.to_timestamp)
        _UniffiConverterOptionalBool.check_lower(value.include_failures)
        _UniffiConverterOptionalUInt32.check_lower(value.offset)
        _UniffiConverterOptionalUInt32.check_lower(value.limit)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalSequenceTypePaymentTypeFilter.write(value.filters, buf)
        _UniffiConverterOptionalSequenceTypeMetadataFilter.write(value.metadata_filters, buf)
        _UniffiConverterOptionalInt64.write(value.from_timestamp, buf)
        _UniffiConverterOptionalInt64.write(value.to_timestamp, buf)
        _UniffiConverterOptionalBool.write(value.include_failures, buf)
        _UniffiConverterOptionalUInt32.write(value.offset, buf)
        _UniffiConverterOptionalUInt32.write(value.limit, buf)


class ListSwapsRequest:
    status: "typing.Optional[typing.List[SwapStatus]]"
    from_timestamp: "typing.Optional[int]"
    to_timestamp: "typing.Optional[int]"
    offset: "typing.Optional[int]"
    limit: "typing.Optional[int]"
    def __init__(self, *, status: "typing.Optional[typing.List[SwapStatus]]" = _DEFAULT, from_timestamp: "typing.Optional[int]" = _DEFAULT, to_timestamp: "typing.Optional[int]" = _DEFAULT, offset: "typing.Optional[int]" = _DEFAULT, limit: "typing.Optional[int]" = _DEFAULT):
        if status is _DEFAULT:
            self.status = None
        else:
            self.status = status
        if from_timestamp is _DEFAULT:
            self.from_timestamp = None
        else:
            self.from_timestamp = from_timestamp
        if to_timestamp is _DEFAULT:
            self.to_timestamp = None
        else:
            self.to_timestamp = to_timestamp
        if offset is _DEFAULT:
            self.offset = None
        else:
            self.offset = offset
        if limit is _DEFAULT:
            self.limit = None
        else:
            self.limit = limit

    def __str__(self):
        return "ListSwapsRequest(status={}, from_timestamp={}, to_timestamp={}, offset={}, limit={})".format(self.status, self.from_timestamp, self.to_timestamp, self.offset, self.limit)

    def __eq__(self, other):
        if self.status != other.status:
            return False
        if self.from_timestamp != other.from_timestamp:
            return False
        if self.to_timestamp != other.to_timestamp:
            return False
        if self.offset != other.offset:
            return False
        if self.limit != other.limit:
            return False
        return True

class _UniffiConverterTypeListSwapsRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ListSwapsRequest(
            status=_UniffiConverterOptionalSequenceTypeSwapStatus.read(buf),
            from_timestamp=_UniffiConverterOptionalInt64.read(buf),
            to_timestamp=_UniffiConverterOptionalInt64.read(buf),
            offset=_UniffiConverterOptionalUInt32.read(buf),
            limit=_UniffiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalSequenceTypeSwapStatus.check_lower(value.status)
        _UniffiConverterOptionalInt64.check_lower(value.from_timestamp)
        _UniffiConverterOptionalInt64.check_lower(value.to_timestamp)
        _UniffiConverterOptionalUInt32.check_lower(value.offset)
        _UniffiConverterOptionalUInt32.check_lower(value.limit)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalSequenceTypeSwapStatus.write(value.status, buf)
        _UniffiConverterOptionalInt64.write(value.from_timestamp, buf)
        _UniffiConverterOptionalInt64.write(value.to_timestamp, buf)
        _UniffiConverterOptionalUInt32.write(value.offset, buf)
        _UniffiConverterOptionalUInt32.write(value.limit, buf)


class LnInvoice:
    bolt11: "str"
    network: "Network"
    payee_pubkey: "str"
    payment_hash: "str"
    description: "typing.Optional[str]"
    description_hash: "typing.Optional[str]"
    amount_msat: "typing.Optional[int]"
    timestamp: "int"
    expiry: "int"
    routing_hints: "typing.List[RouteHint]"
    payment_secret: "typing.List[int]"
    min_final_cltv_expiry_delta: "int"
    def __init__(self, *, bolt11: "str", network: "Network", payee_pubkey: "str", payment_hash: "str", description: "typing.Optional[str]", description_hash: "typing.Optional[str]", amount_msat: "typing.Optional[int]", timestamp: "int", expiry: "int", routing_hints: "typing.List[RouteHint]", payment_secret: "typing.List[int]", min_final_cltv_expiry_delta: "int"):
        self.bolt11 = bolt11
        self.network = network
        self.payee_pubkey = payee_pubkey
        self.payment_hash = payment_hash
        self.description = description
        self.description_hash = description_hash
        self.amount_msat = amount_msat
        self.timestamp = timestamp
        self.expiry = expiry
        self.routing_hints = routing_hints
        self.payment_secret = payment_secret
        self.min_final_cltv_expiry_delta = min_final_cltv_expiry_delta

    def __str__(self):
        return "LnInvoice(bolt11={}, network={}, payee_pubkey={}, payment_hash={}, description={}, description_hash={}, amount_msat={}, timestamp={}, expiry={}, routing_hints={}, payment_secret={}, min_final_cltv_expiry_delta={})".format(self.bolt11, self.network, self.payee_pubkey, self.payment_hash, self.description, self.description_hash, self.amount_msat, self.timestamp, self.expiry, self.routing_hints, self.payment_secret, self.min_final_cltv_expiry_delta)

    def __eq__(self, other):
        if self.bolt11 != other.bolt11:
            return False
        if self.network != other.network:
            return False
        if self.payee_pubkey != other.payee_pubkey:
            return False
        if self.payment_hash != other.payment_hash:
            return False
        if self.description != other.description:
            return False
        if self.description_hash != other.description_hash:
            return False
        if self.amount_msat != other.amount_msat:
            return False
        if self.timestamp != other.timestamp:
            return False
        if self.expiry != other.expiry:
            return False
        if self.routing_hints != other.routing_hints:
            return False
        if self.payment_secret != other.payment_secret:
            return False
        if self.min_final_cltv_expiry_delta != other.min_final_cltv_expiry_delta:
            return False
        return True

class _UniffiConverterTypeLnInvoice(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnInvoice(
            bolt11=_UniffiConverterString.read(buf),
            network=_UniffiConverterTypeNetwork.read(buf),
            payee_pubkey=_UniffiConverterString.read(buf),
            payment_hash=_UniffiConverterString.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            description_hash=_UniffiConverterOptionalString.read(buf),
            amount_msat=_UniffiConverterOptionalUInt64.read(buf),
            timestamp=_UniffiConverterUInt64.read(buf),
            expiry=_UniffiConverterUInt64.read(buf),
            routing_hints=_UniffiConverterSequenceTypeRouteHint.read(buf),
            payment_secret=_UniffiConverterSequenceUInt8.read(buf),
            min_final_cltv_expiry_delta=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.bolt11)
        _UniffiConverterTypeNetwork.check_lower(value.network)
        _UniffiConverterString.check_lower(value.payee_pubkey)
        _UniffiConverterString.check_lower(value.payment_hash)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterOptionalString.check_lower(value.description_hash)
        _UniffiConverterOptionalUInt64.check_lower(value.amount_msat)
        _UniffiConverterUInt64.check_lower(value.timestamp)
        _UniffiConverterUInt64.check_lower(value.expiry)
        _UniffiConverterSequenceTypeRouteHint.check_lower(value.routing_hints)
        _UniffiConverterSequenceUInt8.check_lower(value.payment_secret)
        _UniffiConverterUInt64.check_lower(value.min_final_cltv_expiry_delta)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.bolt11, buf)
        _UniffiConverterTypeNetwork.write(value.network, buf)
        _UniffiConverterString.write(value.payee_pubkey, buf)
        _UniffiConverterString.write(value.payment_hash, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterOptionalString.write(value.description_hash, buf)
        _UniffiConverterOptionalUInt64.write(value.amount_msat, buf)
        _UniffiConverterUInt64.write(value.timestamp, buf)
        _UniffiConverterUInt64.write(value.expiry, buf)
        _UniffiConverterSequenceTypeRouteHint.write(value.routing_hints, buf)
        _UniffiConverterSequenceUInt8.write(value.payment_secret, buf)
        _UniffiConverterUInt64.write(value.min_final_cltv_expiry_delta, buf)


class LnPaymentDetails:
    payment_hash: "str"
    label: "str"
    destination_pubkey: "str"
    payment_preimage: "str"
    keysend: "bool"
    bolt11: "str"
    open_channel_bolt11: "typing.Optional[str]"
    lnurl_success_action: "typing.Optional[SuccessActionProcessed]"
    lnurl_pay_domain: "typing.Optional[str]"
    lnurl_pay_comment: "typing.Optional[str]"
    lnurl_metadata: "typing.Optional[str]"
    ln_address: "typing.Optional[str]"
    lnurl_withdraw_endpoint: "typing.Optional[str]"
    swap_info: "typing.Optional[SwapInfo]"
    reverse_swap_info: "typing.Optional[ReverseSwapInfo]"
    pending_expiration_block: "typing.Optional[int]"
    def __init__(self, *, payment_hash: "str", label: "str", destination_pubkey: "str", payment_preimage: "str", keysend: "bool", bolt11: "str", open_channel_bolt11: "typing.Optional[str]", lnurl_success_action: "typing.Optional[SuccessActionProcessed]", lnurl_pay_domain: "typing.Optional[str]", lnurl_pay_comment: "typing.Optional[str]", lnurl_metadata: "typing.Optional[str]", ln_address: "typing.Optional[str]", lnurl_withdraw_endpoint: "typing.Optional[str]", swap_info: "typing.Optional[SwapInfo]", reverse_swap_info: "typing.Optional[ReverseSwapInfo]", pending_expiration_block: "typing.Optional[int]"):
        self.payment_hash = payment_hash
        self.label = label
        self.destination_pubkey = destination_pubkey
        self.payment_preimage = payment_preimage
        self.keysend = keysend
        self.bolt11 = bolt11
        self.open_channel_bolt11 = open_channel_bolt11
        self.lnurl_success_action = lnurl_success_action
        self.lnurl_pay_domain = lnurl_pay_domain
        self.lnurl_pay_comment = lnurl_pay_comment
        self.lnurl_metadata = lnurl_metadata
        self.ln_address = ln_address
        self.lnurl_withdraw_endpoint = lnurl_withdraw_endpoint
        self.swap_info = swap_info
        self.reverse_swap_info = reverse_swap_info
        self.pending_expiration_block = pending_expiration_block

    def __str__(self):
        return "LnPaymentDetails(payment_hash={}, label={}, destination_pubkey={}, payment_preimage={}, keysend={}, bolt11={}, open_channel_bolt11={}, lnurl_success_action={}, lnurl_pay_domain={}, lnurl_pay_comment={}, lnurl_metadata={}, ln_address={}, lnurl_withdraw_endpoint={}, swap_info={}, reverse_swap_info={}, pending_expiration_block={})".format(self.payment_hash, self.label, self.destination_pubkey, self.payment_preimage, self.keysend, self.bolt11, self.open_channel_bolt11, self.lnurl_success_action, self.lnurl_pay_domain, self.lnurl_pay_comment, self.lnurl_metadata, self.ln_address, self.lnurl_withdraw_endpoint, self.swap_info, self.reverse_swap_info, self.pending_expiration_block)

    def __eq__(self, other):
        if self.payment_hash != other.payment_hash:
            return False
        if self.label != other.label:
            return False
        if self.destination_pubkey != other.destination_pubkey:
            return False
        if self.payment_preimage != other.payment_preimage:
            return False
        if self.keysend != other.keysend:
            return False
        if self.bolt11 != other.bolt11:
            return False
        if self.open_channel_bolt11 != other.open_channel_bolt11:
            return False
        if self.lnurl_success_action != other.lnurl_success_action:
            return False
        if self.lnurl_pay_domain != other.lnurl_pay_domain:
            return False
        if self.lnurl_pay_comment != other.lnurl_pay_comment:
            return False
        if self.lnurl_metadata != other.lnurl_metadata:
            return False
        if self.ln_address != other.ln_address:
            return False
        if self.lnurl_withdraw_endpoint != other.lnurl_withdraw_endpoint:
            return False
        if self.swap_info != other.swap_info:
            return False
        if self.reverse_swap_info != other.reverse_swap_info:
            return False
        if self.pending_expiration_block != other.pending_expiration_block:
            return False
        return True

class _UniffiConverterTypeLnPaymentDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnPaymentDetails(
            payment_hash=_UniffiConverterString.read(buf),
            label=_UniffiConverterString.read(buf),
            destination_pubkey=_UniffiConverterString.read(buf),
            payment_preimage=_UniffiConverterString.read(buf),
            keysend=_UniffiConverterBool.read(buf),
            bolt11=_UniffiConverterString.read(buf),
            open_channel_bolt11=_UniffiConverterOptionalString.read(buf),
            lnurl_success_action=_UniffiConverterOptionalTypeSuccessActionProcessed.read(buf),
            lnurl_pay_domain=_UniffiConverterOptionalString.read(buf),
            lnurl_pay_comment=_UniffiConverterOptionalString.read(buf),
            lnurl_metadata=_UniffiConverterOptionalString.read(buf),
            ln_address=_UniffiConverterOptionalString.read(buf),
            lnurl_withdraw_endpoint=_UniffiConverterOptionalString.read(buf),
            swap_info=_UniffiConverterOptionalTypeSwapInfo.read(buf),
            reverse_swap_info=_UniffiConverterOptionalTypeReverseSwapInfo.read(buf),
            pending_expiration_block=_UniffiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.payment_hash)
        _UniffiConverterString.check_lower(value.label)
        _UniffiConverterString.check_lower(value.destination_pubkey)
        _UniffiConverterString.check_lower(value.payment_preimage)
        _UniffiConverterBool.check_lower(value.keysend)
        _UniffiConverterString.check_lower(value.bolt11)
        _UniffiConverterOptionalString.check_lower(value.open_channel_bolt11)
        _UniffiConverterOptionalTypeSuccessActionProcessed.check_lower(value.lnurl_success_action)
        _UniffiConverterOptionalString.check_lower(value.lnurl_pay_domain)
        _UniffiConverterOptionalString.check_lower(value.lnurl_pay_comment)
        _UniffiConverterOptionalString.check_lower(value.lnurl_metadata)
        _UniffiConverterOptionalString.check_lower(value.ln_address)
        _UniffiConverterOptionalString.check_lower(value.lnurl_withdraw_endpoint)
        _UniffiConverterOptionalTypeSwapInfo.check_lower(value.swap_info)
        _UniffiConverterOptionalTypeReverseSwapInfo.check_lower(value.reverse_swap_info)
        _UniffiConverterOptionalUInt32.check_lower(value.pending_expiration_block)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.payment_hash, buf)
        _UniffiConverterString.write(value.label, buf)
        _UniffiConverterString.write(value.destination_pubkey, buf)
        _UniffiConverterString.write(value.payment_preimage, buf)
        _UniffiConverterBool.write(value.keysend, buf)
        _UniffiConverterString.write(value.bolt11, buf)
        _UniffiConverterOptionalString.write(value.open_channel_bolt11, buf)
        _UniffiConverterOptionalTypeSuccessActionProcessed.write(value.lnurl_success_action, buf)
        _UniffiConverterOptionalString.write(value.lnurl_pay_domain, buf)
        _UniffiConverterOptionalString.write(value.lnurl_pay_comment, buf)
        _UniffiConverterOptionalString.write(value.lnurl_metadata, buf)
        _UniffiConverterOptionalString.write(value.ln_address, buf)
        _UniffiConverterOptionalString.write(value.lnurl_withdraw_endpoint, buf)
        _UniffiConverterOptionalTypeSwapInfo.write(value.swap_info, buf)
        _UniffiConverterOptionalTypeReverseSwapInfo.write(value.reverse_swap_info, buf)
        _UniffiConverterOptionalUInt32.write(value.pending_expiration_block, buf)


class LnUrlAuthRequestData:
    k1: "str"
    domain: "str"
    url: "str"
    action: "typing.Optional[str]"
    def __init__(self, *, k1: "str", domain: "str", url: "str", action: "typing.Optional[str]" = _DEFAULT):
        self.k1 = k1
        self.domain = domain
        self.url = url
        if action is _DEFAULT:
            self.action = None
        else:
            self.action = action

    def __str__(self):
        return "LnUrlAuthRequestData(k1={}, domain={}, url={}, action={})".format(self.k1, self.domain, self.url, self.action)

    def __eq__(self, other):
        if self.k1 != other.k1:
            return False
        if self.domain != other.domain:
            return False
        if self.url != other.url:
            return False
        if self.action != other.action:
            return False
        return True

class _UniffiConverterTypeLnUrlAuthRequestData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnUrlAuthRequestData(
            k1=_UniffiConverterString.read(buf),
            domain=_UniffiConverterString.read(buf),
            url=_UniffiConverterString.read(buf),
            action=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.k1)
        _UniffiConverterString.check_lower(value.domain)
        _UniffiConverterString.check_lower(value.url)
        _UniffiConverterOptionalString.check_lower(value.action)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.k1, buf)
        _UniffiConverterString.write(value.domain, buf)
        _UniffiConverterString.write(value.url, buf)
        _UniffiConverterOptionalString.write(value.action, buf)


class LnUrlErrorData:
    reason: "str"
    def __init__(self, *, reason: "str"):
        self.reason = reason

    def __str__(self):
        return "LnUrlErrorData(reason={})".format(self.reason)

    def __eq__(self, other):
        if self.reason != other.reason:
            return False
        return True

class _UniffiConverterTypeLnUrlErrorData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnUrlErrorData(
            reason=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.reason)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.reason, buf)


class LnUrlPayErrorData:
    payment_hash: "str"
    reason: "str"
    def __init__(self, *, payment_hash: "str", reason: "str"):
        self.payment_hash = payment_hash
        self.reason = reason

    def __str__(self):
        return "LnUrlPayErrorData(payment_hash={}, reason={})".format(self.payment_hash, self.reason)

    def __eq__(self, other):
        if self.payment_hash != other.payment_hash:
            return False
        if self.reason != other.reason:
            return False
        return True

class _UniffiConverterTypeLnUrlPayErrorData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnUrlPayErrorData(
            payment_hash=_UniffiConverterString.read(buf),
            reason=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.payment_hash)
        _UniffiConverterString.check_lower(value.reason)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.payment_hash, buf)
        _UniffiConverterString.write(value.reason, buf)


class LnUrlPayRequest:
    data: "LnUrlPayRequestData"
    amount_msat: "int"
    use_trampoline: "bool"
    comment: "typing.Optional[str]"
    payment_label: "typing.Optional[str]"
    validate_success_action_url: "typing.Optional[bool]"
    def __init__(self, *, data: "LnUrlPayRequestData", amount_msat: "int", use_trampoline: "bool", comment: "typing.Optional[str]" = _DEFAULT, payment_label: "typing.Optional[str]" = _DEFAULT, validate_success_action_url: "typing.Optional[bool]" = _DEFAULT):
        self.data = data
        self.amount_msat = amount_msat
        self.use_trampoline = use_trampoline
        if comment is _DEFAULT:
            self.comment = None
        else:
            self.comment = comment
        if payment_label is _DEFAULT:
            self.payment_label = None
        else:
            self.payment_label = payment_label
        if validate_success_action_url is _DEFAULT:
            self.validate_success_action_url = None
        else:
            self.validate_success_action_url = validate_success_action_url

    def __str__(self):
        return "LnUrlPayRequest(data={}, amount_msat={}, use_trampoline={}, comment={}, payment_label={}, validate_success_action_url={})".format(self.data, self.amount_msat, self.use_trampoline, self.comment, self.payment_label, self.validate_success_action_url)

    def __eq__(self, other):
        if self.data != other.data:
            return False
        if self.amount_msat != other.amount_msat:
            return False
        if self.use_trampoline != other.use_trampoline:
            return False
        if self.comment != other.comment:
            return False
        if self.payment_label != other.payment_label:
            return False
        if self.validate_success_action_url != other.validate_success_action_url:
            return False
        return True

class _UniffiConverterTypeLnUrlPayRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnUrlPayRequest(
            data=_UniffiConverterTypeLnUrlPayRequestData.read(buf),
            amount_msat=_UniffiConverterUInt64.read(buf),
            use_trampoline=_UniffiConverterBool.read(buf),
            comment=_UniffiConverterOptionalString.read(buf),
            payment_label=_UniffiConverterOptionalString.read(buf),
            validate_success_action_url=_UniffiConverterOptionalBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeLnUrlPayRequestData.check_lower(value.data)
        _UniffiConverterUInt64.check_lower(value.amount_msat)
        _UniffiConverterBool.check_lower(value.use_trampoline)
        _UniffiConverterOptionalString.check_lower(value.comment)
        _UniffiConverterOptionalString.check_lower(value.payment_label)
        _UniffiConverterOptionalBool.check_lower(value.validate_success_action_url)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeLnUrlPayRequestData.write(value.data, buf)
        _UniffiConverterUInt64.write(value.amount_msat, buf)
        _UniffiConverterBool.write(value.use_trampoline, buf)
        _UniffiConverterOptionalString.write(value.comment, buf)
        _UniffiConverterOptionalString.write(value.payment_label, buf)
        _UniffiConverterOptionalBool.write(value.validate_success_action_url, buf)


class LnUrlPayRequestData:
    callback: "str"
    min_sendable: "int"
    max_sendable: "int"
    metadata_str: "str"
    comment_allowed: "int"
    domain: "str"
    allows_nostr: "bool"
    nostr_pubkey: "typing.Optional[str]"
    ln_address: "typing.Optional[str]"
    def __init__(self, *, callback: "str", min_sendable: "int", max_sendable: "int", metadata_str: "str", comment_allowed: "int", domain: "str", allows_nostr: "bool", nostr_pubkey: "typing.Optional[str]", ln_address: "typing.Optional[str]"):
        self.callback = callback
        self.min_sendable = min_sendable
        self.max_sendable = max_sendable
        self.metadata_str = metadata_str
        self.comment_allowed = comment_allowed
        self.domain = domain
        self.allows_nostr = allows_nostr
        self.nostr_pubkey = nostr_pubkey
        self.ln_address = ln_address

    def __str__(self):
        return "LnUrlPayRequestData(callback={}, min_sendable={}, max_sendable={}, metadata_str={}, comment_allowed={}, domain={}, allows_nostr={}, nostr_pubkey={}, ln_address={})".format(self.callback, self.min_sendable, self.max_sendable, self.metadata_str, self.comment_allowed, self.domain, self.allows_nostr, self.nostr_pubkey, self.ln_address)

    def __eq__(self, other):
        if self.callback != other.callback:
            return False
        if self.min_sendable != other.min_sendable:
            return False
        if self.max_sendable != other.max_sendable:
            return False
        if self.metadata_str != other.metadata_str:
            return False
        if self.comment_allowed != other.comment_allowed:
            return False
        if self.domain != other.domain:
            return False
        if self.allows_nostr != other.allows_nostr:
            return False
        if self.nostr_pubkey != other.nostr_pubkey:
            return False
        if self.ln_address != other.ln_address:
            return False
        return True

class _UniffiConverterTypeLnUrlPayRequestData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnUrlPayRequestData(
            callback=_UniffiConverterString.read(buf),
            min_sendable=_UniffiConverterUInt64.read(buf),
            max_sendable=_UniffiConverterUInt64.read(buf),
            metadata_str=_UniffiConverterString.read(buf),
            comment_allowed=_UniffiConverterUInt16.read(buf),
            domain=_UniffiConverterString.read(buf),
            allows_nostr=_UniffiConverterBool.read(buf),
            nostr_pubkey=_UniffiConverterOptionalString.read(buf),
            ln_address=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.callback)
        _UniffiConverterUInt64.check_lower(value.min_sendable)
        _UniffiConverterUInt64.check_lower(value.max_sendable)
        _UniffiConverterString.check_lower(value.metadata_str)
        _UniffiConverterUInt16.check_lower(value.comment_allowed)
        _UniffiConverterString.check_lower(value.domain)
        _UniffiConverterBool.check_lower(value.allows_nostr)
        _UniffiConverterOptionalString.check_lower(value.nostr_pubkey)
        _UniffiConverterOptionalString.check_lower(value.ln_address)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.callback, buf)
        _UniffiConverterUInt64.write(value.min_sendable, buf)
        _UniffiConverterUInt64.write(value.max_sendable, buf)
        _UniffiConverterString.write(value.metadata_str, buf)
        _UniffiConverterUInt16.write(value.comment_allowed, buf)
        _UniffiConverterString.write(value.domain, buf)
        _UniffiConverterBool.write(value.allows_nostr, buf)
        _UniffiConverterOptionalString.write(value.nostr_pubkey, buf)
        _UniffiConverterOptionalString.write(value.ln_address, buf)


class LnUrlPaySuccessData:
    success_action: "typing.Optional[SuccessActionProcessed]"
    payment: "Payment"
    def __init__(self, *, success_action: "typing.Optional[SuccessActionProcessed]", payment: "Payment"):
        self.success_action = success_action
        self.payment = payment

    def __str__(self):
        return "LnUrlPaySuccessData(success_action={}, payment={})".format(self.success_action, self.payment)

    def __eq__(self, other):
        if self.success_action != other.success_action:
            return False
        if self.payment != other.payment:
            return False
        return True

class _UniffiConverterTypeLnUrlPaySuccessData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnUrlPaySuccessData(
            success_action=_UniffiConverterOptionalTypeSuccessActionProcessed.read(buf),
            payment=_UniffiConverterTypePayment.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalTypeSuccessActionProcessed.check_lower(value.success_action)
        _UniffiConverterTypePayment.check_lower(value.payment)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeSuccessActionProcessed.write(value.success_action, buf)
        _UniffiConverterTypePayment.write(value.payment, buf)


class LnUrlWithdrawRequest:
    data: "LnUrlWithdrawRequestData"
    amount_msat: "int"
    description: "typing.Optional[str]"
    def __init__(self, *, data: "LnUrlWithdrawRequestData", amount_msat: "int", description: "typing.Optional[str]" = _DEFAULT):
        self.data = data
        self.amount_msat = amount_msat
        if description is _DEFAULT:
            self.description = None
        else:
            self.description = description

    def __str__(self):
        return "LnUrlWithdrawRequest(data={}, amount_msat={}, description={})".format(self.data, self.amount_msat, self.description)

    def __eq__(self, other):
        if self.data != other.data:
            return False
        if self.amount_msat != other.amount_msat:
            return False
        if self.description != other.description:
            return False
        return True

class _UniffiConverterTypeLnUrlWithdrawRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnUrlWithdrawRequest(
            data=_UniffiConverterTypeLnUrlWithdrawRequestData.read(buf),
            amount_msat=_UniffiConverterUInt64.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeLnUrlWithdrawRequestData.check_lower(value.data)
        _UniffiConverterUInt64.check_lower(value.amount_msat)
        _UniffiConverterOptionalString.check_lower(value.description)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeLnUrlWithdrawRequestData.write(value.data, buf)
        _UniffiConverterUInt64.write(value.amount_msat, buf)
        _UniffiConverterOptionalString.write(value.description, buf)


class LnUrlWithdrawRequestData:
    callback: "str"
    k1: "str"
    default_description: "str"
    min_withdrawable: "int"
    max_withdrawable: "int"
    def __init__(self, *, callback: "str", k1: "str", default_description: "str", min_withdrawable: "int", max_withdrawable: "int"):
        self.callback = callback
        self.k1 = k1
        self.default_description = default_description
        self.min_withdrawable = min_withdrawable
        self.max_withdrawable = max_withdrawable

    def __str__(self):
        return "LnUrlWithdrawRequestData(callback={}, k1={}, default_description={}, min_withdrawable={}, max_withdrawable={})".format(self.callback, self.k1, self.default_description, self.min_withdrawable, self.max_withdrawable)

    def __eq__(self, other):
        if self.callback != other.callback:
            return False
        if self.k1 != other.k1:
            return False
        if self.default_description != other.default_description:
            return False
        if self.min_withdrawable != other.min_withdrawable:
            return False
        if self.max_withdrawable != other.max_withdrawable:
            return False
        return True

class _UniffiConverterTypeLnUrlWithdrawRequestData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnUrlWithdrawRequestData(
            callback=_UniffiConverterString.read(buf),
            k1=_UniffiConverterString.read(buf),
            default_description=_UniffiConverterString.read(buf),
            min_withdrawable=_UniffiConverterUInt64.read(buf),
            max_withdrawable=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.callback)
        _UniffiConverterString.check_lower(value.k1)
        _UniffiConverterString.check_lower(value.default_description)
        _UniffiConverterUInt64.check_lower(value.min_withdrawable)
        _UniffiConverterUInt64.check_lower(value.max_withdrawable)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.callback, buf)
        _UniffiConverterString.write(value.k1, buf)
        _UniffiConverterString.write(value.default_description, buf)
        _UniffiConverterUInt64.write(value.min_withdrawable, buf)
        _UniffiConverterUInt64.write(value.max_withdrawable, buf)


class LnUrlWithdrawSuccessData:
    invoice: "LnInvoice"
    def __init__(self, *, invoice: "LnInvoice"):
        self.invoice = invoice

    def __str__(self):
        return "LnUrlWithdrawSuccessData(invoice={})".format(self.invoice)

    def __eq__(self, other):
        if self.invoice != other.invoice:
            return False
        return True

class _UniffiConverterTypeLnUrlWithdrawSuccessData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnUrlWithdrawSuccessData(
            invoice=_UniffiConverterTypeLnInvoice.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeLnInvoice.check_lower(value.invoice)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeLnInvoice.write(value.invoice, buf)


class LocaleOverrides:
    locale: "str"
    spacing: "typing.Optional[int]"
    symbol: "Symbol"
    def __init__(self, *, locale: "str", spacing: "typing.Optional[int]", symbol: "Symbol"):
        self.locale = locale
        self.spacing = spacing
        self.symbol = symbol

    def __str__(self):
        return "LocaleOverrides(locale={}, spacing={}, symbol={})".format(self.locale, self.spacing, self.symbol)

    def __eq__(self, other):
        if self.locale != other.locale:
            return False
        if self.spacing != other.spacing:
            return False
        if self.symbol != other.symbol:
            return False
        return True

class _UniffiConverterTypeLocaleOverrides(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LocaleOverrides(
            locale=_UniffiConverterString.read(buf),
            spacing=_UniffiConverterOptionalUInt32.read(buf),
            symbol=_UniffiConverterTypeSymbol.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.locale)
        _UniffiConverterOptionalUInt32.check_lower(value.spacing)
        _UniffiConverterTypeSymbol.check_lower(value.symbol)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.locale, buf)
        _UniffiConverterOptionalUInt32.write(value.spacing, buf)
        _UniffiConverterTypeSymbol.write(value.symbol, buf)


class LocalizedName:
    locale: "str"
    name: "str"
    def __init__(self, *, locale: "str", name: "str"):
        self.locale = locale
        self.name = name

    def __str__(self):
        return "LocalizedName(locale={}, name={})".format(self.locale, self.name)

    def __eq__(self, other):
        if self.locale != other.locale:
            return False
        if self.name != other.name:
            return False
        return True

class _UniffiConverterTypeLocalizedName(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LocalizedName(
            locale=_UniffiConverterString.read(buf),
            name=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.locale)
        _UniffiConverterString.check_lower(value.name)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.locale, buf)
        _UniffiConverterString.write(value.name, buf)


class LogEntry:
    line: "str"
    level: "str"
    def __init__(self, *, line: "str", level: "str"):
        self.line = line
        self.level = level

    def __str__(self):
        return "LogEntry(line={}, level={})".format(self.line, self.level)

    def __eq__(self, other):
        if self.line != other.line:
            return False
        if self.level != other.level:
            return False
        return True

class _UniffiConverterTypeLogEntry(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LogEntry(
            line=_UniffiConverterString.read(buf),
            level=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.line)
        _UniffiConverterString.check_lower(value.level)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.line, buf)
        _UniffiConverterString.write(value.level, buf)


class LspInformation:
    id: "str"
    name: "str"
    widget_url: "str"
    pubkey: "str"
    host: "str"
    base_fee_msat: "int"
    fee_rate: "float"
    time_lock_delta: "int"
    min_htlc_msat: "int"
    lsp_pubkey: "typing.List[int]"
    opening_fee_params_list: "OpeningFeeParamsMenu"
    def __init__(self, *, id: "str", name: "str", widget_url: "str", pubkey: "str", host: "str", base_fee_msat: "int", fee_rate: "float", time_lock_delta: "int", min_htlc_msat: "int", lsp_pubkey: "typing.List[int]", opening_fee_params_list: "OpeningFeeParamsMenu"):
        self.id = id
        self.name = name
        self.widget_url = widget_url
        self.pubkey = pubkey
        self.host = host
        self.base_fee_msat = base_fee_msat
        self.fee_rate = fee_rate
        self.time_lock_delta = time_lock_delta
        self.min_htlc_msat = min_htlc_msat
        self.lsp_pubkey = lsp_pubkey
        self.opening_fee_params_list = opening_fee_params_list

    def __str__(self):
        return "LspInformation(id={}, name={}, widget_url={}, pubkey={}, host={}, base_fee_msat={}, fee_rate={}, time_lock_delta={}, min_htlc_msat={}, lsp_pubkey={}, opening_fee_params_list={})".format(self.id, self.name, self.widget_url, self.pubkey, self.host, self.base_fee_msat, self.fee_rate, self.time_lock_delta, self.min_htlc_msat, self.lsp_pubkey, self.opening_fee_params_list)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.name != other.name:
            return False
        if self.widget_url != other.widget_url:
            return False
        if self.pubkey != other.pubkey:
            return False
        if self.host != other.host:
            return False
        if self.base_fee_msat != other.base_fee_msat:
            return False
        if self.fee_rate != other.fee_rate:
            return False
        if self.time_lock_delta != other.time_lock_delta:
            return False
        if self.min_htlc_msat != other.min_htlc_msat:
            return False
        if self.lsp_pubkey != other.lsp_pubkey:
            return False
        if self.opening_fee_params_list != other.opening_fee_params_list:
            return False
        return True

class _UniffiConverterTypeLspInformation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LspInformation(
            id=_UniffiConverterString.read(buf),
            name=_UniffiConverterString.read(buf),
            widget_url=_UniffiConverterString.read(buf),
            pubkey=_UniffiConverterString.read(buf),
            host=_UniffiConverterString.read(buf),
            base_fee_msat=_UniffiConverterInt64.read(buf),
            fee_rate=_UniffiConverterDouble.read(buf),
            time_lock_delta=_UniffiConverterUInt32.read(buf),
            min_htlc_msat=_UniffiConverterInt64.read(buf),
            lsp_pubkey=_UniffiConverterSequenceUInt8.read(buf),
            opening_fee_params_list=_UniffiConverterTypeOpeningFeeParamsMenu.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterString.check_lower(value.widget_url)
        _UniffiConverterString.check_lower(value.pubkey)
        _UniffiConverterString.check_lower(value.host)
        _UniffiConverterInt64.check_lower(value.base_fee_msat)
        _UniffiConverterDouble.check_lower(value.fee_rate)
        _UniffiConverterUInt32.check_lower(value.time_lock_delta)
        _UniffiConverterInt64.check_lower(value.min_htlc_msat)
        _UniffiConverterSequenceUInt8.check_lower(value.lsp_pubkey)
        _UniffiConverterTypeOpeningFeeParamsMenu.check_lower(value.opening_fee_params_list)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterString.write(value.widget_url, buf)
        _UniffiConverterString.write(value.pubkey, buf)
        _UniffiConverterString.write(value.host, buf)
        _UniffiConverterInt64.write(value.base_fee_msat, buf)
        _UniffiConverterDouble.write(value.fee_rate, buf)
        _UniffiConverterUInt32.write(value.time_lock_delta, buf)
        _UniffiConverterInt64.write(value.min_htlc_msat, buf)
        _UniffiConverterSequenceUInt8.write(value.lsp_pubkey, buf)
        _UniffiConverterTypeOpeningFeeParamsMenu.write(value.opening_fee_params_list, buf)


class MessageSuccessActionData:
    message: "str"
    def __init__(self, *, message: "str"):
        self.message = message

    def __str__(self):
        return "MessageSuccessActionData(message={})".format(self.message)

    def __eq__(self, other):
        if self.message != other.message:
            return False
        return True

class _UniffiConverterTypeMessageSuccessActionData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MessageSuccessActionData(
            message=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.message)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.message, buf)


class MetadataFilter:
    json_path: "str"
    json_value: "str"
    def __init__(self, *, json_path: "str", json_value: "str"):
        self.json_path = json_path
        self.json_value = json_value

    def __str__(self):
        return "MetadataFilter(json_path={}, json_value={})".format(self.json_path, self.json_value)

    def __eq__(self, other):
        if self.json_path != other.json_path:
            return False
        if self.json_value != other.json_value:
            return False
        return True

class _UniffiConverterTypeMetadataFilter(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MetadataFilter(
            json_path=_UniffiConverterString.read(buf),
            json_value=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.json_path)
        _UniffiConverterString.check_lower(value.json_value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.json_path, buf)
        _UniffiConverterString.write(value.json_value, buf)


class MetadataItem:
    key: "str"
    value: "str"
    def __init__(self, *, key: "str", value: "str"):
        self.key = key
        self.value = value

    def __str__(self):
        return "MetadataItem(key={}, value={})".format(self.key, self.value)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeMetadataItem(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MetadataItem(
            key=_UniffiConverterString.read(buf),
            value=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.key)
        _UniffiConverterString.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.key, buf)
        _UniffiConverterString.write(value.value, buf)


class NodeState:
    id: "str"
    block_height: "int"
    channels_balance_msat: "int"
    onchain_balance_msat: "int"
    pending_onchain_balance_msat: "int"
    utxos: "typing.List[UnspentTransactionOutput]"
    max_payable_msat: "int"
    max_receivable_msat: "int"
    max_single_payment_amount_msat: "int"
    max_chan_reserve_msats: "int"
    connected_peers: "typing.List[str]"
    max_receivable_single_payment_amount_msat: "int"
    total_inbound_liquidity_msats: "int"
    def __init__(self, *, id: "str", block_height: "int", channels_balance_msat: "int", onchain_balance_msat: "int", pending_onchain_balance_msat: "int", utxos: "typing.List[UnspentTransactionOutput]", max_payable_msat: "int", max_receivable_msat: "int", max_single_payment_amount_msat: "int", max_chan_reserve_msats: "int", connected_peers: "typing.List[str]", max_receivable_single_payment_amount_msat: "int", total_inbound_liquidity_msats: "int"):
        self.id = id
        self.block_height = block_height
        self.channels_balance_msat = channels_balance_msat
        self.onchain_balance_msat = onchain_balance_msat
        self.pending_onchain_balance_msat = pending_onchain_balance_msat
        self.utxos = utxos
        self.max_payable_msat = max_payable_msat
        self.max_receivable_msat = max_receivable_msat
        self.max_single_payment_amount_msat = max_single_payment_amount_msat
        self.max_chan_reserve_msats = max_chan_reserve_msats
        self.connected_peers = connected_peers
        self.max_receivable_single_payment_amount_msat = max_receivable_single_payment_amount_msat
        self.total_inbound_liquidity_msats = total_inbound_liquidity_msats

    def __str__(self):
        return "NodeState(id={}, block_height={}, channels_balance_msat={}, onchain_balance_msat={}, pending_onchain_balance_msat={}, utxos={}, max_payable_msat={}, max_receivable_msat={}, max_single_payment_amount_msat={}, max_chan_reserve_msats={}, connected_peers={}, max_receivable_single_payment_amount_msat={}, total_inbound_liquidity_msats={})".format(self.id, self.block_height, self.channels_balance_msat, self.onchain_balance_msat, self.pending_onchain_balance_msat, self.utxos, self.max_payable_msat, self.max_receivable_msat, self.max_single_payment_amount_msat, self.max_chan_reserve_msats, self.connected_peers, self.max_receivable_single_payment_amount_msat, self.total_inbound_liquidity_msats)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.block_height != other.block_height:
            return False
        if self.channels_balance_msat != other.channels_balance_msat:
            return False
        if self.onchain_balance_msat != other.onchain_balance_msat:
            return False
        if self.pending_onchain_balance_msat != other.pending_onchain_balance_msat:
            return False
        if self.utxos != other.utxos:
            return False
        if self.max_payable_msat != other.max_payable_msat:
            return False
        if self.max_receivable_msat != other.max_receivable_msat:
            return False
        if self.max_single_payment_amount_msat != other.max_single_payment_amount_msat:
            return False
        if self.max_chan_reserve_msats != other.max_chan_reserve_msats:
            return False
        if self.connected_peers != other.connected_peers:
            return False
        if self.max_receivable_single_payment_amount_msat != other.max_receivable_single_payment_amount_msat:
            return False
        if self.total_inbound_liquidity_msats != other.total_inbound_liquidity_msats:
            return False
        return True

class _UniffiConverterTypeNodeState(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return NodeState(
            id=_UniffiConverterString.read(buf),
            block_height=_UniffiConverterUInt32.read(buf),
            channels_balance_msat=_UniffiConverterUInt64.read(buf),
            onchain_balance_msat=_UniffiConverterUInt64.read(buf),
            pending_onchain_balance_msat=_UniffiConverterUInt64.read(buf),
            utxos=_UniffiConverterSequenceTypeUnspentTransactionOutput.read(buf),
            max_payable_msat=_UniffiConverterUInt64.read(buf),
            max_receivable_msat=_UniffiConverterUInt64.read(buf),
            max_single_payment_amount_msat=_UniffiConverterUInt64.read(buf),
            max_chan_reserve_msats=_UniffiConverterUInt64.read(buf),
            connected_peers=_UniffiConverterSequenceString.read(buf),
            max_receivable_single_payment_amount_msat=_UniffiConverterUInt64.read(buf),
            total_inbound_liquidity_msats=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterUInt32.check_lower(value.block_height)
        _UniffiConverterUInt64.check_lower(value.channels_balance_msat)
        _UniffiConverterUInt64.check_lower(value.onchain_balance_msat)
        _UniffiConverterUInt64.check_lower(value.pending_onchain_balance_msat)
        _UniffiConverterSequenceTypeUnspentTransactionOutput.check_lower(value.utxos)
        _UniffiConverterUInt64.check_lower(value.max_payable_msat)
        _UniffiConverterUInt64.check_lower(value.max_receivable_msat)
        _UniffiConverterUInt64.check_lower(value.max_single_payment_amount_msat)
        _UniffiConverterUInt64.check_lower(value.max_chan_reserve_msats)
        _UniffiConverterSequenceString.check_lower(value.connected_peers)
        _UniffiConverterUInt64.check_lower(value.max_receivable_single_payment_amount_msat)
        _UniffiConverterUInt64.check_lower(value.total_inbound_liquidity_msats)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterUInt32.write(value.block_height, buf)
        _UniffiConverterUInt64.write(value.channels_balance_msat, buf)
        _UniffiConverterUInt64.write(value.onchain_balance_msat, buf)
        _UniffiConverterUInt64.write(value.pending_onchain_balance_msat, buf)
        _UniffiConverterSequenceTypeUnspentTransactionOutput.write(value.utxos, buf)
        _UniffiConverterUInt64.write(value.max_payable_msat, buf)
        _UniffiConverterUInt64.write(value.max_receivable_msat, buf)
        _UniffiConverterUInt64.write(value.max_single_payment_amount_msat, buf)
        _UniffiConverterUInt64.write(value.max_chan_reserve_msats, buf)
        _UniffiConverterSequenceString.write(value.connected_peers, buf)
        _UniffiConverterUInt64.write(value.max_receivable_single_payment_amount_msat, buf)
        _UniffiConverterUInt64.write(value.total_inbound_liquidity_msats, buf)


class OnchainPaymentLimitsResponse:
    min_sat: "int"
    max_sat: "int"
    max_payable_sat: "int"
    def __init__(self, *, min_sat: "int", max_sat: "int", max_payable_sat: "int"):
        self.min_sat = min_sat
        self.max_sat = max_sat
        self.max_payable_sat = max_payable_sat

    def __str__(self):
        return "OnchainPaymentLimitsResponse(min_sat={}, max_sat={}, max_payable_sat={})".format(self.min_sat, self.max_sat, self.max_payable_sat)

    def __eq__(self, other):
        if self.min_sat != other.min_sat:
            return False
        if self.max_sat != other.max_sat:
            return False
        if self.max_payable_sat != other.max_payable_sat:
            return False
        return True

class _UniffiConverterTypeOnchainPaymentLimitsResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OnchainPaymentLimitsResponse(
            min_sat=_UniffiConverterUInt64.read(buf),
            max_sat=_UniffiConverterUInt64.read(buf),
            max_payable_sat=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.min_sat)
        _UniffiConverterUInt64.check_lower(value.max_sat)
        _UniffiConverterUInt64.check_lower(value.max_payable_sat)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.min_sat, buf)
        _UniffiConverterUInt64.write(value.max_sat, buf)
        _UniffiConverterUInt64.write(value.max_payable_sat, buf)


class OpenChannelFeeRequest:
    amount_msat: "typing.Optional[int]"
    expiry: "typing.Optional[int]"
    def __init__(self, *, amount_msat: "typing.Optional[int]", expiry: "typing.Optional[int]" = _DEFAULT):
        self.amount_msat = amount_msat
        if expiry is _DEFAULT:
            self.expiry = None
        else:
            self.expiry = expiry

    def __str__(self):
        return "OpenChannelFeeRequest(amount_msat={}, expiry={})".format(self.amount_msat, self.expiry)

    def __eq__(self, other):
        if self.amount_msat != other.amount_msat:
            return False
        if self.expiry != other.expiry:
            return False
        return True

class _UniffiConverterTypeOpenChannelFeeRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OpenChannelFeeRequest(
            amount_msat=_UniffiConverterOptionalUInt64.read(buf),
            expiry=_UniffiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalUInt64.check_lower(value.amount_msat)
        _UniffiConverterOptionalUInt32.check_lower(value.expiry)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalUInt64.write(value.amount_msat, buf)
        _UniffiConverterOptionalUInt32.write(value.expiry, buf)


class OpenChannelFeeResponse:
    fee_msat: "typing.Optional[int]"
    fee_params: "OpeningFeeParams"
    def __init__(self, *, fee_msat: "typing.Optional[int]", fee_params: "OpeningFeeParams"):
        self.fee_msat = fee_msat
        self.fee_params = fee_params

    def __str__(self):
        return "OpenChannelFeeResponse(fee_msat={}, fee_params={})".format(self.fee_msat, self.fee_params)

    def __eq__(self, other):
        if self.fee_msat != other.fee_msat:
            return False
        if self.fee_params != other.fee_params:
            return False
        return True

class _UniffiConverterTypeOpenChannelFeeResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OpenChannelFeeResponse(
            fee_msat=_UniffiConverterOptionalUInt64.read(buf),
            fee_params=_UniffiConverterTypeOpeningFeeParams.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalUInt64.check_lower(value.fee_msat)
        _UniffiConverterTypeOpeningFeeParams.check_lower(value.fee_params)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalUInt64.write(value.fee_msat, buf)
        _UniffiConverterTypeOpeningFeeParams.write(value.fee_params, buf)


class OpeningFeeParams:
    min_msat: "int"
    proportional: "int"
    valid_until: "str"
    max_idle_time: "int"
    max_client_to_self_delay: "int"
    promise: "str"
    def __init__(self, *, min_msat: "int", proportional: "int", valid_until: "str", max_idle_time: "int", max_client_to_self_delay: "int", promise: "str"):
        self.min_msat = min_msat
        self.proportional = proportional
        self.valid_until = valid_until
        self.max_idle_time = max_idle_time
        self.max_client_to_self_delay = max_client_to_self_delay
        self.promise = promise

    def __str__(self):
        return "OpeningFeeParams(min_msat={}, proportional={}, valid_until={}, max_idle_time={}, max_client_to_self_delay={}, promise={})".format(self.min_msat, self.proportional, self.valid_until, self.max_idle_time, self.max_client_to_self_delay, self.promise)

    def __eq__(self, other):
        if self.min_msat != other.min_msat:
            return False
        if self.proportional != other.proportional:
            return False
        if self.valid_until != other.valid_until:
            return False
        if self.max_idle_time != other.max_idle_time:
            return False
        if self.max_client_to_self_delay != other.max_client_to_self_delay:
            return False
        if self.promise != other.promise:
            return False
        return True

class _UniffiConverterTypeOpeningFeeParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OpeningFeeParams(
            min_msat=_UniffiConverterUInt64.read(buf),
            proportional=_UniffiConverterUInt32.read(buf),
            valid_until=_UniffiConverterString.read(buf),
            max_idle_time=_UniffiConverterUInt32.read(buf),
            max_client_to_self_delay=_UniffiConverterUInt32.read(buf),
            promise=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.min_msat)
        _UniffiConverterUInt32.check_lower(value.proportional)
        _UniffiConverterString.check_lower(value.valid_until)
        _UniffiConverterUInt32.check_lower(value.max_idle_time)
        _UniffiConverterUInt32.check_lower(value.max_client_to_self_delay)
        _UniffiConverterString.check_lower(value.promise)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.min_msat, buf)
        _UniffiConverterUInt32.write(value.proportional, buf)
        _UniffiConverterString.write(value.valid_until, buf)
        _UniffiConverterUInt32.write(value.max_idle_time, buf)
        _UniffiConverterUInt32.write(value.max_client_to_self_delay, buf)
        _UniffiConverterString.write(value.promise, buf)


class OpeningFeeParamsMenu:
    values: "typing.List[OpeningFeeParams]"
    def __init__(self, *, values: "typing.List[OpeningFeeParams]"):
        self.values = values

    def __str__(self):
        return "OpeningFeeParamsMenu(values={})".format(self.values)

    def __eq__(self, other):
        if self.values != other.values:
            return False
        return True

class _UniffiConverterTypeOpeningFeeParamsMenu(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OpeningFeeParamsMenu(
            values=_UniffiConverterSequenceTypeOpeningFeeParams.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeOpeningFeeParams.check_lower(value.values)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeOpeningFeeParams.write(value.values, buf)


class PayOnchainRequest:
    recipient_address: "str"
    prepare_res: "PrepareOnchainPaymentResponse"
    def __init__(self, *, recipient_address: "str", prepare_res: "PrepareOnchainPaymentResponse"):
        self.recipient_address = recipient_address
        self.prepare_res = prepare_res

    def __str__(self):
        return "PayOnchainRequest(recipient_address={}, prepare_res={})".format(self.recipient_address, self.prepare_res)

    def __eq__(self, other):
        if self.recipient_address != other.recipient_address:
            return False
        if self.prepare_res != other.prepare_res:
            return False
        return True

class _UniffiConverterTypePayOnchainRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PayOnchainRequest(
            recipient_address=_UniffiConverterString.read(buf),
            prepare_res=_UniffiConverterTypePrepareOnchainPaymentResponse.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.recipient_address)
        _UniffiConverterTypePrepareOnchainPaymentResponse.check_lower(value.prepare_res)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.recipient_address, buf)
        _UniffiConverterTypePrepareOnchainPaymentResponse.write(value.prepare_res, buf)


class PayOnchainResponse:
    reverse_swap_info: "ReverseSwapInfo"
    def __init__(self, *, reverse_swap_info: "ReverseSwapInfo"):
        self.reverse_swap_info = reverse_swap_info

    def __str__(self):
        return "PayOnchainResponse(reverse_swap_info={})".format(self.reverse_swap_info)

    def __eq__(self, other):
        if self.reverse_swap_info != other.reverse_swap_info:
            return False
        return True

class _UniffiConverterTypePayOnchainResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PayOnchainResponse(
            reverse_swap_info=_UniffiConverterTypeReverseSwapInfo.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeReverseSwapInfo.check_lower(value.reverse_swap_info)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeReverseSwapInfo.write(value.reverse_swap_info, buf)


class Payment:
    id: "str"
    payment_type: "PaymentType"
    payment_time: "int"
    amount_msat: "int"
    fee_msat: "int"
    status: "PaymentStatus"
    error: "typing.Optional[str]"
    description: "typing.Optional[str]"
    details: "PaymentDetails"
    metadata: "typing.Optional[str]"
    def __init__(self, *, id: "str", payment_type: "PaymentType", payment_time: "int", amount_msat: "int", fee_msat: "int", status: "PaymentStatus", error: "typing.Optional[str]", description: "typing.Optional[str]", details: "PaymentDetails", metadata: "typing.Optional[str]"):
        self.id = id
        self.payment_type = payment_type
        self.payment_time = payment_time
        self.amount_msat = amount_msat
        self.fee_msat = fee_msat
        self.status = status
        self.error = error
        self.description = description
        self.details = details
        self.metadata = metadata

    def __str__(self):
        return "Payment(id={}, payment_type={}, payment_time={}, amount_msat={}, fee_msat={}, status={}, error={}, description={}, details={}, metadata={})".format(self.id, self.payment_type, self.payment_time, self.amount_msat, self.fee_msat, self.status, self.error, self.description, self.details, self.metadata)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.payment_type != other.payment_type:
            return False
        if self.payment_time != other.payment_time:
            return False
        if self.amount_msat != other.amount_msat:
            return False
        if self.fee_msat != other.fee_msat:
            return False
        if self.status != other.status:
            return False
        if self.error != other.error:
            return False
        if self.description != other.description:
            return False
        if self.details != other.details:
            return False
        if self.metadata != other.metadata:
            return False
        return True

class _UniffiConverterTypePayment(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Payment(
            id=_UniffiConverterString.read(buf),
            payment_type=_UniffiConverterTypePaymentType.read(buf),
            payment_time=_UniffiConverterInt64.read(buf),
            amount_msat=_UniffiConverterUInt64.read(buf),
            fee_msat=_UniffiConverterUInt64.read(buf),
            status=_UniffiConverterTypePaymentStatus.read(buf),
            error=_UniffiConverterOptionalString.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            details=_UniffiConverterTypePaymentDetails.read(buf),
            metadata=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterTypePaymentType.check_lower(value.payment_type)
        _UniffiConverterInt64.check_lower(value.payment_time)
        _UniffiConverterUInt64.check_lower(value.amount_msat)
        _UniffiConverterUInt64.check_lower(value.fee_msat)
        _UniffiConverterTypePaymentStatus.check_lower(value.status)
        _UniffiConverterOptionalString.check_lower(value.error)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterTypePaymentDetails.check_lower(value.details)
        _UniffiConverterOptionalString.check_lower(value.metadata)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterTypePaymentType.write(value.payment_type, buf)
        _UniffiConverterInt64.write(value.payment_time, buf)
        _UniffiConverterUInt64.write(value.amount_msat, buf)
        _UniffiConverterUInt64.write(value.fee_msat, buf)
        _UniffiConverterTypePaymentStatus.write(value.status, buf)
        _UniffiConverterOptionalString.write(value.error, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterTypePaymentDetails.write(value.details, buf)
        _UniffiConverterOptionalString.write(value.metadata, buf)


class PaymentFailedData:
    error: "str"
    node_id: "str"
    invoice: "typing.Optional[LnInvoice]"
    label: "typing.Optional[str]"
    def __init__(self, *, error: "str", node_id: "str", invoice: "typing.Optional[LnInvoice]", label: "typing.Optional[str]"):
        self.error = error
        self.node_id = node_id
        self.invoice = invoice
        self.label = label

    def __str__(self):
        return "PaymentFailedData(error={}, node_id={}, invoice={}, label={})".format(self.error, self.node_id, self.invoice, self.label)

    def __eq__(self, other):
        if self.error != other.error:
            return False
        if self.node_id != other.node_id:
            return False
        if self.invoice != other.invoice:
            return False
        if self.label != other.label:
            return False
        return True

class _UniffiConverterTypePaymentFailedData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PaymentFailedData(
            error=_UniffiConverterString.read(buf),
            node_id=_UniffiConverterString.read(buf),
            invoice=_UniffiConverterOptionalTypeLnInvoice.read(buf),
            label=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.error)
        _UniffiConverterString.check_lower(value.node_id)
        _UniffiConverterOptionalTypeLnInvoice.check_lower(value.invoice)
        _UniffiConverterOptionalString.check_lower(value.label)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.error, buf)
        _UniffiConverterString.write(value.node_id, buf)
        _UniffiConverterOptionalTypeLnInvoice.write(value.invoice, buf)
        _UniffiConverterOptionalString.write(value.label, buf)


class PrepareOnchainPaymentRequest:
    amount_sat: "int"
    amount_type: "SwapAmountType"
    claim_tx_feerate: "int"
    def __init__(self, *, amount_sat: "int", amount_type: "SwapAmountType", claim_tx_feerate: "int"):
        self.amount_sat = amount_sat
        self.amount_type = amount_type
        self.claim_tx_feerate = claim_tx_feerate

    def __str__(self):
        return "PrepareOnchainPaymentRequest(amount_sat={}, amount_type={}, claim_tx_feerate={})".format(self.amount_sat, self.amount_type, self.claim_tx_feerate)

    def __eq__(self, other):
        if self.amount_sat != other.amount_sat:
            return False
        if self.amount_type != other.amount_type:
            return False
        if self.claim_tx_feerate != other.claim_tx_feerate:
            return False
        return True

class _UniffiConverterTypePrepareOnchainPaymentRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PrepareOnchainPaymentRequest(
            amount_sat=_UniffiConverterUInt64.read(buf),
            amount_type=_UniffiConverterTypeSwapAmountType.read(buf),
            claim_tx_feerate=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.amount_sat)
        _UniffiConverterTypeSwapAmountType.check_lower(value.amount_type)
        _UniffiConverterUInt32.check_lower(value.claim_tx_feerate)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.amount_sat, buf)
        _UniffiConverterTypeSwapAmountType.write(value.amount_type, buf)
        _UniffiConverterUInt32.write(value.claim_tx_feerate, buf)


class PrepareOnchainPaymentResponse:
    fees_hash: "str"
    fees_percentage: "float"
    fees_lockup: "int"
    fees_claim: "int"
    sender_amount_sat: "int"
    recipient_amount_sat: "int"
    total_fees: "int"
    def __init__(self, *, fees_hash: "str", fees_percentage: "float", fees_lockup: "int", fees_claim: "int", sender_amount_sat: "int", recipient_amount_sat: "int", total_fees: "int"):
        self.fees_hash = fees_hash
        self.fees_percentage = fees_percentage
        self.fees_lockup = fees_lockup
        self.fees_claim = fees_claim
        self.sender_amount_sat = sender_amount_sat
        self.recipient_amount_sat = recipient_amount_sat
        self.total_fees = total_fees

    def __str__(self):
        return "PrepareOnchainPaymentResponse(fees_hash={}, fees_percentage={}, fees_lockup={}, fees_claim={}, sender_amount_sat={}, recipient_amount_sat={}, total_fees={})".format(self.fees_hash, self.fees_percentage, self.fees_lockup, self.fees_claim, self.sender_amount_sat, self.recipient_amount_sat, self.total_fees)

    def __eq__(self, other):
        if self.fees_hash != other.fees_hash:
            return False
        if self.fees_percentage != other.fees_percentage:
            return False
        if self.fees_lockup != other.fees_lockup:
            return False
        if self.fees_claim != other.fees_claim:
            return False
        if self.sender_amount_sat != other.sender_amount_sat:
            return False
        if self.recipient_amount_sat != other.recipient_amount_sat:
            return False
        if self.total_fees != other.total_fees:
            return False
        return True

class _UniffiConverterTypePrepareOnchainPaymentResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PrepareOnchainPaymentResponse(
            fees_hash=_UniffiConverterString.read(buf),
            fees_percentage=_UniffiConverterDouble.read(buf),
            fees_lockup=_UniffiConverterUInt64.read(buf),
            fees_claim=_UniffiConverterUInt64.read(buf),
            sender_amount_sat=_UniffiConverterUInt64.read(buf),
            recipient_amount_sat=_UniffiConverterUInt64.read(buf),
            total_fees=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.fees_hash)
        _UniffiConverterDouble.check_lower(value.fees_percentage)
        _UniffiConverterUInt64.check_lower(value.fees_lockup)
        _UniffiConverterUInt64.check_lower(value.fees_claim)
        _UniffiConverterUInt64.check_lower(value.sender_amount_sat)
        _UniffiConverterUInt64.check_lower(value.recipient_amount_sat)
        _UniffiConverterUInt64.check_lower(value.total_fees)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.fees_hash, buf)
        _UniffiConverterDouble.write(value.fees_percentage, buf)
        _UniffiConverterUInt64.write(value.fees_lockup, buf)
        _UniffiConverterUInt64.write(value.fees_claim, buf)
        _UniffiConverterUInt64.write(value.sender_amount_sat, buf)
        _UniffiConverterUInt64.write(value.recipient_amount_sat, buf)
        _UniffiConverterUInt64.write(value.total_fees, buf)


class PrepareRedeemOnchainFundsRequest:
    to_address: "str"
    sat_per_vbyte: "int"
    def __init__(self, *, to_address: "str", sat_per_vbyte: "int"):
        self.to_address = to_address
        self.sat_per_vbyte = sat_per_vbyte

    def __str__(self):
        return "PrepareRedeemOnchainFundsRequest(to_address={}, sat_per_vbyte={})".format(self.to_address, self.sat_per_vbyte)

    def __eq__(self, other):
        if self.to_address != other.to_address:
            return False
        if self.sat_per_vbyte != other.sat_per_vbyte:
            return False
        return True

class _UniffiConverterTypePrepareRedeemOnchainFundsRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PrepareRedeemOnchainFundsRequest(
            to_address=_UniffiConverterString.read(buf),
            sat_per_vbyte=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.to_address)
        _UniffiConverterUInt32.check_lower(value.sat_per_vbyte)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.to_address, buf)
        _UniffiConverterUInt32.write(value.sat_per_vbyte, buf)


class PrepareRedeemOnchainFundsResponse:
    tx_weight: "int"
    tx_fee_sat: "int"
    def __init__(self, *, tx_weight: "int", tx_fee_sat: "int"):
        self.tx_weight = tx_weight
        self.tx_fee_sat = tx_fee_sat

    def __str__(self):
        return "PrepareRedeemOnchainFundsResponse(tx_weight={}, tx_fee_sat={})".format(self.tx_weight, self.tx_fee_sat)

    def __eq__(self, other):
        if self.tx_weight != other.tx_weight:
            return False
        if self.tx_fee_sat != other.tx_fee_sat:
            return False
        return True

class _UniffiConverterTypePrepareRedeemOnchainFundsResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PrepareRedeemOnchainFundsResponse(
            tx_weight=_UniffiConverterUInt64.read(buf),
            tx_fee_sat=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.tx_weight)
        _UniffiConverterUInt64.check_lower(value.tx_fee_sat)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.tx_weight, buf)
        _UniffiConverterUInt64.write(value.tx_fee_sat, buf)


class PrepareRefundRequest:
    swap_address: "str"
    to_address: "str"
    sat_per_vbyte: "int"
    unilateral: "typing.Optional[bool]"
    def __init__(self, *, swap_address: "str", to_address: "str", sat_per_vbyte: "int", unilateral: "typing.Optional[bool]" = _DEFAULT):
        self.swap_address = swap_address
        self.to_address = to_address
        self.sat_per_vbyte = sat_per_vbyte
        if unilateral is _DEFAULT:
            self.unilateral = None
        else:
            self.unilateral = unilateral

    def __str__(self):
        return "PrepareRefundRequest(swap_address={}, to_address={}, sat_per_vbyte={}, unilateral={})".format(self.swap_address, self.to_address, self.sat_per_vbyte, self.unilateral)

    def __eq__(self, other):
        if self.swap_address != other.swap_address:
            return False
        if self.to_address != other.to_address:
            return False
        if self.sat_per_vbyte != other.sat_per_vbyte:
            return False
        if self.unilateral != other.unilateral:
            return False
        return True

class _UniffiConverterTypePrepareRefundRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PrepareRefundRequest(
            swap_address=_UniffiConverterString.read(buf),
            to_address=_UniffiConverterString.read(buf),
            sat_per_vbyte=_UniffiConverterUInt32.read(buf),
            unilateral=_UniffiConverterOptionalBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.swap_address)
        _UniffiConverterString.check_lower(value.to_address)
        _UniffiConverterUInt32.check_lower(value.sat_per_vbyte)
        _UniffiConverterOptionalBool.check_lower(value.unilateral)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.swap_address, buf)
        _UniffiConverterString.write(value.to_address, buf)
        _UniffiConverterUInt32.write(value.sat_per_vbyte, buf)
        _UniffiConverterOptionalBool.write(value.unilateral, buf)


class PrepareRefundResponse:
    refund_tx_weight: "int"
    refund_tx_fee_sat: "int"
    def __init__(self, *, refund_tx_weight: "int", refund_tx_fee_sat: "int"):
        self.refund_tx_weight = refund_tx_weight
        self.refund_tx_fee_sat = refund_tx_fee_sat

    def __str__(self):
        return "PrepareRefundResponse(refund_tx_weight={}, refund_tx_fee_sat={})".format(self.refund_tx_weight, self.refund_tx_fee_sat)

    def __eq__(self, other):
        if self.refund_tx_weight != other.refund_tx_weight:
            return False
        if self.refund_tx_fee_sat != other.refund_tx_fee_sat:
            return False
        return True

class _UniffiConverterTypePrepareRefundResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PrepareRefundResponse(
            refund_tx_weight=_UniffiConverterUInt32.read(buf),
            refund_tx_fee_sat=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt32.check_lower(value.refund_tx_weight)
        _UniffiConverterUInt64.check_lower(value.refund_tx_fee_sat)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.refund_tx_weight, buf)
        _UniffiConverterUInt64.write(value.refund_tx_fee_sat, buf)


class Rate:
    coin: "str"
    value: "float"
    def __init__(self, *, coin: "str", value: "float"):
        self.coin = coin
        self.value = value

    def __str__(self):
        return "Rate(coin={}, value={})".format(self.coin, self.value)

    def __eq__(self, other):
        if self.coin != other.coin:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeRate(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Rate(
            coin=_UniffiConverterString.read(buf),
            value=_UniffiConverterDouble.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.coin)
        _UniffiConverterDouble.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.coin, buf)
        _UniffiConverterDouble.write(value.value, buf)


class ReceiveOnchainRequest:
    opening_fee_params: "typing.Optional[OpeningFeeParams]"
    def __init__(self, *, opening_fee_params: "typing.Optional[OpeningFeeParams]" = _DEFAULT):
        if opening_fee_params is _DEFAULT:
            self.opening_fee_params = None
        else:
            self.opening_fee_params = opening_fee_params

    def __str__(self):
        return "ReceiveOnchainRequest(opening_fee_params={})".format(self.opening_fee_params)

    def __eq__(self, other):
        if self.opening_fee_params != other.opening_fee_params:
            return False
        return True

class _UniffiConverterTypeReceiveOnchainRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReceiveOnchainRequest(
            opening_fee_params=_UniffiConverterOptionalTypeOpeningFeeParams.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalTypeOpeningFeeParams.check_lower(value.opening_fee_params)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeOpeningFeeParams.write(value.opening_fee_params, buf)


class ReceivePaymentRequest:
    amount_msat: "int"
    description: "str"
    preimage: "typing.Optional[typing.List[int]]"
    opening_fee_params: "typing.Optional[OpeningFeeParams]"
    use_description_hash: "typing.Optional[bool]"
    expiry: "typing.Optional[int]"
    cltv: "typing.Optional[int]"
    def __init__(self, *, amount_msat: "int", description: "str", preimage: "typing.Optional[typing.List[int]]" = _DEFAULT, opening_fee_params: "typing.Optional[OpeningFeeParams]" = _DEFAULT, use_description_hash: "typing.Optional[bool]" = _DEFAULT, expiry: "typing.Optional[int]" = _DEFAULT, cltv: "typing.Optional[int]" = _DEFAULT):
        self.amount_msat = amount_msat
        self.description = description
        if preimage is _DEFAULT:
            self.preimage = None
        else:
            self.preimage = preimage
        if opening_fee_params is _DEFAULT:
            self.opening_fee_params = None
        else:
            self.opening_fee_params = opening_fee_params
        if use_description_hash is _DEFAULT:
            self.use_description_hash = None
        else:
            self.use_description_hash = use_description_hash
        if expiry is _DEFAULT:
            self.expiry = None
        else:
            self.expiry = expiry
        if cltv is _DEFAULT:
            self.cltv = None
        else:
            self.cltv = cltv

    def __str__(self):
        return "ReceivePaymentRequest(amount_msat={}, description={}, preimage={}, opening_fee_params={}, use_description_hash={}, expiry={}, cltv={})".format(self.amount_msat, self.description, self.preimage, self.opening_fee_params, self.use_description_hash, self.expiry, self.cltv)

    def __eq__(self, other):
        if self.amount_msat != other.amount_msat:
            return False
        if self.description != other.description:
            return False
        if self.preimage != other.preimage:
            return False
        if self.opening_fee_params != other.opening_fee_params:
            return False
        if self.use_description_hash != other.use_description_hash:
            return False
        if self.expiry != other.expiry:
            return False
        if self.cltv != other.cltv:
            return False
        return True

class _UniffiConverterTypeReceivePaymentRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReceivePaymentRequest(
            amount_msat=_UniffiConverterUInt64.read(buf),
            description=_UniffiConverterString.read(buf),
            preimage=_UniffiConverterOptionalSequenceUInt8.read(buf),
            opening_fee_params=_UniffiConverterOptionalTypeOpeningFeeParams.read(buf),
            use_description_hash=_UniffiConverterOptionalBool.read(buf),
            expiry=_UniffiConverterOptionalUInt32.read(buf),
            cltv=_UniffiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.amount_msat)
        _UniffiConverterString.check_lower(value.description)
        _UniffiConverterOptionalSequenceUInt8.check_lower(value.preimage)
        _UniffiConverterOptionalTypeOpeningFeeParams.check_lower(value.opening_fee_params)
        _UniffiConverterOptionalBool.check_lower(value.use_description_hash)
        _UniffiConverterOptionalUInt32.check_lower(value.expiry)
        _UniffiConverterOptionalUInt32.check_lower(value.cltv)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.amount_msat, buf)
        _UniffiConverterString.write(value.description, buf)
        _UniffiConverterOptionalSequenceUInt8.write(value.preimage, buf)
        _UniffiConverterOptionalTypeOpeningFeeParams.write(value.opening_fee_params, buf)
        _UniffiConverterOptionalBool.write(value.use_description_hash, buf)
        _UniffiConverterOptionalUInt32.write(value.expiry, buf)
        _UniffiConverterOptionalUInt32.write(value.cltv, buf)


class ReceivePaymentResponse:
    ln_invoice: "LnInvoice"
    opening_fee_params: "typing.Optional[OpeningFeeParams]"
    opening_fee_msat: "typing.Optional[int]"
    def __init__(self, *, ln_invoice: "LnInvoice", opening_fee_params: "typing.Optional[OpeningFeeParams]", opening_fee_msat: "typing.Optional[int]"):
        self.ln_invoice = ln_invoice
        self.opening_fee_params = opening_fee_params
        self.opening_fee_msat = opening_fee_msat

    def __str__(self):
        return "ReceivePaymentResponse(ln_invoice={}, opening_fee_params={}, opening_fee_msat={})".format(self.ln_invoice, self.opening_fee_params, self.opening_fee_msat)

    def __eq__(self, other):
        if self.ln_invoice != other.ln_invoice:
            return False
        if self.opening_fee_params != other.opening_fee_params:
            return False
        if self.opening_fee_msat != other.opening_fee_msat:
            return False
        return True

class _UniffiConverterTypeReceivePaymentResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReceivePaymentResponse(
            ln_invoice=_UniffiConverterTypeLnInvoice.read(buf),
            opening_fee_params=_UniffiConverterOptionalTypeOpeningFeeParams.read(buf),
            opening_fee_msat=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeLnInvoice.check_lower(value.ln_invoice)
        _UniffiConverterOptionalTypeOpeningFeeParams.check_lower(value.opening_fee_params)
        _UniffiConverterOptionalUInt64.check_lower(value.opening_fee_msat)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeLnInvoice.write(value.ln_invoice, buf)
        _UniffiConverterOptionalTypeOpeningFeeParams.write(value.opening_fee_params, buf)
        _UniffiConverterOptionalUInt64.write(value.opening_fee_msat, buf)


class RecommendedFees:
    fastest_fee: "int"
    half_hour_fee: "int"
    hour_fee: "int"
    economy_fee: "int"
    minimum_fee: "int"
    def __init__(self, *, fastest_fee: "int", half_hour_fee: "int", hour_fee: "int", economy_fee: "int", minimum_fee: "int"):
        self.fastest_fee = fastest_fee
        self.half_hour_fee = half_hour_fee
        self.hour_fee = hour_fee
        self.economy_fee = economy_fee
        self.minimum_fee = minimum_fee

    def __str__(self):
        return "RecommendedFees(fastest_fee={}, half_hour_fee={}, hour_fee={}, economy_fee={}, minimum_fee={})".format(self.fastest_fee, self.half_hour_fee, self.hour_fee, self.economy_fee, self.minimum_fee)

    def __eq__(self, other):
        if self.fastest_fee != other.fastest_fee:
            return False
        if self.half_hour_fee != other.half_hour_fee:
            return False
        if self.hour_fee != other.hour_fee:
            return False
        if self.economy_fee != other.economy_fee:
            return False
        if self.minimum_fee != other.minimum_fee:
            return False
        return True

class _UniffiConverterTypeRecommendedFees(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RecommendedFees(
            fastest_fee=_UniffiConverterUInt64.read(buf),
            half_hour_fee=_UniffiConverterUInt64.read(buf),
            hour_fee=_UniffiConverterUInt64.read(buf),
            economy_fee=_UniffiConverterUInt64.read(buf),
            minimum_fee=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.fastest_fee)
        _UniffiConverterUInt64.check_lower(value.half_hour_fee)
        _UniffiConverterUInt64.check_lower(value.hour_fee)
        _UniffiConverterUInt64.check_lower(value.economy_fee)
        _UniffiConverterUInt64.check_lower(value.minimum_fee)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.fastest_fee, buf)
        _UniffiConverterUInt64.write(value.half_hour_fee, buf)
        _UniffiConverterUInt64.write(value.hour_fee, buf)
        _UniffiConverterUInt64.write(value.economy_fee, buf)
        _UniffiConverterUInt64.write(value.minimum_fee, buf)


class RedeemOnchainFundsRequest:
    to_address: "str"
    sat_per_vbyte: "int"
    def __init__(self, *, to_address: "str", sat_per_vbyte: "int"):
        self.to_address = to_address
        self.sat_per_vbyte = sat_per_vbyte

    def __str__(self):
        return "RedeemOnchainFundsRequest(to_address={}, sat_per_vbyte={})".format(self.to_address, self.sat_per_vbyte)

    def __eq__(self, other):
        if self.to_address != other.to_address:
            return False
        if self.sat_per_vbyte != other.sat_per_vbyte:
            return False
        return True

class _UniffiConverterTypeRedeemOnchainFundsRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RedeemOnchainFundsRequest(
            to_address=_UniffiConverterString.read(buf),
            sat_per_vbyte=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.to_address)
        _UniffiConverterUInt32.check_lower(value.sat_per_vbyte)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.to_address, buf)
        _UniffiConverterUInt32.write(value.sat_per_vbyte, buf)


class RedeemOnchainFundsResponse:
    txid: "typing.List[int]"
    def __init__(self, *, txid: "typing.List[int]"):
        self.txid = txid

    def __str__(self):
        return "RedeemOnchainFundsResponse(txid={})".format(self.txid)

    def __eq__(self, other):
        if self.txid != other.txid:
            return False
        return True

class _UniffiConverterTypeRedeemOnchainFundsResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RedeemOnchainFundsResponse(
            txid=_UniffiConverterSequenceUInt8.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceUInt8.check_lower(value.txid)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceUInt8.write(value.txid, buf)


class RefundRequest:
    swap_address: "str"
    to_address: "str"
    sat_per_vbyte: "int"
    unilateral: "typing.Optional[bool]"
    def __init__(self, *, swap_address: "str", to_address: "str", sat_per_vbyte: "int", unilateral: "typing.Optional[bool]" = _DEFAULT):
        self.swap_address = swap_address
        self.to_address = to_address
        self.sat_per_vbyte = sat_per_vbyte
        if unilateral is _DEFAULT:
            self.unilateral = None
        else:
            self.unilateral = unilateral

    def __str__(self):
        return "RefundRequest(swap_address={}, to_address={}, sat_per_vbyte={}, unilateral={})".format(self.swap_address, self.to_address, self.sat_per_vbyte, self.unilateral)

    def __eq__(self, other):
        if self.swap_address != other.swap_address:
            return False
        if self.to_address != other.to_address:
            return False
        if self.sat_per_vbyte != other.sat_per_vbyte:
            return False
        if self.unilateral != other.unilateral:
            return False
        return True

class _UniffiConverterTypeRefundRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RefundRequest(
            swap_address=_UniffiConverterString.read(buf),
            to_address=_UniffiConverterString.read(buf),
            sat_per_vbyte=_UniffiConverterUInt32.read(buf),
            unilateral=_UniffiConverterOptionalBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.swap_address)
        _UniffiConverterString.check_lower(value.to_address)
        _UniffiConverterUInt32.check_lower(value.sat_per_vbyte)
        _UniffiConverterOptionalBool.check_lower(value.unilateral)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.swap_address, buf)
        _UniffiConverterString.write(value.to_address, buf)
        _UniffiConverterUInt32.write(value.sat_per_vbyte, buf)
        _UniffiConverterOptionalBool.write(value.unilateral, buf)


class RefundResponse:
    refund_tx_id: "str"
    def __init__(self, *, refund_tx_id: "str"):
        self.refund_tx_id = refund_tx_id

    def __str__(self):
        return "RefundResponse(refund_tx_id={})".format(self.refund_tx_id)

    def __eq__(self, other):
        if self.refund_tx_id != other.refund_tx_id:
            return False
        return True

class _UniffiConverterTypeRefundResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RefundResponse(
            refund_tx_id=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.refund_tx_id)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.refund_tx_id, buf)


class ReportPaymentFailureDetails:
    payment_hash: "str"
    comment: "typing.Optional[str]"
    def __init__(self, *, payment_hash: "str", comment: "typing.Optional[str]" = _DEFAULT):
        self.payment_hash = payment_hash
        if comment is _DEFAULT:
            self.comment = None
        else:
            self.comment = comment

    def __str__(self):
        return "ReportPaymentFailureDetails(payment_hash={}, comment={})".format(self.payment_hash, self.comment)

    def __eq__(self, other):
        if self.payment_hash != other.payment_hash:
            return False
        if self.comment != other.comment:
            return False
        return True

class _UniffiConverterTypeReportPaymentFailureDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReportPaymentFailureDetails(
            payment_hash=_UniffiConverterString.read(buf),
            comment=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.payment_hash)
        _UniffiConverterOptionalString.check_lower(value.comment)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.payment_hash, buf)
        _UniffiConverterOptionalString.write(value.comment, buf)


class ReverseSwapFeesRequest:
    send_amount_sat: "typing.Optional[int]"
    claim_tx_feerate: "typing.Optional[int]"
    def __init__(self, *, send_amount_sat: "typing.Optional[int]" = _DEFAULT, claim_tx_feerate: "typing.Optional[int]" = _DEFAULT):
        if send_amount_sat is _DEFAULT:
            self.send_amount_sat = None
        else:
            self.send_amount_sat = send_amount_sat
        if claim_tx_feerate is _DEFAULT:
            self.claim_tx_feerate = None
        else:
            self.claim_tx_feerate = claim_tx_feerate

    def __str__(self):
        return "ReverseSwapFeesRequest(send_amount_sat={}, claim_tx_feerate={})".format(self.send_amount_sat, self.claim_tx_feerate)

    def __eq__(self, other):
        if self.send_amount_sat != other.send_amount_sat:
            return False
        if self.claim_tx_feerate != other.claim_tx_feerate:
            return False
        return True

class _UniffiConverterTypeReverseSwapFeesRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReverseSwapFeesRequest(
            send_amount_sat=_UniffiConverterOptionalUInt64.read(buf),
            claim_tx_feerate=_UniffiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalUInt64.check_lower(value.send_amount_sat)
        _UniffiConverterOptionalUInt32.check_lower(value.claim_tx_feerate)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalUInt64.write(value.send_amount_sat, buf)
        _UniffiConverterOptionalUInt32.write(value.claim_tx_feerate, buf)


class ReverseSwapInfo:
    id: "str"
    claim_pubkey: "str"
    lockup_txid: "typing.Optional[str]"
    claim_txid: "typing.Optional[str]"
    onchain_amount_sat: "int"
    status: "ReverseSwapStatus"
    def __init__(self, *, id: "str", claim_pubkey: "str", lockup_txid: "typing.Optional[str]", claim_txid: "typing.Optional[str]", onchain_amount_sat: "int", status: "ReverseSwapStatus"):
        self.id = id
        self.claim_pubkey = claim_pubkey
        self.lockup_txid = lockup_txid
        self.claim_txid = claim_txid
        self.onchain_amount_sat = onchain_amount_sat
        self.status = status

    def __str__(self):
        return "ReverseSwapInfo(id={}, claim_pubkey={}, lockup_txid={}, claim_txid={}, onchain_amount_sat={}, status={})".format(self.id, self.claim_pubkey, self.lockup_txid, self.claim_txid, self.onchain_amount_sat, self.status)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.claim_pubkey != other.claim_pubkey:
            return False
        if self.lockup_txid != other.lockup_txid:
            return False
        if self.claim_txid != other.claim_txid:
            return False
        if self.onchain_amount_sat != other.onchain_amount_sat:
            return False
        if self.status != other.status:
            return False
        return True

class _UniffiConverterTypeReverseSwapInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReverseSwapInfo(
            id=_UniffiConverterString.read(buf),
            claim_pubkey=_UniffiConverterString.read(buf),
            lockup_txid=_UniffiConverterOptionalString.read(buf),
            claim_txid=_UniffiConverterOptionalString.read(buf),
            onchain_amount_sat=_UniffiConverterUInt64.read(buf),
            status=_UniffiConverterTypeReverseSwapStatus.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterString.check_lower(value.claim_pubkey)
        _UniffiConverterOptionalString.check_lower(value.lockup_txid)
        _UniffiConverterOptionalString.check_lower(value.claim_txid)
        _UniffiConverterUInt64.check_lower(value.onchain_amount_sat)
        _UniffiConverterTypeReverseSwapStatus.check_lower(value.status)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterString.write(value.claim_pubkey, buf)
        _UniffiConverterOptionalString.write(value.lockup_txid, buf)
        _UniffiConverterOptionalString.write(value.claim_txid, buf)
        _UniffiConverterUInt64.write(value.onchain_amount_sat, buf)
        _UniffiConverterTypeReverseSwapStatus.write(value.status, buf)


class ReverseSwapPairInfo:
    min: "int"
    max: "int"
    fees_hash: "str"
    fees_percentage: "float"
    fees_lockup: "int"
    fees_claim: "int"
    total_fees: "typing.Optional[int]"
    def __init__(self, *, min: "int", max: "int", fees_hash: "str", fees_percentage: "float", fees_lockup: "int", fees_claim: "int", total_fees: "typing.Optional[int]"):
        self.min = min
        self.max = max
        self.fees_hash = fees_hash
        self.fees_percentage = fees_percentage
        self.fees_lockup = fees_lockup
        self.fees_claim = fees_claim
        self.total_fees = total_fees

    def __str__(self):
        return "ReverseSwapPairInfo(min={}, max={}, fees_hash={}, fees_percentage={}, fees_lockup={}, fees_claim={}, total_fees={})".format(self.min, self.max, self.fees_hash, self.fees_percentage, self.fees_lockup, self.fees_claim, self.total_fees)

    def __eq__(self, other):
        if self.min != other.min:
            return False
        if self.max != other.max:
            return False
        if self.fees_hash != other.fees_hash:
            return False
        if self.fees_percentage != other.fees_percentage:
            return False
        if self.fees_lockup != other.fees_lockup:
            return False
        if self.fees_claim != other.fees_claim:
            return False
        if self.total_fees != other.total_fees:
            return False
        return True

class _UniffiConverterTypeReverseSwapPairInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReverseSwapPairInfo(
            min=_UniffiConverterUInt64.read(buf),
            max=_UniffiConverterUInt64.read(buf),
            fees_hash=_UniffiConverterString.read(buf),
            fees_percentage=_UniffiConverterDouble.read(buf),
            fees_lockup=_UniffiConverterUInt64.read(buf),
            fees_claim=_UniffiConverterUInt64.read(buf),
            total_fees=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.min)
        _UniffiConverterUInt64.check_lower(value.max)
        _UniffiConverterString.check_lower(value.fees_hash)
        _UniffiConverterDouble.check_lower(value.fees_percentage)
        _UniffiConverterUInt64.check_lower(value.fees_lockup)
        _UniffiConverterUInt64.check_lower(value.fees_claim)
        _UniffiConverterOptionalUInt64.check_lower(value.total_fees)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.min, buf)
        _UniffiConverterUInt64.write(value.max, buf)
        _UniffiConverterString.write(value.fees_hash, buf)
        _UniffiConverterDouble.write(value.fees_percentage, buf)
        _UniffiConverterUInt64.write(value.fees_lockup, buf)
        _UniffiConverterUInt64.write(value.fees_claim, buf)
        _UniffiConverterOptionalUInt64.write(value.total_fees, buf)


class RouteHint:
    hops: "typing.List[RouteHintHop]"
    def __init__(self, *, hops: "typing.List[RouteHintHop]"):
        self.hops = hops

    def __str__(self):
        return "RouteHint(hops={})".format(self.hops)

    def __eq__(self, other):
        if self.hops != other.hops:
            return False
        return True

class _UniffiConverterTypeRouteHint(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RouteHint(
            hops=_UniffiConverterSequenceTypeRouteHintHop.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeRouteHintHop.check_lower(value.hops)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeRouteHintHop.write(value.hops, buf)


class RouteHintHop:
    src_node_id: "str"
    short_channel_id: "str"
    fees_base_msat: "int"
    fees_proportional_millionths: "int"
    cltv_expiry_delta: "int"
    htlc_minimum_msat: "typing.Optional[int]"
    htlc_maximum_msat: "typing.Optional[int]"
    def __init__(self, *, src_node_id: "str", short_channel_id: "str", fees_base_msat: "int", fees_proportional_millionths: "int", cltv_expiry_delta: "int", htlc_minimum_msat: "typing.Optional[int]", htlc_maximum_msat: "typing.Optional[int]"):
        self.src_node_id = src_node_id
        self.short_channel_id = short_channel_id
        self.fees_base_msat = fees_base_msat
        self.fees_proportional_millionths = fees_proportional_millionths
        self.cltv_expiry_delta = cltv_expiry_delta
        self.htlc_minimum_msat = htlc_minimum_msat
        self.htlc_maximum_msat = htlc_maximum_msat

    def __str__(self):
        return "RouteHintHop(src_node_id={}, short_channel_id={}, fees_base_msat={}, fees_proportional_millionths={}, cltv_expiry_delta={}, htlc_minimum_msat={}, htlc_maximum_msat={})".format(self.src_node_id, self.short_channel_id, self.fees_base_msat, self.fees_proportional_millionths, self.cltv_expiry_delta, self.htlc_minimum_msat, self.htlc_maximum_msat)

    def __eq__(self, other):
        if self.src_node_id != other.src_node_id:
            return False
        if self.short_channel_id != other.short_channel_id:
            return False
        if self.fees_base_msat != other.fees_base_msat:
            return False
        if self.fees_proportional_millionths != other.fees_proportional_millionths:
            return False
        if self.cltv_expiry_delta != other.cltv_expiry_delta:
            return False
        if self.htlc_minimum_msat != other.htlc_minimum_msat:
            return False
        if self.htlc_maximum_msat != other.htlc_maximum_msat:
            return False
        return True

class _UniffiConverterTypeRouteHintHop(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RouteHintHop(
            src_node_id=_UniffiConverterString.read(buf),
            short_channel_id=_UniffiConverterString.read(buf),
            fees_base_msat=_UniffiConverterUInt32.read(buf),
            fees_proportional_millionths=_UniffiConverterUInt32.read(buf),
            cltv_expiry_delta=_UniffiConverterUInt64.read(buf),
            htlc_minimum_msat=_UniffiConverterOptionalUInt64.read(buf),
            htlc_maximum_msat=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.src_node_id)
        _UniffiConverterString.check_lower(value.short_channel_id)
        _UniffiConverterUInt32.check_lower(value.fees_base_msat)
        _UniffiConverterUInt32.check_lower(value.fees_proportional_millionths)
        _UniffiConverterUInt64.check_lower(value.cltv_expiry_delta)
        _UniffiConverterOptionalUInt64.check_lower(value.htlc_minimum_msat)
        _UniffiConverterOptionalUInt64.check_lower(value.htlc_maximum_msat)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.src_node_id, buf)
        _UniffiConverterString.write(value.short_channel_id, buf)
        _UniffiConverterUInt32.write(value.fees_base_msat, buf)
        _UniffiConverterUInt32.write(value.fees_proportional_millionths, buf)
        _UniffiConverterUInt64.write(value.cltv_expiry_delta, buf)
        _UniffiConverterOptionalUInt64.write(value.htlc_minimum_msat, buf)
        _UniffiConverterOptionalUInt64.write(value.htlc_maximum_msat, buf)


class SendPaymentRequest:
    bolt11: "str"
    use_trampoline: "bool"
    amount_msat: "typing.Optional[int]"
    label: "typing.Optional[str]"
    def __init__(self, *, bolt11: "str", use_trampoline: "bool", amount_msat: "typing.Optional[int]" = _DEFAULT, label: "typing.Optional[str]" = _DEFAULT):
        self.bolt11 = bolt11
        self.use_trampoline = use_trampoline
        if amount_msat is _DEFAULT:
            self.amount_msat = None
        else:
            self.amount_msat = amount_msat
        if label is _DEFAULT:
            self.label = None
        else:
            self.label = label

    def __str__(self):
        return "SendPaymentRequest(bolt11={}, use_trampoline={}, amount_msat={}, label={})".format(self.bolt11, self.use_trampoline, self.amount_msat, self.label)

    def __eq__(self, other):
        if self.bolt11 != other.bolt11:
            return False
        if self.use_trampoline != other.use_trampoline:
            return False
        if self.amount_msat != other.amount_msat:
            return False
        if self.label != other.label:
            return False
        return True

class _UniffiConverterTypeSendPaymentRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SendPaymentRequest(
            bolt11=_UniffiConverterString.read(buf),
            use_trampoline=_UniffiConverterBool.read(buf),
            amount_msat=_UniffiConverterOptionalUInt64.read(buf),
            label=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.bolt11)
        _UniffiConverterBool.check_lower(value.use_trampoline)
        _UniffiConverterOptionalUInt64.check_lower(value.amount_msat)
        _UniffiConverterOptionalString.check_lower(value.label)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.bolt11, buf)
        _UniffiConverterBool.write(value.use_trampoline, buf)
        _UniffiConverterOptionalUInt64.write(value.amount_msat, buf)
        _UniffiConverterOptionalString.write(value.label, buf)


class SendPaymentResponse:
    payment: "Payment"
    def __init__(self, *, payment: "Payment"):
        self.payment = payment

    def __str__(self):
        return "SendPaymentResponse(payment={})".format(self.payment)

    def __eq__(self, other):
        if self.payment != other.payment:
            return False
        return True

class _UniffiConverterTypeSendPaymentResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SendPaymentResponse(
            payment=_UniffiConverterTypePayment.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePayment.check_lower(value.payment)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePayment.write(value.payment, buf)


class SendSpontaneousPaymentRequest:
    node_id: "str"
    amount_msat: "int"
    extra_tlvs: "typing.Optional[typing.List[TlvEntry]]"
    label: "typing.Optional[str]"
    def __init__(self, *, node_id: "str", amount_msat: "int", extra_tlvs: "typing.Optional[typing.List[TlvEntry]]" = _DEFAULT, label: "typing.Optional[str]" = _DEFAULT):
        self.node_id = node_id
        self.amount_msat = amount_msat
        if extra_tlvs is _DEFAULT:
            self.extra_tlvs = None
        else:
            self.extra_tlvs = extra_tlvs
        if label is _DEFAULT:
            self.label = None
        else:
            self.label = label

    def __str__(self):
        return "SendSpontaneousPaymentRequest(node_id={}, amount_msat={}, extra_tlvs={}, label={})".format(self.node_id, self.amount_msat, self.extra_tlvs, self.label)

    def __eq__(self, other):
        if self.node_id != other.node_id:
            return False
        if self.amount_msat != other.amount_msat:
            return False
        if self.extra_tlvs != other.extra_tlvs:
            return False
        if self.label != other.label:
            return False
        return True

class _UniffiConverterTypeSendSpontaneousPaymentRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SendSpontaneousPaymentRequest(
            node_id=_UniffiConverterString.read(buf),
            amount_msat=_UniffiConverterUInt64.read(buf),
            extra_tlvs=_UniffiConverterOptionalSequenceTypeTlvEntry.read(buf),
            label=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.node_id)
        _UniffiConverterUInt64.check_lower(value.amount_msat)
        _UniffiConverterOptionalSequenceTypeTlvEntry.check_lower(value.extra_tlvs)
        _UniffiConverterOptionalString.check_lower(value.label)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.node_id, buf)
        _UniffiConverterUInt64.write(value.amount_msat, buf)
        _UniffiConverterOptionalSequenceTypeTlvEntry.write(value.extra_tlvs, buf)
        _UniffiConverterOptionalString.write(value.label, buf)


class ServiceHealthCheckResponse:
    status: "HealthCheckStatus"
    def __init__(self, *, status: "HealthCheckStatus"):
        self.status = status

    def __str__(self):
        return "ServiceHealthCheckResponse(status={})".format(self.status)

    def __eq__(self, other):
        if self.status != other.status:
            return False
        return True

class _UniffiConverterTypeServiceHealthCheckResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ServiceHealthCheckResponse(
            status=_UniffiConverterTypeHealthCheckStatus.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeHealthCheckStatus.check_lower(value.status)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeHealthCheckStatus.write(value.status, buf)


class SignMessageRequest:
    message: "str"
    def __init__(self, *, message: "str"):
        self.message = message

    def __str__(self):
        return "SignMessageRequest(message={})".format(self.message)

    def __eq__(self, other):
        if self.message != other.message:
            return False
        return True

class _UniffiConverterTypeSignMessageRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SignMessageRequest(
            message=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.message)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.message, buf)


class SignMessageResponse:
    signature: "str"
    def __init__(self, *, signature: "str"):
        self.signature = signature

    def __str__(self):
        return "SignMessageResponse(signature={})".format(self.signature)

    def __eq__(self, other):
        if self.signature != other.signature:
            return False
        return True

class _UniffiConverterTypeSignMessageResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SignMessageResponse(
            signature=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.signature)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.signature, buf)


class StaticBackupRequest:
    working_dir: "str"
    def __init__(self, *, working_dir: "str"):
        self.working_dir = working_dir

    def __str__(self):
        return "StaticBackupRequest(working_dir={})".format(self.working_dir)

    def __eq__(self, other):
        if self.working_dir != other.working_dir:
            return False
        return True

class _UniffiConverterTypeStaticBackupRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StaticBackupRequest(
            working_dir=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.working_dir)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.working_dir, buf)


class StaticBackupResponse:
    backup: "typing.Optional[typing.List[str]]"
    def __init__(self, *, backup: "typing.Optional[typing.List[str]]"):
        self.backup = backup

    def __str__(self):
        return "StaticBackupResponse(backup={})".format(self.backup)

    def __eq__(self, other):
        if self.backup != other.backup:
            return False
        return True

class _UniffiConverterTypeStaticBackupResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StaticBackupResponse(
            backup=_UniffiConverterOptionalSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalSequenceString.check_lower(value.backup)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalSequenceString.write(value.backup, buf)


class SwapInfo:
    bitcoin_address: "str"
    created_at: "int"
    lock_height: "int"
    payment_hash: "typing.List[int]"
    preimage: "typing.List[int]"
    private_key: "typing.List[int]"
    public_key: "typing.List[int]"
    swapper_public_key: "typing.List[int]"
    script: "typing.List[int]"
    bolt11: "typing.Optional[str]"
    paid_msat: "int"
    unconfirmed_sats: "int"
    confirmed_sats: "int"
    total_incoming_txs: "int"
    status: "SwapStatus"
    refund_tx_ids: "typing.List[str]"
    unconfirmed_tx_ids: "typing.List[str]"
    confirmed_tx_ids: "typing.List[str]"
    min_allowed_deposit: "int"
    max_allowed_deposit: "int"
    max_swapper_payable: "int"
    last_redeem_error: "typing.Optional[str]"
    channel_opening_fees: "typing.Optional[OpeningFeeParams]"
    confirmed_at: "typing.Optional[int]"
    def __init__(self, *, bitcoin_address: "str", created_at: "int", lock_height: "int", payment_hash: "typing.List[int]", preimage: "typing.List[int]", private_key: "typing.List[int]", public_key: "typing.List[int]", swapper_public_key: "typing.List[int]", script: "typing.List[int]", bolt11: "typing.Optional[str]", paid_msat: "int", unconfirmed_sats: "int", confirmed_sats: "int", total_incoming_txs: "int", status: "SwapStatus", refund_tx_ids: "typing.List[str]", unconfirmed_tx_ids: "typing.List[str]", confirmed_tx_ids: "typing.List[str]", min_allowed_deposit: "int", max_allowed_deposit: "int", max_swapper_payable: "int", last_redeem_error: "typing.Optional[str]", channel_opening_fees: "typing.Optional[OpeningFeeParams]", confirmed_at: "typing.Optional[int]"):
        self.bitcoin_address = bitcoin_address
        self.created_at = created_at
        self.lock_height = lock_height
        self.payment_hash = payment_hash
        self.preimage = preimage
        self.private_key = private_key
        self.public_key = public_key
        self.swapper_public_key = swapper_public_key
        self.script = script
        self.bolt11 = bolt11
        self.paid_msat = paid_msat
        self.unconfirmed_sats = unconfirmed_sats
        self.confirmed_sats = confirmed_sats
        self.total_incoming_txs = total_incoming_txs
        self.status = status
        self.refund_tx_ids = refund_tx_ids
        self.unconfirmed_tx_ids = unconfirmed_tx_ids
        self.confirmed_tx_ids = confirmed_tx_ids
        self.min_allowed_deposit = min_allowed_deposit
        self.max_allowed_deposit = max_allowed_deposit
        self.max_swapper_payable = max_swapper_payable
        self.last_redeem_error = last_redeem_error
        self.channel_opening_fees = channel_opening_fees
        self.confirmed_at = confirmed_at

    def __str__(self):
        return "SwapInfo(bitcoin_address={}, created_at={}, lock_height={}, payment_hash={}, preimage={}, private_key={}, public_key={}, swapper_public_key={}, script={}, bolt11={}, paid_msat={}, unconfirmed_sats={}, confirmed_sats={}, total_incoming_txs={}, status={}, refund_tx_ids={}, unconfirmed_tx_ids={}, confirmed_tx_ids={}, min_allowed_deposit={}, max_allowed_deposit={}, max_swapper_payable={}, last_redeem_error={}, channel_opening_fees={}, confirmed_at={})".format(self.bitcoin_address, self.created_at, self.lock_height, self.payment_hash, self.preimage, self.private_key, self.public_key, self.swapper_public_key, self.script, self.bolt11, self.paid_msat, self.unconfirmed_sats, self.confirmed_sats, self.total_incoming_txs, self.status, self.refund_tx_ids, self.unconfirmed_tx_ids, self.confirmed_tx_ids, self.min_allowed_deposit, self.max_allowed_deposit, self.max_swapper_payable, self.last_redeem_error, self.channel_opening_fees, self.confirmed_at)

    def __eq__(self, other):
        if self.bitcoin_address != other.bitcoin_address:
            return False
        if self.created_at != other.created_at:
            return False
        if self.lock_height != other.lock_height:
            return False
        if self.payment_hash != other.payment_hash:
            return False
        if self.preimage != other.preimage:
            return False
        if self.private_key != other.private_key:
            return False
        if self.public_key != other.public_key:
            return False
        if self.swapper_public_key != other.swapper_public_key:
            return False
        if self.script != other.script:
            return False
        if self.bolt11 != other.bolt11:
            return False
        if self.paid_msat != other.paid_msat:
            return False
        if self.unconfirmed_sats != other.unconfirmed_sats:
            return False
        if self.confirmed_sats != other.confirmed_sats:
            return False
        if self.total_incoming_txs != other.total_incoming_txs:
            return False
        if self.status != other.status:
            return False
        if self.refund_tx_ids != other.refund_tx_ids:
            return False
        if self.unconfirmed_tx_ids != other.unconfirmed_tx_ids:
            return False
        if self.confirmed_tx_ids != other.confirmed_tx_ids:
            return False
        if self.min_allowed_deposit != other.min_allowed_deposit:
            return False
        if self.max_allowed_deposit != other.max_allowed_deposit:
            return False
        if self.max_swapper_payable != other.max_swapper_payable:
            return False
        if self.last_redeem_error != other.last_redeem_error:
            return False
        if self.channel_opening_fees != other.channel_opening_fees:
            return False
        if self.confirmed_at != other.confirmed_at:
            return False
        return True

class _UniffiConverterTypeSwapInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SwapInfo(
            bitcoin_address=_UniffiConverterString.read(buf),
            created_at=_UniffiConverterInt64.read(buf),
            lock_height=_UniffiConverterInt64.read(buf),
            payment_hash=_UniffiConverterSequenceUInt8.read(buf),
            preimage=_UniffiConverterSequenceUInt8.read(buf),
            private_key=_UniffiConverterSequenceUInt8.read(buf),
            public_key=_UniffiConverterSequenceUInt8.read(buf),
            swapper_public_key=_UniffiConverterSequenceUInt8.read(buf),
            script=_UniffiConverterSequenceUInt8.read(buf),
            bolt11=_UniffiConverterOptionalString.read(buf),
            paid_msat=_UniffiConverterUInt64.read(buf),
            unconfirmed_sats=_UniffiConverterUInt64.read(buf),
            confirmed_sats=_UniffiConverterUInt64.read(buf),
            total_incoming_txs=_UniffiConverterUInt64.read(buf),
            status=_UniffiConverterTypeSwapStatus.read(buf),
            refund_tx_ids=_UniffiConverterSequenceString.read(buf),
            unconfirmed_tx_ids=_UniffiConverterSequenceString.read(buf),
            confirmed_tx_ids=_UniffiConverterSequenceString.read(buf),
            min_allowed_deposit=_UniffiConverterInt64.read(buf),
            max_allowed_deposit=_UniffiConverterInt64.read(buf),
            max_swapper_payable=_UniffiConverterInt64.read(buf),
            last_redeem_error=_UniffiConverterOptionalString.read(buf),
            channel_opening_fees=_UniffiConverterOptionalTypeOpeningFeeParams.read(buf),
            confirmed_at=_UniffiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.bitcoin_address)
        _UniffiConverterInt64.check_lower(value.created_at)
        _UniffiConverterInt64.check_lower(value.lock_height)
        _UniffiConverterSequenceUInt8.check_lower(value.payment_hash)
        _UniffiConverterSequenceUInt8.check_lower(value.preimage)
        _UniffiConverterSequenceUInt8.check_lower(value.private_key)
        _UniffiConverterSequenceUInt8.check_lower(value.public_key)
        _UniffiConverterSequenceUInt8.check_lower(value.swapper_public_key)
        _UniffiConverterSequenceUInt8.check_lower(value.script)
        _UniffiConverterOptionalString.check_lower(value.bolt11)
        _UniffiConverterUInt64.check_lower(value.paid_msat)
        _UniffiConverterUInt64.check_lower(value.unconfirmed_sats)
        _UniffiConverterUInt64.check_lower(value.confirmed_sats)
        _UniffiConverterUInt64.check_lower(value.total_incoming_txs)
        _UniffiConverterTypeSwapStatus.check_lower(value.status)
        _UniffiConverterSequenceString.check_lower(value.refund_tx_ids)
        _UniffiConverterSequenceString.check_lower(value.unconfirmed_tx_ids)
        _UniffiConverterSequenceString.check_lower(value.confirmed_tx_ids)
        _UniffiConverterInt64.check_lower(value.min_allowed_deposit)
        _UniffiConverterInt64.check_lower(value.max_allowed_deposit)
        _UniffiConverterInt64.check_lower(value.max_swapper_payable)
        _UniffiConverterOptionalString.check_lower(value.last_redeem_error)
        _UniffiConverterOptionalTypeOpeningFeeParams.check_lower(value.channel_opening_fees)
        _UniffiConverterOptionalUInt32.check_lower(value.confirmed_at)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.bitcoin_address, buf)
        _UniffiConverterInt64.write(value.created_at, buf)
        _UniffiConverterInt64.write(value.lock_height, buf)
        _UniffiConverterSequenceUInt8.write(value.payment_hash, buf)
        _UniffiConverterSequenceUInt8.write(value.preimage, buf)
        _UniffiConverterSequenceUInt8.write(value.private_key, buf)
        _UniffiConverterSequenceUInt8.write(value.public_key, buf)
        _UniffiConverterSequenceUInt8.write(value.swapper_public_key, buf)
        _UniffiConverterSequenceUInt8.write(value.script, buf)
        _UniffiConverterOptionalString.write(value.bolt11, buf)
        _UniffiConverterUInt64.write(value.paid_msat, buf)
        _UniffiConverterUInt64.write(value.unconfirmed_sats, buf)
        _UniffiConverterUInt64.write(value.confirmed_sats, buf)
        _UniffiConverterUInt64.write(value.total_incoming_txs, buf)
        _UniffiConverterTypeSwapStatus.write(value.status, buf)
        _UniffiConverterSequenceString.write(value.refund_tx_ids, buf)
        _UniffiConverterSequenceString.write(value.unconfirmed_tx_ids, buf)
        _UniffiConverterSequenceString.write(value.confirmed_tx_ids, buf)
        _UniffiConverterInt64.write(value.min_allowed_deposit, buf)
        _UniffiConverterInt64.write(value.max_allowed_deposit, buf)
        _UniffiConverterInt64.write(value.max_swapper_payable, buf)
        _UniffiConverterOptionalString.write(value.last_redeem_error, buf)
        _UniffiConverterOptionalTypeOpeningFeeParams.write(value.channel_opening_fees, buf)
        _UniffiConverterOptionalUInt32.write(value.confirmed_at, buf)


class Symbol:
    grapheme: "typing.Optional[str]"
    template: "typing.Optional[str]"
    rtl: "typing.Optional[bool]"
    position: "typing.Optional[int]"
    def __init__(self, *, grapheme: "typing.Optional[str]", template: "typing.Optional[str]", rtl: "typing.Optional[bool]", position: "typing.Optional[int]"):
        self.grapheme = grapheme
        self.template = template
        self.rtl = rtl
        self.position = position

    def __str__(self):
        return "Symbol(grapheme={}, template={}, rtl={}, position={})".format(self.grapheme, self.template, self.rtl, self.position)

    def __eq__(self, other):
        if self.grapheme != other.grapheme:
            return False
        if self.template != other.template:
            return False
        if self.rtl != other.rtl:
            return False
        if self.position != other.position:
            return False
        return True

class _UniffiConverterTypeSymbol(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Symbol(
            grapheme=_UniffiConverterOptionalString.read(buf),
            template=_UniffiConverterOptionalString.read(buf),
            rtl=_UniffiConverterOptionalBool.read(buf),
            position=_UniffiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.grapheme)
        _UniffiConverterOptionalString.check_lower(value.template)
        _UniffiConverterOptionalBool.check_lower(value.rtl)
        _UniffiConverterOptionalUInt32.check_lower(value.position)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.grapheme, buf)
        _UniffiConverterOptionalString.write(value.template, buf)
        _UniffiConverterOptionalBool.write(value.rtl, buf)
        _UniffiConverterOptionalUInt32.write(value.position, buf)


class TlvEntry:
    field_number: "int"
    value: "typing.List[int]"
    def __init__(self, *, field_number: "int", value: "typing.List[int]"):
        self.field_number = field_number
        self.value = value

    def __str__(self):
        return "TlvEntry(field_number={}, value={})".format(self.field_number, self.value)

    def __eq__(self, other):
        if self.field_number != other.field_number:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeTlvEntry(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TlvEntry(
            field_number=_UniffiConverterUInt64.read(buf),
            value=_UniffiConverterSequenceUInt8.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.field_number)
        _UniffiConverterSequenceUInt8.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.field_number, buf)
        _UniffiConverterSequenceUInt8.write(value.value, buf)


class UnspentTransactionOutput:
    txid: "typing.List[int]"
    outnum: "int"
    amount_millisatoshi: "int"
    address: "str"
    reserved: "bool"
    def __init__(self, *, txid: "typing.List[int]", outnum: "int", amount_millisatoshi: "int", address: "str", reserved: "bool"):
        self.txid = txid
        self.outnum = outnum
        self.amount_millisatoshi = amount_millisatoshi
        self.address = address
        self.reserved = reserved

    def __str__(self):
        return "UnspentTransactionOutput(txid={}, outnum={}, amount_millisatoshi={}, address={}, reserved={})".format(self.txid, self.outnum, self.amount_millisatoshi, self.address, self.reserved)

    def __eq__(self, other):
        if self.txid != other.txid:
            return False
        if self.outnum != other.outnum:
            return False
        if self.amount_millisatoshi != other.amount_millisatoshi:
            return False
        if self.address != other.address:
            return False
        if self.reserved != other.reserved:
            return False
        return True

class _UniffiConverterTypeUnspentTransactionOutput(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UnspentTransactionOutput(
            txid=_UniffiConverterSequenceUInt8.read(buf),
            outnum=_UniffiConverterUInt32.read(buf),
            amount_millisatoshi=_UniffiConverterUInt64.read(buf),
            address=_UniffiConverterString.read(buf),
            reserved=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceUInt8.check_lower(value.txid)
        _UniffiConverterUInt32.check_lower(value.outnum)
        _UniffiConverterUInt64.check_lower(value.amount_millisatoshi)
        _UniffiConverterString.check_lower(value.address)
        _UniffiConverterBool.check_lower(value.reserved)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceUInt8.write(value.txid, buf)
        _UniffiConverterUInt32.write(value.outnum, buf)
        _UniffiConverterUInt64.write(value.amount_millisatoshi, buf)
        _UniffiConverterString.write(value.address, buf)
        _UniffiConverterBool.write(value.reserved, buf)


class UrlSuccessActionData:
    description: "str"
    url: "str"
    matches_callback_domain: "bool"
    def __init__(self, *, description: "str", url: "str", matches_callback_domain: "bool"):
        self.description = description
        self.url = url
        self.matches_callback_domain = matches_callback_domain

    def __str__(self):
        return "UrlSuccessActionData(description={}, url={}, matches_callback_domain={})".format(self.description, self.url, self.matches_callback_domain)

    def __eq__(self, other):
        if self.description != other.description:
            return False
        if self.url != other.url:
            return False
        if self.matches_callback_domain != other.matches_callback_domain:
            return False
        return True

class _UniffiConverterTypeUrlSuccessActionData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UrlSuccessActionData(
            description=_UniffiConverterString.read(buf),
            url=_UniffiConverterString.read(buf),
            matches_callback_domain=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.description)
        _UniffiConverterString.check_lower(value.url)
        _UniffiConverterBool.check_lower(value.matches_callback_domain)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.description, buf)
        _UniffiConverterString.write(value.url, buf)
        _UniffiConverterBool.write(value.matches_callback_domain, buf)





class AesSuccessActionDataResult:
    def __init__(self):
        raise RuntimeError("AesSuccessActionDataResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class DECRYPTED:
        data: "AesSuccessActionDataDecrypted"

        def __init__(self,data: "AesSuccessActionDataDecrypted"):
            self.data = data

        def __str__(self):
            return "AesSuccessActionDataResult.DECRYPTED(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_decrypted():
                return False
            if self.data != other.data:
                return False
            return True
    
    class ERROR_STATUS:
        reason: "str"

        def __init__(self,reason: "str"):
            self.reason = reason

        def __str__(self):
            return "AesSuccessActionDataResult.ERROR_STATUS(reason={})".format(self.reason)

        def __eq__(self, other):
            if not other.is_error_status():
                return False
            if self.reason != other.reason:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_decrypted(self) -> bool:
        return isinstance(self, AesSuccessActionDataResult.DECRYPTED)
    def is_error_status(self) -> bool:
        return isinstance(self, AesSuccessActionDataResult.ERROR_STATUS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
AesSuccessActionDataResult.DECRYPTED = type("AesSuccessActionDataResult.DECRYPTED", (AesSuccessActionDataResult.DECRYPTED, AesSuccessActionDataResult,), {})  # type: ignore
AesSuccessActionDataResult.ERROR_STATUS = type("AesSuccessActionDataResult.ERROR_STATUS", (AesSuccessActionDataResult.ERROR_STATUS, AesSuccessActionDataResult,), {})  # type: ignore




class _UniffiConverterTypeAesSuccessActionDataResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AesSuccessActionDataResult.DECRYPTED(
                _UniffiConverterTypeAesSuccessActionDataDecrypted.read(buf),
            )
        if variant == 2:
            return AesSuccessActionDataResult.ERROR_STATUS(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_decrypted():
            _UniffiConverterTypeAesSuccessActionDataDecrypted.check_lower(value.data)
            return
        if value.is_error_status():
            _UniffiConverterString.check_lower(value.reason)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_decrypted():
            buf.write_i32(1)
            _UniffiConverterTypeAesSuccessActionDataDecrypted.write(value.data, buf)
        if value.is_error_status():
            buf.write_i32(2)
            _UniffiConverterString.write(value.reason, buf)







class BreezEvent:
    def __init__(self):
        raise RuntimeError("BreezEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class NEW_BLOCK:
        block: "int"

        def __init__(self,block: "int"):
            self.block = block

        def __str__(self):
            return "BreezEvent.NEW_BLOCK(block={})".format(self.block)

        def __eq__(self, other):
            if not other.is_new_block():
                return False
            if self.block != other.block:
                return False
            return True
    
    class INVOICE_PAID:
        details: "InvoicePaidDetails"

        def __init__(self,details: "InvoicePaidDetails"):
            self.details = details

        def __str__(self):
            return "BreezEvent.INVOICE_PAID(details={})".format(self.details)

        def __eq__(self, other):
            if not other.is_invoice_paid():
                return False
            if self.details != other.details:
                return False
            return True
    
    class SYNCED:

        def __init__(self,):
            pass

        def __str__(self):
            return "BreezEvent.SYNCED()".format()

        def __eq__(self, other):
            if not other.is_synced():
                return False
            return True
    
    class PAYMENT_SUCCEED:
        details: "Payment"

        def __init__(self,details: "Payment"):
            self.details = details

        def __str__(self):
            return "BreezEvent.PAYMENT_SUCCEED(details={})".format(self.details)

        def __eq__(self, other):
            if not other.is_payment_succeed():
                return False
            if self.details != other.details:
                return False
            return True
    
    class PAYMENT_FAILED:
        details: "PaymentFailedData"

        def __init__(self,details: "PaymentFailedData"):
            self.details = details

        def __str__(self):
            return "BreezEvent.PAYMENT_FAILED(details={})".format(self.details)

        def __eq__(self, other):
            if not other.is_payment_failed():
                return False
            if self.details != other.details:
                return False
            return True
    
    class BACKUP_STARTED:

        def __init__(self,):
            pass

        def __str__(self):
            return "BreezEvent.BACKUP_STARTED()".format()

        def __eq__(self, other):
            if not other.is_backup_started():
                return False
            return True
    
    class BACKUP_SUCCEEDED:

        def __init__(self,):
            pass

        def __str__(self):
            return "BreezEvent.BACKUP_SUCCEEDED()".format()

        def __eq__(self, other):
            if not other.is_backup_succeeded():
                return False
            return True
    
    class BACKUP_FAILED:
        details: "BackupFailedData"

        def __init__(self,details: "BackupFailedData"):
            self.details = details

        def __str__(self):
            return "BreezEvent.BACKUP_FAILED(details={})".format(self.details)

        def __eq__(self, other):
            if not other.is_backup_failed():
                return False
            if self.details != other.details:
                return False
            return True
    
    class REVERSE_SWAP_UPDATED:
        details: "ReverseSwapInfo"

        def __init__(self,details: "ReverseSwapInfo"):
            self.details = details

        def __str__(self):
            return "BreezEvent.REVERSE_SWAP_UPDATED(details={})".format(self.details)

        def __eq__(self, other):
            if not other.is_reverse_swap_updated():
                return False
            if self.details != other.details:
                return False
            return True
    
    class SWAP_UPDATED:
        details: "SwapInfo"

        def __init__(self,details: "SwapInfo"):
            self.details = details

        def __str__(self):
            return "BreezEvent.SWAP_UPDATED(details={})".format(self.details)

        def __eq__(self, other):
            if not other.is_swap_updated():
                return False
            if self.details != other.details:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_new_block(self) -> bool:
        return isinstance(self, BreezEvent.NEW_BLOCK)
    def is_invoice_paid(self) -> bool:
        return isinstance(self, BreezEvent.INVOICE_PAID)
    def is_synced(self) -> bool:
        return isinstance(self, BreezEvent.SYNCED)
    def is_payment_succeed(self) -> bool:
        return isinstance(self, BreezEvent.PAYMENT_SUCCEED)
    def is_payment_failed(self) -> bool:
        return isinstance(self, BreezEvent.PAYMENT_FAILED)
    def is_backup_started(self) -> bool:
        return isinstance(self, BreezEvent.BACKUP_STARTED)
    def is_backup_succeeded(self) -> bool:
        return isinstance(self, BreezEvent.BACKUP_SUCCEEDED)
    def is_backup_failed(self) -> bool:
        return isinstance(self, BreezEvent.BACKUP_FAILED)
    def is_reverse_swap_updated(self) -> bool:
        return isinstance(self, BreezEvent.REVERSE_SWAP_UPDATED)
    def is_swap_updated(self) -> bool:
        return isinstance(self, BreezEvent.SWAP_UPDATED)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
BreezEvent.NEW_BLOCK = type("BreezEvent.NEW_BLOCK", (BreezEvent.NEW_BLOCK, BreezEvent,), {})  # type: ignore
BreezEvent.INVOICE_PAID = type("BreezEvent.INVOICE_PAID", (BreezEvent.INVOICE_PAID, BreezEvent,), {})  # type: ignore
BreezEvent.SYNCED = type("BreezEvent.SYNCED", (BreezEvent.SYNCED, BreezEvent,), {})  # type: ignore
BreezEvent.PAYMENT_SUCCEED = type("BreezEvent.PAYMENT_SUCCEED", (BreezEvent.PAYMENT_SUCCEED, BreezEvent,), {})  # type: ignore
BreezEvent.PAYMENT_FAILED = type("BreezEvent.PAYMENT_FAILED", (BreezEvent.PAYMENT_FAILED, BreezEvent,), {})  # type: ignore
BreezEvent.BACKUP_STARTED = type("BreezEvent.BACKUP_STARTED", (BreezEvent.BACKUP_STARTED, BreezEvent,), {})  # type: ignore
BreezEvent.BACKUP_SUCCEEDED = type("BreezEvent.BACKUP_SUCCEEDED", (BreezEvent.BACKUP_SUCCEEDED, BreezEvent,), {})  # type: ignore
BreezEvent.BACKUP_FAILED = type("BreezEvent.BACKUP_FAILED", (BreezEvent.BACKUP_FAILED, BreezEvent,), {})  # type: ignore
BreezEvent.REVERSE_SWAP_UPDATED = type("BreezEvent.REVERSE_SWAP_UPDATED", (BreezEvent.REVERSE_SWAP_UPDATED, BreezEvent,), {})  # type: ignore
BreezEvent.SWAP_UPDATED = type("BreezEvent.SWAP_UPDATED", (BreezEvent.SWAP_UPDATED, BreezEvent,), {})  # type: ignore




class _UniffiConverterTypeBreezEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return BreezEvent.NEW_BLOCK(
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 2:
            return BreezEvent.INVOICE_PAID(
                _UniffiConverterTypeInvoicePaidDetails.read(buf),
            )
        if variant == 3:
            return BreezEvent.SYNCED(
            )
        if variant == 4:
            return BreezEvent.PAYMENT_SUCCEED(
                _UniffiConverterTypePayment.read(buf),
            )
        if variant == 5:
            return BreezEvent.PAYMENT_FAILED(
                _UniffiConverterTypePaymentFailedData.read(buf),
            )
        if variant == 6:
            return BreezEvent.BACKUP_STARTED(
            )
        if variant == 7:
            return BreezEvent.BACKUP_SUCCEEDED(
            )
        if variant == 8:
            return BreezEvent.BACKUP_FAILED(
                _UniffiConverterTypeBackupFailedData.read(buf),
            )
        if variant == 9:
            return BreezEvent.REVERSE_SWAP_UPDATED(
                _UniffiConverterTypeReverseSwapInfo.read(buf),
            )
        if variant == 10:
            return BreezEvent.SWAP_UPDATED(
                _UniffiConverterTypeSwapInfo.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_new_block():
            _UniffiConverterUInt32.check_lower(value.block)
            return
        if value.is_invoice_paid():
            _UniffiConverterTypeInvoicePaidDetails.check_lower(value.details)
            return
        if value.is_synced():
            return
        if value.is_payment_succeed():
            _UniffiConverterTypePayment.check_lower(value.details)
            return
        if value.is_payment_failed():
            _UniffiConverterTypePaymentFailedData.check_lower(value.details)
            return
        if value.is_backup_started():
            return
        if value.is_backup_succeeded():
            return
        if value.is_backup_failed():
            _UniffiConverterTypeBackupFailedData.check_lower(value.details)
            return
        if value.is_reverse_swap_updated():
            _UniffiConverterTypeReverseSwapInfo.check_lower(value.details)
            return
        if value.is_swap_updated():
            _UniffiConverterTypeSwapInfo.check_lower(value.details)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_new_block():
            buf.write_i32(1)
            _UniffiConverterUInt32.write(value.block, buf)
        if value.is_invoice_paid():
            buf.write_i32(2)
            _UniffiConverterTypeInvoicePaidDetails.write(value.details, buf)
        if value.is_synced():
            buf.write_i32(3)
        if value.is_payment_succeed():
            buf.write_i32(4)
            _UniffiConverterTypePayment.write(value.details, buf)
        if value.is_payment_failed():
            buf.write_i32(5)
            _UniffiConverterTypePaymentFailedData.write(value.details, buf)
        if value.is_backup_started():
            buf.write_i32(6)
        if value.is_backup_succeeded():
            buf.write_i32(7)
        if value.is_backup_failed():
            buf.write_i32(8)
            _UniffiConverterTypeBackupFailedData.write(value.details, buf)
        if value.is_reverse_swap_updated():
            buf.write_i32(9)
            _UniffiConverterTypeReverseSwapInfo.write(value.details, buf)
        if value.is_swap_updated():
            buf.write_i32(10)
            _UniffiConverterTypeSwapInfo.write(value.details, buf)







class BuyBitcoinProvider(enum.Enum):
    MOONPAY = 0
    


class _UniffiConverterTypeBuyBitcoinProvider(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return BuyBitcoinProvider.MOONPAY
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == BuyBitcoinProvider.MOONPAY:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == BuyBitcoinProvider.MOONPAY:
            buf.write_i32(1)







class ChannelState(enum.Enum):
    PENDING_OPEN = 0
    
    OPENED = 1
    
    PENDING_CLOSE = 2
    
    CLOSED = 3
    


class _UniffiConverterTypeChannelState(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ChannelState.PENDING_OPEN
        if variant == 2:
            return ChannelState.OPENED
        if variant == 3:
            return ChannelState.PENDING_CLOSE
        if variant == 4:
            return ChannelState.CLOSED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == ChannelState.PENDING_OPEN:
            return
        if value == ChannelState.OPENED:
            return
        if value == ChannelState.PENDING_CLOSE:
            return
        if value == ChannelState.CLOSED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == ChannelState.PENDING_OPEN:
            buf.write_i32(1)
        if value == ChannelState.OPENED:
            buf.write_i32(2)
        if value == ChannelState.PENDING_CLOSE:
            buf.write_i32(3)
        if value == ChannelState.CLOSED:
            buf.write_i32(4)




# ConnectError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class ConnectError(Exception):
    pass

_UniffiTempConnectError = ConnectError

class ConnectError:  # type: ignore
    class Generic(_UniffiTempConnectError):

        def __repr__(self):
            return "ConnectError.Generic({})".format(repr(str(self)))
    _UniffiTempConnectError.Generic = Generic # type: ignore
    class RestoreOnly(_UniffiTempConnectError):

        def __repr__(self):
            return "ConnectError.RestoreOnly({})".format(repr(str(self)))
    _UniffiTempConnectError.RestoreOnly = RestoreOnly # type: ignore
    class ServiceConnectivity(_UniffiTempConnectError):

        def __repr__(self):
            return "ConnectError.ServiceConnectivity({})".format(repr(str(self)))
    _UniffiTempConnectError.ServiceConnectivity = ServiceConnectivity # type: ignore

ConnectError = _UniffiTempConnectError # type: ignore
del _UniffiTempConnectError


class _UniffiConverterTypeConnectError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ConnectError.Generic(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return ConnectError.RestoreOnly(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return ConnectError.ServiceConnectivity(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, ConnectError.Generic):
            return
        if isinstance(value, ConnectError.RestoreOnly):
            return
        if isinstance(value, ConnectError.ServiceConnectivity):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, ConnectError.Generic):
            buf.write_i32(1)
        if isinstance(value, ConnectError.RestoreOnly):
            buf.write_i32(2)
        if isinstance(value, ConnectError.ServiceConnectivity):
            buf.write_i32(3)





class EnvironmentType(enum.Enum):
    PRODUCTION = 0
    
    STAGING = 1
    
    REGTEST = 2
    


class _UniffiConverterTypeEnvironmentType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return EnvironmentType.PRODUCTION
        if variant == 2:
            return EnvironmentType.STAGING
        if variant == 3:
            return EnvironmentType.REGTEST
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == EnvironmentType.PRODUCTION:
            return
        if value == EnvironmentType.STAGING:
            return
        if value == EnvironmentType.REGTEST:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == EnvironmentType.PRODUCTION:
            buf.write_i32(1)
        if value == EnvironmentType.STAGING:
            buf.write_i32(2)
        if value == EnvironmentType.REGTEST:
            buf.write_i32(3)







class FeeratePreset(enum.Enum):
    REGULAR = 0
    
    ECONOMY = 1
    
    PRIORITY = 2
    


class _UniffiConverterTypeFeeratePreset(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FeeratePreset.REGULAR
        if variant == 2:
            return FeeratePreset.ECONOMY
        if variant == 3:
            return FeeratePreset.PRIORITY
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FeeratePreset.REGULAR:
            return
        if value == FeeratePreset.ECONOMY:
            return
        if value == FeeratePreset.PRIORITY:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FeeratePreset.REGULAR:
            buf.write_i32(1)
        if value == FeeratePreset.ECONOMY:
            buf.write_i32(2)
        if value == FeeratePreset.PRIORITY:
            buf.write_i32(3)







class HealthCheckStatus(enum.Enum):
    OPERATIONAL = 0
    
    MAINTENANCE = 1
    
    SERVICE_DISRUPTION = 2
    


class _UniffiConverterTypeHealthCheckStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return HealthCheckStatus.OPERATIONAL
        if variant == 2:
            return HealthCheckStatus.MAINTENANCE
        if variant == 3:
            return HealthCheckStatus.SERVICE_DISRUPTION
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == HealthCheckStatus.OPERATIONAL:
            return
        if value == HealthCheckStatus.MAINTENANCE:
            return
        if value == HealthCheckStatus.SERVICE_DISRUPTION:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == HealthCheckStatus.OPERATIONAL:
            buf.write_i32(1)
        if value == HealthCheckStatus.MAINTENANCE:
            buf.write_i32(2)
        if value == HealthCheckStatus.SERVICE_DISRUPTION:
            buf.write_i32(3)







class InputType:
    def __init__(self):
        raise RuntimeError("InputType cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BITCOIN_ADDRESS:
        address: "BitcoinAddressData"

        def __init__(self,address: "BitcoinAddressData"):
            self.address = address

        def __str__(self):
            return "InputType.BITCOIN_ADDRESS(address={})".format(self.address)

        def __eq__(self, other):
            if not other.is_bitcoin_address():
                return False
            if self.address != other.address:
                return False
            return True
    
    class BOLT11:
        invoice: "LnInvoice"

        def __init__(self,invoice: "LnInvoice"):
            self.invoice = invoice

        def __str__(self):
            return "InputType.BOLT11(invoice={})".format(self.invoice)

        def __eq__(self, other):
            if not other.is_bolt11():
                return False
            if self.invoice != other.invoice:
                return False
            return True
    
    class NODE_ID:
        node_id: "str"

        def __init__(self,node_id: "str"):
            self.node_id = node_id

        def __str__(self):
            return "InputType.NODE_ID(node_id={})".format(self.node_id)

        def __eq__(self, other):
            if not other.is_node_id():
                return False
            if self.node_id != other.node_id:
                return False
            return True
    
    class URL:
        url: "str"

        def __init__(self,url: "str"):
            self.url = url

        def __str__(self):
            return "InputType.URL(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_url():
                return False
            if self.url != other.url:
                return False
            return True
    
    class LN_URL_PAY:
        data: "LnUrlPayRequestData"
        bip353_address: "typing.Optional[str]"

        def __init__(self,data: "LnUrlPayRequestData", bip353_address: "typing.Optional[str]"):
            self.data = data
            self.bip353_address = bip353_address

        def __str__(self):
            return "InputType.LN_URL_PAY(data={}, bip353_address={})".format(self.data, self.bip353_address)

        def __eq__(self, other):
            if not other.is_ln_url_pay():
                return False
            if self.data != other.data:
                return False
            if self.bip353_address != other.bip353_address:
                return False
            return True
    
    class LN_URL_WITHDRAW:
        data: "LnUrlWithdrawRequestData"

        def __init__(self,data: "LnUrlWithdrawRequestData"):
            self.data = data

        def __str__(self):
            return "InputType.LN_URL_WITHDRAW(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_ln_url_withdraw():
                return False
            if self.data != other.data:
                return False
            return True
    
    class LN_URL_AUTH:
        data: "LnUrlAuthRequestData"

        def __init__(self,data: "LnUrlAuthRequestData"):
            self.data = data

        def __str__(self):
            return "InputType.LN_URL_AUTH(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_ln_url_auth():
                return False
            if self.data != other.data:
                return False
            return True
    
    class LN_URL_ERROR:
        data: "LnUrlErrorData"

        def __init__(self,data: "LnUrlErrorData"):
            self.data = data

        def __str__(self):
            return "InputType.LN_URL_ERROR(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_ln_url_error():
                return False
            if self.data != other.data:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_bitcoin_address(self) -> bool:
        return isinstance(self, InputType.BITCOIN_ADDRESS)
    def is_bolt11(self) -> bool:
        return isinstance(self, InputType.BOLT11)
    def is_node_id(self) -> bool:
        return isinstance(self, InputType.NODE_ID)
    def is_url(self) -> bool:
        return isinstance(self, InputType.URL)
    def is_ln_url_pay(self) -> bool:
        return isinstance(self, InputType.LN_URL_PAY)
    def is_ln_url_withdraw(self) -> bool:
        return isinstance(self, InputType.LN_URL_WITHDRAW)
    def is_ln_url_auth(self) -> bool:
        return isinstance(self, InputType.LN_URL_AUTH)
    def is_ln_url_error(self) -> bool:
        return isinstance(self, InputType.LN_URL_ERROR)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
InputType.BITCOIN_ADDRESS = type("InputType.BITCOIN_ADDRESS", (InputType.BITCOIN_ADDRESS, InputType,), {})  # type: ignore
InputType.BOLT11 = type("InputType.BOLT11", (InputType.BOLT11, InputType,), {})  # type: ignore
InputType.NODE_ID = type("InputType.NODE_ID", (InputType.NODE_ID, InputType,), {})  # type: ignore
InputType.URL = type("InputType.URL", (InputType.URL, InputType,), {})  # type: ignore
InputType.LN_URL_PAY = type("InputType.LN_URL_PAY", (InputType.LN_URL_PAY, InputType,), {})  # type: ignore
InputType.LN_URL_WITHDRAW = type("InputType.LN_URL_WITHDRAW", (InputType.LN_URL_WITHDRAW, InputType,), {})  # type: ignore
InputType.LN_URL_AUTH = type("InputType.LN_URL_AUTH", (InputType.LN_URL_AUTH, InputType,), {})  # type: ignore
InputType.LN_URL_ERROR = type("InputType.LN_URL_ERROR", (InputType.LN_URL_ERROR, InputType,), {})  # type: ignore




class _UniffiConverterTypeInputType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return InputType.BITCOIN_ADDRESS(
                _UniffiConverterTypeBitcoinAddressData.read(buf),
            )
        if variant == 2:
            return InputType.BOLT11(
                _UniffiConverterTypeLnInvoice.read(buf),
            )
        if variant == 3:
            return InputType.NODE_ID(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return InputType.URL(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return InputType.LN_URL_PAY(
                _UniffiConverterTypeLnUrlPayRequestData.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 6:
            return InputType.LN_URL_WITHDRAW(
                _UniffiConverterTypeLnUrlWithdrawRequestData.read(buf),
            )
        if variant == 7:
            return InputType.LN_URL_AUTH(
                _UniffiConverterTypeLnUrlAuthRequestData.read(buf),
            )
        if variant == 8:
            return InputType.LN_URL_ERROR(
                _UniffiConverterTypeLnUrlErrorData.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_bitcoin_address():
            _UniffiConverterTypeBitcoinAddressData.check_lower(value.address)
            return
        if value.is_bolt11():
            _UniffiConverterTypeLnInvoice.check_lower(value.invoice)
            return
        if value.is_node_id():
            _UniffiConverterString.check_lower(value.node_id)
            return
        if value.is_url():
            _UniffiConverterString.check_lower(value.url)
            return
        if value.is_ln_url_pay():
            _UniffiConverterTypeLnUrlPayRequestData.check_lower(value.data)
            _UniffiConverterOptionalString.check_lower(value.bip353_address)
            return
        if value.is_ln_url_withdraw():
            _UniffiConverterTypeLnUrlWithdrawRequestData.check_lower(value.data)
            return
        if value.is_ln_url_auth():
            _UniffiConverterTypeLnUrlAuthRequestData.check_lower(value.data)
            return
        if value.is_ln_url_error():
            _UniffiConverterTypeLnUrlErrorData.check_lower(value.data)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_bitcoin_address():
            buf.write_i32(1)
            _UniffiConverterTypeBitcoinAddressData.write(value.address, buf)
        if value.is_bolt11():
            buf.write_i32(2)
            _UniffiConverterTypeLnInvoice.write(value.invoice, buf)
        if value.is_node_id():
            buf.write_i32(3)
            _UniffiConverterString.write(value.node_id, buf)
        if value.is_url():
            buf.write_i32(4)
            _UniffiConverterString.write(value.url, buf)
        if value.is_ln_url_pay():
            buf.write_i32(5)
            _UniffiConverterTypeLnUrlPayRequestData.write(value.data, buf)
            _UniffiConverterOptionalString.write(value.bip353_address, buf)
        if value.is_ln_url_withdraw():
            buf.write_i32(6)
            _UniffiConverterTypeLnUrlWithdrawRequestData.write(value.data, buf)
        if value.is_ln_url_auth():
            buf.write_i32(7)
            _UniffiConverterTypeLnUrlAuthRequestData.write(value.data, buf)
        if value.is_ln_url_error():
            buf.write_i32(8)
            _UniffiConverterTypeLnUrlErrorData.write(value.data, buf)







class LevelFilter(enum.Enum):
    OFF = 0
    
    ERROR = 1
    
    WARN = 2
    
    INFO = 3
    
    DEBUG = 4
    
    TRACE = 5
    


class _UniffiConverterTypeLevelFilter(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LevelFilter.OFF
        if variant == 2:
            return LevelFilter.ERROR
        if variant == 3:
            return LevelFilter.WARN
        if variant == 4:
            return LevelFilter.INFO
        if variant == 5:
            return LevelFilter.DEBUG
        if variant == 6:
            return LevelFilter.TRACE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == LevelFilter.OFF:
            return
        if value == LevelFilter.ERROR:
            return
        if value == LevelFilter.WARN:
            return
        if value == LevelFilter.INFO:
            return
        if value == LevelFilter.DEBUG:
            return
        if value == LevelFilter.TRACE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == LevelFilter.OFF:
            buf.write_i32(1)
        if value == LevelFilter.ERROR:
            buf.write_i32(2)
        if value == LevelFilter.WARN:
            buf.write_i32(3)
        if value == LevelFilter.INFO:
            buf.write_i32(4)
        if value == LevelFilter.DEBUG:
            buf.write_i32(5)
        if value == LevelFilter.TRACE:
            buf.write_i32(6)




# LnUrlAuthError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class LnUrlAuthError(Exception):
    pass

_UniffiTempLnUrlAuthError = LnUrlAuthError

class LnUrlAuthError:  # type: ignore
    class Generic(_UniffiTempLnUrlAuthError):

        def __repr__(self):
            return "LnUrlAuthError.Generic({})".format(repr(str(self)))
    _UniffiTempLnUrlAuthError.Generic = Generic # type: ignore
    class InvalidUri(_UniffiTempLnUrlAuthError):

        def __repr__(self):
            return "LnUrlAuthError.InvalidUri({})".format(repr(str(self)))
    _UniffiTempLnUrlAuthError.InvalidUri = InvalidUri # type: ignore
    class ServiceConnectivity(_UniffiTempLnUrlAuthError):

        def __repr__(self):
            return "LnUrlAuthError.ServiceConnectivity({})".format(repr(str(self)))
    _UniffiTempLnUrlAuthError.ServiceConnectivity = ServiceConnectivity # type: ignore

LnUrlAuthError = _UniffiTempLnUrlAuthError # type: ignore
del _UniffiTempLnUrlAuthError


class _UniffiConverterTypeLnUrlAuthError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LnUrlAuthError.Generic(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return LnUrlAuthError.InvalidUri(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return LnUrlAuthError.ServiceConnectivity(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, LnUrlAuthError.Generic):
            return
        if isinstance(value, LnUrlAuthError.InvalidUri):
            return
        if isinstance(value, LnUrlAuthError.ServiceConnectivity):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, LnUrlAuthError.Generic):
            buf.write_i32(1)
        if isinstance(value, LnUrlAuthError.InvalidUri):
            buf.write_i32(2)
        if isinstance(value, LnUrlAuthError.ServiceConnectivity):
            buf.write_i32(3)





class LnUrlCallbackStatus:
    def __init__(self):
        raise RuntimeError("LnUrlCallbackStatus cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class OK:

        def __init__(self,):
            pass

        def __str__(self):
            return "LnUrlCallbackStatus.OK()".format()

        def __eq__(self, other):
            if not other.is_ok():
                return False
            return True
    
    class ERROR_STATUS:
        data: "LnUrlErrorData"

        def __init__(self,data: "LnUrlErrorData"):
            self.data = data

        def __str__(self):
            return "LnUrlCallbackStatus.ERROR_STATUS(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_error_status():
                return False
            if self.data != other.data:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_ok(self) -> bool:
        return isinstance(self, LnUrlCallbackStatus.OK)
    def is_error_status(self) -> bool:
        return isinstance(self, LnUrlCallbackStatus.ERROR_STATUS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
LnUrlCallbackStatus.OK = type("LnUrlCallbackStatus.OK", (LnUrlCallbackStatus.OK, LnUrlCallbackStatus,), {})  # type: ignore
LnUrlCallbackStatus.ERROR_STATUS = type("LnUrlCallbackStatus.ERROR_STATUS", (LnUrlCallbackStatus.ERROR_STATUS, LnUrlCallbackStatus,), {})  # type: ignore




class _UniffiConverterTypeLnUrlCallbackStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LnUrlCallbackStatus.OK(
            )
        if variant == 2:
            return LnUrlCallbackStatus.ERROR_STATUS(
                _UniffiConverterTypeLnUrlErrorData.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_ok():
            return
        if value.is_error_status():
            _UniffiConverterTypeLnUrlErrorData.check_lower(value.data)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_ok():
            buf.write_i32(1)
        if value.is_error_status():
            buf.write_i32(2)
            _UniffiConverterTypeLnUrlErrorData.write(value.data, buf)




# LnUrlPayError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class LnUrlPayError(Exception):
    pass

_UniffiTempLnUrlPayError = LnUrlPayError

class LnUrlPayError:  # type: ignore
    class AlreadyPaid(_UniffiTempLnUrlPayError):

        def __repr__(self):
            return "LnUrlPayError.AlreadyPaid({})".format(repr(str(self)))
    _UniffiTempLnUrlPayError.AlreadyPaid = AlreadyPaid # type: ignore
    class Generic(_UniffiTempLnUrlPayError):

        def __repr__(self):
            return "LnUrlPayError.Generic({})".format(repr(str(self)))
    _UniffiTempLnUrlPayError.Generic = Generic # type: ignore
    class InvalidAmount(_UniffiTempLnUrlPayError):

        def __repr__(self):
            return "LnUrlPayError.InvalidAmount({})".format(repr(str(self)))
    _UniffiTempLnUrlPayError.InvalidAmount = InvalidAmount # type: ignore
    class InvalidInvoice(_UniffiTempLnUrlPayError):

        def __repr__(self):
            return "LnUrlPayError.InvalidInvoice({})".format(repr(str(self)))
    _UniffiTempLnUrlPayError.InvalidInvoice = InvalidInvoice # type: ignore
    class InvalidNetwork(_UniffiTempLnUrlPayError):

        def __repr__(self):
            return "LnUrlPayError.InvalidNetwork({})".format(repr(str(self)))
    _UniffiTempLnUrlPayError.InvalidNetwork = InvalidNetwork # type: ignore
    class InvalidUri(_UniffiTempLnUrlPayError):

        def __repr__(self):
            return "LnUrlPayError.InvalidUri({})".format(repr(str(self)))
    _UniffiTempLnUrlPayError.InvalidUri = InvalidUri # type: ignore
    class InvoiceExpired(_UniffiTempLnUrlPayError):

        def __repr__(self):
            return "LnUrlPayError.InvoiceExpired({})".format(repr(str(self)))
    _UniffiTempLnUrlPayError.InvoiceExpired = InvoiceExpired # type: ignore
    class PaymentFailed(_UniffiTempLnUrlPayError):

        def __repr__(self):
            return "LnUrlPayError.PaymentFailed({})".format(repr(str(self)))
    _UniffiTempLnUrlPayError.PaymentFailed = PaymentFailed # type: ignore
    class PaymentTimeout(_UniffiTempLnUrlPayError):

        def __repr__(self):
            return "LnUrlPayError.PaymentTimeout({})".format(repr(str(self)))
    _UniffiTempLnUrlPayError.PaymentTimeout = PaymentTimeout # type: ignore
    class RouteNotFound(_UniffiTempLnUrlPayError):

        def __repr__(self):
            return "LnUrlPayError.RouteNotFound({})".format(repr(str(self)))
    _UniffiTempLnUrlPayError.RouteNotFound = RouteNotFound # type: ignore
    class RouteTooExpensive(_UniffiTempLnUrlPayError):

        def __repr__(self):
            return "LnUrlPayError.RouteTooExpensive({})".format(repr(str(self)))
    _UniffiTempLnUrlPayError.RouteTooExpensive = RouteTooExpensive # type: ignore
    class ServiceConnectivity(_UniffiTempLnUrlPayError):

        def __repr__(self):
            return "LnUrlPayError.ServiceConnectivity({})".format(repr(str(self)))
    _UniffiTempLnUrlPayError.ServiceConnectivity = ServiceConnectivity # type: ignore
    class InsufficientBalance(_UniffiTempLnUrlPayError):

        def __repr__(self):
            return "LnUrlPayError.InsufficientBalance({})".format(repr(str(self)))
    _UniffiTempLnUrlPayError.InsufficientBalance = InsufficientBalance # type: ignore

LnUrlPayError = _UniffiTempLnUrlPayError # type: ignore
del _UniffiTempLnUrlPayError


class _UniffiConverterTypeLnUrlPayError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LnUrlPayError.AlreadyPaid(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return LnUrlPayError.Generic(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return LnUrlPayError.InvalidAmount(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return LnUrlPayError.InvalidInvoice(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return LnUrlPayError.InvalidNetwork(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return LnUrlPayError.InvalidUri(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return LnUrlPayError.InvoiceExpired(
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return LnUrlPayError.PaymentFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 9:
            return LnUrlPayError.PaymentTimeout(
                _UniffiConverterString.read(buf),
            )
        if variant == 10:
            return LnUrlPayError.RouteNotFound(
                _UniffiConverterString.read(buf),
            )
        if variant == 11:
            return LnUrlPayError.RouteTooExpensive(
                _UniffiConverterString.read(buf),
            )
        if variant == 12:
            return LnUrlPayError.ServiceConnectivity(
                _UniffiConverterString.read(buf),
            )
        if variant == 13:
            return LnUrlPayError.InsufficientBalance(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, LnUrlPayError.AlreadyPaid):
            return
        if isinstance(value, LnUrlPayError.Generic):
            return
        if isinstance(value, LnUrlPayError.InvalidAmount):
            return
        if isinstance(value, LnUrlPayError.InvalidInvoice):
            return
        if isinstance(value, LnUrlPayError.InvalidNetwork):
            return
        if isinstance(value, LnUrlPayError.InvalidUri):
            return
        if isinstance(value, LnUrlPayError.InvoiceExpired):
            return
        if isinstance(value, LnUrlPayError.PaymentFailed):
            return
        if isinstance(value, LnUrlPayError.PaymentTimeout):
            return
        if isinstance(value, LnUrlPayError.RouteNotFound):
            return
        if isinstance(value, LnUrlPayError.RouteTooExpensive):
            return
        if isinstance(value, LnUrlPayError.ServiceConnectivity):
            return
        if isinstance(value, LnUrlPayError.InsufficientBalance):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, LnUrlPayError.AlreadyPaid):
            buf.write_i32(1)
        if isinstance(value, LnUrlPayError.Generic):
            buf.write_i32(2)
        if isinstance(value, LnUrlPayError.InvalidAmount):
            buf.write_i32(3)
        if isinstance(value, LnUrlPayError.InvalidInvoice):
            buf.write_i32(4)
        if isinstance(value, LnUrlPayError.InvalidNetwork):
            buf.write_i32(5)
        if isinstance(value, LnUrlPayError.InvalidUri):
            buf.write_i32(6)
        if isinstance(value, LnUrlPayError.InvoiceExpired):
            buf.write_i32(7)
        if isinstance(value, LnUrlPayError.PaymentFailed):
            buf.write_i32(8)
        if isinstance(value, LnUrlPayError.PaymentTimeout):
            buf.write_i32(9)
        if isinstance(value, LnUrlPayError.RouteNotFound):
            buf.write_i32(10)
        if isinstance(value, LnUrlPayError.RouteTooExpensive):
            buf.write_i32(11)
        if isinstance(value, LnUrlPayError.ServiceConnectivity):
            buf.write_i32(12)
        if isinstance(value, LnUrlPayError.InsufficientBalance):
            buf.write_i32(13)





class LnUrlPayResult:
    def __init__(self):
        raise RuntimeError("LnUrlPayResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ENDPOINT_SUCCESS:
        data: "LnUrlPaySuccessData"

        def __init__(self,data: "LnUrlPaySuccessData"):
            self.data = data

        def __str__(self):
            return "LnUrlPayResult.ENDPOINT_SUCCESS(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_endpoint_success():
                return False
            if self.data != other.data:
                return False
            return True
    
    class ENDPOINT_ERROR:
        data: "LnUrlErrorData"

        def __init__(self,data: "LnUrlErrorData"):
            self.data = data

        def __str__(self):
            return "LnUrlPayResult.ENDPOINT_ERROR(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_endpoint_error():
                return False
            if self.data != other.data:
                return False
            return True
    
    class PAY_ERROR:
        data: "LnUrlPayErrorData"

        def __init__(self,data: "LnUrlPayErrorData"):
            self.data = data

        def __str__(self):
            return "LnUrlPayResult.PAY_ERROR(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_pay_error():
                return False
            if self.data != other.data:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_endpoint_success(self) -> bool:
        return isinstance(self, LnUrlPayResult.ENDPOINT_SUCCESS)
    def is_endpoint_error(self) -> bool:
        return isinstance(self, LnUrlPayResult.ENDPOINT_ERROR)
    def is_pay_error(self) -> bool:
        return isinstance(self, LnUrlPayResult.PAY_ERROR)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
LnUrlPayResult.ENDPOINT_SUCCESS = type("LnUrlPayResult.ENDPOINT_SUCCESS", (LnUrlPayResult.ENDPOINT_SUCCESS, LnUrlPayResult,), {})  # type: ignore
LnUrlPayResult.ENDPOINT_ERROR = type("LnUrlPayResult.ENDPOINT_ERROR", (LnUrlPayResult.ENDPOINT_ERROR, LnUrlPayResult,), {})  # type: ignore
LnUrlPayResult.PAY_ERROR = type("LnUrlPayResult.PAY_ERROR", (LnUrlPayResult.PAY_ERROR, LnUrlPayResult,), {})  # type: ignore




class _UniffiConverterTypeLnUrlPayResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LnUrlPayResult.ENDPOINT_SUCCESS(
                _UniffiConverterTypeLnUrlPaySuccessData.read(buf),
            )
        if variant == 2:
            return LnUrlPayResult.ENDPOINT_ERROR(
                _UniffiConverterTypeLnUrlErrorData.read(buf),
            )
        if variant == 3:
            return LnUrlPayResult.PAY_ERROR(
                _UniffiConverterTypeLnUrlPayErrorData.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_endpoint_success():
            _UniffiConverterTypeLnUrlPaySuccessData.check_lower(value.data)
            return
        if value.is_endpoint_error():
            _UniffiConverterTypeLnUrlErrorData.check_lower(value.data)
            return
        if value.is_pay_error():
            _UniffiConverterTypeLnUrlPayErrorData.check_lower(value.data)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_endpoint_success():
            buf.write_i32(1)
            _UniffiConverterTypeLnUrlPaySuccessData.write(value.data, buf)
        if value.is_endpoint_error():
            buf.write_i32(2)
            _UniffiConverterTypeLnUrlErrorData.write(value.data, buf)
        if value.is_pay_error():
            buf.write_i32(3)
            _UniffiConverterTypeLnUrlPayErrorData.write(value.data, buf)




# LnUrlWithdrawError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class LnUrlWithdrawError(Exception):
    pass

_UniffiTempLnUrlWithdrawError = LnUrlWithdrawError

class LnUrlWithdrawError:  # type: ignore
    class Generic(_UniffiTempLnUrlWithdrawError):

        def __repr__(self):
            return "LnUrlWithdrawError.Generic({})".format(repr(str(self)))
    _UniffiTempLnUrlWithdrawError.Generic = Generic # type: ignore
    class InvalidAmount(_UniffiTempLnUrlWithdrawError):

        def __repr__(self):
            return "LnUrlWithdrawError.InvalidAmount({})".format(repr(str(self)))
    _UniffiTempLnUrlWithdrawError.InvalidAmount = InvalidAmount # type: ignore
    class InvalidInvoice(_UniffiTempLnUrlWithdrawError):

        def __repr__(self):
            return "LnUrlWithdrawError.InvalidInvoice({})".format(repr(str(self)))
    _UniffiTempLnUrlWithdrawError.InvalidInvoice = InvalidInvoice # type: ignore
    class InvalidUri(_UniffiTempLnUrlWithdrawError):

        def __repr__(self):
            return "LnUrlWithdrawError.InvalidUri({})".format(repr(str(self)))
    _UniffiTempLnUrlWithdrawError.InvalidUri = InvalidUri # type: ignore
    class ServiceConnectivity(_UniffiTempLnUrlWithdrawError):

        def __repr__(self):
            return "LnUrlWithdrawError.ServiceConnectivity({})".format(repr(str(self)))
    _UniffiTempLnUrlWithdrawError.ServiceConnectivity = ServiceConnectivity # type: ignore
    class InvoiceNoRoutingHints(_UniffiTempLnUrlWithdrawError):

        def __repr__(self):
            return "LnUrlWithdrawError.InvoiceNoRoutingHints({})".format(repr(str(self)))
    _UniffiTempLnUrlWithdrawError.InvoiceNoRoutingHints = InvoiceNoRoutingHints # type: ignore

LnUrlWithdrawError = _UniffiTempLnUrlWithdrawError # type: ignore
del _UniffiTempLnUrlWithdrawError


class _UniffiConverterTypeLnUrlWithdrawError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LnUrlWithdrawError.Generic(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return LnUrlWithdrawError.InvalidAmount(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return LnUrlWithdrawError.InvalidInvoice(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return LnUrlWithdrawError.InvalidUri(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return LnUrlWithdrawError.ServiceConnectivity(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return LnUrlWithdrawError.InvoiceNoRoutingHints(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, LnUrlWithdrawError.Generic):
            return
        if isinstance(value, LnUrlWithdrawError.InvalidAmount):
            return
        if isinstance(value, LnUrlWithdrawError.InvalidInvoice):
            return
        if isinstance(value, LnUrlWithdrawError.InvalidUri):
            return
        if isinstance(value, LnUrlWithdrawError.ServiceConnectivity):
            return
        if isinstance(value, LnUrlWithdrawError.InvoiceNoRoutingHints):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, LnUrlWithdrawError.Generic):
            buf.write_i32(1)
        if isinstance(value, LnUrlWithdrawError.InvalidAmount):
            buf.write_i32(2)
        if isinstance(value, LnUrlWithdrawError.InvalidInvoice):
            buf.write_i32(3)
        if isinstance(value, LnUrlWithdrawError.InvalidUri):
            buf.write_i32(4)
        if isinstance(value, LnUrlWithdrawError.ServiceConnectivity):
            buf.write_i32(5)
        if isinstance(value, LnUrlWithdrawError.InvoiceNoRoutingHints):
            buf.write_i32(6)





class LnUrlWithdrawResult:
    def __init__(self):
        raise RuntimeError("LnUrlWithdrawResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class OK:
        data: "LnUrlWithdrawSuccessData"

        def __init__(self,data: "LnUrlWithdrawSuccessData"):
            self.data = data

        def __str__(self):
            return "LnUrlWithdrawResult.OK(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_ok():
                return False
            if self.data != other.data:
                return False
            return True
    
    class TIMEOUT:
        data: "LnUrlWithdrawSuccessData"

        def __init__(self,data: "LnUrlWithdrawSuccessData"):
            self.data = data

        def __str__(self):
            return "LnUrlWithdrawResult.TIMEOUT(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_timeout():
                return False
            if self.data != other.data:
                return False
            return True
    
    class ERROR_STATUS:
        data: "LnUrlErrorData"

        def __init__(self,data: "LnUrlErrorData"):
            self.data = data

        def __str__(self):
            return "LnUrlWithdrawResult.ERROR_STATUS(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_error_status():
                return False
            if self.data != other.data:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_ok(self) -> bool:
        return isinstance(self, LnUrlWithdrawResult.OK)
    def is_timeout(self) -> bool:
        return isinstance(self, LnUrlWithdrawResult.TIMEOUT)
    def is_error_status(self) -> bool:
        return isinstance(self, LnUrlWithdrawResult.ERROR_STATUS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
LnUrlWithdrawResult.OK = type("LnUrlWithdrawResult.OK", (LnUrlWithdrawResult.OK, LnUrlWithdrawResult,), {})  # type: ignore
LnUrlWithdrawResult.TIMEOUT = type("LnUrlWithdrawResult.TIMEOUT", (LnUrlWithdrawResult.TIMEOUT, LnUrlWithdrawResult,), {})  # type: ignore
LnUrlWithdrawResult.ERROR_STATUS = type("LnUrlWithdrawResult.ERROR_STATUS", (LnUrlWithdrawResult.ERROR_STATUS, LnUrlWithdrawResult,), {})  # type: ignore




class _UniffiConverterTypeLnUrlWithdrawResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LnUrlWithdrawResult.OK(
                _UniffiConverterTypeLnUrlWithdrawSuccessData.read(buf),
            )
        if variant == 2:
            return LnUrlWithdrawResult.TIMEOUT(
                _UniffiConverterTypeLnUrlWithdrawSuccessData.read(buf),
            )
        if variant == 3:
            return LnUrlWithdrawResult.ERROR_STATUS(
                _UniffiConverterTypeLnUrlErrorData.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_ok():
            _UniffiConverterTypeLnUrlWithdrawSuccessData.check_lower(value.data)
            return
        if value.is_timeout():
            _UniffiConverterTypeLnUrlWithdrawSuccessData.check_lower(value.data)
            return
        if value.is_error_status():
            _UniffiConverterTypeLnUrlErrorData.check_lower(value.data)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_ok():
            buf.write_i32(1)
            _UniffiConverterTypeLnUrlWithdrawSuccessData.write(value.data, buf)
        if value.is_timeout():
            buf.write_i32(2)
            _UniffiConverterTypeLnUrlWithdrawSuccessData.write(value.data, buf)
        if value.is_error_status():
            buf.write_i32(3)
            _UniffiConverterTypeLnUrlErrorData.write(value.data, buf)







class Network(enum.Enum):
    BITCOIN = 0
    
    TESTNET = 1
    
    SIGNET = 2
    
    REGTEST = 3
    


class _UniffiConverterTypeNetwork(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Network.BITCOIN
        if variant == 2:
            return Network.TESTNET
        if variant == 3:
            return Network.SIGNET
        if variant == 4:
            return Network.REGTEST
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Network.BITCOIN:
            return
        if value == Network.TESTNET:
            return
        if value == Network.SIGNET:
            return
        if value == Network.REGTEST:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == Network.BITCOIN:
            buf.write_i32(1)
        if value == Network.TESTNET:
            buf.write_i32(2)
        if value == Network.SIGNET:
            buf.write_i32(3)
        if value == Network.REGTEST:
            buf.write_i32(4)







class NodeConfig:
    def __init__(self):
        raise RuntimeError("NodeConfig cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class GREENLIGHT:
        config: "GreenlightNodeConfig"

        def __init__(self,config: "GreenlightNodeConfig"):
            self.config = config

        def __str__(self):
            return "NodeConfig.GREENLIGHT(config={})".format(self.config)

        def __eq__(self, other):
            if not other.is_greenlight():
                return False
            if self.config != other.config:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_greenlight(self) -> bool:
        return isinstance(self, NodeConfig.GREENLIGHT)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
NodeConfig.GREENLIGHT = type("NodeConfig.GREENLIGHT", (NodeConfig.GREENLIGHT, NodeConfig,), {})  # type: ignore




class _UniffiConverterTypeNodeConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return NodeConfig.GREENLIGHT(
                _UniffiConverterTypeGreenlightNodeConfig.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_greenlight():
            _UniffiConverterTypeGreenlightNodeConfig.check_lower(value.config)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_greenlight():
            buf.write_i32(1)
            _UniffiConverterTypeGreenlightNodeConfig.write(value.config, buf)







class NodeCredentials:
    def __init__(self):
        raise RuntimeError("NodeCredentials cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class GREENLIGHT:
        credentials: "GreenlightDeviceCredentials"

        def __init__(self,credentials: "GreenlightDeviceCredentials"):
            self.credentials = credentials

        def __str__(self):
            return "NodeCredentials.GREENLIGHT(credentials={})".format(self.credentials)

        def __eq__(self, other):
            if not other.is_greenlight():
                return False
            if self.credentials != other.credentials:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_greenlight(self) -> bool:
        return isinstance(self, NodeCredentials.GREENLIGHT)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
NodeCredentials.GREENLIGHT = type("NodeCredentials.GREENLIGHT", (NodeCredentials.GREENLIGHT, NodeCredentials,), {})  # type: ignore




class _UniffiConverterTypeNodeCredentials(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return NodeCredentials.GREENLIGHT(
                _UniffiConverterTypeGreenlightDeviceCredentials.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_greenlight():
            _UniffiConverterTypeGreenlightDeviceCredentials.check_lower(value.credentials)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_greenlight():
            buf.write_i32(1)
            _UniffiConverterTypeGreenlightDeviceCredentials.write(value.credentials, buf)







class PaymentDetails:
    def __init__(self):
        raise RuntimeError("PaymentDetails cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class LN:
        data: "LnPaymentDetails"

        def __init__(self,data: "LnPaymentDetails"):
            self.data = data

        def __str__(self):
            return "PaymentDetails.LN(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_ln():
                return False
            if self.data != other.data:
                return False
            return True
    
    class CLOSED_CHANNEL:
        data: "ClosedChannelPaymentDetails"

        def __init__(self,data: "ClosedChannelPaymentDetails"):
            self.data = data

        def __str__(self):
            return "PaymentDetails.CLOSED_CHANNEL(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_closed_channel():
                return False
            if self.data != other.data:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_ln(self) -> bool:
        return isinstance(self, PaymentDetails.LN)
    def is_closed_channel(self) -> bool:
        return isinstance(self, PaymentDetails.CLOSED_CHANNEL)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
PaymentDetails.LN = type("PaymentDetails.LN", (PaymentDetails.LN, PaymentDetails,), {})  # type: ignore
PaymentDetails.CLOSED_CHANNEL = type("PaymentDetails.CLOSED_CHANNEL", (PaymentDetails.CLOSED_CHANNEL, PaymentDetails,), {})  # type: ignore




class _UniffiConverterTypePaymentDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PaymentDetails.LN(
                _UniffiConverterTypeLnPaymentDetails.read(buf),
            )
        if variant == 2:
            return PaymentDetails.CLOSED_CHANNEL(
                _UniffiConverterTypeClosedChannelPaymentDetails.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_ln():
            _UniffiConverterTypeLnPaymentDetails.check_lower(value.data)
            return
        if value.is_closed_channel():
            _UniffiConverterTypeClosedChannelPaymentDetails.check_lower(value.data)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_ln():
            buf.write_i32(1)
            _UniffiConverterTypeLnPaymentDetails.write(value.data, buf)
        if value.is_closed_channel():
            buf.write_i32(2)
            _UniffiConverterTypeClosedChannelPaymentDetails.write(value.data, buf)







class PaymentStatus(enum.Enum):
    PENDING = 0
    
    COMPLETE = 1
    
    FAILED = 2
    


class _UniffiConverterTypePaymentStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PaymentStatus.PENDING
        if variant == 2:
            return PaymentStatus.COMPLETE
        if variant == 3:
            return PaymentStatus.FAILED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == PaymentStatus.PENDING:
            return
        if value == PaymentStatus.COMPLETE:
            return
        if value == PaymentStatus.FAILED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == PaymentStatus.PENDING:
            buf.write_i32(1)
        if value == PaymentStatus.COMPLETE:
            buf.write_i32(2)
        if value == PaymentStatus.FAILED:
            buf.write_i32(3)







class PaymentType(enum.Enum):
    SENT = 0
    
    RECEIVED = 1
    
    CLOSED_CHANNEL = 2
    


class _UniffiConverterTypePaymentType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PaymentType.SENT
        if variant == 2:
            return PaymentType.RECEIVED
        if variant == 3:
            return PaymentType.CLOSED_CHANNEL
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == PaymentType.SENT:
            return
        if value == PaymentType.RECEIVED:
            return
        if value == PaymentType.CLOSED_CHANNEL:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == PaymentType.SENT:
            buf.write_i32(1)
        if value == PaymentType.RECEIVED:
            buf.write_i32(2)
        if value == PaymentType.CLOSED_CHANNEL:
            buf.write_i32(3)







class PaymentTypeFilter(enum.Enum):
    SENT = 0
    
    RECEIVED = 1
    
    CLOSED_CHANNEL = 2
    


class _UniffiConverterTypePaymentTypeFilter(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PaymentTypeFilter.SENT
        if variant == 2:
            return PaymentTypeFilter.RECEIVED
        if variant == 3:
            return PaymentTypeFilter.CLOSED_CHANNEL
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == PaymentTypeFilter.SENT:
            return
        if value == PaymentTypeFilter.RECEIVED:
            return
        if value == PaymentTypeFilter.CLOSED_CHANNEL:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == PaymentTypeFilter.SENT:
            buf.write_i32(1)
        if value == PaymentTypeFilter.RECEIVED:
            buf.write_i32(2)
        if value == PaymentTypeFilter.CLOSED_CHANNEL:
            buf.write_i32(3)




# ReceiveOnchainError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class ReceiveOnchainError(Exception):
    pass

_UniffiTempReceiveOnchainError = ReceiveOnchainError

class ReceiveOnchainError:  # type: ignore
    class Generic(_UniffiTempReceiveOnchainError):

        def __repr__(self):
            return "ReceiveOnchainError.Generic({})".format(repr(str(self)))
    _UniffiTempReceiveOnchainError.Generic = Generic # type: ignore
    class ServiceConnectivity(_UniffiTempReceiveOnchainError):

        def __repr__(self):
            return "ReceiveOnchainError.ServiceConnectivity({})".format(repr(str(self)))
    _UniffiTempReceiveOnchainError.ServiceConnectivity = ServiceConnectivity # type: ignore
    class SwapInProgress(_UniffiTempReceiveOnchainError):

        def __repr__(self):
            return "ReceiveOnchainError.SwapInProgress({})".format(repr(str(self)))
    _UniffiTempReceiveOnchainError.SwapInProgress = SwapInProgress # type: ignore

ReceiveOnchainError = _UniffiTempReceiveOnchainError # type: ignore
del _UniffiTempReceiveOnchainError


class _UniffiConverterTypeReceiveOnchainError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ReceiveOnchainError.Generic(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return ReceiveOnchainError.ServiceConnectivity(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return ReceiveOnchainError.SwapInProgress(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, ReceiveOnchainError.Generic):
            return
        if isinstance(value, ReceiveOnchainError.ServiceConnectivity):
            return
        if isinstance(value, ReceiveOnchainError.SwapInProgress):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, ReceiveOnchainError.Generic):
            buf.write_i32(1)
        if isinstance(value, ReceiveOnchainError.ServiceConnectivity):
            buf.write_i32(2)
        if isinstance(value, ReceiveOnchainError.SwapInProgress):
            buf.write_i32(3)


# ReceivePaymentError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class ReceivePaymentError(Exception):
    pass

_UniffiTempReceivePaymentError = ReceivePaymentError

class ReceivePaymentError:  # type: ignore
    class Generic(_UniffiTempReceivePaymentError):

        def __repr__(self):
            return "ReceivePaymentError.Generic({})".format(repr(str(self)))
    _UniffiTempReceivePaymentError.Generic = Generic # type: ignore
    class InvalidAmount(_UniffiTempReceivePaymentError):

        def __repr__(self):
            return "ReceivePaymentError.InvalidAmount({})".format(repr(str(self)))
    _UniffiTempReceivePaymentError.InvalidAmount = InvalidAmount # type: ignore
    class InvalidInvoice(_UniffiTempReceivePaymentError):

        def __repr__(self):
            return "ReceivePaymentError.InvalidInvoice({})".format(repr(str(self)))
    _UniffiTempReceivePaymentError.InvalidInvoice = InvalidInvoice # type: ignore
    class InvoiceExpired(_UniffiTempReceivePaymentError):

        def __repr__(self):
            return "ReceivePaymentError.InvoiceExpired({})".format(repr(str(self)))
    _UniffiTempReceivePaymentError.InvoiceExpired = InvoiceExpired # type: ignore
    class InvoiceNoDescription(_UniffiTempReceivePaymentError):

        def __repr__(self):
            return "ReceivePaymentError.InvoiceNoDescription({})".format(repr(str(self)))
    _UniffiTempReceivePaymentError.InvoiceNoDescription = InvoiceNoDescription # type: ignore
    class InvoicePreimageAlreadyExists(_UniffiTempReceivePaymentError):

        def __repr__(self):
            return "ReceivePaymentError.InvoicePreimageAlreadyExists({})".format(repr(str(self)))
    _UniffiTempReceivePaymentError.InvoicePreimageAlreadyExists = InvoicePreimageAlreadyExists # type: ignore
    class ServiceConnectivity(_UniffiTempReceivePaymentError):

        def __repr__(self):
            return "ReceivePaymentError.ServiceConnectivity({})".format(repr(str(self)))
    _UniffiTempReceivePaymentError.ServiceConnectivity = ServiceConnectivity # type: ignore
    class InvoiceNoRoutingHints(_UniffiTempReceivePaymentError):

        def __repr__(self):
            return "ReceivePaymentError.InvoiceNoRoutingHints({})".format(repr(str(self)))
    _UniffiTempReceivePaymentError.InvoiceNoRoutingHints = InvoiceNoRoutingHints # type: ignore

ReceivePaymentError = _UniffiTempReceivePaymentError # type: ignore
del _UniffiTempReceivePaymentError


class _UniffiConverterTypeReceivePaymentError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ReceivePaymentError.Generic(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return ReceivePaymentError.InvalidAmount(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return ReceivePaymentError.InvalidInvoice(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return ReceivePaymentError.InvoiceExpired(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return ReceivePaymentError.InvoiceNoDescription(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return ReceivePaymentError.InvoicePreimageAlreadyExists(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return ReceivePaymentError.ServiceConnectivity(
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return ReceivePaymentError.InvoiceNoRoutingHints(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, ReceivePaymentError.Generic):
            return
        if isinstance(value, ReceivePaymentError.InvalidAmount):
            return
        if isinstance(value, ReceivePaymentError.InvalidInvoice):
            return
        if isinstance(value, ReceivePaymentError.InvoiceExpired):
            return
        if isinstance(value, ReceivePaymentError.InvoiceNoDescription):
            return
        if isinstance(value, ReceivePaymentError.InvoicePreimageAlreadyExists):
            return
        if isinstance(value, ReceivePaymentError.ServiceConnectivity):
            return
        if isinstance(value, ReceivePaymentError.InvoiceNoRoutingHints):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, ReceivePaymentError.Generic):
            buf.write_i32(1)
        if isinstance(value, ReceivePaymentError.InvalidAmount):
            buf.write_i32(2)
        if isinstance(value, ReceivePaymentError.InvalidInvoice):
            buf.write_i32(3)
        if isinstance(value, ReceivePaymentError.InvoiceExpired):
            buf.write_i32(4)
        if isinstance(value, ReceivePaymentError.InvoiceNoDescription):
            buf.write_i32(5)
        if isinstance(value, ReceivePaymentError.InvoicePreimageAlreadyExists):
            buf.write_i32(6)
        if isinstance(value, ReceivePaymentError.ServiceConnectivity):
            buf.write_i32(7)
        if isinstance(value, ReceivePaymentError.InvoiceNoRoutingHints):
            buf.write_i32(8)


# RedeemOnchainError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class RedeemOnchainError(Exception):
    pass

_UniffiTempRedeemOnchainError = RedeemOnchainError

class RedeemOnchainError:  # type: ignore
    class Generic(_UniffiTempRedeemOnchainError):

        def __repr__(self):
            return "RedeemOnchainError.Generic({})".format(repr(str(self)))
    _UniffiTempRedeemOnchainError.Generic = Generic # type: ignore
    class ServiceConnectivity(_UniffiTempRedeemOnchainError):

        def __repr__(self):
            return "RedeemOnchainError.ServiceConnectivity({})".format(repr(str(self)))
    _UniffiTempRedeemOnchainError.ServiceConnectivity = ServiceConnectivity # type: ignore
    class InsufficientFunds(_UniffiTempRedeemOnchainError):

        def __repr__(self):
            return "RedeemOnchainError.InsufficientFunds({})".format(repr(str(self)))
    _UniffiTempRedeemOnchainError.InsufficientFunds = InsufficientFunds # type: ignore

RedeemOnchainError = _UniffiTempRedeemOnchainError # type: ignore
del _UniffiTempRedeemOnchainError


class _UniffiConverterTypeRedeemOnchainError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RedeemOnchainError.Generic(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return RedeemOnchainError.ServiceConnectivity(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return RedeemOnchainError.InsufficientFunds(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, RedeemOnchainError.Generic):
            return
        if isinstance(value, RedeemOnchainError.ServiceConnectivity):
            return
        if isinstance(value, RedeemOnchainError.InsufficientFunds):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, RedeemOnchainError.Generic):
            buf.write_i32(1)
        if isinstance(value, RedeemOnchainError.ServiceConnectivity):
            buf.write_i32(2)
        if isinstance(value, RedeemOnchainError.InsufficientFunds):
            buf.write_i32(3)





class ReportIssueRequest:
    def __init__(self):
        raise RuntimeError("ReportIssueRequest cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class PAYMENT_FAILURE:
        data: "ReportPaymentFailureDetails"

        def __init__(self,data: "ReportPaymentFailureDetails"):
            self.data = data

        def __str__(self):
            return "ReportIssueRequest.PAYMENT_FAILURE(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_payment_failure():
                return False
            if self.data != other.data:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_payment_failure(self) -> bool:
        return isinstance(self, ReportIssueRequest.PAYMENT_FAILURE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ReportIssueRequest.PAYMENT_FAILURE = type("ReportIssueRequest.PAYMENT_FAILURE", (ReportIssueRequest.PAYMENT_FAILURE, ReportIssueRequest,), {})  # type: ignore




class _UniffiConverterTypeReportIssueRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ReportIssueRequest.PAYMENT_FAILURE(
                _UniffiConverterTypeReportPaymentFailureDetails.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_payment_failure():
            _UniffiConverterTypeReportPaymentFailureDetails.check_lower(value.data)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_payment_failure():
            buf.write_i32(1)
            _UniffiConverterTypeReportPaymentFailureDetails.write(value.data, buf)







class ReverseSwapStatus(enum.Enum):
    INITIAL = 0
    
    IN_PROGRESS = 1
    
    CANCELLED = 2
    
    COMPLETED_SEEN = 3
    
    COMPLETED_CONFIRMED = 4
    


class _UniffiConverterTypeReverseSwapStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ReverseSwapStatus.INITIAL
        if variant == 2:
            return ReverseSwapStatus.IN_PROGRESS
        if variant == 3:
            return ReverseSwapStatus.CANCELLED
        if variant == 4:
            return ReverseSwapStatus.COMPLETED_SEEN
        if variant == 5:
            return ReverseSwapStatus.COMPLETED_CONFIRMED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == ReverseSwapStatus.INITIAL:
            return
        if value == ReverseSwapStatus.IN_PROGRESS:
            return
        if value == ReverseSwapStatus.CANCELLED:
            return
        if value == ReverseSwapStatus.COMPLETED_SEEN:
            return
        if value == ReverseSwapStatus.COMPLETED_CONFIRMED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == ReverseSwapStatus.INITIAL:
            buf.write_i32(1)
        if value == ReverseSwapStatus.IN_PROGRESS:
            buf.write_i32(2)
        if value == ReverseSwapStatus.CANCELLED:
            buf.write_i32(3)
        if value == ReverseSwapStatus.COMPLETED_SEEN:
            buf.write_i32(4)
        if value == ReverseSwapStatus.COMPLETED_CONFIRMED:
            buf.write_i32(5)




# SdkError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class SdkError(Exception):
    pass

_UniffiTempSdkError = SdkError

class SdkError:  # type: ignore
    class Generic(_UniffiTempSdkError):

        def __repr__(self):
            return "SdkError.Generic({})".format(repr(str(self)))
    _UniffiTempSdkError.Generic = Generic # type: ignore
    class ServiceConnectivity(_UniffiTempSdkError):

        def __repr__(self):
            return "SdkError.ServiceConnectivity({})".format(repr(str(self)))
    _UniffiTempSdkError.ServiceConnectivity = ServiceConnectivity # type: ignore

SdkError = _UniffiTempSdkError # type: ignore
del _UniffiTempSdkError


class _UniffiConverterTypeSdkError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SdkError.Generic(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return SdkError.ServiceConnectivity(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, SdkError.Generic):
            return
        if isinstance(value, SdkError.ServiceConnectivity):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, SdkError.Generic):
            buf.write_i32(1)
        if isinstance(value, SdkError.ServiceConnectivity):
            buf.write_i32(2)


# SendOnchainError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class SendOnchainError(Exception):
    pass

_UniffiTempSendOnchainError = SendOnchainError

class SendOnchainError:  # type: ignore
    class Generic(_UniffiTempSendOnchainError):

        def __repr__(self):
            return "SendOnchainError.Generic({})".format(repr(str(self)))
    _UniffiTempSendOnchainError.Generic = Generic # type: ignore
    class InvalidDestinationAddress(_UniffiTempSendOnchainError):

        def __repr__(self):
            return "SendOnchainError.InvalidDestinationAddress({})".format(repr(str(self)))
    _UniffiTempSendOnchainError.InvalidDestinationAddress = InvalidDestinationAddress # type: ignore
    class OutOfRange(_UniffiTempSendOnchainError):

        def __repr__(self):
            return "SendOnchainError.OutOfRange({})".format(repr(str(self)))
    _UniffiTempSendOnchainError.OutOfRange = OutOfRange # type: ignore
    class PaymentFailed(_UniffiTempSendOnchainError):

        def __repr__(self):
            return "SendOnchainError.PaymentFailed({})".format(repr(str(self)))
    _UniffiTempSendOnchainError.PaymentFailed = PaymentFailed # type: ignore
    class PaymentTimeout(_UniffiTempSendOnchainError):

        def __repr__(self):
            return "SendOnchainError.PaymentTimeout({})".format(repr(str(self)))
    _UniffiTempSendOnchainError.PaymentTimeout = PaymentTimeout # type: ignore
    class ServiceConnectivity(_UniffiTempSendOnchainError):

        def __repr__(self):
            return "SendOnchainError.ServiceConnectivity({})".format(repr(str(self)))
    _UniffiTempSendOnchainError.ServiceConnectivity = ServiceConnectivity # type: ignore

SendOnchainError = _UniffiTempSendOnchainError # type: ignore
del _UniffiTempSendOnchainError


class _UniffiConverterTypeSendOnchainError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SendOnchainError.Generic(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return SendOnchainError.InvalidDestinationAddress(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return SendOnchainError.OutOfRange(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return SendOnchainError.PaymentFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return SendOnchainError.PaymentTimeout(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return SendOnchainError.ServiceConnectivity(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, SendOnchainError.Generic):
            return
        if isinstance(value, SendOnchainError.InvalidDestinationAddress):
            return
        if isinstance(value, SendOnchainError.OutOfRange):
            return
        if isinstance(value, SendOnchainError.PaymentFailed):
            return
        if isinstance(value, SendOnchainError.PaymentTimeout):
            return
        if isinstance(value, SendOnchainError.ServiceConnectivity):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, SendOnchainError.Generic):
            buf.write_i32(1)
        if isinstance(value, SendOnchainError.InvalidDestinationAddress):
            buf.write_i32(2)
        if isinstance(value, SendOnchainError.OutOfRange):
            buf.write_i32(3)
        if isinstance(value, SendOnchainError.PaymentFailed):
            buf.write_i32(4)
        if isinstance(value, SendOnchainError.PaymentTimeout):
            buf.write_i32(5)
        if isinstance(value, SendOnchainError.ServiceConnectivity):
            buf.write_i32(6)


# SendPaymentError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class SendPaymentError(Exception):
    pass

_UniffiTempSendPaymentError = SendPaymentError

class SendPaymentError:  # type: ignore
    class AlreadyPaid(_UniffiTempSendPaymentError):

        def __repr__(self):
            return "SendPaymentError.AlreadyPaid({})".format(repr(str(self)))
    _UniffiTempSendPaymentError.AlreadyPaid = AlreadyPaid # type: ignore
    class Generic(_UniffiTempSendPaymentError):

        def __repr__(self):
            return "SendPaymentError.Generic({})".format(repr(str(self)))
    _UniffiTempSendPaymentError.Generic = Generic # type: ignore
    class InvalidAmount(_UniffiTempSendPaymentError):

        def __repr__(self):
            return "SendPaymentError.InvalidAmount({})".format(repr(str(self)))
    _UniffiTempSendPaymentError.InvalidAmount = InvalidAmount # type: ignore
    class InvalidInvoice(_UniffiTempSendPaymentError):

        def __repr__(self):
            return "SendPaymentError.InvalidInvoice({})".format(repr(str(self)))
    _UniffiTempSendPaymentError.InvalidInvoice = InvalidInvoice # type: ignore
    class InvoiceExpired(_UniffiTempSendPaymentError):

        def __repr__(self):
            return "SendPaymentError.InvoiceExpired({})".format(repr(str(self)))
    _UniffiTempSendPaymentError.InvoiceExpired = InvoiceExpired # type: ignore
    class InvalidNetwork(_UniffiTempSendPaymentError):

        def __repr__(self):
            return "SendPaymentError.InvalidNetwork({})".format(repr(str(self)))
    _UniffiTempSendPaymentError.InvalidNetwork = InvalidNetwork # type: ignore
    class PaymentFailed(_UniffiTempSendPaymentError):

        def __repr__(self):
            return "SendPaymentError.PaymentFailed({})".format(repr(str(self)))
    _UniffiTempSendPaymentError.PaymentFailed = PaymentFailed # type: ignore
    class PaymentTimeout(_UniffiTempSendPaymentError):

        def __repr__(self):
            return "SendPaymentError.PaymentTimeout({})".format(repr(str(self)))
    _UniffiTempSendPaymentError.PaymentTimeout = PaymentTimeout # type: ignore
    class RouteNotFound(_UniffiTempSendPaymentError):

        def __repr__(self):
            return "SendPaymentError.RouteNotFound({})".format(repr(str(self)))
    _UniffiTempSendPaymentError.RouteNotFound = RouteNotFound # type: ignore
    class RouteTooExpensive(_UniffiTempSendPaymentError):

        def __repr__(self):
            return "SendPaymentError.RouteTooExpensive({})".format(repr(str(self)))
    _UniffiTempSendPaymentError.RouteTooExpensive = RouteTooExpensive # type: ignore
    class ServiceConnectivity(_UniffiTempSendPaymentError):

        def __repr__(self):
            return "SendPaymentError.ServiceConnectivity({})".format(repr(str(self)))
    _UniffiTempSendPaymentError.ServiceConnectivity = ServiceConnectivity # type: ignore
    class InsufficientBalance(_UniffiTempSendPaymentError):

        def __repr__(self):
            return "SendPaymentError.InsufficientBalance({})".format(repr(str(self)))
    _UniffiTempSendPaymentError.InsufficientBalance = InsufficientBalance # type: ignore

SendPaymentError = _UniffiTempSendPaymentError # type: ignore
del _UniffiTempSendPaymentError


class _UniffiConverterTypeSendPaymentError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SendPaymentError.AlreadyPaid(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return SendPaymentError.Generic(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return SendPaymentError.InvalidAmount(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return SendPaymentError.InvalidInvoice(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return SendPaymentError.InvoiceExpired(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return SendPaymentError.InvalidNetwork(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return SendPaymentError.PaymentFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return SendPaymentError.PaymentTimeout(
                _UniffiConverterString.read(buf),
            )
        if variant == 9:
            return SendPaymentError.RouteNotFound(
                _UniffiConverterString.read(buf),
            )
        if variant == 10:
            return SendPaymentError.RouteTooExpensive(
                _UniffiConverterString.read(buf),
            )
        if variant == 11:
            return SendPaymentError.ServiceConnectivity(
                _UniffiConverterString.read(buf),
            )
        if variant == 12:
            return SendPaymentError.InsufficientBalance(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, SendPaymentError.AlreadyPaid):
            return
        if isinstance(value, SendPaymentError.Generic):
            return
        if isinstance(value, SendPaymentError.InvalidAmount):
            return
        if isinstance(value, SendPaymentError.InvalidInvoice):
            return
        if isinstance(value, SendPaymentError.InvoiceExpired):
            return
        if isinstance(value, SendPaymentError.InvalidNetwork):
            return
        if isinstance(value, SendPaymentError.PaymentFailed):
            return
        if isinstance(value, SendPaymentError.PaymentTimeout):
            return
        if isinstance(value, SendPaymentError.RouteNotFound):
            return
        if isinstance(value, SendPaymentError.RouteTooExpensive):
            return
        if isinstance(value, SendPaymentError.ServiceConnectivity):
            return
        if isinstance(value, SendPaymentError.InsufficientBalance):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, SendPaymentError.AlreadyPaid):
            buf.write_i32(1)
        if isinstance(value, SendPaymentError.Generic):
            buf.write_i32(2)
        if isinstance(value, SendPaymentError.InvalidAmount):
            buf.write_i32(3)
        if isinstance(value, SendPaymentError.InvalidInvoice):
            buf.write_i32(4)
        if isinstance(value, SendPaymentError.InvoiceExpired):
            buf.write_i32(5)
        if isinstance(value, SendPaymentError.InvalidNetwork):
            buf.write_i32(6)
        if isinstance(value, SendPaymentError.PaymentFailed):
            buf.write_i32(7)
        if isinstance(value, SendPaymentError.PaymentTimeout):
            buf.write_i32(8)
        if isinstance(value, SendPaymentError.RouteNotFound):
            buf.write_i32(9)
        if isinstance(value, SendPaymentError.RouteTooExpensive):
            buf.write_i32(10)
        if isinstance(value, SendPaymentError.ServiceConnectivity):
            buf.write_i32(11)
        if isinstance(value, SendPaymentError.InsufficientBalance):
            buf.write_i32(12)





class SuccessActionProcessed:
    def __init__(self):
        raise RuntimeError("SuccessActionProcessed cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class AES:
        result: "AesSuccessActionDataResult"

        def __init__(self,result: "AesSuccessActionDataResult"):
            self.result = result

        def __str__(self):
            return "SuccessActionProcessed.AES(result={})".format(self.result)

        def __eq__(self, other):
            if not other.is_aes():
                return False
            if self.result != other.result:
                return False
            return True
    
    class MESSAGE:
        data: "MessageSuccessActionData"

        def __init__(self,data: "MessageSuccessActionData"):
            self.data = data

        def __str__(self):
            return "SuccessActionProcessed.MESSAGE(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_message():
                return False
            if self.data != other.data:
                return False
            return True
    
    class URL:
        data: "UrlSuccessActionData"

        def __init__(self,data: "UrlSuccessActionData"):
            self.data = data

        def __str__(self):
            return "SuccessActionProcessed.URL(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_url():
                return False
            if self.data != other.data:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_aes(self) -> bool:
        return isinstance(self, SuccessActionProcessed.AES)
    def is_message(self) -> bool:
        return isinstance(self, SuccessActionProcessed.MESSAGE)
    def is_url(self) -> bool:
        return isinstance(self, SuccessActionProcessed.URL)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
SuccessActionProcessed.AES = type("SuccessActionProcessed.AES", (SuccessActionProcessed.AES, SuccessActionProcessed,), {})  # type: ignore
SuccessActionProcessed.MESSAGE = type("SuccessActionProcessed.MESSAGE", (SuccessActionProcessed.MESSAGE, SuccessActionProcessed,), {})  # type: ignore
SuccessActionProcessed.URL = type("SuccessActionProcessed.URL", (SuccessActionProcessed.URL, SuccessActionProcessed,), {})  # type: ignore




class _UniffiConverterTypeSuccessActionProcessed(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SuccessActionProcessed.AES(
                _UniffiConverterTypeAesSuccessActionDataResult.read(buf),
            )
        if variant == 2:
            return SuccessActionProcessed.MESSAGE(
                _UniffiConverterTypeMessageSuccessActionData.read(buf),
            )
        if variant == 3:
            return SuccessActionProcessed.URL(
                _UniffiConverterTypeUrlSuccessActionData.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_aes():
            _UniffiConverterTypeAesSuccessActionDataResult.check_lower(value.result)
            return
        if value.is_message():
            _UniffiConverterTypeMessageSuccessActionData.check_lower(value.data)
            return
        if value.is_url():
            _UniffiConverterTypeUrlSuccessActionData.check_lower(value.data)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_aes():
            buf.write_i32(1)
            _UniffiConverterTypeAesSuccessActionDataResult.write(value.result, buf)
        if value.is_message():
            buf.write_i32(2)
            _UniffiConverterTypeMessageSuccessActionData.write(value.data, buf)
        if value.is_url():
            buf.write_i32(3)
            _UniffiConverterTypeUrlSuccessActionData.write(value.data, buf)







class SwapAmountType(enum.Enum):
    SEND = 0
    
    RECEIVE = 1
    


class _UniffiConverterTypeSwapAmountType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SwapAmountType.SEND
        if variant == 2:
            return SwapAmountType.RECEIVE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == SwapAmountType.SEND:
            return
        if value == SwapAmountType.RECEIVE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == SwapAmountType.SEND:
            buf.write_i32(1)
        if value == SwapAmountType.RECEIVE:
            buf.write_i32(2)







class SwapStatus(enum.Enum):
    INITIAL = 0
    
    WAITING_CONFIRMATION = 1
    
    REDEEMABLE = 2
    
    REDEEMED = 3
    
    REFUNDABLE = 4
    
    COMPLETED = 5
    


class _UniffiConverterTypeSwapStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SwapStatus.INITIAL
        if variant == 2:
            return SwapStatus.WAITING_CONFIRMATION
        if variant == 3:
            return SwapStatus.REDEEMABLE
        if variant == 4:
            return SwapStatus.REDEEMED
        if variant == 5:
            return SwapStatus.REFUNDABLE
        if variant == 6:
            return SwapStatus.COMPLETED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == SwapStatus.INITIAL:
            return
        if value == SwapStatus.WAITING_CONFIRMATION:
            return
        if value == SwapStatus.REDEEMABLE:
            return
        if value == SwapStatus.REDEEMED:
            return
        if value == SwapStatus.REFUNDABLE:
            return
        if value == SwapStatus.COMPLETED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == SwapStatus.INITIAL:
            buf.write_i32(1)
        if value == SwapStatus.WAITING_CONFIRMATION:
            buf.write_i32(2)
        if value == SwapStatus.REDEEMABLE:
            buf.write_i32(3)
        if value == SwapStatus.REDEEMED:
            buf.write_i32(4)
        if value == SwapStatus.REFUNDABLE:
            buf.write_i32(5)
        if value == SwapStatus.COMPLETED:
            buf.write_i32(6)





class EventListener(typing.Protocol):
    def on_event(self, e: "BreezEvent"):
        raise NotImplementedError
# Magic number for the Rust proxy to call using the same mechanism as every other method,
# to free the callback once it's dropped by Rust.
_UNIFFI_IDX_CALLBACK_FREE = 0
# Return codes for callback calls
_UNIFFI_CALLBACK_SUCCESS = 0
_UNIFFI_CALLBACK_ERROR = 1
_UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

class _UniffiCallbackInterfaceFfiConverter:
    _handle_map = _UniffiHandleMap()

    @classmethod
    def lift(cls, handle):
        return cls._handle_map.get(handle)

    @classmethod
    def read(cls, buf):
        handle = buf.read_u64()
        cls.lift(handle)

    @classmethod
    def check_lower(cls, cb):
        pass

    @classmethod
    def lower(cls, cb):
        handle = cls._handle_map.insert(cb)
        return handle

    @classmethod
    def write(cls, cb, buf):
        buf.write_u64(cls.lower(cb))

# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplEventListener:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_EVENT_LISTENER_METHOD0
    def on_event(
            uniffi_handle,
            e,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeEventListener._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeBreezEvent.lift(e), )
            method = uniffi_obj.on_event
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeEventListener._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceEventListener(
        on_event,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_breez_sdk_bindings_fn_init_callback_vtable_eventlistener(ctypes.byref(_uniffi_vtable))

# The _UniffiConverter which transforms the Callbacks in to Handles to pass to Rust.
_UniffiConverterTypeEventListener = _UniffiCallbackInterfaceFfiConverter()



class LogStream(typing.Protocol):
    def log(self, l: "LogEntry"):
        raise NotImplementedError


# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplLogStream:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_LOG_STREAM_METHOD0
    def log(
            uniffi_handle,
            l,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeLogStream._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeLogEntry.lift(l), )
            method = uniffi_obj.log
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeLogStream._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceLogStream(
        log,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_breez_sdk_bindings_fn_init_callback_vtable_logstream(ctypes.byref(_uniffi_vtable))

# The _UniffiConverter which transforms the Callbacks in to Handles to pass to Rust.
_UniffiConverterTypeLogStream = _UniffiCallbackInterfaceFfiConverter()



class _UniffiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalBool(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterBool.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterBool.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterBool.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeGreenlightCredentials(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeGreenlightCredentials.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeGreenlightCredentials.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeGreenlightCredentials.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLnInvoice(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeLnInvoice.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLnInvoice.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLnInvoice.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLspInformation(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeLspInformation.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLspInformation.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLspInformation.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeOpeningFeeParams(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeOpeningFeeParams.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeOpeningFeeParams.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeOpeningFeeParams.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypePayment(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypePayment.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypePayment.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypePayment.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeReverseSwapInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeReverseSwapInfo.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeReverseSwapInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeReverseSwapInfo.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSwapInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSwapInfo.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSwapInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSwapInfo.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSymbol(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSymbol.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSymbol.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSymbol.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLevelFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeLevelFilter.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLevelFilter.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLevelFilter.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeNodeCredentials(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeNodeCredentials.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeNodeCredentials.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeNodeCredentials.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSuccessActionProcessed(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSuccessActionProcessed.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSuccessActionProcessed.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSuccessActionProcessed.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceUInt8.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceUInt8.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceUInt8.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeMetadataFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeMetadataFilter.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeMetadataFilter.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeMetadataFilter.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeTlvEntry(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeTlvEntry.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeTlvEntry.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeTlvEntry.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypePaymentTypeFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypePaymentTypeFilter.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypePaymentTypeFilter.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypePaymentTypeFilter.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeSwapStatus(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeSwapStatus.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeSwapStatus.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeSwapStatus.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterUInt8.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt8.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterString.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFiatCurrency(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFiatCurrency.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFiatCurrency.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFiatCurrency.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeLocaleOverrides(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeLocaleOverrides.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeLocaleOverrides.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeLocaleOverrides.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeLocalizedName(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeLocalizedName.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeLocalizedName.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeLocalizedName.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeLspInformation(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeLspInformation.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeLspInformation.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeLspInformation.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeMetadataFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeMetadataFilter.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeMetadataFilter.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeMetadataFilter.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeOpeningFeeParams(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeOpeningFeeParams.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeOpeningFeeParams.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeOpeningFeeParams.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePayment(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePayment.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePayment.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePayment.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeRate(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeRate.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeRate.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeRate.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeReverseSwapInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeReverseSwapInfo.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeReverseSwapInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeReverseSwapInfo.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeRouteHint(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeRouteHint.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeRouteHint.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeRouteHint.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeRouteHintHop(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeRouteHintHop.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeRouteHintHop.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeRouteHintHop.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeSwapInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeSwapInfo.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeSwapInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeSwapInfo.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTlvEntry(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTlvEntry.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTlvEntry.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTlvEntry.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeUnspentTransactionOutput(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeUnspentTransactionOutput.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeUnspentTransactionOutput.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeUnspentTransactionOutput.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePaymentTypeFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePaymentTypeFilter.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePaymentTypeFilter.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePaymentTypeFilter.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeSwapStatus(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeSwapStatus.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeSwapStatus.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeSwapStatus.read(buf) for i in range(count)
        ]

# Async support

def connect(req: "ConnectRequest",listener: "EventListener") -> "BlockingBreezServices":
    _UniffiConverterTypeConnectRequest.check_lower(req)
    
    _UniffiConverterTypeEventListener.check_lower(listener)
    
    return _UniffiConverterTypeBlockingBreezServices.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeConnectError,_UniffiLib.uniffi_breez_sdk_bindings_fn_func_connect,
        _UniffiConverterTypeConnectRequest.lower(req),
        _UniffiConverterTypeEventListener.lower(listener)))


def default_config(env_type: "EnvironmentType",api_key: "str",node_config: "NodeConfig") -> "Config":
    _UniffiConverterTypeEnvironmentType.check_lower(env_type)
    
    _UniffiConverterString.check_lower(api_key)
    
    _UniffiConverterTypeNodeConfig.check_lower(node_config)
    
    return _UniffiConverterTypeConfig.lift(_uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_bindings_fn_func_default_config,
        _UniffiConverterTypeEnvironmentType.lower(env_type),
        _UniffiConverterString.lower(api_key),
        _UniffiConverterTypeNodeConfig.lower(node_config)))


def mnemonic_to_seed(phrase: "str") -> "typing.List[int]":
    _UniffiConverterString.check_lower(phrase)
    
    return _UniffiConverterSequenceUInt8.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_func_mnemonic_to_seed,
        _UniffiConverterString.lower(phrase)))


def parse_input(s: "str") -> "InputType":
    _UniffiConverterString.check_lower(s)
    
    return _UniffiConverterTypeInputType.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_func_parse_input,
        _UniffiConverterString.lower(s)))


def parse_invoice(invoice: "str") -> "LnInvoice":
    _UniffiConverterString.check_lower(invoice)
    
    return _UniffiConverterTypeLnInvoice.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_func_parse_invoice,
        _UniffiConverterString.lower(invoice)))


def service_health_check(api_key: "str") -> "ServiceHealthCheckResponse":
    _UniffiConverterString.check_lower(api_key)
    
    return _UniffiConverterTypeServiceHealthCheckResponse.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_func_service_health_check,
        _UniffiConverterString.lower(api_key)))


def set_log_stream(log_stream: "LogStream",filter_level: "typing.Optional[LevelFilter]") -> None:
    _UniffiConverterTypeLogStream.check_lower(log_stream)
    
    _UniffiConverterOptionalTypeLevelFilter.check_lower(filter_level)
    
    _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_func_set_log_stream,
        _UniffiConverterTypeLogStream.lower(log_stream),
        _UniffiConverterOptionalTypeLevelFilter.lower(filter_level))


def static_backup(req: "StaticBackupRequest") -> "StaticBackupResponse":
    _UniffiConverterTypeStaticBackupRequest.check_lower(req)
    
    return _UniffiConverterTypeStaticBackupResponse.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_bindings_fn_func_static_backup,
        _UniffiConverterTypeStaticBackupRequest.lower(req)))


__all__ = [
    "InternalError",
    "AesSuccessActionDataResult",
    "BreezEvent",
    "BuyBitcoinProvider",
    "ChannelState",
    "ConnectError",
    "EnvironmentType",
    "FeeratePreset",
    "HealthCheckStatus",
    "InputType",
    "LevelFilter",
    "LnUrlAuthError",
    "LnUrlCallbackStatus",
    "LnUrlPayError",
    "LnUrlPayResult",
    "LnUrlWithdrawError",
    "LnUrlWithdrawResult",
    "Network",
    "NodeConfig",
    "NodeCredentials",
    "PaymentDetails",
    "PaymentStatus",
    "PaymentType",
    "PaymentTypeFilter",
    "ReceiveOnchainError",
    "ReceivePaymentError",
    "RedeemOnchainError",
    "ReportIssueRequest",
    "ReverseSwapStatus",
    "SdkError",
    "SendOnchainError",
    "SendPaymentError",
    "SuccessActionProcessed",
    "SwapAmountType",
    "SwapStatus",
    "AesSuccessActionDataDecrypted",
    "BackupFailedData",
    "BackupStatus",
    "BitcoinAddressData",
    "BuyBitcoinRequest",
    "BuyBitcoinResponse",
    "CheckMessageRequest",
    "CheckMessageResponse",
    "ClosedChannelPaymentDetails",
    "Config",
    "ConfigureNodeRequest",
    "ConnectRequest",
    "CurrencyInfo",
    "FiatCurrency",
    "GreenlightCredentials",
    "GreenlightDeviceCredentials",
    "GreenlightNodeConfig",
    "InvoicePaidDetails",
    "ListPaymentsRequest",
    "ListSwapsRequest",
    "LnInvoice",
    "LnPaymentDetails",
    "LnUrlAuthRequestData",
    "LnUrlErrorData",
    "LnUrlPayErrorData",
    "LnUrlPayRequest",
    "LnUrlPayRequestData",
    "LnUrlPaySuccessData",
    "LnUrlWithdrawRequest",
    "LnUrlWithdrawRequestData",
    "LnUrlWithdrawSuccessData",
    "LocaleOverrides",
    "LocalizedName",
    "LogEntry",
    "LspInformation",
    "MessageSuccessActionData",
    "MetadataFilter",
    "MetadataItem",
    "NodeState",
    "OnchainPaymentLimitsResponse",
    "OpenChannelFeeRequest",
    "OpenChannelFeeResponse",
    "OpeningFeeParams",
    "OpeningFeeParamsMenu",
    "PayOnchainRequest",
    "PayOnchainResponse",
    "Payment",
    "PaymentFailedData",
    "PrepareOnchainPaymentRequest",
    "PrepareOnchainPaymentResponse",
    "PrepareRedeemOnchainFundsRequest",
    "PrepareRedeemOnchainFundsResponse",
    "PrepareRefundRequest",
    "PrepareRefundResponse",
    "Rate",
    "ReceiveOnchainRequest",
    "ReceivePaymentRequest",
    "ReceivePaymentResponse",
    "RecommendedFees",
    "RedeemOnchainFundsRequest",
    "RedeemOnchainFundsResponse",
    "RefundRequest",
    "RefundResponse",
    "ReportPaymentFailureDetails",
    "ReverseSwapFeesRequest",
    "ReverseSwapInfo",
    "ReverseSwapPairInfo",
    "RouteHint",
    "RouteHintHop",
    "SendPaymentRequest",
    "SendPaymentResponse",
    "SendSpontaneousPaymentRequest",
    "ServiceHealthCheckResponse",
    "SignMessageRequest",
    "SignMessageResponse",
    "StaticBackupRequest",
    "StaticBackupResponse",
    "SwapInfo",
    "Symbol",
    "TlvEntry",
    "UnspentTransactionOutput",
    "UrlSuccessActionData",
    "connect",
    "default_config",
    "mnemonic_to_seed",
    "parse_input",
    "parse_invoice",
    "service_health_check",
    "set_log_stream",
    "static_backup",
    "BlockingBreezServices",
    "EventListener",
    "LogStream",
]

